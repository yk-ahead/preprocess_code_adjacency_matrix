public static double log 10 ( double val ) { if ( val > NUM_ ) return Math . log 10 ( val ) ; return HUGE NEGATIVE ; }
@ Override public Request < List < Builder Status > > builds ( Project Reference project Reference ) { List < Dummy Builder Status > current = current Builder Statuses . get ( project Reference . name ( ) ) ; List < Builder Status > update = new Array List < > ( ) ; if ( current != null ) { for ( Dummy Builder Status dummy Builder Status : current ) { update . add ( dummy Builder Status ) ; } } return new Dummy Request < > ( update ) ; }
public static void draw Circled Text ( Graphics 2 D g , Font font , String text , int x , int y ) { Graphics 2 D g 2 = ( Graphics 2 D ) g . create ( ) ; g 2 . set Font ( font ) ; Font Metrics fm = g 2 . get Font Metrics ( ) ; int padding = NUM_ ; Rectangle 2 D bounds = fm . get String Bounds ( text , g 2 ) ; double th = bounds . get Height ( ) ; double tw = bounds . get Width ( ) ; float radius = ( float ) ( Math . max ( th , tw ) / NUM_ + padding ) ; Ellipse 2 D . Float circle = new Ellipse 2 D . Float ( x - radius , y - radius , NUM_ * radius + NUM_ , NUM_ * radius + NUM_ ) ; g 2 . fill ( circle ) ; g 2 . set Color ( Color . BLACK ) ; g 2 . draw String ( text , ( int ) ( x - tw / NUM_ ) , ( y + fm . get Ascent ( ) / NUM_ ) ) ; if ( DEBUG ) { g 2 . set Color ( Color . RED ) ; g 2 . draw Line ( x - NUM_ , y , x + NUM_ , y ) ; g 2 . draw Line ( x , y - NUM_ , x , y + NUM_ ) ; } g 2 . dispose ( ) ; }
public static Binary Field Accessor create ( Field field , int id ) { Binary Write Mode mode = Binary Utils . mode ( field . get Type ( ) ) ; switch ( mode ) { case P BYTE : return new Byte Primitive Accessor ( field , id ) ; case P BOOLEAN : return new Boolean Primitive Accessor ( field , id ) ; case P SHORT : return new Short Primitive Accessor ( field , id ) ; case P CHAR : return new Char Primitive Accessor ( field , id ) ; case P INT : return new Int Primitive Accessor ( field , id ) ; case P LONG : return new Long Primitive Accessor ( field , id ) ; case P FLOAT : return new Float Primitive Accessor ( field , id ) ; case P DOUBLE : return new Double Primitive Accessor ( field , id ) ; case BYTE : case BOOLEAN : case SHORT : case CHAR : case INT : case LONG : case FLOAT : case DOUBLE : case DECIMAL : case STRING : case UUID : case DATE : case TIMESTAMP : case BYTE ARR : case SHORT ARR : case INT ARR : case LONG ARR : case FLOAT ARR : case DOUBLE ARR : case CHAR ARR : case BOOLEAN ARR : case DECIMAL ARR : case STRING ARR : case UUID ARR : case DATE ARR : case TIMESTAMP ARR : case ENUM ARR : case OBJECT ARR : case BINARY OBJ : case BINARY : return new Default Final Class Accessor ( field , id , mode , false ) ; default : return new Default Final Class Accessor ( field , id , mode , ! U . is Final ( field . get Type ( ) ) ) ; } }
public boolean is Banned Method ( String sig ) { return banned methods . contains ( sig ) ; }
private float interpolate ( ) { long curr Time = System . current Time Millis ( ) ; float elapsed = ( curr Time - start Time ) / ZOOM TIME ; elapsed = Math . min ( NUM_ , elapsed ) ; return interpolator . get Interpolation ( elapsed ) ; }
public void update League History ( ) { Collections . sort ( team List , new Team Comp Poll ( ) ) ; String [ ] year Top 10 = new String [ NUM_ ] ; Team tt ; for ( int i = NUM_ ; i < NUM_ ; ++ i ) { tt = team List . get ( i ) ; year Top 10 [ i ] = tt . abbr + STR_ + tt . wins + STR_ + tt . losses + STR_ ; } league History . add ( year Top 10 ) ; }
public Suffix File Filter ( String [ ] suffixes , IO Case case Sensitivity ) { if ( suffixes == null ) { throw new Illegal Argument Exception ( STR_ ) ; } this . suffixes = new String [ suffixes . length ] ; System . arraycopy ( suffixes , NUM_ , this . suffixes , NUM_ , suffixes . length ) ; this . case Sensitivity = case Sensitivity == null ? IO Case . SENSITIVE : case Sensitivity ; }
public static Bytes To Name Canonicalizer create Root ( ) { long now = System . current Time Millis ( ) ; int seed = ( ( ( int ) now ) + ( ( int ) now > > > NUM_ ) ) | NUM_ ; return create Root ( seed ) ; }
public static void add Startup Listener ( Start Up Listener s ) { s startup Listeners . add ( s ) ; }
@ Transactional public void save ( final List < Work Flow Matrix > actual Work Flow Matrix Details , final String [ ] departments ) { for ( final String dept : departments ) { for ( final Work Flow Matrix work Flow Matrix : actual Work Flow Matrix Details ) { final Work Flow Matrix wf Obj = work Flow Matrix . clone ( ) ; if ( dept . equals ( DEFAULT ) ) { wf Obj . set Department ( STR_ ) ; } else { wf Obj . set Department ( dept ) ; } workflow Matrix Repository . save ( wf Obj ) ; } } }
@ Override void to XML ( String Builder xml , int level ) { indent ( xml , level ) ; xml . append ( STR_ ) ; for ( int i = NUM_ ; i < bytes . length ; i ++ ) { byte b = bytes [ i ] ; if ( b < NUM_ ) xml . append ( STR_ ) ; xml . append ( Integer . to Hex String ( b ) ) ; } xml . append ( STR_ ) ; }
public static int hash Object ( Object o ) { return o == null ? NUM_ : o . hash Code ( ) ; }
private void put With Validation ( String key , Object value ) throws Bitcoin URI Parse Exception { if ( parameter Map . contains Key ( key ) ) { throw new Bitcoin URI Parse Exception ( String . format ( Locale . US , STR_ , key ) ) ; } else { parameter Map . put ( key , value ) ; } }
public void close ( ) { if ( null != input Stream Reader ) { Carbon Util . close Streams ( input Stream Reader ) ; } }
public synchronized void add Action Listener ( Action Listener action Listener ) { if ( action Listeners == null ) action Listeners = new Array List < Action Listener > ( ) ; action Listeners . add ( action Listener ) ; if ( fired ) { action Listener . action Performed ( new Action Event ( this , Action Event . ACTION PERFORMED , STR_ ) ) ; } }
public void replace ( String param , String value ) { int [ ] range ; while ( ( range = find Template ( param ) ) != null ) buff . replace ( range [ NUM_ ] , range [ NUM_ ] , value ) ; }
private void update Progress ( String progress Label , int progress ) { if ( my Host != null && ( ( progress != previous Progress ) || ( ! progress Label . equals ( previous Progress Label ) ) ) ) { my Host . update Progress ( progress Label , progress ) ; } previous Progress = progress ; previous Progress Label = progress Label ; }
public XML Parser ( final String namespace , final String schema ) throws XML Exception { try { JAXB Context jc = JAXB Context . new Instance ( namespace ) ; marshaller = jc . create Marshaller ( ) ; marshaller . set Schema ( XML Schema Utils . create Schema ( schema ) ) ; unmarshaller = jc . create Unmarshaller ( ) ; unmarshaller . set Schema ( XML Schema Utils . create Schema ( schema ) ) ; } catch ( JAXB Exception e ) { throw new XML Exception ( STR_ + namespace , e ) ; } }
@ Suppress Warnings ( STR_ ) public void query For Dump ( String cf Name , String file Name , String [ ] ids ) throws Exception { final Class clazz = get Class From CF Name ( cf Name ) ; if ( clazz == null ) { return ; } init Dump Xml File ( cf Name ) ; for ( String id : ids ) { query And Print Record ( URI . create ( id ) , clazz , Db Cli Operation . DUMP ) ; } write To Xml File ( file Name ) ; }
@ GET @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Path ( STR_ ) @ Deprecated public Host List list Hosts ( @ Path Param ( STR_ ) URI id ) throws Database Exception { get Tenant By Id ( id , false ) ; verify Authorized In Tenant Org ( id , get User From Context ( ) ) ; Host List list = new Host List ( ) ; list . set Hosts ( map ( Resource Type Enum . HOST , list Children ( id , Host . class , STR_ , STR_ ) ) ) ; return list ; }
private void correct Changed ( ) { clock . set Correct Hardware ( correct Check Box . is Selected ( ) , true ) ; changed = true ; }
private static boolean is Non Left ( int i 0 , int i 1 , int i 2 , int i 3 , double [ ] pts ) { double l 1 , l 2 , l 4 , l 5 , l 6 , angle 1 , angle 2 , angle ; l 1 = Math . sqrt ( Math . pow ( pts [ i 2 + NUM_ ] - pts [ i 1 + NUM_ ] , NUM_ ) + Math . pow ( pts [ i 2 ] - pts [ i 1 ] , NUM_ ) ) ; l 2 = Math . sqrt ( Math . pow ( pts [ i 3 + NUM_ ] - pts [ i 2 + NUM_ ] , NUM_ ) + Math . pow ( pts [ i 3 ] - pts [ i 2 ] , NUM_ ) ) ; l 4 = Math . sqrt ( Math . pow ( pts [ i 3 + NUM_ ] - pts [ i 0 + NUM_ ] , NUM_ ) + Math . pow ( pts [ i 3 ] - pts [ i 0 ] , NUM_ ) ) ; l 5 = Math . sqrt ( Math . pow ( pts [ i 1 + NUM_ ] - pts [ i 0 + NUM_ ] , NUM_ ) + Math . pow ( pts [ i 1 ] - pts [ i 0 ] , NUM_ ) ) ; l 6 = Math . sqrt ( Math . pow ( pts [ i 2 + NUM_ ] - pts [ i 0 + NUM_ ] , NUM_ ) + Math . pow ( pts [ i 2 ] - pts [ i 0 ] , NUM_ ) ) ; angle 1 = Math . acos ( ( ( l 2 * l 2 ) + ( l 6 * l 6 ) - ( l 4 * l 4 ) ) / ( NUM_ * l 2 * l 6 ) ) ; angle 2 = Math . acos ( ( ( l 6 * l 6 ) + ( l 1 * l 1 ) - ( l 5 * l 5 ) ) / ( NUM_ * l 6 * l 1 ) ) ; angle = ( Math . PI - angle 1 ) - angle 2 ; if ( angle <= NUM_ ) { return ( true ) ; } else { return ( false ) ; } }
public static Pc Runner serializable Instance ( ) { return Pc Runner . serializable Instance ( ) ; }
void save To Stream ( Data Output Stream out ) throws IO Exception { out . write UTF ( m Url ) ; out . write UTF ( m Name ) ; out . write UTF ( m Value ) ; out . write UTF ( m Domain ) ; out . write UTF ( m Path ) ; out . write Long ( m Creation ) ; out . write Long ( m Expiration ) ; out . write Long ( m Last Access ) ; out . write Boolean ( m Secure ) ; out . write Boolean ( m Http Only ) ; out . write Boolean ( m First Party Only ) ; out . write Int ( m Priority ) ; }
public static int read Int ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Object . get Int ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } int value = NUM_ ; if ( ! json Object . is Null ( key ) ) { value = json Object . get Int ( key ) ; } return value ; }
public static String encode ECC 200 ( String codewords , Symbol Info symbol Info ) { if ( codewords . length ( ) != symbol Info . get Data Capacity ( ) ) { throw new Illegal Argument Exception ( STR_ ) ; } String Builder sb = new String Builder ( symbol Info . get Data Capacity ( ) + symbol Info . get Error Codewords ( ) ) ; sb . append ( codewords ) ; int block Count = symbol Info . get Interleaved Block Count ( ) ; if ( block Count == NUM_ ) { String ecc = create ECC Block ( codewords , symbol Info . get Error Codewords ( ) ) ; sb . append ( ecc ) ; } else { sb . set Length ( sb . capacity ( ) ) ; int [ ] data Sizes = new int [ block Count ] ; int [ ] error Sizes = new int [ block Count ] ; int [ ] start Pos = new int [ block Count ] ; for ( int i = NUM_ ; i < block Count ; i ++ ) { data Sizes [ i ] = symbol Info . get Data Length For Interleaved Block ( i + NUM_ ) ; error Sizes [ i ] = symbol Info . get Error Length For Interleaved Block ( i + NUM_ ) ; start Pos [ i ] = NUM_ ; if ( i > NUM_ ) { start Pos [ i ] = start Pos [ i - NUM_ ] + data Sizes [ i ] ; } } for ( int block = NUM_ ; block < block Count ; block ++ ) { String Builder temp = new String Builder ( data Sizes [ block ] ) ; for ( int d = block ; d < symbol Info . get Data Capacity ( ) ; d += block Count ) { temp . append ( codewords . char At ( d ) ) ; } String ecc = create ECC Block ( temp . to String ( ) , error Sizes [ block ] ) ; int pos = NUM_ ; for ( int e = block ; e < error Sizes [ block ] * block Count ; e += block Count ) { sb . set Char At ( symbol Info . get Data Capacity ( ) + e , ecc . char At ( pos ++ ) ) ; } } } return sb . to String ( ) ; }
public static void main ( String [ ] args ) { Log . print Line ( STR_ ) ; try { int num user = NUM_ ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = false ; Cloud Sim . init ( num user , calendar , trace flag ) ; Datacenter datacenter 0 = create Datacenter ( STR_ ) ; Datacenter datacenter 1 = create Datacenter ( STR_ ) ; Datacenter Broker broker = create Broker ( ) ; int broker Id = broker . get Id ( ) ; vmlist = new Array List < Vm > ( ) ; int vmid = NUM_ ; int mips = NUM_ ; long size = NUM_ ; int ram = NUM_ ; long bw = NUM_ ; int pes Number = NUM_ ; String vmm = STR_ ; Vm vm 1 = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmid ++ ; Vm vm 2 = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmlist . add ( vm 1 ) ; vmlist . add ( vm 2 ) ; broker . submit Vm List ( vmlist ) ; cloudlet List = new Array List < Cloudlet > ( ) ; int id = NUM_ ; long length = NUM_ ; long file Size = NUM_ ; long output Size = NUM_ ; Utilization Model utilization Model = new Utilization Model Full ( ) ; Cloudlet cloudlet 1 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 1 . set User Id ( broker Id ) ; id ++ ; Cloudlet cloudlet 2 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 2 . set User Id ( broker Id ) ; cloudlet List . add ( cloudlet 1 ) ; cloudlet List . add ( cloudlet 2 ) ; broker . submit Cloudlet List ( cloudlet List ) ; broker . bind Cloudlet To Vm ( cloudlet 1 . get Cloudlet Id ( ) , vm 1 . get Id ( ) ) ; broker . bind Cloudlet To Vm ( cloudlet 2 . get Cloudlet Id ( ) , vm 2 . get Id ( ) ) ; Network Topology . build Network Topology ( STR_ ) ; int brite Node = NUM_ ; Network Topology . map Node ( datacenter 0 . get Id ( ) , brite Node ) ; brite Node = NUM_ ; Network Topology . map Node ( datacenter 1 . get Id ( ) , brite Node ) ; brite Node = NUM_ ; Network Topology . map Node ( broker . get Id ( ) , brite Node ) ; Cloud Sim . start Simulation ( ) ; List < Cloudlet > new List = broker . get Cloudlet Received List ( ) ; Cloud Sim . stop Simulation ( ) ; print Cloudlet List ( new List ) ; Log . print Line ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STR_ ) ; } }
public static void over Scroll By ( final Pull To Refresh Base < ? > view , final int delta X , final int scroll X , final int delta Y , final int scroll Y , final int scroll Range , final int fuzzy Threshold , final float scale Factor , final boolean is Touch Event ) { final int delta Value , current Scroll Value , scroll Value ; switch ( view . get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : delta Value = delta X ; scroll Value = scroll X ; current Scroll Value = view . get Scroll X ( ) ; break ; case VERTICAL : default : delta Value = delta Y ; scroll Value = scroll Y ; current Scroll Value = view . get Scroll Y ( ) ; break ; } if ( view . is Pull To Refresh Over Scroll Enabled ( ) && ! view . is Refreshing ( ) ) { final Mode mode = view . get Mode ( ) ; if ( mode . permits Pull To Refresh ( ) && ! is Touch Event && delta Value != NUM_ ) { final int new Scroll Value = ( delta Value + scroll Value ) ; if ( Pull To Refresh Base . DEBUG ) { Log . d ( LOG TAG , STR_ + delta X + STR_ + scroll X + STR_ + delta Y + STR_ + scroll Y + STR_ + new Scroll Value + STR_ + scroll Range + STR_ + current Scroll Value ) ; } if ( new Scroll Value < ( NUM_ - fuzzy Threshold ) ) { if ( mode . show Header Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value ) ) ) ; } } else if ( new Scroll Value > ( scroll Range + fuzzy Threshold ) ) { if ( mode . show Footer Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value - scroll Range ) ) ) ; } } else if ( Math . abs ( new Scroll Value ) <= fuzzy Threshold || Math . abs ( new Scroll Value - scroll Range ) <= fuzzy Threshold ) { view . set State ( State . RESET ) ; } } else if ( is Touch Event && State . OVERSCROLLING == view . get State ( ) ) { view . set State ( State . RESET ) ; } } }
public static boolean is Array ( Element array E ) { String name = array E . get Tag Name ( ) ; if ( name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || is Sparse Array ( array E ) ) { return true ; } return false ; }
void save Offset In External Store ( String topic , int partition , long offset ) { try { File Writer writer = new File Writer ( storage Name ( topic , partition ) , false ) ; Buffered Writer buffered Writer = new Buffered Writer ( writer ) ; buffered Writer . write ( offset + STR_ ) ; buffered Writer . flush ( ) ; buffered Writer . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( e ) ; } }
protected void draw With Offset ( float zone , int points Right , int points Left , float fixed Points , Canvas canvas , Paint paint ) { int position = get Position For Zone ( zone ) ; int first Position = ( int ) ( position - points Left - fixed Points ) ; int last Position = ( int ) ( position + points Right + fixed Points ) ; if ( last Position > points Number - NUM_ && last Position != points Number ) { int offset = last Position - points Number - NUM_ ; float [ ] points F = get Array Float ( points . sub List ( NUM_ , offset ) ) ; last Position = points Number - NUM_ ; canvas . draw Points ( points F , paint ) ; } if ( first Position < NUM_ ) { int offset = Math . abs ( first Position ) ; float [ ] points F = get Array Float ( points . sub List ( ( points Number - NUM_ ) - offset , points Number - NUM_ ) ) ; canvas . draw Points ( points F , paint ) ; first Position = NUM_ ; } float [ ] points F = get Array Float ( points . sub List ( first Position , last Position ) ) ; canvas . draw Points ( points F , paint ) ; }
public Executor env ( Map < String , String > env ) { this . env = env ; return this ; }
protected void init View ( ) { m Month Title Paint = new Paint ( ) ; m Month Title Paint . set Fake Bold Text ( true ) ; m Month Title Paint . set Anti Alias ( true ) ; m Month Title Paint . set Text Size ( MONTH LABEL TEXT SIZE ) ; m Month Title Paint . set Typeface ( Typeface . create ( m Month Title Typeface , Typeface . BOLD ) ) ; m Month Title Paint . set Color ( m Day Text Color ) ; m Month Title Paint . set Text Align ( Align . CENTER ) ; m Month Title Paint . set Style ( Style . FILL ) ; m Month Title BG Paint = new Paint ( ) ; m Month Title BG Paint . set Fake Bold Text ( true ) ; m Month Title BG Paint . set Anti Alias ( true ) ; m Month Title BG Paint . set Color ( m Month Title BG Color ) ; m Month Title BG Paint . set Text Align ( Align . CENTER ) ; m Month Title BG Paint . set Style ( Style . FILL ) ; m Selected Circle Paint = new Paint ( ) ; m Selected Circle Paint . set Fake Bold Text ( true ) ; m Selected Circle Paint . set Anti Alias ( true ) ; m Selected Circle Paint . set Color ( m Today Number Color ) ; m Selected Circle Paint . set Text Align ( Align . CENTER ) ; m Selected Circle Paint . set Style ( Style . FILL ) ; m Selected Circle Paint . set Alpha ( SELECTED CIRCLE ALPHA ) ; m Month Day Label Paint = new Paint ( ) ; m Month Day Label Paint . set Anti Alias ( true ) ; m Month Day Label Paint . set Text Size ( MONTH DAY LABEL TEXT SIZE ) ; m Month Day Label Paint . set Color ( m Day Text Color ) ; m Month Day Label Paint . set Typeface ( Typeface . create ( m Day Of Week Typeface , Typeface . NORMAL ) ) ; m Month Day Label Paint . set Style ( Style . FILL ) ; m Month Day Label Paint . set Text Align ( Align . CENTER ) ; m Month Day Label Paint . set Fake Bold Text ( true ) ; m Month Num Paint = new Paint ( ) ; m Month Num Paint . set Anti Alias ( true ) ; m Month Num Paint . set Text Size ( MINI DAY NUMBER TEXT SIZE ) ; m Month Num Paint . set Style ( Style . FILL ) ; m Month Num Paint . set Text Align ( Align . CENTER ) ; m Month Num Paint . set Fake Bold Text ( false ) ; m Circle Indicator Paint = new Paint ( ) ; m Circle Indicator Paint . set Anti Alias ( true ) ; m Circle Indicator Paint . set Style ( Style . FILL ) ; m Circle Indicator Paint . set Color ( m Day Text Color ) ; }
private void fit Image To View ( ) { Drawable drawable = get Drawable ( ) ; if ( drawable == null || drawable . get Intrinsic Width ( ) == NUM_ || drawable . get Intrinsic Height ( ) == NUM_ ) { return ; } if ( matrix == null || prev Matrix == null ) { return ; } int drawable Width = drawable . get Intrinsic Width ( ) ; int drawable Height = drawable . get Intrinsic Height ( ) ; float scale X = ( float ) view Width / drawable Width ; float scale Y = ( float ) view Height / drawable Height ; switch ( m Scale Type ) { case CENTER : scale X = scale Y = NUM_ ; break ; case CENTER CROP : scale X = scale Y = Math . max ( scale X , scale Y ) ; break ; case CENTER INSIDE : scale X = scale Y = Math . min ( NUM_ , Math . min ( scale X , scale Y ) ) ; case FIT CENTER : scale X = scale Y = Math . min ( scale X , scale Y ) ; break ; case FIT XY : break ; default : throw new Unsupported Operation Exception ( STR_ ) ; } float redundant X Space = view Width - ( scale X * drawable Width ) ; float redundant Y Space = view Height - ( scale Y * drawable Height ) ; match View Width = view Width - redundant X Space ; match View Height = view Height - redundant Y Space ; if ( ! is Zoomed ( ) && ! image Rendered At Least Once ) { matrix . set Scale ( scale X , scale Y ) ; matrix . post Translate ( redundant X Space / NUM_ , redundant Y Space / NUM_ ) ; normalized Scale = NUM_ ; } else { if ( prev Match View Width == NUM_ || prev Match View Height == NUM_ ) { save Previous Image Values ( ) ; } prev Matrix . get Values ( m ) ; m [ Matrix . MSCALE X ] = match View Width / drawable Width * normalized Scale ; m [ Matrix . MSCALE Y ] = match View Height / drawable Height * normalized Scale ; float trans X = m [ Matrix . MTRANS X ] ; float trans Y = m [ Matrix . MTRANS Y ] ; float prev Actual Width = prev Match View Width * normalized Scale ; float actual Width = get Image Width ( ) ; translate Matrix After Rotate ( Matrix . MTRANS X , trans X , prev Actual Width , actual Width , prev View Width , view Width , drawable Width ) ; float prev Actual Height = prev Match View Height * normalized Scale ; float actual Height = get Image Height ( ) ; translate Matrix After Rotate ( Matrix . MTRANS Y , trans Y , prev Actual Height , actual Height , prev View Height , view Height , drawable Height ) ; matrix . set Values ( m ) ; } fix Trans ( ) ; set Image Matrix ( matrix ) ; }
private void finalize Additions ( boolean add Home Screen Shortcuts ) { finalize Work Folder ( ) ; if ( add Home Screen Shortcuts && ! m Homescreen Apps . is Empty ( ) ) { sort List ( m Homescreen Apps ) ; m Model . add And Bind Added Workspace Items ( m Context , m Homescreen Apps ) ; } }
public void update Notification ( int notification Id ) { try { notification DAO . open ( ) ; notification DAO . update Notification ( notification Id , Notification . Status . DISMISSED ) ; } finally { notification DAO . close ( ) ; } }
protected Tams Message poll Message ( ) { if ( disable Poll ) { return null ; } if ( ! poll Queue . is Empty ( ) ) { Poll Message pm = poll Queue . peek ( ) ; if ( pm != null ) { tm = pm . get Message ( ) ; return pm . get Message ( ) ; } } return null ; }
public static void paint Checked Background ( Component c , Graphics g , int x , int y , int width , int height ) { if ( background Image == null ) { background Image = new Buffered Image ( NUM_ , NUM_ , Buffered Image . TYPE INT ARGB ) ; Graphics bg = background Image . create Graphics ( ) ; for ( int by = NUM_ ; by < NUM_ ; by += NUM_ ) { for ( int bx = NUM_ ; bx < NUM_ ; bx += NUM_ ) { bg . set Color ( ( ( bx ^ by ) & NUM_ ) != NUM_ ? Color . light Gray : Color . white ) ; bg . fill Rect ( bx , by , NUM_ , NUM_ ) ; } } bg . dispose ( ) ; } if ( background Image != null ) { Shape save Clip = g . get Clip ( ) ; Rectangle r = g . get Clip Bounds ( ) ; if ( r == null ) r = new Rectangle ( c . get Size ( ) ) ; r = r . intersection ( new Rectangle ( x , y , width , height ) ) ; g . set Clip ( r ) ; int w = background Image . get Width ( ) ; int h = background Image . get Height ( ) ; if ( w != - NUM_ && h != - NUM_ ) { int x 1 = ( r . x / w ) * w ; int y 1 = ( r . y / h ) * h ; int x 2 = ( ( r . x + r . width + w - NUM_ ) / w ) * w ; int y 2 = ( ( r . y + r . height + h - NUM_ ) / h ) * h ; for ( y = y 1 ; y < y 2 ; y += h ) for ( x = x 1 ; x < x 2 ; x += w ) g . draw Image ( background Image , x , y , c ) ; } g . set Clip ( save Clip ) ; } }
private byte [ ] copy Array ( byte [ ] buffer , int length ) { byte [ ] result = new byte [ length ] ; System . arraycopy ( buffer , NUM_ , result , NUM_ , Math . min ( buffer . length , length ) ) ; return result ; }
public Set search 3 ( String token ID , String start DN , String filter , int num Of Entries , int time Limit , boolean sort Results , boolean ascending Order , Set excludes ) throws SMS Exception , SSO Exception , Remote Exception { initialize ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + start DN + STR_ + filter + STR_ + excludes ) ; } Iterator i = SMS Entry . search ( get Token ( token ID ) , start DN , filter , num Of Entries , time Limit , sort Results , ascending Order , excludes ) ; Set < String > result = new Hash Set < String > ( ) ; while ( i . has Next ( ) ) { SMS Data Entry e = ( SMS Data Entry ) i . next ( ) ; try { result . add ( e . to JSON String ( ) ) ; } catch ( JSON Exception ex ) { debug . error ( STR_ + start DN + STR_ + filter + STR_ + excludes , ex ) ; } } return result ; }
public void add Handler ( String column Name , SQL Data Handler handler ) { if ( m overrides == null ) m overrides = new Hash Map ( NUM_ ) ; m overrides . put ( column Name , handler ) ; }
public org . smpte ra . schemas . st 2067 2 2016 . Content Maturity Rating Type build Content Maturity Rating Type ( String agency , String rating , org . smpte ra . schemas . st 2067 2 2016 . Content Maturity Rating Type . Audience audience ) throws URI Syntax Exception { org . smpte ra . schemas . st 2067 2 2016 . Content Maturity Rating Type content Maturity Rating Type = new org . smpte ra . schemas . st 2067 2 2016 . Content Maturity Rating Type ( ) ; if ( ! agency . matches ( STR_ ) == true ) { throw new URI Syntax Exception ( STR_ , STR_ ) ; } content Maturity Rating Type . set Agency ( agency ) ; content Maturity Rating Type . set Rating ( rating ) ; content Maturity Rating Type . set Audience ( audience ) ; return content Maturity Rating Type ; }
public void listen ( Stanza Listener stanza Listener , Stanza Filter stanza Filter ) { connection . add Async Stanza Listener ( stanza Listener , stanza Filter ) ; logger . info ( STR_ ) ; }
private void init ( Configuration exp ) throws IO Exception { is Initialized = true ; }
private void create Record Holder Queue ( File [ ] list Files ) { this . record Holder Heap = new Priority Queue < Sort Temp File Chunk Holder > ( list Files . length ) ; }
public boolean should Data Be Routed ( Simple Router Context context , Data Meta Data data Meta Data , Node node , boolean initial Load , boolean initial Load Select Used , Trigger Router trigger Router ) { I Data Router router = get Data Router ( data Meta Data . get Router ( ) ) ; Set < Node > one Node Set = new Hash Set < Node > ( NUM_ ) ; one Node Set . add ( node ) ; Collection < String > node Ids = router . route To Nodes ( context , data Meta Data , one Node Set , initial Load , initial Load Select Used , trigger Router ) ; return node Ids != null && node Ids . contains ( node . get Node Id ( ) ) ; }
private static boolean member Equals ( final Class < ? > type , final Object o 1 , final Object o 2 ) { if ( o 1 == o 2 ) { return true ; } if ( o 1 == null || o 2 == null ) { return false ; } if ( type . is Array ( ) ) { return array Member Equals ( type . get Component Type ( ) , o 1 , o 2 ) ; } if ( type . is Annotation ( ) ) { return equals ( ( Annotation ) o 1 , ( Annotation ) o 2 ) ; } return o 1 . equals ( o 2 ) ; }
@ Api Operation ( value = STR_ ) @ Request Mapping ( value = STR_ , method = Request Method . POST ) @ Response Status ( Http Status . NO CONTENT ) @ Response Body public final void post Uninstall ( ) { uninstall Impl ( get Symmetric Engine ( ) ) ; }
public Date Time Zone Builder add Cutover ( int year , char mode , int month Of Year , int day Of Month , int day Of Week , boolean advance Day Of Week , int millis Of Day ) { if ( i Rule Sets . size ( ) > NUM_ ) { Of Year of Year = new Of Year ( mode , month Of Year , day Of Month , day Of Week , advance Day Of Week , millis Of Day ) ; Rule Set last Rule Set = i Rule Sets . get ( i Rule Sets . size ( ) - NUM_ ) ; last Rule Set . set Upper Limit ( year , of Year ) ; } i Rule Sets . add ( new Rule Set ( ) ) ; return this ; }
public static Node select Single Node ( Node context Node , String str , Node namespace Node ) throws Transformer Exception { Node Iterator nl = select Node Iterator ( context Node , str , namespace Node ) ; return nl . next Node ( ) ; }
public static boolean is Viewable Value ( Object value ) { if ( value instanceof Composite Data || value instanceof Tabular Data ) { return true ; } if ( value instanceof Composite Data [ ] || value instanceof Tabular Data [ ] ) { return Array . get Length ( value ) > NUM_ ; } if ( value instanceof Collection ) { Collection < ? > c = ( Collection < ? > ) value ; if ( c . is Empty ( ) ) { return false ; } else { return Utils . is Uniform Collection ( c , Composite Data . class ) || Utils . is Uniform Collection ( c , Tabular Data . class ) ; } } return false ; }
public void disconnect ( ) { connected = false ; synchronized ( conn Lost Wait ) { conn Lost Wait . notify ( ) ; } if ( mqtt != null ) { try { mqtt . disconnect ( ) ; } catch ( Exception ex ) { set Title Text ( STR_ ) ; ex . print Stack Trace ( ) ; System . exit ( NUM_ ) ; } } if ( led . is Flashing ( ) ) { led . set Flash ( ) ; } led . set Red ( ) ; set Connected ( false ) ; synchronized ( this ) { write Logln ( STR_ ) ; } }
public Wildcard File Filter ( String [ ] wildcards , IO Case case Sensitivity ) { if ( wildcards == null ) { throw new Illegal Argument Exception ( STR_ ) ; } this . wildcards = new String [ wildcards . length ] ; System . arraycopy ( wildcards , NUM_ , this . wildcards , NUM_ , wildcards . length ) ; this . case Sensitivity = case Sensitivity == null ? IO Case . SENSITIVE : case Sensitivity ; }
public Future < Void > update Table Entity Async ( Table Entity table Entity , boolean commit ) { update Table Entity ( table Entity , commit ) ; return new Async Result < Void > ( null ) ; }
private boolean process Single Event ( ) { if ( event Buffer . remaining ( ) < NUM_ ) { return false ; } try { event Buffer . get Int ( ) ; final int buffer Length = event Buffer . get Int ( ) ; final int padding = ( NUM_ - buffer Length ) & NUM_ ; if ( event Buffer . remaining ( ) < buffer Length + padding + NUM_ ) return false ; final byte [ ] buffer = new byte [ buffer Length ] ; event Buffer . get ( buffer ) ; event Buffer . position ( event Buffer . position ( ) + padding ) ; int event Count = NUM_ ; if ( buffer Length > NUM_ ) { event Count = isc Vax Integer ( buffer , buffer Length - NUM_ , NUM_ ) ; } event Buffer . get Long ( ) ; int event Id = event Buffer . get Int ( ) ; log . debug ( String . format ( STR_ , event Id , event Count ) ) ; channel Listener Dispatcher . event Received ( this , new Asynchronous Channel Listener . Event ( event Id , event Count ) ) ; return true ; } catch ( Buffer Underflow Exception ex ) { return false ; } }
public static int int Hash ( String ip String ) { int val = NUM_ ; String [ ] strs = ip String . split ( STR_ ) ; int len = strs . length ; if ( len >= NUM_ ) { val = int Val ( strs [ NUM_ ] ) ; val <<= NUM_ ; val |= int Val ( strs [ NUM_ ] ) ; val <<= NUM_ ; val |= int Val ( strs [ NUM_ ] ) ; val <<= NUM_ ; val |= int Val ( strs [ NUM_ ] ) ; } return val ; }
public Fluent Jdbc Builder connection Provider ( Connection Provider connection Provider ) { check Not Null ( connection Provider , STR_ ) ; this . connection Provider = Optional . of ( connection Provider ) ; return this ; }
private static int uarimax Gt ( double value , double [ ] bv , int bvi [ ] , Binary Operator b Op ) throws DML Runtime Exception { int ix Max = bv . length ; if ( value <= bv [ NUM_ ] || value > bv [ bv . length - NUM_ ] ) return ix Max ; int ix = Arrays . binary Search ( bv , value ) ; ix = Math . abs ( ix ) - NUM_ ; ix Max = bvi [ ix - NUM_ ] + NUM_ ; return ix Max ; }
private void persist Volume Native ID ( Db Client db Client , URI volume Id , String native ID , Calendar creation Time ) throws IO Exception { Volume volume = db Client . query Object ( Volume . class , volume Id ) ; volume . set Creation Time ( creation Time ) ; volume . set Native Id ( native ID ) ; volume . set Native Guid ( Native GUID Generator . generate Native Guid ( db Client , volume ) ) ; db Client . update Object ( volume ) ; }
public static Map < String , List < Data File Footer > > create Data File Footer Mapping For Segments ( List < Table Block Info > table Block Info List ) throws Index Builder Exception { Map < String , List < Data File Footer > > segment Block Info Mapping = new Hash Map < > ( ) ; for ( Table Block Info block Info : table Block Info List ) { List < Data File Footer > each Segment Blocks = new Array List < > ( ) ; String seg Id = block Info . get Segment Id ( ) ; Data File Footer data File Matadata = null ; List < Data File Footer > metadata List = segment Block Info Mapping . get ( seg Id ) ; try { data File Matadata = Carbon Util . read Metadat File ( block Info . get File Path ( ) , block Info . get Block Offset ( ) , block Info . get Block Length ( ) ) ; } catch ( Carbon Util Exception e ) { throw new Index Builder Exception ( e ) ; } if ( null == metadata List ) { each Segment Blocks . add ( data File Matadata ) ; segment Block Info Mapping . put ( seg Id , each Segment Blocks ) ; } else { metadata List . add ( data File Matadata ) ; } } return segment Block Info Mapping ; }
static Array List < String > load Image ( File file ) throws File Not Found Exception , Runtime Exception { if ( file == null ) return null ; Scanner sc ; sc = new Scanner ( file ) ; Array List < String > rows = new Array List < String > ( ) ; String s = sc . next Line ( ) ; int len = s . length ( ) ; int idx = NUM_ ; rows . add ( s ) ; while ( sc . has Next ( ) ) { idx ++ ; s = sc . next Line ( ) ; if ( s . length ( ) != len ) { sc . close ( ) ; throw new Runtime Exception ( STR_ + idx + STR_ + s . length ( ) + STR_ + len + STR_ ) ; } rows . add ( s ) ; } sc . close ( ) ; return rows ; }
public boolean check Arguments ( List arguments ) { boolean valid Args = true ; if ( arguments != null && arguments . size ( ) > NUM_ ) { String specified Args = format Args ( arguments ) ; Debug . log ( STR_ + specified Args ) ; print Console Message ( LOC HR MSG INVALID OPTION , new Object [ ] { specified Args } ) ; valid Args = false ; } return valid Args ; }
public static Internal Distributed Member read Essential Data ( Data Input in ) throws IO Exception , Class Not Found Exception { final Internal Distributed Member mbr = new Internal Distributed Member ( ) ; mbr . read Essential Data ( in ) ; return mbr ; }
public boolean fill If Live ( long timeout ) throws IO Exception { Stream Impl source = source ; byte [ ] read Buffer = read Buffer ; if ( read Buffer == null || source == null ) { read Offset = NUM_ ; read Length = NUM_ ; return false ; } if ( read Offset > NUM_ ) { System . arraycopy ( read Buffer , read Offset , read Buffer , NUM_ , read Length - read Offset ) ; read Length -= read Offset ; read Offset = NUM_ ; } if ( read Length == read Buffer . length ) return true ; int read Length = source . read Timeout ( read Buffer , read Length , read Buffer . length - read Length , timeout ) ; if ( read Length >= NUM_ ) { read Length += read Length ; position += read Length ; if ( is Enable Read Time ) read Time = Current Time . current Time ( ) ; return true ; } else if ( read Length == READ TIMEOUT ) { return true ; } else { return false ; } }
public void notify Query Running ( final Bound Entity song ) { synchronized ( m Running Queries ) { m Running Queries . add ( song ) ; } }
private static Properties create Properties 1 ( ) { Properties props = new Properties ( ) ; props . set Property ( MCAST PORT , STR_ ) ; props . set Property ( LOCATORS , STR_ ) ; return props ; }
public final String translate ( final Char Sequence input ) { if ( input == null ) { return null ; } try { final String Writer writer = new String Writer ( input . length ( ) * NUM_ ) ; translate ( input , writer ) ; return writer . to String ( ) ; } catch ( final IO Exception ioe ) { throw new Runtime Exception ( ioe ) ; } }
public Config load Installed Codenvy Config ( Install Type install Type ) throws IO Exception { Map < String , String > properties = load Installed Codenvy Properties ( install Type ) ; return new Config ( properties ) ; }
protected int index First Of ( final String s , final String delims , int offset ) { if ( s == null || s . length ( ) == NUM_ ) { return - NUM_ ; } if ( delims == null || delims . length ( ) == NUM_ ) { return - NUM_ ; } if ( offset < NUM_ ) { offset = NUM_ ; } else if ( offset > s . length ( ) ) { return - NUM_ ; } int min = s . length ( ) ; final char [ ] delim = delims . to Char Array ( ) ; for ( int i = NUM_ ; i < delim . length ; i ++ ) { final int at = s . index Of ( delim [ i ] , offset ) ; if ( at >= NUM_ && at < min ) { min = at ; } } return ( min == s . length ( ) ) ? - NUM_ : min ; }
private void write Attribute ( java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( namespace . equals ( STR_ ) ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { register Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
private static String [ ] process Object Classes ( final String object Class ) { String [ ] object Classes = null ; if ( object Class != null ) { object Classes = object Class . split ( STR_ ) ; } if ( object Classes != null ) { String obj Class = null ; for ( int i = NUM_ ; i < object Classes . length ; i ++ ) { obj Class = object Classes [ i ] ; if ( obj Class != null ) { object Classes [ i ] = obj Class . trim ( ) ; } } } return object Classes ; }
protected Abstract Simplex ( final double [ ] steps ) { if ( steps == null ) { throw new Null Argument Exception ( ) ; } if ( steps . length == NUM_ ) { throw new Math Illegal Argument Exception ( Localized Core Formats . ZERO NOT ALLOWED ) ; } dimension = steps . length ; start Configuration = new double [ dimension ] [ dimension ] ; for ( int i = NUM_ ; i < dimension ; i ++ ) { final double [ ] vertex I = start Configuration [ i ] ; for ( int j = NUM_ ; j < i + NUM_ ; j ++ ) { if ( steps [ j ] == NUM_ ) { throw new Math Illegal Argument Exception ( Localized Optim Formats . EQUAL VERTICES IN SIMPLEX ) ; } System . arraycopy ( steps , NUM_ , vertex I , NUM_ , j + NUM_ ) ; } } }
protected final void enable Retransmission Timer ( int tick Count ) { if ( is Invite Transaction ( ) && ( this instanceof SIP Client Transaction ) ) { retransmission Timer Ticks Left = tick Count ; } else { retransmission Timer Ticks Left = Math . min ( tick Count , MAXIMUM RETRANSMISSION TICK COUNT ) ; } retransmission Timer Last Tick Count = retransmission Timer Ticks Left ; retransmission Outdated Time = System Clock . elapsed Realtime ( ) + retransmission Timer Ticks Left * BASE TIMER INTERVAL ; }
void tidy ( int window Start Year ) { if ( last Rule List . size ( ) == NUM_ ) { throw new Illegal State Exception ( STR_ ) ; } if ( window End . equals ( Local Date Time . MAX ) ) { max Last Rule Start Year = Math . max ( max Last Rule Start Year , window Start Year ) + NUM_ ; for ( TZ Rule last Rule : last Rule List ) { add Rule ( last Rule . year , max Last Rule Start Year , last Rule . month , last Rule . day Of Month Indicator , last Rule . day Of Week , last Rule . time , last Rule . time End Of Day , last Rule . time Definition , last Rule . saving Amount Secs ) ; last Rule . year = max Last Rule Start Year + NUM_ ; } if ( max Last Rule Start Year == YEAR MAX VALUE ) { last Rule List . clear ( ) ; } else { max Last Rule Start Year ++ ; } } else { int end Year = window End . get Year ( ) ; for ( TZ Rule last Rule : last Rule List ) { add Rule ( last Rule . year , end Year + NUM_ , last Rule . month , last Rule . day Of Month Indicator , last Rule . day Of Week , last Rule . time , last Rule . time End Of Day , last Rule . time Definition , last Rule . saving Amount Secs ) ; } last Rule List . clear ( ) ; max Last Rule Start Year = YEAR MAX VALUE ; } Collections . sort ( rule List ) ; Collections . sort ( last Rule List ) ; if ( rule List . size ( ) == NUM_ && fixed Saving Amount Secs == null ) { fixed Saving Amount Secs = NUM_ ; } }
private int [ ] determine Dimensions ( int source Code Words , int error Correction Code Words ) throws Writer Exception { float ratio = NUM_ ; int [ ] dimension = null ; for ( int cols = min Cols ; cols <= max Cols ; cols ++ ) { int rows = calculate Number Of Rows ( source Code Words , error Correction Code Words , cols ) ; if ( rows < min Rows ) { break ; } if ( rows > max Rows ) { continue ; } float new Ratio = ( ( NUM_ * cols + NUM_ ) * DEFAULT MODULE WIDTH ) / ( rows * HEIGHT ) ; if ( dimension != null && Math . abs ( new Ratio - PREFERRED RATIO ) > Math . abs ( ratio - PREFERRED RATIO ) ) { continue ; } ratio = new Ratio ; dimension = new int [ ] { cols , rows } ; } if ( dimension == null ) { int rows = calculate Number Of Rows ( source Code Words , error Correction Code Words , min Cols ) ; if ( rows < min Rows ) { dimension = new int [ ] { min Cols , min Rows } ; } } if ( dimension == null ) { throw new Writer Exception ( STR_ ) ; } return dimension ; }
private void assert Char Vectors ( int n ) { int k = NUM_ * n + NUM_ ; int limit = ( int ) Math . pow ( NUM_ , k + NUM_ ) ; for ( int i = NUM_ ; i < limit ; i ++ ) { String encoded = Integer . to String ( i , NUM_ ) ; assert Lev ( encoded , n ) ; } }
private void publish Rtf ( Resource resource , Big Decimal version ) throws Publication Exception { if ( is Locked ( resource . get Shortname ( ) ) ) { throw new Publication Exception ( Publication Exception . TYPE . LOCKED , STR_ + resource . get Shortname ( ) + STR_ ) ; } Document doc = new Document ( ) ; File rtf File = data Dir . resource Rtf File ( resource . get Shortname ( ) , version ) ; Output Stream out = null ; try { out = new File Output Stream ( rtf File ) ; Rtf Writer 2 . get Instance ( doc , out ) ; eml 2 Rtf . write Eml Into Rtf ( doc , resource ) ; } catch ( File Not Found Exception e ) { throw new Publication Exception ( Publication Exception . TYPE . RTF , STR_ + rtf File . get Absolute Path ( ) , e ) ; } catch ( Document Exception e ) { throw new Publication Exception ( Publication Exception . TYPE . RTF , STR_ + rtf File . get Absolute Path ( ) , e ) ; } catch ( Exception e ) { throw new Publication Exception ( Publication Exception . TYPE . RTF , STR_ + e . get Message ( ) , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( IO Exception e ) { log . warn ( STR_ ) ; } } } }
private String base phone number ( ) throws Parse Exception { String Builder s = new String Builder ( ) ; if ( debug ) dbg enter ( STR_ ) ; try { int lc = NUM_ ; while ( lexer . has More Chars ( ) ) { char w = lexer . look Ahead ( NUM_ ) ; if ( Lexer . is Digit ( w ) || w == STR_ || w == STR_ || w == STR_ || w == STR_ ) { lexer . consume ( NUM_ ) ; s . append ( w ) ; lc ++ ; } else if ( lc > NUM_ ) break ; else throw create Parse Exception ( STR_ + w ) ; } return s . to String ( ) ; } finally { if ( debug ) dbg leave ( STR_ ) ; } }
public org . smpte ra . schemas . st 2067 2 2016 . Content Version Type build Content Version Type ( String id , org . smpte ra . schemas . st 2067 2 2016 . User Text Type value ) { Content Version Type content Version Type = new Content Version Type ( ) ; content Version Type . set Id ( id ) ; content Version Type . set Label Text ( value ) ; return content Version Type ; }
private static Input Stream open System File ( String filename ) throws File Not Found Exception { try { return new File Input Stream ( filename ) ; } catch ( File Not Found Exception e ) { String resname = filename . replace ( File . separator Char , STR_ ) ; Input Stream result = Class Loader . get System Resource As Stream ( resname ) ; if ( result == null ) { throw e ; } return result ; } }
private boolean condition CH 1 ( String value , int index ) { return ( ( contains ( value , NUM_ , NUM_ , STR_ , STR_ ) || contains ( value , NUM_ , NUM_ , STR_ ) ) || contains ( value , index - NUM_ , NUM_ , STR_ , STR_ , STR_ ) || contains ( value , index + NUM_ , NUM_ , STR_ , STR_ ) || ( ( contains ( value , index - NUM_ , NUM_ , STR_ , STR_ , STR_ , STR_ ) || index == NUM_ ) && ( contains ( value , index + NUM_ , NUM_ , L R N M B H F V W SPACE ) || index + NUM_ == value . length ( ) - NUM_ ) ) ) ; }
private void delete File If Empty ( ) throws IO Exception { if ( Files . size ( preferences File Path ) == NUM_ ) { Files . delete ( preferences File Path ) ; } }
public static int scan ( long v ) { if ( v == NUM_ ) { return - NUM_ ; } return Long . number Of Trailing Zeros ( v ) ; }
public static < T extends Object & Comparable < ? super T > > T min ( Collection < ? extends T > collection ) { Iterator < ? extends T > it = collection . iterator ( ) ; T min = it . next ( ) ; while ( it . has Next ( ) ) { T next = it . next ( ) ; if ( min . compare To ( next ) > NUM_ ) { min = next ; } } return min ; }
private void add URL Token ( String url , String text ) { add Token ( token For Url ( url , text ) ) ; }
public void log And System Out ( String message ) { log And System Out ( message , null ) ; }
private static void attempt Retry On Exception ( String log Prefix , Request < ? > request , Volley Error exception ) throws Volley Error { Retry Policy retry Policy = request . get Retry Policy ( ) ; int old Timeout = request . get Timeout Ms ( ) ; try { retry Policy . retry ( exception ) ; } catch ( Volley Error e ) { request . add Marker ( String . format ( STR_ , log Prefix , old Timeout ) ) ; throw e ; } request . add Marker ( String . format ( STR_ , log Prefix , old Timeout ) ) ; }
private int [ ] parse Months ( String line ) { int [ ] months = new int [ NUM_ ] ; String [ ] numbers = line . split ( STR_ ) ; if ( numbers . length != NUM_ ) { throw new Illegal Argument Exception ( STR_ + Arrays . to String ( numbers ) + STR_ + numbers . length ) ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { try { months [ i ] = Integer . value Of ( numbers [ i ] ) ; } catch ( Number Format Exception nfe ) { throw new Illegal Argument Exception ( STR_ + numbers [ i ] ) ; } } return months ; }
public String generate File Name ( ) { return new Unique Test Id ( ) . id + STR_ + get Current Test Class Name ( ) + STR_ + get Current Test Method Name ( ) + STR_ + get Current Test Method Line Number ( ) ; }
@ Override public int process ( Callback [ ] callbacks , int state ) throws Login Exception { switch ( state ) { case IS Auth Constants . LOGIN START : { set User Session Property ( Jwt Session Module . TOKEN IDLE TIME IN MINUTES CLAIM KEY , token Idle Time . to String ( ) ) ; set User Session Property ( Jwt Session Module . MAX TOKEN LIFE IN MINUTES KEY , max Token Life . to String ( ) ) ; set User Session Property ( ENFORCE CLIENT IP SETTING KEY , Boolean . to String ( enforce Client IP ) ) ; set User Session Property ( SECURE COOKIE KEY , Boolean . to String ( secure Cookie ) ) ; set User Session Property ( HTTP ONLY COOKIE KEY , Boolean . to String ( http Only Cookie ) ) ; if ( cookie Name != null ) { set User Session Property ( COOKIE NAME KEY , cookie Name ) ; } String cookie Domains String = STR_ ; for ( String cookie Domain : cookie Domains ) { cookie Domains String += cookie Domain + STR_ ; } set User Session Property ( COOKIE DOMAINS KEY , cookie Domains String ) ; set User Session Property ( HMAC KEY , encrypted Hmac Key ) ; final Subject client Subject = new Subject ( ) ; Message Info message Info = persistent Cookie Module Wrapper . prepare Message Info ( get Http Servlet Request ( ) , get Http Servlet Response ( ) ) ; if ( process ( message Info , client Subject , callbacks ) ) { if ( principal != null ) { set Authenticating User Name ( principal . get Name ( ) ) ; } return IS Auth Constants . LOGIN SUCCEED ; } throw new Auth Login Exception ( AUTH RESOURCE BUNDLE NAME , STR_ , null ) ; } default : { throw new Auth Login Exception ( AUTH RESOURCE BUNDLE NAME , STR_ , null ) ; } } }
protected static Die die ( String why ) { return new Die ( why ) ; }
private void open Line ( boolean first Entry ) throws IO Exception { if ( first Entry ) { out . append ( STR_ ) ; } }
public static Sparse Int Array adjust Position ( Sparse Int Array positions , int start Position , int end Position , int adjust By ) { Sparse Int Array new Positions = new Sparse Int Array ( ) ; for ( int i = NUM_ , size = positions . size ( ) ; i < size ; i ++ ) { int position = positions . key At ( i ) ; if ( position < start Position || position > end Position ) { new Positions . put ( position , positions . value At ( i ) ) ; } else if ( adjust By > NUM_ ) { new Positions . put ( position + adjust By , positions . value At ( i ) ) ; } else if ( adjust By < NUM_ ) { if ( position > start Position + adjust By && position <= start Position ) { ; } else { new Positions . put ( position + adjust By , positions . value At ( i ) ) ; } } } return new Positions ; }
public Flac Stream Reader ( Random Access File raf ) { this . raf = raf ; }
protected void create Filter Toolbar ( ) { timer = new Timer ( NUM_ , null ) ; timer . set Initial Delay ( NUM_ ) ; timer . set Action Command ( CMD FILTER CHANGED ) ; timer . set Repeats ( false ) ; search Filter = new Search Filter ( ) ; search Filter . set Filter Text ( String Utils . EMPTY ) ; }
public void action Performed ( Action Event e ) { Action Map map = tab Pane . get Action Map ( ) ; if ( map != null ) { String action Key ; if ( e . get Source ( ) == scroll Forward Button ) { action Key = STR_ ; } else { action Key = STR_ ; } Action action = map . get ( action Key ) ; if ( action != null && action . is Enabled ( ) ) { action . action Performed ( new Action Event ( tab Pane , Action Event . ACTION PERFORMED , null , e . get When ( ) , e . get Modifiers ( ) ) ) ; } } }
public static String now ( ) { Calendar cal = Calendar . get Instance ( ) ; Simple Date Format sdf = new Simple Date Format ( DATE FORMAT NOW ) ; return sdf . format ( cal . get Time ( ) ) ; }
public void add Observer ( Observer observer ) { Assert . not Null ( STR_ , observer ) ; observers . add If Absent ( observer ) ; }
private void write Attribute ( java . lang . String prefix , java . lang . String namespace , java . lang . String att Name , java . lang . String att Value , javax . xml . stream . XML Stream Writer xml Writer ) throws javax . xml . stream . XML Stream Exception { if ( xml Writer . get Prefix ( namespace ) == null ) { xml Writer . write Namespace ( prefix , namespace ) ; xml Writer . set Prefix ( prefix , namespace ) ; } xml Writer . write Attribute ( namespace , att Name , att Value ) ; }
public static double [ ] round To Significant Digits ( double x , double y , int n Signif ) { double [ ] rounded = new double [ NUM_ ] ; double diff = Math . abs ( x - y ) ; if ( diff < NUM_ ) { rounded [ NUM_ ] = x ; rounded [ NUM_ ] = y ; return rounded ; } if ( diff > NUM_ ) { rounded [ NUM_ ] = Math . rint ( x * Math . pow ( NUM_ , n Signif ) ) / Math . pow ( NUM_ , n Signif ) ; rounded [ NUM_ ] = Math . rint ( y * Math . pow ( NUM_ , n Signif ) ) / Math . pow ( NUM_ , n Signif ) ; return rounded ; } else { int nzeros = ( int ) ( Math . ceil ( Math . abs ( Math . log 10 ( diff ) ) ) + n Signif ) ; rounded [ NUM_ ] = Math . rint ( x * Math . pow ( NUM_ , nzeros ) ) / Math . pow ( NUM_ , nzeros ) ; rounded [ NUM_ ] = Math . rint ( y * Math . pow ( NUM_ , nzeros ) ) / Math . pow ( NUM_ , nzeros ) ; return rounded ; } }
private boolean schedule Next ( ) { final String tag = STR_ + taskid + STR_ ; try { LOG . finer ( tag + STR_ + delay Before Next + STR_ ) ; if ( cancelled || ! notify State Change ( SCHEDULED , STR_ ) ) { LOG . finer ( tag + STR_ ) ; return false ; } final Session Task next Task = new Session Task ( delay Before Next ) ; if ( ! schedule Session ( next Task , delay Before Next ) ) return false ; LOG . finer ( tag + STR_ ) ; } catch ( Exception x ) { if ( LOG . is Loggable ( Level . FINEST ) ) { LOG . log ( Level . FINEST , tag + STR_ + x , x ) ; } else if ( LOG . is Loggable ( Level . FINE ) ) { LOG . fine ( tag + STR_ + x ) ; } } return true ; }
private void add Json For Entry ( final String Builder result , Entry entry , boolean include Just Text Fields , boolean include User Was Sign In , boolean user Was Signed In , boolean force Quotation To Note ) throws IO Exception { result . append ( STR_ + Json Builder . quote ( entry . get Note Or Title ( STR_ ) ) + STR_ ) ; result . append ( STR_ + Json Builder . quote ( entry . get Quotation ( STR_ ) ) + STR_ ) ; result . append ( STR_ + entry . get Is Public ( ) + STR_ ) ; String type To Add = entry . get Type ( ) ; if ( type To Add . equals ( Db Logic . Constants . quotation ) ) { type To Add = Db Logic . Constants . note ; } result . append ( STR_ + type To Add + STR_ ) ; if ( include User Was Sign In ) { result . append ( STR_ + user Was Signed In + STR_ ) ; } if ( include Just Text Fields ) { result . append ( STR_ + Json Builder . quote ( get Note Html ( entry , false , entry . has Quotation ( ) , true ) ) + STR_ ) ; result . append ( STR_ + Json Builder . quote ( get Quotation Html ( entry , true ) ) + STR_ ) ; } else { final String Builder inner Result = new String Builder ( ) ; add Entry Html To Tree Simple ( entry , inner Result , null , NUM_ , ! entry . is Notebook ( ) ) ; result . append ( STR_ + Json Builder . quote ( inner Result . to String ( ) ) + STR_ ) ; } }
public Builder root Source Section Equals ( Source Section ... section ) { verify Not Null ( section ) ; expressions . add ( new Event Filter Expression . Root Source Section Equals ( section ) ) ; return this ; }
public void dispose ( ) { m Listeners . clear ( ) ; }
protected void delete Family Set ( ) { Item Palette . remove Icon Map ( item Type , family ) ; family = null ; current Icon Map = null ; update Families Panel ( ) ; }
private void finish Item List Item ( String Builder result ) { result . append ( STR_ ) ; }
private static String create Tooltip ( String column Name , String type , String role Name ) { String Builder tip Builder = new String Builder ( ) ; tip Builder . append ( STR_ ) ; tip Builder . append ( I 18 N . get GUI Label ( STR_ ) ) ; tip Builder . append ( STR_ ) ; tip Builder . append ( column Name ) ; tip Builder . append ( STR_ ) ; tip Builder . append ( I 18 N . get GUI Label ( STR_ ) ) ; tip Builder . append ( STR_ ) ; tip Builder . append ( type ) ; tip Builder . append ( STR_ ) ; if ( role Name != null ) { tip Builder . append ( STR_ ) ; tip Builder . append ( I 18 N . get GUI Label ( STR_ ) ) ; tip Builder . append ( STR_ ) ; tip Builder . append ( role Name ) ; tip Builder . append ( STR_ ) ; } tip Builder . append ( STR_ ) ; return tip Builder . to String ( ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Default Interval Category Dataset ) ) { return false ; } Default Interval Category Dataset that = ( Default Interval Category Dataset ) obj ; if ( ! Arrays . equals ( this . series Keys , that . series Keys ) ) { return false ; } if ( ! Arrays . equals ( this . category Keys , that . category Keys ) ) { return false ; } if ( ! equal ( this . start Data , that . start Data ) ) { return false ; } if ( ! equal ( this . end Data , that . end Data ) ) { return false ; } return true ; }
public static void main ( String [ ] args ) { Log . print Line ( STR_ ) ; try { int num user = NUM_ ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = false ; Cloud Sim . init ( num user , calendar , trace flag ) ; @ Suppress Warnings ( STR_ ) Datacenter datacenter 0 = create Datacenter ( STR_ ) ; @ Suppress Warnings ( STR_ ) Datacenter datacenter 1 = create Datacenter ( STR_ ) ; Datacenter Broker broker = create Broker ( ) ; int broker Id = broker . get Id ( ) ; vmlist = create VM ( broker Id , NUM_ ) ; cloudlet List = create Cloudlet ( broker Id , NUM_ ) ; broker . submit Vm List ( vmlist ) ; broker . submit Cloudlet List ( cloudlet List ) ; Cloud Sim . start Simulation ( ) ; List < Cloudlet > new List = broker . get Cloudlet Received List ( ) ; Cloud Sim . stop Simulation ( ) ; print Cloudlet List ( new List ) ; Log . print Line ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STR_ ) ; } }
public void table Switch ( final int [ ] keys , final Table Switch Generator generator , final boolean use Table ) { for ( int i = NUM_ ; i < keys . length ; ++ i ) { if ( keys [ i ] < keys [ i - NUM_ ] ) { throw new Illegal Argument Exception ( STR_ ) ; } } Label def = new Label ( ) ; Label end = new Label ( ) ; if ( keys . length > NUM_ ) { int len = keys . length ; int min = keys [ NUM_ ] ; int max = keys [ len - NUM_ ] ; int range = max - min + NUM_ ; if ( use Table ) { Label [ ] labels = new Label [ range ] ; Arrays . fill ( labels , def ) ; for ( int i = NUM_ ; i < len ; ++ i ) { labels [ keys [ i ] - min ] = new Label ( ) ; } mv . visit Table Switch Insn ( min , max , def , labels ) ; for ( int i = NUM_ ; i < range ; ++ i ) { Label label = labels [ i ] ; if ( label != def ) { mark ( label ) ; generator . generate Case ( i + min , end ) ; } } } else { Label [ ] labels = new Label [ len ] ; for ( int i = NUM_ ; i < len ; ++ i ) { labels [ i ] = new Label ( ) ; } mv . visit Lookup Switch Insn ( def , keys , labels ) ; for ( int i = NUM_ ; i < len ; ++ i ) { mark ( labels [ i ] ) ; generator . generate Case ( keys [ i ] , end ) ; } } } mark ( def ) ; generator . generate Default ( ) ; mark ( end ) ; }
protected void trigger Preferred Leader Election ( Zk Utils zk Utils , List < Partition Info > partition Info List ) { scala . collection . mutable . Hash Set < Topic And Partition > scala Partition Info Set = new scala . collection . mutable . Hash Set < > ( ) ; for ( Partition Info java Partition Info : partition Info List ) { scala Partition Info Set . add ( new Topic And Partition ( topic , java Partition Info . partition ( ) ) ) ; } Preferred Replica Leader Election Command . write Preferred Replica Election Data ( zk Utils , scala Partition Info Set ) ; }
public void remove Item ( int position ) { m Datas . remove ( position ) ; notify Data Set Changed ( ) ; }
public void resolve Urls ( ) { try { pool = Executors . new Fixed Thread Pool ( num Threads ) ; Buffered Reader buff Read = new Buffered Reader ( new File Reader ( new File ( urls File ) ) ) ; String url Str = null ; while ( ( url Str = buff Read . read Line ( ) ) != null ) { LOG . info ( STR_ + url Str ) ; pool . execute ( new Resolver Thread ( url Str ) ) ; } buff Read . close ( ) ; pool . await Termination ( NUM_ , Time Unit . SECONDS ) ; } catch ( Exception e ) { pool . shutdown Now ( ) ; LOG . info ( String Utils . stringify Exception ( e ) ) ; } pool . shutdown ( ) ; LOG . info ( STR_ + num Total . get ( ) + STR_ + num Resolved . get ( ) + STR_ + num Errored . get ( ) + STR_ + total Time . get ( ) / num Total . get ( ) ) ; }
public static String to Hex ( String arg ) { return String . format ( STR_ , new Big Integer ( NUM_ , arg . get Bytes ( ) ) ) ; }
private static boolean evaluate Options Rules ( List req Options , List reg Options ) { if ( req Options == null || reg Options == null || ( req Options . size ( ) == NUM_ ) ) { return true ; } Iterator i = req Options . iterator ( ) ; while ( i . has Next ( ) ) { String option = ( String ) i . next ( ) ; if ( reg Options . contains ( option ) ) { return true ; } } return false ; }
public void add Property Change Listener ( String property Name , Property Change Listener in pcl ) { bean Context Child Support . add Property Change Listener ( property Name , in pcl ) ; }
private void start Download Repeat ( final String hostname , final int port , final String uri ) { m Repeat Download = true ; m Speed Test Socket . start Download ( hostname , port , uri ) ; }
public void stop Logging ( ) { active = false ; }
protected void tear Down ( ) { obj Array = null ; obj Array 2 = null ; hm = null ; }
@ Override protected void init Request ( ) { super . init Request ( ) ; state = state . to Active ( ) ; Http Buffer Store buffer Store = get Http Buffer Store ( ) ; method . clear ( ) ; method String = null ; protocol . clear ( ) ; uri Length = NUM_ ; if ( buffer Store == null ) { uri = get Small Uri Buffer ( ) ; header Buffer = get Small Header Buffer ( ) ; header Keys = get Small Header Keys ( ) ; header Values = get Small Header Values ( ) ; } uri Host . clear ( ) ; host = null ; keepalive = Keepalive State . INIT ; header Size = NUM_ ; header Length = NUM_ ; in Offset = NUM_ ; is Chunked In = false ; is First = true ; }
private void repaint Children ( final Rectangle r ) { final Rectangle content = get Content Size ( ) ; for ( final LW Component Peer < ? , ? > child : get Children ( ) ) { final Rectangle child Bounds = child . get Bounds ( ) ; Rectangle to Paint = r . intersection ( child Bounds ) ; to Paint = to Paint . intersection ( content ) ; to Paint . translate ( - child Bounds . x , - child Bounds . y ) ; child . repaint Peer ( to Paint ) ; } }
protected void add ( String type , String info ) { String seperator = SEPERATOR ; if ( start ( type ) ) { text = new String Builder ( ) ; text . append ( timestamp ( ) ) ; text . append ( type ) ; text . append ( STR_ ) ; seperator = STR_ ; } text . append ( seperator ) ; text . append ( info ) ; length ++ ; if ( length >= MAX LENGTH ) { close ( ) ; } }
public void request ( int sender What , Handler target , int target What ) { synchronized ( this ) { Registration r = null ; if ( m Reg == null ) { r = new Registration ( ) ; r . sender What = sender What ; r . targets = new Handler [ NUM_ ] ; r . target Whats = new int [ NUM_ ] ; r . targets [ NUM_ ] = target ; r . target Whats [ NUM_ ] = target What ; m Reg = r ; r . next = r ; r . prev = r ; } else { Registration start = m Reg ; r = start ; do { if ( r . sender What >= sender What ) { break ; } r = r . next ; } while ( r != start ) ; int n ; if ( r . sender What != sender What ) { Registration reg = new Registration ( ) ; reg . sender What = sender What ; reg . targets = new Handler [ NUM_ ] ; reg . target Whats = new int [ NUM_ ] ; reg . next = r ; reg . prev = r . prev ; r . prev . next = reg ; r . prev = reg ; if ( r == m Reg && r . sender What > reg . sender What ) { m Reg = reg ; } r = reg ; n = NUM_ ; } else { n = r . targets . length ; Handler [ ] old Targets = r . targets ; int [ ] old Whats = r . target Whats ; for ( int i = NUM_ ; i < n ; i ++ ) { if ( old Targets [ i ] == target && old Whats [ i ] == target What ) { return ; } } r . targets = new Handler [ n + NUM_ ] ; System . arraycopy ( old Targets , NUM_ , r . targets , NUM_ , n ) ; r . target Whats = new int [ n + NUM_ ] ; System . arraycopy ( old Whats , NUM_ , r . target Whats , NUM_ , n ) ; } r . targets [ n ] = target ; r . target Whats [ n ] = target What ; } } }
private boolean equals ( Object o , Object p ) { return ( o == p || ( ( o != null ) && o . equals ( p ) ) ) ; }
public boolean is Configured ( ) { return pre Calc Match Client . is Configured ( ) ; }
@ Side Only ( Side . CLIENT ) public void add Special Item Tooltip ( int x Pos , int y Pos , Item Stack stack , Array List < String > tool Tips ) { if ( mouse X >= x Pos && mouse Y >= y Pos && mouse X <= x Pos + NUM_ && mouse Y <= y Pos + NUM_ ) { if ( stack != null ) { List < String > tooltip Data = stack . get Tooltip ( Minecraft . get Minecraft ( ) . the Player , false ) ; List < String > parsed Tooltip = new Array List ( ) ; boolean first = true ; for ( String tip : tool Tips ) tooltip Data . add ( tip ) ; for ( String s : tooltip Data ) { String s = s ; if ( ! first ) s = Chat Formatting . GRAY + s ; parsed Tooltip . add ( s ) ; first = false ; } render Tooltip ( mouse X , mouse Y , parsed Tooltip , NUM_ , NUM_ ) ; } } }
private static boolean is Supported Add Mirrors Virtual Pool Change For Vplex Distributed ( Volume volume , Virtual Pool current Vpool , Virtual Pool new Vpool , Db Client db Client , String Buffer not Supp Reason Buff ) { s logger . info ( String . format ( STR_ , current Vpool . get Label ( ) , new Vpool . get Label ( ) ) ) ; boolean supported = false ; if ( new Vpool . get Max Native Continuous Copies ( ) > NUM_ && new Vpool . get Mirror Virtual Pool ( ) != null ) { String [ ] include = new String [ ] { TYPE , VARRAYS , REF VPOOL , HIGH AVAILABILITY , PROTECTION VARRAY SETTINGS , FAST EXPANSION , ACLS , INACTIVE , DRIVE TYPE , ARRAY INFO , PROVISIONING TYPE , PROTOCOLS } ; String [ ] contain = new String [ ] { MATCHED POOLS , ASSIGNED STORAGE POOLS } ; Map < String , Change > changes = analyze Changes ( current Vpool , new Vpool , include , null , contain ) ; if ( ! changes . is Empty ( ) ) { not Supp Reason Buff . append ( STR_ ) ; fill In Not Supported Reasons ( changes , not Supp Reason Buff ) ; return false ; } supported = true ; } Virtual Pool current Ha Vpool = Virtual Pool . get HAV Pool ( current Vpool , db Client ) ; if ( current Ha Vpool == null ) { current Ha Vpool = current Vpool ; } Virtual Pool new Ha Vpool = Virtual Pool . get HAV Pool ( new Vpool , db Client ) ; if ( current Ha Vpool != null && new Ha Vpool != null ) { if ( new Ha Vpool . get Max Native Continuous Copies ( ) > NUM_ && new Ha Vpool . get Mirror Virtual Pool ( ) != null ) { String [ ] include = new String [ ] { TYPE , VARRAYS , REF VPOOL , PROTECTION VARRAY SETTINGS , FAST EXPANSION , ACLS , INACTIVE , DRIVE TYPE , ARRAY INFO , PROVISIONING TYPE , PROTOCOLS } ; String [ ] contain = new String [ ] { MATCHED POOLS , ASSIGNED STORAGE POOLS } ; Map < String , Change > changes = analyze Changes ( current Ha Vpool , new Ha Vpool , include , null , contain ) ; if ( ! changes . is Empty ( ) ) { not Supp Reason Buff . append ( STR_ ) ; fill In Not Supported Reasons ( changes , not Supp Reason Buff ) ; return false ; } supported = true ; } } return supported ; }
private void generate Request ( Http Servlet Request http Request , org . compiere . cm . cache . XML this XML , Properties ctx ) { Http Session this Session = http Request . get Session ( false ) ; Web Info wi = null ; if ( this Session != null ) { if ( this Session . get Attribute ( Web Info . NAME ) != null ) wi = ( Web Info ) this Session . get Attribute ( Web Info . NAME ) ; xml Code . append ( STR_ ) ; int l n Client ID = Integer . parse Int ( ctx . get Property ( STR_ ) ) ; if ( wi != null ) { if ( wi . get C B Partner ID ( ) != - NUM_ ) { gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , true , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ + l n Client ID + STR_ , true , ctx , wi ) ; } gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , true , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ + l n Client ID + STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ , false , ctx , wi ) ; gen Table ( STR_ , STR_ , false , ctx , wi ) ; } xml Code . append ( STR_ ) ; } }
synchronized void unregister To Notifications ( ) throws JMS Exception { if ( event Session == null ) { return ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STR_ ) ; } try { event Session . close ( ) ; } catch ( IO Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STR_ + e ) ; } JMS Exception e 1 = new JMS Exception ( STR_ ) ; e 1 . set Linked Exception ( e ) ; throw e 1 ; } catch ( Unknown Lease Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STR_ + e ) ; } JMS Exception e 1 = new JMS Exception ( STR_ ) ; e 1 . set Linked Exception ( e ) ; throw e 1 ; } catch ( Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STR_ + e ) ; } JMS Exception e 1 = new JMS Exception ( STR_ ) ; e 1 . set Linked Exception ( e ) ; throw e 1 ; } finally { event Session = null ; } }
public static void register Update Listener ( Update Listener l ) { update Listeners . add ( l ) ; }
private int offset ( int i , int j ) { if ( i < NUM_ || j > max || i > j ) { throw new Runtime Exception ( String . format ( STR_ , i , j , max ) ) ; } return i * ( max + NUM_ ) - i * ( i + NUM_ ) / NUM_ + j ; }
private static double chi Cell ( double freq , double expected , boolean yates ) { if ( Utils . sm Or Eq ( expected , NUM_ ) ) { return NUM_ ; } double diff = Math . abs ( freq - expected ) ; if ( yates ) { diff -= NUM_ ; if ( diff < NUM_ ) { diff = NUM_ ; } } return ( diff * diff / expected ) ; }
private void rotate Right ( Node < K , V > root ) { Node < K , V > pivot = root . left ; Node < K , V > right = root . right ; Node < K , V > pivot Left = pivot . left ; Node < K , V > pivot Right = pivot . right ; root . left = pivot Right ; if ( pivot Right != null ) { pivot Right . parent = root ; } replace In Parent ( root , pivot ) ; pivot . right = root ; root . parent = pivot ; root . height = Math . max ( right != null ? right . height : NUM_ , pivot Right != null ? pivot Right . height : NUM_ ) + NUM_ ; pivot . height = Math . max ( root . height , pivot Left != null ? pivot Left . height : NUM_ ) + NUM_ ; }
public void remove Claims For ( int row , int col ) { effect Claims . remove ( get Key For Coords ( row , col ) ) ; }
protected void remove All Current Downloads ( ) { Log . i ( LOG TAG , STR_ ) ; Array List < Long > ids = new Array List < Long > ( ) ; Cursor cursor = m Download Manager . query ( new Query ( ) ) ; try { if ( cursor . move To First ( ) ) { do { int index = cursor . get Column Index ( Download Manager . COLUMN ID ) ; long download Id = cursor . get Long ( index ) ; ids . add ( download Id ) ; } while ( cursor . move To Next ( ) ) ; } } finally { cursor . close ( ) ; } for ( long id : ids ) { m Download Manager . remove ( id ) ; } cursor = m Download Manager . query ( new Query ( ) ) ; try { assert Equals ( NUM_ , cursor . get Count ( ) ) ; } finally { cursor . close ( ) ; } }
public void add Property Change Listener ( Property Change Listener listener ) { property Support . add Property Change Listener ( listener ) ; }
public void update Track Point ( Point p ) { int new Loc X = Math . min ( p . x , this . anchor . x ) ; int new Loc Y = Math . min ( p . y , this . anchor . y ) ; int delta X = Math . abs ( p . x - this . anchor . x ) ; int delta Y = Math . abs ( p . y - this . anchor . y ) ; set Location ( new Loc X , new Loc Y ) ; set Size ( delta X , delta Y ) ; }
public void prepare Pid Pvs ( int obd Service , Pv List pv List ) { reset Fixed Pid ( ) ; Hash Map < String , Ecu Data Pv > new List = new Hash Map < String , Ecu Data Pv > ( ) ; for ( Integer curr Pid : pid Supported ) { Vector < Ecu Data Item > items = data Items . get Pid Data Items ( obd Service , curr Pid ) ; if ( items == null ) { log . warn ( String . format ( STR_ , curr Pid ) ) ; Conversion [ ] dummy Cnvs = { Ecu Conversions . dflt Cnv , Ecu Conversions . dflt Cnv } ; Ecu Data Item new Item = new Ecu Data Item ( curr Pid , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , dummy Cnvs , STR_ , null , null , String . format ( STR_ , curr Pid ) ) ; data Items . append Item To Service ( obd Service , new Item ) ; items = data Items . get Pid Data Items ( obd Service , curr Pid ) ; } for ( Ecu Data Item pid Pv : items ) { if ( pid Pv != null ) { new List . put ( pid Pv . to String ( ) , pid Pv . pv ) ; } } } pv List . put All ( new List , Pv Change Event . PV ADDED , false ) ; }
private Cluster < Dendrogram Model > make Cluster ( DBID Ref lead , double depth , DBI Ds members ) { final String name ; if ( members . size ( ) == NUM_ ) { name = STR_ + DBID Util . to String ( lead ) + STR_ + depth ; } else if ( ! Double . is Na N ( depth ) && Double . is Infinite ( depth ) || ( members . size ( ) == NUM_ && members . contains ( lead ) ) ) { name = STR_ + DBID Util . to String ( lead ) ; } else if ( ! Double . is Na N ( depth ) ) { name = STR_ + DBID Util . to String ( lead ) + STR_ + depth ; } else { name = STR_ + DBID Util . to String ( lead ) ; } Cluster < Dendrogram Model > cluster = new Cluster < > ( name , members , new Dendrogram Model ( depth ) ) ; return cluster ; }
public int wait For Condition ( Channel c , long timeout , int condition mask ) { long end time = NUM_ ; boolean end time set = false ; synchronized ( c ) { while ( true ) { int current cond = NUM_ ; int stdout Avail = c . stdout Writepos - c . stdout Readpos ; int stderr Avail = c . stderr Writepos - c . stderr Readpos ; if ( stdout Avail > NUM_ ) current cond = current cond | Channel Condition . STDOUT DATA ; if ( stderr Avail > NUM_ ) current cond = current cond | Channel Condition . STDERR DATA ; if ( c . EOF ) current cond = current cond | Channel Condition . EOF ; if ( c . get Exit Status ( ) != null ) current cond = current cond | Channel Condition . EXIT STATUS ; if ( c . get Exit Signal ( ) != null ) current cond = current cond | Channel Condition . EXIT SIGNAL ; if ( c . state == Channel . STATE CLOSED ) return current cond | Channel Condition . CLOSED | Channel Condition . EOF ; if ( ( current cond & condition mask ) != NUM_ ) return current cond ; if ( timeout > NUM_ ) { if ( ! end time set ) { end time = System . current Time Millis ( ) + timeout ; end time set = true ; } else { timeout = end time - System . current Time Millis ( ) ; if ( timeout <= NUM_ ) return current cond | Channel Condition . TIMEOUT ; } } try { if ( timeout > NUM_ ) c . wait ( timeout ) ; else c . wait ( ) ; } catch ( Interrupted Exception e ) { } } } }
private void create Portland ( final int HOME END TIME ) { int current Id = NUM_ ; int duration = ( int ) ( NUM_ * NUM_ ) ; final int DEFAULT CARS PER HOUR PER LANE = NUM_ ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; current Id = add Commodity ( STR_ , STR_ , HOME END TIME , duration , ( int ) ( NUM_ * DEFAULT CARS PER HOUR PER LANE ) , STR_ , current Id ) ; }
public Ranking Image List Provider in Weeks ( int weeks ) { m Time = Integer . to String ( weeks ) + STR_ ; return this ; }
public boolean is Use Compression ( ) { return this . use Compression ; }
private void log Missing Regions ( Partitioned Region region ) { String names Of Missing = STR_ ; if ( ! missing Children . is Empty ( ) ) { names Of Missing = String . join ( STR_ , missing Children ) ; } String multiple Children ; String singular = STR_ ; String plural = STR_ ; multiple Children = missing Children . size ( ) > NUM_ ? plural : singular ; names Of Missing = String . join ( STR_ , multiple Children , names Of Missing ) ; logger . warn ( Localized Message . create ( Localized Strings . Colocation Logger PERSISTENT DATA RECOVERY OF REGION PREVENTED BY OFFLINE COLOCATED CHILDREN , new Object [ ] { region . get Full Path ( ) , names Of Missing } ) ) ; }
static Optimized Class Descriptor class Descriptor ( Concurrent Map < Class , Optimized Class Descriptor > cls Map , int id , Class Loader ldr , Marshaller Context ctx , Optimized Marshaller Id Mapper mapper ) throws IO Exception , Class Not Found Exception { Class cls ; try { cls = ctx . get Class ( id , ldr ) ; } catch ( Ignite Checked Exception e ) { throw new IO Exception ( STR_ + id , e ) ; } Optimized Class Descriptor desc = cls Map . get ( cls ) ; if ( desc == null ) { Optimized Class Descriptor old = cls Map . put If Absent ( cls , desc = new Optimized Class Descriptor ( cls , resolve Type Id ( cls . get Name ( ) , mapper ) , cls Map , ctx , mapper ) ) ; if ( old != null ) desc = old ; } return desc ; }
public static boolean compute Instances Started State With Accepted Error Rate ( Amazon EC 2 Async Client client , Verification Host host , List < String > instance Ids , int error Rate ) throws Throwable { if ( instance Ids . size ( ) == NUM_ ) { return false ; } Array List < Boolean > provisioning Flags = new Array List < Boolean > ( instance Ids . size ( ) ) ; for ( int i = NUM_ ; i < instance Ids . size ( ) ; i ++ ) { provisioning Flags . add ( i , Boolean . FALSE ) ; } check Instances Started ( host , client , instance Ids , provisioning Flags ) ; int total Count = instance Ids . size ( ) ; int pass Count = ( int ) Math . ceil ( ( ( ( NUM_ - error Rate ) / HUNDERED ) * total Count ) ) ; int powered On Count = NUM_ ; for ( boolean started Flag : provisioning Flags ) { if ( started Flag ) { powered On Count ++ ; } } return ( powered On Count >= pass Count ) ; }
protected void fire Fatal Connection Error ( SQL Exception ex ) { Connection Event evt = new Connection Event ( this , ex ) ; for ( Connection Event Listener listener : connection Event Listeners ) { listener . connection Error Occurred ( evt ) ; } }
private static String [ ] make Lines ( int n ) { String [ ] ret = new String [ n ] ; for ( int i = NUM_ ; i < n ; ++ i ) { ret [ i ] = STR_ + i ; } return ret ; }
void add Access Key ( int access Key , Component cmp , boolean override ) { if ( ( override ) && ( access Keys . contains ( cmp ) ) ) { Hashtable new Access Keys = new Hashtable ( ) ; for ( Enumeration e = access Keys . keys ( ) ; e . has More Elements ( ) ; ) { Object key = e . next Element ( ) ; Component c = ( Component ) access Keys . get ( key ) ; if ( c != cmp ) { new Access Keys . put ( key , c ) ; } } access Keys = new Access Keys ; } access Keys . put ( new Integer ( access Key ) , cmp ) ; Form form = get Component Form ( ) ; if ( form != null ) { form . add Key Listener ( access Key , this ) ; } }
public boolean remove Selection ( int position ) { return m Selected Positions . remove ( position ) ; }
public void to Lax String ( String Builder sb ) { sb . append ( STR_ ) ; for ( String step : steps ) { if ( step . char At ( NUM_ ) != STR_ ) { sb . append ( STR_ ) ; sb . append ( step ) ; } } }
public Follower Info ( Follower . Type type , String stream , String error ) { this . type = type ; this . followers = null ; this . total = - NUM_ ; this . time = System . current Time Millis ( ) ; this . stream = stream ; this . request Error = true ; this . request Error Description = error ; }
private boolean dyn Init ( ) { Vector < String > column Names = new Vector < String > ( ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , m C B Partner ID == NUM_ ? STR_ : STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; Vector < Vector < Object > > data = null ; if ( m C B Partner ID == NUM_ ) data = query B Partner ( ) ; else data = query Product ( ) ; m model Price = new Default Table Model ( data , column Names ) ; m table Price . set Model ( m model Price ) ; m table Price . set Column Class ( NUM_ , String . class , true ) ; m table Price . set Column Class ( NUM_ , Double . class , true ) ; m table Price . set Column Class ( NUM_ , Double . class , true ) ; m table Price . set Column Class ( NUM_ , Big Decimal . class , true ) ; m table Price . set Column Class ( NUM_ , String . class , true ) ; m table Price . set Column Class ( NUM_ , Timestamp . class , true ) ; m table Price . set Column Class ( NUM_ , String . class , true ) ; m table Price . auto Size ( ) ; return data . size ( ) != NUM_ ; }
private void update Colors ( Play play ) { if ( play . get Player Count ( ) == NUM_ ) { return ; } if ( ! Resolver Utils . row Exists ( resolver , Games . build Game Uri ( play . game Id ) ) ) { return ; } List < Content Values > values = new Array List < > ( ) ; for ( Player player : play . get Players ( ) ) { String color = player . color ; if ( ! Text Utils . is Empty ( color ) ) { Content Values cv = new Content Values ( ) ; cv . put ( Game Colors . COLOR , color ) ; values . add ( cv ) ; } } if ( values . size ( ) > NUM_ ) { Content Values [ ] array = { } ; resolver . bulk Insert ( Games . build Colors Uri ( play . game Id ) , values . to Array ( array ) ) ; } }
int current Pool Size ( ) { return max Pool Size - available Connections . available Permits ( ) ; }
private synchronized void write Object ( java . io . Object Output Stream s ) throws IO Exception { if ( actions == null ) get Actions ( ) ; s . default Write Object ( ) ; }
public void load Contents ( Prepared Statement Wrapper ps ) { if ( m interface . get Content Type ( ) != null && m interface . get Content Types ( ) != null ) { s logger . log ( Level . FINE , STR_ , new Object [ ] { get Content Types ( ) , get Object Type ( ) , m name , m parent . get Direction ( ) } ) ; m contents = new Hash Map < Integer , DB Object Definition > ( ) ; m interface . load Contents ( m contents , s parameters , s logger , s db Engine , m parent , m name , m headers , ps ) ; int counter = m contents . size ( ) ; String log Object = get Content Types ( ) ; if ( counter == NUM_ ) log Object = get Content Type ( ) ; s logger . log ( Level . FINE , STR_ , new Object [ ] { Integer . to String ( counter ) , log Object } ) ; } }
Property for Key ( String property Name ) { String property Name Canon = Strings . to Lower Case ( property Name ) ; Property property = properties . get ( property Name Canon ) ; if ( property != null ) { return property ; } int n = property Name Canon . length ( ) ; if ( n != NUM_ && property Name Canon . char At ( NUM_ ) == STR_ ) { String bare Property Name Canon = strip Vendor Prefix ( property Name Canon ) ; property = properties . get ( bare Property Name Canon ) ; if ( property != null ) { return property ; } } return DISALLOWED ; }
public static String enumerate Collection ( final Collection < String > collection ) { if ( collection == null ) { return STR_ ; } final String [ ] elements = collection . to Array ( new String [ collection . size ( ) ] ) ; String ret ; if ( elements . length == NUM_ ) { ret = STR_ ; } else if ( elements . length == NUM_ ) { ret = quote Hash ( elements [ NUM_ ] ) ; } else if ( elements . length == NUM_ ) { ret = quote Hash ( elements [ NUM_ ] ) + STR_ + quote Hash ( elements [ NUM_ ] ) ; } else { final String Builder sb = new String Builder ( ) ; for ( int i = NUM_ ; i < elements . length - NUM_ ; i ++ ) { sb . append ( quote Hash ( elements [ i ] ) + STR_ ) ; } sb . append ( STR_ + quote Hash ( elements [ elements . length - NUM_ ] ) ) ; ret = sb . to String ( ) ; } return replace Internal By Display Names ( ret ) ; }
static void reset Cache Recreation Count ( ) { cache Recreation Count . set ( NUM_ ) ; }
public void remove Item ( M model ) { m Datas . remove ( model ) ; notify Data Set Changed ( ) ; }
public void finish ( ) throws Carbon Data Writer Exception { if ( this . entry Count > NUM_ ) { producer Executor Service Task List . add ( producer Executor Service . submit ( new Producer ( blocklet Data Holder , data Rows , ++ writer Task Sequence Counter ) ) ) ; blocklet Processing Count . increment And Get ( ) ; processed Data Count += entry Count ; } close Writer Execution Service ( producer Executor Service ) ; process Write Task Submit List ( producer Executor Service Task List ) ; processing Complete = true ; }
public static long now In Millis ( ) { return System . current Time Millis ( ) ; }
public void update Refresh Timer ( ) { last Refresh = System . current Time Millis ( ) ; }
public static Array List < String > extract Ts Conf ( String [ ] frame ) { Array List < String > sorti = new Array List < > ( ) ; String info = General . hex To Bin ( frame [ NUM_ ] ) ; for ( ; info . length ( ) < NUM_ ; ) { info = STR_ + info ; } String timeslot = String . value Of ( Integer . parse Int ( info . substring ( NUM_ , NUM_ ) , NUM_ ) ) ; if ( info . char At ( NUM_ ) == STR_ ) { sorti . add ( timeslot ) ; sorti . add ( STR_ ) ; } else { sorti . add ( timeslot ) ; sorti . add ( STR_ ) ; } return sorti ; }
@ Rpc Method public void provision ( List < String > data Store List , Set < String > image Data Stores , boolean used For V Ms , String host Address , int host Port , double memory Over Commit , String logging Endpoint , String log Level , Stats Plugin Config stats Plugin Config , boolean management Only , String host Id , String deployment Id , String ntp Endpoint , Async Method Callback < Agent Control . Async Client . provision call > handler ) throws Rpc Exception { ensure Client ( ) ; Hash Set < Image Datastore > image Datastore Set = new Hash Set < > ( ) ; image Data Stores . for Each ( null ) ; Provision Request provision Request = new Provision Request ( ) ; provision Request . set Datastores ( data Store List ) ; provision Request . set Address ( new Server Address ( host Address , host Port ) ) ; provision Request . set Memory overcommit ( memory Over Commit ) ; provision Request . set Management only ( management Only ) ; provision Request . set Host id ( host Id ) ; provision Request . set Deployment id ( deployment Id ) ; provision Request . set Ntp endpoint ( ntp Endpoint ) ; provision Request . set Image datastores ( image Datastore Set ) ; provision Request . set Stats plugin config ( stats Plugin Config ) ; client Proxy . set Timeout ( PROVISION TIMEOUT MS ) ; logger . info ( STR_ , get Host Ip ( ) , provision Request ) ; try { client Proxy . provision ( provision Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
protected void fill And Sort ( final int dim ) { for ( int j = NUM_ ; j < size ; j ++ ) { E e = get ( j ) ; min Sorting [ j ] . first = e . get Min ( dim ) ; min Sorting [ j ] . second = j ; max Sorting [ j ] . first = e . get Max ( dim ) ; max Sorting [ j ] . second = j ; } Arrays . sort ( min Sorting ) ; Arrays . sort ( max Sorting ) ; }
public Launcher Edge Effect ( ) { m Paint . set Anti Alias ( true ) ; m Paint . set Style ( Paint . Style . FILL ) ; m Interpolator = new Decelerate Interpolator ( ) ; }
@ Px private int calculate Indicator Dot Start ( ) { final int dot Count = indicator Dots . size ( ) ; final float half Dot Count = dot Count / NUM_ ; final int dot Width = NUM_ * dot Radius ; final float total Dot Width = dot Width * half Dot Count ; final float half Dot Padding Count = Math . max ( half Dot Count - NUM_ , NUM_ ) ; final float total Dot Padding Width = dot Padding * half Dot Padding Count ; int start Position = get Width ( ) / NUM_ ; start Position -= total Dot Width + total Dot Padding Width ; return start Position ; }
public static boolean is Geo Header Enabled For Url ( Context context , String url , boolean is Incognito ) { if ( is Incognito ) return false ; if ( ! Url Utilities . native Is Google Search Url ( url ) ) return false ; Uri uri = Uri . parse ( url ) ; if ( ! HTTPS SCHEME . equals ( uri . get Scheme ( ) ) ) return false ; if ( is Location Disabled For Url ( uri ) ) return false ; return true ; }
protected double find Maximum Tick Label Height ( List ticks , Graphics 2 D g 2 , Rectangle 2 D draw Area , boolean vertical ) { Rectangle Insets insets = get Tick Label Insets ( ) ; Font font = get Tick Label Font ( ) ; g 2 . set Font ( font ) ; double max Height = NUM_ ; if ( vertical ) { Font Metrics fm = g 2 . get Font Metrics ( font ) ; Iterator iterator = ticks . iterator ( ) ; while ( iterator . has Next ( ) ) { Tick tick = ( Tick ) iterator . next ( ) ; Rectangle 2 D label Bounds = null ; if ( tick instanceof Log Tick ) { Log Tick lt = ( Log Tick ) tick ; if ( lt . get Attributed Label ( ) != null ) { label Bounds = Attr String Utils . get Text Bounds ( lt . get Attributed Label ( ) , g 2 ) ; } } else if ( tick . get Text ( ) != null ) { label Bounds = Text Utilities . get Text Bounds ( tick . get Text ( ) , g 2 , fm ) ; } if ( label Bounds != null && label Bounds . get Width ( ) + insets . get Top ( ) + insets . get Bottom ( ) > max Height ) { max Height = label Bounds . get Width ( ) + insets . get Top ( ) + insets . get Bottom ( ) ; } } } else { Line Metrics metrics = font . get Line Metrics ( STR_ , g 2 . get Font Render Context ( ) ) ; max Height = metrics . get Height ( ) + insets . get Top ( ) + insets . get Bottom ( ) ; } return max Height ; }
private Annotation [ ] extract ( Annotation label ) throws Exception { Class union = label . annotation Type ( ) ; Method [ ] list = union . get Declared Methods ( ) ; if ( list . length != NUM_ ) { throw new Union Exception ( STR_ , label , type ) ; } Method method = list [ NUM_ ] ; Object value = method . invoke ( label ) ; return ( Annotation [ ] ) value ; }
public void close ( Jar File jar File ) { synchronized ( instance ) { URL url Removed = url Cache . remove ( jar File ) ; if ( url Removed != null ) file Cache . remove ( URL Util . url No Frag String ( url Removed ) ) ; } }
void release Object ( long object , boolean dissociate ) { if ( dissociate ) { try { port Dissociate ( port , PORT SOURCE FILE , object ) ; } catch ( Unix Exception x ) { } } long name = unsafe . get Address ( object + OFFSET FO NAME ) ; unsafe . free Memory ( name ) ; unsafe . free Memory ( object ) ; }
public Jsp Runtime Context ( Servlet Context context , Options options ) { this . context = context ; this . options = options ; int hash Size = options . get Initial Capacity ( ) ; jsps = new Concurrent Hash Map < String , Jsp Servlet Wrapper > ( hash Size ) ; bytecodes = new Concurrent Hash Map < String , byte [ ] > ( hash Size ) ; bytecode Birth Times = new Concurrent Hash Map < String , Long > ( hash Size ) ; package Map = new Concurrent Hash Map < String , Map < String , Java File Object > > ( ) ; if ( log . is Loggable ( Level . FINEST ) ) { Class Loader parent Class Loader = get Parent Class Loader ( ) ; if ( parent Class Loader != null ) { log . finest ( Localizer . get Message ( STR_ , parent Class Loader . to String ( ) ) ) ; } else { log . finest ( Localizer . get Message ( STR_ , STR_ ) ) ; } } init Class Path ( ) ; if ( context instanceof org . apache . jasper . servlet . Jsp C Servlet Context ) { return ; } if ( Constants . IS SECURITY ENABLED ) { init Security ( ) ; } String app Base = context . get Real Path ( STR_ ) ; if ( ! options . get Development ( ) && app Base != null && options . get Check Interval ( ) > NUM_ && ! options . get Use Precompiled ( ) ) { if ( app Base . ends With ( File . separator ) ) { app Base = app Base . substring ( NUM_ , app Base . length ( ) - NUM_ ) ; } String directory = app Base . substring ( app Base . last Index Of ( File . separator ) ) ; thread Name = thread Name + STR_ + directory + STR_ ; thread Start ( ) ; } }
@ Override public int compare To ( Firewall Rule rule ) { return this . priority - rule . priority ; }
Format Specifier Parser ( String format ) { this . format = format ; this . length = format . length ( ) ; }
@ Override protected Statement class Block ( Run Notifier notifier ) { return children Invoker ( notifier ) ; }
protected void connection Up ( ) { if ( connected Status != null ) { connected Status . set Text ( STATUS CONNECTED ) ; connected Status . set Background ( Color . green ) ; } }
Bleach Composer ( Color c ) { int color = c . get RGB ( ) ; int [ ] components = new int [ NUM_ ] ; split Rgb ( color , components ) ; red = Math . max ( NUM_ , components [ RED ] ) ; green = Math . max ( NUM_ , components [ GREEN ] ) ; blue = Math . max ( NUM_ , components [ BLUE ] ) ; }
public void append To Nal Unit ( byte [ ] data , int offset , int limit ) { if ( ! is Filling ) { return ; } int read Length = limit - offset ; if ( buffer . length < buffer Length + read Length ) { buffer = Arrays . copy Of ( buffer , ( buffer Length + read Length ) * NUM_ ) ; } System . arraycopy ( data , offset , buffer , buffer Length , read Length ) ; buffer Length += read Length ; scratch . reset ( buffer , buffer Length ) ; if ( scratch . bits Left ( ) < NUM_ ) { return ; } scratch . skip Bits ( NUM_ ) ; int nal Ref Idc = scratch . read Bits ( NUM_ ) ; scratch . skip Bits ( NUM_ ) ; if ( ! scratch . can Read Exp Golomb Coded Num ( ) ) { return ; } scratch . read Unsigned Exp Golomb Coded Int ( ) ; if ( ! scratch . can Read Exp Golomb Coded Num ( ) ) { return ; } int slice Type = scratch . read Unsigned Exp Golomb Coded Int ( ) ; if ( ! detect Access Units ) { is Filling = false ; slice Header . set Slice Type ( slice Type ) ; return ; } if ( ! scratch . can Read Exp Golomb Coded Num ( ) ) { return ; } int pic Parameter Set Id = scratch . read Unsigned Exp Golomb Coded Int ( ) ; if ( pps . index Of Key ( pic Parameter Set Id ) < NUM_ ) { is Filling = false ; return ; } Nal Unit Util . Pps Data pps Data = pps . get ( pic Parameter Set Id ) ; Nal Unit Util . Sps Data sps Data = sps . get ( pps Data . seq Parameter Set Id ) ; if ( sps Data . separate Color Plane Flag ) { if ( scratch . bits Left ( ) < NUM_ ) { return ; } scratch . skip Bits ( NUM_ ) ; } if ( scratch . bits Left ( ) < sps Data . frame Num Length ) { return ; } boolean field Pic Flag = false ; boolean bottom Field Flag Present = false ; boolean bottom Field Flag = false ; int frame Num = scratch . read Bits ( sps Data . frame Num Length ) ; if ( ! sps Data . frame Mbs Only Flag ) { if ( scratch . bits Left ( ) < NUM_ ) { return ; } field Pic Flag = scratch . read Bit ( ) ; if ( field Pic Flag ) { if ( scratch . bits Left ( ) < NUM_ ) { return ; } bottom Field Flag = scratch . read Bit ( ) ; bottom Field Flag Present = true ; } } boolean idr Pic Flag = nal Unit Type == NAL UNIT TYPE IDR ; int idr Pic Id = NUM_ ; if ( idr Pic Flag ) { if ( ! scratch . can Read Exp Golomb Coded Num ( ) ) { return ; } idr Pic Id = scratch . read Unsigned Exp Golomb Coded Int ( ) ; } int pic Order Cnt Lsb = NUM_ ; int delta Pic Order Cnt Bottom = NUM_ ; int delta Pic Order Cnt 0 = NUM_ ; int delta Pic Order Cnt 1 = NUM_ ; if ( sps Data . pic Order Count Type == NUM_ ) { if ( scratch . bits Left ( ) < sps Data . pic Order Cnt Lsb Length ) { return ; } pic Order Cnt Lsb = scratch . read Bits ( sps Data . pic Order Cnt Lsb Length ) ; if ( pps Data . bottom Field Pic Order In Frame Present Flag && ! field Pic Flag ) { if ( ! scratch . can Read Exp Golomb Coded Num ( ) ) { return ; } delta Pic Order Cnt Bottom = scratch . read Signed Exp Golomb Coded Int ( ) ; } } else if ( sps Data . pic Order Count Type == NUM_ && ! sps Data . delta Pic Order Always Zero Flag ) { if ( ! scratch . can Read Exp Golomb Coded Num ( ) ) { return ; } delta Pic Order Cnt 0 = scratch . read Signed Exp Golomb Coded Int ( ) ; if ( pps Data . bottom Field Pic Order In Frame Present Flag && ! field Pic Flag ) { if ( ! scratch . can Read Exp Golomb Coded Num ( ) ) { return ; } delta Pic Order Cnt 1 = scratch . read Signed Exp Golomb Coded Int ( ) ; } } slice Header . set All ( sps Data , nal Ref Idc , slice Type , frame Num , pic Parameter Set Id , field Pic Flag , bottom Field Flag Present , bottom Field Flag , idr Pic Flag , idr Pic Id , pic Order Cnt Lsb , delta Pic Order Cnt Bottom , delta Pic Order Cnt 0 , delta Pic Order Cnt 1 ) ; is Filling = false ; }
public void remove ( History Reference href ) { synchronized ( href List ) { int index = href List . index Of ( href ) ; if ( index >= NUM_ ) { href List . remove ( index ) ; fire Table Rows Deleted ( index , index ) ; } } }
private static boolean is Assignable From ( Type from , Parameterized Type to , Map < String , Type > type Var Map ) { if ( from == null ) { return false ; } if ( to . equals ( from ) ) { return true ; } Class < ? > clazz = $Gson$Types . get Raw Type ( from ) ; Parameterized Type ptype = null ; if ( from instanceof Parameterized Type ) { ptype = ( Parameterized Type ) from ; } if ( ptype != null ) { Type [ ] t Args = ptype . get Actual Type Arguments ( ) ; Type Variable < ? > [ ] t Params = clazz . get Type Parameters ( ) ; for ( int i = NUM_ ; i < t Args . length ; i ++ ) { Type arg = t Args [ i ] ; Type Variable < ? > var = t Params [ i ] ; while ( arg instanceof Type Variable < ? > ) { Type Variable < ? > v = ( Type Variable < ? > ) arg ; arg = type Var Map . get ( v . get Name ( ) ) ; } type Var Map . put ( var . get Name ( ) , arg ) ; } if ( type Equals ( ptype , to , type Var Map ) ) { return true ; } } for ( Type itype : clazz . get Generic Interfaces ( ) ) { if ( is Assignable From ( itype , to , new Hash Map < String , Type > ( type Var Map ) ) ) { return true ; } } Type s Type = clazz . get Generic Superclass ( ) ; return is Assignable From ( s Type , to , new Hash Map < String , Type > ( type Var Map ) ) ; }
public static String Builder left Shift ( String Builder self , Object value ) { self . append ( value ) ; return self ; }
public boolean parse KML File ( File file ) { m Local File = file ; Log . d ( Bonus Pack Helper . LOG TAG , STR_ + m Local File . get Absolute Path ( ) ) ; Input Stream stream ; boolean ok ; try { stream = new Buffered Input Stream ( new File Input Stream ( m Local File ) ) ; ok = parse KML Stream ( stream , null ) ; stream . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; ok = false ; } return ok ; }
public static < T extends Object & java . lang . Comparable < ? super T > > T max ( Collection < ? extends T > collection ) { Iterator < ? extends T > it = collection . iterator ( ) ; T max = it . next ( ) ; if ( Number Comparator . is Number ( max ) ) { return ( T ) max ( collection , Number Comparator . create Comparator ( max . get Class ( ) ) ) ; } while ( it . has Next ( ) ) { T next = it . next ( ) ; if ( max . compare To ( next ) < NUM_ ) { max = next ; } } return max ; }
public static void decomposition ( Image input Img , Image coarse Img , Image horizontal Img , Image vertical Img , Image diagonal Img , Filter filter G , Filter filter H , int method ) { Image temp Img = null ; temp Img = new Image ( coarse Img . get Width ( ) , input Img . get Height ( ) ) ; convolute Lines ( temp Img , input Img , filter H , method ) ; convolute Rows ( coarse Img , temp Img , filter H , method ) ; convolute Rows ( horizontal Img , temp Img , filter G , method ) ; temp Img = new Image ( vertical Img . get Width ( ) , input Img . get Height ( ) ) ; convolute Lines ( temp Img , input Img , filter G , method ) ; convolute Rows ( vertical Img , temp Img , filter H , method ) ; convolute Rows ( diagonal Img , temp Img , filter G , method ) ; }
@ Override public Drag Source Context Peer create Drag Source Context Peer ( Drag Gesture Event dge ) throws Invalid Dn D Operation Exception { final Lightweight Frame f = Sun Toolkit . get Lightweight Frame ( dge . get Component ( ) ) ; if ( f != null ) { return f . create Drag Source Context Peer ( dge ) ; } return W Drag Source Context Peer . create Drag Source Context Peer ( dge ) ; }
private void expand ( int i ) { if ( count + i <= buf . length ) { return ; } byte [ ] newbuf = m Pool . get Buf ( ( count + i ) * NUM_ ) ; System . arraycopy ( buf , NUM_ , newbuf , NUM_ , count ) ; m Pool . return Buf ( buf ) ; buf = newbuf ; }
public static Buffered Writer new Writer ( Path self ) throws IO Exception { return Files . new Buffered Writer ( self , Charset . default Charset ( ) ) ; }
private static String convert To Quoted String ( String s ) { if ( s == null || s . is Empty ( ) ) { return null ; } if ( s . char At ( NUM_ ) == STR_ && s . char At ( s . length ( ) - NUM_ ) == STR_ ) { return s ; } return STR_ + s + STR_ ; }
private boolean is Spurious ( Temp Cluster clus , boolean is Core ) { return clus != null ? clus . is Spurious ( min Cl Size ) : ( min Cl Size > NUM_ || ! is Core ) ; }
public void debug Print ( String name , Print Stream out ) throws Ade Exception { if ( name != null ) { out . println ( STR_ + name + STR_ + get LL Max ( ) ) ; } if ( m point Scores != null && ! m point Scores . is Empty ( ) ) { for ( Entry < Integer , Double > point Score : m point Scores . entry Set ( ) ) { out . println ( STR_ + point Score . get Key ( ) + STR_ + point Score . get Value ( ) ) ; } out . println ( STR_ + - m log Half ) ; } }
public static void write Centroids To File ( Clusters clusters , Flag Config flag Config ) { Vector Store RAM centroids Output = new Vector Store RAM ( flag Config ) ; for ( int i = NUM_ ; i < clusters . centroids . length ; ++ i ) { centroids Output . put Vector ( Integer . to String ( i ) , clusters . centroids [ i ] ) ; } try { Vector Store Writer . write Vectors ( STR_ , flag Config , centroids Output ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
@ Suppress Warnings ( STR_ ) @ Json Creator public static Client Detail Response V 2 from Parts ( @ Json Property ( STR_ ) String name , @ Json Property ( STR_ ) String description , @ Json Property ( STR_ ) long created At Seconds , @ Json Property ( STR_ ) long updated At Seconds , @ Json Property ( STR_ ) String created By , @ Json Property ( STR_ ) String updated By , @ Json Property ( STR_ ) Optional < Long > last Seen Seconds ) { return new Auto Value Client Detail Response V 2 ( name , description , created At Seconds , updated At Seconds , created By , updated By , last Seen Seconds ) ; }
public void dont Notify ( final Turn Listener turn Listener ) { for ( final Map . Entry < Integer , Set < Turn Listener > > map Entry : register . entry Set ( ) ) { final Set < Turn Listener > set = map Entry . get Value ( ) ; final Set < Turn Listener > to Be Removed = new Hash Set < Turn Listener > ( ) ; if ( set . contains ( turn Listener ) ) { to Be Removed . add ( turn Listener ) ; } for ( final Turn Listener event : to Be Removed ) { set . remove ( event ) ; } } }
public void init ( Action Listener done Action ) { update = false ; supress Dragging = true ; bottom 1 Panel = new J Panel ( ) ; add Show Button To Bottom ( ) ; add Update Button To Bottom ( done Action ) ; init Icon Families Panel ( ) ; add ( icon Family Panel ) ; add ( bottom 1 Panel ) ; }
public static float read Float ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return ( float ) json Object . get Double ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } float value = NUM_ ; if ( ! json Object . is Null ( key ) ) { value = ( float ) json Object . get Double ( key ) ; } return value ; }
private static String convert To Quoted String ( String string ) { if ( string == null || string . length ( ) == NUM_ ) { return null ; } if ( string . char At ( NUM_ ) == STR_ && string . char At ( string . length ( ) - NUM_ ) == STR_ ) { return string ; } return STR_ + string + STR_ ; }
public void connection Closed ( Connection Event event ) { if ( is Active ) { Managed Connection conn = ( Managed Connection ) event . get Source ( ) ; XA Resource xar = null ; if ( xa Resources Map . get ( conn ) != null ) xar = ( XA Resource ) xa Resources Map . get ( conn ) ; xa Resources Map . remove ( conn ) ; try { Transaction txn = trans Manager . get Transaction ( ) ; if ( txn != null && xar != null ) { txn . delist Resource ( xar , XA Resource . TMSUCCESS ) ; } } catch ( Exception se ) { String exception = STR_ + se ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( exception , se ) ; } } mann Pool Cache . return Pooled Connection To Pool ( conn ) ; } }
public Stax Writer ( final Q Name Map qname Map , final XML Stream Writer out , final boolean write Enclosing Document , final boolean namespace Repairing Mode , final Name Coder name Coder ) throws XML Stream Exception { super ( name Coder ) ; this . qname Map = qname Map ; this . out = out ; this . write Enclosing Document = write Enclosing Document ; this . namespace Repairing Mode = namespace Repairing Mode ; if ( write Enclosing Document ) { out . write Start Document ( ) ; } }
public void add Table Header ( final J Table Header new Table Header ) { if ( ! registred Table Headers . contains ( new Table Header ) ) { if ( table Header == null ) { table Header = new Table Header ; } new Table Header . add Mouse Listener ( mouse Listener ) ; new Table Header . set Default Renderer ( new Sortable Header Renderer ( new Table Header . get Default Renderer ( ) ) ) ; registred Table Headers . add ( new Table Header ) ; } }
public Emote Condition ( final String player Action ) { this . player Action = player Action . trim ( ) ; }
private File create New Format ( int AD Table ID , Http Servlet Request request , Grid Tab m cur Tab , M Query m query ) { Web Session Ctx wsc = Web Session Ctx . get ( request ) ; M Print Format pf = M Print Format . create From Table ( wsc . ctx , AD Table ID ) ; File file = launch Report ( pf , request , m cur Tab , m query ) ; return file ; }
public Date Time Formatter Builder parse Defaulting ( Temporal Field field , long value ) { Objects . require Non Null ( field , STR_ ) ; append Internal ( new Default Value Parser ( field , value ) ) ; return this ; }
public Map < Integer , Integer > pop Missing ( ) { Hash Map < Integer , Integer > map = new Hash Map < > ( ) ; for ( int i = NUM_ ; i < missing Blocks . length ; i ++ ) { int count = missing Blocks [ i ] ; if ( count > NUM_ ) { map . put ( i , count ) ; } } Arrays . fill ( missing Blocks , NUM_ ) ; return map ; }
public int max ( ) { return max ; }
public void remove All Update Listeners ( ) { if ( m Update Listeners == null ) { return ; } m Update Listeners . clear ( ) ; m Update Listeners = null ; }
private void prepare Coward Soldier ( ) { final Speaker NPC henry = npcs . get ( STR_ ) ; henry . add ( Conversation States . ATTENDING , Conversation Phrases . QUEST MESSAGES , new And Condition ( new Quest Not Completed Condition ( QUEST SLOT ) , new Quest Not In State Condition ( QUEST SLOT , STR_ ) ) , Conversation States . QUEST OFFERED , STR_ , null ) ; henry . add ( Conversation States . ATTENDING , Conversation Phrases . QUEST MESSAGES , new Or Condition ( new Quest Completed Condition ( QUEST SLOT ) , new Quest In State Condition ( QUEST SLOT , STR_ ) ) , Conversation States . ATTENDING , STR_ , null ) ; henry . add ( Conversation States . QUEST OFFERED , Conversation Phrases . YES MESSAGES , null , Conversation States . ATTENDING , STR_ , new Set Quest Action ( QUEST SLOT , STR_ ) ) ; henry . add ( Conversation States . QUEST OFFERED , STR_ , null , Conversation States . QUEST OFFERED , STR_ , null ) ; henry . add ( Conversation States . QUEST OFFERED , STR_ , null , Conversation States . QUEST OFFERED , STR_ , null ) ; henry . add ( Conversation States . QUEST OFFERED , Conversation Phrases . NO MESSAGES , null , Conversation States . ATTENDING , STR_ , new Set Quest And Modify Karma Action ( QUEST SLOT , STR_ , - NUM_ ) ) ; final List < Chat Action > actions = new Linked List < Chat Action > ( ) ; actions . add ( new Increase XP Action ( NUM_ ) ) ; actions . add ( new Drop Infostring Item Action ( STR_ , STR_ ) ) ; actions . add ( new Drop Infostring Item Action ( STR_ , STR_ ) ) ; actions . add ( new Increase Karma Action ( NUM_ ) ) ; actions . add ( new Give Map Action ( false ) ) ; henry . add ( Conversation States . IDLE , Conversation Phrases . GREETING MESSAGES , new And Condition ( new Greeting Matches Name Condition ( henry . get Name ( ) ) , new Quest In State Condition ( QUEST SLOT , STR_ ) , new Player Has Infostring Item With Him Condition ( STR_ , STR_ ) , new Player Has Infostring Item With Him Condition ( STR_ , STR_ ) , new Player Has Infostring Item With Him Condition ( STR_ , STR_ ) ) , Conversation States . ATTENDING , STR_ , new Multiple Actions ( actions ) ) ; henry . add ( Conversation States . IDLE , Conversation Phrases . GREETING MESSAGES , new And Condition ( new Greeting Matches Name Condition ( henry . get Name ( ) ) , new Quest In State Condition ( QUEST SLOT , STR_ ) , new Not Condition ( new And Condition ( new Player Has Infostring Item With Him Condition ( STR_ , STR_ ) , new Player Has Infostring Item With Him Condition ( STR_ , STR_ ) , new Player Has Infostring Item With Him Condition ( STR_ , STR_ ) ) ) ) , Conversation States . ATTENDING , STR_ , null ) ; henry . add ( Conversation States . ATTENDING , Arrays . as List ( STR_ , STR_ , STR_ ) , new Or Condition ( new Quest Completed Condition ( QUEST SLOT ) , new And Condition ( new Henry Quest Completed Condition ( ) , new Player Owns Item Including Bank Condition ( STR_ ) ) ) , Conversation States . ATTENDING , STR_ , null ) ; henry . add ( Conversation States . ATTENDING , Arrays . as List ( STR_ ) , new And Condition ( new Quest Not Completed Condition ( QUEST SLOT ) , new Henry Quest Completed Condition ( ) , new Not Condition ( new Player Owns Item Including Bank Condition ( STR_ ) ) ) , Conversation States . ATTENDING , STR_ , new Give Map Action ( true ) ) ; henry . add ( Conversation States . ATTENDING , Arrays . as List ( STR_ ) , new Henry Quest Not Completed Condition ( ) , Conversation States . ATTENDING , STR_ , null ) ; }
public static Vec back Sub ( Matrix U , Vec y ) { if ( y . length ( ) != U . rows ( ) ) throw new Arithmetic Exception ( STR_ ) ; Vec x = y instanceof Sparse Vector ? new Sparse Vector ( U . cols ( ) ) : new Dense Vector ( U . cols ( ) ) ; final int start = Math . min ( U . rows ( ) , U . cols ( ) ) - NUM_ ; for ( int i = start ; i >= NUM_ ; i -- ) { double x i = y . get ( i ) ; for ( int j = i + NUM_ ; j <= start ; j ++ ) x i -= U . get ( i , j ) * x . get ( j ) ; x i /= U . get ( i , i ) ; if ( Double . is Infinite ( x i ) ) x i = NUM_ ; x . set ( i , x i ) ; } return x ; }
public void create Data Channel ( ) { if ( null != call Reference ) { Respoke Call call = call Reference . get ( ) ; if ( null != call ) { Peer Connection peer Connection = call . get Peer Connection ( ) ; data Channel = peer Connection . create Data Channel ( STR_ , new Data Channel . Init ( ) ) ; data Channel . register Observer ( this ) ; } } }
public Workflow . Method update Consistency Group Read Only State Method ( List < URI > vplex Volume UR Is , Boolean is Read Only ) { return new Workflow . Method ( STR_ , vplex Volume UR Is , is Read Only ) ; }
private Rect calc Bounds ( int index , Paint paint ) { Rect bounds = new Rect ( ) ; Char Sequence title = get Title ( index ) ; bounds . right = ( int ) paint . measure Text ( title , NUM_ , title . length ( ) ) ; bounds . bottom = ( int ) ( paint . descent ( ) - paint . ascent ( ) ) ; return bounds ; }
public boolean is Protected ( ) { return Modifier . is Protected ( flags ) ; }
private static String [ ] fracture ( String str , String sep ) { if ( str . length ( ) == NUM_ ) { return new String [ NUM_ ] ; } Array List < String > res = new Array List < String > ( ) ; int in = NUM_ ; int cur Pos = NUM_ ; int i = str . index Of ( sep ) ; int len = sep . length ( ) ; while ( i != - NUM_ ) { String s = str . substring ( cur Pos , i ) ; res . add ( s ) ; in ++ ; cur Pos = i + len ; i = str . index Of ( sep , cur Pos ) ; } len = str . length ( ) ; if ( cur Pos <= len ) { String s = str . substring ( cur Pos , len ) ; in ++ ; res . add ( s ) ; } return res . to Array ( new String [ in ] ) ; }
public void add Message Listener ( Release Message Listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
public void generate Partition ( Instances data ) throws Exception { if ( m Classifier instanceof Partition Generator ) build Classifier ( data ) ; else throw new Exception ( STR_ + get Classifier Spec ( ) + STR_ ) ; }
protected Object evaluate Single ( Structured Content element , String expr ) { return null ; }
@ Override public synchronized int last Index Of ( Object object ) { return last Index Of ( object , element Count - NUM_ ) ; }
public Colorful Square ( float r , float g , float b , float a ) { Byte Buffer bb = Byte Buffer . allocate Direct ( square Coords . length * NUM_ ) ; bb . order ( Byte Order . native Order ( ) ) ; vertex Buffer = bb . as Float Buffer ( ) ; vertex Buffer . put ( square Coords ) ; vertex Buffer . position ( NUM_ ) ; Byte Buffer dlb = Byte Buffer . allocate Direct ( draw Order . length * NUM_ ) ; dlb . order ( Byte Order . native Order ( ) ) ; draw List Buffer = dlb . as Short Buffer ( ) ; draw List Buffer . put ( draw Order ) ; draw List Buffer . position ( NUM_ ) ; color = new float [ ] { r , g , b , a } ; }
public static int calc Column Width ( J Table table , int col ) { int result ; Table Model data ; int row Count ; int row ; int dec ; Component c ; result = calc Header Width ( table , col ) ; if ( result == - NUM_ ) return result ; data = table . get Model ( ) ; row Count = data . get Row Count ( ) ; dec = ( int ) Math . ceil ( ( double ) row Count / ( double ) MAX ROWS ) ; try { for ( row = row Count - NUM_ ; row >= NUM_ ; row -= dec ) { c = table . prepare Renderer ( table . get Cell Renderer ( row , col ) , row , col ) ; result = Math . max ( result , c . get Preferred Size ( ) . width + NUM_ ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } return result ; }
private void divide ( DBID Array Iter it , double [ ] data , Array List < DBI Ds > idx , int start , int end , int depth , Mean mean ) { final int count = end - start ; if ( depth == NUM_ ) { if ( count > NUM_ ) { Modifiable DBI Ds out = DBID Util . new Hash Set ( count ) ; it . seek ( start ) ; for ( int i = count ; i > NUM_ ; i -- , it . advance ( ) ) { out . add ( it ) ; } idx . add ( out ) ; } else { idx . add ( DBID Util . EMPTYDBIDS ) ; } return ; } else { if ( count > NUM_ ) { mean . reset ( ) ; for ( int i = start ; i < end ; i ++ ) { mean . put ( data [ i ] ) ; } final double m = mean . get Mean ( ) ; int pos = Arrays . binary Search ( data , start , end , m ) ; if ( pos >= NUM_ ) { int opt = ( start + end ) > > NUM_ ; while ( Double . compare ( data [ pos ] , m ) == NUM_ ) { if ( pos < opt ) { pos ++ ; } else if ( pos > opt ) { pos -- ; } else { break ; } } } else { pos = ( - pos - NUM_ ) ; } divide ( it , data , idx , start , pos , depth - NUM_ , mean ) ; divide ( it , data , idx , pos , end , depth - NUM_ , mean ) ; } else { divide ( it , data , idx , start , end , depth - NUM_ , mean ) ; divide ( it , data , idx , start , end , depth - NUM_ , mean ) ; } } }
public synchronized boolean remove ( File file ) { if ( value . remove ( file ) ) { set Value ( value ) ; return true ; } else { return false ; } }
public int add ( GL 10 gl , Drawable background , String text , Paint text Paint , int min Width , int min Height ) { check State ( STATE ADDING , STATE ADDING ) ; boolean draw Background = background != null ; boolean draw Text = ( text != null ) && ( text Paint != null ) ; Rect padding = new Rect ( ) ; if ( draw Background ) { background . get Padding ( padding ) ; min Width = Math . max ( min Width , background . get Minimum Width ( ) ) ; min Height = Math . max ( min Height , background . get Minimum Height ( ) ) ; } int ascent = NUM_ ; int descent = NUM_ ; int measured Text Width = NUM_ ; if ( draw Text ) { ascent = ( int ) Math . ceil ( - text Paint . ascent ( ) ) ; descent = ( int ) Math . ceil ( text Paint . descent ( ) ) ; measured Text Width = ( int ) Math . ceil ( text Paint . measure Text ( text ) ) ; } int text Height = ascent + descent ; int text Width = Math . min ( m Strike Width , measured Text Width ) ; int pad Height = padding . top + padding . bottom ; int pad Width = padding . left + padding . right ; int height = Math . max ( min Height , text Height + pad Height ) ; int width = Math . max ( min Width , text Width + pad Width ) ; int effective Text Height = height - pad Height ; int effective Text Width = width - pad Width ; int center Offset Height = ( effective Text Height - text Height ) / NUM_ ; int center Offset Width = ( effective Text Width - text Width ) / NUM_ ; int u = m U ; int v = m V ; int line Height = m Line Height ; if ( width > m Strike Width ) { width = m Strike Width ; } if ( u + width > m Strike Width ) { u = NUM_ ; v += line Height ; line Height = NUM_ ; } line Height = Math . max ( line Height , height ) ; if ( v + line Height > m Strike Height ) { throw new Illegal Argument Exception ( STR_ ) ; } int u 2 = u + width ; int v Base = v + ascent ; int v 2 = v + height ; if ( draw Background ) { background . set Bounds ( u , v , u + width , v + height ) ; background . draw ( m Canvas ) ; } if ( draw Text ) { m Canvas . draw Text ( text , u + padding . left + center Offset Width , v Base + padding . top + center Offset Height , text Paint ) ; } m U = u + width ; m V = v ; m Line Height = line Height ; m Labels . add ( new Label ( width , height , ascent , u , v + height , width , - height ) ) ; return m Labels . size ( ) - NUM_ ; }
public static String join Gt ( boolean phased , int ... gt ) { final char sep = phased ? PHASED SEPARATOR : UNPHASED SEPARATOR ; switch ( gt . length ) { case NUM_ : return MISSING FIELD ; case NUM_ : return encode Id ( gt [ NUM_ ] ) ; case NUM_ : return encode Id ( gt [ NUM_ ] ) + sep + encode Id ( gt [ NUM_ ] ) ; default : final String Builder sb = new String Builder ( ) ; for ( final int c : gt ) { if ( sb . length ( ) > NUM_ ) { sb . append ( sep ) ; } sb . append ( encode Id ( c ) ) ; } return sb . to String ( ) ; } }
@ Override protected int size Of ( String key , Bitmap Drawable value ) { final int bitmap Size = get Bitmap Size ( value ) / NUM_ ; return bitmap Size == NUM_ ? NUM_ : bitmap Size ; }
private int substitute ( final Str Builder buf , final int offset , final int length , List < String > prior Variables ) { final Str Matcher pfx Matcher = get Variable Prefix Matcher ( ) ; final Str Matcher suff Matcher = get Variable Suffix Matcher ( ) ; final char escape = get Escape Char ( ) ; final Str Matcher value Delim Matcher = get Value Delimiter Matcher ( ) ; final boolean substitution In Variables Enabled = is Enable Substitution In Variables ( ) ; final boolean top = prior Variables == null ; boolean altered = false ; int length Change = NUM_ ; char [ ] chars = buf . buffer ; int buf End = offset + length ; int pos = offset ; while ( pos < buf End ) { final int start Match Len = pfx Matcher . is Match ( chars , pos , offset , buf End ) ; if ( start Match Len == NUM_ ) { pos ++ ; } else { if ( pos > offset && chars [ pos - NUM_ ] == escape ) { buf . delete Char At ( pos - NUM_ ) ; chars = buf . buffer ; length Change -- ; altered = true ; buf End -- ; } else { final int start Pos = pos ; pos += start Match Len ; int end Match Len = NUM_ ; int nested Var Count = NUM_ ; while ( pos < buf End ) { if ( substitution In Variables Enabled && ( end Match Len = pfx Matcher . is Match ( chars , pos , offset , buf End ) ) != NUM_ ) { nested Var Count ++ ; pos += end Match Len ; continue ; } end Match Len = suff Matcher . is Match ( chars , pos , offset , buf End ) ; if ( end Match Len == NUM_ ) { pos ++ ; } else { if ( nested Var Count == NUM_ ) { String var Name Expr = new String ( chars , start Pos + start Match Len , pos - start Pos - start Match Len ) ; if ( substitution In Variables Enabled ) { final Str Builder buf Name = new Str Builder ( var Name Expr ) ; substitute ( buf Name , NUM_ , buf Name . length ( ) ) ; var Name Expr = buf Name . to String ( ) ; } pos += end Match Len ; final int end Pos = pos ; String var Name = var Name Expr ; String var Default Value = null ; if ( value Delim Matcher != null ) { final char [ ] var Name Expr Chars = var Name Expr . to Char Array ( ) ; int value Delimiter Match Len = NUM_ ; for ( int i = NUM_ ; i < var Name Expr Chars . length ; i ++ ) { if ( ! substitution In Variables Enabled && pfx Matcher . is Match ( var Name Expr Chars , i , i , var Name Expr Chars . length ) != NUM_ ) { break ; } if ( ( value Delimiter Match Len = value Delim Matcher . is Match ( var Name Expr Chars , i ) ) != NUM_ ) { var Name = var Name Expr . substring ( NUM_ , i ) ; var Default Value = var Name Expr . substring ( i + value Delimiter Match Len ) ; break ; } } } if ( prior Variables == null ) { prior Variables = new Array List < String > ( ) ; prior Variables . add ( new String ( chars , offset , length ) ) ; } check Cyclic Substitution ( var Name , prior Variables ) ; prior Variables . add ( var Name ) ; String var Value = resolve Variable ( var Name , buf , start Pos , end Pos ) ; if ( var Value == null ) { var Value = var Default Value ; } if ( var Value != null ) { final int var Len = var Value . length ( ) ; buf . replace ( start Pos , end Pos , var Value ) ; altered = true ; int change = substitute ( buf , start Pos , var Len , prior Variables ) ; change = change + var Len - ( end Pos - start Pos ) ; pos += change ; buf End += change ; length Change += change ; chars = buf . buffer ; } prior Variables . remove ( prior Variables . size ( ) - NUM_ ) ; break ; } nested Var Count -- ; pos += end Match Len ; } } } } } if ( top ) { return altered ? NUM_ : NUM_ ; } return length Change ; }
private void update Base Matrix ( Drawable d ) { Image View image View = get Image View ( ) ; if ( null == image View || null == d ) { return ; } final float view Width = image View . get Width ( ) ; final float view Height = image View . get Height ( ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; m Base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( m Scale Type == Scale Type . CENTER ) { m Base Matrix . post Translate ( ( view Width - drawable Width ) / NUM_ , ( view Height - drawable Height ) / NUM_ ) ; } else if ( m Scale Type == Scale Type . CENTER CROP ) { float scale = Math . max ( width Scale , height Scale ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM_ , ( view Height - drawable Height * scale ) / NUM_ ) ; } else if ( m Scale Type == Scale Type . CENTER INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( width Scale , height Scale ) ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM_ , ( view Height - drawable Height * scale ) / NUM_ ) ; } else { Rect F m Temp Src = new Rect F ( NUM_ , NUM_ , drawable Width , drawable Height ) ; Rect F m Temp Dst = new Rect F ( NUM_ , NUM_ , view Width , view Height ) ; switch ( m Scale Type ) { case FIT CENTER : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . CENTER ) ; break ; case FIT START : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . START ) ; break ; case FIT END : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . END ) ; break ; case FIT XY : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STR_ + start Id ) ; if ( ACTION SYNC FOLDER . equals ( intent . get Action ( ) ) ) { if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA REMOTE PATH ) ) { Log OC . e ( TAG , STR_ ) ; return START NOT STICKY ; } Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; String remote Path = intent . get String Extra ( EXTRA REMOTE PATH ) ; Pair < Account , String > item Sync Key = new Pair < Account , String > ( account , remote Path ) ; Pair < Target , Remote Operation > item To Queue = new Operation ( intent ) ; if ( item To Queue != null ) { m Sync Folder Handler . add ( account , remote Path , ( Synchronize Folder Operation ) item To Queue . second ) ; Message msg = m Sync Folder Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = item Sync Key ; m Sync Folder Handler . send Message ( msg ) ; } } else { Message msg = m Operations Handler . obtain Message ( ) ; msg . arg 1 = start Id ; m Operations Handler . send Message ( msg ) ; } return START NOT STICKY ; }
private byte [ ] update No Dictionary Start And End Key ( byte [ ] key ) { if ( key . length == NUM_ ) { return key ; } Byte Buffer buffer = Byte Buffer . wrap ( key , NUM_ , key . length - NUM_ ) ; Byte Buffer output = Byte Buffer . allocate ( key . length - NUM_ ) ; short number Of Byte To Stor Length = NUM_ ; for ( int i = NUM_ ; i < number Of No Dictionary Column ; i ++ ) { output . put Short ( ( short ) ( buffer . get Short ( ) - number Of Byte To Stor Length ) ) ; } while ( buffer . has Remaining ( ) ) { output . put ( buffer . get ( ) ) ; } output . rewind ( ) ; return output . array ( ) ; }
protected final boolean init ( ) throws Ade Exception { boolean initialized ; final Properties prop = new Properties ( ) ; try ( File Input Stream fis = new File Input Stream ( properties File Name ) ) { prop . load ( fis ) ; initialized = true ; } catch ( File Not Found Exception e ) { throw new Ade Ext Usage Exception ( STR_ + properties File Name + STR_ , e ) ; } catch ( IO Exception e ) { throw new Ade Ext Usage Exception ( STR_ + properties File Name + STR_ , e ) ; } catch ( Exception e ) { throw new Ade Ext Usage Exception ( STR_ + properties File Name + STR_ , e ) ; } return initialized ; }
void create Edges ( Integer [ ] v ) { graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] ) ; }
public Task Resource Rep host Vcenter Unassign ( URI host Id , URI event Id ) { return host Cluster Change ( host Id , Null Column Value Getter . get Null URI ( ) , Null Column Value Getter . get Null URI ( ) , true , event Id ) ; }
public String print Insts ( int start Idx , int end Idx ) { String Buffer bf = new String Buffer ( ) ; try { bf . append ( STR_ ) ; for ( int i = start Idx ; i <= end Idx ; i ++ ) { if ( i == start Idx ) { bf . append ( STR_ + m Inst List [ i ] ) ; } else { bf . append ( STR_ + m Inst List [ i ] ) ; } } } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } return bf . to String ( ) ; }
public static byte [ ] as Bytes ( String basic String ) { final byte [ ] b = new byte [ basic String . length ( ) ] ; for ( int i = NUM_ ; i < b . length ; ++ i ) { b [ i ] = ( byte ) basic String . char At ( i ) ; } return b ; }
public static String key For Image ( String image Path ) { String key = null ; try { Message Digest message Digest = Message Digest . get Instance ( STR_ ) ; message Digest . update ( image Path . get Bytes ( ) ) ; key = byte To Hex ( message Digest . digest ( ) ) ; } catch ( No Such Algorithm Exception e ) { e . print Stack Trace ( ) ; } return key ; }
private void context Menu ( Logical Visualization Ex visualization , Mouse Event mouse Event ) { J Component menu = new J Popup Menu ( ) ; J Menu Item restore = new J Menu Item ( STR_ ) ; restore . add Action Listener ( null ) ; J Menu Item collapse = new J Menu Item ( STR_ ) ; collapse . add Action Listener ( null ) ; J Menu Item expand = new J Menu Item ( STR_ ) ; expand . add Action Listener ( null ) ; menu . add ( restore ) ; menu . add ( collapse ) ; menu . add ( expand ) ; get Visibility Menu Items ( menu , visualization ) ; if ( menu instanceof J Popup Menu ) { J Popup Menu popup = ( J Popup Menu ) menu ; popup . set Location ( mouse Event . get Location On Screen ( ) ) ; popup . set Invoker ( get Display ( ) ) ; popup . set Visible ( true ) ; popup . request Focus ( ) ; } }
private String pick Lower Or Upper ( String input Mode ) { int pos = get Cursor Position ( ) - NUM_ ; if ( pending Commit ) { pos -- ; } String text = get Text ( ) ; if ( pos >= text . length ( ) ) { pos = text . length ( ) - NUM_ ; } while ( pos > - NUM_ ) { if ( text . char At ( pos ) == STR_ ) { return input Mode . to Upper Case ( ) ; } if ( text . char At ( pos ) != STR_ ) { return input Mode . to Lower Case ( ) ; } pos -- ; } return input Mode . to Upper Case ( ) ; }
public void children Added ( Bean Context Membership Event bcme ) { find And Init ( bcme . iterator ( ) ) ; }
public void init ( Iterator iter , Comparator c ) { m tuples . clear ( ) ; m cmp = c ; while ( iter . has Next ( ) ) { Tuple t = ( Tuple ) iter . next ( ) ; m tuples . add ( t ) ; } Collections . sort ( m tuples , m cmp ) ; m iter = m tuples . iterator ( ) ; }
public Instances transform ( Instances D ) throws Exception { int L = D . class Index ( ) ; d = D . num Attributes ( ) - L ; int keep [ ] = A . append ( this . pa Y , j ) ; Arrays . sort ( keep ) ; int remv [ ] = A . invert ( keep , L ) ; Arrays . sort ( remv ) ; map = new int [ L ] ; for ( int j = NUM_ ; j < L ; j ++ ) { map [ j ] = Arrays . binary Search ( keep , j ) ; } Instances D = F . remove ( new Instances ( D ) , remv , false ) ; D . set Class Index ( map [ this . j ] ) ; return D ; }
private void validate Mask And Place Volumes ( Storage System array , URI varray URI , Map < URI , Export Mask > mask Set , Set < URI > invalid Masks , Export Mask mask , Export Mask Placement Descriptor placement Descriptor , Map < URI , Volume > volume Map , String log Msg ) { if ( ! is Open Stack ( array ) ) { log . info ( log Msg ) ; if ( V Plex Back End Orchestrator Util . validate Export Mask ( varray URI , initiator Port Map , mask , invalid Masks , director To Initiator Ids , id To Initiator Map , db Client , coordinator , port Wwn To Cluster Map ) ) { mask Set . put ( mask . get Id ( ) , mask ) ; placement Descriptor . place Volumes ( mask . get Id ( ) , volume Map ) ; } for ( URI invalid Mask : invalid Masks ) { placement Descriptor . invalidate Export Mask ( invalid Mask ) ; } } else { mask Set . put ( mask . get Id ( ) , mask ) ; placement Descriptor . place Volumes ( mask . get Id ( ) , volume Map ) ; } }
private boolean is Primal Feasible ( ) { double [ ] x = row ( ) ; double sum = NUM_ ; for ( int j = NUM_ ; j < n ; j ++ ) { if ( x [ j ] < NUM_ ) { Std Out . println ( STR_ ) ; Std Out . printf ( STR_ , j , x [ j ] ) ; return false ; } sum += x [ j ] ; } if ( Math . abs ( sum - NUM_ ) > EPSILON ) { Std Out . println ( STR_ ) ; Std Out . println ( STR_ + sum ) ; return false ; } return true ; }
public static Map < UUID , Collection < Cluster Node > > neighbors ( Collection < Cluster Node > top Snapshot ) { Map < String , Collection < Cluster Node > > mac Map = new Hash Map < > ( top Snapshot . size ( ) , NUM_ ) ; for ( Cluster Node node : top Snapshot ) { String macs = node . attribute ( Ignite Node Attributes . ATTR MACS ) ; Collection < Cluster Node > nodes = mac Map . get ( macs ) ; if ( nodes == null ) mac Map . put ( macs , nodes = new Hash Set < > ( ) ) ; nodes . add ( node ) ; } Map < UUID , Collection < Cluster Node > > neighbors = new Hash Map < > ( top Snapshot . size ( ) , NUM_ ) ; for ( Collection < Cluster Node > group : mac Map . values ( ) ) for ( Cluster Node node : group ) neighbors . put ( node . id ( ) , group ) ; return neighbors ; }
public Lexer ( String s ) { init Keywords ( ) ; tok = new Stream Tokenizer ( new String Reader ( s ) ) ; tok . word Chars ( STR_ , STR_ ) ; tok . ordinary Char ( STR_ ) ; tok . lower Case Mode ( true ) ; next Token ( ) ; }
@ Override public Object remove ( Object key ) { Entry tab [ ] = table ; if ( key != null ) { int hash = System . identity Hash Code ( key ) ; int index = ( hash & NUM_ ) % tab . length ; for ( Entry e = tab [ index ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( ( e . hash == hash ) && key == e . key ) { mod Count ++ ; if ( prev != null ) prev . next = e . next ; else tab [ index ] = e . next ; count -- ; Object old Value = e . value ; e . value = null ; return old Value ; } } } else { for ( Entry e = tab [ NUM_ ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( e . key == null ) { mod Count ++ ; if ( prev != null ) prev . next = e . next ; else tab [ NUM_ ] = e . next ; count -- ; Object old Value = e . value ; e . value = null ; return old Value ; } } } return null ; }
public void add Files ( Collection < String > files ) { check File Names ( files ) ; for ( String f : files ) { set Files . add ( named For This Segment ( f ) ) ; } }
public static String Indent ( String str ) { cur Indent [ indent Depth + NUM_ ] = cur Indent [ indent Depth ] + str . length ( ) ; indent Depth = indent Depth + NUM_ ; return str ; }
public Builder timeout ( long timeout , Time Unit time Unit ) { this . timeout = time Unit . to Millis ( timeout ) ; return this ; }
public void add Mapping ( Matcher < Request > request Matcher , Response Source response Source ) { mappings . add First ( new Matcher Response Source Pair ( request Matcher , response Source ) ) ; }
Output Stream write Channel ( int channel ) throws IO Exception { while ( os != null ) { boolean can Write = false ; synchronized ( WRITE LOCK ) { if ( ! is Write Locked ) { is Write Locked = true ; can Write = true ; } else { try { WRITE LOCK . wait ( NUM_ ) ; } catch ( Exception e ) { } } } if ( can Write ) { os . write ( STR_ ) ; os . write ( channel > > NUM_ ) ; os . write ( channel ) ; return os ; } } return null ; }
public static String escape Text ( String text ) { String result = text . replace ( STR_ , STR_ ) ; return STR_ + result + STR_ ; }
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m evaluate Thread != null && m evaluate Thread . is Alive ( ) ) { wait ( ) ; } } catch ( Interrupted Exception ex ) { } } else { notify All ( ) ; } }
public void run ( ) { int number Of Lines = highlighter . get Number Of Lines ( ) ; cached Line Done = new boolean [ number Of Lines ] ; parser . clear Cache ( number Of Lines ) ; boolean skipbreakpoint = false ; if ( is Break Point ( data . get Instruction Pointer ( ) ) ) { skipbreakpoint = true ; } int line Number = data . get Instruction Pointer ( ) ; while ( ( line Number < number Of Lines ) ) { if ( ! running ) { break ; } if ( is Break Point ( line Number ) && ! skipbreakpoint ) { break ; } else if ( is Break Point ( line Number ) && skipbreakpoint ) { skipbreakpoint = false ; } if ( ( line Number < number Of Lines ) ) { data . set Instruction Pointer ( line Number + NUM_ ) ; try { execute Line Number ( line Number , true ) ; } catch ( Exception ex ) { update Execution Mark ( ) ; scroll To Execution Mark ( ) ; Error Label . set Text ( ex . to String ( ) + STR_ ) ; ex . print Stack Trace ( ) ; break ; } } line Number = data . get Instruction Pointer ( ) ; } data . update Dirty ( ) ; running = false ; Thread . yield ( ) ; update All ( ) ; frame . check Button States ( ) ; running Thread = null ; }
public void add Allowed ( Class < ? > c , String display Name ) { Hash Set < String > list ; list = m Allowed . get ( c ) ; if ( list == null ) { list = new Hash Set < String > ( ) ; m Allowed . put ( c , list ) ; } list . add ( display Name ) ; }
protected void validate State ( State current ) { Validation Utils . validate State ( current ) ; check Not Null ( current . execution State , STR_ ) ; check Is Positive Number ( current . triggers Success , STR_ ) ; check Is Positive Number ( current . triggers Error , STR_ ) ; }
public Locale read ( String locale ) throws Exception { String [ ] list = pattern . split ( locale ) ; if ( list . length < NUM_ ) { throw new Invalid Format Exception ( STR_ , locale ) ; } return read ( list ) ; }
public void recalculate Path ( ) { if ( target Vector != null ) { delta Path X = target Vector . x Pos - start Pos . x Pos ; delta Path Y = target Vector . y Pos - start Pos . y Pos ; delta Path Z = target Vector . z Pos - start Pos . z Pos ; flat Distance = Vector 2 . distance ( new Vector 2 ( start Pos ) , new Vector 2 ( target Vector ) ) ; max Height = NUM_ + ( int ) ( flat Distance * NUM_ ) ; missile Flight Time = ( float ) Math . max ( NUM_ , NUM_ * flat Distance ) - airborne Ticks ; acceleration = ( float ) max Height * NUM_ / ( missile Flight Time * missile Flight Time ) ; } }
public void register Receiver ( Broadcast Receiver receiver , Intent Filter filter ) { synchronized ( m Receivers ) { Receiver Record entry = new Receiver Record ( filter , receiver ) ; Array List < Intent Filter > filters = m Receivers . get ( receiver ) ; if ( filters == null ) { filters = new Array List < Intent Filter > ( NUM_ ) ; m Receivers . put ( receiver , filters ) ; } filters . add ( filter ) ; for ( int i = NUM_ ; i < filter . count Actions ( ) ; i ++ ) { String action = filter . get Action ( i ) ; Array List < Receiver Record > entries = m Actions . get ( action ) ; if ( entries == null ) { entries = new Array List < Receiver Record > ( NUM_ ) ; m Actions . put ( action , entries ) ; } entries . add ( entry ) ; } } }
private Point 2 D calculate Range Marker Text Anchor Point ( Graphics 2 D g 2 , Plot Orientation orientation , Rectangle 2 D data Area , Rectangle 2 D marker Area , Rectangle Insets marker Offset , Length Adjustment Type label Offset For Range , Rectangle Anchor anchor ) { Rectangle 2 D anchor Rect = null ; if ( orientation == Plot Orientation . HORIZONTAL ) { anchor Rect = marker Offset . create Adjusted Rectangle ( marker Area , label Offset For Range , Length Adjustment Type . CONTRACT ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { anchor Rect = marker Offset . create Adjusted Rectangle ( marker Area , Length Adjustment Type . CONTRACT , label Offset For Range ) ; } return Rectangle Anchor . coordinates ( anchor Rect , anchor ) ; }
public void action Performed ( Action Event e ) { Object source = e . get Source ( ) ; String command = e . get Action Command ( ) ; String inter String ; Paint tmp Paint ; if ( command == Line Color Command && line Paint instanceof Color ) { inter String = i 18 n . get ( Drawing Attributes . class , STR_ , STR_ ) ; tmp Paint = get New Paint ( ( Component ) source , inter String , ( Color ) line Paint ) ; if ( tmp Paint != null ) { set Line Paint ( tmp Paint ) ; } } else if ( command == Fill Color Command && fill Paint instanceof Color ) { inter String = i 18 n . get ( Drawing Attributes . class , STR_ , STR_ ) ; tmp Paint = get New Paint ( ( Component ) source , inter String , ( Color ) fill Paint ) ; if ( tmp Paint != null ) { set Fill Paint ( tmp Paint ) ; } } else if ( command == Select Color Command && select Paint instanceof Color ) { inter String = i 18 n . get ( Drawing Attributes . class , STR_ , STR_ ) ; tmp Paint = get New Paint ( ( Component ) source , inter String , ( Color ) select Paint ) ; if ( tmp Paint != null ) { set Select Paint ( tmp Paint ) ; } } else if ( command == Matting Color Command && matting Paint instanceof Color ) { inter String = i 18 n . get ( Drawing Attributes . class , STR_ , STR_ ) ; tmp Paint = get New Paint ( ( Component ) source , inter String , ( Color ) matting Paint ) ; if ( tmp Paint != null ) { set Matting Paint ( tmp Paint ) ; } } else if ( command == Matted Command ) { set Matted ( matted Enabled Item . get State ( ) ) ; } else { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + command ) ; } } }
static private String INT Max Plus ( ) { long temp Value = Integer . MAX VALUE + NUM_ ; return String . value Of ( temp Value ) ; }
public Node parse Text ( String text ) throws IO Exception , SAX Exception { return parse ( new String Reader ( text ) ) ; }
public static boolean is Valid Name ( String name ) { if ( name == null ) { return false ; } return name . length ( ) > NUM_ ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! ( obj instanceof IP Address Name ) ) return false ; IP Address Name other Name = ( IP Address Name ) obj ; byte [ ] other = other Name . address ; if ( other . length != address . length ) return false ; if ( address . length == NUM_ || address . length == NUM_ ) { int mask Len = address . length / NUM_ ; for ( int i = NUM_ ; i < mask Len ; i ++ ) { byte masked This = ( byte ) ( address [ i ] & address [ i + mask Len ] ) ; byte masked Other = ( byte ) ( other [ i ] & other [ i + mask Len ] ) ; if ( masked This != masked Other ) { return false ; } } for ( int i = mask Len ; i < address . length ; i ++ ) if ( address [ i ] != other [ i ] ) return false ; return true ; } else { return Arrays . equals ( other , address ) ; } }
public void add Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . add Vetoable Change Listener ( property Name , in vcl ) ; }
public default Independent Distribution query Prob ( B Network network , String query Var ) { return query Prob ( network , query Var , new Assignment ( ) ) ; }
public int prune ( double [ ] alphas , double [ ] errors , Instances test ) throws Exception { Vector < LMT Node > node List ; Compare Node comparator = new Compare Node ( ) ; tree Errors ( ) ; calculate Alphas ( ) ; node List = get Nodes ( ) ; boolean prune = ( node List . size ( ) > NUM_ ) ; alphas [ NUM_ ] = NUM_ ; Evaluation eval ; if ( errors != null ) { eval = new Evaluation ( test ) ; eval . evaluate Model ( this , test ) ; errors [ NUM_ ] = eval . error Rate ( ) ; } int iteration = NUM_ ; while ( prune ) { iteration ++ ; LMT Node node To Prune = Collections . min ( node List , comparator ) ; node To Prune . m is Leaf = true ; alphas [ iteration ] = node To Prune . m alpha ; if ( errors != null ) { eval = new Evaluation ( test ) ; eval . evaluate Model ( this , test ) ; errors [ iteration ] = eval . error Rate ( ) ; } tree Errors ( ) ; calculate Alphas ( ) ; node List = get Nodes ( ) ; prune = ( node List . size ( ) > NUM_ ) ; } alphas [ iteration + NUM_ ] = NUM_ ; return iteration ; }
public void append To Nal Unit ( byte [ ] data , int offset , int limit ) { if ( ! is Filling ) { return ; } int read Length = limit - offset ; if ( nal Data . length < nal Length + read Length ) { nal Data = Arrays . copy Of ( nal Data , ( nal Length + read Length ) * NUM_ ) ; } System . arraycopy ( data , offset , nal Data , nal Length , read Length ) ; nal Length += read Length ; }
private void update System Icon ( ) { Window window = get Window ( ) ; if ( window == null ) { system Icon = null ; return ; } java . util . List < Image > icons = window . get Icon Images ( ) ; assert icons != null ; if ( icons . size ( ) == NUM_ ) { system Icon = null ; } else if ( icons . size ( ) == NUM_ ) { system Icon = icons . get ( NUM_ ) ; } else { system Icon = Sun Toolkit . get Scaled Icon Image ( icons , IMAGE WIDTH , IMAGE HEIGHT ) ; } }
public static void shutdown Forcely ( int status ) throws Exception { Class z = Class . for Name ( STR_ ) ; Method exit = z . get Declared Method ( STR_ , int . class ) ; exit . set Accessible ( true ) ; exit . invoke ( z , status ) ; }
public void write Data ( Data Output dout ) throws IO Exception { dout . write Short ( reference ) ; dout . write Short ( bit Count ) ; }
@ Override public List < Period > generate Periods ( Date Time Unit date Time Unit ) { Calendar cal = get Calendar ( ) ; date Time Unit . set Month ( NUM_ ) ; date Time Unit . set Day ( NUM_ ) ; List < Period > periods = Lists . new Array List ( ) ; int year = date Time Unit . get Year ( ) ; while ( date Time Unit . get Year ( ) == year ) { periods . add ( create Period ( date Time Unit , cal ) ) ; date Time Unit = cal . plus Months ( date Time Unit , NUM_ ) ; } return periods ; }
@ Visible For Testing protected State build Patch ( Task State . Task Stage stage , Task State . Sub Stage sub Stage ) { return build Patch ( stage , sub Stage , ( Throwable ) null ) ; }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { s . default Write Object ( ) ; s . write Int ( values . size ( ) ) ; for ( int i = NUM_ ; i < values . size ( ) ; i ++ ) { s . write Object ( values . element At ( i ) ) ; } }
@ Rpc Method public void transfer Image ( String image Id , String source , String destination , Server Address destination Host , Async Method Callback < Host . Async Client . copy image call > handler ) throws Rpc Exception { ensure Client ( ) ; Transfer Image Request transfer Image Request = new Transfer Image Request ( ) ; transfer Image Request . set Destination datastore id ( destination ) ; transfer Image Request . set Destination host ( destination Host ) ; transfer Image Request . set Source datastore id ( source ) ; transfer Image Request . set Source image id ( image Id ) ; client Proxy . set Timeout ( TRANSFER IMAGE TIMEOUT MS ) ; logger . info ( STR_ , get Host Ip ( ) , transfer Image Request ) ; try { client Proxy . transfer image ( transfer Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
private static J Free Chart create Chart ( ) { XY Series series 1 = new XY Series ( STR_ ) ; series 1 . add ( NUM_ , NUM_ ) ; series 1 . add ( NUM_ , NUM_ ) ; series 1 . add ( NUM_ , NUM_ ) ; XY Dataset dataset = new XY Series Collection ( series 1 ) ; return Chart Factory . create XY Area Chart ( STR_ , STR_ , STR_ , dataset ) ; }
public void add Table Value Change Listener ( Table Value Change Listener listener ) { if ( listener == null ) { return ; } m listeners . add ( listener ) ; }
public Update Info ( String feature Id ) { this . feature Id = feature Id ; }
private void log Min ( String type , String value , String arg , long amount ) { Key key = new Key ( type , value , arg + MINIMUM INDICATOR ) ; synchronized ( counts ) { Long old Min = counts . get ( key ) ; if ( old Min == null ) { old Min = amount ; } counts . put ( key , Math . min ( old Min , amount ) ) ; } }
public boolean append items ( String p button name , String p window title , java . util . Collection < Brd Item > p items ) { java . util . Collection < Printable Info > object list = new java . util . Linked List < Printable Info > ( ) ; object list . add All ( p items ) ; return append objects ( p button name , p window title , object list ) ; }
private static Dex Class Loader create Instance ( Configuration config ) { File file 1 ; File file 2 ; switch ( config ) { case ONE DEX : file 1 = DEX FILE ; file 2 = null ; break ; case ONE JAR : file 1 = JAR FILE ; file 2 = null ; break ; case TWO DEX : file 1 = DEX FILE ; file 2 = DEX 2 FILE ; break ; case TWO JAR : file 1 = JAR FILE ; file 2 = JAR 2 FILE ; break ; default : throw new Assertion Error ( STR_ ) ; } String path = file 1 . get Absolute Path ( ) ; if ( file 2 != null ) { path += File . path Separator + file 2 . get Absolute Path ( ) ; } return new Dex Class Loader ( path , OPTIMIZED DIR . get Absolute Path ( ) , null , Class Loader . get System Class Loader ( ) ) ; }
public void add Bridge Idle Debug Listener ( Not Thread Safe Bridge Idle Debug Listener listener ) { m Bridge Idle Listeners . add ( listener ) ; }
public static void register Tile Codec ( int comp , XTIFF Tile Codec codec ) { tile Codecs . put ( new Integer ( comp ) , codec ) ; }
public Auth Properties Model Impl ( Http Servlet Request req , Map map ) { super ( req , map ) ; current Realm = ( String ) map . get ( AM Admin Constants . CURRENT REALM ) ; if ( current Realm == null ) { current Realm = STR_ ; } }
protected boolean add New Icon ( String name ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + icon Map . size ( ) ) ; } if ( name == null || name . length ( ) == NUM_ ) { J Option Pane . show Message Dialog ( parent . palette Frame , Bundle . get Message ( STR_ ) , Bundle . get Message ( STR_ ) , J Option Pane . WARNING MESSAGE ) ; return false ; } else if ( icon Map . get ( name ) != null ) { J Option Pane . show Message Dialog ( parent . palette Frame , Bundle . get Message ( STR_ , name ) , Bundle . get Message ( STR_ ) , J Option Pane . WARNING MESSAGE ) ; return false ; } String file Name = STR_ ; Named Icon icon = new jmri . jmrit . catalog . Named Icon ( file Name , file Name ) ; icon Map . put ( name , icon ) ; return true ; }
public static void main ( String args [ ] ) { logger . info ( STR_ ) ; String str = STR_ ; byte [ ] ba = str . get Bytes ( ) ; logger . info ( STR_ + str ) ; logger . info ( STR_ + byte Array To Hex String ( ba ) ) ; logger . info ( STR_ + byte Array To Hex String ( ba , NUM_ , ba . length ) ) ; logger . info ( STR_ + string To Hex String ( str ) ) ; logger . info ( STR_ ) ; int i = - NUM_ ; logger . info ( STR_ + i + STR_ + int To Hex String ( i ) ) ; logger . info ( STR_ ) ; byte [ ] ba To Convert = { ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ , ( byte ) NUM_ } ; logger . info ( STR_ + to Hex String ( ba To Convert ) + STR_ + byte Array To Binary String ( ba To Convert ) ) ; set Byte Separator ( STR_ ) ; logger . info ( STR_ + to Hex String ( ba To Convert ) + STR_ + byte Array To Binary String ( ba To Convert ) ) ; set Byte Separator ( STR_ ) ; set With Byte Separator ( true ) ; logger . info ( STR_ + to Hex String ( ba To Convert ) + STR_ + byte Array To Binary String ( ba To Convert ) ) ; char [ ] bd = { STR_ , STR_ } ; try { set Bit Digits ( bd ) ; } catch ( Exception ex ) { logger . debug ( STR_ , ex ) ; } logger . info ( STR_ + to Hex String ( ba To Convert ) + STR_ + byte Array To Binary String ( ba To Convert ) ) ; set Bit Digits ( STR_ , STR_ ) ; logger . info ( STR_ ) ; for ( int i To Convert = - NUM_ ; i To Convert < NUM_ ; i To Convert ++ ) { logger . info ( STR_ + i To Convert + STR_ + Hex Dump . to Binary String ( i To Convert ) ) ; byte [ ] ba Conv Int = new byte [ NUM_ ] ; ba Conv Int = Hex Dump . to Byte Array ( i To Convert ) ; logger . info ( STR_ + Hex Dump . to Binary String ( ba Conv Int ) ) ; } logger . info ( STR_ ) ; i = - NUM_ ; logger . info ( i + STR_ + to Hex String ( i ) + STR_ + to Binary String ( i ) ) ; i ++ ; logger . info ( i + STR_ + to Hex String ( i ) + STR_ + to Binary String ( i ) ) ; logger . info ( STR_ ) ; long l = NUM_ ; logger . info ( l + STR_ + to Hex String ( l ) + STR_ + to Binary String ( l ) ) ; java . util . Random rnd = new java . util . Random ( ) ; l = rnd . next Long ( ) ; logger . info ( l + STR_ + to Hex String ( l ) + STR_ + to Binary String ( l ) ) ; logger . info ( STR_ ) ; short s = NUM_ ; logger . info ( s + STR_ + to Hex String ( s ) + STR_ + to Binary String ( s ) ) ; rnd = new java . util . Random ( ) ; s = ( short ) rnd . next Int ( ) ; logger . info ( s + STR_ + to Hex String ( s ) + STR_ + to Binary String ( s ) ) ; logger . info ( STR_ ) ; String str To Convert = STR_ ; logger . info ( str To Convert + STR_ + string To Hex String ( str To Convert ) ) ; logger . info ( STR_ ) ; logger . info ( STR_ + to Hex String ( ba ) ) ; }
private void first Tuple ( Object input Event ) { if ( first Tuple Processed ) { return ; } first Tuple Processed = true ; Class < ? > clazz = input Event . get Class ( ) ; getters = GPO Utils . build GPO Getters ( field To Getter , schema . get Values Descriptor ( ) , clazz ) ; }
public void check ( ) throws Erlang Version Exception { String erlang Version ; try { erlang Version = erlang Shell . get Erlang Version ( ) ; LOGGER . debug ( STR_ , erlang Version ) ; } catch ( Erlang Shell Exception e ) { throw new Erlang Version Exception ( STR_ , e ) ; } if ( min Erlang Version == null ) { LOGGER . debug ( STR_ ) ; return ; } else { LOGGER . debug ( STR_ , min Erlang Version ) ; } double expected ; double actual ; try { expected = parse ( min Erlang Version ) ; actual = parse ( erlang Version ) ; } catch ( Runtime Exception e ) { LOGGER . warn ( STR_ + min Erlang Version + STR_ + erlang Version + STR_ ) ; return ; } if ( actual < expected ) { throw new Erlang Version Exception ( String . format ( STR_ , min Erlang Version , erlang Version ) ) ; } }
void free Write Lock ( ) { synchronized ( WRITE LOCK ) { is Write Locked = false ; WRITE LOCK . notify All ( ) ; } }
public void add Listener ( AM Client Data Listener cdl ) { synchronized ( listeners ) { if ( ! listeners . contains ( cdl ) ) { listeners . add ( cdl ) ; } } }
public void cancel Throttle Request ( int address , Throttle Listener l ) { boolean is Long = true ; if ( can Be Short Address ( address ) ) { is Long = false ; } cancel Throttle Request ( address , is Long , l ) ; }
public void close ( ) throws IO Exception { if ( input != null ) { input . close ( ) ; input = null ; } }
protected void write Column Default Value Stmt ( Table table , Column column , String Builder ddl ) { Object parsed Default = column . get Parsed Default Value ( ) ; if ( parsed Default != null ) { if ( ! database Info . is Default Values For Long Types Supported ( ) && ( ( column . get Mapped Type Code ( ) == Types . LONGVARBINARY ) || ( column . get Mapped Type Code ( ) == Types . LONGVARCHAR ) ) ) { throw new Model Exception ( STR_ ) ; } if ( is Valid Default Value ( column . get Default Value ( ) , column . get Mapped Type Code ( ) ) ) { ddl . append ( STR_ ) ; write Column Default Value ( table , column , ddl ) ; } } else if ( database Info . is Default Value Used For Identity Spec ( ) && column . is Auto Increment ( ) ) { ddl . append ( STR_ ) ; write Column Default Value ( table , column , ddl ) ; } else if ( ! String Utils . is Blank ( column . get Default Value ( ) ) ) { ddl . append ( STR_ ) ; write Column Default Value ( table , column , ddl ) ; } }
private int detect Type ( String file Name ) throws IO Exception , FTP Illegal Reply Exception , FTP Exception { int start = file Name . last Index Of ( STR_ ) + NUM_ ; int stop = file Name . length ( ) ; if ( start > NUM_ && start < stop - NUM_ ) { String ext = file Name . substring ( start , stop ) ; ext = ext . to Lower Case ( ) ; if ( textual Extension Recognizer . is Textual Ext ( ext ) ) { return TYPE TEXTUAL ; } else { return TYPE BINARY ; } } else { return TYPE BINARY ; } }
public static void write One Block To Xml ( Block to Serialize , Output Stream os ) throws Blockly Serializer Exception { List < Block > temp = new Array List < > ( ) ; temp . add ( to Serialize ) ; write To Xml ( temp , os ) ; }
public Builder add Pattern ( String pattern ) { patterns . add ( pattern ) ; return this ; }
private void commit ( ) throws Interrupted Exception , Replicator Exception { applier . commit ( ) ; schedule . commit ( ) ; block Event Count = NUM_ ; last Commit Millis = System . current Time Millis ( ) ; }
private static void add Variable If Required ( Data Set data , String var ) { List < String > nodes = data . get Variable Names ( ) ; if ( ! nodes . contains ( var ) ) { data . add Variable ( new Continuous Variable ( var ) ) ; } }
@ Override public void send Mail ( Mime Message message ) throws Messaging Exception { Mail Address sender = new Mail Address ( ( Internet Address ) message . get From ( ) [ NUM_ ] ) ; Collection < Mail Address > recipients = new Hash Set < Mail Address > ( ) ; Address addresses [ ] = message . get All Recipients ( ) ; if ( addresses != null ) { for ( Address address : addresses ) { if ( address instanceof Internet Address ) { recipients . add ( new Mail Address ( ( Internet Address ) address ) ) ; } } } send Mail ( sender , recipients , message ) ; }
public static void register App ( int application , String app Name ) throws App ID Exception { if ( ( application & APP ID MASK ) != application ) { throw new Invalid App ID Value Exception ( application ) ; } String old App = app Id Map . put If Absent ( application , app Name ) ; if ( old App != null && ! old App . equals ( app Name ) ) { throw new App ID In Use Exception ( application , old App , app Name ) ; } }
public static DB Maker < ? > new Default Db ( String loc , Enum < ? > e ) { return new Default Db ( loc , e . name ( ) ) ; }
@ Override public void close Archive Entry ( ) throws IO Exception { if ( finished ) { throw new IO Exception ( STR_ ) ; } if ( entry == null ) { throw new IO Exception ( STR_ ) ; } if ( ! entry . has Written ) { write ( EMPTY , NUM_ , NUM_ ) ; } flush Deflater ( ) ; final Zip 64 Mode effective Mode = get Effective Zip 64 Mode ( entry . entry ) ; long bytes Written = written - entry . data Start ; long real Crc = crc . get Value ( ) ; crc . reset ( ) ; final boolean actually Needs Zip 64 = handle Sizes And Crc ( bytes Written , real Crc , effective Mode ) ; if ( raf != null ) { rewrite Sizes And Crc ( actually Needs Zip 64 ) ; } write Data Descriptor ( entry . entry ) ; entry = null ; }
public Result filter Only ( List < String > sources ) { Result ret = new Result ( ) ; for ( Result Entry l : this . log ) { if ( sources . contains ( l . get Source ( ) ) ) { ret . add ( l ) ; } } return ret ; }
private int scroll By ( int dy , Recycler View . Recycler recycler , Recycler View . State state ) { int delta = NUM_ ; if ( dy > NUM_ ) { top Border = get Padding Top ( ) ; bottom Border += dy ; m Current Position = last Attached Item Position + NUM_ ; fill Grid ( recycler , state , true ) ; if ( span Bottom Min >= bottom Border ) { delta = dy ; bottom Border -= dy ; } else { bottom Border = get Height ( ) - get Padding Bottom ( ) ; if ( span Bottom Max - bottom Border >= dy ) { delta = dy ; } else { delta = Math . max ( NUM_ , span Bottom Max - bottom Border ) ; } } offset Children Vertical ( - delta ) ; for ( int i = NUM_ ; i < m Span Count ; i ++ ) { span Top [ i ] -= delta ; span Bottom [ i ] -= delta ; } span Top Min -= delta ; span Top Max -= delta ; span Bottom Min -= delta ; span Bottom Max -= delta ; recycle Top Invisible Views ( recycler ) ; } else { top Border += dy ; bottom Border = get Height ( ) - get Padding Bottom ( ) ; if ( first Attached Item Position == - NUM_ || first Attached Item Position >= state . get Item Count ( ) ) { first Attached Item Position = state . get Item Count ( ) - NUM_ ; last Attached Item Position = first Attached Item Position ; m Current Position = first Attached Item Position ; } else { m Current Position = first Attached Item Position - NUM_ ; } fill Grid ( recycler , state , false ) ; if ( span Top Max <= top Border ) { delta = dy ; top Border -= dy ; } else { top Border = get Padding Top ( ) ; if ( span Top Min - top Border <= dy ) { delta = dy ; } else { delta = - Math . max ( NUM_ , top Border - span Top Min ) ; } } offset Children Vertical ( - delta ) ; for ( int i = NUM_ ; i < m Span Count ; i ++ ) { span Top [ i ] -= delta ; span Bottom [ i ] -= delta ; } span Top Min -= delta ; span Top Max -= delta ; span Bottom Min -= delta ; span Bottom Max -= delta ; recycle Bottom Invisible Views ( recycler ) ; } scroll Offset += delta ; return delta ; }
public void start ( int total Seeds , int max NFE ) { this . total Seeds = total Seeds ; this . max NFE = max NFE ; last Seed = NUM_ ; last NFE = NUM_ ; current Seed = NUM_ ; current NFE = NUM_ ; statistics . clear ( ) ; start Time = System . current Time Millis ( ) ; last Time = start Time ; }
public void invalidate ( ) { net no = - NUM_ ; drill list . clear ( ) ; }
public String object To String ( final long shop Id , final String sku Code , final Big Decimal quantity ) { String Builder string Builder = new String Builder ( ) ; string Builder . append ( id Bridge . object To String ( new Big Decimal ( shop Id ) ) ) ; string Builder . append ( STR_ ) ; string Builder . append ( sku Code ) ; string Builder . append ( STR_ ) ; string Builder . append ( qty Bridge . object To String ( quantity ) ) ; return string Builder . to String ( ) ; }
public Config Sets Handler ( final Core Container core Container ) { this . core Container = core Container ; }
private float clamp Mag ( float value , float abs Min , float abs Max ) { final float abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM_ ; if ( abs Value > abs Max ) return value > NUM_ ? abs Max : - abs Max ; return value ; }
public static int patch Fast ( File old File , File new File , File diff File , int ext Len ) throws IO Exception { if ( old File == null || old File . length ( ) <= NUM_ ) { return RETURN OLD FILE ERR ; } if ( new File == null ) { return RETURN NEW FILE ERR ; } if ( diff File == null || diff File . length ( ) <= NUM_ ) { return RETURN DIFF FILE ERR ; } Input Stream old Input Stream = new Buffered Input Stream ( new File Input Stream ( old File ) ) ; byte [ ] diff Bytes = new byte [ ( int ) diff File . length ( ) ] ; Input Stream diff Input Stream = new File Input Stream ( diff File ) ; try { BS Util . read From Stream ( diff Input Stream , diff Bytes , NUM_ , diff Bytes . length ) ; } finally { diff Input Stream . close ( ) ; } byte [ ] new Bytes = patch Fast ( old Input Stream , ( int ) old File . length ( ) , diff Bytes , ext Len ) ; Output Stream new Output Stream = new File Output Stream ( new File ) ; try { new Output Stream . write ( new Bytes ) ; } finally { new Output Stream . close ( ) ; } return RETURN SUCCESS ; }
private String create Workflow Step For Relink Native Targets ( Workflow workflow , Block Snapshot Session tgt Snap Session , List < URI > snapshot UR Is , String wait For , Workflow . Method rollback Method ) { URI parent System URI = tgt Snap Session . get Storage Controller ( ) ; Storage System parent System = get Data Object ( Storage System . class , parent System URI , db Client ) ; Workflow . Method relink Method = new Workflow . Method ( RELINK SNAPSHOT SESSION TARGETS METHOD NAME , parent System URI , tgt Snap Session . get Id ( ) , snapshot UR Is , Boolean . FALSE ) ; workflow . create Step ( RELINK SNAPSHOT SESSION TARGET STEP , String . format ( STR_ , snapshot UR Is , tgt Snap Session . get Id ( ) ) , wait For , parent System URI , parent System . get System Type ( ) , Block Device Controller . class , relink Method , rollback Method , null ) ; log . info ( STR_ , snapshot UR Is , tgt Snap Session . get Id ( ) ) ; return RELINK SNAPSHOT SESSION TARGET STEP ; }
protected Pair < Class < ? extends Page > , Page Parameters > determine Cancel Target ( boolean is Checkout , final Customer customer ) { return determine Success Target ( is Checkout , customer ) ; }
Watch watch ( Compilation Request request ) { Watch watch = request For Thread . get ( ) ; if ( watch == null ) { watch = new Watch ( ) ; synchronized ( requests ) { requests . put ( Thread . current Thread ( ) , watch ) ; } } watch . open ( request ) ; return watch ; }
public Collection Relationship Provider ( final Connection Factory connection Factory , final Resource Path resource Path , final Schema Field schema Field , final Activity Logger activity Logger , final Managed Object Set Service managed Object Sync Service ) { super ( connection Factory , resource Path , schema Field , activity Logger , managed Object Sync Service ) ; final Router router = new Router ( ) ; router . add Route ( Routing Mode . STARTS WITH , uri Template ( String . format ( STR_ , PARAM MANAGED OBJECT ID , schema Field . get Name ( ) ) ) , Resources . new Handler ( this ) ) ; this . request Handler = router ; }
private Set < String > wait For Mac App Quit ( String browser ) { Set < String > running Apps ; boolean app Closed = true ; final long start Millis = System . current Time Millis ( ) ; final long wait Millis = NUM_ ; do { running Apps = running Applications ( ) ; if ( running Apps . contains ( browser ) ) { app Closed = false ; try { Thread . sleep ( wait Millis ) ; } catch ( Interrupted Exception e ) { return running Apps ; } long current Millis = System . current Time Millis ( ) ; if ( current Millis - start Millis >= MAX TERMINATE WAIT MILLIS ) break ; } else { app Closed = true ; } } while ( ! app Closed ) ; return running Apps ; }
public Value read ( Type type , Node Map node , Map map ) throws Exception { Class actual = read Value ( type , node ) ; Class expect = type . get Type ( ) ; if ( expect . is Array ( ) ) { return read Array ( actual , node ) ; } if ( expect != actual ) { return new Object Value ( actual ) ; } return null ; }
public void add Items ( int how Many ) { if ( how Many > NUM_ ) { for ( int i = last Inserted Index + NUM_ ; i <= last Inserted Index + how Many ; i ++ ) { items . add ( STR_ + i ) ; notify Item Inserted ( items . size ( ) - NUM_ ) ; } last Inserted Index = last Inserted Index + how Many ; } }
private void init Resource Bundle ( UI Defaults table ) { table . set Default Locale ( Locale . get Default ( ) ) ; table . add Resource Bundle ( STR_ ) ; }
public Extended Message Format ( final String pattern ) { this ( pattern , Locale . get Default ( ) ) ; }
private static Remote Stub create Stub ( Class < ? > remote Class , Remote Ref ref ) throws Stub Not Found Exception { String stubname = remote Class . get Name ( ) + STR_ ; try { Class < ? > stubcl = Class . for Name ( stubname , false , remote Class . get Class Loader ( ) ) ; Constructor < ? > cons = stubcl . get Constructor ( stub Cons Param Types ) ; return ( Remote Stub ) cons . new Instance ( new Object [ ] { ref } ) ; } catch ( Class Not Found Exception e ) { throw new Stub Not Found Exception ( STR_ + stubname , e ) ; } catch ( No Such Method Exception e ) { throw new Stub Not Found Exception ( STR_ + stubname , e ) ; } catch ( Instantiation Exception e ) { throw new Stub Not Found Exception ( STR_ + stubname , e ) ; } catch ( Illegal Access Exception e ) { throw new Stub Not Found Exception ( STR_ + stubname , e ) ; } catch ( Invocation Target Exception e ) { throw new Stub Not Found Exception ( STR_ + stubname , e ) ; } catch ( Class Cast Exception e ) { throw new Stub Not Found Exception ( STR_ + stubname , e ) ; } }
public boolean equals ( Object obj ) { if ( obj instanceof Object Endpoint ) { Object Endpoint oe = ( Object Endpoint ) obj ; return id . equals ( oe . id ) && transport == oe . transport ; } else { return false ; } }
public boolean is Source Core Healthy ( Solr Core bestsrc Core ) { if ( bestsrc Core == null ) { Replication Diagnostics replicated Core Diagnostic = new Replication Diagnostics ( ) ; replicated Core Diagnostic . set Entity ( STR_ ) ; replicated Core Diagnostic . set Failed Replication ( true ) ; replicated Core Diagnostic . set Reason ( STR_ ) ; all Diagnostics . add ( replicated Core Diagnostic ) ; if ( ! replicator Config . should Skip Replication Failures ( ) ) { return false ; } } else if ( ! bestsrc Core . available ) { Replication Diagnostics replicated Core Diagnostic = new Replication Diagnostics ( ) ; replicated Core Diagnostic . set Entity ( bestsrc Core . name ) ; replicated Core Diagnostic . set Failed Replication ( true ) ; replicated Core Diagnostic . set Reason ( STR_ ) ; all Diagnostics . add ( replicated Core Diagnostic ) ; if ( ! replicator Config . should Skip Replication Failures ( ) ) { return false ; } } return true ; }
private void start Animation ( ) { Value Animator animator = Value Animator . of Float ( NUM_ ) ; Array List < Name Values Holder > name Value List = ( Array List < Name Values Holder > ) m Pending Animations . clone ( ) ; m Pending Animations . clear ( ) ; int property Mask = NUM_ ; int property Count = name Value List . size ( ) ; for ( int i = NUM_ ; i < property Count ; ++ i ) { Name Values Holder name Values Holder = name Value List . get ( i ) ; property Mask |= name Values Holder . m Name Constant ; } m Animator Map . put ( animator , new Property Bundle ( property Mask , name Value List ) ) ; animator . add Update Listener ( m Animator Event Listener ) ; animator . add Listener ( m Animator Event Listener ) ; if ( m Start Delay Set ) { animator . set Start Delay ( m Start Delay ) ; } if ( m Duration Set ) { animator . set Duration ( m Duration ) ; } if ( m Interpolator Set ) { animator . set Interpolator ( m Interpolator ) ; } animator . start ( ) ; }
private void release Waiters ( int phase ) { Q Node q ; Thread t ; Atomic Reference < Q Node > head = ( phase & NUM_ ) == NUM_ ? even Q : odd Q ; while ( ( q = head . get ( ) ) != null && q . phase != ( int ) ( root . state > > > PHASE SHIFT ) ) { if ( head . compare And Set ( q , q . next ) && ( t = q . thread ) != null ) { q . thread = null ; Lock Support . unpark ( t ) ; } } }
public void update Weights ( double l , double m ) { if ( ! m weights Updated && ! Double . is Na N ( m unit Error ) ) { m methods . update Weights ( this , l , m ) ; super . update Weights ( l , m ) ; } }
public static void open Imdb For Person ( Context context , String name ) { if ( context == null || Text Utils . is Empty ( name ) ) { return ; } Intent intent = new Intent ( Intent . ACTION VIEW , Uri . parse ( String . format ( IMDB APP PERSON SEARCH URI , name ) ) ) ; intent . add Flags ( Intent . FLAG ACTIVITY CLEAR WHEN TASK RESET ) ; if ( ! Utils . try Start Activity ( context , intent ) ) { intent = new Intent ( Intent . ACTION VIEW , Uri . parse ( String . format ( IMDB PERSON SEARCH URL , name ) ) ) ; intent . add Flags ( Intent . FLAG ACTIVITY CLEAR WHEN TASK RESET ) ; context . start Activity ( intent ) ; } }
protected J Menu Item create Column Menu Item ( Action Listener listener , Data Line Model < ? , ? > model , Lime J Table table , int i ) { Object id = model . get Column Id ( i ) ; String name = model . get Column Name ( i ) ; J Check Box Menu Item item = new Skin Check Box Menu Item ( name , table . is Column Visible ( id ) ) ; item . put Client Property ( COLUMN ID , id ) ; item . add Action Listener ( listener ) ; return item ; }
public static List < Container > create Container List ( int broker Id , int containers Number ) { Array List < Container > containers = new Array List < Container > ( ) ; for ( int i = NUM_ ; i < containers Number ; ++ i ) { int container Type = i / ( int ) Math . ceil ( ( double ) containers Number / NUM_ ) ; containers . add ( new Power Container ( I Ds . poll Id ( Container . class ) , broker Id , ( double ) Constants Examples . CONTAINER MIPS [ container Type ] , Constants Examples . CONTAINER PES [ container Type ] , Constants Examples . CONTAINER RAM [ container Type ] , Constants Examples . CONTAINER BW , NUM_ , STR_ , new Container Cloudlet Scheduler Dynamic Workload ( Constants Examples . CONTAINER MIPS [ container Type ] , Constants Examples . CONTAINER PES [ container Type ] ) , Constants Examples . SCHEDULING INTERVAL ) ) ; } return containers ; }
public boolean generate ( Projection proj ) { boolean ret = super . generate ( proj ) ; create Labels ( ) ; labels . generate ( proj ) ; points . generate ( proj ) ; return ret ; }
public static void write Element ( final XML Stream Writer writer , final String element Name , final String [ ] value ) throws XML Stream Exception { if ( value == null || value . length == NUM_ ) { return ; } writer . write Start Element ( element Name ) ; for ( int i = NUM_ ; i < value . length ; i ++ ) { writer . write Start Element ( STR_ ) ; writer . write Characters ( value [ i ] ) ; writer . write End Element ( ) ; } writer . write End Element ( ) ; }
public static void notify List Change ( String name ) { java . util . List < String > list = new Linked List < > ( ) ; String Tokenizer st = new String Tokenizer ( Program Properties . get ( name , STR_ ) , STR_ ) ; while ( st . has More Tokens ( ) ) { list . add ( st . next Token ( ) ) ; } synchronized ( propertieslist Listeners ) { for ( Properties List Listener listener : propertieslist Listeners ) { if ( listener . is Interested ( name ) ) listener . has Changed ( list ) ; } } }
private void mark Clinits As Modeled ( ) { for ( Soot Class clz : all System Classes ) { if ( clz . declares Method ( STR_ ) ) { Soot Method clinit = clz . get Method ( STR_ ) ; api modeled methods . add Method ( clinit ) ; safe methods . add Method ( clinit ) ; } } }
@ Override public int clamp View Position Vertical ( View child , int top , int dy ) { if ( m Dragged View == null ) { return NUM_ ; } final int view Margin = m Dragged View . get Top Bottom Margin ( ) ; final int top Bound = get Padding Top ( ) - view Margin ; final int bottom Bound = get Height ( ) - m Dragged View . get Height ( ) + view Margin ; return Math . min ( Math . max ( top , top Bound ) , bottom Bound ) ; }
public void pad ( int byte size ) { for ( int i = NUM_ ; i < byte size ; i ++ ) bb . put ( -- space , ( byte ) NUM_ ) ; }
public static void un Register Client App ( Context context ) throws App Catalog Exception { String server IP = Preference . get String ( context , Constants . Preference Flag . IP ) ; if ( server IP != null && ! server IP . is Empty ( ) ) { String application Name = Preference . get String ( context , Constants . CLIENT NAME ) ; String consumer Key = Preference . get String ( context , Constants . CLIENT ID ) ; String user Id = Preference . get String ( context , Constants . USERNAME ) ; if ( application Name != null && ! application Name . is Empty ( ) && consumer Key != null && ! consumer Key . is Empty ( ) && user Id != null && ! user Id . is Empty ( ) ) { Unregister Profile profile = new Unregister Profile ( ) ; profile . set Application Name ( application Name ) ; profile . set Consumer Key ( consumer Key ) ; profile . set User Id ( user Id ) ; Server Config utils = new Server Config ( ) ; utils . set Server IP ( server IP ) ; Dynamic Client Manager dynamic Client Manager = new Dynamic Client Manager ( ) ; boolean is Unregistered = dynamic Client Manager . unregister Client ( profile , utils , context ) ; if ( ! is Unregistered ) { Log . e ( TAG , STR_ ) ; } } else { Log . e ( TAG , STR_ ) ; } } else { Log . e ( TAG , STR_ ) ; } }
Node < K , V > find Near ( K kkey , int rel ) { Comparable < ? super K > key = comparable ( kkey ) ; for ( ; ; ) { Node < K , V > b = find Predecessor ( key ) ; Node < K , V > n = b . next ; for ( ; ; ) { if ( n == null ) return ( ( rel & LT ) == NUM_ || b . is Base Header ( ) ) ? null : b ; Node < K , V > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compare To ( n . key ) ; if ( ( c == NUM_ && ( rel & EQ ) != NUM_ ) || ( c < NUM_ && ( rel & LT ) == NUM_ ) ) return n ; if ( c <= NUM_ && ( rel & LT ) != NUM_ ) return b . is Base Header ( ) ? null : b ; b = n ; n = f ; } } }
private static boolean has Specialized Handler Intents ( Context context , Intent intent ) { try { Package Manager pm = context . get Package Manager ( ) ; List < Resolve Info > handlers = pm . query Intent Activities ( intent , Package Manager . GET RESOLVED FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM_ ) { return false ; } for ( Resolve Info resolve Info : handlers ) { Intent Filter filter = resolve Info . filter ; if ( filter == null ) continue ; if ( filter . count Data Authorities ( ) == NUM_ || filter . count Data Paths ( ) == NUM_ ) continue ; if ( resolve Info . activity Info == null ) continue ; return true ; } } catch ( Runtime Exception e ) { Log . e ( TAG , STR_ ) ; } return false ; }
protected IE Object Description create Single Element Description ( T Member existing Member ) { return E Object Description . create ( existing Member . get Name ( ) , existing Member ) ; }
public void ask Permissions ( ) { m Permissions To Ask = get Not Granted Permissions ( ) ; if ( m Permissions To Ask . size ( ) > NUM_ && Build . VERSION . SDK INT >= Build . VERSION CODES . M ) { request Permissions ( m Permissions To Ask . to Array ( new String [ m Permissions To Ask . size ( ) ] ) , MY PERMISSION REQUEST ALL ) ; } else { send Response ( true ) ; } }
public static final int binary Search ( Object [ ] a , Object key , Comparator cp , int begin , int end ) { int x 1 = begin ; int x 2 = end ; int i = x 1 + ( x 2 - x 1 ) / NUM_ , c ; while ( x 1 < x 2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == NUM_ ) { return i ; } else if ( c < NUM_ ) { x 1 = i + NUM_ ; } else { x 2 = i ; } i = x 1 + ( x 2 - x 1 ) / NUM_ ; } return - NUM_ * ( i + NUM_ ) ; }
private void post Init View Pager ( ) { try { Class < ? > viewpager = View Pager . class ; Field scroller = viewpager . get Declared Field ( STR_ ) ; scroller . set Accessible ( true ) ; Field interpolator = viewpager . get Declared Field ( STR_ ) ; interpolator . set Accessible ( true ) ; m Scroller = new Custom Duration Scroller ( get Context ( ) , ( Interpolator ) interpolator . get ( null ) ) ; double duration = NUM_ ; m Scroller . set Scroll Duration Factor ( duration ) ; scroller . set ( this , m Scroller ) ; } catch ( No Such Field Exception e ) { } catch ( Illegal Argument Exception e ) { } catch ( Illegal Access Exception e ) { } }
protected void process Initiators ( Export Group export Group , Collection < Initiator > initiators , Collection < String > port Names , Map < String , URI > port Name To Initiator URI , Collection < URI > host UR Is , List Multimap < String , String > compute Resource To Port Names ) { for ( Initiator initiator : initiators ) { String normalized Name = Initiator . normalize Port ( initiator . get Initiator Port ( ) ) ; port Names . add ( normalized Name ) ; port Name To Initiator URI . put ( normalized Name , initiator . get Id ( ) ) ; if ( host UR Is != null ) { if ( ! Null Column Value Getter . is Null URI ( initiator . get Host ( ) ) && ! host UR Is . contains ( initiator . get Host ( ) ) ) { host UR Is . add ( initiator . get Host ( ) ) ; } } if ( compute Resource To Port Names != null ) { String compute Resource Id ; if ( export Group != null && export Group . for Cluster ( ) ) { compute Resource Id = initiator . get Cluster Name ( ) ; } else { URI host URI = initiator . get Host ( ) ; if ( host URI == null ) { host URI = Null Column Value Getter . get Null URI ( ) ; } compute Resource Id = host URI . to String ( ) ; } compute Resource To Port Names . put ( compute Resource Id , normalized Name ) ; } } }
public final boolean is clearance compensation used ( ) { return compensated clearance class no > NUM_ ; }
private void assert Write Result ( int size ) throws IO Exception { Byte Buffer buf = Byte Buffer . allocate ( size + NUM_ ) ; int count = NUM_ ; int total = NUM_ ; long begin Time = System . current Time Millis ( ) ; while ( ( count = client Channel . read ( buf ) ) != - NUM_ ) { total = total + count ; if ( System . current Time Millis ( ) - begin Time > NUM_ ) { break ; } } assert Equals ( total , size ) ; buf . flip ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { assert Equals ( ( byte ) i , buf . get ( i ) ) ; } }
private static double [ ] compute Labels ( final double start , final double end , final int approx Num Labels ) { if ( Math . abs ( start - end ) < NUM_ ) { return new double [ ] { start , start , NUM_ } ; } double s = start ; double e = end ; boolean switched = false ; if ( s > e ) { switched = true ; double tmp = s ; s = e ; e = tmp ; } double x Step = round Up ( Math . abs ( s - e ) / approx Num Labels ) ; double x Start = x Step * Math . ceil ( s / x Step ) ; double x End = x Step * Math . floor ( e / x Step ) ; if ( switched ) { return new double [ ] { x End , x Start , - NUM_ * x Step } ; } return new double [ ] { x Start , x End , x Step } ; }
public Type Name ( String full Name , String nickname , String parent Type Name ) { this . top Level Alias = Type Alias . create ( full Name , nickname , parent Type Name ) ; this . pattern = null ; this . inner Type Names = Arrays . as List ( ) ; }
private void put With Validation ( String key , Object value ) throws Bitcoin URI Parse Exception { if ( parameter Map . contains Key ( key ) ) { throw new Bitcoin URI Parse Exception ( String . format ( STR_ , key ) ) ; } else { parameter Map . put ( key , value ) ; } }
public boolean qualify ( final Node that , final Declaration d ) { String path = qualified Path ( that , d ) ; if ( path . length ( ) > NUM_ ) { out ( path , d instanceof Constructor ? names . constructor Separator ( d ) : STR_ ) ; } return path . length ( ) > NUM_ ; }
final boolean is Running Or Shutdown ( boolean shutdown OK ) { int rs = run State Of ( ctl . get ( ) ) ; return rs == RUNNING || ( rs == SHUTDOWN && shutdown OK ) ; }
static String format Debug Time ( long unix Time , long now ) { Time time = new Time ( ) ; time . set ( unix Time ) ; long delta = unix Time - now ; if ( delta > Date Utils . MINUTE IN MILLIS ) { delta /= Date Utils . MINUTE IN MILLIS ; return String . format ( STR_ , unix Time , time . format ( STR_ ) , delta ) ; } else { delta /= Date Utils . SECOND IN MILLIS ; return String . format ( STR_ , unix Time , time . format ( STR_ ) , delta ) ; } }
public void repaint Panel ( ) { remove All ( ) ; initialize Layout ( ) ; repaint ( ) ; }
public void clear Image ( ) { clear Image Int ( ) ; m Crop Overlay View . set Initial Crop Window Rect ( null ) ; }
public void next Group ( ) { release ( ) ; }
public synchronized void open Write ( ) throws Replicator Exception , Interrupted Exception { if ( ! file . exists ( ) ) { throw new THL Exception ( STR_ + file . get Name ( ) ) ; } try { Buffered File Data Input bfdi = new Buffered File Data Input ( file , buffer Size ) ; check File Header ( bfdi ) ; bfdi . close ( ) ; data Output = new Buffered File Data Output ( file , buffer Size ) ; } catch ( IO Exception e ) { throw new THL Exception ( STR_ + file . get Name ( ) , e ) ; } mode = Access Mode . write ; if ( log Flush Task != null ) log Flush Task . add Log File ( this ) ; }
public void do Filter ( final Servlet Request request , final Servlet Response response , final Filter Chain chain ) throws IO Exception , Servlet Exception { Url Rewriter url Rewriter = get Url Rewriter ( request , response , chain ) ; final Http Servlet Request hs Request = ( Http Servlet Request ) request ; final Http Servlet Response hs Response = ( Http Servlet Response ) response ; Url Rewrite Wrapped Response url Rewrite Wrapped Response = new Url Rewrite Wrapped Response ( hs Response , hs Request , url Rewriter ) ; if ( status Enabled && status Server Name Matcher . is Match ( request . get Server Name ( ) ) ) { String uri = hs Request . get Request URI ( ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + uri ) ; } String context Path = hs Request . get Context Path ( ) ; if ( uri != null && uri . starts With ( context Path + status Path ) ) { show Status ( hs Request , url Rewrite Wrapped Response ) ; return ; } } boolean request Rewritten = false ; if ( url Rewriter != null ) { request Rewritten = url Rewriter . process Request ( hs Request , url Rewrite Wrapped Response , chain ) ; } else { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ ) ; } } if ( ! request Rewritten ) { chain . do Filter ( hs Request , url Rewrite Wrapped Response ) ; } }
public Builder add Service ( Action Service service ) { if ( service == null ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( service . get Supported Annotation Type ( ) == null ) { throw new Illegal Argument Exception ( STR_ ) ; } services . add ( service ) ; return this ; }
public int next ( ) { Tree Node n = stack . pop ( ) ; push All ( n . right ) ; return n . val ; }
static private String SHORT Max ( ) { short temp Value = Short . MAX VALUE ; return String . value Of ( temp Value ) ; }
@ Suppress Warnings ( STR_ ) public boolean add Telegram Writer ( Telegram Writer new Writer ) { return ( telegram Writers . add ( new Writer ) ) ; }
private Resource pack Icon ( int dpi , Bitmap icon ) { Resource res = new Resource ( ) ; res . dpi = dpi ; Byte Array Output Stream os = new Byte Array Output Stream ( ) ; if ( icon . compress ( IMAGE FORMAT , IMAGE COMPRESSION QUALITY , os ) ) { res . data = os . to Byte Array ( ) ; } return res ; }
public void retain ( ) { bbl List . add ( this ) ; }
protected Object visit ( Binary Logic Operator filter , Object extra Data ) { LOGGER . finer ( STR_ ) ; final List < Filter Builder > filter List = new Array List < > ( ) ; for ( final Filter child : filter . get Children ( ) ) { child . accept ( this , extra Data ) ; filter List . add ( filter Builder ) ; } final Filter Builder [ ] filters ; filters = filter List . to Array ( new Filter Builder [ filter List . size ( ) ] ) ; if ( extra Data . equals ( STR_ ) ) { filter Builder = Filter Builders . and Filter ( filters ) ; } else { filter Builder = Filter Builders . or Filter ( filters ) ; } return extra Data ; }
public void add Tree Model Listener ( Tree Model Listener l ) { tree Model Listeners . add Element ( l ) ; }
private String copy ( final char [ ] array , final int start , final int end ) { String Builder text = new String Builder ( ) ; for ( int j = start ; j < end ; j ++ ) { text . append ( array [ j ] ) ; } return text . to String ( ) ; }
private int clamp Mag ( int value , int abs Min , int abs Max ) { final int abs Value = Math . abs ( value ) ; if ( abs Value < abs Min ) return NUM_ ; if ( abs Value > abs Max ) return value > NUM_ ? abs Max : - abs Max ; return value ; }
public static X 509 Cert Impl to Impl ( X 509 Certificate cert ) throws Certificate Exception { if ( cert instanceof X 509 Cert Impl ) { return ( X 509 Cert Impl ) cert ; } else { return X 509 Factory . intern ( cert ) ; } }
protected JSON Object read Input Stream ( Input Stream is ) throws IO Exception { String json String = read Stream To String ( is ) ; JSON Object json Object ; try { return new JSON Object ( json String ) ; } catch ( JSON Exception error ) { throw new IO Exception ( error . to String ( ) ) ; } }
public String generate XML ( String session ID , String version Name , long install Age , Request Data data ) throws Request Failure Exception { Xml Serializer serializer = Xml . new Serializer ( ) ; String Writer writer = new String Writer ( ) ; try { serializer . set Output ( writer ) ; serializer . start Document ( STR_ , true ) ; serializer . start Tag ( null , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , STR_ + data . get Request ID ( ) + STR_ ) ; serializer . attribute ( null , STR_ , STR_ + session ID + STR_ ) ; serializer . attribute ( null , STR_ , data . get Install Source ( ) ) ; append Extra Attributes ( STR_ , serializer ) ; serializer . start Tag ( null , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , Build . VERSION . RELEASE ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . end Tag ( null , STR_ ) ; serializer . start Tag ( null , STR_ ) ; serializer . attribute ( null , STR_ , get Brand ( ) ) ; serializer . attribute ( null , STR_ , get Client ( ) ) ; serializer . attribute ( null , STR_ , get App Id ( ) ) ; serializer . attribute ( null , STR_ , version Name ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , get Language ( ) ) ; serializer . attribute ( null , STR_ , String . value Of ( install Age ) ) ; serializer . attribute ( null , STR_ , get Additional Parameters ( ) ) ; append Extra Attributes ( STR_ , serializer ) ; if ( data . is Send Install Event ( ) ) { serializer . start Tag ( null , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . end Tag ( null , STR_ ) ; } else { serializer . start Tag ( null , STR_ ) ; serializer . end Tag ( null , STR_ ) ; serializer . start Tag ( null , STR_ ) ; serializer . attribute ( null , STR_ , STR_ ) ; serializer . end Tag ( null , STR_ ) ; } serializer . end Tag ( null , STR_ ) ; serializer . end Tag ( null , STR_ ) ; serializer . end Document ( ) ; } catch ( IO Exception e ) { throw new Request Failure Exception ( STR_ , e ) ; } catch ( Illegal Argument Exception e ) { throw new Request Failure Exception ( STR_ , e ) ; } catch ( Illegal State Exception e ) { throw new Request Failure Exception ( STR_ , e ) ; } return writer . to String ( ) ; }
@ Suppress Warnings ( STR_ ) protected final void ensure Capacity ( long target Size ) { long capacity = capacity ( ) ; if ( target Size > capacity ) { inflate Spine ( ) ; for ( int i = spine Index + NUM_ ; target Size > capacity ; i ++ ) { if ( i >= spine . length ) { int new Spine Size = spine . length * NUM_ ; spine = Arrays . copy Of ( spine , new Spine Size ) ; prior Element Count = Arrays . copy Of ( prior Element Count , new Spine Size ) ; } int next Chunk Size = chunk Size ( i ) ; spine [ i ] = ( E [ ] ) new Object [ next Chunk Size ] ; prior Element Count [ i ] = prior Element Count [ i - NUM_ ] + spine [ i - NUM_ ] . length ; capacity += next Chunk Size ; } } }
@ Side Only ( Side . CLIENT ) public static void create Tooltip ( Item Stack stack , List < String > tooltip ) { if ( is Tesla Holder ( stack , Enum Facing . DOWN ) ) { final Key Binding key Bind Sneak = Minecraft . get Minecraft ( ) . game Settings . key Bind Sneak ; final I Tesla Holder holder = Tesla Utils . get Tesla Holder ( stack , Enum Facing . DOWN ) ; if ( Game Settings . is Key Down ( key Bind Sneak ) ) { add Holder Info ( holder , tooltip ) ; if ( holder instanceof Base Tesla Container ) { final Base Tesla Container container = ( Base Tesla Container ) holder ; tooltip . add ( Chat Formatting . DARK AQUA + I 18 n . format ( STR_ , Long . to String ( container . get Input Rate ( ) ) ) ) ; tooltip . add ( Chat Formatting . DARK AQUA + I 18 n . format ( STR_ , Long . to String ( container . get Output Rate ( ) ) ) ) ; } } else tooltip . add ( I 18 n . format ( STR_ , Chat Formatting . DARK AQUA , key Bind Sneak . get Display Name ( ) , Chat Formatting . GRAY ) ) ; } }
void dump Unsafe ( Printer printer , boolean verbose ) { printer . println ( STR_ + m Connection Id + STR_ ) ; if ( verbose ) { printer . println ( STR_ + Integer . to Hex String ( System . identity Hash Code ( m Connection Ptr ) ) ) ; } printer . println ( STR_ + m Is Primary Connection ) ; printer . println ( STR_ + m Only Allow Read Only Operations ) ; m Recent Operations . dump ( printer , verbose ) ; if ( verbose ) { m Prepared Statement Cache . dump ( printer ) ; } }
public Singleton Task ( Scheduled Executor Service ses , Runnable task ) { super ( ) ; this . task = task ; this . ses = ses ; }
public String format Export Cmd ( String data Mover , List < VNX File Export > exports , Map < String , String > user Info , String net Bios ) { if ( exports . is Empty ( ) ) { log . debug ( STR_ ) ; return null ; } String mount Point = entry Paths Differ ( exports ) ; if ( mount Point == null ) { log . debug ( STR_ ) ; return null ; } String protocol = entry Protocols Differ ( exports ) ; if ( protocol == null ) { log . debug ( STR_ ) ; return null ; } String Builder options = new String Builder ( ) ; String result = null ; if ( protocol . equals Ignore Case ( VNX CIFS ) ) { result = format Cifs Cmd ( exports , net Bios ) ; } else { result = format Nfs Cmd ( exports , user Info ) ; } options . append ( result ) ; options . append ( STR_ ) ; String Builder cmd = new String Builder ( ) ; cmd . append ( data Mover ) ; cmd . append ( options . to String ( ) ) ; cmd . append ( mount Point ) ; return cmd . to String ( ) ; }
public boolean is Buffered ( ) { return true ; }
public boolean parse More Data ( final Encoded Image encoded Image ) { if ( m Parser State == NOT A JPEG ) { return false ; } final int data Buffer Size = encoded Image . get Size ( ) ; if ( data Buffer Size <= m Bytes Parsed ) { return false ; } final Input Stream buffered Data Stream = new Pooled Byte Array Buffered Input Stream ( encoded Image . get Input Stream ( ) , m Byte Array Pool . get ( BUFFER SIZE ) , m Byte Array Pool ) ; try { Stream Util . skip ( buffered Data Stream , m Bytes Parsed ) ; return do Parse More Data ( buffered Data Stream ) ; } catch ( IO Exception ioe ) { Throwables . propagate ( ioe ) ; return false ; } finally { Closeables . close Quietly ( buffered Data Stream ) ; } }
private void delete Storage HWI Ds ( Storage System storage , List < Initiator > initiators ) { if ( initiators == null || initiators . is Empty ( ) ) { log . debug ( STR_ ) ; return ; } CIM Object Path hw Id Management Svc = cim Path . get Storage Hardware ID Management Service ( storage ) ; for ( Initiator initiator : initiators ) { try { CIM Argument [ ] create Hw Id In = helper . get Delete Storage Hardware ID Args ( storage , initiator ) ; CIM Argument [ ] create Hw Id Out = new CIM Argument [ NUM_ ] ; helper . invoke Method ( storage , hw Id Management Svc , Smis Constants . DELETE STORAGE HARDWARE ID , create Hw Id In , create Hw Id Out ) ; } catch ( WBEM Exception e ) { log . error ( STR_ + e . get Message ( ) ) ; } catch ( Exception e ) { log . error ( STR_ + e . get Message ( ) ) ; } } }
public void enqueue ( Source Record record ) throws Interrupted Exception { if ( record != null ) { records . put ( record ) ; } }
public Drawer Builder add Sticky Drawer Items ( @ Non Null I Drawer Item ... sticky Drawer Items ) { if ( this . m Sticky Drawer Items == null ) { this . m Sticky Drawer Items = new Array List < > ( ) ; } Collections . add All ( this . m Sticky Drawer Items , Id Distributor . check Ids ( sticky Drawer Items ) ) ; return this ; }
public static void init ( Context context ) { if ( s Instance == null ) { final Executor Service service = Executors . new Single Thread Executor ( ) ; s Training Task Future = service . submit ( new Training Task ( context ) ) ; } else { throw new Illegal State Exception ( STR_ + STR_ ) ; } }
private Handshake Status run Tasks ( ) { Runnable runnable ; while ( ( runnable = ssl Engine . get Delegated Task ( ) ) != null ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + runnable + STR_ + ses + STR_ ) ; runnable . run ( ) ; } if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + ssl Engine . get Handshake Status ( ) + STR_ + ses + STR_ ) ; return ssl Engine . get Handshake Status ( ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Long Needle ) ) { return false ; } return super . equals ( obj ) ; }
private static long spin ( long ms ) { long start = thread MX Bean . get Current Thread Cpu Time ( ) ; do { long duration MS = ( thread MX Bean . get Current Thread Cpu Time ( ) - start ) / NUM_ ; if ( duration MS >= ms ) { return duration MS ; } } while ( true ) ; }
@ Nullable public static Block load One Block From Xml ( String xml , Block Factory block Factory ) throws Blockly Parser Exception { List < Block > result = new Array List < > ( ) ; load Blocks From Xml ( null , xml , block Factory , null , result ) ; if ( result . is Empty ( ) ) { return null ; } return result . get ( NUM_ ) ; }
public static void do Web Artifact ( Http Servlet Request request , Http Servlet Response response , String target ) throws IO Exception , SAML Exception { do SSO ( request , response , target , SAML Constants . SAML AWARE NAMING ) ; }
protected void create Renderers ( Combined Chart chart , Chart Animator animator , View Port Handler view Port Handler ) { m Renderers . clear ( ) ; Draw Order [ ] orders = chart . get Draw Order ( ) ; for ( Draw Order order : orders ) { switch ( order ) { case BAR : if ( chart . get Bar Data ( ) != null ) m Renderers . add ( new Bar Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case BUBBLE : if ( chart . get Bubble Data ( ) != null ) m Renderers . add ( new Bubble Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case LINE : if ( chart . get Line Data ( ) != null ) m Renderers . add ( new Line Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case CANDLE : if ( chart . get Candle Data ( ) != null ) m Renderers . add ( new Candle Stick Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case SCATTER : if ( chart . get Scatter Data ( ) != null ) m Renderers . add ( new Scatter Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; } } }
private void build Options ( Options options ) { Option Builder . with Arg Name ( OPTION HELP ) ; Option Builder . with Long Opt ( OPTION HELP ) ; Option Builder . is Required ( false ) ; Option Builder . with Description ( STR_ ) ; options . add Option ( Option Builder . create ( STR_ ) ) ; Option Builder . with Arg Name ( OPTION INPUT JSON ) ; Option Builder . with Long Opt ( OPTION INPUT JSON ) ; Option Builder . is Required ( false ) ; Option Builder . has Arg ( ) ; Option Builder . with Description ( STR_ ) ; options . add Option ( Option Builder . create ( STR_ ) ) ; }
void stop Recording ( ) { if ( DEBUG ) Log . v ( TAG , STR_ ) ; synchronized ( m Sync ) { if ( ! m Is Capturing || m Request Stop ) { return ; } m Request Stop = true ; m Sync . notify All ( ) ; } }
public void antialiasing ( final int ulx , final int uly , final int lrx , final int lry , final int bgcolor ) { filter ( ulx , uly , lrx , lry , Filter Mode . FILTER ANTIALIASING , bgcolor ) ; }
@ Override public void run ( ) { am I Active = true ; String input Text File = null ; String input Raster Files = null ; String output Text File = null ; boolean interpolate Values = false ; boolean include Statistics = false ; String [ ] gat Header File ; List < Whitebox Raster > gat Grids = new Array List < > ( ) ; String file Name ; int number Of Lines = NUM_ ; int counter ; String temp Line ; String [ ] line ; int id ; double x Coord ; double y Coord ; String name ; int x Gridcell ; int y Gridcell ; double delta X ; double delta Y ; int d Xi ; int d Yi ; double average ; double w ; double [ ] ww = new double [ NUM_ ] ; double value ; int [ ] xd = new int [ ] { NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int [ ] yd = new int [ ] { - NUM_ , - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ } ; double min ; double max ; double sum ; int sum Count ; double mean = NUM_ ; double neighbour Value ; File Writer stream Writer = null ; String output Line ; float progress = NUM_ ; if ( args . length <= NUM_ ) { show Feedback ( STR_ ) ; return ; } for ( int i = NUM_ ; i < args . length ; i ++ ) { if ( i == NUM_ ) { input Text File = args [ i ] ; } else if ( i == NUM_ ) { input Raster Files = args [ i ] ; } else if ( i == NUM_ ) { output Text File = args [ i ] ; } else if ( i == NUM_ ) { interpolate Values = Boolean . parse Boolean ( args [ i ] ) ; } else if ( i == NUM_ ) { include Statistics = Boolean . parse Boolean ( args [ i ] ) ; } } if ( ( input Text File == null ) || ( input Raster Files == null ) || ( output Text File == null ) ) { show Feedback ( STR_ ) ; return ; } try { gat Header File = input Raster Files . split ( STR_ ) ; for ( int i = NUM_ ; i <= gat Header File . length - NUM_ ; i ++ ) { Whitebox Raster gat Grid = new Whitebox Raster ( gat Header File [ i ] , STR_ ) ; gat Grids . add ( gat Grid ) ; } Buffered Reader buffered Reader = new Buffered Reader ( new File Reader ( input Text File ) ) ; stream Writer = new File Writer ( output Text File , false ) ; output Line = STR_ + STR_ + STR_ + STR_ + STR_ ; for ( Whitebox Raster gat Grid : gat Grids ) { file Name = gat Grid . get Short Header File ( ) ; output Line = output Line + STR_ + file Name ; if ( include Statistics ) { output Line = output Line + STR_ + file Name + STR_ + STR_ + file Name + STR_ + STR_ + file Name + STR_ ; } } output Line = output Line + STR_ + STR_ ; stream Writer . write ( output Line + System . line Separator ( ) ) ; while ( ( temp Line = buffered Reader . read Line ( ) ) != null ) { number Of Lines = number Of Lines + NUM_ ; } buffered Reader . close ( ) ; buffered Reader = new Buffered Reader ( new File Reader ( input Text File ) ) ; temp Line = buffered Reader . read Line ( ) ; counter = NUM_ ; while ( ( temp Line = buffered Reader . read Line ( ) ) != null ) { line = temp Line . split ( STR_ ) ; counter = counter + NUM_ ; if ( ( line . length != NUM_ ) && ( line . length != NUM_ ) ) { J Option Pane . show Message Dialog ( null , STR_ + counter + STR_ ) ; return ; } if ( ! Is Integer ( line [ NUM_ ] ) || ! Is Double ( line [ NUM_ ] ) || ! Is Double ( line [ NUM_ ] ) ) { J Option Pane . show Message Dialog ( null , STR_ + counter + STR_ ) ; return ; } id = Integer . parse Int ( line [ NUM_ ] ) ; x Coord = Double . parse Double ( line [ NUM_ ] ) ; y Coord = Double . parse Double ( line [ NUM_ ] ) ; if ( line . length == NUM_ ) { name = line [ NUM_ ] ; } else { name = STR_ ; } output Line = id + STR_ + x Coord + STR_ + y Coord ; for ( Whitebox Raster gat Grid : gat Grids ) { grid Res = gat Grid . get Cell Size X ( ) ; x Gridcell = ( int ) ( ( x Coord - gat Grid . get West ( ) ) / grid Res ) ; y Gridcell = ( int ) ( ( y Coord - gat Grid . get South ( ) ) / grid Res ) ; delta X = x Coord - ( ( x Gridcell + NUM_ ) * grid Res + gat Grid . get West ( ) ) ; delta Y = y Coord - ( ( y Gridcell + NUM_ ) * grid Res + gat Grid . get South ( ) ) ; y Gridcell = Invert Y Coord ( gat Grid , y Gridcell ) ; if ( delta X > NUM_ ) { d Xi = NUM_ ; } else { d Xi = - NUM_ ; } if ( delta Y > NUM_ ) { d Yi = - NUM_ ; } else { d Yi = NUM_ ; } delta X = Math . abs ( delta X ) ; delta Y = Math . abs ( delta Y ) ; if ( interpolate Values ) { if ( ( gat Grid . get Value ( y Gridcell , x Gridcell ) == gat Grid . get No Data Value ( ) ) || ( gat Grid . get Value ( y Gridcell + d Yi , x Gridcell ) == gat Grid . get No Data Value ( ) ) || ( gat Grid . get Value ( y Gridcell , x Gridcell + d Xi ) == gat Grid . get No Data Value ( ) ) || ( gat Grid . get Value ( y Gridcell + d Yi , x Gridcell + d Xi ) == gat Grid . get No Data Value ( ) ) ) { value = gat Grid . get No Data Value ( ) ; } else if ( delta X == NUM_ && delta Y == NUM_ ) { value = gat Grid . get Value ( y Gridcell , x Gridcell ) ; } else { ww [ NUM_ ] = NUM_ / Math . sqrt ( Math . pow ( delta X , NUM_ ) + Math . pow ( delta Y , NUM_ ) ) ; average = gat Grid . get Value ( y Gridcell , x Gridcell ) * ww [ NUM_ ] ; w = ww [ NUM_ ] ; ww [ NUM_ ] = NUM_ / Math . sqrt ( Math . pow ( delta X , NUM_ ) + Math . pow ( grid Res - delta Y , NUM_ ) ) ; average = average + gat Grid . get Value ( y Gridcell + d Yi , x Gridcell ) * ww [ NUM_ ] ; w = w + ww [ NUM_ ] ; ww [ NUM_ ] = NUM_ / Math . sqrt ( Math . pow ( grid Res - delta X , NUM_ ) + Math . pow ( delta Y , NUM_ ) ) ; average = average + gat Grid . get Value ( y Gridcell , x Gridcell + d Xi ) * ww [ NUM_ ] ; w = w + ww [ NUM_ ] ; ww [ NUM_ ] = NUM_ / Math . sqrt ( Math . pow ( grid Res - delta X , NUM_ ) + Math . pow ( grid Res - delta Y , NUM_ ) ) ; average = average + gat Grid . get Value ( y Gridcell + d Yi , x Gridcell + d Xi ) * ww [ NUM_ ] ; w = w + ww [ NUM_ ] ; value = average / w ; } } else { value = gat Grid . get Value ( y Gridcell , x Gridcell ) ; } output Line = output Line + STR_ + value ; if ( include Statistics ) { value = gat Grid . get Value ( y Gridcell , x Gridcell ) ; if ( value == gat Grid . get No Data Value ( ) ) { min = Double . MAX VALUE ; max = Double . MIN VALUE ; sum = NUM_ ; sum Count = NUM_ ; mean = gat Grid . get No Data Value ( ) ; } else { min = value ; max = value ; sum = value ; sum Count = NUM_ ; } for ( int c = NUM_ ; c < NUM_ ; c ++ ) { neighbour Value = gat Grid . get Value ( y Gridcell + yd [ c ] , x Gridcell + xd [ c ] ) ; if ( neighbour Value != gat Grid . get No Data Value ( ) ) { if ( neighbour Value < min ) { min = neighbour Value ; } if ( neighbour Value > max ) { max = neighbour Value ; } sum = sum + neighbour Value ; sum Count = sum Count + NUM_ ; } } if ( sum Count == NUM_ ) { min = gat Grid . get No Data Value ( ) ; max = gat Grid . get No Data Value ( ) ; } else { mean = sum / sum Count ; } output Line = output Line + STR_ + min + STR_ + max + STR_ + mean ; } } if ( name != STR_ ) { output Line = output Line + STR_ + name ; } stream Writer . write ( output Line + System . line Separator ( ) ) ; if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * counter / number Of Lines ) ; update Progress ( STR_ , ( int ) progress ) ; } for ( Whitebox Raster gat Grid : gat Grids ) { gat Grid . close ( ) ; } stream Writer . close ( ) ; } catch ( IO Exception | Headless Exception | Number Format Exception e ) { show Feedback ( e . get Message ( ) ) ; } finally { update Progress ( STR_ , NUM_ ) ; am I Active = false ; my Host . plugin Complete ( ) ; } }
protected boolean [ ] can Predict ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance ) { print ( STR_ ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance ) ; print ( STR_ ) ; Vector < String > accepts = new Vector < String > ( ) ; accepts . add Element ( STR_ ) ; accepts . add Element ( STR_ ) ; accepts . add Element ( STR_ ) ; accepts . add Element ( STR_ ) ; accepts . add Element ( STR_ ) ; accepts . add Element ( STR_ ) ; accepts . add Element ( STR_ ) ; accepts . add Element ( STR_ ) ; accepts . add Element ( STR_ ) ; int num Train = get Num Instances ( ) , missing Level = NUM_ ; boolean predictor Missing = false ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , missing Level , predictor Missing , num Train , accepts ) ; }
private void synchronize Changed ( ) { clock . set Synchronize ( synchronize Check Box . is Selected ( ) , true ) ; changed = true ; }
private boolean show Header Of ( int position , @ Non Null T item , boolean init ) { I Header header = get Header Of ( item ) ; if ( header == null || get Pending Removed Item ( item ) != null ) return false ; if ( header . is Hidden ( ) ) { if ( DEBUG ) Log . v ( TAG , STR_ + position + STR_ + header ) ; header . set Hidden ( false ) ; if ( init ) { if ( position < m Items . size ( ) ) { m Items . add ( position , ( T ) header ) ; } else { m Items . add ( ( T ) header ) ; } return true ; } else { return add Item ( position , ( T ) header ) ; } } return false ; }
private int [ ] expand Key ( byte [ ] u Key ) { int [ ] key = new int [ NUM_ ] ; if ( u Key . length < NUM_ ) { byte [ ] tmp = new byte [ NUM_ ] ; System . arraycopy ( u Key , NUM_ , tmp , tmp . length - u Key . length , u Key . length ) ; u Key = tmp ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { key [ i ] = bytes To Word ( u Key , i * NUM_ ) ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( ( i & NUM_ ) < NUM_ ) { key [ i ] = ( ( key [ i - NUM_ ] & NUM_ ) << NUM_ | key [ i - NUM_ ] > > NUM_ ) & MASK ; } else if ( ( i & NUM_ ) == NUM_ ) { key [ i ] = ( ( key [ i - NUM_ ] & NUM_ ) << NUM_ | key [ i - NUM_ ] > > NUM_ ) & MASK ; } else { key [ i ] = ( ( key [ i - NUM_ ] & NUM_ ) << NUM_ | key [ i - NUM_ ] > > NUM_ ) & MASK ; } } return key ; }
private void multi Touch Controller ( ) { if ( DEBUG ) Log . i ( STR_ , STR_ + m Mode + STR_ + m Curr Pt . get Num Touch Points ( ) + STR_ + m Curr Pt . is Down ( ) + m Curr Pt . is Multi Touch ( ) ) ; switch ( m Mode ) { case MODE NOTHING : if ( DEBUG ) Log . i ( STR_ , STR_ ) ; if ( m Curr Pt . is Down ( ) ) { selected Object = object Canvas . get Draggable Object At Point ( m Curr Pt ) ; if ( selected Object != null ) { if ( object Canvas . point In Object Grab Area ( m Curr Pt , selected Object ) ) { m Mode = MODE ST GRAB ; object Canvas . select Object ( selected Object , m Curr Pt ) ; anchor At This Position And Scale ( ) ; m Settle Start Time = m Settle End Time = m Curr Pt . get Event Time ( ) ; } else { m Mode = MODE DRAG ; object Canvas . select Object ( selected Object , m Curr Pt ) ; anchor At This Position And Scale ( ) ; m Settle Start Time = m Settle End Time = m Curr Pt . get Event Time ( ) ; } } } break ; case MODE ST GRAB : if ( DEBUG ) Log . i ( STR_ , STR_ ) ; if ( ! m Curr Pt . is Down ( ) ) { m Mode = MODE NOTHING ; object Canvas . select Object ( ( selected Object = null ) , m Curr Pt ) ; m Drag Occurred = false ; } else { perform Drag Or Pinch ( ) ; } break ; case MODE DRAG : if ( DEBUG ) Log . i ( STR_ , STR_ ) ; if ( ! m Curr Pt . is Down ( ) ) { m Mode = MODE NOTHING ; object Canvas . select Object ( ( selected Object = null ) , m Curr Pt ) ; m Drag Occurred = false ; } else if ( m Curr Pt . is Multi Touch ( ) ) { m Mode = MODE PINCH ; anchor At This Position And Scale ( ) ; m Settle Start Time = m Curr Pt . get Event Time ( ) ; m Settle End Time = m Settle Start Time + EVENT SETTLE TIME INTERVAL ; } else { if ( m Curr Pt . get Event Time ( ) < m Settle End Time ) { anchor At This Position And Scale ( ) ; } else { perform Drag Or Pinch ( ) ; } } break ; case MODE PINCH : if ( DEBUG ) Log . i ( STR_ , STR_ ) ; if ( ! m Curr Pt . is Multi Touch ( ) || ! m Curr Pt . is Down ( ) ) { if ( ! m Curr Pt . is Down ( ) ) { m Mode = MODE NOTHING ; object Canvas . select Object ( ( selected Object = null ) , m Curr Pt ) ; } else { m Mode = MODE DRAG ; anchor At This Position And Scale ( ) ; m Settle Start Time = m Curr Pt . get Event Time ( ) ; m Settle End Time = m Settle Start Time + EVENT SETTLE TIME INTERVAL ; } } else { if ( Math . abs ( m Curr Pt . get X ( ) - m Prev Pt . get X ( ) ) > MAX MULTITOUCH POS JUMP SIZE || Math . abs ( m Curr Pt . get Y ( ) - m Prev Pt . get Y ( ) ) > MAX MULTITOUCH POS JUMP SIZE || Math . abs ( m Curr Pt . get Multi Touch Width ( ) - m Prev Pt . get Multi Touch Width ( ) ) * NUM_ > MAX MULTITOUCH DIM JUMP SIZE || Math . abs ( m Curr Pt . get Multi Touch Height ( ) - m Prev Pt . get Multi Touch Height ( ) ) * NUM_ > MAX MULTITOUCH DIM JUMP SIZE ) { anchor At This Position And Scale ( ) ; m Settle Start Time = m Curr Pt . get Event Time ( ) ; m Settle End Time = m Settle Start Time + EVENT SETTLE TIME INTERVAL ; } else if ( m Curr Pt . event Time < m Settle End Time ) { anchor At This Position And Scale ( ) ; } else { perform Drag Or Pinch ( ) ; } } break ; } if ( DEBUG ) Log . i ( STR_ , STR_ + m Mode + STR_ + m Curr Pt . get Num Touch Points ( ) + STR_ + m Curr Pt . is Down ( ) + m Curr Pt . is Multi Touch ( ) ) ; }
public void trim To Size ( ) { if ( names != null ) names . trim To Size ( ) ; if ( required Children != null ) { required Children . trim To Size ( ) ; for ( Gaz Entry nextkey : required Children . values ( ) ) { nextkey . trim To Size ( ) ; } } }
@ Override public void end RDF ( ) throws RDF Handler Exception { logger . info ( STR_ ) ; try { statement Cache . put ( DONE ) ; } catch ( Interrupted Exception e ) { throw new RDF Handler Exception ( STR_ , e ) ; } }
static void export Prefs ( Preferences prefs , Output Stream stream , boolean with Sub Tree ) throws IO Exception , Backing Store Exception { indent = - NUM_ ; Buffered Writer out = new Buffered Writer ( new Output Stream Writer ( stream , STR_ ) ) ; out . write ( HEADER ) ; out . new Line ( ) ; out . new Line ( ) ; out . write ( DOCTYPE ) ; out . write ( STR_ ) ; out . write ( PREFS DTD NAME ) ; out . write ( STR_ ) ; out . new Line ( ) ; out . new Line ( ) ; flush Start Tag ( STR_ , new String [ ] { STR_ } , new String [ ] { String . value Of ( XML VERSION ) } , out ) ; flush Start Tag ( STR_ , new String [ ] { STR_ } , new String [ ] { prefs . is User Node ( ) ? STR_ : STR_ } , out ) ; flush Empty Element ( STR_ , out ) ; String Tokenizer ancestors = new String Tokenizer ( prefs . absolute Path ( ) , STR_ ) ; export Node ( ancestors , prefs , with Sub Tree , out ) ; flush End Tag ( STR_ , out ) ; flush End Tag ( STR_ , out ) ; out . flush ( ) ; out = null ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static int to Int ( boolean b ) { return b ? - NUM_ : - NUM_ ; }
public static void draw Split String ( Font Renderer font Renderer , String string , int x , int y , int width , int colour ) { font Renderer . reset Styles ( ) ; font Renderer . text Color = colour ; List < String > list = font Renderer . list Formatted String To Width ( string , width ) ; Float Buffer current GL Color = Buffer Utils . create Float Buffer ( NUM_ ) ; int line = NUM_ ; for ( Iterator < String > iterator = list . iterator ( ) ; iterator . has Next ( ) ; y += font Renderer . FONT HEIGHT ) { String next = iterator . next ( ) ; if ( line > NUM_ ) { int current Colour = font Renderer . text Color ; GL 11 . gl Get Float ( GL 11 . GL CURRENT COLOR , current GL Color ) ; int gl Colour RGBA = ( ( int ) ( current GL Color . get ( NUM_ ) * NUM_ ) << NUM_ ) + ( ( int ) ( current GL Color . get ( NUM_ ) * NUM_ ) << NUM_ ) + ( ( int ) ( current GL Color . get ( NUM_ ) * NUM_ ) ) ; if ( gl Colour RGBA != current Colour ) { int j = NUM_ ; for ( ; j < font Renderer . color Code . length ; j ++ ) if ( font Renderer . color Code [ j ] == gl Colour RGBA ) { String code = Integer . to Hex String ( j % NUM_ ) ; next = STR_ + code + next ; break ; } } } font Renderer . draw String ( next , x , y , colour , false ) ; } }
public static URL [ ] path To UR Ls ( String path ) { String Tokenizer st = new String Tokenizer ( path , File . path Separator ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; int count = NUM_ ; while ( st . has More Tokens ( ) ) { URL url = file To URL ( new File ( st . next Token ( ) ) ) ; if ( url != null ) { urls [ count ++ ] = url ; } } urls = Arrays . copy Of ( urls , count ) ; return urls ; }
public static Remove Files Dialog Fragment new Instance ( OC File file ) { Array List < OC File > list = new Array List < > ( ) ; list . add ( file ) ; return new Instance ( list ) ; }
public static boolean match ( String expected Name , Principal principal ) { String host Name = get Server Name ( principal ) ; return ( expected Name . equals Ignore Case ( host Name ) ) ; }
public void insert Node Into ( Mutable Tree Node new Child , Mutable Tree Node parent , int index ) { parent . insert ( new Child , index ) ; int [ ] new Indexs = new int [ NUM_ ] ; new Indexs [ NUM_ ] = index ; nodes Were Inserted ( parent , new Indexs ) ; }
private boolean is Maintain Aspect Ratio ( ) { return preferences . get Boolean ( STR_ , false ) ; }
public static void notify All ( Object obj ) { synchronized ( obj ) { obj . notify All ( ) ; } }
public static void sync Immediately ( Context context ) { Bundle bundle = new Bundle ( ) ; bundle . put Boolean ( Content Resolver . SYNC EXTRAS EXPEDITED , true ) ; bundle . put Boolean ( Content Resolver . SYNC EXTRAS MANUAL , true ) ; Content Resolver . request Sync ( get Sync Account ( context ) , context . get String ( R . string . content authority ) , bundle ) ; }
public boolean is Property Set ( Object property ) { return false ; }
public void generate ( Batch Environment env , Class Doc input Class , File dest Dir ) { Remote Class remote Class = Remote Class . for Class ( env , input Class ) ; if ( remote Class == null ) { return ; } Stub Skeleton Writer writer = new Stub Skeleton Writer ( env , remote Class , version ) ; File stub File = source File For Class ( writer . stub Class Name ( ) , dest Dir ) ; try { Indenting Writer out = new Indenting Writer ( new Output Stream Writer ( new File Output Stream ( stub File ) ) ) ; writer . write Stub ( out ) ; out . close ( ) ; if ( env . verbose ( ) ) { env . output ( Resources . get Text ( STR_ , stub File . get Path ( ) ) ) ; } env . add Generated File ( stub File ) ; } catch ( IO Exception e ) { env . error ( STR_ , stub File . to String ( ) ) ; return ; } File skeleton File = source File For Class ( writer . skeleton Class Name ( ) , dest Dir ) ; if ( version == Stub Version . V 1 1 || version == Stub Version . VCOMPAT ) { try { Indenting Writer out = new Indenting Writer ( new Output Stream Writer ( new File Output Stream ( skeleton File ) ) ) ; writer . write Skeleton ( out ) ; out . close ( ) ; if ( env . verbose ( ) ) { env . output ( Resources . get Text ( STR_ , skeleton File . get Path ( ) ) ) ; } env . add Generated File ( skeleton File ) ; } catch ( IO Exception e ) { env . error ( STR_ , skeleton File . to String ( ) ) ; return ; } } else { File skeleton Class File = class File For Class ( writer . skeleton Class Name ( ) , dest Dir ) ; skeleton File . delete ( ) ; skeleton Class File . delete ( ) ; } }
public Builder certificate Info ( Certificate Info certificate Info ) { this . certificate Info = certificate Info ; return this ; }
private boolean process Transaction ( Transaction transaction ) throws IO Exception { synchronized ( m Processing ) { for ( Transaction t : m Pending ) { if ( t . is Equivalent ( transaction ) ) { if ( LOCAL LOGV ) Log . v ( TAG , STR_ + transaction . get Service Id ( ) ) ; return true ; } } for ( Transaction t : m Processing ) { if ( t . is Equivalent ( transaction ) ) { if ( LOCAL LOGV ) Log . v ( TAG , STR_ + transaction . get Service Id ( ) ) ; return true ; } } if ( LOCAL LOGV ) Log . v ( TAG , STR_ ) ; int connectivity Result = begin Mms Connectivity ( ) ; if ( connectivity Result == Phone Constants . APN REQUEST STARTED ) { m Pending . add ( transaction ) ; if ( LOCAL LOGV ) Log . v ( TAG , STR_ + STR_ ) ; return true ; } if ( LOCAL LOGV ) Log . v ( TAG , STR_ + transaction ) ; m Processing . add ( transaction ) ; } send Message Delayed ( obtain Message ( EVENT CONTINUE MMS CONNECTIVITY ) , APN EXTENSION WAIT ) ; if ( LOCAL LOGV ) Log . v ( TAG , STR_ + transaction ) ; transaction . attach ( Transaction Service . this ) ; transaction . process ( ) ; return true ; }
public static String trim Leading And Trailing Slashes ( final String in ) { if ( null == in ) return in ; String out = in ; if ( out . starts With ( STR_ ) ) { out = out . substring ( NUM_ ) ; } if ( out . ends With ( STR_ ) ) { out = out . substring ( NUM_ , out . length ( ) - NUM_ ) ; } return out ; }
@ Override public void send Full Status ( Train train ) throws IO Exception { Array List < Attribute > status = new Array List < Attribute > ( ) ; if ( train != null ) { status . add ( new Attribute ( TRAIN , train . get Name ( ) ) ) ; status . add ( new Attribute ( TRAINLOCATION , train . get Current Location Name ( ) ) ) ; status . add ( new Attribute ( TRAINLENGTH , String . value Of ( train . get Train Length ( ) ) ) ) ; status . add ( new Attribute ( TRAINWEIGHT , String . value Of ( train . get Train Weight ( ) ) ) ) ; status . add ( new Attribute ( TRAINCARS , String . value Of ( train . get Number Cars In Train ( ) ) ) ) ; status . add ( new Attribute ( TRAINLEADLOCO , construct Train Lead Loco ( train . get Name ( ) ) ) ) ; status . add ( new Attribute ( TRAINCABOOSE , construct Train Caboose ( train . get Name ( ) ) ) ) ; send Message ( status ) ; } }
private static String format Address ( Interface Address interface Address ) throws IO Exception { String Builder sb = new String Builder ( ) ; Inet Address address = interface Address . get Address ( ) ; if ( address instanceof Inet 6 Address ) { sb . append ( STR_ ) ; sb . append ( Network Address . format Address ( address ) ) ; sb . append ( STR_ ) ; sb . append ( interface Address . get Network Prefix Length ( ) ) ; } else { sb . append ( STR_ ) ; sb . append ( Network Address . format Address ( address ) ) ; int netmask = NUM_ << ( NUM_ - interface Address . get Network Prefix Length ( ) ) ; sb . append ( STR_ + Network Address . format Address ( Inet Address . get By Address ( new byte [ ] { ( byte ) ( netmask > > > NUM_ ) , ( byte ) ( netmask > > > NUM_ & NUM_ ) , ( byte ) ( netmask > > > NUM_ & NUM_ ) , ( byte ) ( netmask & NUM_ ) } ) ) ) ; Inet Address broadcast = interface Address . get Broadcast ( ) ; if ( broadcast != null ) { sb . append ( STR_ + Network Address . format Address ( broadcast ) ) ; } } if ( address . is Loopback Address ( ) ) { sb . append ( STR_ ) ; } else if ( address . is Link Local Address ( ) ) { sb . append ( STR_ ) ; } else if ( address . is Site Local Address ( ) ) { sb . append ( STR_ ) ; } return sb . to String ( ) ; }
static void clear Instance Cache ( ) { synchronized ( INSTANCE CACHE ) { INSTANCE CACHE . clear ( ) ; } }
public Execution ( Sequence owner ) { this . the List = new Array List < > ( owner . size ( ) ) ; for ( int i = NUM_ ; i < owner . size ( ) ; i ++ ) { the List . add ( Not Executed . create ( ) ) ; } this . covered Classes = new Linked Hash Set < > ( ) ; }
public static String entity Encode ( String text ) { String result = text ; if ( result == null ) { return result ; } return String Escape Utils . escape Xml ( XML String Util . escape Control Chrs ( result ) ) ; }
private Column Error make Duplicate Role Error ( Entry < String , List < Integer > > role Entry ) { final String duplicate Role Message = I 18 N . get GUI Label ( STR_ , role Entry . get Key ( ) , list To String ( role Entry . get Value ( ) ) ) ; return new Column Error ( role Entry . get Value ( ) , role Entry . get Key ( ) , duplicate Role Message ) ; }
private String process Special Characters ( String s ) { if ( s == null ) { return null ; } char [ ] char Str = s . to Char Array ( ) ; String special Str = STR_ ; for ( int i = NUM_ ; i < char Str . length ; i ++ ) { if ( char Str [ i ] == STR_ ) { special Str = special Str . concat ( STR_ ) ; } else if ( char Str [ i ] == STR_ ) { special Str = special Str . concat ( STR_ ) ; } else if ( char Str [ i ] == STR_ ) { special Str = special Str . concat ( STR_ ) ; } else if ( char Str [ i ] == STR_ ) { special Str = special Str . concat ( STR_ ) ; } else if ( char Str [ i ] == STR_ ) { special Str = special Str . concat ( STR_ ) ; } else { special Str = special Str . concat ( String . value Of ( char Str [ i ] ) ) ; } } s = special Str ; return s ; }
public long cminflt ( ) { return Long . parse Long ( fields [ NUM_ ] ) ; }
private void write UTF Body ( String s ) throws IO Exception { int len = s . length ( ) ; for ( int off = NUM_ ; off < len ; ) { int csize = Math . min ( len - off , CHAR BUF SIZE ) ; s . get Chars ( off , off + csize , cbuf , NUM_ ) ; for ( int cpos = NUM_ ; cpos < csize ; cpos ++ ) { char c = cbuf [ cpos ] ; if ( c <= NUM_ && c != NUM_ ) write ( c ) ; else if ( c > NUM_ ) { write ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; write ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; write ( NUM_ | ( ( c ) & NUM_ ) ) ; } else { write ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; write ( NUM_ | ( ( c ) & NUM_ ) ) ; } } off += csize ; } }
@ Override public int hash Code ( ) { final int prime = NUM_ ; int result = NUM_ ; result = prime * result + ( ( carbon Table Identifier == null ) ? NUM_ : carbon Table Identifier . hash Code ( ) ) ; result = prime * result + ( ( store Path == null ) ? NUM_ : store Path . hash Code ( ) ) ; return result ; }
public static X 509 CRL Entry Impl to Impl ( X 509 CRL Entry entry ) throws CRL Exception { if ( entry instanceof X 509 CRL Entry Impl ) { return ( X 509 CRL Entry Impl ) entry ; } else { return new X 509 CRL Entry Impl ( entry . get Encoded ( ) ) ; } }
public Challan Info ( final Receipt Header receipt Header , final Egov Common egov Common , final Receipt Header receipt Header Ref Obj , final Chart Of Accounts Hibernate DAO chart Of Accounts Hibernate DAO , final Persistence Service persistence Service ) { this . receipt Header = receipt Header ; if ( receipt Header Ref Obj != null && receipt Header Ref Obj . get Challan ( ) != null ) receip Header Reference Obj = receipt Header Ref Obj ; for ( final Receipt Detail receipt Detail : receipt Header . get Receipt Details ( ) ) { account Details . add ( new Receipt Account Info Impl ( receipt Detail , chart Of Accounts Hibernate DAO , persistence Service ) ) ; for ( final Account Payee Detail account Payee Detail : receipt Detail . get Account Payee Details ( ) ) account Payee Details . add ( new Account Payee Detail Info ( account Payee Detail , egov Common ) ) ; } for ( final Instrument Header instrument Header : receipt Header . get Receipt Instrument ( ) ) instrument Details . add ( new Receipt Instrument Info Impl ( instrument Header ) ) ; }
private double psfunc 2 ( double x , double t 1 , int dim , int css ) { dim = dim + NUM_ ; double xy = NUM_ * ( x - NUM_ ) ; if ( l Type == NUM_ ) { return xy - Math . pow ( t 1 , NUM_ * ( number Of Variables + NUM_ * dim - NUM_ ) / ( number Of Variables - NUM_ ) ) ; } else if ( l Type == NUM_ ) { double theta = NUM_ * Math . PI * t 1 + dim * Math . PI / number Of Variables ; return xy - Math . sin ( theta ) ; } else if ( l Type == NUM_ ) { double theta = NUM_ * Math . PI * t 1 + dim * Math . PI / number Of Variables ; double ra = NUM_ * t 1 ; if ( css == NUM_ ) { return xy - ra * Math . cos ( theta ) ; } else { return xy - ra * Math . sin ( theta ) ; } } else if ( l Type == NUM_ ) { double theta = NUM_ * Math . PI * t 1 + dim * Math . PI / number Of Variables ; double ra = NUM_ * t 1 ; if ( css == NUM_ ) { return xy - ra * Math . cos ( theta / NUM_ ) ; } else { return xy - ra * Math . sin ( theta ) ; } } else if ( l Type == NUM_ ) { double rho = NUM_ ; double phi = Math . PI * t 1 ; double theta = NUM_ * Math . PI * t 1 + dim * Math . PI / number Of Variables ; if ( css == NUM_ ) { return xy - rho * Math . sin ( phi ) * Math . sin ( theta ) ; } else if ( css == NUM_ ) { return xy - rho * Math . sin ( phi ) * Math . cos ( theta ) ; } else { return xy - rho * Math . cos ( phi ) ; } } else if ( l Type == NUM_ ) { double theta = NUM_ * Math . PI * t 1 + dim * Math . PI / number Of Variables ; double ra = NUM_ * t 1 * ( t 1 * Math . cos ( NUM_ * theta ) + NUM_ ) ; if ( css == NUM_ ) { return xy - ra * Math . cos ( theta ) ; } else { return xy - ra * Math . sin ( theta ) ; } } else { throw new Illegal State Exception ( ) ; } }
@ Override public void create Chart Print Job ( ) { Printer Job job = Printer Job . get Printer Job ( ) ; Page Format pf = job . default Page ( ) ; Page Format pf 2 = job . page Dialog ( pf ) ; if ( pf 2 != pf ) { job . set Printable ( this , pf 2 ) ; if ( job . print Dialog ( ) ) { try { job . print ( ) ; } catch ( Printer Exception e ) { J Option Pane . show Message Dialog ( this , e ) ; } } } }
private void send Discarded ( Service Registrar reg , String [ ] cur Groups ) { Service ID srvc ID = reg . get Service ID ( ) ; if ( cur Groups == null ) { Unicast Response resp = ( Unicast Response ) registrars . get ( srvc ID ) ; if ( resp == null ) return ; cur Groups = resp . get Groups ( ) ; } if ( registrars . remove ( srvc ID ) != null ) { reg Info . remove ( srvc ID ) ; if ( ! listeners . is Empty ( ) ) { add Notify ( ( Array List ) listeners . clone ( ) , map Reg To Groups ( reg , cur Groups ) , DISCARDED ) ; } } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Marker Axis Band ) ) { return false ; } Marker Axis Band that = ( Marker Axis Band ) obj ; if ( this . top Outer Gap != that . top Outer Gap ) { return false ; } if ( this . top Inner Gap != that . top Inner Gap ) { return false ; } if ( this . bottom Inner Gap != that . bottom Inner Gap ) { return false ; } if ( this . bottom Outer Gap != that . bottom Outer Gap ) { return false ; } if ( ! Object Utilities . equal ( this . font , that . font ) ) { return false ; } if ( ! Object Utilities . equal ( this . markers , that . markers ) ) { return false ; } return true ; }
public static String convert To ARGB ( int color ) { String alpha = Integer . to Hex String ( Color . alpha ( color ) ) ; String red = Integer . to Hex String ( Color . red ( color ) ) ; String green = Integer . to Hex String ( Color . green ( color ) ) ; String blue = Integer . to Hex String ( Color . blue ( color ) ) ; if ( alpha . length ( ) == NUM_ ) { alpha = STR_ + alpha ; } if ( red . length ( ) == NUM_ ) { red = STR_ + red ; } if ( green . length ( ) == NUM_ ) { green = STR_ + green ; } if ( blue . length ( ) == NUM_ ) { blue = STR_ + blue ; } return STR_ + alpha + red + green + blue ; }
public void for Each ( Tri Consumer < Integer , K , V > action ) { Objects . require Non Null ( action ) ; for Each ( null ) ; }
public void release ( ) { if ( m Media Player != null ) { if ( m Media Player . is Playing ( ) ) { m Media Player . stop ( ) ; } m Media Player . reset ( ) ; m Media Player . release ( ) ; } m Media Player = null ; }
@ Rpc Method public void delete Vm ( String vm Id , List < String > disk Ids To Detach , Async Method Callback < Host . Async Client . delete vm call > handler ) throws Rpc Exception { ensure Client ( ) ; Delete Vm Request delete Vm Request = new Delete Vm Request ( vm Id ) ; delete Vm Request . set Disk ids ( disk Ids To Detach ) ; client Proxy . set Timeout ( DELETE VM TIMEOUT MS ) ; logger . info ( STR_ , vm Id , get Host Ip ( ) , delete Vm Request ) ; try { client Proxy . delete vm ( delete Vm Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public boolean has Alpha Changed From ( float v ) { return ( Float . compare ( alpha , v ) != NUM_ ) ; }
public void register Provider ( Class < ? > dto Interface , Dto Provider < ? > provider ) { dto Interface 2 Providers . put ( dto Interface , provider ) ; }
public void close ( Result Set rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQL Exception e ) { } } }
public Coords drift Add Smoke ( Coords coords , int wind Dir , int wind Str ) { return drift Add Smoke ( coords , wind Dir , wind Str , NUM_ ) ; }
OF Channel Handler ( @ Nonnull IOF Switch Manager switch Manager , @ Nonnull I New OF Connection Listener new Connection Listener , @ Nonnull Channel Pipeline pipeline , @ Nonnull I Debug Counter Service debug Counters , @ Nonnull Timer timer , @ Nonnull List < U 32 > of Bitmaps , @ Nonnull OF Factory default Factory ) { Preconditions . check Not Null ( switch Manager , STR_ ) ; Preconditions . check Not Null ( new Connection Listener , STR_ ) ; Preconditions . check Not Null ( pipeline , STR_ ) ; Preconditions . check Not Null ( timer , STR_ ) ; Preconditions . check Not Null ( debug Counters , STR_ ) ; this . pipeline = pipeline ; this . debug Counters = debug Counters ; this . new Connection Listener = new Connection Listener ; this . counters = switch Manager . get Counters ( ) ; this . state = new Init State ( ) ; this . timer = timer ; this . of Bitmaps = of Bitmaps ; this . factory = default Factory ; log . debug ( STR_ , String . format ( STR_ , System . identity Hash Code ( this ) ) ) ; }
protected boolean check Original Model Fields ( Calendar Event Model original Model ) { if ( m All Day != original Model . m All Day ) { return false ; } if ( m Attendees List == null ) { if ( original Model . m Attendees List != null ) { return false ; } } else if ( ! m Attendees List . equals ( original Model . m Attendees List ) ) { return false ; } if ( m Calendar Id != original Model . m Calendar Id ) { return false ; } if ( m Calendar Color != original Model . m Calendar Color ) { return false ; } if ( m Calendar Color Initialized != original Model . m Calendar Color Initialized ) { return false ; } if ( m Guests Can Invite Others != original Model . m Guests Can Invite Others ) { return false ; } if ( m Guests Can Modify != original Model . m Guests Can Modify ) { return false ; } if ( m Guests Can See Guests != original Model . m Guests Can See Guests ) { return false ; } if ( m Organizer Can Respond != original Model . m Organizer Can Respond ) { return false ; } if ( m Calendar Access Level != original Model . m Calendar Access Level ) { return false ; } if ( m Model Updated With Event Cursor != original Model . m Model Updated With Event Cursor ) { return false ; } if ( m Has Alarm != original Model . m Has Alarm ) { return false ; } if ( m Has Attendee Data != original Model . m Has Attendee Data ) { return false ; } if ( m Id != original Model . m Id ) { return false ; } if ( m Is Organizer != original Model . m Is Organizer ) { return false ; } if ( m Organizer == null ) { if ( original Model . m Organizer != null ) { return false ; } } else if ( ! m Organizer . equals ( original Model . m Organizer ) ) { return false ; } if ( m Original All Day == null ) { if ( original Model . m Original All Day != null ) { return false ; } } else if ( ! m Original All Day . equals ( original Model . m Original All Day ) ) { return false ; } if ( m Original Time == null ) { if ( original Model . m Original Time != null ) { return false ; } } else if ( ! m Original Time . equals ( original Model . m Original Time ) ) { return false ; } if ( m Owner Account == null ) { if ( original Model . m Owner Account != null ) { return false ; } } else if ( ! m Owner Account . equals ( original Model . m Owner Account ) ) { return false ; } if ( m Reminders == null ) { if ( original Model . m Reminders != null ) { return false ; } } else if ( ! m Reminders . equals ( original Model . m Reminders ) ) { return false ; } if ( m Self Attendee Status != original Model . m Self Attendee Status ) { return false ; } if ( m Owner Attendee Id != original Model . m Owner Attendee Id ) { return false ; } if ( m Sync Account == null ) { if ( original Model . m Sync Account != null ) { return false ; } } else if ( ! m Sync Account . equals ( original Model . m Sync Account ) ) { return false ; } if ( m Sync Account Type == null ) { if ( original Model . m Sync Account Type != null ) { return false ; } } else if ( ! m Sync Account Type . equals ( original Model . m Sync Account Type ) ) { return false ; } if ( m Sync Id == null ) { if ( original Model . m Sync Id != null ) { return false ; } } else if ( ! m Sync Id . equals ( original Model . m Sync Id ) ) { return false ; } if ( m Timezone == null ) { if ( original Model . m Timezone != null ) { return false ; } } else if ( ! m Timezone . equals ( original Model . m Timezone ) ) { return false ; } if ( m Timezone 2 == null ) { if ( original Model . m Timezone 2 != null ) { return false ; } } else if ( ! m Timezone 2 . equals ( original Model . m Timezone 2 ) ) { return false ; } if ( m Availability != original Model . m Availability ) { return false ; } if ( m Uri == null ) { if ( original Model . m Uri != null ) { return false ; } } else if ( ! m Uri . equals ( original Model . m Uri ) ) { return false ; } if ( m Access Level != original Model . m Access Level ) { return false ; } if ( m Event Status != original Model . m Event Status ) { return false ; } if ( m Event Color != original Model . m Event Color ) { return false ; } if ( m Event Color Initialized != original Model . m Event Color Initialized ) { return false ; } return true ; }
public void add Event Source Listener ( Event Source Listener listener ) { LOG . entering ( CLASS NAME , STR_ , listener ) ; if ( listener == null ) { throw new Null Pointer Exception ( STR_ ) ; } listeners . add ( listener ) ; }
static boolean is Accessible ( Member m ) { return m != null && Modifier . is Public ( m . get Modifiers ( ) ) && ! is Synthetic ( m ) ; }
private void handle Image Map Area ( HTML Element area Tag ) { if ( cur Image Map != null ) { String shape = area Tag . get Attribute By Id ( HTML Element . ATTR SHAPE ) ; boolean supported Shape = false ; if ( shape != null ) { String href Str = area Tag . get Attribute By Id ( HTML Element . ATTR HREF ) ; if ( shape . equals Ignore Case ( STR_ ) ) { supported Shape = true ; cur Image Map . set Default Link ( href Str ) ; } else if ( ( shape . equals Ignore Case ( STR_ ) ) || ( shape . equals Ignore Case ( STR_ ) ) ) { supported Shape = true ; String coords Str = area Tag . get Attribute By Id ( HTML Element . ATTR COORDS ) ; if ( ( coords Str != null ) && ( href Str != null ) ) { String cur Val Str = STR_ ; int coords [ ] = new int [ NUM_ ] ; int cur Coord = NUM_ ; boolean error = true ; try { for ( int c = NUM_ ; c < coords Str . length ( ) ; c ++ ) { char ch = coords Str . char At ( c ) ; if ( ch != STR_ ) { cur Val Str += ch ; } else { coords [ cur Coord ] = Integer . parse Int ( cur Val Str ) ; cur Coord ++ ; cur Val Str = STR_ ; } } if ( cur Val Str . length ( ) > NUM_ ) { coords [ cur Coord ] = Integer . parse Int ( cur Val Str ) ; cur Coord ++ ; } if ( shape . equals Ignore Case ( STR_ ) ) { if ( cur Coord == NUM_ ) { cur Image Map . add Rect Area ( new Rectangle ( coords [ NUM_ ] , coords [ NUM_ ] , coords [ NUM_ ] - coords [ NUM_ ] , coords [ NUM_ ] - coords [ NUM_ ] ) , href Str ) ; error = false ; } } else if ( cur Coord == NUM_ ) { cur Image Map . add Rect Area ( new Rectangle ( coords [ NUM_ ] - coords [ NUM_ ] , coords [ NUM_ ] - coords [ NUM_ ] , coords [ NUM_ ] * NUM_ + NUM_ , coords [ NUM_ ] * NUM_ + NUM_ ) , href Str ) ; error = false ; } } catch ( Exception e ) { } if ( error ) { notify Image Map Error ( STR_ + coords Str , HTML Callback . ERROR ATTIBUTE VALUE INVALID , HTML Element . ATTR COORDS , coords Str ) ; } } } } if ( ! supported Shape ) { notify Image Map Error ( STR_ + shape , HTML Callback . ERROR ATTIBUTE VALUE INVALID , HTML Element . ATTR SHAPE , shape ) ; } } else { notify Image Map Error ( STR_ , HTML Callback . ERROR INVALID TAG HIERARCHY , - NUM_ , null ) ; } }
public void update Record Soft ( int id ) throws IO Exception { if ( ! database . is Open ( ) ) throw new Illegal State Exception ( STR_ ) ; if ( hard Write Mode ) throw new Illegal State Exception ( STR_ ) ; if ( id > last Transaction Insert Id ) throw new Illegal State Exception ( STR_ ) ; if ( id >= committed Next Row Id ) return ; if ( soft Mode Saved Rows . get ( id , false ) ) return ; soft Mode Saved Rows . put ( id , true ) ; synchronized ( this ) { get Record ( temp Record Data , id ) ; } Util . write Int ( roll Back Out , id ) ; roll Back Out . write ( temp Record Data ) ; }
public void add Morph Listener ( Morph Listener listener ) { if ( ! m Morph Listeners . contains ( listener ) ) { m Morph Listeners . add ( listener ) ; } }
public Hash Map < String , String > read Config ( String config File Path ) throws Exception { file Path = config File Path ; Vector < String > content Vec = read File Into Vector ( config File Path ) ; content Vec = filter Comments From Input ( content Vec ) ; split Lines Into Hash Map ( content Vec ) ; config Read = new Timestamp ( System . current Time Millis ( ) ) ; return get Config Map ( ) ; }
public static String convert Method Signature ( Java Class java Class , Method method ) { return convert Method Signature ( java Class . get Class Name ( ) , method . get Name ( ) , method . get Signature ( ) ) ; }
private void generate Legal Times Tree ( ) { int k 0 = Key Event . KEYCODE 0 ; int k 1 = Key Event . KEYCODE 1 ; int k 2 = Key Event . KEYCODE 2 ; int k 3 = Key Event . KEYCODE 3 ; int k 4 = Key Event . KEYCODE 4 ; int k 5 = Key Event . KEYCODE 5 ; int k 6 = Key Event . KEYCODE 6 ; int k 7 = Key Event . KEYCODE 7 ; int k 8 = Key Event . KEYCODE 8 ; int k 9 = Key Event . KEYCODE 9 ; m Legal Times Tree = new Node ( ) ; if ( m Is 24 Hour Mode ) { Node minute First Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; Node minute Second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; minute First Digit . add Child ( minute Second Digit ) ; Node first Digit = new Node ( k 0 , k 1 ) ; m Legal Times Tree . add Child ( first Digit ) ; Node second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; Node third Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; second Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; first Digit = new Node ( k 2 ) ; m Legal Times Tree . add Child ( first Digit ) ; second Digit = new Node ( k 0 , k 1 , k 2 , k 3 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; second Digit = new Node ( k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute Second Digit ) ; first Digit = new Node ( k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( minute First Digit ) ; } else { Node ampm = new Node ( get Am Or Pm Key Code ( AM ) , get Am Or Pm Key Code ( PM ) ) ; Node first Digit = new Node ( k 1 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( ampm ) ; Node second Digit = new Node ( k 0 , k 1 , k 2 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( ampm ) ; Node third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; Node fourth Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; third Digit . add Child ( fourth Digit ) ; fourth Digit . add Child ( ampm ) ; third Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; second Digit = new Node ( k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; first Digit = new Node ( k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( ampm ) ; second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; } }
public byte [ ] serialize Session Data ( Custom Request Session session , Session Serialization Metadata metadata ) throws IO Exception { byte [ ] serialized = null ; try ( Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( new Buffered Output Stream ( bos ) ) ) { oos . write Object ( metadata ) ; session . write Object Data ( oos ) ; oos . flush ( ) ; serialized = bos . to Byte Array ( ) ; } return serialized ; }
@ Override public void purge Logs Older Than ( long min Tx Id To Keep ) throws IO Exception { Preconditions . check Argument ( min Tx Id To Keep > NUM_ , STR_ + min Tx Id To Keep ) ; check Closed Or In Error ( STR_ ) ; BK Log Write Handler ledger Handler = create Write Handler ( true ) ; try { LOG . info ( STR_ , ledger Handler . get Fully Qualified Name ( ) , min Tx Id To Keep ) ; Future Utils . result ( ledger Handler . purge Log Segments Older Than Txn Id ( min Tx Id To Keep ) ) ; } finally { Utils . close Quietly ( ledger Handler ) ; } }
private Document create Document ( final Input Stream input Stream , final Form Data Content Disposition form Data Content Disposition ) { final Document document = new Document ( ) ; final List < File > files = new Array List < File > ( NUM_ ) ; final List < String > content Types = new Array List < String > ( NUM_ ) ; final List < String > file Names = new Array List < String > ( NUM_ ) ; File file = null ; if ( input Stream != null && form Data Content Disposition != null ) { file Names . add ( form Data Content Disposition . get File Name ( ) ) ; document . set Uploads File Name ( file Names ) ; file = write To File ( input Stream , form Data Content Disposition . get File Name ( ) ) ; files . add ( file ) ; document . set Uploads ( files ) ; content Types . add ( Message Format . format ( THIRD PARTY CONTENT TYPE , Filename Utils . get Extension ( file . get Path ( ) ) ) ) ; document . set Uploads Content Type ( content Types ) ; } return document ; }
void update Grid ( ) { if ( ! grid Valid ) { rows . remove All Elements ( ) ; int n = get View Count ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { View v = get View ( i ) ; if ( v instanceof Table Row ) { rows . add Element ( ( Table Row ) v ) ; Table Row rv = ( Table Row ) v ; rv . clear Filled Columns ( ) ; rv . set Row ( i ) ; } } int max Columns = NUM_ ; int nrows = rows . size ( ) ; for ( int row = NUM_ ; row < nrows ; row ++ ) { Table Row rv = get Row ( row ) ; int col = NUM_ ; for ( int cell = NUM_ ; cell < rv . get View Count ( ) ; cell ++ , col ++ ) { View cv = rv . get View ( cell ) ; for ( ; rv . is Filled ( col ) ; col ++ ) ; int row Span = get Rows Occupied ( cv ) ; int col Span = get Columns Occupied ( cv ) ; if ( ( col Span > NUM_ ) || ( row Span > NUM_ ) ) { int row Limit = row + row Span ; int col Limit = col + col Span ; for ( int i = row ; i < row Limit ; i ++ ) { for ( int j = col ; j < col Limit ; j ++ ) { if ( i != row || j != col ) { add Fill ( i , j ) ; } } } if ( col Span > NUM_ ) { col += col Span - NUM_ ; } } } max Columns = Math . max ( max Columns , col ) ; } column Spans = new int [ max Columns ] ; column Offsets = new int [ max Columns ] ; column Requirements = new Size Requirements [ max Columns ] ; for ( int i = NUM_ ; i < max Columns ; i ++ ) { column Requirements [ i ] = new Size Requirements ( ) ; } grid Valid = true ; } }
public static String enumerate Collection With Hash ( final Collection < String > collection ) { if ( collection == null ) { return STR_ ; } final List < String > result = new Array List < String > ( collection . size ( ) ) ; for ( String entry : collection ) { result . add ( STR_ + entry ) ; } return enumerate Collection ( result ) ; }
public void schedule Tasks ( ) { Task Manager . Task [ ] tmp = create Tasks ( ) ; if ( tmp != null ) { if ( logger . is Loggable ( Level . FINEST ) ) { logger . log ( Level . FINEST , STR_ , new Integer ( tmp . length ) ) ; } results = new Object [ tmp . length ] ; attempts = new int [ tmp . length ] ; set Pending ( tmp . length ) ; for ( int i = NUM_ ; i < tmp . length ; i ++ ) { synchronized ( tasks ) { tasks . put ( tmp [ i ] , new Integer ( i ) ) ; pool . add ( tmp [ i ] ) ; if ( logger . is Loggable ( Level . FINEST ) ) { logger . log ( Level . FINEST , STR_ , tmp [ i ] ) ; } attempts [ i ] = NUM_ ; } } } }
@ Override public void commit ( ) { if ( write Cache != null ) { synchronized ( this ) { flush Write Cache ( ) ; } } super . commit ( ) ; }
public static void save Icon Only Pref ( boolean logout On Exit ) { Preferences prefs = get Prefs ( ) ; prefs . put Boolean ( get Custom User Key ( ICON ONLY KEY ) , logout On Exit ) ; flush Prefs ( prefs ) ; }
public int encrypt Block ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STR_ ) ; } if ( ( out Off + block Size ) > out . length ) { throw new Data Length Exception ( STR_ ) ; } cipher . process Block ( cfb V , NUM_ , cfb Out V , NUM_ ) ; for ( int i = NUM_ ; i < block Size ; i ++ ) { out [ out Off + i ] = ( byte ) ( cfb Out V [ i ] ^ in [ in Off + i ] ) ; } System . arraycopy ( cfb V , block Size , cfb V , NUM_ , cfb V . length - block Size ) ; System . arraycopy ( out , out Off , cfb V , cfb V . length - block Size , block Size ) ; return block Size ; }
private Log discover Log Implementation ( String log Category ) throws Log Configuration Exception { if ( is Diagnostics Enabled ( ) ) { log Diagnostic ( STR_ ) ; } init Configuration ( ) ; Log result = null ; String specified Log Class Name = find User Specified Log Class Name ( ) ; if ( specified Log Class Name != null ) { if ( is Diagnostics Enabled ( ) ) { log Diagnostic ( STR_ + specified Log Class Name + STR_ ) ; } result = create Log From Class ( specified Log Class Name , log Category , true ) ; if ( result == null ) { String Buffer message Buffer = new String Buffer ( STR_ ) ; message Buffer . append ( specified Log Class Name ) ; message Buffer . append ( STR_ ) ; if ( specified Log Class Name != null ) { inform Upon Similar Name ( message Buffer , specified Log Class Name , LOGGING IMPL LOG 4 J LOGGER ) ; inform Upon Similar Name ( message Buffer , specified Log Class Name , LOGGING IMPL JDK 14 LOGGER ) ; inform Upon Similar Name ( message Buffer , specified Log Class Name , LOGGING IMPL LUMBERJACK LOGGER ) ; inform Upon Similar Name ( message Buffer , specified Log Class Name , LOGGING IMPL SIMPLE LOGGER ) ; } throw new Log Configuration Exception ( message Buffer . to String ( ) ) ; } return result ; } if ( is Diagnostics Enabled ( ) ) { log Diagnostic ( STR_ + STR_ ) ; } for ( int i = NUM_ ; ( i < classes To Discover . length ) && ( result == null ) ; ++ i ) { result = create Log From Class ( classes To Discover [ i ] , log Category , true ) ; } if ( result == null ) { throw new Log Configuration Exception ( STR_ ) ; } return result ; }
public static void newick ( Tree tree , Node Ref node , boolean labels , Branch Length Type lengths , Number Format format , Branch Rates branch Rates , Tree Trait Provider [ ] tree Trait Providers , Map < String , Integer > id Map , String Buffer buffer ) { Node Ref parent = tree . get Parent ( node ) ; if ( tree . is External ( node ) ) { if ( ! labels ) { int k = node . get Number ( ) ; if ( id Map != null ) { buffer . append ( id Map . get ( tree . get Taxon Id ( k ) ) ) ; } else { buffer . append ( ( k + NUM_ ) ) ; } } else { String label = tree . get Taxon Id ( node . get Number ( ) ) ; if ( label . contains ( STR_ ) || label . contains ( STR_ ) || label . contains ( STR_ ) || label . contains ( STR_ ) ) { buffer . append ( STR_ ) ; buffer . append ( label ) ; buffer . append ( STR_ ) ; } else { buffer . append ( label ) ; } } } else { buffer . append ( STR_ ) ; newick ( tree , tree . get Child ( node , NUM_ ) , labels , lengths , format , branch Rates , tree Trait Providers , id Map , buffer ) ; for ( int i = NUM_ ; i < tree . get Child Count ( node ) ; i ++ ) { buffer . append ( STR_ ) ; newick ( tree , tree . get Child ( node , i ) , labels , lengths , format , branch Rates , tree Trait Providers , id Map , buffer ) ; } buffer . append ( STR_ ) ; } write Tree Traits ( buffer , tree , node , tree Trait Providers , Tree Trait . Intent . NODE ) ; if ( parent != null && lengths != Branch Length Type . NO BRANCH LENGTHS ) { buffer . append ( STR_ ) ; write Tree Traits ( buffer , tree , node , tree Trait Providers , Tree Trait . Intent . BRANCH ) ; if ( lengths != Branch Length Type . NO BRANCH LENGTHS ) { double length = tree . get Node Height ( parent ) - tree . get Node Height ( node ) ; if ( lengths == Branch Length Type . LENGTHS AS SUBSTITUTIONS ) { if ( branch Rates == null ) { throw new Illegal Argument Exception ( STR_ ) ; } length *= branch Rates . get Branch Rate ( tree , node ) ; } String length String ; if ( format != null ) { length String = format . format ( length ) ; } else { length String = String . value Of ( length ) ; } buffer . append ( length String ) ; } } }
public Bottom Navigation Bar add Item ( Bottom Navigation Item item ) { m Bottom Navigation Items . add ( item ) ; return this ; }
public void bind Tree ( Container ui , int defer , boolean object Lead ) { int component Count = ui . get Component Count ( ) ; for ( int iter = NUM_ ; iter < component Count ; iter ++ ) { Component c = ui . get Component At ( iter ) ; if ( c instanceof Container ) { bind Tree ( ( Container ) c , defer , object Lead ) ; continue ; } String bind = c . get Cloud Bound Property ( ) ; if ( bind != null && bind . length ( ) > NUM_ ) { String attribute Name = c . get Cloud Destination Property ( ) ; if ( attribute Name != null ) { bind Property ( c , bind , attribute Name , defer , object Lead ) ; } } } }
protected void do Validate Int Contents ( String path , String filename , int start , int end ) { File in File = new File ( path , filename ) ; Data Input Stream in Stream = null ; Log . i ( LOG TAG , STR_ + filename + STR_ + path ) ; try { in Stream = new Data Input Stream ( new File Input Stream ( in File ) ) ; for ( int i = start ; i < end ; ++ i ) { if ( in Stream . read Int ( ) != i ) { fail ( STR_ ) ; } } if ( in Stream != null ) { in Stream . close ( ) ; } Log . i ( LOG TAG , STR_ + filename ) ; } catch ( File Not Found Exception e ) { fail ( STR_ + in File + STR_ + e . to String ( ) ) ; } catch ( IO Exception e ) { fail ( STR_ + in File + STR_ + e . to String ( ) ) ; } }
public static void run Update Port Associations Process ( Collection < Storage Port > ports , Collection < Storage Port > rem Ports , Db Client db Client , Coordinator Client coordinator , List < Storage Pool > pools ) { try { if ( null == pools ) { pools = new Array List < Storage Pool > ( ) ; } if ( null == ports ) { ports = new Array List < Storage Port > ( ) ; } if ( null != rem Ports ) { ports . add All ( rem Ports ) ; } Map < Network Lite , List < Storage Port > > ports By Network = group Ports By Network ( ports , db Client ) ; if ( ! ports By Network . is Empty ( ) ) { update Port Associations ( ports , ports By Network , db Client ) ; Set < URI > pool Uris = get Storage Pool Ids ( pools ) ; List < Storage Pool > modified Pools = Storage Pool Association Helper . get Storage Pools From Ports ( db Client , ports , rem Ports ) ; for ( Storage Pool pool : modified Pools ) { if ( ! pool Uris . contains ( pool . get Id ( ) ) ) { pools . add ( pool ) ; } } } String Buffer error Message = new String Buffer ( ) ; Implicit Pool Matcher . match Modified Storage Pools With All Virtual Pool ( pools , db Client , coordinator , error Message ) ; Hash Set < URI > systems To Process = Storage Pool Association Helper . get Storage Sytems From Ports ( ports , rem Ports ) ; Connectivity Util . update Rp Systems Connectivity ( systems To Process , db Client ) ; } catch ( Exception e ) { log . error ( STR_ , e ) ; } }
private Attribute Values find Attribute Values ( String attr ) { Attribute Values list = attributes . get ( attr ) ; if ( list == null ) { list = new Attribute Values ( ) ; Attribute Values prev = attributes . put If Absent ( attr , list ) ; if ( prev != null ) return prev ; } return list ; }
public boolean parse Args ( String [ ] args , Main main ) { String explicit Version = null ; for ( int i = NUM_ ; i < args . length ; i ++ ) { String arg = args [ i ] ; if ( version Options . contains Key ( arg ) ) { if ( explicit Version != null && ! explicit Version . equals ( arg ) ) { main . error ( STR_ , explicit Version , arg ) ; return false ; } explicit Version = arg ; version = version Options . get ( arg ) ; args [ i ] = null ; } } return true ; }
public void schedule ( Timer Task task , Date when , long period ) { if ( period <= NUM_ || when . get Time ( ) < NUM_ ) { throw new Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) - System . current Time Millis ( ) ; schedule Impl ( task , delay < NUM_ ? NUM_ : delay , period , false ) ; }
public void minus ( Set x ) { if ( size ( ) > x . size ( ) ) { Enumeration elements = x . elements ( ) ; while ( elements . has More Elements ( ) ) remove ( elements . next Element ( ) ) ; } else { Enumeration elements = elements ( ) ; Object a ; while ( elements . has More Elements ( ) ) { a = elements . next Element ( ) ; if ( x . in ( a ) ) remove ( a ) ; } } }
private void add Fillet ( Coordinate p , double start Angle , double end Angle , int direction , double radius ) { int direction Factor = direction == CG Algorithms . CLOCKWISE ? - NUM_ : NUM_ ; double total Angle = Math . abs ( start Angle - end Angle ) ; int n Segs = ( int ) ( total Angle / fillet Angle Quantum + NUM_ ) ; if ( n Segs < NUM_ ) return ; double init Angle , curr Angle Inc ; init Angle = NUM_ ; curr Angle Inc = total Angle / n Segs ; double curr Angle = init Angle ; Coordinate pt = new Coordinate ( ) ; while ( curr Angle < total Angle ) { double angle = start Angle + direction Factor * curr Angle ; pt . x = p . x + radius * Math . cos ( angle ) ; pt . y = p . y + radius * Math . sin ( angle ) ; seg List . add Pt ( pt ) ; curr Angle += curr Angle Inc ; } }
@ HLE Unimplemented @ HLE Function ( nid = NUM_ , version = NUM_ , check Inside Interrupt = true ) public int sce Sas Set Triangular Wave ( int sas Core , int voice , int unknown ) { check Sas And Voice Handles Good ( sas Core , voice ) ; return NUM_ ; }
public synchronized String generate Tag ( ) { return Integer . to Hex String ( rand . next Int ( ) ) ; }
protected void index Polygons ( Input Stream is , long ptr , Output Stream os ) { boolean more Records = true ; byte r Hdr [ ] = new byte [ SHAPE RECORD HEADER LENGTH ] ; byte out Buf [ ] = new byte [ SPATIAL INDEX RECORD LENGTH ] ; int result ; int shape Type ; int n Records = NUM_ ; int rec Length Words , rec Length Bytes ; long rec Offset ; int rec Buf Size = NUM_ ; byte rec Buf [ ] = new byte [ rec Buf Size ] ; ESRI Bounding Box poly Bounds ; try { while ( more Records ) { result = is . read ( r Hdr , NUM_ , SHAPE RECORD HEADER LENGTH ) ; if ( result < NUM_ ) { more Records = false ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + n Records + STR_ ) ; logger . fine ( STR_ + rec Buf Size ) ; } } else { n Records ++ ; rec Offset = ptr ; read BE Int ( r Hdr , NUM_ ) ; rec Length Words = read BE Int ( r Hdr , NUM_ ) ; rec Length Bytes = rec Length Words * NUM_ ; if ( rec Length Bytes > rec Buf Size ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + rec Length Bytes ) ; } rec Buf Size = rec Length Bytes ; rec Buf = new byte [ rec Buf Size ] ; } result = is . read ( rec Buf , NUM_ , rec Length Bytes ) ; shape Type = read LE Int ( rec Buf , NUM_ ) ; if ( shape Type != SHAPE TYPE NULL ) { poly Bounds = read Box ( rec Buf , NUM_ ) ; } else { poly Bounds = new ESRI Bounding Box ( ) ; } ptr += rec Length Bytes + NUM_ ; write BE Int ( out Buf , NUM_ , ( int ) ( rec Offset / NUM_ ) ) ; write BE Int ( out Buf , NUM_ , rec Length Words ) ; write LE Double ( out Buf , NUM_ , poly Bounds . min . x ) ; write LE Double ( out Buf , NUM_ , poly Bounds . min . y ) ; write LE Double ( out Buf , NUM_ , poly Bounds . max . x ) ; write LE Double ( out Buf , NUM_ , poly Bounds . max . y ) ; os . write ( out Buf , NUM_ , SPATIAL INDEX RECORD LENGTH ) ; } } } catch ( java . io . IO Exception e ) { e . print Stack Trace ( ) ; } finally { try { is . close ( ) ; } catch ( java . io . IO Exception e ) { } } }
public void intersection ( Set x ) { Enumeration elements = elements ( ) ; Object a ; while ( elements . has More Elements ( ) ) { a = elements . next Element ( ) ; if ( ! x . in ( a ) ) remove ( a ) ; } }
public static < T extends Chunkable > int chunk Count From ( T chunkable , int chunk Length ) { byte [ ] data = chunkable . get Chunkable Data ( ) ; return ( int ) Math . ceil ( data . length * NUM_ / chunk Length ) ; }
void notify Client Handler Created ( Client Handler h ) { client Handler Vector . add Element ( h ) ; }
void process Update Queue For Testing ( ) { while ( ! updates . is Empty ( ) ) { I Update update = updates . poll ( ) ; if ( update != null ) update . dispatch ( ) ; } }
private void alter Syntax ( ) { m st . reset Syntax ( ) ; m st . word Chars ( STR_ , STR_ ) ; m st . slash Star Comments ( false ) ; m st . slash Slash Comments ( false ) ; m st . ordinary Char ( STR_ ) ; m st . ordinary Char ( STR_ ) ; }
private void delete Impl ( final int start Index , final int end Index , final int len ) { System . arraycopy ( buffer , end Index , buffer , start Index , size - end Index ) ; size -= len ; }
public static void ensure Output Directory ( final File directory ) { if ( ! directory . exists ( ) ) { if ( ! directory . mkdirs ( ) ) { throw new No Talkback Slim Exception ( Error Type . DIRECTORY NOT CREATED , directory . get Path ( ) ) ; } } else { if ( ! directory . is Directory ( ) ) { throw new No Talkback Slim Exception ( Error Type . NOT A DIRECTORY , directory . get Path ( ) ) ; } } }
public static Buffered Image convert To Buffered Image ( Image awt Img , int type ) { Buffered Image bimg ; if ( awt Img instanceof Buffered Image ) { bimg = ( Buffered Image ) awt Img ; } else { bimg = create Compatible Buffered Image ( awt Img . get Width ( null ) , awt Img . get Height ( null ) , type ) ; Graphics 2 D g = bimg . create Graphics ( ) ; g . draw Image ( awt Img , NUM_ , NUM_ , null , null ) ; g . dispose ( ) ; } return bimg ; }
private static String do Normalize ( String filename , char separator , boolean keep Separator ) { if ( filename == null ) { return null ; } int size = filename . length ( ) ; if ( size == NUM_ ) { return filename ; } int prefix = get Prefix Length ( filename ) ; if ( prefix < NUM_ ) { return null ; } char [ ] array = new char [ size + NUM_ ] ; filename . get Chars ( NUM_ , filename . length ( ) , array , NUM_ ) ; char other Separator = separator == SYSTEM SEPARATOR ? OTHER SEPARATOR : SYSTEM SEPARATOR ; for ( int i = NUM_ ; i < array . length ; i ++ ) { if ( array [ i ] == other Separator ) { array [ i ] = separator ; } } boolean last Is Directory = true ; if ( array [ size - NUM_ ] != separator ) { array [ size ++ ] = separator ; last Is Directory = false ; } for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == separator ) { System . arraycopy ( array , i , array , i - NUM_ , size - i ) ; size -- ; i -- ; } } for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == STR_ && ( i == prefix + NUM_ || array [ i - NUM_ ] == separator ) ) { if ( i == size - NUM_ ) { last Is Directory = true ; } System . arraycopy ( array , i + NUM_ , array , i - NUM_ , size - i ) ; size -= NUM_ ; i -- ; } } outer : for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == STR_ && array [ i - NUM_ ] == STR_ && ( i == prefix + NUM_ || array [ i - NUM_ ] == separator ) ) { if ( i == prefix + NUM_ ) { return null ; } if ( i == size - NUM_ ) { last Is Directory = true ; } int j ; for ( j = i - NUM_ ; j >= prefix ; j -- ) { if ( array [ j ] == separator ) { System . arraycopy ( array , i + NUM_ , array , j + NUM_ , size - i ) ; size -= i - j ; i = j + NUM_ ; continue outer ; } } System . arraycopy ( array , i + NUM_ , array , prefix , size - i ) ; size -= i + NUM_ - prefix ; i = prefix + NUM_ ; } } if ( size <= NUM_ ) { return STR_ ; } if ( size <= prefix ) { return new String ( array , NUM_ , size ) ; } if ( last Is Directory && keep Separator ) { return new String ( array , NUM_ , size ) ; } return new String ( array , NUM_ , size - NUM_ ) ; }
public org . smpte ra . schemas . st 2067 2 2013 . Content Version Type build Content Version Type ( String id , org . smpte ra . schemas . st 2067 2 2013 . User Text Type value ) { Content Version Type content Version Type = new Content Version Type ( ) ; content Version Type . set Id ( id ) ; content Version Type . set Label Text ( value ) ; return content Version Type ; }
public static int binary Search ( float [ ] array , int start Index , int end Index , float value ) { check Index For Binary Search ( array . length , start Index , end Index ) ; int int Bits = Float . float To Int Bits ( value ) ; int low = start Index , mid = - NUM_ , high = end Index - NUM_ ; while ( low <= high ) { mid = ( low + high ) > > > NUM_ ; if ( less Than ( array [ mid ] , value ) ) { low = mid + NUM_ ; } else if ( int Bits == Float . float To Int Bits ( array [ mid ] ) ) { return mid ; } else { high = mid - NUM_ ; } } if ( mid < NUM_ ) { int insert Point = end Index ; for ( int index = start Index ; index < end Index ; index ++ ) { if ( value < array [ index ] ) { insert Point = index ; } } return - insert Point - NUM_ ; } return - mid - ( less Than ( value , array [ mid ] ) ? NUM_ : NUM_ ) ; }
public static Run Stats delegate Get Bucket For Binary Base 64 ( int buckets ) throws Exception { Long start Time = System . current Time Millis ( ) ; Primary Index Bucket Generator Impl ibg = new Primary Index Bucket Generator Impl ( Field Data Type . BINARY , buckets ) ; Primary Index Bucket Locator Impl locator = new Primary Index Bucket Locator Impl ( null , null , null , null , null , null , ibg . generate Buckets ( ) , null , null ) ; logger . debug ( STR_ ) ; Hash Map < Long , List < Object > > hm = new Hash Map < > ( ) ; Summary Statistics stats = new Summary Statistics ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { String random String = Random String Utils . random Alphanumeric ( NUM_ ) ; byte [ ] bytes Encoded = Base 64 . encode Base 64 ( random String . get Bytes ( ) ) ; String line = new String ( bytes Encoded ) ; Long bucket Id = locator . get Bucket ( line , Field Data Type . BINARY ) ; Test Utils . calculate ( hm , stats , bucket Id , line ) ; } Long run Time = System . current Time Millis ( ) - start Time ; Run Stats run Stats = new Run Stats ( STR_ , Field Data Type . BINARY , run Time , stats , hm ) ; logger . debug ( run Stats . to String ( ) ) ; return run Stats ; }
private void heapify Up ( int twopos , Comparable < Object > cur ) { while ( twopos > NUM_ ) { final int parent = ( twopos - NUM_ ) > > > NUM_ ; Comparable < Object > par = twoheap [ parent ] ; if ( cur . compare To ( par ) >= NUM_ ) { break ; } twoheap [ twopos ] = par ; twopos = parent ; } twoheap [ twopos ] = cur ; }
public static boolean is Valid SQL Text ( C Text Field f ) { if ( f != null && f . get Text ( ) != null ) return is Valid SQL Text ( f . get Text ( ) ) ; return false ; }
private static int index Of ( Object o , Object [ ] elements , int index , int fence ) { if ( o == null ) { for ( int i = index ; i < fence ; i ++ ) if ( elements [ i ] == null ) return i ; } else { for ( int i = index ; i < fence ; i ++ ) if ( o . equals ( elements [ i ] ) ) return i ; } return - NUM_ ; }
public static String generate CQL Statement For Insert ( Index index ) { String i Table To Update = Utils . calculate I Table Name ( index ) ; List < String > fields = index . get Fields Values ( ) ; String field Names Insert Syntax = Utils . join ( STR_ , fields ) ; String Builder field Value Insert Syntax = new String Builder ( ) ; for ( int i = NUM_ ; i < fields . size ( ) ; i ++ ) { if ( i != NUM_ ) { field Value Insert Syntax . append ( STR_ ) ; } field Value Insert Syntax . append ( STR_ ) ; } return String . format ( ITABLE INSERT CQL , i Table To Update , field Names Insert Syntax , field Value Insert Syntax ) ; }
public static void draw Horizontal Margin Indicator ( Graphics 2 D g , String text , int x 1 , int x 2 , int y ) { if ( x 1 > x 2 ) { int temp = x 1 ; x 1 = x 2 ; x 2 = temp ; } if ( text == null ) { g . draw Line ( x 1 , y , x 2 , y ) ; g . draw Line ( x 1 , y , x 1 + CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x 1 , y , x 1 + CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; g . draw Line ( x 2 , y , x 2 - CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x 2 , y , x 2 - CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; return ; } Canvas c = new Canvas ( ) ; Font Metrics fm = c . get Font Metrics ( s Font ) ; g . set Font ( s Font ) ; int padding = NUM_ ; Rectangle 2 D bounds = fm . get String Bounds ( text , g ) ; int th = ( int ) bounds . get Height ( ) ; int tw = ( int ) bounds . get Width ( ) ; int offset = NUM_ * CONNECTION ARROW SIZE ; int w = ( ( x 2 - x 1 ) - ( tw + NUM_ * padding ) ) / NUM_ ; if ( w <= padding ) { g . draw Line ( x 1 , y , x 2 , y ) ; g . draw String ( text , x 1 + w + padding , y + offset ) ; g . draw Line ( x 1 , y - CONNECTION ARROW SIZE , x 1 , y + CONNECTION ARROW SIZE ) ; g . draw Line ( x 2 , y - CONNECTION ARROW SIZE , x 2 , y + CONNECTION ARROW SIZE ) ; } else { g . draw Line ( x 1 , y , x 1 + w , y ) ; g . draw Line ( x 2 - w , y , x 2 , y ) ; g . draw String ( text , x 1 + w + padding , ( int ) ( y + ( bounds . get Height ( ) / NUM_ ) ) ) ; g . draw Line ( x 1 , y , x 1 + CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x 1 , y , x 1 + CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; g . draw Line ( x 2 , y , x 2 - CONNECTION ARROW SIZE , y - CONNECTION ARROW SIZE ) ; g . draw Line ( x 2 , y , x 2 - CONNECTION ARROW SIZE , y + CONNECTION ARROW SIZE ) ; } }
public Status List ( RP Entity entity ) { this . entity Ref = new Weak Reference < RP Entity > ( entity ) ; immunities = Enum Set . none Of ( Status Type . class ) ; statuses = new Linked List < Status > ( ) ; }
protected void draw Image ( int x , int y , int w , int h , String image ) { Image img = load Image ( image ) ; if ( img != null ) { g . draw Image ( img , x , y , w , h , null ) ; } }
public void add Task ( Join Task task ) { synchronized ( Join Manager . this ) { if ( b Terminated ) return ; } synchronized ( task List ) { if ( b Terminated ) { return ; } task List . add ( task ) ; if ( this . proxy Reg Task == null ) { this . proxy Reg Task = new Proxy Reg Task ( this , task Seq N ++ ) ; synchronized ( task Mgr ) { task Mgr . add ( this . proxy Reg Task ) ; } } } }
private Schema Factory load From Services File ( String schema Language , String resource Name , Input Stream in ) { if ( debug ) debug Println ( STR_ + resource Name ) ; Buffered Reader rd ; try { rd = new Buffered Reader ( new Input Stream Reader ( in , STR_ ) , DEFAULT LINE LENGTH ) ; } catch ( java . io . Unsupported Encoding Exception e ) { rd = new Buffered Reader ( new Input Stream Reader ( in ) , DEFAULT LINE LENGTH ) ; } String factory Class Name = null ; Schema Factory result Factory = null ; while ( true ) { try { factory Class Name = rd . read Line ( ) ; } catch ( IO Exception x ) { break ; } if ( factory Class Name != null ) { int hash Index = factory Class Name . index Of ( STR_ ) ; if ( hash Index != - NUM_ ) { factory Class Name = factory Class Name . substring ( NUM_ , hash Index ) ; } factory Class Name = factory Class Name . trim ( ) ; if ( factory Class Name . length ( ) == NUM_ ) { continue ; } try { Schema Factory found Factory = ( Schema Factory ) create Instance ( factory Class Name ) ; if ( found Factory . is Schema Language Supported ( schema Language ) ) { result Factory = found Factory ; break ; } } catch ( Exception ignored ) { } } else { break ; } } Io Utils . close Quietly ( rd ) ; return result Factory ; }
public String parse To Regex ( ) { if ( regex == null ) { regex = new String Builder ( STR_ ) ; parse Glob ( ) ; regex . append ( STR_ ) ; } return regex . to String ( ) ; }
private String build Remote Name ( String account Name , String remote Path ) { return account Name + remote Path ; }
private static byte [ ] create File Req ( byte [ ] command , String path ) { byte [ ] path Content ; try { path Content = path . get Bytes ( Adb Helper . DEFAULT ENCODING ) ; } catch ( Unsupported Encoding Exception e ) { return null ; } return create File Req ( command , path Content ) ; }
public Windows Directory ( Path path , Lock Factory lock Factory ) throws IO Exception { super ( path , lock Factory ) ; }
public void check Has Child Account ( final Has Child Account Callback callback ) { if ( m Has Child Account != null || maybe Update Predetermined Child Account Status ( ) ) { post Callback ( callback ) ; return ; } m Callbacks . add ( callback ) ; if ( m Account Manager Future == null ) request Child Account Status ( ) ; }
protected void sprint ( short short Field ) { sprint ( String . value Of ( short Field ) ) ; }
@ Override public void on Update Scrollbar ( int dy ) { List < Alphabetical Apps List . Adapter Item > items = m Apps . get Adapter Items ( ) ; if ( items . is Empty ( ) || m Num Apps Per Row == NUM_ ) { m Scrollbar . set Thumb Offset ( - NUM_ , - NUM_ ) ; return ; } int row Count = m Apps . get Num App Rows ( ) ; get Cur Scroll State ( m Scroll Pos State ) ; if ( m Scroll Pos State . row Index < NUM_ ) { m Scrollbar . set Thumb Offset ( - NUM_ , - NUM_ ) ; return ; } int available Scroll Bar Height = get Available Scroll Bar Height ( ) ; int available Scroll Height = get Available Scroll Height ( m Apps . get Num App Rows ( ) , m Scroll Pos State . row Height ) ; if ( available Scroll Height <= NUM_ ) { m Scrollbar . set Thumb Offset ( - NUM_ , - NUM_ ) ; return ; } int scroll Y = get Padding Top ( ) + ( m Scroll Pos State . row Index * m Scroll Pos State . row Height ) - m Scroll Pos State . row Top Offset ; int scroll Bar Y = m Background Padding . top + ( int ) ( ( ( float ) scroll Y / available Scroll Height ) * available Scroll Bar Height ) ; if ( m Scrollbar . is Thumb Detached ( ) ) { int scroll Bar X ; if ( Utilities . is Rtl ( get Resources ( ) ) ) { scroll Bar X = m Background Padding . left ; } else { scroll Bar X = get Width ( ) - m Background Padding . right - m Scrollbar . get Thumb Width ( ) ; } if ( m Scrollbar . is Dragging Thumb ( ) ) { m Scrollbar . set Thumb Offset ( scroll Bar X , ( int ) m Scrollbar . get Last Touch Y ( ) ) ; } else { int thumb Scroll Y = m Scrollbar . get Thumb Offset ( ) . y ; int diff Scroll Y = scroll Bar Y - thumb Scroll Y ; if ( diff Scroll Y * dy > NUM_ ) { if ( dy < NUM_ ) { int offset = ( int ) ( ( dy * thumb Scroll Y ) / ( float ) scroll Bar Y ) ; thumb Scroll Y += Math . max ( offset , diff Scroll Y ) ; } else { int offset = ( int ) ( ( dy * ( available Scroll Bar Height - thumb Scroll Y ) ) / ( float ) ( available Scroll Bar Height - scroll Bar Y ) ) ; thumb Scroll Y += Math . min ( offset , diff Scroll Y ) ; } thumb Scroll Y = Math . max ( NUM_ , Math . min ( available Scroll Bar Height , thumb Scroll Y ) ) ; m Scrollbar . set Thumb Offset ( scroll Bar X , thumb Scroll Y ) ; if ( scroll Bar Y == thumb Scroll Y ) { m Scrollbar . reattach Thumb To Scroll ( ) ; } } else { m Scrollbar . set Thumb Offset ( scroll Bar X , thumb Scroll Y ) ; } } } else { synchronize Scroll Bar Thumb Offset To View Scroll ( m Scroll Pos State , row Count ) ; } }
@ Override public Label conditional Jump ( int index , Condition condition ) { Label label ; if ( conditional Label Pointer <= conditional Labels . size ( ) ) { label = new Label ( ) ; conditional Labels . add ( label ) ; conditional Label Pointer = conditional Labels . size ( ) ; } else { label = conditional Labels . get ( conditional Label Pointer ++ ) ; } conditional Jump ( index , condition , label ) ; return label ; }
public Only One Is Allowed To Be Set Global Constraint ( Parameter < ? > ... params ) { parameters = Arrays . as List ( params ) ; }
public void add Comment ( int pos , String comment ) { List < String > list = comments . get ( pos ) ; if ( list == null ) { list = new Array List < > ( ) ; comments . put ( pos , list ) ; } list . add ( encode String ( comment ) ) ; }
Solr Input Document doc ( Solr Input Field ... fields ) { Solr Input Document d = new Solr Input Document ( ) ; for ( Solr Input Field f : fields ) { d . put ( f . get Name ( ) , f ) ; } return d ; }
public Expression Parser Builder with Scope ( Resolver resolver ) { scope Resolvers . add ( resolver ) ; return this ; }
private static Class < ? > [ ] types ( Object ... values ) { if ( values == null ) { return new Class [ NUM_ ] ; } Class < ? > [ ] result = new Class [ values . length ] ; for ( int i = NUM_ ; i < values . length ; i ++ ) { Object value = values [ i ] ; result [ i ] = value == null ? NULL . class : value . get Class ( ) ; } return result ; }
public void initialize ( Map < String , Set < String > > config Params ) throws Id Repo Exception { config Map = Collections . unmodifiable Map ( config Params ) ; }
protected void tag ( String tag , String [ ] names , String [ ] values , int nattr , boolean close ) { spacing ( ) ; m out . print ( STR_ ) ; m out . print ( tag ) ; for ( int i = NUM_ ; i < nattr ; ++ i ) { m out . print ( STR_ ) ; m out . print ( names [ i ] ) ; m out . print ( STR_ ) ; m out . print ( STR_ ) ; escape String ( values [ i ] ) ; m out . print ( STR_ ) ; } if ( close ) m out . print ( STR_ ) ; m out . print ( STR_ ) ; println ( ) ; if ( ! close ) { m tag Stack . add ( tag ) ; } }
private static C Inlining Result inline Function Silently ( final J Frame parent , final I View Container view Container , final Zy Graph graph , final I Navi Code Node node , final I Navi Instruction instruction , final I Navi Function function ) { final I Navi Function inline Function = prepare Function Inlining ( parent , node , instruction , function , view Container ) ; if ( inline Function == null ) { return null ; } else if ( inline Function . get Basic Block Count ( ) == NUM_ ) { return null ; } else { try { if ( ! inline Function . is Loaded ( ) ) { inline Function . load ( ) ; } return C Inlining Helper . inline Code Node ( graph . get Raw View ( ) , node , instruction , inline Function ) ; } catch ( final Couldnt Load Data Exception e ) { exception Dialog ( parent , inline Function , e ) ; } } return null ; }
private Priority Queue < Score Term > retrieve Terms ( int doc Num ) throws IO Exception { Map < String , Map < String , Int > > field 2 term Freq Map = new Hash Map < > ( ) ; for ( String field Name : field Names ) { final Fields vectors = ir . get Term Vectors ( doc Num ) ; final Terms vector ; if ( vectors != null ) { vector = vectors . terms ( field Name ) ; } else { vector = null ; } if ( vector == null ) { Document d = ir . document ( doc Num ) ; Indexable Field [ ] fields = d . get Fields ( field Name ) ; for ( Indexable Field field : fields ) { final String string Value = field . string Value ( ) ; if ( string Value != null ) { add Term Frequencies ( new String Reader ( string Value ) , field 2 term Freq Map , field Name ) ; } } } else { add Term Frequencies ( field 2 term Freq Map , vector , field Name ) ; } } return create Queue ( field 2 term Freq Map ) ; }
private static String capitalize ( String s ) { if ( s == null || s . length ( ) == NUM_ ) { return STR_ ; } char first = s . char At ( NUM_ ) ; if ( Character . is Upper Case ( first ) ) { return s ; } else { return Character . to Upper Case ( first ) + s . substring ( NUM_ ) ; } }
public S 2 Cell Id cell Id ( int i ) { return cell Ids . get ( i ) ; }
private String lock Path ( String id ) { return String . format ( STR_ , work Item Lock Path , id ) ; }
public void add Time Bounds Listener ( Time Bounds Listener tbl ) { if ( ! time Bounds Listeners . contains ( tbl ) ) { time Bounds Listeners . add ( tbl ) ; } }
private Random Data create Random ( ) { final JDK Random Generator random Gen = new JDK Random Generator ( ) ; random Gen . set Seed ( NUM_ ) ; return new Random Data Impl ( random Gen ) ; }
public Options Cache ( ) { cache List = new Array List < > ( ) ; cache List . add ( new Static Cache ( Gen Inputs Abstract . class ) ) ; cache List . add ( new Static Cache ( Reflection Executor . class ) ) ; cache List . add ( new Static Cache ( Abstract Generator . class ) ) ; }
@ Override public Instances define Data Format ( ) throws Exception { set Options ( get Options ( ) ) ; check Coverage ( ) ; Random random = new Random ( get Seed ( ) ) ; set Random ( random ) ; Instances dataset ; Array List < Attribute > attributes = new Array List < Attribute > ( NUM_ ) ; Attribute attribute ; boolean class Flag = get Class Flag ( ) ; Array List < String > class Values = null ; if ( class Flag ) { class Values = new Array List < String > ( get Clusters ( ) . length ) ; } Array List < String > bool Values = new Array List < String > ( NUM_ ) ; bool Values . add ( STR_ ) ; bool Values . add ( STR_ ) ; Array List < String > nom Values = null ; for ( int i = NUM_ ; i < get Num Attributes ( ) ; i ++ ) { if ( m boolean Cols . is In Range ( i ) ) { attribute = new Attribute ( STR_ + i , bool Values ) ; } else if ( m nominal Cols . is In Range ( i ) ) { nom Values = new Array List < String > ( m num Values [ i ] ) ; for ( int j = NUM_ ; j < m num Values [ i ] ; j ++ ) { nom Values . add ( STR_ + j ) ; } attribute = new Attribute ( STR_ + i , nom Values ) ; } else { attribute = new Attribute ( STR_ + i ) ; } attributes . add ( attribute ) ; } if ( class Flag ) { for ( int i = NUM_ ; i < get Clusters ( ) . length ; i ++ ) { class Values . add ( STR_ + i ) ; } attribute = new Attribute ( STR_ , class Values ) ; attributes . add ( attribute ) ; } dataset = new Instances ( get Relation Name To Use ( ) , attributes , NUM_ ) ; if ( class Flag ) { dataset . set Class Index ( m Num Attributes ) ; } Instances format = new Instances ( dataset , NUM_ ) ; set Dataset Format ( format ) ; for ( int i = NUM_ ; i < get Clusters ( ) . length ; i ++ ) { Subspace Cluster Definition cl = ( Subspace Cluster Definition ) get Clusters ( ) [ i ] ; cl . set Num Instances ( random ) ; cl . set Parent ( this ) ; } return dataset ; }
final void detach From Thread Pool ( ) { if ( shutdown . get And Set ( true ) ) throw new Assertion Error ( STR_ ) ; if ( ! is Empty ( ) ) throw new Assertion Error ( STR_ ) ; shutdown Handler Tasks ( ) ; }
@ Nullable public static Class < ? > box ( @ Nullable Class < ? > cls ) { if ( cls == null ) return null ; if ( ! cls . is Primitive ( ) ) return cls ; return boxed Cls Map . get ( cls ) ; }
protected void draw Month Nums ( Canvas canvas ) { int y = ( ( ( m Row Height + MINI DAY NUMBER TEXT SIZE ) / NUM_ ) - DAY SEPARATOR WIDTH ) + get Month Header Size ( ) ; final float day Width Half = ( m Width - m Edge Padding * NUM_ ) / ( m Num Days * NUM_ ) ; int j = find Day Offset ( ) ; for ( int day Number = NUM_ ; day Number <= m Num Cells ; day Number ++ ) { final int x = ( int ) ( ( NUM_ * j + NUM_ ) * day Width Half + m Edge Padding ) ; int y Relative To Day = ( m Row Height + MINI DAY NUMBER TEXT SIZE ) / NUM_ - DAY SEPARATOR WIDTH ; final int start X = ( int ) ( x - day Width Half ) ; final int stop X = ( int ) ( x + day Width Half ) ; final int start Y = ( int ) ( y - y Relative To Day ) ; final int stop Y = ( int ) ( start Y + m Row Height ) ; draw Month Day ( canvas , m Year , m Month , day Number , x , y , start X , stop X , start Y , stop Y ) ; j ++ ; if ( j == m Num Days ) { j = NUM_ ; y += m Row Height ; } } }
protected void check Row Pos ( ) throws SQL Exception { check Closed ( ) ; if ( ! this . on Valid Row ) { throw SQL Error . create SQL Exception ( this . invalid Row Reason , SQL Error . SQL STATE GENERAL ERROR , get Exception Interceptor ( ) ) ; } }
static void check Args ( byte [ ] in , int in Offset , byte [ ] out , int out Offset ) { if ( probability ( VERY SLOW PATH PROBABILITY , in Offset < NUM_ || in . length - AES BLOCK SIZE < in Offset || out Offset < NUM_ || out . length - AES BLOCK SIZE < out Offset ) ) { Deoptimize Node . deopt ( Deoptimization Action . None , Deoptimization Reason . Runtime Constraint ) ; } }
public void clear Query ( Query query ) { lock . lock ( ) ; try { final Query singleton = unique Queries . remove ( query ) ; if ( singleton != null ) { on Eviction ( singleton ) ; } } finally { lock . unlock ( ) ; } }
private void calc Angular Bounds ( Node Item r ) { if ( m prev Root == null || ! m prev Root . is Valid ( ) || r == m prev Root ) { m prev Root = r ; return ; } Node Item p = m prev Root ; while ( true ) { Node Item pp = ( Node Item ) p . get Parent ( ) ; if ( pp == r ) { break ; } else if ( pp == null ) { m prev Root = r ; return ; } p = pp ; } double dt = NUM_ ; Iterator iter = sorted Children ( r ) ; while ( iter . has Next ( ) ) { Node n = ( Node ) iter . next ( ) ; if ( n == p ) break ; dt += ( ( Params ) n . get ( PARAMS ) ) . width ; } double rw = ( ( Params ) r . get ( PARAMS ) ) . width ; double pw = ( ( Params ) p . get ( PARAMS ) ) . width ; dt = - Math Lib . TWO PI * ( dt + pw / NUM_ ) / rw ; m theta 1 = dt + Math . atan 2 ( p . get Y ( ) - r . get Y ( ) , p . get X ( ) - r . get X ( ) ) ; m theta 2 = m theta 1 + Math Lib . TWO PI ; m prev Root = r ; }
private static String encode Path ( String path ) { String Builder buffer = new String Builder ( ) ; for ( int i = NUM_ ; i < path . length ( ) ; i ++ ) { char c = path . char At ( i ) ; if ( c == STR_ ) { buffer . append ( STR_ ) ; } else { buffer . append ( c ) ; } } return buffer . to String ( ) ; }
Eval Thread ( Context Info context Info ) { super ( null ) ; this . context Info = context Info ; set Daemon ( true ) ; }
protected void select Vertical Auto Tick Unit ( Graphics 2 D g 2 , Rectangle 2 D data Area , Rectangle Edge edge ) { Range range = get Range ( ) ; double log Axis Min = calculate Log ( Math . max ( this . smallest Value , range . get Lower Bound ( ) ) ) ; double log Axis Max = calculate Log ( range . get Upper Bound ( ) ) ; double size = ( log Axis Max - log Axis Min ) / NUM_ ; Tick Unit Source tick Units = get Standard Tick Units ( ) ; Tick Unit candidate = tick Units . get Ceiling Tick Unit ( size ) ; Tick Unit prev Candidate = candidate ; boolean found = false ; while ( ! found ) { this . tick Unit = ( Number Tick Unit ) candidate ; double tick Label Height = estimate Maximum Tick Label Height ( g 2 ) ; double candidate Height = exponent Length To Java 2 D ( candidate . get Size ( ) , data Area , edge ) ; if ( tick Label Height < candidate Height ) { found = true ; } else if ( Double . is Na N ( candidate Height ) ) { candidate = prev Candidate ; found = true ; } else { prev Candidate = candidate ; candidate = tick Units . get Larger Tick Unit ( prev Candidate ) ; if ( candidate . equals ( prev Candidate ) ) { found = true ; } } } set Tick Unit ( ( Number Tick Unit ) candidate , false , false ) ; }
public void limit ( double x 1 , double y 1 , double x 2 , double y 2 ) { clip [ NUM_ ] = Math . max ( clip [ NUM_ ] , x 1 ) ; clip [ NUM_ ] = Math . max ( clip [ NUM_ ] , y 1 ) ; clip [ NUM_ ] = Math . min ( clip [ NUM_ ] , x 2 ) ; clip [ NUM_ ] = Math . min ( clip [ NUM_ ] , y 2 ) ; }
private int timeout Wait ( int current Total Wait Time , long poll , long max Timeout Millis , String timed Out Message ) throws Timeout Exception { long now = System Clock . elapsed Realtime ( ) ; long end = now + poll ; while ( now < end ) { try { Thread . sleep ( end - now ) ; } catch ( Interrupted Exception e ) { } now = System Clock . elapsed Realtime ( ) ; } current Total Wait Time += poll ; if ( current Total Wait Time > max Timeout Millis ) { throw new Timeout Exception ( timed Out Message ) ; } return current Total Wait Time ; }
private void write Java Parameter Spec ( Java Parameter Spec spec , Document document , Element parent Element ) { Element parameter = document . create Element ( STR_ ) ; parent Element . append Child ( parameter ) ; parameter . set Attribute ( STR_ , spec . get Package Name ( ) ) ; parameter . set Attribute ( STR_ , spec . get Class Name ( ) ) ; parameter . set Attribute ( STR_ , spec . get Half Signature ( ) ) ; parameter . set Attribute ( STR_ , Integer . to String ( spec . get Param Idx ( ) ) ) ; }
protected final Permit Status permit Status ( ) { if ( permits . get ( ) > NUM_ ) return Permit Status . MAYBE MORE ; else return unlimited ? Permit Status . UNLIMITED : Permit Status . NO MORE ; }
private boolean on Notification Clicked ( long persistent Notification Id , String origin , String tag , int action Index ) { m Last Notification Click Ms = System . current Time Millis ( ) ; return native On Notification Clicked ( m Native Notification Manager , persistent Notification Id , origin , tag , action Index ) ; }
private List < Recommendation > create Metro Point Recommendations ( Virtual Array src Varray , List < Virtual Array > tgt Varrays , Virtual Pool src Vpool , Virtual Array ha Varray , Virtual Pool ha Vpool , Project project , Virtual Pool Capability Values Wrapper capabilities , List < Storage Pool > candidate Primary Pools , List < Storage Pool > candidate Secondary Pools , Volume vpool Change Volume ) { List < Recommendation > recommendations = new Array List < Recommendation > ( ) ; RP Protection Recommendation rp Protection Recommendaton = null ; Map < Virtual Array , List < Storage Pool > > tgt Varray Storage Pools Map = get Vplex Target Matching Pools ( tgt Varrays , src Vpool , project , capabilities , vpool Change Volume ) ; rp Protection Recommendaton = create RP Protection Recommendation For Metro Point ( src Varray , tgt Varrays , src Vpool , ha Varray , ha Vpool , capabilities , candidate Primary Pools , candidate Secondary Pools , tgt Varray Storage Pools Map , vpool Change Volume , project ) ; log . info ( String . format ( STR_ , rp Protection Recommendaton . get Resource Count ( ) ) ) ; recommendations . add ( rp Protection Recommendaton ) ; return recommendations ; }
public void handle Keep Alive Signal ( long platform Ident ) { Agent Status Data agent Status Data = agent Status Data Map . get ( platform Ident ) ; if ( null != agent Status Data ) { agent Status Data . set Last Keep Alive Timestamp ( System . current Time Millis ( ) ) ; if ( agent Status Data . get Agent Connection ( ) == Agent Connection . NO KEEP ALIVE ) { agent Status Data . set Agent Connection ( Agent Connection . CONNECTED ) ; if ( log . is Info Enabled ( ) ) { log . info ( STR_ + platform Ident + STR_ ) ; } } } }
public static String remove Hashbang ( String url ) { return url . replace First ( STR_ , STR_ ) ; }
public void register Text Flavor Properties ( String nat , String charset , String eoln , String terminators ) { Long format = get Format For Native As Long ( nat ) ; text Natives . add ( format ) ; native Charsets . put ( format , ( charset != null && charset . length ( ) != NUM_ ) ? charset : get Default Text Charset ( ) ) ; if ( eoln != null && eoln . length ( ) != NUM_ && ! eoln . equals ( STR_ ) ) { native EOL Ns . put ( format , eoln ) ; } if ( terminators != null && terminators . length ( ) != NUM_ ) { Integer i Terminators = Integer . value Of ( terminators ) ; if ( i Terminators . int Value ( ) > NUM_ ) { native Terminators . put ( format , i Terminators ) ; } } }
public static void object String ( Object obj , String Builder sb ) { if ( obj instanceof Object [ ] ) { sb . append ( STR_ ) ; boolean first = true ; for ( Object o : ( Object [ ] ) obj ) { if ( ! first ) { sb . append ( STR_ ) ; } else { first = false ; } object String ( o , sb ) ; } sb . append ( STR_ ) ; } else { object String With Bytes ( obj , sb ) ; } }
final int full Try Acquire Shared ( Thread current ) { Hold Counter rh = null ; for ( ; ; ) { int c = get State ( ) ; if ( exclusive Count ( c ) != NUM_ ) { if ( get Exclusive Owner Thread ( ) != current ) return - NUM_ ; } else if ( reader Should Block ( ) ) { if ( first Reader == current ) { } else { if ( rh == null ) { rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) { rh = read Holds . get ( ) ; if ( rh . count == NUM_ ) read Holds . remove ( ) ; } } if ( rh . count == NUM_ ) return - NUM_ ; } } if ( shared Count ( c ) == MAX COUNT ) throw new Error ( STR_ ) ; if ( compare And Set State ( c , c + SHARED UNIT ) ) { if ( shared Count ( c ) == NUM_ ) { first Reader = current ; first Reader Hold Count = NUM_ ; } else if ( first Reader == current ) { first Reader Hold Count ++ ; } else { if ( rh == null ) rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) rh = read Holds . get ( ) ; else if ( rh . count == NUM_ ) read Holds . set ( rh ) ; rh . count ++ ; cached Hold Counter = rh ; } return NUM_ ; } } }
private int [ ] to Int Array ( String str ) { int [ ] ret Val = new int [ NUM_ ] ; str = str + STR_ ; int rlen = ret Val . length ; for ( int i = NUM_ ; i < rlen ; i ++ ) { ret Val [ i ] = Integer . parse Int ( str . substring ( NUM_ , str . index Of ( STR_ ) ) ) ; str = str . substring ( str . index Of ( STR_ ) + NUM_ , str . length ( ) ) ; } return ret Val ; }
private Connection table Setup ( String insert Entry Query ) throws Throwable { Connection connection = null ; Statement statement = null ; try { connection = get New Connection ( true ) ; statement = connection . create Statement ( ) ; statement . execute Query ( STR_ ) ; statement . execute Query ( STR_ + STR_ ) ; Result Set result Set = statement . execute Query ( STR_ + STR_ + STR_ + STR_ + STR_ ) ; while ( result Set . next ( ) ) { String values = STR_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { values += ( i == NUM_ ) ? STR_ : STR_ + result Set . get String ( i ) + STR_ ; } statement . execute Query ( STR_ + STR_ + values + STR_ ) ; } if ( insert Entry Query != null ) { statement . execute Query ( insert Entry Query ) ; } try { set Db Name ( connection , STR_ ) ; } catch ( Throwable t ) { fail ( STR_ ) ; } int server Id = get Server Id ( connection ) ; stop Proxy ( server Id , NUM_ ) ; statement = connection . create Statement ( ) ; statement . execute Query ( STR_ ) ; } catch ( SQL Exception se ) { fail ( STR_ + se ) ; } finally { if ( statement != null ) { statement . close ( ) ; } } return connection ; }
protected void add Context ( final Server Context server Context ) { team Project Table Model . add Server Contexts ( Collections . singleton List ( server Context ) ) ; }
public void do Get Embed Html ( Http Servlet Request request , Http Servlet Response response , String type , String location , String item ) throws Servlet Exception , IO Exception { response . set Status ( Http Servlet Response . SC OK ) ; response . set Content Type ( STR_ ) ; Print Writer writer = response . get Writer ( ) ; String path = STR_ + type + STR_ + location + STR_ + item ; writer . print ( STR_ ) ; writer . println ( STR_ ) ; writer . println ( STR_ ) ; writer . printf ( STR_ , path ) ; writer . printf ( STR_ , path ) ; writer . println ( STR_ ) ; }
@ Override public void visit Map Node ( Map Node node ) { node Buffer . add ( node ) ; }
@ Skip Validation private void prepare Display Info ( ) { if ( LOGGER . is Debug Enabled ( ) ) LOGGER . debug ( STR_ ) ; dcb Disp Info = new DCB Display Info ( ) ; dcb Disp Info . set Reason Category Codes ( Collections . < String > empty List ( ) ) ; List < String > reason List = new Array List < String > ( ) ; reason List . add All ( DEMAND REASON ORDER MAP . key Set ( ) ) ; dcb Disp Info . set Reason Master Codes ( reason List ) ; if ( LOGGER . is Debug Enabled ( ) ) { LOGGER . debug ( STR_ + dcb Disp Info ) ; LOGGER . debug ( STR_ + ( reason List != null ? reason List . size ( ) : ZERO ) ) ; LOGGER . debug ( STR_ ) ; } }
protected void print Attribute Summary ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type ) { String str = STR_ ; if ( numeric Predictor ) { str += STR_ ; } if ( nominal Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( string Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( date Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( relational Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } str += STR_ ; switch ( class Type ) { case Attribute . NUMERIC : str = STR_ + str ; break ; case Attribute . NOMINAL : str = STR_ + str ; break ; case Attribute . STRING : str = STR_ + str ; break ; case Attribute . DATE : str = STR_ + str ; break ; case Attribute . RELATIONAL : str = STR_ + str ; break ; } print ( str ) ; }
public void register Interest Completed ( ) { if ( Gem Fire Cache Impl . this . is Closing ) { return ; } int cv = register Interests In Progress . decrement And Get ( ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ , cv ) ; } if ( cv == NUM_ ) { synchronized ( ri Waiters ) { cv = register Interests In Progress . get ( ) ; if ( cv == NUM_ ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ ) ; } Iterator it = ri Waiters . iterator ( ) ; while ( it . has Next ( ) ) { Simple Waiter sw = ( Simple Waiter ) it . next ( ) ; sw . do Notify ( ) ; } ri Waiters . clear ( ) ; } } } }
@ Override public boolean equals ( Object o ) { if ( ! ( o instanceof Connection ) ) { return false ; } Connection c = ( Connection ) o ; return client Handle . equals ( c . client Handle ) ; }
public String dump Node ( int node Handle ) { if ( node Handle == DTM . NULL ) return STR_ ; String typestring ; switch ( get Node Type ( node Handle ) ) { case DTM . ATTRIBUTE NODE : typestring = STR_ ; break ; case DTM . CDATA SECTION NODE : typestring = STR_ ; break ; case DTM . COMMENT NODE : typestring = STR_ ; break ; case DTM . DOCUMENT FRAGMENT NODE : typestring = STR_ ; break ; case DTM . DOCUMENT NODE : typestring = STR_ ; break ; case DTM . DOCUMENT TYPE NODE : typestring = STR_ ; break ; case DTM . ELEMENT NODE : typestring = STR_ ; break ; case DTM . ENTITY NODE : typestring = STR_ ; break ; case DTM . ENTITY REFERENCE NODE : typestring = STR_ ; break ; case DTM . NAMESPACE NODE : typestring = STR_ ; break ; case DTM . NOTATION NODE : typestring = STR_ ; break ; case DTM . NULL : typestring = STR_ ; break ; case DTM . PROCESSING INSTRUCTION NODE : typestring = STR_ ; break ; case DTM . TEXT NODE : typestring = STR_ ; break ; default : typestring = STR_ ; break ; } String Buffer sb = new String Buffer ( ) ; sb . append ( STR_ + node Handle + STR_ + typestring + STR_ + Integer . to Hex String ( get Expanded Type ID ( node Handle ) ) + STR_ + get Node Name X ( node Handle ) + STR_ + get Namespace URI ( node Handle ) + STR_ + STR_ + get Node Value ( node Handle ) + STR_ ) ; return sb . to String ( ) ; }
public boolean exists ( ) { return null != get TX State ( ) ; }
public void save Bytecode ( String class Name , String class File Name ) { byte [ ] bytecode = get Bytecode ( class Name ) ; if ( bytecode != null ) { try { File Output Stream fos = new File Output Stream ( class File Name ) ; fos . write ( bytecode ) ; fos . close ( ) ; } catch ( IO Exception ex ) { context . log ( STR_ + class Name + STR_ + class File Name , ex ) ; } } }
protected boolean [ ] can Predict ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type ) { print ( STR_ ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STR_ ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; int num Train = get Num Instances ( ) , num Classes = NUM_ , missing Level = NUM_ ; boolean predictor Missing = false , class Missing = false ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Classes , accepts ) ; }
private static < T extends Glow Structure Piece > T create Structure Piece ( Structure Piece Store < T > store , Compound Tag compound ) { T structure Piece = store . create Structure Piece ( ) ; store . load ( structure Piece , compound ) ; return structure Piece ; }
public String char Set Tip Text ( ) { return STR_ + STR_ ; }
@ Override public boolean on Restart ( Scheduler . Restart Topology Request request ) { int container Id = request . get Container Index ( ) ; List < Process > processes To Restart = new Linked List < > ( ) ; if ( container Id == - NUM_ ) { LOG . info ( STR_ + Local Context . topology Name ( config ) ) ; processes To Restart . add All ( process To Container . key Set ( ) ) ; } else { LOG . info ( STR_ + Local Context . topology Name ( config ) ) ; LOG . info ( STR_ + container Id ) ; for ( Process p : process To Container . key Set ( ) ) { if ( container Id == process To Container . get ( p ) ) { processes To Restart . add ( p ) ; } } } if ( processes To Restart . is Empty ( ) ) { LOG . severe ( STR_ ) ; return false ; } for ( Process process : processes To Restart ) { process . destroy ( ) ; } return true ; }
static Char Handler [ ] load Codes ( String codes File Path , char first Char , char last Char ) { int num Codes = ( as Unsigned Char ( last Char ) - as Unsigned Char ( first Char ) ) + NUM_ ; Char Handler [ ] values = new Char Handler [ num Codes ] ; Map < String , Type > prefix Map = new Hash Map < String , Type > ( ) ; for ( Type type : Type . values ( ) ) { prefix Map . put ( type . get Prefix Code ( ) , type ) ; } Buffered Reader reader = null ; try { reader = new Buffered Reader ( new Input Stream Reader ( Database Impl . get Resource As Stream ( codes File Path ) , STR_ ) ) ; int start = as Unsigned Char ( first Char ) ; int end = as Unsigned Char ( last Char ) ; for ( int i = start ; i <= end ; ++ i ) { char c = ( char ) i ; Char Handler ch = null ; if ( Character . is High Surrogate ( c ) || Character . is Low Surrogate ( c ) ) { ch = SURROGATE CHAR HANDLER ; } else { String code Line = reader . read Line ( ) ; ch = parse Codes ( prefix Map , code Line ) ; } values [ ( i - start ) ] = ch ; } } catch ( IO Exception e ) { throw new Runtime Exception ( STR_ + codes File Path , e ) ; } finally { Byte Util . close Quietly ( reader ) ; } return values ; }
protected void scan Directory ( ) { if ( System . current Time Millis ( ) - scan Interval Millis >= last Scan Millis ) { Set < Path > new Paths = scanner . scan ( fs , file Path , processed Files ) ; for ( Path new Path : new Paths ) { String new Path String = new Path . to String ( ) ; pending Files . add ( new Path String ) ; processed Files . add ( new Path String ) ; local Processed File Count . increment ( ) ; } last Scan Millis = System . current Time Millis ( ) ; } }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof Command APDU == false ) { return false ; } Command APDU other = ( Command APDU ) obj ; return Arrays . equals ( this . apdu , other . apdu ) ; }
@ Override public Graphics 2 D create Graphics ( Surface Data sd , W Component Peer peer , Color fg Color , Color bg Color , Font font ) { if ( ! done && sd instanceof D 3 D Window Surface Data ) { D 3 D Window Surface Data d 3 dw = ( D 3 D Window Surface Data ) sd ; if ( ! d 3 dw . is Surface Lost ( ) || validate ( d 3 dw ) ) { track Screen Surface ( d 3 dw ) ; return new Sun Graphics 2 D ( sd , fg Color , bg Color , font ) ; } sd = get Gdi Surface ( d 3 dw ) ; } return super . create Graphics ( sd , peer , fg Color , bg Color , font ) ; }
private void generate Legal Times Tree ( ) { final int k 0 = Key Event . KEYCODE 0 ; final int k 1 = Key Event . KEYCODE 1 ; final int k 2 = Key Event . KEYCODE 2 ; final int k 3 = Key Event . KEYCODE 3 ; final int k 4 = Key Event . KEYCODE 4 ; final int k 5 = Key Event . KEYCODE 5 ; final int k 6 = Key Event . KEYCODE 6 ; final int k 7 = Key Event . KEYCODE 7 ; final int k 8 = Key Event . KEYCODE 8 ; final int k 9 = Key Event . KEYCODE 9 ; m Legal Times Tree = new Node ( ) ; if ( m Is 24 Hour View ) { Node minute First Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; Node minute Second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; minute First Digit . add Child ( minute Second Digit ) ; Node first Digit = new Node ( k 0 , k 1 ) ; m Legal Times Tree . add Child ( first Digit ) ; Node second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; Node third Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; second Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; first Digit = new Node ( k 2 ) ; m Legal Times Tree . add Child ( first Digit ) ; second Digit = new Node ( k 0 , k 1 , k 2 , k 3 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; second Digit = new Node ( k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute Second Digit ) ; first Digit = new Node ( k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( minute First Digit ) ; } else { Node ampm = new Node ( get Am Or Pm Key Code ( AM ) , get Am Or Pm Key Code ( PM ) ) ; Node first Digit = new Node ( k 1 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( ampm ) ; Node second Digit = new Node ( k 0 , k 1 , k 2 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( ampm ) ; Node third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; Node fourth Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; third Digit . add Child ( fourth Digit ) ; fourth Digit . add Child ( ampm ) ; third Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; second Digit = new Node ( k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; first Digit = new Node ( k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( ampm ) ; second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; } }
public static double angle Sparse ( Sparse Number Vector v 1 , Sparse Number Vector v 2 ) { double l 1 = NUM_ , l 2 = NUM_ , cross = NUM_ ; int i 1 = v 1 . iter ( ) , i 2 = v 2 . iter ( ) ; while ( v 1 . iter Valid ( i 1 ) && v 2 . iter Valid ( i 2 ) ) { final int d 1 = v 1 . iter Dim ( i 1 ) , d 2 = v 2 . iter Dim ( i 2 ) ; if ( d 1 < d 2 ) { final double val = v 1 . iter Double Value ( i 1 ) ; l 1 += val * val ; i 1 = v 1 . iter Advance ( i 1 ) ; } else if ( d 2 < d 1 ) { final double val = v 2 . iter Double Value ( i 2 ) ; l 2 += val * val ; i 2 = v 2 . iter Advance ( i 2 ) ; } else { final double val 1 = v 1 . iter Double Value ( i 1 ) ; final double val 2 = v 2 . iter Double Value ( i 2 ) ; l 1 += val 1 * val 1 ; l 2 += val 2 * val 2 ; cross += val 1 * val 2 ; i 1 = v 1 . iter Advance ( i 1 ) ; i 2 = v 2 . iter Advance ( i 2 ) ; } } while ( v 1 . iter Valid ( i 1 ) ) { final double val = v 1 . iter Double Value ( i 1 ) ; l 1 += val * val ; i 1 = v 1 . iter Advance ( i 1 ) ; } while ( v 2 . iter Valid ( i 2 ) ) { final double val = v 2 . iter Double Value ( i 2 ) ; l 2 += val * val ; i 2 = v 2 . iter Advance ( i 2 ) ; } final double a = ( cross == NUM_ ) ? NUM_ : ( l 1 == NUM_ || l 2 == NUM_ ) ? NUM_ : Math . sqrt ( ( cross / l 1 ) * ( cross / l 2 ) ) ; return ( a < NUM_ ) ? a : NUM_ ; }
private void update Sub Tree ( final Tree Node node ) { int c = node . num Children ; final Stack < Tree Node > node Stack = new Stack < Tree Node > ( ) ; node Stack . push ( node ) ; Tree Node parent Temp ; Tree Node child ; while ( node Stack . size ( ) > NUM_ ) { parent Temp = node Stack . pop ( ) ; c = parent Temp . num Children ; for ( int i = NUM_ ; i < c ; i ++ ) { child = parent Temp . children [ i ] ; if ( parent Temp . g + child . get Cost ( ) < child . g ) { parent Temp . update Child ( child ) ; node Stack . push ( child ) ; } } } }
protected void sprint ( float float Field ) { sprint ( String . value Of ( float Field ) ) ; }
public boolean is Conversion Supported ( Audio Format target Format , Audio Format source Format ) { target Format = replace Not Specified ( source Format , target Format ) ; boolean res = Audio Formats . matches ( source Format , target Format ) || ( do Match ( target Format . get Frame Rate ( ) , source Format . get Frame Rate ( ) ) && do Match ( target Format . get Sample Rate ( ) , source Format . get Sample Rate ( ) ) && get Conversion Type ( get Format Type ( source Format ) , source Format . get Channels ( ) , get Format Type ( target Format ) , target Format . get Channels ( ) ) != CONVERT NOT POSSIBLE ) ; if ( T Debug . Trace Audio Converter ) { T Debug . out ( STR_ ) ; T Debug . out ( STR_ ) ; T Debug . out ( STR_ + source Format ) ; T Debug . out ( STR_ + target Format ) ; T Debug . out ( STR_ + res ) ; } return res ; }
public boolean has Call Event ( String channel , String from , String to ) { boolean has Event = false ; if ( m Channel Call Map . contains Key ( channel ) ) { P 25 Call Event event = m Channel Call Map . get ( channel ) ; if ( to != null && event . get To ID ( ) != null && to . content Equals ( event . get To ID ( ) ) ) { if ( from != null ) { if ( event . get From ID ( ) == null ) { has Event = true ; } else if ( from . content Equals ( event . get From ID ( ) ) ) { has Event = true ; } } else { has Event = true ; } } } return has Event ; }
protected void add Tasks For Volumes And C Gs ( Db Client db Client , List < Volume > add Vols , List < Volume > remove Vols , Set < URI > remove Volume C Gs , String task Id , Task List task List ) { if ( add Vols != null && ! add Vols . is Empty ( ) ) { for ( Volume vol : add Vols ) { add Volume Task ( db Client , vol , task List , task Id , Resource Operation Type Enum . UPDATE VOLUME GROUP ) ; } } if ( remove Vols != null && ! remove Vols . is Empty ( ) ) { for ( Volume vol : remove Vols ) { add Volume Task ( db Client , vol , task List , task Id , Resource Operation Type Enum . UPDATE VOLUME GROUP ) ; } } if ( remove Volume C Gs != null && ! remove Volume C Gs . is Empty ( ) ) { for ( URI cg : remove Volume C Gs ) { add Consistency Group Task ( db Client , cg , task List , task Id , Resource Operation Type Enum . UPDATE VOLUME GROUP ) ; } } }
protected void open Known Loco ( ) { if ( loco Box . get Selected Roster Entries ( ) . length != NUM_ ) { Roster Entry re = loco Box . get Selected Roster Entries ( ) [ NUM_ ] ; if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + re . get File Name ( ) ) ; } start Programmer ( null , re , ( String ) programmer Box . get Selected Item ( ) ) ; } else { log . error ( STR_ ) ; } }
private void clip View On The Right ( Rect cur View Bound , float cur View Width , int right ) { cur View Bound . right = ( int ) ( right - m Clip Padding ) ; cur View Bound . left = ( int ) ( cur View Bound . right - cur View Width ) ; }
public void release Remote Download Lock ( String svc Id ) { try { if ( remote Download Lock != null ) { remote Download Lock . release ( ) ; publish Remote Download Leader ( null ) ; } } catch ( Exception e ) { log . error ( STR_ , svc Id , e ) ; } }
public static M Cash Line create Cash Line ( Properties ctx , int cash Id , int invoice Id , Big Decimal amount , Big Decimal write Off Amout , Big Decimal discount Amt , String trx Name ) throws Operation Exception { M Invoice invoice = new M Invoice ( ctx , invoice Id , trx Name ) ; if ( invoice . get ID ( ) == NUM_ ) { throw new Operation Exception ( STR_ ) ; } M Cash Line cash Line = new M Cash Line ( ctx , NUM_ , trx Name ) ; cash Line . set C Cash ID ( cash Id ) ; cash Line . set Invoice ( invoice ) ; cash Line . set Amount ( amount ) ; cash Line . set Write Off Amt ( write Off Amout ) ; cash Line . set Discount Amt ( discount Amt ) ; Po Manager . save ( cash Line ) ; return cash Line ; }
@ Override public int hash Code ( ) { return distributed Member . hash Code ( ) ; }
public void generate Add Animation ( View child , boolean from More Card ) { if ( m Is Expanded && m Animations Enabled && ! m Change Position In Progress ) { m Children To Add Animated . add ( child ) ; if ( from More Card ) { m From More Card Additions . add ( child ) ; } m Needs Animation = true ; } }
private double median ( List < Double > w ) { if ( w . size ( ) == NUM_ ) { return w . get ( NUM_ ) ; } List < Double > window = new Array List < Double > ( w . size ( ) ) ; for ( Double v : w ) { if ( ! Math Utils . is Calculatable ( v ) ) { return Double . Na N ; } window . add ( v ) ; } int median Index = Math Utils . randomized Select ( window , NUM_ , window . size ( ) - NUM_ , window . size ( ) / NUM_ ) ; double median = window . get ( median Index ) ; if ( ( window . size ( ) & NUM_ ) == NUM_ ) { int median Upper Index = Math Utils . randomized Select ( window , NUM_ , window . size ( ) - NUM_ , window . size ( ) / NUM_ + NUM_ ) ; double median Upper = window . get ( median Upper Index ) ; median = ( median + median Upper ) / NUM_ ; } return median ; }
private boolean condition L 0 ( String value , int index ) { if ( index == value . length ( ) - NUM_ && contains ( value , index - NUM_ , NUM_ , STR_ , STR_ , STR_ ) ) { return true ; } else if ( ( contains ( value , index - NUM_ , NUM_ , STR_ , STR_ ) || contains ( value , value . length ( ) - NUM_ , NUM_ , STR_ , STR_ ) ) && contains ( value , index - NUM_ , NUM_ , STR_ ) ) { return true ; } else { return false ; } }
protected final Json Token handle Field Name ( ) throws IO Exception , Json Parse Exception { if ( input Ptr >= input End ) { load More Guaranteed ( ) ; } int ch = input Buffer [ input Ptr ++ ] ; type Byte = ch ; switch ( ( ch > > NUM_ ) & NUM_ ) { case NUM_ : switch ( ch ) { case NUM_ : parsing Context . set Current Name ( STR_ ) ; return Json Token . FIELD NAME ; case NUM_ : case NUM_ : case NUM_ : case NUM_ : { if ( input Ptr >= input End ) { load More Guaranteed ( ) ; } int index = ( ( ch & NUM_ ) << NUM_ ) + ( input Buffer [ input Ptr ++ ] & NUM_ ) ; if ( index >= seen Name Count ) { report Invalid Shared Name ( index ) ; } parsing Context . set Current Name ( seen Names [ index ] ) ; } return Json Token . FIELD NAME ; case NUM_ : handle Long Field Name ( ) ; return Json Token . FIELD NAME ; } break ; case NUM_ : { int index = ( ch & NUM_ ) ; if ( index >= seen Name Count ) { report Invalid Shared Name ( index ) ; } parsing Context . set Current Name ( seen Names [ index ] ) ; } return Json Token . FIELD NAME ; case NUM_ : { int len = NUM_ + ( ch & NUM_ ) ; String name ; Name n = find Decoded From Symbols ( len ) ; if ( n != null ) { name = n . get Name ( ) ; input Ptr += len ; } else { name = decode Short Ascii Name ( len ) ; name = add Decoded To Symbols ( len , name ) ; } if ( seen Names != null ) { if ( seen Name Count >= seen Names . length ) { seen Names = expand Seen Names ( seen Names ) ; } seen Names [ seen Name Count ++ ] = name ; } parsing Context . set Current Name ( name ) ; } return Json Token . FIELD NAME ; case NUM_ : ch &= NUM_ ; { if ( ch > NUM_ ) { if ( ch == NUM_ ) { if ( ! parsing Context . in Object ( ) ) { report Mismatched End Marker ( STR_ , STR_ ) ; } parsing Context = parsing Context . get Parent ( ) ; return Json Token . END OBJECT ; } } else { final int len = ch + NUM_ ; String name ; Name n = find Decoded From Symbols ( len ) ; if ( n != null ) { name = n . get Name ( ) ; input Ptr += len ; } else { name = decode Short Unicode Name ( len ) ; name = add Decoded To Symbols ( len , name ) ; } if ( seen Names != null ) { if ( seen Name Count >= seen Names . length ) { seen Names = expand Seen Names ( seen Names ) ; } seen Names [ seen Name Count ++ ] = name ; } parsing Context . set Current Name ( name ) ; return Json Token . FIELD NAME ; } } break ; } report Error ( STR_ + Integer . to Hex String ( type Byte ) + STR_ ) ; return null ; }
public static I Multi Point [ ] copy Of ( I Multi Point [ ] original , int new Length ) { I Multi Point [ ] copy = new I Multi Point [ new Length ] ; System . arraycopy ( original , NUM_ , copy , NUM_ , Math . min ( original . length , new Length ) ) ; return copy ; }
public void request X 11 Forwarding ( String hostname , int port , byte [ ] cookie , boolean single Connection ) throws IO Exception { if ( hostname == null ) throw new Illegal Argument Exception ( STR_ ) ; synchronized ( this ) { if ( flag closed ) throw new IO Exception ( STR_ ) ; if ( flag x 11 requested ) throw new IO Exception ( STR_ ) ; if ( flag execution started ) throw new IO Exception ( STR_ ) ; flag x 11 requested = true ; } X 11 Server Data x 11 data = new X 11 Server Data ( ) ; x 11 data . hostname = hostname ; x 11 data . port = port ; x 11 data . x 11 magic cookie = cookie ; byte [ ] fake Cookie = new byte [ NUM_ ] ; String hex Encoded Fake Cookie ; while ( true ) { rnd . next Bytes ( fake Cookie ) ; String Buffer tmp = new String Buffer ( NUM_ ) ; for ( int i = NUM_ ; i < fake Cookie . length ; i ++ ) { String digit 2 = Integer . to Hex String ( fake Cookie [ i ] & NUM_ ) ; tmp . append ( ( digit 2 . length ( ) == NUM_ ) ? digit 2 : STR_ + digit 2 ) ; } hex Encoded Fake Cookie = tmp . to String ( ) ; if ( cm . check X 11 Cookie ( hex Encoded Fake Cookie ) == null ) break ; } cm . request X 11 ( cn , single Connection , STR_ , hex Encoded Fake Cookie , NUM_ ) ; synchronized ( this ) { if ( flag closed == false ) { this . x 11 Fake Cookie = hex Encoded Fake Cookie ; cm . register X 11 Cookie ( hex Encoded Fake Cookie , x 11 data ) ; } } }
public static String encode String ( String s ) { s = String Util . gsub ( STR_ , STR_ , s ) ; s = String Util . gsub ( STR_ , STR_ , s ) ; s = String Util . gsub ( STR_ , STR_ , s ) ; s = String Util . gsub ( STR_ , STR_ , s ) ; s = String Util . gsub ( STR_ , STR_ , s ) ; return s ; }
public Standard Pie Tool Tip Generator ( String label Format , Locale locale ) { this ( label Format , Number Format . get Number Instance ( locale ) , Number Format . get Percent Instance ( locale ) ) ; }
void fully Unlock ( ) { take Lock . unlock ( ) ; put Lock . unlock ( ) ; }
public void key ( String skey ) throws SQ Lite . Exception { synchronized ( this ) { byte ekey [ ] = null ; if ( skey != null && skey . length ( ) > NUM_ ) { ekey = new byte [ skey . length ( ) ] ; for ( int i = NUM_ ; i < skey . length ( ) ; i ++ ) { char c = skey . char At ( i ) ; ekey [ i ] = ( byte ) ( ( c & NUM_ ) ^ ( c > > NUM_ ) ) ; } } key ( ekey ) ; } }
public void add File ( String filename ) { synchronized ( files ) { if ( ! files . contains ( filename ) ) { files . add ( filename ) ; } } }
private void initialize Download Progress ( String version , long version Size ) { coordinator . set Target Info ( new Downloading Info ( version , version Size ) ) ; for ( Site site : dr Util . list Sites ( ) ) { for ( String node Id : coordinator . get All Nodes ( site . get Uuid ( ) ) ) { coordinator . set Node Global Scope Info ( new Downloading Info ( version , version Size ) , site . get Uuid ( ) , DOWNLOADINFO KIND , node Id ) ; } } }
public void fix Package Contents ( ) { if ( is Fixed ) return ; is Fixed = true ; fix E Classifiers ( ) ; }
@ Override public void flush ( ) { super . flush ( ) ; try { if ( out != null ) synchronized ( out ) { out . flush ( ) ; } } catch ( Socket Exception se ) { close ( ) ; } catch ( IO Exception ioe ) { ioe . print Stack Trace ( ) ; close ( ) ; } }
private void show Notification Label ( String i 18 n Key , Object ... arguments ) { Grid Bag Constraints constraint = new Grid Bag Constraints ( ) ; constraint . fill = Grid Bag Constraints . BOTH ; constraint . weightx = NUM_ ; constraint . weighty = NUM_ ; center Panel . remove All ( ) ; center Panel . add ( new J Panel ( ) , constraint ) ; constraint . weightx = NUM_ ; constraint . weighty = NUM_ ; constraint . fill = Grid Bag Constraints . NONE ; constraint . anchor = Grid Bag Constraints . CENTER ; center Panel . add ( new Resource Label ( i 18 n Key , arguments ) , constraint ) ; constraint . weightx = NUM_ ; constraint . weighty = NUM_ ; constraint . fill = Grid Bag Constraints . BOTH ; center Panel . add ( new J Panel ( ) , constraint ) ; center Panel . revalidate ( ) ; center Panel . repaint ( ) ; enable Header Actions ( false ) ; }
protected String try Create New Baseline ( String actual ) throws IO Exception { File file = new File ( File . separator + DIRECTORY TO COPY NEW BASELINE + File . separator + get Sub Directory Path For New Baseline ( ) + File . separator + baseline File Name ( ) ) ; Files . create Parent Dirs ( file ) ; Files . write ( actual , file , Charset . default Charset ( ) ) ; return file . to String ( ) ; }
public static void increment Bind ( ) { Log . d ( TAG , STR_ + bound . increment And Get ( ) ) ; Log . d ( TAG , STR_ + recycled . get ( ) ) ; }
public File resource Eml File ( @ Not Null String resource Name , @ Not Null Big Decimal version ) { String fn = STR_ + version . to Plain String ( ) + STR_ ; return data File ( RESOURCES DIR + STR_ + resource Name + STR_ + fn ) ; }
synchronized void add Bg Image ( Component img Comp , String image Url , int styles ) { if ( HTML Component . SUPPORT CSS ) { add ( img Comp , image Url ) ; if ( ( styles & CSS Engine . STYLE SELECTED ) != NUM_ ) { bg Image Comps Selected . add Element ( img Comp ) ; } if ( ( styles & CSS Engine . STYLE UNSELECTED ) != NUM_ ) { bg Image Comps Unselected . add Element ( img Comp ) ; } if ( ( styles & CSS Engine . STYLE PRESSED ) != NUM_ ) { bg Image Comps Pressed . add Element ( img Comp ) ; } } }
public boolean log Modified ( Logger log ) { for ( int i = dependency List . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Dependency dependency = dependency List . get ( i ) ; if ( dependency . log Modified ( log ) ) return true ; } return false ; }
public void check Jvm Thread Contention Monitoring ( Enum Jvm Thread Contention Monitoring x ) throws Snmp Status Exception { if ( Jvm Thread Contention Monitoring Unsupported . int Value ( ) == x . int Value ( ) ) { log . debug ( STR_ , STR_ ) ; throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Wrong Value ) ; } if ( ( Jvm Thread Contention Monitoring Enabled . int Value ( ) == x . int Value ( ) ) || ( Jvm Thread Contention Monitoring Disabled . int Value ( ) == x . int Value ( ) ) ) { Thread MX Bean mbean = get Thread MX Bean ( ) ; if ( mbean . is Thread Contention Monitoring Supported ( ) ) return ; log . debug ( STR_ , STR_ ) ; throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Inconsistent Value ) ; } log . debug ( STR_ , STR_ ) ; throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Wrong Value ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj instanceof EC Field F 2 m ) { return ( ( m == ( ( EC Field F 2 m ) obj ) . m ) && ( Arrays . equals ( ks , ( ( EC Field F 2 m ) obj ) . ks ) ) ) ; } return false ; }
public static boolean matches Url ( final Http Servlet Request request , final String path ) { final Pattern pattern = Pattern . compile ( STR_ + path + STR_ , Pattern . CASE INSENSITIVE ) ; if ( request . get Request URI ( ) != null ) { final Matcher m = pattern . matcher ( request . get Request URI ( ) ) ; return m . matches ( ) ; } return false ; }
private static void add Multiple Select Xform Value Node ( Element node ) { Element xforms Value Node = node . create Element ( null , null ) ; xforms Value Node . set Name ( NODE XFORMS VALUE ) ; xforms Value Node . set Attribute ( null , ATTRIBUTE XSI NILL , VALUE TRUE ) ; node . add Child ( Element . ELEMENT , xforms Value Node ) ; }
public boolean log Modified ( Logger log ) { if ( is Digest Modified ) { log . info ( source . get Native Path ( ) + STR_ ) ; return true ; } long source Last Modified = source . get Last Modified ( ) ; long source Length = source . length ( ) ; if ( ! require Source && source Last Modified == NUM_ ) { return false ; } else if ( source Length != length ) { log . info ( source . get Native Path ( ) + STR_ + length + STR_ + source Length + STR_ ) ; return true ; } else if ( source Last Modified != last Modified ) { log . info ( source . get Native Path ( ) + STR_ ) ; return true ; } else return false ; }
synchronized void flush Operations ( RT Edit Text editor ) { Stack < Operation > undo Stack = get Undo Stack ( editor ) ; Stack < Operation > redo Stack = get Redo Stack ( editor ) ; undo Stack . clear ( ) ; redo Stack . clear ( ) ; }
protected void make Widgets ( ) { String loc Text ; Grid Bag Layout gridbag = new Grid Bag Layout ( ) ; Grid Bag Constraints c = new Grid Bag Constraints ( ) ; set Layout ( gridbag ) ; loc Text = i 18 n . get ( Coord Panel . class , STR_ , STR_ ) ; set Border ( new Titled Border ( new Etched Border ( ) , loc Text ) ) ; Insets left Insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; Insets right Insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; loc Text = i 18 n . get ( Coord Panel . class , STR_ , STR_ ) ; J Label latlabel = new J Label ( loc Text ) ; c . gridx = NUM_ ; c . gridy = NUM_ ; c . fill = Grid Bag Constraints . NONE ; c . weightx = NUM_ ; c . insets = left Insets ; c . anchor = Grid Bag Constraints . EAST ; gridbag . set Constraints ( latlabel , c ) ; add ( latlabel ) ; latitude = new J Text Field ( NUM_ ) ; c . gridx = NUM_ ; c . gridy = NUM_ ; c . fill = Grid Bag Constraints . HORIZONTAL ; c . weightx = NUM_ ; c . insets = right Insets ; gridbag . set Constraints ( latitude , c ) ; add ( latitude ) ; loc Text = i 18 n . get ( Coord Panel . class , STR_ , STR_ ) ; J Label lonlabel = new J Label ( loc Text ) ; c . gridx = NUM_ ; c . gridy = NUM_ ; c . fill = Grid Bag Constraints . NONE ; c . weightx = NUM_ ; c . insets = left Insets ; gridbag . set Constraints ( lonlabel , c ) ; add ( lonlabel ) ; longitude = new J Text Field ( NUM_ ) ; c . gridx = NUM_ ; c . gridy = NUM_ ; c . fill = Grid Bag Constraints . HORIZONTAL ; c . weightx = NUM_ ; c . insets = right Insets ; gridbag . set Constraints ( longitude , c ) ; add ( longitude ) ; }
public void write ( Processing Instruction pi ) throws SAX Exception { String target = pi . get Target ( ) ; String text = pi . get Text ( ) ; content Handler . processing Instruction ( target , text ) ; }
public Mim Search Editor ( Mim Build Runner runner ) { this ( runner , STR_ ) ; }
@ Override public int hash Code ( ) { int result = NUM_ ; for ( int i = NUM_ ; i < vals . length ; i ++ ) result = NUM_ * result + Float . float To Int Bits ( vals [ i ] ) ; return result ; }
public void process Statement ( final Statement statement , long start Time , Result Set Future result ) { report ( start Time , statement , result ) ; }
public static boolean matches ( final Certificate ID cert Id , final Single Resp single Resp ) { final Certificate ID single Resp Cert ID = single Resp . get Cert ID ( ) ; final ASN 1 Object Identifier single Resp Cert ID Hash Alg OID = single Resp Cert ID . get Hash Alg OID ( ) ; final byte [ ] single Resp Cert ID Issuer Key Hash = single Resp Cert ID . get Issuer Key Hash ( ) ; final byte [ ] single Resp Cert ID Issuer Name Hash = single Resp Cert ID . get Issuer Name Hash ( ) ; final Big Integer single Resp Cert ID Serial Number = single Resp Cert ID . get Serial Number ( ) ; final ASN 1 Object Identifier cert Id Hash Alg OID = cert Id . get Hash Alg OID ( ) ; final byte [ ] cert Id Issuer Key Hash = cert Id . get Issuer Key Hash ( ) ; final byte [ ] cert Id Issuer Name Hash = cert Id . get Issuer Name Hash ( ) ; final Big Integer cert Id Serial Number = cert Id . get Serial Number ( ) ; return single Resp Cert ID Hash Alg OID . equals ( cert Id Hash Alg OID ) && Arrays . are Equal ( single Resp Cert ID Issuer Key Hash , cert Id Issuer Key Hash ) && Arrays . are Equal ( single Resp Cert ID Issuer Name Hash , cert Id Issuer Name Hash ) && single Resp Cert ID Serial Number . equals ( cert Id Serial Number ) ; }
public void add Property Change Listener ( String property Name , Property Change Listener in pcl ) { pc Support . add Property Change Listener ( property Name , in pcl ) ; }
private void install Selector For Protocol ( Dict proxy Settings , Protocol Dispatch Selector ps , String protocol ) { String prefix = protocol . trim ( ) ; if ( is Active ( proxy Settings . get ( prefix + STR_ ) ) ) { String proxy Host = ( String ) proxy Settings . get ( prefix + STR_ ) ; int proxy Port = ( Integer ) proxy Settings . get ( prefix + STR_ ) ; Fixed Proxy Selector fp = new Fixed Proxy Selector ( proxy Host , proxy Port ) ; ps . set Selector ( protocol . to Lower Case ( ) , fp ) ; Logger . log ( get Class ( ) , Log Level . TRACE , STR_ , protocol , proxy Host , proxy Port ) ; } }
public void remove Discovery Listener ( Discovery Listener listener ) { listeners . remove ( listener ) ; }
private Image Icon add Space To Icon ( Image Icon icon ) { int width = icon . get Icon Width ( ) ; int height = icon . get Icon Height ( ) ; int hspace = NUM_ ; Buffered Image res = new Buffered Image ( width + hspace , height , Buffered Image . TYPE INT ARGB ) ; Graphics g = res . get Graphics ( ) ; g . draw Image ( icon . get Image ( ) , NUM_ , NUM_ , null ) ; g . dispose ( ) ; return new Image Icon ( res ) ; }
public final void add Clinit ( ) { if ( need Class Init Method ( ) ) { int length ; Abstract Method Declaration [ ] method Declarations ; if ( ( method Declarations = this . methods ) == null ) { length = NUM_ ; method Declarations = new Abstract Method Declaration [ NUM_ ] ; } else { length = method Declarations . length ; System . arraycopy ( method Declarations , NUM_ , ( method Declarations = new Abstract Method Declaration [ length + NUM_ ] ) , NUM_ , length ) ; } Clinit clinit = new Clinit ( this . compilation Result ) ; method Declarations [ NUM_ ] = clinit ; clinit . declaration Source Start = clinit . source Start = this . source Start ; clinit . declaration Source End = clinit . source End = this . source End ; clinit . body End = this . source End ; this . methods = method Declarations ; } }
public static void begin Wrapper ( Writer writer ) throws IO Exception { writer . write ( STR_ ) ; }
static void clean Garbage ( ) { System . gc ( ) ; try { Thread . sleep ( NUM_ ) ; } catch ( Exception e ) { } System . gc ( ) ; }
private void create Field Annotation ( J Cas jcas , String local Name , int begin , int end ) { String field Name = null ; if ( use Substitution ) { field Name = substitution . get ( local Name ) ; if ( field Name == null ) { field Name = local Name ; } } else { field Name = local Name ; } Field field = new Field ( jcas , begin , end ) ; field . set Name ( field Name ) ; field . add To Indexes ( ) ; }
void validate Oustanding Injections ( Errors errors ) { for ( Injectable Reference < ? > reference : pending Injection . values ( ) ) { try { reference . validate ( errors ) ; } catch ( Errors Exception e ) { errors . merge ( e . get Errors ( ) ) ; } } }
public boolean validate ( Line State state ) { Augmented Node < I Line Segment > s = state . root ( ) ; if ( s == null ) return true ; return validate Node ( s ) ; }
private static void compress Table ( String table Name , boolean compress In Place ) throws Ade Internal Exception { logger . trace ( String . format ( STR_ , table Name , compress In Place ) ) ; logger . warn ( String . format ( STR_ , table Name ) ) ; logger . trace ( String . format ( STR_ , table Name ) ) ; }
public static int color ( Color c ) { return c . get RGB ( ) ; }
public static String exception To String ( Throwable t ) { String Writer sw = new String Writer ( ) ; Print Writer out = new Print Writer ( sw ) ; print Exception Stack ( t , out , NUM_ ) ; return sw . to String ( ) ; }
public static void generate Parameter Reifier Code ( String [ ] param Types , boolean is Static , final Code Visitor cv ) { cv . visit Int Insn ( SIPUSH , param Types . length ) ; cv . visit Type Insn ( ANEWARRAY , STR_ ) ; int local Var Index = is Static ? NUM_ : NUM_ ; for ( int i = NUM_ ; i < param Types . length ; ++ i ) { String param = param Types [ i ] ; cv . visit Insn ( DUP ) ; cv . visit Int Insn ( SIPUSH , i ) ; if ( is Primitive ( param ) ) { int opcode ; if ( param . equals ( STR_ ) ) { opcode = FLOAD ; } else if ( param . equals ( STR_ ) ) { opcode = DLOAD ; } else if ( param . equals ( STR_ ) ) { opcode = LLOAD ; } else { opcode = ILOAD ; } String type = STR_ ; cv . visit Type Insn ( NEW , type ) ; cv . visit Insn ( DUP ) ; cv . visit Var Insn ( opcode , local Var Index ) ; String desc = param ; cv . visit Method Insn ( INVOKESPECIAL , type , STR_ , STR_ + desc + STR_ ) ; } else { cv . visit Var Insn ( ALOAD , local Var Index ) ; } cv . visit Insn ( AASTORE ) ; local Var Index += ( ( param . equals ( STR_ ) || param . equals ( STR_ ) ) ? NUM_ : NUM_ ) ; } }
public static String as String ( String json Path , Map < String , Object > json ) { String str = null ; Object obj = at Path ( json Path , json ) ; if ( obj != null ) { if ( obj instanceof String ) { str = ( String ) obj ; } else { throw new Illegal State Exception ( STR_ + json Path + STR_ + obj + STR_ + json ) ; } } return str ; }
protected Json Deserializer < Object > find Deserializer ( Deserialization Config config , Deserializer Provider provider , Java Type type , Bean Property property ) throws Json Mapping Exception { Json Deserializer < Object > deser = provider . find Value Deserializer ( config , type , property ) ; return deser ; }
protected boolean os Create Dir If Neccessary ( File dest Dir Folder ) { return dest Dir Folder . mkdirs ( ) || dest Dir Folder . is Directory ( ) ; }
private static Element build Repeat Control ( Element body Node , Element control Node , String name , Element model Node ) { Element repeat Control = body Node . create Element ( NAMESPACE XFORMS , null ) ; repeat Control . set Name ( CONTROL REPEAT ) ; repeat Control . set Attribute ( null , ATTRIBUTE BIND , name ) ; if ( control Node != null ) repeat Control . add Child ( Element . ELEMENT , control Node ) ; else if ( name . contains ( STR_ ) || name . contains ( STR_ ) ) add Default Problem List Child ( name , repeat Control , null , model Node ) ; else if ( obs Repeat Items . contains ( name ) ) add Default Problem List Child ( name , repeat Control , STR_ , model Node ) ; return repeat Control ; }
public Block Id ( String file Name , long blk Num ) { this . file Name = file Name ; this . blk Num = blk Num ; my String = STR_ + file Name + STR_ + blk Num + STR_ ; my Hash Code = my String . hash Code ( ) ; }
@ Override public void generate Partition ( Instances data ) throws Exception { if ( m Classifier instanceof Partition Generator ) build Classifier ( data ) ; else throw new Exception ( STR_ + get Classifier Spec ( ) + STR_ ) ; }
public void register Listener ( Js File Loaded Listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
private void start Servers ( ) { Util . print Section ( STR_ ) ; Nio Server nio Server = new Nio Server ( Network Config . NIO READ WRITE THREADS , new Server Cfg ( Network Config . GAME BIND ADDRESS , Network Config . GAME PORT , STR_ , new Game Connection Factory Impl ( ) ) ) ; Login Server ls = Login Server . get Instance ( ) ; Chat Server cs = Chat Server . get Instance ( ) ; ls . set Nio Server ( nio Server ) ; cs . set Nio Server ( nio Server ) ; nio Server . connect ( ) ; ls . connect ( ) ; if ( GS Config . ENABLE CHAT SERVER ) { cs . connect ( ) ; } Util . print Section ( STR_ ) ; }
private void store Request Id ( String request Id , String key ) { request Ids . put ( request Id , key ) ; }
public void prune Old Exceptions ( ) { Set < T > members ; members = new Hash Set < T > ( member To GC Version . key Set ( ) ) ; for ( T member : members ) { Long gc Version = member To GC Version . get ( member ) ; Region Version Holder < T > holder ; holder = member To Version . get ( member ) ; if ( holder != null && gc Version != null ) { synchronized ( holder ) { holder . remove Exceptions Older Than ( gc Version ) ; } } } local Exceptions . remove Exceptions Older Than ( local GC Version . get ( ) ) ; }
private Workflow . Method create Import Copy Method ( URI vplex URI , List < Volume Descriptor > volume Descriptors , URI project URI , URI tenant URI ) { return new Workflow . Method ( IMPORT COPY METHOD NAME , vplex URI , volume Descriptors , project URI , tenant URI ) ; }
public void add Literal Result Attribute ( String att ) { if ( null == m xsl Attr ) m xsl Attr = new Array List ( ) ; m xsl Attr . add ( att ) ; }
public static final Object [ ] resize ( Object [ ] a , int size ) { if ( a . length >= size ) return a ; Object [ ] b = new Object [ size ] ; System . arraycopy ( a , NUM_ , b , NUM_ , a . length ) ; return b ; }
public int hash Code ( ) { return name . hash Code ( ) ; }
@ Override protected void copy Item ( Positionable p ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ , selection Group != null ? STR_ + selection Group . size ( ) : STR_ ) ; } if ( paste Pending ) { paste Items ( ) ; } if ( selection Group != null && ! selection Group . contains ( p ) ) { deselect Selection Group ( ) ; } if ( selection Group == null ) { selection Group = new Array List < Positionable > ( ) ; selection Group . add ( p ) ; } Array List < Positionable > selection Group = new Array List < Positionable > ( ) ; for ( Positionable comp : selection Group ) { Positionable pos = comp . deep Clone ( ) ; selection Group . add ( pos ) ; } selection Group = selection Group ; paste Pending = true ; }
@ Override public void on Bind View Holder ( Category View Holder holder , int position ) { int amount Due = NUM_ ; if ( position == NUM_ ) { for ( Category category : m Categories ) { amount Due += m Due Challenge Counts . get ( category . get Id ( ) ) ; } holder . bind All Categories Card ( amount Due ) ; } else { final Category category = m Categories . get ( position - NUM_ ) ; holder . bind Card ( category , m Due Challenge Counts . get ( category . get Id ( ) ) ) ; } }
public static Observable < Network Service Discovery Info > start Discovery ( @ Non Null Context context , @ Non Null String protocol ) throws Nsd Exception { if ( protocol . equals Ignore Case ( ALL AVAILABLE SERVICES ) ) { throw new Nsd Exception ( Nsd Exception . INVALID ARGUMENT , protocol , NUM_ ) ; } return Discovery On Subscribe Factory . from ( context , protocol ) ; }
@ Override public void do Edit Chart Properties ( ) { Chart Editor editor = Chart Editor Manager . get Chart Editor ( this . chart ) ; int result = J Option Pane . show Confirm Dialog ( this , editor , localization Resources . get String ( STR_ ) , J Option Pane . OK CANCEL OPTION , J Option Pane . PLAIN MESSAGE ) ; if ( result == J Option Pane . OK OPTION ) { editor . update Chart ( this . chart ) ; } }
public static < T > void remove All ( Collection < T > collection , Collection < T > elements ) { if ( Collection Utils . is Empty ( collection ) || Collection Utils . is Empty ( elements ) ) { return ; } for ( T element : elements ) { collection . remove ( element ) ; } }
private void send Broadcast Download Finished ( Download File Operation download , Remote Operation Result download Result , String unlinked From Remote Path ) { Intent end = new Intent ( get Download Finish Message ( ) ) ; end . put Extra ( EXTRA DOWNLOAD RESULT , download Result . is Success ( ) ) ; end . put Extra ( ACCOUNT NAME , download . get Account ( ) . name ) ; end . put Extra ( EXTRA REMOTE PATH , download . get Remote Path ( ) ) ; end . put Extra ( EXTRA FILE PATH , download . get Save Path ( ) ) ; if ( unlinked From Remote Path != null ) { end . put Extra ( EXTRA LINKED TO PATH , unlinked From Remote Path ) ; } send Sticky Broadcast ( end ) ; }
protected void prepare Import Table ( ) throws SQL Exception { Result Set column List = null ; One Row Change spec Orc = new One Row Change ( ) ; column Definitions = new Array List < Column Spec > ( ) ; try { column List = metadata . get Columns ( import Tables . get String ( STR_ ) , import Tables . get String ( STR_ ) , import Tables . get String ( STR_ ) , null ) ; while ( column List . next ( ) ) { Column Spec c Spec = spec Orc . new Column Spec ( ) ; c Spec . set Name ( column List . get String ( STR_ ) ) ; c Spec . set Type ( extract Column Type ( column List ) ) ; c Spec . set Length ( column List . get Int ( STR_ ) ) ; column Definitions . add ( c Spec ) ; logger . debug ( STR_ + column List . get String ( STR_ ) + STR_ + column List . get String ( STR_ ) + STR_ + column List . get String ( STR_ ) + STR_ + column List . get String ( STR_ ) + STR_ + column List . get String ( STR_ ) + STR_ + column List . get Int ( STR_ ) ) ; } } finally { if ( column List != null ) { column List . close ( ) ; } } }
public static File Descriptor Set generate ( Service normalized Service ) { Descriptor Generator generator = new Descriptor Generator ( ) ; generator . analyze Service ( normalized Service ) ; return generator . generate ( ) ; }
public void file Reused ( File f ) { if ( ! recent Files . contains ( f ) ) { throw new Illegal State Exception ( STR_ ) ; } else { recent Files . remove ( f ) ; recent Files . add ( f ) ; } }
protected Map < String , String > overrides ( ) { return Collections . empty Map ( ) ; }
public Node List select Node List ( Node context Node , Node xpathnode , String str , Node namespace Node ) throws Transformer Exception { X Object list = eval ( context Node , xpathnode , str , namespace Node ) ; return list . nodelist ( ) ; }
public static void send Error ( Http Servlet Request request , Http Servlet Response response , int http Status Code , String error Code , String error Msg ) { if ( ( error Url == null ) || ( error Url . length ( ) == NUM_ ) ) { try { response . send Error ( http Status Code , error Msg ) ; return ; } catch ( IO Exception ioe ) { debug . error ( STR_ , ioe ) ; } } else { String joint String = STR_ ; if ( error Url . index Of ( STR_ ) != - NUM_ ) { joint String = STR_ ; } String new Url = error Url . trim ( ) + joint String + STR_ + error Code + STR_ + STR_ + http Status Code + STR_ + STR_ + URL Enc Dec . encode ( error Msg ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + new Url ) ; } String tmp = error Url . to Lower Case ( ) ; if ( tmp . starts With ( STR_ ) || tmp . starts With ( STR_ ) ) { try { response . send Redirect ( new Url ) ; } catch ( IO Exception e ) { debug . error ( STR_ + STR_ + new Url , e ) ; } } else { try { Request Dispatcher dispatcher = request . get Request Dispatcher ( new Url ) ; dispatcher . forward ( request , response ) ; } catch ( Servlet Exception e ) { debug . error ( STR_ + STR_ + new Url , e ) ; } catch ( IO Exception e ) { debug . error ( STR_ + STR_ + new Url , e ) ; } } } }
private static void print Usage ( Options options ) { Help Formatter help = new Help Formatter ( ) ; help . print Help ( STR_ , options ) ; System . exit ( NUM_ ) ; }
public static < T > Set < T > empty Set ( final Set < T > set ) { return ( set != null ? set : Collections . < T > empty Set ( ) ) ; }
public void load ( ) { files = new Hash Map < String , Virtual File > ( ) ; Zip File zip File = null ; try { zip File = new Zip File ( path ) ; Enumeration e = zip File . get Entries ( ) ; while ( e . has More Elements ( ) ) { Zip Entry ze = ( Zip Entry ) e . next Element ( ) ; Input Stream input Stream = zip File . get Input Stream ( ze ) ; Virtual File f = new In Memory File ( input Stream , ze . get Size ( ) , path + STR_ + ze . get Name ( ) , Mime Mappings . get Mime Type ( ze . get Name ( ) ) , ze . get Time ( ) ) ; files . put ( ze . get Name ( ) , f ) ; } } catch ( Swc Exception . Unknown Zip Format e ) { throw new Swc Exception . Not A Swc File ( path ) ; } catch ( Swc Exception e ) { throw e ; } catch ( Exception e ) { throw new Swc Exception . Files Not Read ( e . get Message ( ) ) ; } finally { try { if ( zip File != null ) zip File . close ( ) ; } catch ( IO Exception ioe ) { } } }
private String match Map ( Array List < EL Node . Function > functions ) { String map Name = null ; for ( int i = NUM_ ; i < functions . size ( ) ; i ++ ) { EL Node . Function f = functions . get ( i ) ; String tem Name = g Map . get ( f . get Prefix ( ) + STR_ + f . get Name ( ) + STR_ + f . get Uri ( ) ) ; if ( tem Name == null ) { return null ; } if ( map Name == null ) { map Name = tem Name ; } else if ( ! tem Name . equals ( map Name ) ) { return null ; } } return map Name ; }
public String validate Last Paid Date ( Properties ctx , int Window No , Grid Tab m Tab , Grid Field m Field , Object value ) { if ( is Callout Active ( ) || value == null ) return STR_ ; I HR Employee Insurance employee Insurance = Grid Tab Wrapper . create ( m Tab , I HR Employee Insurance . class ) ; Timestamp pay Date = employee Insurance . get Pay Date ( ) ; Timestamp last Paid Date = ( Timestamp ) value ; if ( pay Date == null ) return STR_ ; if ( last Paid Date . before ( pay Date ) ) return STR_ ; else { String message = Msg . get Msg ( Env . get Ctx ( ) , STR_ ) + STR_ + Msg . parse Translation ( ctx , STR_ ) ; employee Insurance . set Date Last Paid ( ( Timestamp ) m Field . get Old Value ( ) ) ; m Tab . fire Data Status E Event ( message , null , false ) ; } return STR_ ; }
private static String build Message ( String reason , String description , int status Code , Druid Query < ? > druid Query , Throwable cause , Object Writer object Writer ) { String druid Query String ; try { druid Query String = object Writer . write Value As String ( druid Query ) ; } catch ( Json Processing Exception jse ) { try { druid Query String = druid Query . to String ( ) ; } catch ( Exception e ) { LOG . warn ( STR_ , e ) ; druid Query String = STR_ ; } LOG . warn ( String . format ( STR_ , druid Query String ) , jse ) ; } return String . format ( STR_ , reason , description , status Code , druid Query String , cause ) ; }
private void call Delete Api ( String wall Id ) { Retro Callback retro Callback ; retro Callback = new Retro Callback ( this ) ; retro Callback . set Request Id ( Http Constants . Api Response Codes . DELETE WALL ) ; retro Callback List . add ( retro Callback ) ; m Yelo Api . delete Wall ( wall Id , retro Callback ) ; String selection = Database Columns . ID + SQL Constants . EQUALS ARG ; DB Interface . delete Async ( App Constants . Query Tokens . DELETE WALL POST , get Task Tag ( ) , null , Table Wall Posts . NAME , selection , new String [ ] { wall Id } , true , this ) ; }
@ Log Message Doc ( level = STR_ , message = STR_ + STR_ , explanation = STR_ + STR_ ) protected void parse Config Parameters ( Properties prop ) { if ( prop == null ) return ; Enumeration < ? > e = prop . property Names ( ) ; while ( e . has More Elements ( ) ) { String key = ( String ) e . next Element ( ) ; String config Value = null ; int last Period = key . last Index Of ( STR_ ) ; String module Name = key . substring ( NUM_ , last Period ) ; String config Key = key . substring ( last Period + NUM_ ) ; String system Key = System . get Property ( key ) ; if ( system Key != null ) { config Value = system Key ; } else { config Value = prop . get Property ( key ) ; } I Floodlight Module mod = module Name Map . get ( module Name ) ; if ( mod == null ) { logger . debug ( STR_ + STR_ , new Object [ ] { module Name , config Key , config Value } ) ; } else { logger . debug ( STR_ , new Object [ ] { config Key , config Value , module Name } ) ; floodlight Module Context . add Config Param ( mod , config Key , config Value ) ; } } }
protected List < T > create New Row ( final T value , final int cols ) { Array List < T > row = new Array List < T > ( ) ; for ( int i = NUM_ ; i < cols ; i ++ ) { row . add ( value ) ; } return row ; }
public Map < Context , List < Outlier Classification Result > > search Context Given Outliers ( List < Contextual Datum > data ) throws Exception { List < Contextual Datum > input Outliers = find Input Outliers ( data ) ; return search Context Given Outliers ( data , input Outliers ) ; }
public void init Channel ( ) throws Carbon Data Writer Exception { init File Count ( ) ; if ( this . is In Progress Extrequired ) { this . file Name = Message Format . format ( this . file Name Format , this . file Count ) + Carbon Common Constants . FILE INPROGRESS STATUS ; File Data file Data = new File Data ( this . file Name , this . store Location ) ; file Manager . add ( file Data ) ; } else { this . file Name = Message Format . format ( this . file Name Format , this . file Count ) ; } this . file Count ++ ; try { this . file Data Out Stream = File Factory . get Data Output Stream ( this . file Name , File Factory . get File Type ( this . file Name ) , ( short ) NUM_ ) ; } catch ( File Not Found Exception file Not Found Exception ) { throw new Carbon Data Writer Exception ( STR_ , file Not Found Exception ) ; } catch ( IO Exception e ) { throw new Carbon Data Writer Exception ( STR_ , e ) ; } }
public void notify Data Changed ( ) { init ( m Data Sets ) ; }
public void add Apply Action Listener ( Action Listener al ) { apply Button . add Action Listener ( al ) ; }
public static Buffered Image byte Array To Image ( byte [ ] image Data , String img File Name ) throws Open Stego Exception { Buffered Image image = null ; try { if ( image Data == null ) { return null ; } image = Image IO . read ( new Byte Array Input Stream ( image Data ) ) ; if ( image == null ) { throw new Open Stego Exception ( null , Open Stego . NAMESPACE , Open Stego Exception . IMAGE FILE INVALID , img File Name ) ; } return image ; } catch ( IO Exception io Ex ) { throw new Open Stego Exception ( io Ex ) ; } }
public Checkbox Tree ( ) { super ( get Default Tree Model ( ) ) ; initialize ( ) ; }
private void general Information Dialogs ( ) { final Speaker NPC npc = npcs . get ( STR_ ) ; npc . add ( Conversation States . ATTENDING , STR_ , null , Conversation States . ATTENDING , STR_ + STR_ , null ) ; npc . add ( Conversation States . QUEST OFFERED , STR_ , null , Conversation States . QUEST OFFERED , STR_ + STR_ , null ) ; List < String > berry Strings = new Array List < String > ( ) ; berry Strings . add ( STR_ ) ; berry Strings . add ( STR_ ) ; berry Strings . add ( STR_ ) ; berry Strings . add ( STR_ ) ; npc . add Reply ( berry Strings , STR_ ) ; npc . add Reply ( STR_ , STR_ ) ; }
public static String parsed Page To Html ( Parsed Page pp ) { String Builder result = new String Builder ( ) ; result . append ( get Html Header ( ) ) ; if ( pp != null ) { result . append ( STR_ + STR_ + pp . get Name ( ) + STR_ ) ; result . append ( STR_ ) ; for ( Section s : pp . get Sections ( ) ) { result . append ( section To Html ( s ) ) ; } result . append ( STR_ ) ; if ( pp . get Category Element ( ) != null ) { result . append ( STR_ ) ; result . append ( STR_ + content Element To Html ( pp . get Category Element ( ) ) ) ; result . append ( STR_ ) ; } if ( pp . get Languages Element ( ) != null ) { result . append ( STR_ ) ; result . append ( STR_ + content Element To Html ( pp . get Languages Element ( ) ) ) ; result . append ( STR_ ) ; } result . append ( STR_ ) ; } result . append ( get Html Footer ( ) ) ; return result . to String ( ) ; }
double evaluate Instance Leave One Out ( Instance instance , double [ ] inst A ) throws Exception { Decision Table Hash Key thekey ; double [ ] temp Dist ; double [ ] norm Dist ; thekey = new Decision Table Hash Key ( inst A ) ; if ( m class Is Nominal ) { if ( ( temp Dist = m entries . get ( thekey ) ) == null ) { throw new Error ( STR_ ) ; } else { norm Dist = new double [ temp Dist . length ] ; System . arraycopy ( temp Dist , NUM_ , norm Dist , NUM_ , temp Dist . length ) ; norm Dist [ ( int ) instance . class Value ( ) ] -= instance . weight ( ) ; boolean ok = false ; for ( double element : norm Dist ) { if ( Utils . gr ( element , NUM_ ) ) { ok = true ; break ; } } m class Prior Counts [ ( int ) instance . class Value ( ) ] -= instance . weight ( ) ; double [ ] class Priors = m class Prior Counts . clone ( ) ; Utils . normalize ( class Priors ) ; if ( ! ok ) { norm Dist = class Priors ; } m class Prior Counts [ ( int ) instance . class Value ( ) ] += instance . weight ( ) ; Utils . normalize ( norm Dist ) ; if ( m evaluation Measure == EVAL AUC ) { m evaluation . evaluate Model Once And Record Prediction ( norm Dist , instance ) ; } else { m evaluation . evaluate Model Once ( norm Dist , instance ) ; } return Utils . max Index ( norm Dist ) ; } } else { if ( ( temp Dist = m entries . get ( thekey ) ) != null ) { norm Dist = new double [ temp Dist . length ] ; System . arraycopy ( temp Dist , NUM_ , norm Dist , NUM_ , temp Dist . length ) ; norm Dist [ NUM_ ] -= ( instance . class Value ( ) * instance . weight ( ) ) ; norm Dist [ NUM_ ] -= instance . weight ( ) ; if ( Utils . eq ( norm Dist [ NUM_ ] , NUM_ ) ) { double [ ] temp = new double [ NUM_ ] ; temp [ NUM_ ] = m majority ; m evaluation . evaluate Model Once ( temp , instance ) ; return m majority ; } else { double [ ] temp = new double [ NUM_ ] ; temp [ NUM_ ] = norm Dist [ NUM_ ] / norm Dist [ NUM_ ] ; m evaluation . evaluate Model Once ( temp , instance ) ; return temp [ NUM_ ] ; } } else { throw new Error ( STR_ ) ; } } }
private void write Link Files ( String output Folder ) throws IO Exception { if ( this . links Checked ) { write Link Statistics File ( output Folder ) ; write Storage Capacity Warning File ( output Folder ) ; } write Clusters And Network 2 ESRI Shape ( output Folder ) ; }
public Set < Integer > primary Partitions ( UUID node Id ) { Set < Integer > set = primary . get ( node Id ) ; return set == null ? Collections . < Integer > empty Set ( ) : set ; }
public void paint Border ( Component c , Graphics g , int x , int y , int width , int height ) { Color old Color = g . get Color ( ) ; g . translate ( x , y ) ; if ( bevel Type == RAISED ) { g . set Color ( get Highlight Outer Color ( c ) ) ; g . draw Line ( NUM_ , NUM_ , width - NUM_ , NUM_ ) ; g . draw Line ( NUM_ , NUM_ , NUM_ , height - NUM_ ) ; g . draw Line ( NUM_ , NUM_ , NUM_ , NUM_ ) ; g . set Color ( get Highlight Inner Color ( c ) ) ; g . draw Line ( NUM_ , NUM_ , width - NUM_ , NUM_ ) ; g . draw Line ( NUM_ , NUM_ , NUM_ , height - NUM_ ) ; g . draw Line ( NUM_ , NUM_ , NUM_ , NUM_ ) ; g . draw Line ( NUM_ , height - NUM_ , NUM_ , height - NUM_ ) ; g . draw Line ( width - NUM_ , NUM_ , width - NUM_ , NUM_ ) ; g . set Color ( get Shadow Outer Color ( c ) ) ; g . draw Line ( NUM_ , height - NUM_ , width - NUM_ , height - NUM_ ) ; g . draw Line ( width - NUM_ , NUM_ , width - NUM_ , height - NUM_ ) ; g . set Color ( get Shadow Inner Color ( c ) ) ; g . draw Line ( width - NUM_ , height - NUM_ , width - NUM_ , height - NUM_ ) ; } else if ( bevel Type == LOWERED ) { g . set Color ( get Shadow Outer Color ( c ) ) ; g . draw Line ( NUM_ , NUM_ , width - NUM_ , NUM_ ) ; g . draw Line ( NUM_ , NUM_ , NUM_ , height - NUM_ ) ; g . draw Line ( NUM_ , NUM_ , NUM_ , NUM_ ) ; g . set Color ( get Shadow Inner Color ( c ) ) ; g . draw Line ( NUM_ , NUM_ , width - NUM_ , NUM_ ) ; g . draw Line ( NUM_ , NUM_ , NUM_ , height - NUM_ ) ; g . draw Line ( NUM_ , NUM_ , NUM_ , NUM_ ) ; g . draw Line ( NUM_ , height - NUM_ , NUM_ , height - NUM_ ) ; g . draw Line ( width - NUM_ , NUM_ , width - NUM_ , NUM_ ) ; g . set Color ( get Highlight Outer Color ( c ) ) ; g . draw Line ( NUM_ , height - NUM_ , width - NUM_ , height - NUM_ ) ; g . draw Line ( width - NUM_ , NUM_ , width - NUM_ , height - NUM_ ) ; g . set Color ( get Highlight Inner Color ( c ) ) ; g . draw Line ( width - NUM_ , height - NUM_ , width - NUM_ , height - NUM_ ) ; } g . translate ( - x , - y ) ; g . set Color ( old Color ) ; }
@ Deprecated public static JC Diagnostic fragment ( String key , Object ... args ) { return new JC Diagnostic ( get Fragment Formatter ( ) , FRAGMENT , null , Enum Set . none Of ( Diagnostic Flag . class ) , null , null , STR_ + FRAGMENT . key + STR_ + key , args ) ; }
private static void remove Branches After Gotos ( Basic Block bb ) { Instruction first Goto = null ; Instruction end = bb . last Real Instruction ( ) ; for ( Enumeration < Instruction > branches = bb . enumerate Branch Instructions ( ) ; branches . has More Elements ( ) ; ) { Instruction s = branches . next Element ( ) ; if ( Goto . conforms ( s ) ) { first Goto = s ; break ; } } if ( first Goto != null ) { Enumeration < Instruction > ie = IR Enumeration . forward Intra Block IE ( first Goto , end ) ; ie . next Element ( ) ; while ( ie . has More Elements ( ) ) { Instruction s = ie . next Element ( ) ; if ( Guard Result Carrier . conforms ( s ) ) { insert True Guard ( s , Guard Result Carrier . get Guard Result ( s ) ) ; } s . remove ( ) ; } } }
public Save Load Manager ( String profile Name ) { this . profile Name = profile Name ; }
public AM Cert Store ( AMLDAP Cert Store Parameters param ) { store Param = param ; }
static short read Code Page ( Byte Buffer buffer , int offset , Jet Format format ) { int cp Offset = format . OFFSET COLUMN CODE PAGE ; return ( ( cp Offset >= NUM_ ) ? buffer . get Short ( offset + cp Offset ) : NUM_ ) ; }
public static Lazy Query Container create DS Lazy Query Container ( final Bean Query Factory < ? extends Abstract Bean Query < ? > > query Factory ) { query Factory . set Query Configuration ( Collections . empty Map ( ) ) ; return new Lazy Query Container ( new Lazy Query Definition ( true , NUM_ , STR_ ) , query Factory ) ; }
public final Byte Buffer encode ( Char Buffer in ) throws Character Coding Exception { int length = ( int ) ( in . remaining ( ) * average Bytes Per Char ) ; Byte Buffer out = Byte Buffer . allocate ( length ) ; reset ( ) ; while ( state != FLUSHED ) { Coder Result result = encode ( in , out , true ) ; if ( result == Coder Result . OVERFLOW ) { out = allocate More ( out ) ; continue ; } else { check Coder Result ( result ) ; } result = flush ( out ) ; if ( result == Coder Result . OVERFLOW ) { out = allocate More ( out ) ; } else { check Coder Result ( result ) ; } } out . flip ( ) ; return out ; }
public static boolean decode To File ( final String data To Decode , final String filename ) { boolean success = false ; Base 64 . Output Stream bos = null ; try { bos = new Base 64 . Output Stream ( new java . io . File Output Stream ( filename ) , Base 64 . DECODE ) ; bos . write ( data To Decode . get Bytes ( Base 64 . PREFERRED ENCODING ) ) ; success = true ; } catch ( java . io . IO Exception e ) { success = false ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } return success ; }
public int hash Code ( ) { if ( hash == NUM_ ) { hash = Arrays . hash Code ( from Key ) ; } return hash ; }
public void prune Exceptional Out ( ) { if ( has Reachable Exception Handlers ( ) ) { for ( Enumeration < Basic Block > e = get Basic Blocks ( ) ; e . has More Elements ( ) ; ) { Basic Block bb = e . next Element ( ) ; bb . prune Exceptional Out ( this ) ; } } }
final protected void start Query ( final I Chunk Message < I Binding Set > msg ) { if ( ! controller ) throw new Unsupported Operation Exception ( ERR NOT CONTROLLER ) ; if ( msg == null ) throw new Illegal Argument Exception ( ) ; if ( ! query Id . equals ( msg . get Query Id ( ) ) ) throw new Illegal Argument Exception ( ) ; lock . lock ( ) ; try { run State . start Query ( msg ) ; } catch ( Timeout Exception ex ) { halt ( ex ) ; } finally { lock . unlock ( ) ; } }
public Auth Configuration Model Impl ( Http Servlet Request req , Map map ) { super ( req , map ) ; current Realm = ( String ) map . get ( AM Admin Constants . CURRENT REALM ) ; }
public Hypergraph Sorter ( final int num Edges , final boolean compute Edges ) { this . num Edges = num Edges ; this . compute Edges = compute Edges ; final int m = num Edges == NUM_ ? NUM_ : ( int ) Math . ceil ( GAMMA * num Edges ) + NUM_ ; num Vertices = m + ( NUM_ - m % NUM_ ) % NUM_ ; part Size = num Vertices / NUM_ ; vertex 1 = new int [ num Vertices ] ; vertex 2 = new int [ num Vertices ] ; edge = compute Edges ? new int [ num Vertices ] : null ; stack = new int [ num Edges ] ; d = new int [ num Vertices ] ; visit Stack = new Int Array List ( INITIAL QUEUE SIZE ) ; never Used = true ; }
public Simple Cache ( String id , String file , long expire Time ) { this . id = id ; this . file = Paths . get ( file ) ; this . expire Time = expire Time ; }
private void add Property ( Property prop , int index , Map < String , Property > keys map , String key name ) throws Malformed Object Name Exception { if ( keys map . contains Key ( key name ) ) throw new Malformed Object Name Exception ( STR_ + key name + STR_ ) ; if ( index == kp array . length ) { Property [ ] tmp prop array = new Property [ index + NUM_ ] ; System . arraycopy ( kp array , NUM_ , tmp prop array , NUM_ , index ) ; kp array = tmp prop array ; } kp array [ index ] = prop ; keys map . put ( key name , prop ) ; }
@ Bean ( init Method = STR_ , destroy Method = STR_ ) @ Profile ( Constants . SPRING PROFILE DEVELOPMENT ) public Server h 2 TCP Server ( ) throws SQL Exception { return Server . create Tcp Server ( STR_ , STR_ ) ; }
private void create Entity ( SSO Token token , Persistent Object parent Obj , int object Type , Map attributes , String profile Name ) throws UMS Exception , AM Entry Exists Exception , AM Exception { String org DN = get Organization DN ( internal Token , parent Obj . get DN ( ) ) ; Attr Set attr Set = Common Utils . map To Attr Set ( attributes ) ; make Naming First ( attr Set , get Naming Attribute ( object Type ) , profile Name ) ; String ct Name = get Creation Template Name ( object Type ) ; if ( ct Name == null ) { ct Name = STR_ ; } Template Manager temp Mgr = Template Manager . get Template Manager ( ) ; Creation Template creation Temp = temp Mgr . get Creation Template ( ct Name , new Guid ( org DN ) , Template Manager . SCOPE ANCESTORS ) ; attr Set = combine O Cs ( creation Temp , attr Set ) ; Persistent Object user = new Persistent Object ( creation Temp , attr Set ) ; try { parent Obj . add Child ( user ) ; } catch ( Access Rights Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STR_ + STR_ , e ) ; } throw new AM Exception ( token , STR_ ) ; } catch ( Entry Already Exists Exception ee ) { if ( Compliance Services Impl . is Compliance User Deletion Enabled ( ) ) { compliance Impl . check If Deleted User ( token , user . get DN ( ) ) ; } if ( debug . warning Enabled ( ) ) { debug . warning ( STR_ + STR_ , ee ) ; } throw new AM Entry Exists Exception ( token , STR_ , ee ) ; } catch ( UMS Exception ue ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STR_ + STR_ , ue ) ; } process Internal Exception ( token , ue , STR_ ) ; } }
@ Caller Sensitive public static < U , W > Atomic Reference Field Updater < U , W > new Updater ( Class < U > tclass , Class < W > vclass , String field Name ) { return new Atomic Reference Field Updater Impl < U , W > ( tclass , vclass , field Name , Reflection . get Caller Class ( ) ) ; }
public void load Complete ( ) { if ( m loader Thread != null ) { if ( m loader Thread . is Alive ( ) ) { try { m loader Thread . join ( ) ; } catch ( Interrupted Exception ie ) { log . log ( Level . SEVERE , STR_ , ie ) ; } } } for ( int i = NUM_ ; i < m fields . size ( ) ; i ++ ) { Grid Field field = ( Grid Field ) m fields . get ( i ) ; field . lookup Load Complete ( ) ; } }
public String prep Operand ( String label , Data Type dt , Value Type vt ) { String Builder sb = new String Builder ( ) ; sb . append ( label ) ; sb . append ( Lop . DATATYPE PREFIX ) ; sb . append ( dt ) ; sb . append ( Lop . VALUETYPE PREFIX ) ; sb . append ( vt ) ; return sb . to String ( ) ; }
public void write IOR ( String ior File , org . omg . CORBA . Object ior Obj ) throws IO Exception { if ( ior File != null ) { ORB orb = init ORB ( null ) ; java . io . File Writer out File = new java . io . File Writer ( ior File ) ; java . io . Print Writer writer = new java . io . Print Writer ( out File ) ; String ior = orb . object to string ( ior Obj ) ; writer . println ( ior ) ; writer . close ( ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( orb . object to string ( ior Obj ) ) ; } } }
public static Buffered Writer new Writer ( Path self , boolean append ) throws IO Exception { if ( append ) { return Files . new Buffered Writer ( self , Charset . default Charset ( ) , CREATE , APPEND ) ; } return Files . new Buffered Writer ( self , Charset . default Charset ( ) ) ; }
public Image create Image ( int width , int height ) { Component Peer peer = this . peer ; if ( peer instanceof Lightweight Peer ) { if ( parent != null ) { return parent . create Image ( width , height ) ; } else { return null ; } } else { return ( peer != null ) ? peer . create Image ( width , height ) : null ; } }
private Cursor query Request Headers ( SQ Lite Database db , Uri uri ) { String where = Download Contract . Request Headers . COLUMN DOWNLOAD ID + STR_ + get Download Id From Uri ( uri ) ; String [ ] projection = new String [ ] { Download Contract . Request Headers . COLUMN HEADER , Download Contract . Request Headers . COLUMN VALUE } ; return db . query ( Download Contract . Request Headers . HEADERS DB TABLE , projection , where , null , null , null , null ) ; }
static void calculate ( ) { for ( byte level Byte : item Levels ) { short level = ( short ) ( level Byte & NUM_ ) ; if ( level < NUM_ ) { continue ; } int count Index = NUM_ ; for ( short count Byte : full Counts ) { short count = ( short ) ( count Byte & NUM_ ) ; int final Level = level ; if ( final Level % NUM_ == NUM_ ) { final Level -- ; } int point Level = ( int ) item Levels [ ( final Level / NUM_ ) ] ; int feed Points = Math . max ( NUM_ , point Level - NUM_ ) / NUM_ * NUM_ ; point Values [ final Level / NUM_ ] [ count Index ++ ] = get Points ( feed Points , count ) ; } } }
public static void register M Bean ( Connection Info connection Info , Database database ) throws JM Exception { String path = connection Info . get Name ( ) ; if ( ! MBEANS . contains Key ( path ) ) { M Bean Server mbean Server = Management Factory . get Platform M Bean Server ( ) ; String name = database . get Short Name ( ) ; Object Name mbean Object Name = get Object Name ( name , path ) ; MBEANS . put ( path , mbean Object Name ) ; Database Info info = new Database Info ( database ) ; Object mbean = new Documented M Bean ( info , Database Info M Bean . class ) ; mbean Server . register M Bean ( mbean , mbean Object Name ) ; } }
@ Override public void run ( ) { am I Active = true ; String pointer Header , loading Header , efficiency Header , absorption Header , output Header ; int row , col , x , y ; float progress = NUM_ ; double slope ; double z , z 2 ; int i , c ; double num In Neighbours ; boolean flag = false ; double flow Dir ; efficiency Multiplier = NUM_ ; if ( args . length <= NUM_ ) { show Feedback ( STR_ ) ; return ; } pointer Header = args [ NUM_ ] ; loading Header = args [ NUM_ ] ; efficiency Header = args [ NUM_ ] ; absorption Header = args [ NUM_ ] ; output Header = args [ NUM_ ] ; if ( pointer Header . is Empty ( ) || output Header . is Empty ( ) || loading Header . is Empty ( ) || efficiency Header . is Empty ( ) || absorption Header . is Empty ( ) ) { show Feedback ( STR_ ) ; return ; } try { pointer = new Whitebox Raster ( pointer Header , STR_ ) ; int rows = pointer . get Number Rows ( ) ; int cols = pointer . get Number Columns ( ) ; no Data = pointer . get No Data Value ( ) ; grid Res = pointer . get Cell Size X ( ) ; Whitebox Raster loading = new Whitebox Raster ( loading Header , STR_ ) ; if ( loading . get Number Rows ( ) != rows || loading . get Number Columns ( ) != cols ) { show Feedback ( STR_ ) ; return ; } double no Data Loading = loading . get No Data Value ( ) ; efficiency = new Whitebox Raster ( efficiency Header , STR_ ) ; if ( efficiency . get Number Rows ( ) != rows || efficiency . get Number Columns ( ) != cols ) { show Feedback ( STR_ ) ; return ; } double no Data Efficiency = efficiency . get No Data Value ( ) ; if ( efficiency . get Maximum Value ( ) > NUM_ ) { efficiency Multiplier = NUM_ ; } absorption = new Whitebox Raster ( absorption Header , STR_ ) ; if ( absorption . get Number Rows ( ) != rows || absorption . get Number Columns ( ) != cols ) { show Feedback ( STR_ ) ; return ; } double no Data Absorption = absorption . get No Data Value ( ) ; double output No Data = - NUM_ ; output = new Whitebox Raster ( output Header , STR_ , pointer Header , Whitebox Raster . Data Type . FLOAT , NUM_ ) ; output . set Preferred Palette ( STR_ ) ; output . set Data Scale ( Whitebox Raster . Data Scale . CONTINUOUS ) ; output . set Z Units ( STR_ ) ; tmp Grid = new Whitebox Raster ( output Header . replace ( STR_ , STR_ ) , STR_ , pointer Header , Whitebox Raster . Data Type . FLOAT , output No Data ) ; tmp Grid . is Temporary File = true ; update Progress ( STR_ , NUM_ ) ; for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { flow Dir = pointer . get Value ( row , col ) ; if ( flow Dir != no Data && loading . get Value ( row , col ) != no Data Loading && efficiency . get Value ( row , col ) != no Data Efficiency && absorption . get Value ( row , col ) != no Data Absorption ) { i = NUM_ ; for ( c = NUM_ ; c < NUM_ ; c ++ ) { x = col + d X [ c ] ; y = row + d Y [ c ] ; flow Dir = pointer . get Value ( y , x ) ; if ( flow Dir >= NUM_ && flow Dir <= NUM_ ) { if ( c != NUM_ ) { if ( flow Dir > start FD [ c ] && flow Dir < end FD [ c ] ) { i ++ ; } } else { if ( flow Dir > start FD [ c ] || flow Dir < end FD [ c ] ) { i ++ ; } } } } tmp Grid . set Value ( row , col , i ) ; output . set Value ( row , col , loading . get Value ( row , col ) ) ; } else { output . set Value ( row , col , output No Data ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * row / ( rows - NUM_ ) ) ; update Progress ( STR_ , ( int ) progress ) ; } loading . close ( ) ; update Progress ( STR_ , NUM_ ) ; for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { if ( tmp Grid . get Value ( row , col ) == NUM_ ) { Dinf Accum ( row , col ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * row / ( rows - NUM_ ) ) ; update Progress ( STR_ , ( int ) progress ) ; } output . add Metadata Entry ( STR_ + get Descriptive Name ( ) + STR_ ) ; output . add Metadata Entry ( STR_ + new Date ( ) ) ; pointer . close ( ) ; efficiency . close ( ) ; absorption . close ( ) ; tmp Grid . close ( ) ; output . close ( ) ; return Data ( output Header ) ; } catch ( Out Of Memory Error oe ) { my Host . show Feedback ( STR_ ) ; } catch ( Exception e ) { my Host . show Feedback ( STR_ ) ; my Host . log Exception ( STR_ + get Descriptive Name ( ) , e ) ; } finally { update Progress ( STR_ , NUM_ ) ; am I Active = false ; my Host . plugin Complete ( ) ; } }
public void register Url Change Listener ( Url Change Listener url Change Listener ) { if ( ! url Change Listeners . contains ( url Change Listener ) ) { url Change Listeners . add ( url Change Listener ) ; } }
public static CX Form With Alpha cx Form With Alpha ( double alpha Multiplier ) { CX Form With Alpha c = new CX Form With Alpha ( ) ; c . has Mult = true ; c . alpha Mult Term = fixed 8 ( alpha Multiplier ) ; return c ; }
public Container create Container ( Configuration configuration ) { return create Container ( get Test Data ( ) . container Type , configuration ) ; }
@ Override public void run ( ) { try { LOGGER . log ( Level . FINEST , STR_ , incoming Messages . size ( ) ) ; sweep ( ) ; } catch ( Throwable t ) { LOGGER . log ( Level . WARNING , STR_ , t ) ; } finally { try { schedule ( ) ; } catch ( Throwable t ) { LOGGER . log ( Level . WARNING , STR_ , t ) ; } } }
public static String construct Hash Redis Key ( String queue Name , String shard Name , long job Id ) { return String . format ( STR_ , construct Hash Redis Key Prefix ( queue Name , shard Name ) , job Id ) ; }
int compile If Static ( Ct Class type , String name , Bytecode code , Javac drv ) throws Cannot Compile Exception { String desc ; code . add New ( object Type ) ; code . add ( Bytecode . DUP ) ; int stacksize = NUM_ ; if ( string Params == null ) desc = STR_ ; else { desc = STR_ ; stacksize += compile String Parameter ( code ) ; } code . add Invokespecial ( object Type , STR_ , desc ) ; code . add Putstatic ( Bytecode . THIS , name , Descriptor . of ( type ) ) ; return stacksize ; }
private Coordinator Imp create CC ( Recovery Coordinator adaptor , String root , boolean check Orphans , boolean heuristic commit , long timeout ) { Coordinator Imp cc = null ; if ( max Timeout > NUM_ && timeout > max Timeout ) { timeout = max Timeout ; LOGGER . log Warning ( STR_ + max Timeout ) ; } synchronized ( shutdown Synchronizer ) { if ( shutdown In Progress ) throw new Illegal State Exception ( STR_ ) ; if ( ots Override ) { check Orphans = false ; } cc = new Coordinator Imp ( root , adaptor , heuristic commit , timeout , check Orphans , single threaded 2 pc ) ; recoverymanager . register ( cc ) ; synchronized ( get Latch ( root . intern ( ) ) ) { root To Coordinator Map . put ( root . intern ( ) , cc ) ; } startlistening ( cc ) ; } return cc ; }
public void schedule At Fixed Rate ( Timer Task task , Date when , long period ) { if ( period <= NUM_ || when . get Time ( ) < NUM_ ) { throw new Illegal Argument Exception ( ) ; } long delay = when . get Time ( ) - System . current Time Millis ( ) ; schedule Impl ( task , delay , period , true ) ; }
public boolean add Callback ( Uri uri , Item Loaded Callback callback ) { if ( Log . is Loggable ( TAG , Log . DEBUG ) ) { Log . d ( TAG , STR_ + callback ) ; } if ( uri == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( callback == null ) { throw new Null Pointer Exception ( STR_ ) ; } Set < Item Loaded Callback > callbacks = m Callbacks . get ( uri ) ; if ( callbacks == null ) { callbacks = new Hash Set < Item Loaded Callback > ( NUM_ ) ; m Callbacks . put ( uri , callbacks ) ; } callbacks . add ( callback ) ; return true ; }
protected Object read Object Override ( ) throws Optional Data Exception , Class Not Found Exception , IO Exception { if ( input == null ) { return null ; } throw new IO Exception ( ) ; }
public String generate Key ( ) throws Exception { return Random String Utils . random ( KEY LENGTH , NUM_ , chars For Key . length - NUM_ , true , true , chars For Key , Secure Random . get Instance ( Security Util . get Secured Random Algorithm ( ) ) ) ; }
static String encode Entities ( String source ) { String Buffer buffer = new String Buffer ( ) ; String encoded ; for ( int index = NUM_ ; index < source . length ( ) ; index ++ ) { char ch = source . char At ( index ) ; if ( ( encoded = encode Entity ( ch ) ) != null ) { buffer . append ( encoded ) ; } else { buffer . append ( ch ) ; } } return buffer . to String ( ) ; }
public Console Out Stream ( final Log Controller log Controller ) { super ( ) ; this . log Controller = log Controller ; try { final File f = new File ( System . get Property ( STR_ ) , log Name ) ; if ( ! f . exists ( ) ) { f . create New File ( ) ; } filestream = new Print Stream ( new File Output Stream ( f , true ) ) ; } catch ( final IO Exception e ) { Console Print Stream . print Exception ( e ) ; } }
protected void check ( ) { double tsum ; int i , j ; double s = NUM_ ; for ( i = NUM_ ; i < examples total ; i ++ ) { tsum = NUM_ ; s += alphas [ i ] ; for ( j = NUM_ ; j < examples . count examples ( ) ; j ++ ) { tsum += alphas [ j ] * kernel . calculate K ( i , j ) ; } ; if ( Math . abs ( tsum - sum [ i ] ) > is zero ) { logln ( NUM_ , STR_ + i + STR_ + ( tsum - sum [ i ] ) + STR_ + sum [ i ] + STR_ + tsum ) ; } ; } ; tsum = NUM_ ; for ( j = NUM_ ; j < examples . count examples ( ) ; j ++ ) { tsum += alphas [ j ] ; } ; if ( Math . abs ( tsum - NUM_ ) > is zero ) { logln ( NUM_ , STR_ + ( tsum - NUM_ ) ) ; } if ( Math . abs ( s + sum alpha - NUM_ ) > is zero ) { logln ( NUM_ , STR_ + ( s + sum alpha - NUM_ ) ) ; } ; }
public void lighter Color ( int factor ) { int color = get Color ( ) ; int r = color > > NUM_ & NUM_ ; int g = color > > NUM_ & NUM_ ; int b = color & NUM_ ; r = Math . min ( NUM_ , r + factor ) ; g = Math . min ( NUM_ , g + factor ) ; b = Math . min ( NUM_ , b + factor ) ; set Color ( ( ( r << NUM_ ) & NUM_ ) | ( ( g << NUM_ ) & NUM_ ) | ( b & NUM_ ) ) ; }
public static List < User Record > deaggregate ( List < Kinesis Event Record > input Records ) { List < User Record > output Records = new Linked List < > ( ) ; for ( Kinesis Event Record input Record : input Records ) { output Records . add All ( deaggregate ( input Record ) ) ; } return output Records ; }
public static String encode Path For URL ( String str ) { String Buffer result = new String Buffer ( ) ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { char ch = str . char At ( i ) ; if ( ch >= STR_ && ch <= STR_ || ch >= STR_ && ch <= STR_ || ch >= STR_ && ch <= STR_ ) result . append ( ch ) ; else { switch ( ch ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : result . append ( ch ) ; break ; default : result . append ( STR_ ) ; result . append ( hexchars [ ( ch & NUM_ ) > > NUM_ ] ) ; result . append ( hexchars [ ch & NUM_ ] ) ; break ; } } } return result . to String ( ) ; }
public static Thread new Managed Thread ( Runnable r ) { return FACTORY . new Thread ( r ) ; }
private void add Statement Input Patches ( boolean is Shadow , int i , int x From , int x To Above , int x To Below , Input View input View , View Point input Layout Origin ) { int x Offset = x From + input View . get Field Layout Width ( ) ; m Helper . set Point Maybe Flip ( m Input Connector Offsets . get ( i ) , x Offset + m Patch Manager . m Statement Input Padding , input Layout Origin . y + m Patch Manager . m Statement Top Thickness ) ; final Nine Patch Drawable statement Top Drawable = get Colored Patch Drawable ( is Shadow ? R . drawable . statementinput top shadow : R . drawable . statementinput top ) ; final Nine Patch Drawable statement Top Border Drawable = m Patch Manager . get Patch Drawable ( R . drawable . statementinput top border ) ; final Nine Patch Drawable statement Connection Highlight = m Patch Manager . get Patch Drawable ( R . drawable . statementinput top connection ) ; m Helper . set Rtl Aware Bounds ( temp Rect , m Block View Size . x , x Offset , input Layout Origin . y , x To Above , input Layout Origin . y + statement Top Drawable . get Intrinsic Height ( ) ) ; statement Top Drawable . set Bounds ( temp Rect ) ; statement Top Border Drawable . set Bounds ( temp Rect ) ; statement Connection Highlight . set Bounds ( temp Rect ) ; m Block Patches . add ( statement Top Drawable ) ; m Block Border Patches . add ( statement Top Border Drawable ) ; m Input Connection Highlight Patches . set ( i , statement Connection Highlight ) ; final Nine Patch Drawable statement Bottom Drawable = get Colored Patch Drawable ( is Shadow ? R . drawable . statementinput bottom shadow : R . drawable . statementinput bottom ) ; final Nine Patch Drawable statement Bottom Border Drawable = m Patch Manager . get Patch Drawable ( R . drawable . statementinput bottom border ) ; final int connector Height = Math . max ( input View . get Total Child Height ( ) , input View . get Measured Height ( ) ) ; m Helper . set Rtl Aware Bounds ( temp Rect , m Block View Size . x , x Offset , input Layout Origin . y + statement Top Drawable . get Intrinsic Height ( ) , x To Below , input Layout Origin . y + connector Height ) ; statement Bottom Drawable . set Bounds ( temp Rect ) ; statement Bottom Border Drawable . set Bounds ( temp Rect ) ; m Block Patches . add ( statement Bottom Drawable ) ; m Block Border Patches . add ( statement Bottom Border Drawable ) ; }
public void remove On Scroll Listener ( On Scroll Listener listener ) { m On Scroll Listeners . remove ( listener ) ; }
public Mp 4 Box Header ( String id ) { if ( id . length ( ) != IDENTIFIER LENGTH ) { throw new Runtime Exception ( STR_ ) ; } data Buffer = Byte Buffer . allocate ( HEADER LENGTH ) ; try { this . id = id ; data Buffer . put ( NUM_ , id . get Bytes ( STR_ ) [ NUM_ ] ) ; data Buffer . put ( NUM_ , id . get Bytes ( STR_ ) [ NUM_ ] ) ; data Buffer . put ( NUM_ , id . get Bytes ( STR_ ) [ NUM_ ] ) ; data Buffer . put ( NUM_ , id . get Bytes ( STR_ ) [ NUM_ ] ) ; } catch ( Unsupported Encoding Exception uee ) { throw new Runtime Exception ( uee ) ; } }
public Line 3 D ( Stack < Vector 3 > points , float thickness , int [ ] colors , boolean create VB Os ) { super ( ) ; m Points = points ; m Line Thickness = thickness ; m Colors = colors ; if ( colors != null && colors . length != points . size ( ) ) throw new Runtime Exception ( STR_ ) ; init ( create VB Os ) ; }
public final byte [ ] compute Hash ( byte [ ] data ) { byte [ ] ret = null ; hash Lock . lock ( ) ; ret = md . digest ( data ) ; hash Lock . unlock ( ) ; return ret ; }
public void dispose ( ) { synchronized ( this . lock ) { if ( page != null ) { page . dispose ( ) ; } preview Frame . dispose ( ) ; if ( job != null ) { job . end ( ) ; } } }
public void record Controller Estimate Cost Do Nothing ( RVM Method method , int opt Level , double cost ) { if ( Controller . options . LOGGING LEVEL >= NUM_ ) { synchronized ( log ) { log . print ( get Time ( ) + STR_ ) ; if ( opt Level == - NUM_ ) { log . print ( STR_ ) ; } else { log . print ( STR_ + opt Level ) ; } log . println ( STR_ + method + STR_ + cost ) ; } } }
public void projection Changed ( Projection Event e ) { Projection new Proj = e . get Projection ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( new Proj != null ? new Proj . to String ( ) : STR_ ) ; } if ( new Proj != null && ( projection == null || ( ! projection . equals ( new Proj ) ) ) ) { set Projection ( ( Projection ) new Proj . make Clone ( ) ) ; Object source = e . get Source ( ) ; if ( source instanceof Component ) { proj Component = ( Component ) source ; } } }
private Object read ( String [ ] list , int length ) throws Exception { Object array = Array . new Instance ( entry , length ) ; for ( int i = NUM_ ; i < length ; i ++ ) { Object item = delegate . read ( list [ i ] ) ; if ( item != null ) { Array . set ( array , i , item ) ; } } return array ; }
@ Override protected void validate Auto Tier Policy ( String auto Tier Policy Id , Un Managed Volume un Managed Volume , Virtual Pool v Pool ) { return ; }
public void request Cursor ( java . awt . Cursor cursor ) { if ( cursor == null ) { if ( show Wait Cursor && ! waiting For Layers ) reset Cursor ( ) ; current Map Bean Cursor = null ; } else if ( this . map != null ) { Cursor new Cursor ; if ( show Wait Cursor && waiting For Layers ) { new Cursor = Cursor . get Predefined Cursor ( Cursor . WAIT CURSOR ) ; current Map Bean Cursor = cursor ; } else new Cursor = cursor ; map . set Cursor ( new Cursor ) ; } }
public void define To File ( String key , File value ) { define ( key , value . get Absolute Path ( ) ) ; }
public static int find Infraction Count ( Entity Manager em , Principal User user , Sub System sub System , long start Time ) { List < Suspension Record > records ; if ( sub System == null ) { records = find By User ( em , user ) ; } else { Suspension Record record = find By User And Subsystem ( em , user , sub System ) ; records = record == null ? new Array List < Suspension Record > ( NUM_ ) : Arrays . as List ( new Suspension Record [ ] { record } ) ; } int count = NUM_ ; for ( Suspension Record record : records ) { List < Long > timestamps = record . get Infraction History ( ) ; for ( Long timestamp : timestamps ) { if ( timestamp > start Time ) { count ++ ; } } } return count ; }
public void add Timeout Listener ( Action Listener listener ) { comm Timer . add Action Listener ( listener ) ; }
default < T > T method Writer ( Class < T > t Class , Class ... additional ) { Class [ ] interfaces = Object Utils . add All ( t Class , additional ) ; return ( T ) Proxy . new Proxy Instance ( t Class . get Class Loader ( ) , interfaces , new Method Writer Invocation Handler ( this ) ) ; }
public void reduce ( Text key , Iterator < Link Node > values , Output Collector < Text , Link Nodes > output , Reporter reporter ) throws IO Exception { List < Link Node > node List = new Array List < Link Node > ( ) ; int num Nodes = NUM_ ; while ( values . has Next ( ) ) { Link Node cur = values . next ( ) ; if ( num Nodes < max Inlinks ) { node List . add ( ( Link Node ) Writable Utils . clone ( cur , conf ) ) ; num Nodes ++ ; } else { break ; } } Link Node [ ] link Nodes Ar = node List . to Array ( new Link Node [ node List . size ( ) ] ) ; Link Nodes link Nodes = new Link Nodes ( link Nodes Ar ) ; output . collect ( key , link Nodes ) ; }
public static void extract Dimensions And Measures From Expression ( List < Custom Aggregate Expression > expressions , List < Carbon Dimension > dims , List < Carbon Measure > msrs ) { for ( Custom Aggregate Expression expression : expressions ) { List < Carbon Column > dims From Expr = expression . get Referred Columns ( ) ; for ( Carbon Column dim From Expr : dims From Expr ) { if ( ! dim From Expr . is Dimesion ( ) ) { msrs . add ( ( Carbon Measure ) dim From Expr ) ; } else { dims . add ( ( Carbon Dimension ) dim From Expr ) ; } } } }
public void update Yaw And Pitch ( ) { long time Now = System . current Time Millis ( ) ; long delta Time = time Now - this . last Angular Update Time ; this . last Angular Update Time = time Now ; double overclock Scale = NUM_ / ( double ) Time Helper . server Tick Length ; double delta Yaw = this . yaw Scale * overclock Scale * this . max Angular Velocity Degrees Per Second * ( delta Time / NUM_ ) ; double delta Pitch = this . pitch Scale * overclock Scale * this . max Angular Velocity Degrees Per Second * ( delta Time / NUM_ ) ; m Yaw += delta Yaw ; m Camera Pitch += delta Pitch ; m Camera Pitch = ( m Camera Pitch < - NUM_ ) ? - NUM_ : ( m Camera Pitch > NUM_ ? NUM_ : m Camera Pitch ) ; }
protected void append Big Decimal Numeric Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
private static float alpha Blending Component ( int foreground Component , float foreground Alpha , int background Component , float background Alpha ) { float alpha = foreground Alpha + background Alpha * ( NUM_ - foreground Alpha ) ; if ( Math . abs ( alpha ) < NUM_ ) { return NUM_ ; } return ( foreground Alpha * foreground Component + background Alpha * background Component * ( NUM_ - foreground Alpha ) ) / ( NUM_ * alpha ) ; }
static byte [ ] decrypt Data ( byte [ ] password , byte [ ] encrypted Data ) { try { Cipher c = Cipher . get Instance ( ENCRYPT DATA ALGORITHM ) ; c . init ( Cipher . DECRYPT MODE , new Secret Key Spec ( password , SECRET KEY ALGORITHM ) , CBC SALT DATA ) ; return c . do Final ( encrypted Data ) ; } catch ( Exception e ) { throw new Illegal State Exception ( ENCRYPT DATA ALGORITHM + STR_ , e ) ; } }
private Name serialized Lambda Name ( ) { String Builder buf = new String Builder ( ) ; buf . append ( names . lambda ) ; buf . append ( enclosing Method Name ( ) ) ; buf . append ( STR_ ) ; String disam = serialized Lambda Disambiguation ( ) ; buf . append ( Integer . to Hex String ( disam . hash Code ( ) ) ) ; buf . append ( STR_ ) ; buf . append ( synthetic Method Name Counts . get Index ( buf ) ) ; String result = buf . to String ( ) ; return names . from String ( result ) ; }
private int handle Data Message ( String last Rx Msg ) { int result = NUM_ ; switch ( service ) { case OBD SVC NONE : break ; case OBD SVC CAN MONITOR : result = can Prot . handle Telegram ( last Rx Msg . to Char Array ( ) ) ; break ; default : result = super . handle Telegram ( last Rx Msg . to Char Array ( ) ) ; } return result ; }
private String create Choice Xml ( String choice Id , String choice Description , String next Moment Id , boolean deplete Weapon Charge , boolean increment Num Enemies Defeated , String icon Resource Name ) { String xml = STR_ ; xml += STR_ ; xml += STR_ + choice Id + STR_ ; xml += STR_ + choice Description + STR_ ; xml += create Next Moment Xml ( next Moment Id ) ; xml += STR_ ; xml += STR_ + Boolean . to String ( deplete Weapon Charge ) + STR_ ; xml += STR_ + Boolean . to String ( increment Num Enemies Defeated ) + STR_ ; if ( icon Resource Name != null ) { xml += create Icon XML ( icon Resource Name ) ; } xml += STR_ ; return xml ; }
int find Sync Position ( ) { int count = m Item Count ; if ( count == NUM_ ) { return INVALID POSITION ; } long id To Match = m Sync Row Id ; int seed = m Sync Position ; if ( id To Match == INVALID ROW ID ) { return INVALID POSITION ; } seed = Math . max ( NUM_ , seed ) ; seed = Math . min ( count - NUM_ , seed ) ; long end Time = System Clock . uptime Millis ( ) + SYNC MAX DURATION MILLIS ; long row Id ; int first = seed ; int last = seed ; boolean next = false ; boolean hit First ; boolean hit Last ; T adapter = get Adapter ( ) ; if ( adapter == null ) { return INVALID POSITION ; } while ( System Clock . uptime Millis ( ) <= end Time ) { row Id = adapter . get Item Id ( seed ) ; if ( row Id == id To Match ) { return seed ; } hit Last = last == count - NUM_ ; hit First = first == NUM_ ; if ( hit Last && hit First ) { break ; } if ( hit First || ( next && ! hit Last ) ) { last ++ ; seed = last ; next = false ; } else if ( hit Last || ( ! next && ! hit First ) ) { first -- ; seed = first ; next = true ; } } return INVALID POSITION ; }
protected double calculate Series Width ( double space , Category Axis axis , int categories , int series ) { double factor = NUM_ - get Item Margin ( ) - axis . get Lower Margin ( ) - axis . get Upper Margin ( ) ; if ( categories > NUM_ ) { factor = factor - axis . get Category Margin ( ) ; } return ( space * factor ) / ( categories * series ) ; }
public static int modifier Flags ( boolean alt P , boolean ctrl P , boolean meta P , boolean shift P ) { int flags = NUM_ ; if ( alt P ) flags |= F ALT DOWN ; if ( ctrl P ) flags |= F CTRL DOWN ; if ( meta P ) flags |= F META DOWN ; if ( shift P ) flags |= F SHIFT DOWN ; return flags ; }
private double min Ignore Na N ( double a , double b ) { if ( Double . is Na N ( a ) ) { return b ; } if ( Double . is Na N ( b ) ) { return a ; } return Math . min ( a , b ) ; }
public static String make Descriptor ( String params , Class ret Type ) { String Buffer sbuf = new String Buffer ( params ) ; make Desc ( sbuf , ret Type ) ; return sbuf . to String ( ) ; }
@ Override public Instances define Data Format ( ) throws Exception { int i ; int j ; Array List < Attribute > atts ; Array List < String > cls Values ; Random rand ; m Random = new Random ( get Seed ( ) ) ; rand = get Random ( ) ; set Num Examples Act ( get Num Examples ( ) ) ; m centroids = new double [ get Num Centroids ( ) ] [ get Num Attributes ( ) ] ; m centroid Classes = new int [ get Num Centroids ( ) ] ; m centroid Weights = new double [ get Num Centroids ( ) ] ; m centroid Std Devs = new double [ get Num Centroids ( ) ] ; for ( i = NUM_ ; i < get Num Centroids ( ) ; i ++ ) { for ( j = NUM_ ; j < get Num Attributes ( ) ; j ++ ) { m centroids [ i ] [ j ] = rand . next Double ( ) ; } m centroid Classes [ i ] = rand . next Int ( get Num Classes ( ) ) ; m centroid Weights [ i ] = rand . next Double ( ) ; m centroid Std Devs [ i ] = rand . next Double ( ) ; } atts = new Array List < Attribute > ( ) ; for ( i = NUM_ ; i < get Num Attributes ( ) ; i ++ ) { atts . add ( new Attribute ( STR_ + i ) ) ; } cls Values = new Array List < String > ( ) ; for ( i = NUM_ ; i < get Num Classes ( ) ; i ++ ) { cls Values . add ( STR_ + i ) ; } atts . add ( new Attribute ( STR_ , cls Values ) ) ; m Dataset Format = new Instances ( get Relation Name To Use ( ) , atts , NUM_ ) ; return m Dataset Format ; }
public boolean should Reverse ( String token ) { int pos Q = token . index Of ( STR_ ) ; int pos A = token . index Of ( STR_ ) ; if ( pos Q == - NUM_ && pos A == - NUM_ ) { return false ; } int pos ; int last Pos ; int len = token . length ( ) ; last Pos = token . last Index Of ( STR_ ) ; pos = token . last Index Of ( STR_ ) ; if ( pos > last Pos ) last Pos = pos ; if ( pos Q != - NUM_ ) { pos = pos Q ; if ( pos A != - NUM_ ) { pos = Math . min ( pos Q , pos A ) ; } } else { pos = pos A ; } if ( len - last Pos < min Trailing ) { return false ; } if ( pos Q != - NUM_ && pos Q < max Pos Question ) { return true ; } if ( pos A != - NUM_ && pos A < max Pos Asterisk ) { return true ; } if ( max Fraction Asterisk > NUM_ && pos < ( float ) token . length ( ) * max Fraction Asterisk ) { return true ; } return false ; }
private static < T > void insert Into Sorted List ( List < T > list , Comparator < T > comparator , T new Item ) { int index ; for ( index = NUM_ ; index < list . size ( ) ; index ++ ) { if ( comparator . compare ( list . get ( index ) , new Item ) > NUM_ ) break ; } list . add ( index , new Item ) ; }
public static Color shift Color Space To FX ( final int raw ) { final int r = ( ( raw > > NUM_ ) & NUM_ ) ; final int g = ( ( raw > > NUM_ ) & NUM_ ) ; final int b = ( ( raw ) & NUM_ ) ; return Color . rgb ( r , g , b ) ; }
private void extend ( ) throws IO Exception { while ( true ) { long now Ms Since Epoch = now ( ) ; List < String > assume Expired = new Array List < > ( ) ; List < String > to Be Extended = new Array List < > ( ) ; List < String > to Be Expired = new Array List < > ( ) ; for ( Map . Entry < String , In Flight State > entry : in Flight . entry Set ( ) ) { if ( entry . get Value ( ) . ack Deadline Ms Since Epoch - ( ack Timeout Ms * ACK SAFETY PCT ) / NUM_ > now Ms Since Epoch ) { break ; } if ( entry . get Value ( ) . ack Deadline Ms Since Epoch - ACK TOO LATE . get Millis ( ) < now Ms Since Epoch ) { assume Expired . add ( entry . get Key ( ) ) ; continue ; } if ( entry . get Value ( ) . request Time Ms Since Epoch + PROCESSING TIMEOUT . get Millis ( ) < now Ms Since Epoch ) { to Be Expired . add ( entry . get Key ( ) ) ; continue ; } to Be Extended . add ( entry . get Key ( ) ) ; if ( to Be Extended . size ( ) >= ACK BATCH SIZE ) { break ; } } if ( assume Expired . is Empty ( ) && to Be Extended . is Empty ( ) && to Be Expired . is Empty ( ) ) { return ; } if ( ! assume Expired . is Empty ( ) ) { num Late Deadlines . add ( now Ms Since Epoch , assume Expired . size ( ) ) ; for ( String ack Id : assume Expired ) { in Flight . remove ( ack Id ) ; } } if ( ! to Be Expired . is Empty ( ) ) { num Expired . add ( now Ms Since Epoch , to Be Expired . size ( ) ) ; for ( String ack Id : to Be Expired ) { in Flight . remove ( ack Id ) ; } } if ( ! to Be Extended . is Empty ( ) ) { long new Deadline Ms Since Epoch = now Ms Since Epoch + ( ack Timeout Ms * ACK EXTENSION PCT ) / NUM_ ; for ( String ack Id : to Be Extended ) { In Flight State state = in Flight . remove ( ack Id ) ; in Flight . put ( ack Id , new In Flight State ( state . request Time Ms Since Epoch , new Deadline Ms Since Epoch ) ) ; } extend Batch ( now Ms Since Epoch , to Be Extended ) ; } } }
protected Jvm Compilation Meta create Jvm Compilation Meta Node ( String group Name , String group Oid , Object Name group Objname , M Bean Server server ) { if ( Management Factory . get Compilation MX Bean ( ) == null ) return null ; return super . create Jvm Compilation Meta Node ( group Name , group Oid , group Objname , server ) ; }
public void expand To Integer Limits ( ) { clip [ NUM_ ] = Math . floor ( clip [ NUM_ ] ) ; clip [ NUM_ ] = Math . floor ( clip [ NUM_ ] ) ; clip [ NUM_ ] = Math . ceil ( clip [ NUM_ ] ) ; clip [ NUM_ ] = Math . ceil ( clip [ NUM_ ] ) ; }
private Workflow . Method create Forget Volumes Method ( URI vplex System URI , List < Volume Info > volume Info ) { return new Workflow . Method ( FORGET VOLUMES METHOD NAME , vplex System URI , volume Info ) ; }
public void prep Read Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ , only Changes ) ; } just Changes = only Changes ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } enable Buttons ( false ) ; if ( just Changes == true ) { read Changes Button . set Enabled ( true ) ; read Changes Button . set Selected ( true ) ; } else { read All Button . set Selected ( true ) ; read All Button . set Enabled ( true ) ; } if ( container . is Busy ( ) == false ) { container . enable Buttons ( false ) ; } set To Read ( just Changes , true ) ; var List Index = NUM_ ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM_ ; }
protected void update Base Matrix ( Drawable d ) { Image View image View = get Image View ( ) ; if ( null == image View || null == d ) { return ; } final float view Width = get Image View Width ( image View ) ; final float view Height = get Image View Height ( image View ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; m Base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( m Scale Type == Scale Type . CENTER ) { m Base Matrix . post Translate ( ( view Width - drawable Width ) / NUM_ , ( view Height - drawable Height ) / NUM_ ) ; } else if ( m Scale Type == Scale Type . CENTER CROP ) { float scale = Math . max ( width Scale , height Scale ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM_ , ( view Height - drawable Height * scale ) / NUM_ ) ; } else if ( m Scale Type == Scale Type . CENTER INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( width Scale , height Scale ) ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM_ , ( view Height - drawable Height * scale ) / NUM_ ) ; } else { Rect F m Temp Src = new Rect F ( NUM_ , NUM_ , drawable Width , drawable Height ) ; Rect F m Temp Dst = new Rect F ( NUM_ , NUM_ , view Width , view Height ) ; if ( ( int ) m Base Rotation % NUM_ != NUM_ ) { m Temp Src = new Rect F ( NUM_ , NUM_ , drawable Height , drawable Width ) ; } switch ( m Scale Type ) { case FIT CENTER : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . CENTER ) ; break ; case FIT START : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . START ) ; break ; case FIT END : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . END ) ; break ; case FIT XY : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }
private String print D Format ( long x ) { return print D Format ( Long . to String ( x ) ) ; }
static public Panel Menu instance ( ) { if ( this Menu == null ) { this Menu = new Panel Menu ( ) ; } return this Menu ; }
public static double read Double ( final JSON Array json Array , final int index , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Array . get Double ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT ARRAY , index ) ) ; } double value = NUM_ ; if ( ! json Array . is Null ( index ) ) { value = json Array . get Double ( index ) ; } return value ; }
public static < T extends Sabres Object > void print Schema ( Class < T > clazz ) { Schema . print Schema ( clazz . get Simple Name ( ) ) ; }
public Forum Post Config fetch ( Forum Post Config config ) { config . add Credentials ( this ) ; String xml = POST ( this . url + STR_ , config . to XML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { Forum Post Config post = new Forum Post Config ( ) ; post . parse XML ( root ) ; return post ; } catch ( Exception exception ) { this . exception = SDK Exception . parse Failure ( exception ) ; throw this . exception ; } }
void start Source File For Generated Implementation ( String name Of Generated Class , Type Element source Class ) { messager . print Message ( Kind . NOTE , STR_ + name Of Generated Class ) ; file Object = get Source File ( name Of Generated Class , source Class ) ; if ( file Object == null ) { give Up ( ) ; return ; } writer = get Writer ( file Object ) ; if ( writer == null ) { give Up ( ) ; return ; } current Indentation Level = NUM_ ; }
public boolean ensure Valid ( Object value ) { int count = - NUM_ ; try { Collection < ? > collection = ( Collection < ? > ) value ; count = collection . size ( ) ; } catch ( Exception e ) { try { count = Array . get Length ( value ) ; } catch ( Illegal Argument Exception e 2 ) { } } return ensure Valid ( count ) ; }
protected Shape create Outer Focus ( final Segment Type segment Type , final int x , final int y , final int w , final int h ) { switch ( segment Type ) { case FIRST : return shape Generator . create Round Rectangle ( x - NUM_ , y - NUM_ , w + NUM_ , h + NUM_ , Corner Size . OUTER FOCUS , Corner Style . ROUNDED , Corner Style . ROUNDED , Corner Style . SQUARE , Corner Style . SQUARE ) ; case MIDDLE : return shape Generator . create Rectangle ( x - NUM_ , y - NUM_ , w + NUM_ , h + NUM_ ) ; case LAST : return shape Generator . create Round Rectangle ( x - NUM_ , y - NUM_ , w + NUM_ , h + NUM_ , Corner Size . OUTER FOCUS , Corner Style . SQUARE , Corner Style . SQUARE , Corner Style . ROUNDED , Corner Style . ROUNDED ) ; default : return shape Generator . create Round Rectangle ( x - NUM_ , y - NUM_ , w + NUM_ , h + NUM_ , Corner Size . OUTER FOCUS ) ; } }
public Remover Manager track ( Remover remover ) { if ( handlers == null ) { handlers = new Array List < > ( ) ; } handlers . add ( remover ) ; return this ; }
protected boolean add Header Int ( char [ ] key Buf , int key Off , int key Len , Char Segment value ) { if ( key Len < NUM_ ) { return true ; } int key 1 = key Buf [ key Off ] | NUM_ | ( key Len << NUM_ ) ; switch ( key 1 ) { case CONNECTION KEY : if ( match ( key Buf , key Off , key Len , CONNECTION ) ) { char [ ] value Buffer = value . buffer ( ) ; int value Offset = value . offset ( ) ; int value Length = value . length ( ) ; int end = value Offset + value Length ; boolean is Keepalive = false ; while ( value Offset < end ) { char ch = Character . to Lower Case ( value Buffer [ value Offset ] ) ; if ( ch == STR_ && match ( value Buffer , value Offset , KEEPALIVE . length , KEEPALIVE ) ) { is Keepalive = true ; value Offset += KEEPALIVE . length ; } else if ( ch == STR_ && match ( value Buffer , value Offset , UPGRADE . length , UPGRADE ) ) { is Upgrade = true ; value Offset += UPGRADE . length ; } while ( value Offset < end && value Buffer [ value Offset ++ ] != STR_ ) { } if ( value Buffer [ value Offset ] == STR_ ) { value Offset ++ ; } } is Keepalive = is Keepalive ; return true ; } case COOKIE KEY : if ( match ( key Buf , key Off , key Len , COOKIE ) ) { fill Cookie ( cookies , value ) ; } return true ; case CONTENT LENGTH KEY : if ( match ( key Buf , key Off , key Len , CONTENT LENGTH ) ) { content Length In ( value ) ; } return true ; case EXPECT KEY : if ( match ( key Buf , key Off , key Len , EXPECT ) ) { if ( match ( value . buffer ( ) , value . offset ( ) , value . length ( ) , CONTINUE 100 ) ) { expect 100 Continue = true ; return false ; } } return true ; case HOST KEY : if ( match ( key Buf , key Off , key Len , HOST ) ) { host Header = value ; } return true ; case TRANSFER ENCODING KEY : if ( match ( key Buf , key Off , key Len , TRANSFER ENCODING ) ) { is Chunked In = true ; } return true ; case X FORWARDED HOST KEY : if ( match ( key Buf , key Off , key Len , X FORWARDED HOST ) ) { x Forwarded Host Header = value ; } return true ; default : return true ; } }
private static void release Latch ( final Count Down Latch latch ) { if ( latch == null ) { return ; } while ( latch . get Count ( ) > NUM_ ) { latch . count Down ( ) ; } }
public static void move File ( File orig Path , File dest Path ) throws IO Exception { copy File ( orig Path , dest Path ) ; if ( ! orig Path . delete ( ) ) throw new IO Exception ( STR_ + orig Path . get Name ( ) ) ; }
public static Buffered Image generate Random Image ( int num Of Pixels ) throws Open Stego Exception { final double ASPECT RATIO = NUM_ / NUM_ ; int width = NUM_ ; int height = NUM_ ; byte [ ] rgb Value = new byte [ NUM_ ] ; Buffered Image image = null ; Secure Random random = null ; try { random = Secure Random . get Instance ( STR_ ) ; width = ( int ) Math . ceil ( Math . sqrt ( num Of Pixels * ASPECT RATIO ) ) ; height = ( int ) Math . ceil ( num Of Pixels / ( double ) width ) ; image = new Buffered Image ( width , height , Buffered Image . TYPE INT RGB ) ; for ( int x = NUM_ ; x < width ; x ++ ) { for ( int y = NUM_ ; y < height ; y ++ ) { random . next Bytes ( rgb Value ) ; image . set RGB ( x , y , Common Util . byte To Int ( rgb Value [ NUM_ ] ) + ( Common Util . byte To Int ( rgb Value [ NUM_ ] ) << NUM_ ) + ( Common Util . byte To Int ( rgb Value [ NUM_ ] ) << NUM_ ) ) ; } } return image ; } catch ( No Such Algorithm Exception nsa Ex ) { throw new Open Stego Exception ( nsa Ex ) ; } }
public Serializer disable Whitelist ( ) { whitelist Required . set ( false ) ; return this ; }
private static int uarimin Le ( double value , double [ ] bv , int [ ] bvi , Binary Operator b Op ) throws DML Runtime Exception { int ix Min = NUM_ ; if ( value < bv [ NUM_ ] || value > bv [ bv . length - NUM_ ] ) return ix Min ; int ix = Arrays . binary Search ( bv , value ) ; if ( ix < NUM_ ) ix = Math . abs ( ix ) - NUM_ ; ix Min = bvi [ ix ] + NUM_ ; return ix Min ; }
public Class load ( String type ) throws Exception { Class Loader loader = get Class Loader ( ) ; if ( loader == null ) { loader = get Caller Class Loader ( ) ; } return loader . load Class ( type ) ; }
@ Log Message Doc ( level = STR_ , message = STR_ , explanation = STR_ + STR_ , recommendation = Log Message Doc . REPORT CONTROLLER BUG ) public void queue Hint ( String store Name , Byte Array key , Versioned < byte [ ] > value ) { try { Hint Key hk = new Hint Key ( store Name , key ) ; hint Lock . lock ( ) ; try { boolean needed = ! hints . contains Key ( hk ) ; needed &= hints . doput ( hk , value ) ; if ( needed ) { hint Queue . add ( hk ) ; hints Available . signal ( ) ; } } finally { hint Lock . unlock ( ) ; } } catch ( Sync Exception e ) { logger . error ( STR_ + store Name , e ) ; } }
private static Pair < String , String > generate Sign Mask ( final I Translation Environment environment , long offset , final String value , final Operand Size size , final List < Reil Instruction > instructions ) { final String msb Mask = String . value Of ( Translation Helpers . get Msb Mask ( size ) ) ; final String shift Value = String . value Of ( Translation Helpers . get Shift Msb Lsb Mask ( size ) ) ; final String masked Msb = environment . get Next Variable String ( ) ; final String msb In Lsb = environment . get Next Variable String ( ) ; final String sign Mask = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create And ( offset ++ , size , value , size , msb Mask , size , masked Msb ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset ++ , size , masked Msb , size , shift Value , size , msb In Lsb ) ) ; instructions . add ( Reil Helpers . create Sub ( offset ++ , size , STR_ , size , msb In Lsb , size , sign Mask ) ) ; return new Pair < String , String > ( msb In Lsb , sign Mask ) ; }
@ Override public Cursor run Query On Background Thread ( Char Sequence constraint ) { if ( DBG ) Log . d ( LOG TAG , STR_ + constraint + STR_ ) ; String query = ( constraint == null ) ? STR_ : constraint . to String ( ) ; Cursor cursor = null ; if ( m Search View . get Visibility ( ) != View . VISIBLE || m Search View . get Window Visibility ( ) != View . VISIBLE ) { return null ; } try { cursor = get Suggestions ( query , QUERY LIMIT ) ; if ( cursor != null ) { cursor . get Count ( ) ; return cursor ; } } catch ( Runtime Exception e ) { Log . w ( LOG TAG , STR_ , e ) ; } return null ; }
protected Function < Object [ ] , Object > create Key Generator ( Schema schema , Table Id column Set Name , List < Column > columns ) { if ( schema != null ) { int [ ] record Indexes = indexes For Columns ( columns ) ; Field [ ] fields = fields For Columns ( schema , columns ) ; int num Fields = record Indexes . length ; Value Converter [ ] converters = converters For Columns ( schema , column Set Name , columns , null , null ) ; return null ; } return null ; }
public void add Tester ( final Tester tester ) { testers . add ( tester ) ; }
public Object key ( ) { String Builder key = new String Builder ( ) ; for ( int i = NUM_ ; i < filled . length ; i ++ ) { if ( filled [ i ] ) { key . append ( STR_ ) ; } else { key . append ( STR_ ) ; } } return key . to String ( ) ; }
protected boolean is Quiet ( ) { return false ; }
public void on Accessibility Event ( Accessibility Event event ) { if ( event . get Event Type ( ) == Accessibility Event Compat . TYPE TOUCH INTERACTION START ) { m Last Touch Time = System . nano Time ( ) ; } }
public void register Message ( Class < ? > cls ) { Atomic Integer cntr = cnt Map . get ( cls ) ; if ( cntr == null ) cnt Map . put ( cls , new Atomic Integer ( ) ) ; }
public True Type ( final Pdf Object Reader current pdf file , final String substitute Font ) { glyphs = new TT Glyphs ( ) ; init ( current pdf file ) ; this . substitute Font = substitute Font ; }
private void append Type ( Type generic Type , final String Builder builder ) { builder . append ( get Impl Name ( generic Type , false ) ) ; }
public String create Tables String ( Table Creation Mode mode ) { Array List < Type < ? > > sorted = sort Types ( ) ; String Builder sb = new String Builder ( ) ; for ( Type < ? > type : sorted ) { String sql = table Create Statement ( type , mode ) ; sb . append ( sql ) ; sb . append ( STR_ ) ; } return sb . to String ( ) ; }
public SIP Response create Response ( int status Code , String reason Phrase ) { SIP Response new Response ; new Response = new SIP Response ( ) ; try { new Response . set Status Code ( status Code ) ; } catch ( Parse Exception ex ) { throw new Illegal Argument Exception ( STR_ + status Code ) ; } if ( reason Phrase != null ) new Response . set Reason Phrase ( reason Phrase ) ; else new Response . set Reason Phrase ( SIP Response . get Reason Phrase ( status Code ) ) ; for ( String header Name : headers To Include In Response ) { SIP Header next Header = header Table . get ( header Name ) ; if ( next Header != null ) { if ( ! ( next Header instanceof Record Route List ) || ( next Header instanceof Record Route List && must Copy RR ( status Code ) ) ) { try { new Response . attach Header ( ( SIP Header ) next Header . clone ( ) , false ) ; } catch ( SIP Duplicate Header Exception e ) { e . print Stack Trace ( ) ; } } } } if ( Message Factory Impl . get Default Server Header ( ) != null ) { new Response . set Header ( Message Factory Impl . get Default Server Header ( ) ) ; } Server Header server = Message Factory Impl . get Default Server Header ( ) ; if ( server != null ) { new Response . set Header ( server ) ; } return new Response ; }
static Object new Instance ( Class Loader class Loader , String class Name ) throws Class Not Found Exception , Illegal Access Exception , Instantiation Exception { Class driver Class ; if ( class Loader == null ) { driver Class = Class . for Name ( class Name ) ; } else { driver Class = class Loader . load Class ( class Name ) ; } return driver Class . new Instance ( ) ; }
public void add Bottom Sheet Callback ( Bottom Sheet Callback callback ) { if ( m Callback == null ) m Callback = new Vector < > ( ) ; m Callback . add ( callback ) ; }
protected boolean parse Line Internal ( ) { int i = NUM_ ; for ( ; tokenizer . valid ( ) ; tokenizer . advance ( ) , i ++ ) { if ( ! is Label Column ( i ) && ! tokenizer . is Quoted ( ) ) { try { attributes . add ( tokenizer . get Double ( ) ) ; continue ; } catch ( Number Format Exception e ) { } } String lbl = tokenizer . get Stripped Substring ( ) ; if ( lbl . length ( ) > NUM_ ) { haslabels = true ; lbl = unique . add Or Get ( lbl ) ; labels . add ( lbl ) ; } } if ( curvec == null && attributes . size == NUM_ ) { columnnames = new Array List < > ( labels ) ; haslabels = false ; curvec = null ; curlbl = null ; labels . clear ( ) ; return false ; } curvec = create Vector ( ) ; curlbl = Label List . make ( labels ) ; attributes . clear ( ) ; labels . clear ( ) ; return true ; }
protected boolean add Hash ( Object entity , Hasher hasher ) { Entity Type entity Type = get Element Type ( entity ) ; if ( entity Type == UNKNOWN ) { return false ; } try { hasher . put String ( get Json ( entity , entity Type ) , Charset . default Charset ( ) ) ; } catch ( Runtime Exception e ) { return false ; } return true ; }
static private List < Initiator > add Host Initiators ( int number Initiators , URI host Id , String host Name ) { List < Initiator > initiators = new Array List < Initiator > ( ) ; for ( int i = NUM_ ; i < number Initiators ; i ++ ) { Initiator initiator = new Initiator ( ) ; initiator . set Host ( host Id ) ; initiator . set Host Name ( host Name ) ; String byte 1 = String . format ( STR_ , init Index / NUM_ ) ; String byte 0 = String . format ( STR_ , init Index % NUM_ ) ; initiator . set Initiator Port ( STR_ + byte 1 + STR_ + byte 0 ) ; initiator . set Id ( URI . create ( STR_ + init Index ++ ) ) ; initiators . add ( initiator ) ; } return initiators ; }
public static String gensalt ( int log rounds , Secure Random random ) { if ( log rounds < NUM_ || log rounds > NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } String Builder rs = new String Builder ( ) ; byte rnd [ ] = new byte [ BCRYPT SALT LEN ] ; random . next Bytes ( rnd ) ; rs . append ( STR_ ) ; if ( log rounds < NUM_ ) { rs . append ( STR_ ) ; } rs . append ( log rounds ) ; rs . append ( STR_ ) ; encode base 64 ( rnd , rnd . length , rs ) ; return rs . to String ( ) ; }
protected Map < String , Map < String , Object > > parse Libs ( String default Lib Format ) throws IO Exception , Parse Exception { Map < String , Map < String , Object > > src File Data Models = Ftl Doc File Parser . make Data Map ( ) ; for ( String lib Filename : lib Filenames ) { File src File = new File ( src Folder Path File , lib Filename ) ; msg Handler . log Info ( STR_ + src File . to String ( ) ) ; Map < String , Object > data Model = parse Lib ( lib Filename , src File , default Lib Format ) ; String lib Name = ( String ) data Model . get ( STR_ ) ; src File Data Models . put ( lib Name , data Model ) ; } return src File Data Models ; }
@ Override public List < Carbon Dictionary Column Meta Chunk > read ( ) throws IO Exception { List < Carbon Dictionary Column Meta Chunk > dictionary Meta Chunks = new Array List < Carbon Dictionary Column Meta Chunk > ( Carbon Common Constants . DEFAULT COLLECTION SIZE ) ; Carbon Dictionary Column Meta Chunk column Meta Chunk = null ; Column Dictionary Chunk Meta dictionary Chunk Meta = null ; open Thrift Reader ( ) ; while ( dictionary Metadata File Reader . has Next ( ) ) { dictionary Chunk Meta = ( Column Dictionary Chunk Meta ) dictionary Metadata File Reader . read ( ) ; column Meta Chunk = get New Instance Of Carbon Dictionary Column Meta Chunk ( dictionary Chunk Meta ) ; dictionary Meta Chunks . add ( column Meta Chunk ) ; } return dictionary Meta Chunks ; }
public static int compile Shader ( final int shader Type , final String shader Source ) { int shader Handle = GLES 20 . gl Create Shader ( shader Type ) ; if ( shader Handle != NUM_ ) { GLES 20 . gl Shader Source ( shader Handle , shader Source ) ; GLES 20 . gl Compile Shader ( shader Handle ) ; final int [ ] compile Status = new int [ NUM_ ] ; GLES 20 . gl Get Shaderiv ( shader Handle , GLES 20 . GL COMPILE STATUS , compile Status , NUM_ ) ; if ( compile Status [ NUM_ ] == NUM_ ) { Log . e ( TAG , STR_ + GLES 20 . gl Get Shader Info Log ( shader Handle ) ) ; GLES 20 . gl Delete Shader ( shader Handle ) ; shader Handle = NUM_ ; } } if ( shader Handle == NUM_ ) { throw new Runtime Exception ( STR_ ) ; } return shader Handle ; }
public Media Config create Channel Image Attachment ( String file , Media Config config ) { config . add Credentials ( this ) ; String xml = POSTIMAGE ( this . url + STR_ , file , config . name , config . to XML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { Media Config media = new Media Config ( ) ; media . parse XML ( root ) ; return media ; } catch ( Exception exception ) { this . exception = SDK Exception . parse Failure ( exception ) ; throw this . exception ; } }
private void maybe Update Stats ( ) { if ( lock . try Lock ( ) ) { try { if ( ( System Clock . elapsed Realtime ( ) - m Last Restat Time ) > RESTAT INTERVAL MS ) { update Stats ( ) ; } } finally { lock . unlock ( ) ; } } }
public void update ( Double actual Future Change , Prediction prediction ) { Outcome outcome = Outcome . get Outcome ( prediction , actual Future Change ) ; switch ( outcome ) { case CORRECT : total Percent Predicted += Math . abs ( actual Future Change ) ; break ; case INCORRECT : total Percent Mispredicted += Math . abs ( actual Future Change ) ; break ; } }
public Workflow . Method delete Replication Group Method ( URI storage , URI consistency Group , String group Name , Boolean keep RG Name , Boolean mark Inactive , String source Group Name ) { return new Workflow . Method ( STR_ , storage , consistency Group , group Name , keep RG Name , mark Inactive , source Group Name ) ; }
public void remove Cancel Listener ( Action Listener a ) { m cancel But . remove Action Listener ( a ) ; }
public static C Remote Selection Dialog show ( final J Frame parent , final I Debugger debugger , final Remote File System system , final Process List list ) { final C Remote Selection Dialog dlg = new C Remote Selection Dialog ( parent , debugger , system , list ) ; Gui Helper . center Child To Parent ( parent , dlg , true ) ; dlg . set Visible ( true ) ; return dlg ; }
protected void include Properties ( Set < Property > all Properties ) { all Properties . add All ( this . properties ) ; }
private Paint create Graphic Inner Shadow Gradient ( Shape s ) { Rectangle 2 D b = s . get Bounds 2 D ( ) ; float mid X = ( float ) b . get Center X ( ) ; float y 1 = ( float ) b . get Min Y ( ) ; float y 2 = ( float ) b . get Max Y ( ) ; return create Gradient ( mid X , y 1 , mid X , y 2 , new float [ ] { NUM_ , NUM_ , NUM_ , NUM_ } , new Color [ ] { graphic Inner Shadow 1 , graphic Inner Shadow 2 , graphic Inner Shadow 3 , graphic Inner Shadow 4 } ) ; }
public void clear ( ) { data Dimension Items . clear ( ) ; periods . clear ( ) ; relatives = null ; organisation Units . clear ( ) ; data Element Groups . clear ( ) ; organisation Unit Groups . clear ( ) ; organisation Unit Levels . clear ( ) ; category Dimensions . clear ( ) ; category Option Groups . clear ( ) ; attribute Dimensions . clear ( ) ; data Element Dimensions . clear ( ) ; program Indicator Dimensions . clear ( ) ; user Organisation Unit = false ; user Organisation Unit Children = false ; user Organisation Unit Grand Children = false ; item Organisation Unit Groups . clear ( ) ; }
protected static List < Integer > sort Group Nodes ( final List < Integer > group Node Indices , final Bi Map < Integer , I Navi Group Node > group Node Map ) { final List < Integer > sorted List = new Array List < Integer > ( ) ; final List < Integer > cloned List = new Array List < Integer > ( group Node Indices ) ; final Set < I Navi Group Node > added Nodes = new Hash Set < I Navi Group Node > ( ) ; while ( ! cloned List . is Empty ( ) ) { for ( final Integer id : cloned List ) { final I Navi Group Node node = group Node Map . get ( id ) ; if ( ( node . get Parent Group ( ) == null ) || added Nodes . contains ( node . get Parent Group ( ) ) ) { added Nodes . add ( node ) ; sorted List . add ( id ) ; cloned List . remove ( id ) ; break ; } } } return sorted List ; }
private void create New Format ( int AD Table ID ) { M Print Format pf = M Print Format . create From Table ( Env . get Ctx ( ) , AD Table ID ) ; launch Report ( pf ) ; }
@ Override public void customize Popup Menu ( Result History List history , int index , J Popup Menu menu ) { menu . add Separator ( ) ; Abstract Classify Result History Plugin . populate Menu ( Classify Tab . this , history , index , menu ) ; }
private double [ ] [ ] Calc Constant Coef ( Variogram variogarm , List < Kriging Point > NN Points ) { int n = NN Points . size ( ) ; double [ ] [ ] mat = new double [ n + NUM_ ] [ n + NUM_ ] ; double dist = NUM_ ; for ( int i = NUM_ ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { dist = Math . sqrt ( Math . abs ( Math . pow ( NN Points . get ( i ) . x - NN Points . get ( j ) . x , NUM_ ) ) + Math . abs ( Math . pow ( NN Points . get ( i ) . y - NN Points . get ( j ) . y , NUM_ ) ) ) ; mat [ i ] [ j ] = get Theoretical SV Value ( dist , variogarm ) ; mat [ j ] [ i ] = mat [ i ] [ j ] ; } } for ( int i = NUM_ ; i < n ; i ++ ) { mat [ i ] [ n ] = NUM_ ; mat [ n ] [ i ] = NUM_ ; } return mat ; }
public void update Gui Setting ( String key ) { gui . revert Setting ( key ) ; }
synchronized String add Listener ( Service Listener listener ) { return add Listener ( null , listener ) ; }
static private String format Exec Status ( Tungsten Properties exec Status ) { Execute Query Status status = ( Execute Query Status ) exec Status . get Object ( STATUS KEY ) ; String status Message = exec Status . get String ( STATUS MESSAGE KEY ) ; return String . format ( STR_ , status . to String ( ) , status Message ) ; }
private String download Url ( String str Url ) throws IO Exception { String data = STR_ ; Input Stream i Stream = null ; Http URL Connection url Connection = null ; try { URL url = new URL ( str Url ) ; url Connection = ( Http URL Connection ) url . open Connection ( ) ; url Connection . connect ( ) ; i Stream = url Connection . get Input Stream ( ) ; Buffered Reader br = new Buffered Reader ( new Input Stream Reader ( i Stream ) ) ; String Buffer sb = new String Buffer ( ) ; String line = STR_ ; while ( ( line = br . read Line ( ) ) != null ) { sb . append ( line ) ; } data = sb . to String ( ) ; br . close ( ) ; } catch ( Exception e ) { Log . d ( STR_ , e . to String ( ) ) ; } finally { i Stream . close ( ) ; url Connection . disconnect ( ) ; } return data ; }
public static String pretty Format ( Dependency Graph graph ) { return pretty Format ( graph . get Edges ( ) ) ; }
public static String decode String ( String source ) throws URI Syntax Exception { if ( source == null ) { return source ; } int i ; if ( ( i = source . index Of ( QUOTE MARKER ) ) == - NUM_ ) { return source ; } Byte Array Output Stream decoded = new Byte Array Output Stream ( ) ; try { decoded . write ( to Bytes ( source . substring ( NUM_ , i ) ) ) ; int len = source . length ( ) ; for ( ; i < len ; i ++ ) { char ch = source . char At ( i ) ; if ( ch == QUOTE MARKER ) { if ( ( i + NUM_ ) >= len ) { ch = ENCODING ERROR MARKER ; } else { try { ch = ( char ) Integer . parse Int ( source . substring ( i + NUM_ , i + NUM_ ) , NUM_ ) ; } catch ( Number Format Exception nfe ) { throw new URI Syntax Exception ( source , STR_ ) ; } decoded . write ( ch ) ; } i += NUM_ ; } else { decoded . write ( ch ) ; } } return new String ( decoded . to Byte Array ( ) , STR_ ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; return null ; } }
static void stop Refresh Timer ( ) { try { if ( refresh Timer != null && mbean Server != null ) { mbean Server . unregister M Bean ( refresh Timer Object Name ) ; refresh Timer . stop ( ) ; } } catch ( JM Exception e ) { log Stack Trace ( Level . WARN , e ) ; } catch ( JM Runtime Exception e ) { log Stack Trace ( Level . WARN , e ) ; } catch ( Exception e ) { log Stack Trace ( Level . DEBUG , e , STR_ ) ; } }
public Extended Message Format ( final String pattern , final Map < String , ? extends Format Factory > registry ) { this ( pattern , Locale . get Default ( ) , registry ) ; }
public static Rename Participant [ ] load Rename Participants ( Refactoring Status status , Refactoring Processor processor , Object element , Rename Arguments arguments , I Participant Descriptor Filter filter , String [ ] affected Natures , Sharable Participants shared ) { Refactoring Participant [ ] participants = fg Rename Instance . get Participants ( status , processor , element , arguments , filter , affected Natures , shared ) ; Rename Participant [ ] result = new Rename Participant [ participants . length ] ; System . arraycopy ( participants , NUM_ , result , NUM_ , participants . length ) ; return result ; }
public static Resource Group State create Default Resource Group ( Verification Host host , String project Id ) throws Throwable { Resource Group State resource Group = new Resource Group State ( ) ; resource Group . name = project Id ; return Test Utils . do Post ( host , resource Group , Resource Group State . class , Uri Utils . build Uri ( host , Resource Group Service . FACTORY LINK ) ) ; }
protected void add Serializer ( String serializer ) { if ( ! String Utils . is Empty ( serializer ) ) { serializers . add ( serializer ) ; } }
private boolean check Select For Swipe ( int action , Motion Event motion Event , int pointer Index ) { if ( selected != null || action != Motion Event . ACTION MOVE ) { return false ; } if ( recycler View . get Scroll State ( ) == Recycler View . SCROLL STATE DRAGGING ) { return false ; } final Recycler View . View Holder vh = find Swiped View ( motion Event ) ; if ( vh == null ) { return false ; } final int movement Flags = callback . get Abs Movement Flags ( recycler View , vh ) ; final int swipe Flags = ( movement Flags & ACTION MODE SWIPE MASK ) > > ( DIRECTION FLAG COUNT * ACTION STATE SWIPE ) ; if ( swipe Flags == NUM_ ) { return false ; } final float x = Motion Event Compat . get X ( motion Event , pointer Index ) ; final float y = Motion Event Compat . get Y ( motion Event , pointer Index ) ; final float dx = x - initial Touch X ; final float dy = y - initial Touch Y ; final float abs Dx = Math . abs ( dx ) ; final float abs Dy = Math . abs ( dy ) ; if ( abs Dx < slop && abs Dy < slop ) { return false ; } if ( abs Dx > abs Dy ) { if ( dx < NUM_ && ( swipe Flags & LEFT ) == NUM_ ) { return false ; } if ( dx > NUM_ && ( swipe Flags & RIGHT ) == NUM_ ) { return false ; } } else { if ( dy < NUM_ && ( swipe Flags & UP ) == NUM_ ) { return false ; } if ( dy > NUM_ && ( swipe Flags & DOWN ) == NUM_ ) { return false ; } } d X = d Y = NUM_ ; active Pointer Id = Motion Event Compat . get Pointer Id ( motion Event , NUM_ ) ; select ( ( Swipe Open View Holder ) vh , ACTION STATE SWIPE ) ; return true ; }
protected void tag ( String tag , String name , String value , boolean close ) { spacing ( ) ; m out . print ( STR_ ) ; m out . print ( tag ) ; m out . print ( STR_ ) ; m out . print ( name ) ; m out . print ( STR_ ) ; m out . print ( STR_ ) ; escape String ( value ) ; m out . print ( STR_ ) ; if ( close ) m out . print ( STR_ ) ; m out . print ( STR_ ) ; println ( ) ; if ( ! close ) { m tag Stack . add ( tag ) ; } }
private void check Policy ( X 509 Certificate curr Cert ) throws Cert Path Validator Exception { String msg = STR_ ; if ( debug != null ) { debug . println ( STR_ + msg + STR_ ) ; debug . println ( STR_ + cert Index ) ; debug . println ( STR_ + STR_ + explicit Policy ) ; debug . println ( STR_ + STR_ + policy Mapping ) ; debug . println ( STR_ + STR_ + inhibit Any Policy ) ; debug . println ( STR_ + STR_ + root Node ) ; } X 509 Cert Impl curr Cert Impl = null ; try { curr Cert Impl = X 509 Cert Impl . to Impl ( curr Cert ) ; } catch ( Certificate Exception ce ) { throw new Cert Path Validator Exception ( ce ) ; } boolean final Cert = ( cert Index == cert Path Len ) ; root Node = process Policies ( cert Index , init Policies , explicit Policy , policy Mapping , inhibit Any Policy , reject Policy Qualifiers , root Node , curr Cert Impl , final Cert ) ; if ( ! final Cert ) { explicit Policy = merge Explicit Policy ( explicit Policy , curr Cert Impl , final Cert ) ; policy Mapping = merge Policy Mapping ( policy Mapping , curr Cert Impl ) ; inhibit Any Policy = merge Inhibit Any Policy ( inhibit Any Policy , curr Cert Impl ) ; } cert Index ++ ; if ( debug != null ) { debug . println ( STR_ + STR_ + explicit Policy ) ; debug . println ( STR_ + STR_ + policy Mapping ) ; debug . println ( STR_ + STR_ + inhibit Any Policy ) ; debug . println ( STR_ + STR_ + root Node ) ; debug . println ( STR_ + msg + STR_ ) ; } }
@ Override protected void post Process Template Loaders ( List < Template Loader > template Loaders ) { template Loaders . add ( new Class Template Loader ( Free Marker Configurer . class , STR_ ) ) ; logger . info ( STR_ ) ; }
public String options Tip Text HTML ( ) { return STR_ ; }
private String build Java Script Data ( String event , String msg ) { String b 64 Encoded Msg = STR_ ; try { if ( msg != null ) { b 64 Encoded Msg = Base 64 . encode Bytes ( msg . get Bytes ( UTF 8 CHARSET ) ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } String d = STR_ + event + STR_ + STR_ + STR_ + id + STR_ + STR_ + b 64 Encoded Msg + STR_ + STR_ + STR_ ; return d ; }
static I Constraint [ ] combine Constraints ( final I Constraint [ ] constraints , final I Hash Join Utility [ ] all ) { final List < I Constraint > list = new Linked List < I Constraint > ( ) ; for ( int i = NUM_ ; i < all . length ; i ++ ) { final I Hash Join Utility tmp = all [ i ] ; if ( tmp . get Constraints ( ) != null ) { list . add All ( Arrays . as List ( tmp . get Constraints ( ) ) ) ; } } if ( constraints != null ) { list . add All ( Arrays . as List ( constraints ) ) ; } return list . is Empty ( ) ? null : list . to Array ( new I Constraint [ list . size ( ) ] ) ; }
private static Instance create Instance Template ( String user Email , String project Id , String zone Id , List < String > scopes ) { Instance instance = new Instance ( ) ; instance . set Machine Type ( String . format ( ENUMERATION TEST MACHINE TYPE , project Id , zone Id ) ) ; Network Interface ifc = new Network Interface ( ) ; ifc . set Network ( String . format ( NETWORK INTERFACE , project Id ) ) ; List < Access Config > configs = new Array List < > ( ) ; Access Config config = new Access Config ( ) ; config . set Type ( NETWORK INTERFACE CONFIG ) ; config . set Name ( NETWORK ACCESS CONFIG ) ; configs . add ( config ) ; ifc . set Access Configs ( configs ) ; instance . set Network Interfaces ( Collections . singleton List ( ifc ) ) ; Attached Disk disk = new Attached Disk ( ) ; disk . set Boot ( true ) ; disk . set Auto Delete ( true ) ; disk . set Type ( DISK TYPE PERSISTENT ) ; Attached Disk Initialize Params params = new Attached Disk Initialize Params ( ) ; params . set Source Image ( SOURCE IMAGE ) ; params . set Disk Type ( String . format ( DISK TYPE , project Id , zone Id ) ) ; disk . set Initialize Params ( params ) ; instance . set Disks ( Collections . singleton List ( disk ) ) ; Service Account account = new Service Account ( ) ; account . set Email ( user Email ) ; account . set Scopes ( scopes ) ; instance . set Service Accounts ( Collections . singleton List ( account ) ) ; return instance ; }
private void reset Notes ( ) { if ( error In Status 1 ) { if ( edit Mode ) { status Text 1 . set Text ( edit Status 1 ) ; } else { status Text 1 . set Text ( std Status 1 ) ; } error In Status 1 = false ; } reset Notes 2 ( ) ; }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N , Buffered Writer out ) throws IO Exception { reset State ( ) ; if ( null == hg . goal Node ) return ; for ( int k = NUM_ ; k <= top N ; k ++ ) { String hyp Str = get Kth Hyp ( hg . goal Node , k ) ; if ( null == hyp Str ) break ; out . write ( hyp Str ) ; out . write ( STR_ ) ; out . flush ( ) ; } }
@ Override public List < Period > generate Periods ( Date date ) { Calendar cal = create Calendar Instance ( date ) ; cal . add ( Calendar . YEAR , cal . get ( Calendar . YEAR ) % NUM_ == NUM_ ? - NUM_ : - NUM_ ) ; cal . set ( Calendar . DAY OF YEAR , NUM_ ) ; Array List < Period > two Years = new Array List < > ( ) ; for ( int i = NUM_ ; i < NUM_ ; ++ i ) { Date start Date = cal . get Time ( ) ; cal . add ( Calendar . YEAR , NUM_ ) ; cal . set ( Calendar . DAY OF YEAR , cal . get Actual Maximum ( Calendar . DAY OF YEAR ) ) ; two Years . add ( new Period ( this , start Date , cal . get Time ( ) ) ) ; cal . add ( Calendar . DAY OF YEAR , NUM_ ) ; } return two Years ; }
protected void process Initiators ( Export Group export Group , Collection < URI > initiator UR Is , Collection < String > port Names , Map < String , URI > port Name To Initiator URI ) { Collection < String > initiator URI Strs = Collections 2 . transform ( initiator UR Is , Common Transformer Functions . FCTN URI TO STRING ) ; Collection < Initiator > initiators = Collections 2 . transform ( initiator URI Strs , Common Transformer Functions . fctn String To Initiator ( db Client ) ) ; process Initiators ( export Group , initiators , port Names , port Name To Initiator URI , null , null ) ; }
protected void remove User Tool Bar Beans ( Vector < ? > metabeans ) { int i ; int n ; Meta Bean meta ; Vector < Object > subflow ; Bean Instance beaninst ; for ( i = NUM_ ; i < metabeans . size ( ) ; i ++ ) { meta = ( Meta Bean ) metabeans . get ( i ) ; subflow = meta . get Sub Flow ( ) ; for ( n = NUM_ ; n < subflow . size ( ) ; n ++ ) { beaninst = ( Bean Instance ) subflow . get ( n ) ; beaninst . remove Bean ( m Bean Layout ) ; } } }
private void compute Default Filters ( File indicator File , Json Object json Obj ) { default Filters = new Array List < Filter > ( ) ; Json Array filter Array = Utils . get Field Value As Array ( json Obj , STR_ ) ; if ( filter Array != null ) { Set < String > filter Fields = Utils . get All Filter Fields ( json Obj ) ; for ( int i = NUM_ ; i < filter Array . size ( ) ; i ++ ) { Json Element filter Elt = filter Array . get ( i ) ; Filter filter ; try { filter = Filter . parse ( filter Elt , filter Fields ) ; default Filters . add ( filter ) ; } catch ( Filter Parse Exception e ) { String title = STR_ ; String msg = STR_ + indicator File ; Droidsafe Plugin Utilities . show Error ( title , msg , e ) ; ; e . print Stack Trace ( ) ; } } } }
Values values ( Thread current ) { return current . local Values ; }
public void add Mech Display Listener ( Mech Display Listener listener ) { event Listeners . add ( listener ) ; }
public static < Containing Type extends Message Lite , Type > Generated Extension < Containing Type , Type > new Repeated Generated Extension ( final Containing Type containing Type Default Instance , final Message Lite message Default Instance , final Internal . Enum Lite Map < ? > enum Type Map , final int number , final Wire Format . Field Type type , final boolean is Packed ) { @ Suppress Warnings ( STR_ ) Type empty List = ( Type ) Collections . empty List ( ) ; return new Generated Extension < Containing Type , Type > ( containing Type Default Instance , empty List , message Default Instance , new Extension Descriptor ( enum Type Map , number , type , true , is Packed ) ) ; }
public void disable ( ) throws IO Exception { assert m writer != null ; m writer . close ( ) ; }
public static Buffered Reader new Reader ( Path self ) throws IO Exception { return Files . new Buffered Reader ( self , Charset . default Charset ( ) ) ; }
@ Override public void build Classifier ( Instances data ) throws Exception { if ( m fast Regression && ( m fixed Num Iterations < NUM_ ) ) { m fixed Num Iterations = try Logistic ( data ) ; } Instances cv Data = new Instances ( data ) ; cv Data . stratify ( m num Folds Pruning ) ; double [ ] [ ] alphas = new double [ m num Folds Pruning ] [ ] ; double [ ] [ ] errors = new double [ m num Folds Pruning ] [ ] ; for ( int i = NUM_ ; i < m num Folds Pruning ; i ++ ) { Instances train = cv Data . train CV ( m num Folds Pruning , i ) ; Instances test = cv Data . test CV ( m num Folds Pruning , i ) ; build Tree ( train , null , train . num Instances ( ) , NUM_ , null ) ; int num Nodes = get Num Inner Nodes ( ) ; alphas [ i ] = new double [ num Nodes + NUM_ ] ; errors [ i ] = new double [ num Nodes + NUM_ ] ; prune ( alphas [ i ] , errors [ i ] , test ) ; } cv Data = null ; build Tree ( data , null , data . num Instances ( ) , NUM_ , null ) ; int num Nodes = get Num Inner Nodes ( ) ; double [ ] tree Alphas = new double [ num Nodes + NUM_ ] ; int iterations = prune ( tree Alphas , null , null ) ; double [ ] tree Errors = new double [ num Nodes + NUM_ ] ; for ( int i = NUM_ ; i <= iterations ; i ++ ) { double alpha = Math . sqrt ( tree Alphas [ i ] * tree Alphas [ i + NUM_ ] ) ; double error = NUM_ ; for ( int k = NUM_ ; k < m num Folds Pruning ; k ++ ) { int l = NUM_ ; while ( alphas [ k ] [ l ] <= alpha ) { l ++ ; } error += errors [ k ] [ l - NUM_ ] ; } tree Errors [ i ] = error ; } int best = - NUM_ ; double best Error = Double . MAX VALUE ; for ( int i = iterations ; i >= NUM_ ; i -- ) { if ( tree Errors [ i ] < best Error ) { best Error = tree Errors [ i ] ; best = i ; } } double best Alpha = Math . sqrt ( tree Alphas [ best ] * tree Alphas [ best + NUM_ ] ) ; unprune ( ) ; prune ( best Alpha ) ; }
private void release All Locks ( ) { synchronized ( read notify ) { read notify . notify All ( ) ; } synchronized ( write notify ) { write notify . notify All ( ) ; } synchronized ( state notify ) { state notify . notify All ( ) ; } }
public static void update Provider Key Info ( String realm , String entity ID , Set < String > cert Aliases , boolean is Signing , boolean is IDP , String enc Algo , int key Size ) throws SAML 2 Meta Exception { SAML 2 Meta Manager meta Manager = new SAML 2 Meta Manager ( ) ; Entity Config Element config = meta Manager . get Entity Config ( realm , entity ID ) ; if ( ! config . is Hosted ( ) ) { String [ ] args = { entity ID , realm } ; throw new SAML 2 Meta Exception ( STR_ , args ) ; } Entity Descriptor Element desp = meta Manager . get Entity Descriptor ( realm , entity ID ) ; Base Config Type base Config ; Role Descriptor Type descriptor ; if ( is IDP ) { base Config = SAML 2 Meta Utils . get IDPSSO Config ( config ) ; descriptor = SAML 2 Meta Utils . get IDPSSO Descriptor ( desp ) ; if ( base Config == null || descriptor == null ) { String [ ] args = { entity ID , realm } ; throw new SAML 2 Meta Exception ( STR_ , args ) ; } } else { base Config = SAML 2 Meta Utils . get SPSSO Config ( config ) ; descriptor = SAML 2 Meta Utils . get SPSSO Descriptor ( desp ) ; if ( base Config == null || descriptor == null ) { String [ ] args = { entity ID , realm } ; throw new SAML 2 Meta Exception ( STR_ , args ) ; } } if ( Collection Utils . is Empty ( cert Aliases ) ) { remove Key Descriptor ( descriptor , is Signing ) ; if ( is Signing ) { set Extended Attribute Value ( base Config , SAML 2 Constants . SIGNING CERT ALIAS , null ) ; } else { set Extended Attribute Value ( base Config , SAML 2 Constants . ENCRYPTION CERT ALIAS , null ) ; } } else { Set < Key Descriptor Type > key Descriptors = new Linked Hash Set < > ( cert Aliases . size ( ) ) ; for ( String cert Alias : cert Aliases ) { key Descriptors . add ( get Key Descriptor ( cert Alias , is Signing , enc Algo , key Size ) ) ; } update Key Descriptor ( descriptor , key Descriptors ) ; if ( is Signing ) { set Extended Attribute Value ( base Config , SAML 2 Constants . SIGNING CERT ALIAS , cert Aliases ) ; } else { set Extended Attribute Value ( base Config , SAML 2 Constants . ENCRYPTION CERT ALIAS , cert Aliases ) ; } } meta Manager . set Entity Descriptor ( realm , desp ) ; meta Manager . set Entity Config ( realm , config ) ; }
public void reset ( ) { current Time = NUM_ ; stored Time = NUM_ ; start Time = System . current Time Millis ( ) ; }
public String emit Pattern ( boolean with White Space ) { String Buffer result = new String Buffer ( ) ; for ( int i = NUM_ ; i < patterns . size ( ) ; ++ i ) { Pattern Entry entry = patterns . get ( i ) ; if ( entry != null ) { entry . add To Buffer ( result , true , with White Space , null ) ; } } return result . to String ( ) ; }
public static void invalidate Session ( Object session , Http Servlet Request request , Http Servlet Response response , String protocol ) throws Session Exception { Session Provider provider = Session Manager . get Provider ( ) ; if ( ! is Multiple Protocol Session ( session , protocol ) ) { provider . invalidate Session ( session , request , response ) ; } else { remove Federation Protocol ( session , protocol ) ; } }
private void fit Image To View ( ) { Drawable drawable = get Drawable ( ) ; if ( drawable == null || drawable . get Intrinsic Width ( ) == NUM_ || drawable . get Intrinsic Height ( ) == NUM_ ) { return ; } if ( matrix == null || prev Matrix == null ) { return ; } int drawable Width = drawable . get Intrinsic Width ( ) ; int drawable Height = drawable . get Intrinsic Height ( ) ; float scale X = ( float ) view Width / drawable Width ; float scale Y = ( float ) view Height / drawable Height ; switch ( scale Type ) { case CENTER : scale X = scale Y = NUM_ ; break ; case CENTER CROP : scale X = scale Y = Math . max ( scale X , scale Y ) ; break ; case CENTER INSIDE : scale X = scale Y = Math . min ( NUM_ , Math . min ( scale X , scale Y ) ) ; case FIT CENTER : scale X = scale Y = Math . min ( scale X , scale Y ) ; break ; case FIT XY : break ; default : throw new Unsupported Operation Exception ( STR_ ) ; } float redundant X Space = view Width - ( scale X * drawable Width ) ; float redundant Y Space = view Height - ( scale Y * drawable Height ) ; match View Width = view Width - redundant X Space ; match View Height = view Height - redundant Y Space ; if ( ! is Zoomed ( ) && ! image Rendered At Least Once ) { matrix . set Scale ( scale X , scale Y ) ; matrix . post Translate ( redundant X Space / NUM_ , redundant Y Space / NUM_ ) ; normalized Scale = NUM_ ; } else { if ( Math Utils . float Equal ( prev Match View Width , NUM_ ) || Math Utils . float Equal ( prev Match View Height , NUM_ ) ) { save Previous Image Values ( ) ; } prev Matrix . get Values ( m ) ; m [ Matrix . MSCALE X ] = match View Width / drawable Width * normalized Scale ; m [ Matrix . MSCALE Y ] = match View Height / drawable Height * normalized Scale ; float trans X = m [ Matrix . MTRANS X ] ; float trans Y = m [ Matrix . MTRANS Y ] ; float prev Actual Width = prev Match View Width * normalized Scale ; float actual Width = get Image Width ( ) ; translate Matrix After Rotate ( Matrix . MTRANS X , trans X , prev Actual Width , actual Width , prev View Width , view Width , drawable Width ) ; float prev Actual Height = prev Match View Height * normalized Scale ; float actual Height = get Image Height ( ) ; translate Matrix After Rotate ( Matrix . MTRANS Y , trans Y , prev Actual Height , actual Height , prev View Height , view Height , drawable Height ) ; matrix . set Values ( m ) ; } fix Trans ( ) ; set Image Matrix ( matrix ) ; }
public void process Bytes ( byte [ ] in , int in Off , int len ) { if ( len == NUM_ ) { return ; } if ( len < NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( buf Off + len > buf . length ) { throw new Data Length Exception ( STR_ ) ; } System . arraycopy ( in , in Off , buf , buf Off , len ) ; buf Off += len ; }
public Default Syntax Kit ( Lexer lexer ) { super ( ) ; this . lexer = lexer ; }
private static void load Adobe Map ( ) { Buffered Reader input stream = null ; if ( adobe Map == null ) { try { adobe Map = new Hash Map < String , Integer > ( ) ; input stream = new Buffered Reader ( new Input Stream Reader ( loader . get Resource As Stream ( STR_ ) , enc ) ) ; if ( input stream == null ) { Log Writer . write Log ( STR_ ) ; } while ( true ) { final String line = input stream . read Line ( ) ; if ( line == null ) { break ; } if ( ( ! line . starts With ( STR_ ) ) && ( line . index Of ( STR_ ) != - NUM_ ) ) { final String Tokenizer vals = new String Tokenizer ( line , STR_ ) ; final String key = vals . next Token ( ) ; String operand = vals . next Token ( ) ; final int space = operand . index Of ( STR_ ) ; if ( space != - NUM_ ) { operand = operand . substring ( NUM_ , space ) ; } final int op Val = Integer . parse Int ( operand , NUM_ ) ; adobe Map . put ( key , op Val ) ; unicode name mapping table . put ( key , Character . to String ( ( char ) op Val ) ) ; } } } catch ( final Exception e ) { Log Writer . write Log ( STR_ + e + STR_ ) ; } } if ( input stream != null ) { try { input stream . close ( ) ; } catch ( final Exception e ) { Log Writer . write Log ( STR_ + e + STR_ ) ; } } }
private boolean executor Alive ( Thread Pool Executor tpe , String name ) { if ( tpe == null ) { return false ; } else { int ac = tpe . get Active Count ( ) ; if ( ac > NUM_ ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ , ac , name ) ; } return true ; } else { return false ; } } }
public boolean add Stack Changed Listener ( Stack Changed Listener listener ) { return listeners . add ( listener ) ; }
static final int advance Probe ( int probe ) { probe ^= probe << NUM_ ; probe ^= probe > > > NUM_ ; probe ^= probe << NUM_ ; UNSAFE . put Int ( Thread . current Thread ( ) , PROBE , probe ) ; return probe ; }
private static Table Info create Table Info ( String table Name , Integer page Number , int flags , Short type , String linked Db Name , String linked Table Name ) { if ( TYPE LINKED TABLE . equals ( type ) ) { return new Linked Table Info ( page Number , table Name , flags , linked Db Name , linked Table Name ) ; } return new Table Info ( page Number , table Name , flags ) ; }
protected void paint Component ( Graphics g ) { super . paint Component ( g ) ; if ( caret Line Y > - NUM_ ) { g . set Color ( get Caret Marker Color ( ) ) ; g . fill Rect ( NUM_ , caret Line Y , get Width ( ) , NUM_ ) ; } }
@ After public void tear Down ( ) throws Exception { for ( Thread thread : stuck Threads ) { thread . interrupt ( ) ; } stuck Threads . clear ( ) ; }
private void specialised Functions ( ) { Function < Integer , Employee > emp Function = null ; Int Function < Employee > emp Function 2 = null ; Double Function < String > double Function = null ; double Function . apply ( NUM_ ) ; Long Function < Patient > long Function = null ; long Function . apply ( NUM_ ) ; }
private void update Names ( ) { for ( Cluster < ? > cluster : clustering . get All Clusters ( ) ) { if ( names . get ( cluster ) == null ) { String sugname = cluster . get Name Automatic ( ) ; Integer count = namecount . get ( sugname ) ; if ( count == null ) { count = new Integer ( NUM_ ) ; } names . put ( cluster , sugname + STR_ + count . to String ( ) ) ; count ++ ; namecount . put ( sugname , count ) ; } } }
protected void generate Fields ( ) { for ( Soot Field f : sc . get Fields ( ) ) { String name = f . get Name ( ) ; String desc = to Type Desc ( f . get Type ( ) ) ; String sig = null ; if ( f . has Tag ( STR_ ) ) { Signature Tag generic Signature = ( Signature Tag ) f . get Tag ( STR_ ) ; sig = generic Signature . get Signature ( ) ; } Object value = get Default Value ( f ) ; int access = get Modifiers ( f . get Modifiers ( ) , f ) ; Field Visitor fv = cv . visit Field ( access , name , desc , sig , value ) ; if ( fv != null ) { generate Annotations ( fv , f ) ; generate Attributes ( fv , f ) ; fv . visit End ( ) ; } } }
public Result File Reader ( Problem problem , File file ) throws IO Exception { super ( ) ; this . problem = problem ; reader = new Buffered Reader ( new File Reader ( file ) ) ; line = reader . read Line ( ) ; }
@ Action ( value = STR_ ) @ Validation Error Page ( value = ERROR ) @ Skip Validation public String view Challan ( ) { if ( challan Id == null ) receipt Header = receipt Header Service . find By Id ( receipt Id , false ) ; else receipt Header = ( Receipt Header ) persistence Service . find By Named Query ( Collection Constants . QUERY RECEIPT BY CHALLANID , Long . value Of ( challan Id ) ) ; set Login Dept ( ) ; load Receipt Details ( ) ; return VIEW ; }
private static Double compute Angle ( final Geo Point point , final double sin Latitude , final double cos Latitude , final double sin Longitude , final double cos Longitude ) { final double x 1 = point . x * cos Longitude + point . y * sin Longitude ; final double y 1 = - point . x * sin Longitude + point . y * cos Longitude ; final double z 1 = point . z ; final double y 2 = y 1 ; final double z 2 = - x 1 * sin Latitude + z 1 * cos Latitude ; if ( Math . sqrt ( y 2 * y 2 + z 2 * z 2 ) < Vector . MINIMUM RESOLUTION ) { return null ; } return Math . atan 2 ( z 2 , y 2 ) ; }
private void find Large Car Item Sets ( ) throws Exception { Array List < Object > k Minus One Sets , k Sets ; Hashtable < Item Set , Integer > hashtable ; int nec Support , i = NUM_ ; double next Min Support = m min Support * m instances . num Instances ( ) ; double next Max Support = m upper Bound Min Support * m instances . num Instances ( ) ; if ( Math . rint ( next Min Support ) == next Min Support ) { nec Support = ( int ) next Min Support ; } else { nec Support = Math . round ( ( float ) ( next Min Support + NUM_ ) ) ; } if ( Math . rint ( next Max Support ) == next Max Support ) { } else { Math . round ( ( float ) ( next Max Support + NUM_ ) ) ; } k Sets = Labeled Item Set . singletons ( m instances , m only Class ) ; Labeled Item Set . up Date Counters ( k Sets , m instances , m only Class ) ; k Sets = Labeled Item Set . delete Item Sets ( k Sets , nec Support , m instances . num Instances ( ) ) ; if ( k Sets . size ( ) == NUM_ ) { return ; } do { m Ls . add ( k Sets ) ; k Minus One Sets = k Sets ; k Sets = Labeled Item Set . merge All Item Sets ( k Minus One Sets , i , m instances . num Instances ( ) ) ; hashtable = Labeled Item Set . get Hashtable ( k Minus One Sets , k Minus One Sets . size ( ) ) ; k Sets = Labeled Item Set . prune Item Sets ( k Sets , hashtable ) ; Labeled Item Set . up Date Counters ( k Sets , m instances , m only Class ) ; k Sets = Labeled Item Set . delete Item Sets ( k Sets , nec Support , m instances . num Instances ( ) ) ; i ++ ; } while ( k Sets . size ( ) > NUM_ ) ; }
public void store ( Table metadata ) { String key = generate Key ( metadata . get Schema ( ) , metadata . get Name ( ) ) ; cache . put ( key , metadata ) ; }
public final String translate ( Char Sequence input ) { if ( input == null ) { return null ; } try { String Writer writer = new String Writer ( input . length ( ) * NUM_ ) ; translate ( input , writer ) ; return writer . to String ( ) ; } catch ( IO Exception ioe ) { throw new Runtime Exception ( ioe ) ; } }
@ Objective C Name ( STR_ ) private Json Element deep Copy ( Json Element element ) { try { return gson . from Json ( gson . to Json ( element , Json Element . class ) , Json Element . class ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public static Hash merge ( Hash a , Hash b ) { try { Message Digest digest = Message Digest . get Instance ( STR_ ) ; digest . update ( a . bytes ) ; return Hash . create From Safe Array ( digest . digest ( digest . digest ( b . bytes ) ) ) ; } catch ( No Such Algorithm Exception e ) { throw new Runtime Exception ( e ) ; } }
public boolean create Bookmark Rollback Step ( String step Id ) { Workflow Step Completer . step Executing ( step Id ) ; log . info ( String . format ( STR_ , step Id ) ) ; Workflow Step Completer . step Succeded ( step Id ) ; return true ; }
public boolean disable Image Access Single Step ( URI rp System Id , URI export Group URI , List < URI > snapshots , boolean is Rollback , String token ) throws Controller Exception { try { Workflow Step Completer . step Executing ( token ) ; disable Image For Snapshots ( rp System Id , snapshots , is Rollback , false , token ) ; Workflow Step Completer . step Succeded ( token ) ; } catch ( Exception e ) { log . error ( String . format ( STR_ , String . value Of ( rp System Id ) , String . value Of ( export Group URI ) ) ) ; return step Failed ( token , e , STR_ ) ; } return true ; }
public static Abstract Statistics Collector new Instance ( final Properties properties ) { final int interval = Integer . parse Int ( properties . get Property ( Options . PERFORMANCE COUNTERS SAMPLE INTERVAL , Options . DEFAULT PERFORMANCE COUNTERS SAMPLE INTERVAL ) ) ; if ( interval <= NUM_ ) throw new Illegal Argument Exception ( ) ; final String process Name = properties . get Property ( Options . PROCESS NAME ) ; if ( process Name == null ) throw new Illegal Argument Exception ( STR_ + Options . PROCESS NAME ) ; if ( System Util . is Linux ( ) ) { return new Statistics Collector For Linux ( interval , process Name ) ; } else if ( System Util . is Windows ( ) ) { return new Statistics Collector For Windows ( interval , process Name ) ; } else if ( System Util . is OSX ( ) ) { return new Statistics Collector For OSX ( interval , process Name ) ; } else { throw new Unsupported Operation Exception ( STR_ + System . get Property ( STR_ ) ) ; } }
public static void write Config File ( Output Stream output Stream , File search Dir ) throws SQL Exception , IO Exception { List < Class < ? > > class List = new Array List < Class < ? > > ( ) ; find Annotated Classes ( class List , search Dir , NUM_ ) ; write Config File ( output Stream , class List . to Array ( new Class [ class List . size ( ) ] ) ) ; }
public static final < R > R dispatch ( Class clazz , Object instance , String method , Object [ ] args , Class [ ] types ) throws No Such Method Exception { try { java . lang . reflect . Method m = clazz . get Declared Method ( method , types ) ; m . set Accessible ( true ) ; return ( R ) m . invoke ( instance , args ) ; } catch ( No Such Method Exception x ) { if ( clazz . get Superclass ( ) != null ) return ( R ) dispatch ( clazz . get Superclass ( ) , instance , method , args , types ) ; else throw x ; } catch ( Exception x ) { throw new Runtime Exception ( x ) ; } }
public void reset ( ) { m refs . remove All Elements ( ) ; }
private static String [ ] make Column Names ( Column Type types [ ] ) { String [ ] header = new String [ types . length ] ; for ( int i = NUM_ ; i < types . length ; i ++ ) { header [ i ] = STR_ + i ; } return header ; }
private Map < URI , Storage System > build Array Map ( List < Volume Descriptor > descriptors , Volume Descriptor . Type type ) { Map < URI , Storage System > array Map = new Hash Map < URI , Storage System > ( ) ; if ( type != null ) { descriptors = Volume Descriptor . filter By Type ( descriptors , new Volume Descriptor . Type [ ] { type } , new Volume Descriptor . Type [ ] { } ) ; } for ( Volume Descriptor desc : descriptors ) { if ( array Map . contains Key ( desc . get Device URI ( ) ) == false ) { Storage System array = get Data Object ( Storage System . class , desc . get Device URI ( ) , db Client ) ; array Map . put ( desc . get Device URI ( ) , array ) ; } } return array Map ; }
@ Override protected J Popup Menu create Popup Menu ( boolean properties , boolean save , boolean print , boolean zoom ) { J Popup Menu result = super . create Popup Menu ( properties , save , print , zoom ) ; int zoom In Index = get Popup Menu Item ( result , localization Resources . get String ( STR_ ) ) ; int zoom Out Index = get Popup Menu Item ( result , localization Resources . get String ( STR_ ) ) ; int auto Index = get Popup Menu Item ( result , localization Resources . get String ( STR_ ) ) ; if ( zoom ) { J Menu Item zoom In = new J Menu Item ( localization Resources . get String ( STR_ ) ) ; zoom In . set Action Command ( POLAR ZOOM IN ACTION COMMAND ) ; zoom In . add Action Listener ( this ) ; J Menu Item zoom Out = new J Menu Item ( localization Resources . get String ( STR_ ) ) ; zoom Out . set Action Command ( POLAR ZOOM OUT ACTION COMMAND ) ; zoom Out . add Action Listener ( this ) ; J Menu Item auto = new J Menu Item ( localization Resources . get String ( STR_ ) ) ; auto . set Action Command ( POLAR AUTO RANGE ACTION COMMAND ) ; auto . add Action Listener ( this ) ; if ( zoom In Index != - NUM_ ) { result . remove ( zoom In Index ) ; } else { zoom In Index = result . get Component Count ( ) - NUM_ ; } result . add ( zoom In , zoom In Index ) ; if ( zoom Out Index != - NUM_ ) { result . remove ( zoom Out Index ) ; } else { zoom Out Index = zoom In Index + NUM_ ; } result . add ( zoom Out , zoom Out Index ) ; if ( auto Index != - NUM_ ) { result . remove ( auto Index ) ; } else { auto Index = zoom Out Index + NUM_ ; } result . add ( auto , auto Index ) ; } return result ; }
private void balance ( ) { balance Heights ( ) ; }
private String normilize ( String path ) { if ( ! U . is Windows ( ) ) return path ; return path . replace ( STR_ , File . separator Char ) ; }
public static void create Index ( Connection conn , String schema , String table , String column List ) throws SQL Exception { init ( conn ) ; Prepared Statement prep = conn . prepare Statement ( STR_ + SCHEMA + STR_ ) ; prep . set String ( NUM_ , schema ) ; prep . set String ( NUM_ , table ) ; prep . set String ( NUM_ , column List ) ; prep . execute ( ) ; create Trigger ( conn , schema , table ) ; index Existing Rows ( conn , schema , table ) ; }
private static Object read Field Value ( final Object obj , final Field field ) { try { return field . get ( obj ) ; } catch ( Exception ex ) { throw new JBBP Exception ( STR_ + field + STR_ , ex ) ; } }
public void add On Tab Selected Listener ( On Tab Selected Listener listener ) { if ( listener != null ) { m Listeners . add ( listener ) ; } }
public void retrieve List ( String path , List < FTP File > entries , int limit , FTP File Entry Parser parser ) throws IO Exception , Ftp Exception Can Not Have Data Connection , Ftp Exception Unknown Forced Data Close , Ftp Exception Control Closed By Forced Data Close { Socket socket = open Passive Data Connection ( FTP Command . LIST , path ) ; if ( socket == null ) throw new Ftp Exception Can Not Have Data Connection ( STR_ + ( ( path == null ) ? STR_ : path ) ) ; Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( socket . get Input Stream ( ) ) ) ; int count = NUM_ ; String line = parser . read Next Entry ( reader ) ; while ( line != null ) { FTP File ftp File = parser . parse FTP Entry ( line ) ; if ( ftp File == null ) { line = parser . read Next Entry ( reader ) ; continue ; } entries . add ( ftp File ) ; count += line . length ( ) ; if ( limit >= NUM_ && count > limit ) { break ; } line = parser . read Next Entry ( reader ) ; } socket . close ( ) ; try { int reply = get Reply ( ) ; if ( ! not Bad Reply ( reply ) ) throw new Ftp Exception Unknown Forced Data Close ( get Reply String ( ) ) ; } catch ( FTP Connection Closed Exception e ) { throw new Ftp Exception Control Closed By Forced Data Close ( e . get Message ( ) ) ; } }
public void recompose ( Vector recomposable Elements ) throws Transformer Exception { int n = get Include Count Composed ( ) ; for ( int i = - NUM_ ; i < n ; i ++ ) { Stylesheet included = get Include Composed ( i ) ; int s = included . get Output Count ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Output ( j ) ) ; } s = included . get Attribute Set Count ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Attribute Set ( j ) ) ; } s = included . get Decimal Format Count ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Decimal Format ( j ) ) ; } s = included . get Key Count ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Key ( j ) ) ; } s = included . get Namespace Alias Count ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Namespace Alias ( j ) ) ; } s = included . get Template Count ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Template ( j ) ) ; } s = included . get Variable Or Param Count ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Variable Or Param ( j ) ) ; } s = included . get Strip Space Count ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Strip Space ( j ) ) ; } s = included . get Preserve Space Count ( ) ; for ( int j = NUM_ ; j < s ; j ++ ) { recomposable Elements . add Element ( included . get Preserve Space ( j ) ) ; } } }
public static String python Escape ( String s ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; default : sb . append ( c ) ; } } return sb . to String ( ) ; }
public boolean textbox Key Typed ( char p 146201 1 , int p 146201 2 ) { if ( ! field 146213 o ) return false ; else switch ( p 146201 1 ) { case NUM_ : func 146202 e ( ) ; func 146199 i ( NUM_ ) ; return true ; case NUM_ : Gui Screen . set Clipboard String ( func 146207 c ( ) ) ; return true ; case NUM_ : if ( field 146226 p ) func 146191 b ( Gui Screen . get Clipboard String ( ) ) ; return true ; case NUM_ : Gui Screen . set Clipboard String ( func 146207 c ( ) ) ; if ( field 146226 p ) func 146191 b ( STR_ ) ; return true ; default : switch ( p 146201 2 ) { case NUM_ : if ( Gui Screen . is Ctrl Key Down ( ) ) { if ( field 146226 p ) func 146177 a ( - NUM_ ) ; } else if ( field 146226 p ) func 146175 b ( - NUM_ ) ; return true ; case NUM_ : if ( Gui Screen . is Shift Key Down ( ) ) func 146199 i ( NUM_ ) ; else func 146196 d ( ) ; return true ; case NUM_ : if ( Gui Screen . is Shift Key Down ( ) ) { if ( Gui Screen . is Ctrl Key Down ( ) ) func 146199 i ( func 146183 a ( - NUM_ , func 146186 n ( ) ) ) ; else func 146199 i ( func 146186 n ( ) - NUM_ ) ; } else if ( Gui Screen . is Ctrl Key Down ( ) ) func 146190 e ( func 146187 c ( - NUM_ ) ) ; else func 146182 d ( - NUM_ ) ; return true ; case NUM_ : if ( Gui Screen . is Shift Key Down ( ) ) { if ( Gui Screen . is Ctrl Key Down ( ) ) func 146199 i ( func 146183 a ( NUM_ , func 146186 n ( ) ) ) ; else func 146199 i ( func 146186 n ( ) + NUM_ ) ; } else if ( Gui Screen . is Ctrl Key Down ( ) ) func 146190 e ( func 146187 c ( NUM_ ) ) ; else func 146182 d ( NUM_ ) ; return true ; case NUM_ : if ( Gui Screen . is Shift Key Down ( ) ) func 146199 i ( field 146216 j . length ( ) ) ; else func 146202 e ( ) ; return true ; case NUM_ : if ( Gui Screen . is Ctrl Key Down ( ) ) { if ( field 146226 p ) func 146177 a ( NUM_ ) ; } else if ( field 146226 p ) func 146175 b ( NUM_ ) ; return true ; default : if ( Chat Allowed Characters . is Allowed Character ( p 146201 1 ) ) { if ( field 146226 p ) func 146191 b ( Character . to String ( p 146201 1 ) ) ; return true ; } else return false ; } } }
protected void wait Flush ( ) { if ( done Lock == null ) return ; try { if ( NS Logger . debug Logger ) Log . v ( STR_ , String . format ( STR_ , sequence Number ) ) ; done Condition . await ( ) ; } catch ( Interrupted Exception e ) { } finally { done Lock . unlock ( ) ; } }
public Abstract Script Command ( Configuration configuration , String resource Path ) { this . configuration = configuration ; this . resource Path = resource Path ; this . resource Utils = new Resource Utils ( ) ; this . ant Utils = new Ant Utils ( ) ; }
public static double trainer Level To Max Poke Level ( int trainer Level ) { return Math . min ( trainer Level + NUM_ , NUM_ ) ; }
protected void add Explosion Info ( int rank , int file , int from Square , List < Atomic Explosion Info > explosion Info ) { if ( Game Utils . is In Bounds ( rank , file ) ) { int square = Game Utils . get Square ( rank , file ) ; if ( square != from Square && board [ square ] != EMPTY && board [ square ] != PAWN ) { Atomic Explosion Info info = new Atomic Explosion Info ( ) ; info . color = ( get Color BB ( WHITE ) & get Bitboard ( square ) ) != NUM_ ? WHITE : BLACK ; info . piece = board [ square ] ; info . square = square ; explosion Info . add ( info ) ; } } }
public static String decode Email ( String user Email ) { return user Email . replace ( STR_ , STR_ ) ; }
public void do Prepare ( ) { synchronized ( LAYERWORKER LOCK ) { if ( layer Worker Queue ) { return ; } I Swing Worker < OM Graphic List > current Layer Worker = layer Worker ; if ( current Layer Worker != null ) { layer Worker Queue = true ; if ( interruptable ) { current Layer Worker . interrupt ( ) ; } return ; } set Layer Worker ( create Layer Worker ( ) ) ; } }
public Selection Builder reset ( ) { table Name = null ; projection Map . clear ( ) ; selection . set Length ( NUM_ ) ; selection Args . clear ( ) ; group By . clear ( ) ; return this ; }
private void parse Config ( ) throws Parser Configuration Exception , SAX Exception , IO Exception { Document Builder Factory factory = Document Builder Factory . new Instance ( ) ; factory . set Ignoring Comments ( true ) ; Document Builder builder = factory . new Document Builder ( ) ; Document dom Tree = null ; if ( file Name . starts With ( STR_ ) || file Name . starts With ( STR_ ) ) { if ( ! Local File Utils . validate External Filename ( file Name , true ) ) throw new IO Exception ( STR_ ) ; File System DFS = File System . get ( Configuration Manager . get Cached Job Conf ( ) ) ; Path config File Path = new Path ( file Name ) ; dom Tree = builder . parse ( DFS . open ( config File Path ) ) ; } else { if ( ! Local File Utils . validate External Filename ( file Name , false ) ) throw new IO Exception ( STR_ ) ; dom Tree = builder . parse ( file Name ) ; } xml Root = dom Tree . get Document Element ( ) ; }
private static float [ ] derive Text Bounds Anchor Offsets ( Graphics 2 D g 2 , String text , Text Anchor anchor , Rectangle 2 D text Bounds ) { float [ ] result = new float [ NUM_ ] ; Font Render Context frc = g 2 . get Font Render Context ( ) ; Font f = g 2 . get Font ( ) ; Font Metrics fm = g 2 . get Font Metrics ( f ) ; Rectangle 2 D bounds = get Text Bounds ( text , fm ) ; Line Metrics metrics = f . get Line Metrics ( text , frc ) ; float ascent = metrics . get Ascent ( ) ; result [ NUM_ ] = - ascent ; float half Ascent = ascent / NUM_ ; float descent = metrics . get Descent ( ) ; float leading = metrics . get Leading ( ) ; float x Adj = NUM_ ; float y Adj = NUM_ ; if ( anchor . is Horizontal Center ( ) ) { x Adj = ( float ) - bounds . get Width ( ) / NUM_ ; } else if ( anchor . is Right ( ) ) { x Adj = ( float ) - bounds . get Width ( ) ; } if ( anchor . is Top ( ) ) { y Adj = - descent - leading + ( float ) bounds . get Height ( ) ; } else if ( anchor . is Half Ascent ( ) ) { y Adj = half Ascent ; } else if ( anchor . is Horizontal Center ( ) ) { y Adj = - descent - leading + ( float ) ( bounds . get Height ( ) / NUM_ ) ; } else if ( anchor . is Baseline ( ) ) { y Adj = NUM_ ; } else if ( anchor . is Bottom ( ) ) { y Adj = - metrics . get Descent ( ) - metrics . get Leading ( ) ; } if ( text Bounds != null ) { text Bounds . set Rect ( bounds ) ; } result [ NUM_ ] = x Adj ; result [ NUM_ ] = y Adj ; return result ; }
public static final void print Current Thread Cpu Time ( ) { print Thread Cpu Time ( Thread . current Thread ( ) ) ; }
public void register Font Metrics ( String name , Font font , float line Height ) { Html Font Metrics metrics = get Font Metrics ( font ) ; font Metrics . put ( font , new Html Font Metrics ( font , line Height , metrics . emwidth ) ) ; }
private static void add Common Permissions ( Permissions permissions ) { permissions . add ( new Audio Permission ( STR_ ) ) ; permissions . add ( new AWT Permission ( STR_ ) ) ; permissions . add ( new AWT Permission ( STR_ ) ) ; permissions . add ( new AWT Permission ( STR_ ) ) ; permissions . add ( new Logging Permission ( STR_ , STR_ ) ) ; permissions . add ( new Socket Permission ( STR_ , STR_ ) ) ; permissions . add ( new URL Permission ( STR_ , STR_ ) ) ; permissions . add ( new URL Permission ( STR_ , STR_ ) ) ; permissions . add ( new Runtime Permission ( STR_ ) ) ; permissions . add ( new Runtime Permission ( STR_ ) ) ; permissions . add ( new Runtime Permission ( STR_ ) ) ; permissions . add ( new Runtime Permission ( STR_ ) ) ; permissions . add ( new Runtime Permission ( STR_ ) ) ; permissions . add ( new Runtime Permission ( STR_ ) ) ; permissions . add ( new Runtime Permission ( STR_ ) ) ; }
@ Override public void encode Begin ( final Faces Context context ) throws IO Exception { super . encode Begin ( context ) ; }
@ Override public VH on Create View Holder ( View Group parent , int view Type ) { if ( view Type == TYPE ITEM ) { return on Create Item View Holder ( parent ) ; } else if ( view Type == TYPE HEADER ) { return on Create Header View Holder ( parent ) ; } throw new Runtime Exception ( STR_ + view Type ) ; }
@ Override public void flip ( W Component Peer peer , Component target , Volatile Image back Buffer , int x 1 , int y 1 , int x 2 , int y 2 , Buffer Capabilities . Flip Contents flip Action ) { if ( flip Action == Buffer Capabilities . Flip Contents . COPIED ) { Surface Manager vsm = Surface Manager . get Manager ( back Buffer ) ; Surface Data sd = vsm . get Primary Surface Data ( ) ; if ( sd instanceof WGLV Sync Off Screen Surface Data ) { WGLV Sync Off Screen Surface Data vsd = ( WGLV Sync Off Screen Surface Data ) sd ; Surface Data bbsd = vsd . get Flip Surface ( ) ; Graphics 2 D bbg = new Sun Graphics 2 D ( bbsd , Color . black , Color . white , null ) ; try { bbg . draw Image ( back Buffer , NUM_ , NUM_ , null ) ; } finally { bbg . dispose ( ) ; } } else { Graphics g = peer . get Graphics ( ) ; try { g . draw Image ( back Buffer , x 1 , y 1 , x 2 , y 2 , x 1 , y 1 , x 2 , y 2 , null ) ; } finally { g . dispose ( ) ; } return ; } } else if ( flip Action == Buffer Capabilities . Flip Contents . PRIOR ) { return ; } OGL Surface Data . swap Buffers ( peer . get Data ( ) ) ; if ( flip Action == Buffer Capabilities . Flip Contents . BACKGROUND ) { Graphics g = back Buffer . get Graphics ( ) ; try { g . set Color ( target . get Background ( ) ) ; g . fill Rect ( NUM_ , NUM_ , back Buffer . get Width ( ) , back Buffer . get Height ( ) ) ; } finally { g . dispose ( ) ; } } }
public String add Listener ( Service Listener listener ) { return ( org Config Impl . add Listener ( listener ) ) ; }
public Row create Row ( Value [ ] data , int memory ) { return row Factory . create Row ( data , memory ) ; }
@ Override public boolean equals ( Object object ) { if ( object == null ) { return false ; } if ( object == this ) { return true ; } if ( super . equals ( object ) && object instanceof Middle Pin Needle ) { return true ; } return false ; }
private void execute Hooks ( List < Abstract Hook > hooks , Event Data [ ] events ) { if ( hooks != null ) { for ( Abstract Hook hook : hooks ) { Hook And Events hook And Events = new Hook And Events ( hook , events ) ; hook Router . route ( hook And Events , get Self ( ) ) ; } } }
private int decode Channel Sf Idx ( int ch Num ) { Channel chan = ctx . channels [ ch Num ] ; Channel ref Chan = ctx . channels [ NUM_ ] ; int weight Idx = NUM_ ; chan . fill Mode = NUM_ ; switch ( br . read ( NUM_ ) ) { case NUM_ : for ( int i = NUM_ ; i < ctx . used Quant Units ; i ++ ) { chan . qu Sf Idx [ i ] = br . read ( NUM_ ) ; } break ; case NUM_ : if ( ch Num > NUM_ ) { VLC vlc Tab = sf vlc tabs [ br . read ( NUM_ ) ] ; for ( int i = NUM_ ; i < ctx . used Quant Units ; i ++ ) { int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Sf Idx [ i ] = ( ref Chan . qu Sf Idx [ i ] + delta ) & NUM_ ; } } else { weight Idx = br . read ( NUM_ ) ; if ( weight Idx == NUM_ ) { unpack Sf Vq Shape ( chan . qu Sf Idx , ctx . used Quant Units ) ; int num Long Vals = br . read ( NUM_ ) ; int delta Bits = br . read ( NUM_ ) ; int min Val = br . read ( NUM_ ) - NUM_ ; for ( int i = NUM_ ; i < num Long Vals ; i ++ ) { chan . qu Sf Idx [ i ] = ( chan . qu Sf Idx [ i ] + br . read ( NUM_ ) - NUM_ ) & NUM_ ; } for ( int i = num Long Vals ; i < ctx . used Quant Units ; i ++ ) { chan . qu Sf Idx [ i ] = ( chan . qu Sf Idx [ i ] + min Val + get Delta ( delta Bits ) ) & NUM_ ; } } else { int num Long Vals = br . read ( NUM_ ) ; int delta Bits = br . read ( NUM_ ) ; int min Val = br . read ( NUM_ ) ; if ( num Long Vals > ctx . used Quant Units || delta Bits == NUM_ ) { log . error ( String . format ( STR_ ) ) ; return AT 3 P ERROR ; } for ( int i = NUM_ ; i < num Long Vals ; i ++ ) { chan . qu Sf Idx [ i ] = br . read ( NUM_ ) ; } for ( int i = num Long Vals ; i < ctx . used Quant Units ; i ++ ) { chan . qu Sf Idx [ i ] = ( min Val + get Delta ( delta Bits ) ) & NUM_ ; } } } break ; case NUM_ : if ( ch Num > NUM_ ) { VLC vlc Tab = sf vlc tabs [ br . read ( NUM_ ) ] ; int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Sf Idx [ NUM_ ] = ( ref Chan . qu Sf Idx [ NUM_ ] + delta ) & NUM_ ; for ( int i = NUM_ ; i < ctx . used Quant Units ; i ++ ) { int diff = ref Chan . qu Sf Idx [ i ] - ref Chan . qu Sf Idx [ i - NUM_ ] ; delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Sf Idx [ i ] = ( chan . qu Sf Idx [ i - NUM_ ] + diff + delta ) & NUM_ ; } } else if ( chan . num Coded Vals > NUM_ ) { VLC vlc Tab = sf vlc tabs [ br . read ( NUM_ ) + NUM_ ] ; unpack Sf Vq Shape ( chan . qu Sf Idx , ctx . used Quant Units ) ; for ( int i = NUM_ ; i < ctx . used Quant Units ; i ++ ) { int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Sf Idx [ i ] = ( chan . qu Sf Idx [ i ] + sign Extend ( delta , NUM_ ) ) & NUM_ ; } } break ; case NUM_ : if ( ch Num > NUM_ ) { for ( int i = NUM_ ; i < ctx . used Quant Units ; i ++ ) { chan . qu Sf Idx [ i ] = ref Chan . qu Sf Idx [ i ] ; } } else { weight Idx = br . read ( NUM_ ) ; int vlc Sel = br . read ( NUM_ ) ; VLC vlc Tab = sf vlc tabs [ vlc Sel ] ; if ( weight Idx == NUM_ ) { vlc Tab = sf vlc tabs [ vlc Sel + NUM_ ] ; unpack Sf Vq Shape ( chan . qu Sf Idx , ctx . used Quant Units ) ; int diff = ( br . read ( NUM_ ) + NUM_ ) & NUM_ ; chan . qu Sf Idx [ NUM_ ] = ( chan . qu Sf Idx [ NUM_ ] + diff ) & NUM_ ; for ( int i = NUM_ ; i < ctx . used Quant Units ; i ++ ) { int delta = vlc Tab . get VLC 2 ( br ) ; diff = ( diff + sign Extend ( delta , NUM_ ) ) & NUM_ ; chan . qu Sf Idx [ i ] = ( diff + chan . qu Sf Idx [ i ] ) & NUM_ ; } } else { chan . qu Sf Idx [ NUM_ ] = br . read ( NUM_ ) ; for ( int i = NUM_ ; i < ctx . used Quant Units ; i ++ ) { int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Sf Idx [ i ] = ( chan . qu Sf Idx [ i - NUM_ ] + delta ) & NUM_ ; } } } break ; } if ( weight Idx != NUM_ && weight Idx < NUM_ ) { return substract Sf Weights ( chan , weight Idx ) ; } return NUM_ ; }
public Builder check And Unpack File ( String name In Apk , String dest File Name ) { unpackers . add ( new Content Checking Unpacker ( name In Apk , dest File Name ) ) ; return this ; }
public JSON Buffer append Newline ( ) { buffer . append ( STR_ ) ; return this ; }
public void insert Sleep Time ( ) { Script Step sleep Time Script Step = Script Step Factory . create Sleep Time ( get Sleep Time ( ) ) ; steps . add ( get Insert Index ( ) , sleep Time Script Step ) ; sleep Time = STR_ ; reindex Script Steps ( ) ; }
public void tick ( ) { Iterator < Satellite Base > iterator = ticking Satallites . iterator ( ) ; while ( iterator . has Next ( ) ) { Satellite Base satallite = iterator . next ( ) ; satallite . tick Entity ( ) ; } }
private Class < ? > define Structure ( Field destination , Field source ) { Class < ? > destination Class = destination . get Type ( ) ; Class < ? > source Class = source . get Type ( ) ; Class < ? > result = null ; if ( destination Class . is Interface ( ) ) if ( source Class . is Interface ( ) ) result = ( Class < ? > ) implementation Class . get ( destination Class . get Name ( ) ) ; else { Class < ? > source Interface = source Class . get Interfaces ( ) [ NUM_ ] ; if ( destination Class == source Interface ) result = source Class ; else result = ( Class < ? > ) implementation Class . get ( destination Class . get Name ( ) ) ; } else result = destination Class ; return result ; }
private static Dfareporting initialize Dfareporting ( ) throws Exception { Credential credential = authorize ( ) ; return new Dfareporting ( http Transport , JSON FACTORY , credential ) ; }
public void reset ( ) throws IO Exception { m structure = null ; m XML Instances = null ; set Retrieval ( NONE ) ; if ( m File != null ) { set File ( new File ( m File ) ) ; } else if ( ( m URL != null ) && ! m URL . equals ( STR_ ) ) { set URL ( m URL ) ; } }
static void silently Close ( Closeable closeable ) { try { if ( closeable != null ) { closeable . close ( ) ; } } catch ( IO Exception e ) { } }
public static String encode XML ( String text ) { if ( text == null ) { return null ; } final String Builder result = new String Builder ( ) ; final String Character Iterator iterator = new String Character Iterator ( text ) ; char character = iterator . current ( ) ; while ( character != Character Iterator . DONE ) { if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else if ( character == STR_ ) { result . append ( STR_ ) ; } else { result . append ( character ) ; } character = iterator . next ( ) ; } return result . to String ( ) ; }
public void schedule ( Timer Task task , Date time ) { sched ( task , time . get Time ( ) , NUM_ ) ; }
public void run Unsafe ( Fawe Queue queue , Runnable run ) { queue . start Set ( true ) ; try { run . run ( ) ; } catch ( Throwable e ) { e . print Stack Trace ( ) ; } queue . end Set ( true ) ; }
public Float read ( String value ) { return Float . value Of ( value ) ; }
private String process Node Name ( Tree node ) { String code = node . get Text ( ) ; try { Node Name node Name = Node Name . find By Code ( code ) ; return node Name . get Name ( ) ; } catch ( Node Name For Code Does Not Exist Exception e ) { } return code ; }
public static I Proposal Computer new With Type Proposal Computer ( Content Assist Request content Assist Request , I Java Project java Project ) { IDOM Attr attribute = Xml Content Assist Utilities . get Attribute ( content Assist Request ) ; if ( attribute == null || attribute . get Owner Element ( ) == null ) { return null ; } if ( ! attribute . equals ( Ui Binder Xml Model Utilities . get Type Attribute ( attribute . get Owner Element ( ) ) ) ) { return null ; } String attr Value = Xml Content Assist Utilities . get Attribute Value Using Match String ( content Assist Request ) ; return new Code Complete Proposal Computer ( new int [ ] { Completion Proposal . TYPE REF , Completion Proposal . PACKAGE REF } , java Project , attr Value , Xml Content Assist Utilities . get Attribute Value Offset ( content Assist Request ) , attr Value . length ( ) , null , false ) ; }
@ Override public < T > T instance ( Injection Point < T > ip ) { Objects . require Non Null ( ip ) ; Provider < T > provider = provider ( ip ) ; if ( provider != null ) { return provider . get ( ) ; } else { return null ; } }
public static void over Scroll By ( final Pull To Refresh Base < ? > view , final int delta X , final int scroll X , final int delta Y , final int scroll Y , final int scroll Range , final int fuzzy Threshold , final float scale Factor , final boolean is Touch Event ) { final int delta Value , current Scroll Value , scroll Value ; switch ( view . get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : delta Value = delta X ; scroll Value = scroll X ; current Scroll Value = view . get Scroll X ( ) ; break ; case VERTICAL : default : delta Value = delta Y ; scroll Value = scroll Y ; current Scroll Value = view . get Scroll Y ( ) ; break ; } if ( view . is Pull To Refresh Over Scroll Enabled ( ) && ! view . is Refreshing ( ) ) { final Mode mode = view . get Mode ( ) ; if ( mode . permits Pull To Refresh ( ) && ! is Touch Event && delta Value != NUM_ ) { final int new Scroll Value = ( delta Value + scroll Value ) ; if ( Pull To Refresh Base . DEBUG ) { Log . d ( LOG TAG , STR_ + delta X + STR_ + scroll X + STR_ + delta Y + STR_ + scroll Y + STR_ + new Scroll Value + STR_ + scroll Range + STR_ + current Scroll Value ) ; } if ( new Scroll Value < ( NUM_ - fuzzy Threshold ) ) { if ( mode . show Header Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( Pull To Refresh Base . State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value ) ) ) ; } } else if ( new Scroll Value > ( scroll Range + fuzzy Threshold ) ) { if ( mode . show Footer Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value - scroll Range ) ) ) ; } } else if ( Math . abs ( new Scroll Value ) <= fuzzy Threshold || Math . abs ( new Scroll Value - scroll Range ) <= fuzzy Threshold ) { view . set State ( State . RESET ) ; } } else if ( is Touch Event && State . OVERSCROLLING == view . get State ( ) ) { view . set State ( State . RESET ) ; } } }
public static long decrypt ECB ( final byte [ ] concatenated Hash Value , final String base 64 Encrypted Turn Over Value , final Secret Key symmetric Key ) throws No Such Algorithm Exception , No Such Provider Exception , No Such Padding Exception , Invalid Key Exception , Invalid Algorithm Parameter Exception , Illegal Block Size Exception , Bad Padding Exception { final Byte Buffer byte Buffer IV = Byte Buffer . allocate ( NUM_ ) ; byte Buffer IV . put ( concatenated Hash Value ) ; final byte [ ] IV = byte Buffer IV . array ( ) ; final byte [ ] encrypted Turn Over Value = Cash Box Utils . base 64 Decode ( base 64 Encrypted Turn Over Value , false ) ; final Cipher cipher = Cipher . get Instance ( STR_ , STR_ ) ; cipher . init ( Cipher . ENCRYPT MODE , symmetric Key ) ; final byte [ ] intermediate Result = cipher . do Final ( IV ) ; final byte [ ] result = new byte [ encrypted Turn Over Value . length ] ; for ( int i = NUM_ ; i < encrypted Turn Over Value . length ; i ++ ) { result [ i ] = ( byte ) ( ( encrypted Turn Over Value [ i ] ) ^ ( intermediate Result [ i ] ) ) ; } return get Long ( result ) ; }
public static int compute Hash ( byte [ ] key , int offset , int length , int mask ) { return Math . abs ( Murmur Hash 3 . murmurhash 3 x 8632 ( key , offset , length , NUM_ ) & mask ) ; }
public void select Default Runner ( ) { String runner Name = get Default Runner Name ( ) ; if ( runner Name == null ) { return ; } for ( Environment e : system Runners ) { if ( runner Name . equals ( e . get Name ( ) ) ) { drop Down Header Widget . select Element ( resources . scope System ( ) , e . get Name ( ) ) ; return ; } } for ( Environment e : project Runners ) { if ( runner Name . equals ( e . get Name ( ) ) ) { drop Down Header Widget . select Element ( resources . scope Project ( ) , e . get Name ( ) ) ; return ; } } }
private void fire Object Added ( Binding new Bd , long change ID ) { if ( naming Listeners == null || naming Listeners . size ( ) == NUM_ ) return ; Naming Event e = new Naming Event ( event Src , Naming Event . OBJECT ADDED , new Bd , null , new Long ( change ID ) ) ; support . queue Event ( e , naming Listeners ) ; }
public static void reset Max AIO ( ) { total Max IO . set ( NUM_ ) ; }
public void stop ( ) { timer . stop ( ) ; }
protected void init View ( ) { m Month Title Paint = new Paint ( ) ; m Month Title Paint . set Fake Bold Text ( true ) ; m Month Title Paint . set Anti Alias ( true ) ; m Month Title Paint . set Text Size ( MONTH LABEL TEXT SIZE ) ; m Month Title Paint . set Typeface ( Typeface . create ( m Month Title Typeface , Typeface . BOLD ) ) ; m Month Title Paint . set Color ( m Day Text Color ) ; m Month Title Paint . set Text Align ( Align . CENTER ) ; m Month Title Paint . set Style ( Style . FILL ) ; m Selected Circle Paint = new Paint ( ) ; m Selected Circle Paint . set Fake Bold Text ( true ) ; m Selected Circle Paint . set Anti Alias ( true ) ; m Selected Circle Paint . set Color ( m Today Number Color ) ; m Selected Circle Paint . set Text Align ( Align . CENTER ) ; m Selected Circle Paint . set Style ( Style . FILL ) ; m Selected Circle Paint . set Alpha ( SELECTED CIRCLE ALPHA ) ; m Month Day Label Paint = new Paint ( ) ; m Month Day Label Paint . set Anti Alias ( true ) ; m Month Day Label Paint . set Text Size ( MONTH DAY LABEL TEXT SIZE ) ; m Month Day Label Paint . set Color ( m Month Day Text Color ) ; m Month Day Label Paint . set Typeface ( Typeface Helper . get ( get Context ( ) , STR_ ) ) ; m Month Day Label Paint . set Style ( Style . FILL ) ; m Month Day Label Paint . set Text Align ( Align . CENTER ) ; m Month Day Label Paint . set Fake Bold Text ( true ) ; m Month Num Paint = new Paint ( ) ; m Month Num Paint . set Anti Alias ( true ) ; m Month Num Paint . set Text Size ( MINI DAY NUMBER TEXT SIZE ) ; m Month Num Paint . set Style ( Style . FILL ) ; m Month Num Paint . set Text Align ( Align . CENTER ) ; m Month Num Paint . set Fake Bold Text ( false ) ; }
private static int uarimin Lt ( double value , double [ ] bv , int [ ] bvi , Binary Operator b Op ) throws DML Runtime Exception { int ix Min = NUM_ ; if ( value < bv [ NUM_ ] || value >= bv [ bv . length - NUM_ ] ) return ix Min ; int ix = Arrays . binary Search ( bv , value ) ; if ( ix < NUM_ ) ix = Math . abs ( ix ) - NUM_ ; ix Min = bvi [ ix ] + NUM_ ; return ix Min ; }
public void each Row ( Closure closure ) throws SQL Exception { while ( next ( ) ) { closure . call ( this ) ; } }
public static void r Replace Literals ( Hop hop , Local Variable Map vars ) throws DML Runtime Exception { Literal Replacement . r Replace Literals ( hop , vars ) ; }
private static void clear Stack ( int depth ) { int a = NUM_ ; int b = NUM_ ; int c = NUM_ ; int d = NUM_ ; int e = NUM_ ; int f = NUM_ ; int g = NUM_ ; int h = NUM_ ; int i = NUM_ ; int j = NUM_ ; if ( depth > NUM_ ) { clear Stack ( depth - NUM_ ) ; } }
public static String create History For Script ( Script script , long when ) { Date Format date Format = new Simple Date Format ( STR_ ) ; String Builder sb = new String Builder ( ) ; sb . append ( STR_ + script . get Name ( ) + STR_ ) ; sb . append ( STR_ + date Format . format ( new Date ( when ) ) + STR_ ) ; sb . append ( script . display Inputs ( ) ) ; sb . append ( script . display Outputs ( ) ) ; sb . append ( script . display Symbol Table ( ) ) ; return sb . to String ( ) ; }
public boolean remove Telegram Listener ( Telegram Listener rem Listener ) { return ( Telegram Listeners . remove ( rem Listener ) ) ; }
public Builder unpack File ( String name In Apk , String dest File Name ) { unpackers . add ( new Existence Checking Unpacker ( name In Apk , dest File Name ) ) ; return this ; }
private void show Popup Menu ( final Mouse Event event ) { final int index = m tabbed Pane . index At Location ( event . get X ( ) , event . get Y ( ) ) ; if ( index == - NUM_ ) { return ; } final C Graph Panel child = ( C Graph Panel ) m tabbed Pane . get Component At ( index ) ; final J Popup Menu menu = new J Graph Tab Menu ( m tabbed Pane , child ) ; menu . show ( event . get Component ( ) , event . get X ( ) , event . get Y ( ) ) ; }
public static void draw Arrow ( Graphics 2 D g , Polygon arrow , int x , int y ) { arrow . translate ( x , y ) ; g . draw ( arrow ) ; g . fill ( arrow ) ; arrow . translate ( - x , - y ) ; }
protected void draw Value Label ( Drawing Context context , Shape point , Row row , int point Index , int col ) { Comparable < ? > value = row . get ( col ) ; Format format = get Value Format ( ) ; if ( ( format == null ) && row . is Column Numeric ( col ) ) { format = Number Format . get Instance ( ) ; } String text = ( format != null ) ? format . format ( value ) : value . to String ( ) ; Color Mapper colors = get Value Color ( ) ; Paint paint = colors . get ( point Index ) ; Font font = get Value Font ( ) ; double font Size = font . get Size 2 D ( ) ; Location location = get Value Location ( ) ; double align X = get Value Alignment X ( ) ; double align Y = get Value Alignment Y ( ) ; double rotation = get Value Rotation ( ) ; double distance = get Value Distance ( ) ; if ( Math Utils . is Calculatable ( distance ) ) { distance *= font Size ; } else { distance = NUM_ ; } Label label = new Label ( text ) ; label . set Alignment X ( align X ) ; label . set Alignment Y ( align Y ) ; label . set Rotation ( rotation ) ; label . set Color ( paint ) ; label . set Font ( font ) ; Rectangle 2 D bounds Point = point . get Bounds 2 D ( ) ; Drawable Container label Container = new Drawable Container ( new Outer Edge Layout ( distance ) ) ; label Container . add ( label , location ) ; label Container . set Bounds ( bounds Point ) ; label Container . draw ( context ) ; }
private static void format ( String Buffer target , int scale , long int P , long dec P ) { if ( dec P != NUM_ ) { dec P += NUM_ ; dec P /= NUM_ ; if ( dec P >= ten Pow Double ( scale ) ) { int P ++ ; dec P -= ten Pow ( scale ) ; } if ( dec P != NUM_ ) { while ( dec P % NUM_ == NUM_ ) { dec P = dec P / NUM_ ; scale -- ; } } } target . append ( int P ) ; if ( dec P != NUM_ ) { target . append ( STR_ ) ; while ( scale > NUM_ && ( scale > NUM_ ? dec P < ten Pow Double ( -- scale ) : dec P < ten Pow ( -- scale ) ) ) { target . append ( STR_ ) ; } target . append ( dec P ) ; } }
private static synchronized String format Date As Year ( Date d ) { return format Year In . format ( d ) ; }
private Injector create Injector For ( final Class < ? > [ ] classes ) throws Initialization Error { final List < Module > modules = new Array List < > ( ) ; if ( classes != null ) { for ( final Class < ? > module : Arrays . as List ( classes ) ) { try { modules . add ( ( Module ) module . new Instance ( ) ) ; } catch ( final Reflective Operation Exception exception ) { throw new Initialization Error ( exception ) ; } } } return Guice . create Injector ( modules ) ; }
@ Suppress Warnings ( STR_ ) public long insert With On Conflict ( String table , String null Column Hack , Content Values initial Values , @ Conflict Algorithm int conflict Algorithm ) { acquire Reference ( ) ; try { String Builder sql = new String Builder ( ) ; sql . append ( STR_ ) ; sql . append ( CONFLICT VALUES [ conflict Algorithm ] ) ; sql . append ( STR_ ) ; sql . append ( table ) ; sql . append ( STR_ ) ; Object [ ] bind Args = null ; int size = ( initial Values != null && initial Values . size ( ) > NUM_ ) ? initial Values . size ( ) : NUM_ ; if ( size > NUM_ ) { bind Args = new Object [ size ] ; int i = NUM_ ; for ( Map . Entry < String , Object > entry : initial Values . value Set ( ) ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; sql . append ( entry . get Key ( ) ) ; bind Args [ i ++ ] = entry . get Value ( ) ; } sql . append ( STR_ ) ; sql . append ( STR_ ) ; for ( i = NUM_ ; i < size ; i ++ ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; } } else { sql . append ( null Column Hack + STR_ ) ; } sql . append ( STR_ ) ; SQ Lite Statement statement = new SQ Lite Statement ( this , sql . to String ( ) , bind Args ) ; try { return statement . execute Insert ( ) ; } finally { statement . close ( ) ; } } finally { release Reference ( ) ; } }
public static int levenshtein Distance ( String o 1 , String o 2 ) { if ( o 1 . length ( ) > o 2 . length ( ) ) { return levenshtein Distance ( o 2 , o 1 ) ; } final int l 1 = o 1 . length ( ) , l 2 = o 2 . length ( ) ; if ( l 1 == l 2 && o 1 . hash Code ( ) == o 2 . hash Code ( ) && o 1 . equals ( o 2 ) ) { return NUM_ ; } final int prefix = prefix Len ( o 1 , o 2 ) ; if ( prefix == l 1 || prefix == l 2 ) { return Math . abs ( l 1 - l 2 ) ; } final int postfix = postfix Len ( o 1 , o 2 , prefix ) ; return ( prefix + postfix == l 1 || prefix + postfix == l 2 ) ? Math . abs ( l 1 - l 2 ) : ( l 1 == l 2 && prefix + postfix + NUM_ == l 1 ) ? NUM_ : levenshtein Distance ( o 1 , o 2 , prefix , postfix ) ; }
private String extract Context ( String s , int position ) { String Builder sb = new String Builder ( ) ; int j = position - NUM_ ; char c = s . char At ( j ) ; while ( j > NUM_ && c != STR_ && c != STR_ ) { c = s . char At ( -- j ) ; } String ps = j > NUM_ ? s . substring ( j + NUM_ , position ) : s . substring ( NUM_ , position ) ; ps = convert ( ps ) ; sb . append ( STR_ ) ; sb . append ( ps ) ; sb . append ( STR_ ) ; sb . append ( lexicon . has Word ( ps ) ? NUM_ : NUM_ ) ; j = position + NUM_ ; c = s . char At ( j ) ; while ( j < s . length ( ) && c != STR_ && c != STR_ ) { c = s . char At ( j ++ ) ; } String ns = j < s . length ( ) ? s . substring ( position + NUM_ , j - NUM_ ) : s . substring ( position + NUM_ ) ; ns = convert ( ns ) ; sb . append ( STR_ ) ; sb . append ( ns ) ; sb . append ( STR_ ) ; sb . append ( lexicon . has Word ( ns ) ? NUM_ : NUM_ ) ; sb . append ( STR_ ) ; sb . append ( ps ) ; sb . append ( STR_ ) ; sb . append ( ns ) ; return sb . to String ( ) ; }
private Option < File > find Manifest In Parents Directories ( ) { Option < File Helper . File Holder > project Root Holder Option = file Helper . find Root Project Holder ( ) ; if ( project Root Holder Option . is Absent ( ) ) { return Option . absent ( ) ; } File Helper . File Holder project Root Holder = project Root Holder Option . get ( ) ; File project Root = project Root Holder . project Root ; File android Manifest File = new File ( project Root , STR_ ) ; for ( int i = NUM_ ; i < MAX PARENTS FROM SOURCE FOLDER ; i ++ ) { if ( android Manifest File . exists ( ) ) { break ; } android Manifest File = new File ( project Root , STR_ + File . separator + STR_ + File . separator + STR_ ) ; if ( android Manifest File . exists ( ) ) { break ; } if ( project Root . get Parent File ( ) != null ) { project Root = project Root . get Parent File ( ) ; android Manifest File = new File ( project Root , STR_ ) ; } else { break ; } } if ( ! android Manifest File . exists ( ) ) { return Option . absent ( ) ; } return Option . of ( android Manifest File ) ; }
public static Marshaller create Marshaller ( Class < ? > clazz , Namespace Prefix Mapper mpr ) throws Exception { Marshaller marshaller = create Marshaller ( clazz ) ; marshaller . set Property ( STR_ , mpr ) ; marshaller . set Property ( Marshaller . JAXB FRAGMENT , Boolean . TRUE ) ; return marshaller ; }
public static int parse Combining Class ( String s ) throws Exception { int combining = - NUM_ ; if ( s . length ( ) > NUM_ ) { combining = Integer . parse Int ( s , NUM_ ) ; } return combining ; }
public double output Value ( boolean calculate ) { if ( Double . is Na N ( m unit Value ) && calculate ) { m unit Value = m methods . output Value ( this ) ; } return m unit Value ; }
public static void print Stack Trace ( SQL Exception e ) { print Stack Trace ( e , new Print Writer ( System . err ) ) ; }
public Runtime Collector ( Algorithm algorithm , int frequency , Result File Writer writer ) { super ( algorithm , frequency , Frequency Type . EVALUATIONS ) ; this . writer = writer ; start Time = System . nano Time ( ) ; }
public synchronized OM Graphic List prepare ( ) { Projection p = get Projection ( ) ; Temporal OM Graphic List scenario Graphics = null ; OM Graphic List list = get List ( ) ; if ( p != null ) { boolean DEBUG = logger . is Loggable ( Level . FINE ) ; if ( list == null || ! ( list instanceof Temporal OM Graphic List ) ) { scenario Graphics = create Data ( ) ; if ( scenario Graphics == null ) { return null ; } } else { scenario Graphics = new Temporal OM Graphic List ( list ) ; } long current Time = get Time ( ) ; if ( DEBUG ) { logger . fine ( STR_ + get Name ( ) + STR_ + current Time ) ; } scenario Graphics . generate ( p , current Time ) ; if ( DEBUG ) { logger . fine ( STR_ + get Name ( ) + STR_ + scenario Graphics . size ( ) + STR_ ) ; } } return scenario Graphics ; }
public void add Repaint Notify ( Component c ) { m Repainters . add ( c ) ; }
private void update Contact ( int index ) { Contact contact = contacts . get ( index ) ; Intent intent = new Intent ( this , View Activity . class ) ; intent . put Extra ( STR_ , contact ) ; start Activity ( intent ) ; }
private void ask Permissions ( ) { m Permissions To Ask = get Not Granted Permissions ( ) ; if ( m Permissions To Ask . size ( ) > NUM_ && Build . VERSION . SDK INT >= Build . VERSION CODES . M ) { request Permissions ( m Permissions To Ask . to Array ( new String [ m Permissions To Ask . size ( ) ] ) , MY PERMISSION REQUEST ALL ) ; } }
protected void create User Dict Settings ( Preference Group user Dict Group ) { final Activity activity = get Activity ( ) ; user Dict Group . remove All ( ) ; final Tree Set < String > locale List = User Dictionary List . get User Dictionary Locales Set ( activity ) ; if ( locale List . is Empty ( ) ) { user Dict Group . add Preference ( create User Dictionary Preference ( null , activity ) ) ; } else { for ( String locale : locale List ) { user Dict Group . add Preference ( create User Dictionary Preference ( locale , activity ) ) ; } } }
private void load Default Exclude Pattern ( final String src Folder ) { if ( build Tool Name . equals Ignore Case ( STR_ ) ) { ignore File = Ignore File . load ( src Folder , JDK IGNORE PATTERN ) ; } else if ( build Tool Name . equals Ignore Case ( STR_ ) ) { ignore File = Ignore File . load ( src Folder , ANT IGNORE PATTERN ) ; } }
public long cnswap ( ) { return Long . parse Long ( fields [ NUM_ ] ) ; }
public void remove Item ( M model ) { remove Item ( m Datas . index Of ( model ) ) ; }
private int lookup Row Item ( Comparator < Row Item > comparator , Row Item item ) { int left = NUM_ ; int right = table . get Row Count ( ) - NUM_ ; while ( left <= right ) { int middle = ( left + right ) > > > NUM_ ; Row Item i = get Row Item ( middle ) ; int cmp = comparator . compare ( i , item ) ; if ( cmp < NUM_ ) { left = middle + NUM_ ; } else if ( cmp > NUM_ ) { right = middle - NUM_ ; } else { return middle ; } } return left ; }
public void add Notify ( ) { super . add Notify ( ) ; text Area . add Caret Listener ( listener ) ; text Area . add Property Change Listener ( R Syntax Text Area . PARSER NOTICES PROPERTY , listener ) ; text Area . add Property Change Listener ( R Syntax Text Area . MARK OCCURRENCES PROPERTY , listener ) ; text Area . add Property Change Listener ( R Syntax Text Area . MARKED OCCURRENCES CHANGED PROPERTY , listener ) ; refresh Markers ( ) ; }
protected void post Runnable ( Runnable runnable ) { if ( runnable != null ) { handler . post ( runnable ) ; } }
public Disjunction Max Weight ( Index Searcher searcher , boolean needs Scores , float boost ) throws IO Exception { super ( Disjunction Max Query . this ) ; for ( Query disjunct Query : disjuncts ) { weights . add ( searcher . create Weight ( disjunct Query , needs Scores , boost ) ) ; } this . needs Scores = needs Scores ; }
protected Record [ ] lookup ( String namestr , int type , String type Desc ) throws Temporary Resolution Exception { try { Lookup l = new Lookup ( namestr , type ) ; l . set Cache ( cache ) ; l . set Resolver ( resolver ) ; l . set Credibility ( dns Credibility ) ; l . set Search Path ( search Paths ) ; Record [ ] r = l . run ( ) ; try { if ( l . get Result ( ) == Lookup . TRY AGAIN ) { throw new Temporary Resolution Exception ( STR_ ) ; } else { return r ; } } catch ( Illegal State Exception ise ) { logger . debug ( STR_ , ise ) ; throw new Temporary Resolution Exception ( STR_ ) ; } } catch ( Text Parse Exception tpe ) { logger . error ( STR_ + namestr , tpe ) ; return null ; } }
public void add Display Changed Listener ( Display Changed Listener client ) { display Changer . add ( client ) ; }
@ Log Message Doc ( level = STR_ , message = STR_ , explanation = STR_ + STR_ , recommendation = Log Message Doc . REPORT CONTROLLER BUG ) protected void unexpected Message ( int transaction Id , Message Type type , Channel channel ) { String message = STR_ + type ; logger . warn ( STR_ , new Object [ ] { get Local Node Id String ( ) , get Remote Node Id String ( ) , message } ) ; channel . write ( get Error ( transaction Id , new Sync Exception ( message ) , type ) ) ; }
public String most Of String ( ) { String type Name = STR_ ; switch ( type ) { case BUILTIN : type Name = STR_ ; break ; case NUMBER : type Name = STR_ ; break ; case STRING : type Name = STR_ ; break ; case IDENT : type Name = STR_ ; break ; case OTHER : type Name = STR_ ; break ; case REP CHAR : type Name = STR_ ; break ; case LEFT DQUOTE : type Name = STR_ ; break ; case RIGHT DQUOTE : type Name = STR_ ; break ; case VERB : type Name = STR_ ; break ; case TEX : type Name = STR_ ; break ; } ; String str = STR_ + string + STR_ ; if ( string == null ) { str = STR_ ; } ; String result = STR_ + str + STR_ + type Name + STR_ + column + STR_ + get Width ( ) ; if ( is TLA ) { result = result + STR_ ; } ; if ( is Ambiguous ) { result = result + STR_ ; } ; return result ; }
public static Map < URI , Block Object > verify Source And Full Copy ( URI source URI , URI full Copy URI , Uri Info uri Info , Db Client db Client ) { Block Object fc Source Obj = query Full Copy Resource ( source URI , uri Info , true , db Client ) ; Volume full Copy Volume = ( Volume ) query Full Copy Resource ( full Copy URI , uri Info , false , db Client ) ; verify Volume Is Full Copy ( full Copy Volume ) ; verify Copy Is For Source ( full Copy Volume , source URI ) ; Map < URI , Block Object > resource Map = new Hash Map < URI , Block Object > ( ) ; resource Map . put ( source URI , fc Source Obj ) ; resource Map . put ( full Copy URI , full Copy Volume ) ; return resource Map ; }
public void fill Default Values ( ) { tf Learning Rate . set Text ( Double . to String ( Hebbian Threshold Rule . DEFAULT LEARNING RATE ) ) ; tf Output Threshold Momentum . set Text ( Double . to String ( Hebbian Threshold Rule . DEFAULT OUTPUT THRESHOLD MOMENTUM ) ) ; tf Output Threshold . set Text ( Double . to String ( Hebbian Threshold Rule . DEFAULT OUTPUT THRESHOLD ) ) ; is Output Threshold Sliding . set Selected ( Hebbian Threshold Rule . DEFAULT USE SLIDING OUTPUT THRESHOLD ) ; }
private void adjust Min Pref For Spanning Comps ( Dim Constraint [ ] specs , Float [ ] def Push , Flow Size Spec fss , Array List < Linked Dim Group > [ ] groups Lists ) { for ( int r = groups Lists . length - NUM_ ; r >= NUM_ ; r -- ) { Array List < Linked Dim Group > groups = groups Lists [ r ] ; for ( Linked Dim Group group : groups ) { if ( group . span == NUM_ ) continue ; int [ ] sizes = group . get Min Pref Max ( ) ; for ( int s = Layout Util . MIN ; s <= Layout Util . PREF ; s ++ ) { int c Size = sizes [ s ] ; if ( c Size == Layout Util . NOT SET ) continue ; int row Size = NUM_ ; int s Ix = ( r << NUM_ ) + NUM_ ; int len = Math . min ( ( group . span << NUM_ ) , fss . sizes . length - s Ix ) - NUM_ ; for ( int j = s Ix ; j < s Ix + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != Layout Util . NOT SET ) row Size += sz ; } if ( row Size < c Size && len > NUM_ ) { for ( int eagerness = NUM_ , new Row Size = NUM_ ; eagerness < NUM_ && new Row Size < c Size ; eagerness ++ ) new Row Size = fss . expand Sizes ( specs , def Push , c Size , s Ix , len , s , eagerness ) ; } } } } }
private final char [ ] find Buffer ( int needed ) { if ( allocator != null ) { return allocator . alloc Char Buffer ( Buffer Recycler . Char Buffer Type . TEXT BUFFER , needed ) ; } return new char [ Math . max ( needed , MIN SEGMENT LEN ) ] ; }
static String parse Method Desc return ( String s ) { int j ; j = s . last Index Of ( STR_ ) ; if ( j >= NUM_ ) { return parse Desc ( s . substring ( j + NUM_ ) , STR_ ) ; } return parse Desc ( s , STR_ ) ; }
protected void check And Send Unparsed Entity ( Unparsed Entity ent ) { if ( is Root Document ( ) ) { int index = f Unparsed Entities . index Of ( ent ) ; if ( index == - NUM_ ) { XML Resource Identifier id = new XML Resource Identifier Impl ( ent . public Id , ent . system Id , ent . base URI , ent . expanded System Id ) ; add Unparsed Entity ( ent . name , id , ent . notation , ent . augmentations ) ; if ( f Send UE And Notation Events && f DTD Handler != null ) { f DTD Handler . unparsed Entity Decl ( ent . name , id , ent . notation , ent . augmentations ) ; } } else { Unparsed Entity local Entity = ( Unparsed Entity ) f Unparsed Entities . get ( index ) ; if ( ! ent . is Duplicate ( local Entity ) ) { report Fatal Error ( STR_ , new Object [ ] { ent . name } ) ; } } } else { f Parent X Include Handler . check And Send Unparsed Entity ( ent ) ; } }
public boolean is Font Substituted ( ) { return is Font Substituted ; }
final short rlshort ( Data Input Stream dis ) throws IO Exception { short s = NUM_ ; short high , low ; s = dis . read Short ( ) ; high = ( short ) ( ( s & NUM_ ) << NUM_ ) ; low = ( short ) ( ( s & NUM_ ) > > > NUM_ ) ; s = ( short ) ( high | low ) ; return s ; }
private void register M Bean ( ) { if ( wro Configuration . is Jmx Enabled ( ) ) { try { mbean Server = get M Bean Server ( ) ; final Object Name name = get M Bean Object Name ( ) ; if ( ! mbean Server . is Registered ( name ) ) { mbean Server . register M Bean ( wro Configuration , name ) ; } } catch ( final JM Exception e ) { LOG . error ( STR_ , e ) ; } } }
@ Override public void update UI ( ) { if ( this . popup != null ) { Swing Utilities . update Component Tree UI ( this . popup ) ; } super . update UI ( ) ; }
public void init ( int max Char Code , Lex Scan scanner ) { if ( max Char Code < NUM_ ) { throw new Illegal Argument Exception ( STR_ + max Char Code + STR_ ) ; } else if ( max Char Code > max Char ) { throw new Illegal Argument Exception ( STR_ + Integer . to Hex String ( max Char Code ) + STR_ + Integer . to Hex String ( max Char ) ) ; } max Char Used = max Char Code ; this . scanner = scanner ; classes = new Array List < Int Char Set > ( ) ; classes . add ( new Int Char Set ( new Interval ( NUM_ , max Char Code ) ) ) ; }
public final Char Sequence Translator with ( Char Sequence Translator ... translators ) { Char Sequence Translator [ ] new Array = new Char Sequence Translator [ translators . length + NUM_ ] ; new Array [ NUM_ ] = this ; System . arraycopy ( translators , NUM_ , new Array , NUM_ , translators . length ) ; return new Aggregate Translator ( new Array ) ; }
public void apply Component Orientation ( Component Orientation o ) { possibly Fix Cursor ( o . is Left To Right ( ) ) ; super . apply Component Orientation ( o ) ; }
private void create Host ( Network network , List < Scale IOSDC > all SD Cs ) { List < URI > tenant Org List = db Client . query By Type ( Tenant Org . class , true ) ; Iterator < Tenant Org > it = db Client . query Iterative Objects ( Tenant Org . class , tenant Org List ) ; List < String > initiators To Add To Network = new Array List < > ( ) ; URI root Tenant = null ; while ( it . has Next ( ) ) { Tenant Org tenant Org = it . next ( ) ; if ( Tenant Org . is Root Tenant ( tenant Org ) ) { root Tenant = tenant Org . get Id ( ) ; break ; } } for ( Scale IOSDC sdc : all SD Cs ) { String ip = sdc . get Sdc Ip ( ) ; String guid = sdc . get Sdc Guid ( ) ; Host host = find By Native Guid ( guid ) ; if ( host == null ) { host = find Or Create By Ip ( root Tenant , ip , guid ) ; } Initiator initiator = create Initiator ( host , ip , sdc . get Id ( ) ) ; if ( ! network . has Endpoint ( initiator . get Initiator Port ( ) ) ) { initiators To Add To Network . add ( initiator . get Initiator Port ( ) ) ; } } if ( ! initiators To Add To Network . is Empty ( ) ) { network . add Endpoints ( initiators To Add To Network , true ) ; db Client . update And Reindex Object ( network ) ; } }
private void draw All Deployment ( Graphics g ) { Rectangle view = g . get Clip Bounds ( ) ; int draw X = ( view . x / ( int ) ( HEX WC * scale ) ) - NUM_ ; int draw Y = ( view . y / ( int ) ( HEX H * scale ) ) - NUM_ ; int draw Width = ( view . width / ( int ) ( HEX WC * scale ) ) + NUM_ ; int draw Height = ( view . height / ( int ) ( HEX H * scale ) ) + NUM_ ; I Board board = game . get Board ( ) ; for ( int i = NUM_ ; i < draw Height ; i ++ ) { for ( int j = NUM_ ; j < draw Width ; j ++ ) { Coords c = new Coords ( j + draw X , i + draw Y ) ; Enumeration < I Player > all P = game . get Players ( ) ; I Player cp ; int p Count = NUM_ ; int b Thickness = NUM_ + NUM_ / game . get No Of Players ( ) ; while ( all P . has More Elements ( ) ) { cp = all P . next Element ( ) ; if ( board . is Legal Deployment ( c , cp . get Starting Pos ( ) ) ) { Color b C = new Color ( Player Colors . get Color RGB ( cp . get Color Index ( ) ) ) ; draw Hex Border ( g , get Hex Location ( c ) , b C , ( b Thickness + NUM_ ) * p Count , b Thickness ) ; p Count ++ ; } } } } }
public static Map < String , byte [ ] > load Non Class Entries ( File jar File ) throws IO Exception { Map < String , byte [ ] > entries = new Hash Map < String , byte [ ] > ( ) ; Zip Input Stream jis = new Zip Input Stream ( new File Input Stream ( jar File ) ) ; Zip Entry entry ; while ( ( entry = jis . get Next Entry ( ) ) != null ) { try { final String name = entry . get Name ( ) ; if ( ! name . ends With ( STR_ ) && ! entry . is Directory ( ) ) { byte [ ] bytes = IO Utils . to Byte Array ( jis ) ; entries . put ( name , bytes ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } finally { jis . close Entry ( ) ; } } jis . close ( ) ; return entries ; }
@ Override public < V > Method Vault < V > new Method ( Class < ? > type , String method Name , Class < ? > [ ] param Types ) { Objects . require Non Null ( type ) ; Method Vault < V > method = new Method Rec ( type , method Name , param Types ) ; if ( method != null ) { return method ; } throw new Illegal State Exception ( L . l ( STR_ , type . get Simple Name ( ) , method Name , Arrays . as List ( param Types ) ) ) ; }
public static void clean Up Full Copy Associations ( List < Volume Descriptor > volume Descriptors , Db Client db Client ) { List < URI > volume UR Is = Volume Descriptor . get Volume UR Is ( volume Descriptors ) ; for ( URI volume URI : volume UR Is ) { Volume volume = db Client . query Object ( Volume . class , volume URI ) ; URI source Volume URI = volume . get Associated Source Volume ( ) ; if ( ! Null Column Value Getter . is Null URI ( source Volume URI ) ) { Volume source Volume = db Client . query Object ( Volume . class , source Volume URI ) ; if ( source Volume != null ) { String Set full Copy Ids = source Volume . get Full Copies ( ) ; if ( full Copy Ids . contains ( volume URI . to String ( ) ) ) { full Copy Ids . remove ( volume URI . to String ( ) ) ; db Client . update Object ( source Volume ) ; } } } } }
public Program Rewriter ( Statement Block Rewrite Rule rewrite ) { dag Rule Set = new Array List < Hop Rewrite Rule > ( ) ; sb Rule Set = new Array List < Statement Block Rewrite Rule > ( ) ; sb Rule Set . add ( rewrite ) ; }
private void update Storage Pool Required Capacity Map ( Map < URI , Long > storage Pool Required Capacity , URI storage Pool Uri , long required Capacity ) { if ( storage Pool Required Capacity . get ( storage Pool Uri ) == null ) { storage Pool Required Capacity . put ( storage Pool Uri , required Capacity ) ; } else { long updated Required Capacity = storage Pool Required Capacity . get ( storage Pool Uri ) + required Capacity ; storage Pool Required Capacity . put ( storage Pool Uri , updated Required Capacity ) ; } }
public static String normalize Wwn ( String wwn ) { wwn = String Utils . lower Case ( wwn ) ; wwn = String Utils . replace ( wwn , STR_ , STR_ ) ; wwn = String Utils . left Pad ( wwn , NUM_ , STR_ ) ; return wwn ; }
public Set entry Set ( ) { return map . entry Set ( ) ; }
public static int compute Latest Available Version From Version Spec ( Tree Set < Integer > all Available Facebook App Versions , int latest Sdk Version , int [ ] version Spec ) { int version Spec Index = version Spec . length - NUM_ ; Iterator < Integer > fb App Versions Iterator = all Available Facebook App Versions . descending Iterator ( ) ; int latest Facebook App Version = - NUM_ ; while ( fb App Versions Iterator . has Next ( ) ) { int fb App Version = fb App Versions Iterator . next ( ) ; latest Facebook App Version = Math . max ( latest Facebook App Version , fb App Version ) ; while ( version Spec Index >= NUM_ && version Spec [ version Spec Index ] > fb App Version ) { version Spec Index -- ; } if ( version Spec Index < NUM_ ) { return NO PROTOCOL AVAILABLE ; } if ( version Spec [ version Spec Index ] == fb App Version ) { return ( version Spec Index % NUM_ == NUM_ ? Math . min ( latest Facebook App Version , latest Sdk Version ) : NO PROTOCOL AVAILABLE ) ; } } return NO PROTOCOL AVAILABLE ; }
private final boolean park And Check Interrupt ( ) { Lock Support . park ( this ) ; return Thread . interrupted ( ) ; }
@ Objective C Name ( STR_ ) Connection ( final String url , final Deepstream Config options , Deepstream Client client , Endpoint endpoint ) { this . client = client ; this . connect State Listeners = new Array List < > ( ) ; this . original Url = url ; this . url = url ; this . connection State = Connection State . CLOSED ; this . message Buffer = new String Builder ( ) ; this . too Many Auth Attempts = false ; this . challenge Denied = false ; this . deliberate Close = false ; this . redirecting = false ; this . reconnect Timeout = null ; this . reconnection Attempt = NUM_ ; this . options = options ; this . endpoint = endpoint ; this . record Thread = Executors . new Single Thread Executor ( ) ; this . event Thread = Executors . new Single Thread Executor ( ) ; this . rpc Thread = Executors . new Single Thread Executor ( ) ; }
public final void open Pdf File From Stream ( final Object filename , final String password ) throws Pdf Exception { close On Exit = false ; if ( filename instanceof Image Input Stream ) { final Image Input Stream iis = ( Image Input Stream ) filename ; if ( is Open ) { close Pdf File ( ) ; } is Open = false ; this . filename = STR_ + System . current Time Millis ( ) ; org . jpedal . Dev Flags . current File = this . filename ; res . flush ( ) ; res . flush Objects ( ) ; object Store Ref . store File Name ( this . filename ) ; current Pdf File = new Pdf Object Reader ( password ) ; current Pdf File . open Pdf File ( iis ) ; open Pdf File ( ) ; } else { throw new Runtime Exception ( filename + STR_ ) ; } }
@ Override public void receive ( Complex Buffer sample Buffer ) { m Queue . offer ( sample Buffer ) ; }
private int convert Surrogate ( int first Part , int second Part ) { if ( second Part < SURR 2 FIRST || second Part > SURR 2 LAST ) { throw new Illegal Argument Exception ( STR_ + Integer . to Hex String ( first Part ) + STR_ + Integer . to Hex String ( second Part ) + STR_ ) ; } return NUM_ + ( ( first Part - SURR 1 FIRST ) << NUM_ ) + ( second Part - SURR 2 FIRST ) ; }
public static String [ ] split ( String str , String delimiter ) { List < String > result = new Array List < String > ( ) ; int last Index = NUM_ ; int index = str . index Of ( delimiter ) ; while ( index != - NUM_ ) { result . add ( str . substring ( last Index , index ) ) ; last Index = index + delimiter . length ( ) ; index = str . index Of ( delimiter , index + delimiter . length ( ) ) ; } result . add ( str . substring ( last Index , str . length ( ) ) ) ; return Array Util . to Array ( result , String . class ) ; }
public static boolean equal ( long [ ] x , long [ ] y ) { if ( x == null || y == null ) { return ( x == null ) && ( y == null ) ; } int p = Math . min ( x . length , y . length ) - NUM_ ; for ( int i = x . length - NUM_ ; i > p ; i -- ) { if ( x [ i ] != NUM_ ) { return false ; } } for ( int i = y . length - NUM_ ; i > p ; i -- ) { if ( y [ i ] != NUM_ ) { return false ; } } for ( ; p >= NUM_ ; p -- ) { if ( x [ p ] != y [ p ] ) { return false ; } } return true ; }
private @ Not Null Aggregation create Summing Aggregator ( Metric Field inner Metric ) { String outer Summing Field Name ; if ( ! inner Metric . is Sketch ( ) && inner Metric instanceof Aggregation ) { outer Summing Field Name = inner Metric . get Name ( ) ; } else { outer Summing Field Name = inner Metric . get Name ( ) + STR_ ; } if ( inner Metric . is Floating Point ( ) ) { return new Double Sum Aggregation ( outer Summing Field Name , inner Metric . get Name ( ) ) ; } return new Long Sum Aggregation ( outer Summing Field Name , inner Metric . get Name ( ) ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof Response APDU == false ) { return false ; } Response APDU other = ( Response APDU ) obj ; return Arrays . equals ( this . apdu , other . apdu ) ; }
public static Run Stats delegate Get Bucket For Boolean ( int buckets ) throws Exception { Long start Time = System . current Time Millis ( ) ; Primary Index Bucket Generator Impl ibg = new Primary Index Bucket Generator Impl ( Field Data Type . BOOLEAN , buckets ) ; Primary Index Bucket Locator Impl locator = new Primary Index Bucket Locator Impl ( null , null , null , null , ibg . generate Buckets ( ) , null , null , null , null ) ; logger . debug ( STR_ ) ; Hash Map < Long , List < Object > > hm = new Hash Map < > ( ) ; Summary Statistics stats = new Summary Statistics ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { Boolean random Boolean = Random Utils . next Boolean ( ) ; Long bucket Id = locator . get Bucket ( random Boolean , Field Data Type . BOOLEAN ) ; Test Utils . calculate ( hm , stats , bucket Id , random Boolean ) ; } Long run Time = System . current Time Millis ( ) - start Time ; Run Stats run Stats = new Run Stats ( STR_ , Field Data Type . BOOLEAN , run Time , stats , hm ) ; logger . debug ( run Stats . to String ( ) ) ; return run Stats ; }
@ Override protected void paint Component ( final Graphics g ) { super . paint Component ( g ) ; if ( has Focus ( ) ) { g . set Color ( JB Color . black ) ; Darcula UI Util . paint Focus Ring ( g , NUM_ , NUM_ , get Width ( ) , get Height ( ) ) ; } }
public String pop And Encode As Js ( ) { synchronized ( this ) { int length = queue . size ( ) ; if ( length == NUM_ ) { return null ; } int total Payload Len = NUM_ ; int num Messages To Send = NUM_ ; for ( Js Message message : queue ) { int message Size = message . calculate Encoded Length ( ) + NUM_ ; if ( num Messages To Send > NUM_ && total Payload Len + message Size > MAX PAYLOAD SIZE && MAX PAYLOAD SIZE > NUM_ ) { break ; } total Payload Len += message Size ; num Messages To Send += NUM_ ; } boolean will Send All Messages = num Messages To Send == queue . size ( ) ; String Builder sb = new String Builder ( total Payload Len + ( will Send All Messages ? NUM_ : NUM_ ) ) ; for ( int i = NUM_ ; i < num Messages To Send ; ++ i ) { Js Message message = queue . remove First ( ) ; if ( will Send All Messages && ( i + NUM_ == num Messages To Send ) ) { message . encode As Js Message ( sb ) ; } else { sb . append ( STR_ ) ; message . encode As Js Message ( sb ) ; sb . append ( STR_ ) ; } } if ( ! will Send All Messages ) { sb . append ( STR_ ) ; } for ( int i = will Send All Messages ? NUM_ : NUM_ ; i < num Messages To Send ; ++ i ) { sb . append ( STR_ ) ; } String ret = sb . to String ( ) ; return ret ; } }
@ Override public void end RDF ( ) throws RDF Handler Exception { final long nparsed = nmodified . get ( ) ; final long elapsed = System . nano Time ( ) - begin Nanos ; conn . fire Event ( new SPARQL Update Event . Load Progress ( op , elapsed , nparsed , true ) ) ; }
public static URL [ ] path To UR Ls ( String path ) { String Tokenizer st = new String Tokenizer ( path , File . path Separator ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; int count = NUM_ ; while ( st . has More Tokens ( ) ) { URL url = file To URL ( new File ( st . next Token ( ) ) ) ; if ( url != null ) { urls [ count ++ ] = url ; } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , NUM_ , tmp , NUM_ , count ) ; urls = tmp ; } return urls ; }
public void print Map ( ) { if ( last Entry > NUM_ ) { VM . sys Write ( STR_ ) ; } for ( int i = NUM_ ; i <= last Entry ; i ++ ) { VM . sys Write ( STR_ + i + STR_ ) ; int map Index = get OSR Map Index ( i ) ; VM . sys Write ( STR_ + map Index + STR_ ) ; int mc Offset = get MC Offset ( i ) ; VM . sys Write ( STR_ + mc Offset + STR_ ) ; int bc Index = get BC Index ( i ) ; VM . sys Writeln ( STR_ + bc Index ) ; int regmap = osr Maps [ map Index ] & ~ NEXT BIT ; VM . sys Write ( STR_ + Integer . to Binary String ( regmap ) ) ; OSR Map Iterator iterator = new OSR Map Iterator ( osr Maps , map Index ) ; while ( iterator . has More ( ) ) { VM . sys Write ( STR_ + iterator . get Value Type ( ) + STR_ + iterator . get Value ( ) + STR_ ) ; iterator . move To Next ( ) ; } VM . sys Write ( STR_ ) ; } }
private void reset Buffered Graphic ( ) { buffer Graphics . clear Rect ( NUM_ , NUM_ , get Width ( ) , get Height ( ) ) ; buffer Graphics . set Font ( m font ) ; }
public void restore Current Background ( ) { if ( saved Background . is Present ( ) ) { set Arena Background ( saved Background . get ( ) ) ; saved Background = Optional . empty ( ) ; } else { set Arena Background ( null ) ; } }
public void render Validation Messages ( Payment Item payment Item ) { field Ids Of Error Messages Showing . clear ( ) ; for ( Validation Error Message validation Result : validation Messages ) { render Validation Message On Screen ( validation Result , payment Item ) ; } }
public View create ( Element elem ) { Document doc = elem . get Document ( ) ; Object i 18 n Flag = doc . get Property ( STR_ ) ; if ( ( i 18 n Flag != null ) && i 18 n Flag . equals ( Boolean . TRUE ) ) { return create I 18 N ( elem ) ; } else { J Text Component c = get Component ( ) ; if ( c instanceof J Text Area ) { J Text Area area = ( J Text Area ) c ; View v ; if ( area . get Line Wrap ( ) ) { v = new Wrapped Plain View ( elem , area . get Wrap Style Word ( ) ) ; } else { v = new Plain View ( elem ) ; } return v ; } } return null ; }
public static double raw Log Probability ( double x , double lambda ) { if ( lambda == NUM_ ) { return ( ( x == NUM_ ) ? NUM_ : Double . NEGATIVE INFINITY ) ; } if ( Double . is Infinite ( lambda ) || x < NUM_ ) { return Double . NEGATIVE INFINITY ; } if ( x <= lambda * Double . MIN NORMAL ) { return - lambda ; } if ( lambda < x * Double . MIN NORMAL ) { return - lambda + x * Math . log ( lambda ) - Gamma Distribution . log Gamma ( x + NUM_ ) ; } final double f = Math Util . TWOPI * x ; final double y = - stirling Error ( x ) - deviance Term ( x , lambda ) ; return - NUM_ * Math . log ( f ) + y ; }
private void initialize Conductor ( ) { active Delays = new Linked List < Float > ( ) ; float random Delay = Math Utils . random ( NUM_ , NUM_ ) ; current Delay = random Delay ; total Delay += random Delay ; active Delays . add ( random Delay ) ; do { float delay Percentage = total Delay / time Til Victory ; random Delay = this . max delay - delay Percentage * ( this . max delay - this . min delay ) ; active Delays . add ( random Delay ) ; total Delay += random Delay ; } while ( total Delay < time Til Victory ) ; turn Off All Tracks ( ) ; }
protected boolean is Forbidden Attribute ( Tag Node tag Node , String att Name , String value ) { return ! props . is Namespaces Aware ( ) && ( XMLNS NAMESPACE . equals ( att Name ) || att Name . starts With ( XMLNS NAMESPACE + STR_ ) ) ; }
private boolean acquire ( ) { while ( true ) { int cnt = active Cnt . get ( ) ; if ( cnt == NUM_ ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + this ) ; return false ; } if ( active Cnt . compare And Set ( cnt , cnt + NUM_ ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + this ) ; return true ; } } }
private Counting Thread Pool Executor create Executor ( int num Threads ) { return new Counting Thread Pool Executor ( num Threads , Integer . MAX VALUE , NUM_ , Time Unit . SECONDS , new Linked Blocking Queue < Runnable > ( ) ) ; }
public String add Listener ( Configuration Listener listener ) throws Configuration Exception { return STR_ ; }
public char [ ] expand Current Segment ( ) { char [ ] curr = current Segment ; int len = curr . length ; int new Len = ( len == MAX SEGMENT LEN ) ? ( MAX SEGMENT LEN + NUM_ ) : Math . min ( MAX SEGMENT LEN , len + ( len > > NUM_ ) ) ; current Segment = char Array ( new Len ) ; System . arraycopy ( curr , NUM_ , current Segment , NUM_ , len ) ; return current Segment ; }
public static int open Socket ( ) throws IO Exception { server Socket = new Server Socket ( NUM_ , NUM_ , Inet Address . get Local Host ( ) ) ; return server Socket . get Local Port ( ) ; }
protected void log Assign Node ( Graph Node node , int level , int offset ) { logger . info ( STR_ + level + STR_ + offset + STR_ + node ) ; }
public synchronized void add Contact List Listener ( Contact List Listener listener ) { if ( ( listener != null ) && ! m Contact List Listeners . contains ( listener ) ) { m Contact List Listeners . add ( listener ) ; } }
public TS Request ( String t SA Policy ID , byte [ ] to Be Time Stamped , Message Digest message Digest ) throws No Such Algorithm Exception { this . policy Id = t SA Policy ID ; this . hash Algorithm Id = Algorithm Id . get ( message Digest . get Algorithm ( ) ) ; this . hash Value = message Digest . digest ( to Be Time Stamped ) ; }
public static Buffered Image rotate ( final Buffered Image src , final int rotation ) { Buffered Image dst ; if ( src == null ) { return null ; } if ( rotation == NUM_ ) { return src ; } final double angle = rotation * Math . PI / NUM_ ; final int w = src . get Width ( ) ; final int h = src . get Height ( ) ; final int new W = ( int ) ( Math . round ( h * Math . abs ( Math . sin ( angle ) ) + w * Math . abs ( Math . cos ( angle ) ) ) ) ; final int new H = ( int ) ( Math . round ( h * Math . abs ( Math . cos ( angle ) ) + w * Math . abs ( Math . sin ( angle ) ) ) ) ; final Affine Transform at = Affine Transform . get Translate Instance ( ( new W - w ) / NUM_ , ( new H - h ) / NUM_ ) ; at . rotate ( angle , w / NUM_ , h / NUM_ ) ; dst = new Buffered Image ( new W , new H , Buffered Image . TYPE INT ARGB ) ; final Graphics 2 D g 2 = dst . create Graphics ( ) ; g 2 . draw Rendered Image ( src , at ) ; g 2 . dispose ( ) ; return dst ; }
protected void prepare For Addition ( Object bean , Bean Info bean Info , Point location ) { try { set Bean Properties ( bean , bean Info , location ) ; create Property Sheet ( bean ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public static double [ ] compute Log Power Spectrum ( final double [ ] signal ) { double [ ] spectrum = compute Power Spectrum ( signal ) ; for ( int i = NUM_ ; i < spectrum . length ; i ++ ) { spectrum [ i ] = Math Utils . db ( spectrum [ i ] ) ; } return spectrum ; }
private void calculate Window Proportions ( final int slots ) { int width = ( int ) Math . sqrt ( slots ) ; while ( slots % width != NUM_ ) { width -- ; if ( width <= NUM_ ) { logger . error ( STR_ + slots ) ; width = NUM_ ; } } slot Window Width = width ; slot Window Height = slots / width ; }
public static < T > void do For All ( Collection < T > c , Object Visitor < T > v ) { for ( Iterator < T > iter = c . iterator ( ) ; iter . has Next ( ) ; ) v . visit ( iter . next ( ) ) ; }
public boolean is Optional ( final Attribute Type attribute Type ) { return optional Attributes . contains ( attribute Type ) ; }
public static Async World wrap ( World world ) { if ( world instanceof Async World ) { return ( Async World ) world ; } return new Async World ( world , false ) ; }
public static Database Impl create ( File Format file Format , File mdb File , File Channel channel , boolean auto Sync , Charset charset , Time Zone time Zone ) throws IO Exception { File Format Details details = get File Format Details ( file Format ) ; if ( details . get Format ( ) . READ ONLY ) { throw new IO Exception ( STR_ + file Format + STR_ + mdb File ) ; } if ( details . get Empty File Path ( ) == null ) { throw new IO Exception ( STR_ + file Format + STR_ + mdb File ) ; } boolean close Channel = false ; if ( channel == null ) { channel = open Channel ( mdb File , false ) ; close Channel = true ; } boolean success = false ; try { channel . truncate ( NUM_ ) ; transfer From ( channel , get Resource As Stream ( details . get Empty File Path ( ) ) ) ; channel . force ( true ) ; Database Impl db = new Database Impl ( mdb File , channel , close Channel , auto Sync , file Format , charset , time Zone , null ) ; success = true ; return db ; } finally { if ( ! success && close Channel ) { Byte Util . close Quietly ( channel ) ; } } }
protected void calculate Fitness And Sort Population ( ) { logger . debug ( STR_ + population . size ( ) + STR_ ) ; Iterator < T > iterator = population . iterator ( ) ; while ( iterator . has Next ( ) ) { T c = iterator . next ( ) ; if ( is Finished ( ) ) { if ( c . is Changed ( ) ) iterator . remove ( ) ; } else { for ( Fitness Function < T > fitness Function : fitness Functions ) { fitness Function . get Fitness ( c ) ; notify Evaluation ( c ) ; } } } sort Population ( ) ; }
public boolean write ( Type type , Object value , Node Map node ) { Class actual = value . get Class ( ) ; Class expect = type . get Type ( ) ; Class real = actual ; if ( actual . is Array ( ) ) { real = write Array ( actual , value , node ) ; } if ( actual != expect ) { node . put ( label , real . get Name ( ) ) ; } return write Reference ( value , node ) ; }
Bulk Import Result do Import ( final Job Status Listener status Listener , final File [ ] files To Import , final String csv Import Descriptor Name , final Csv Import Descriptor csv Import Descriptor , final Set < String > imported Files ) throws Exception { for ( File file To Import : files To Import ) { imported Files . add ( file To Import . get Absolute Path ( ) ) ; } for ( File file To Import : files To Import ) { final Bulk Import Result status = do Import ( status Listener , file To Import , csv Import Descriptor Name , csv Import Descriptor ) ; if ( status != Bulk Import Result . OK ) { return status ; } } return Bulk Import Result . OK ; }
public void remove Cookie ( String url ) { cookie Jar . remove ( url ) ; }
@ Override public void add Connection Event Listener ( Connection Event Listener listener ) { debug Code ( STR_ ) ; listeners . add ( listener ) ; }
public static String name For Stream Alias ( String alias ) { Objects . require Non Null ( alias , STR_ ) ; return ALIAS PREFIX + alias ; }
protected boolean handle Chunk ( final E [ ] chunk ) throws Execution Exception , Interrupted Exception , IO Exception { assert chunk != null ; assert chunk . length > NUM_ ; final int chunk Size = chunk . length ; final long begin Nanos = System . nano Time ( ) ; try { for ( E e : chunk ) { master . add Pending ( e , this , locator ) ; } try { client Task . accept ( chunk ) ; } catch ( Throwable t ) { master . halt ( t ) ; throw new Runtime Exception ( t ) ; } if ( log . is Debug Enabled ( ) ) log . debug ( stats ) ; return false ; } finally { final long elapsed Nanos = System . nano Time ( ) - begin Nanos ; synchronized ( stats ) { stats . chunks Out . increment And Get ( ) ; stats . elements Out . add And Get ( chunk Size ) ; stats . elapsed Chunk Writing Nanos += elapsed Nanos ; } synchronized ( master . stats ) { master . stats . chunks Out . increment And Get ( ) ; master . stats . elements Out . add And Get ( chunk Size ) ; master . stats . elapsed Sink Chunk Writing Nanos += elapsed Nanos ; } } }
public static Matrix Block to Matrix Block ( Java Pair RDD < Matrix Indexes , Matrix Cell > rdd , int rlen , int clen , long nnz ) throws DML Runtime Exception { long t 0 = DML Script . STATISTICS ? System . nano Time ( ) : NUM_ ; Matrix Block out = null ; long lnnz = ( nnz >= NUM_ ) ? nnz : ( long ) rlen * clen ; boolean sparse = Matrix Block . eval Sparse Format In Memory ( rlen , clen , lnnz ) ; out = new Matrix Block ( rlen , clen , sparse ) ; List < Tuple 2 < Matrix Indexes , Matrix Cell > > list = rdd . collect ( ) ; for ( Tuple 2 < Matrix Indexes , Matrix Cell > keyval : list ) { Matrix Indexes ix = keyval . 1 ( ) ; Matrix Cell cell = keyval . 2 ( ) ; out . append Value ( ( int ) ix . get Row Index ( ) - NUM_ , ( int ) ix . get Column Index ( ) - NUM_ , cell . get Value ( ) ) ; } if ( sparse ) out . sort Sparse Rows ( ) ; out . recompute Non Zeros ( ) ; out . exam Sparsity ( ) ; if ( DML Script . STATISTICS ) { Statistics . acc Spark Collect Time ( System . nano Time ( ) - t 0 ) ; Statistics . inc Spark Collect Count ( NUM_ ) ; } return out ; }
private void process Instruction ( Instruction s ) { if ( s . is Dynamic Linking Point ( ) ) { process Call ( s ) ; } else if ( Move . conforms ( s ) ) { process Move ( s ) ; } else if ( s . operator ( ) == PI ) { process Pi ( s ) ; } else if ( New . conforms ( s ) ) { process New ( s ) ; } else if ( New Array . conforms ( s ) ) { process New Array ( s ) ; } else if ( Unary . conforms ( s ) ) { process Unary ( s ) ; } else if ( Guarded Unary . conforms ( s ) ) { process Guarded Unary ( s ) ; } else if ( Null Check . conforms ( s ) ) { process Null Check ( s ) ; } else if ( Zero Check . conforms ( s ) ) { process Zero Check ( s ) ; } else if ( Binary . conforms ( s ) ) { process Binary ( s ) ; } else if ( Guarded Binary . conforms ( s ) ) { process Guarded Binary ( s ) ; } else if ( Inline Guard . conforms ( s ) ) { process Inline Guard ( s ) ; } else if ( If Cmp . conforms ( s ) ) { process If Cmp ( s ) ; } else if ( Call . conforms ( s ) ) { process Call ( s ) ; } else if ( Monitor Op . conforms ( s ) ) { process Call ( s ) ; } else if ( Prepare . conforms ( s ) ) { process Call ( s ) ; } else if ( Attempt . conforms ( s ) ) { process Call ( s ) ; } else if ( Cache Op . conforms ( s ) ) { process Call ( s ) ; } else if ( A Load . conforms ( s ) ) { process A Load ( s ) ; } else if ( Put Field . conforms ( s ) ) { process Put Field ( s ) ; } else if ( Put Static . conforms ( s ) ) { process Put Static ( s ) ; } else if ( A Store . conforms ( s ) ) { process A Store ( s ) ; } else if ( Phi . conforms ( s ) ) { process Phi ( s ) ; } else if ( s . operator ( ) == IR PROLOGUE ) { process Prologue ( s ) ; } }
@ Subscribe public synchronized void on Step Moved ( Step Moved Event event ) { Platform Impl . run And Wait ( null ) ; }
public void check Number Args ( int arg Num ) throws Wrong Number Args Exception { if ( ( arg Num < NUM_ ) || ( arg Num > NUM_ ) ) report Wrong Number Args ( ) ; }
private Gregorian Calendar read ( Date date ) throws Exception { Gregorian Calendar calendar = new Gregorian Calendar ( ) ; if ( date != null ) { calendar . set Time ( date ) ; } return calendar ; }
private void compute Multiplier ( LST Node n ) { n . initialize Loop Exits ( ) ; compute Node Weights ( n ) ; float loop Exit Weight = compute Loop Exit Weight ( n ) ; n . loop Multiplier = NUM_ / loop Exit Weight ; }
private String trim Text ( String text ) { if ( text . length ( ) > BUBBLE TEXT LENGTH ) { text = text . substring ( NUM_ , BUBBLE TEXT LENGTH ) ; int n = text . last Index Of ( STR_ ) ; n = Math . max ( n , text . last Index Of ( STR_ ) ) ; n = Math . max ( n , text . last Index Of ( STR_ ) ) ; n = Math . max ( n , text . last Index Of ( STR_ ) ) ; if ( n > NUM_ ) { text = text . substring ( NUM_ , n ) ; } text += STR_ ; } return text ; }
public boolean queue At ( Alarm alarm , long wake Time ) { boolean is Earliest = false ; long prev Next Alarm Time ; do { prev Next Alarm Time = next Alarm Time . get ( ) ; } while ( wake Time > NUM_ && wake Time < prev Next Alarm Time && ! next Alarm Time . compare And Set ( prev Next Alarm Time , wake Time ) ) ; if ( wake Time < prev Next Alarm Time ) { is Earliest = true ; } long old Wake Time = alarm . get And Set Wake Time ( wake Time ) ; if ( old Wake Time == wake Time ) { return false ; } if ( old Wake Time > NUM_ ) { if ( ! dequeue Impl ( alarm ) ) { } } if ( wake Time <= NUM_ ) { return false ; } long now = now . get ( ) ; if ( wake Time <= now ) { queue Current ( alarm ) ; return true ; } synchronized ( lock ) { if ( alarm . get Bucket ( ) >= NUM_ ) { return false ; } int bucket = get Bucket ( wake Time ) ; alarm . set Bucket ( bucket ) ; Alarm top = clock Array [ bucket ] ; alarm . set Next ( top ) ; clock Array [ bucket ] = alarm ; } now = now . get ( ) ; long next Wake Time = alarm . get Wake Time ( ) ; if ( next Wake Time != wake Time || wake Time < now ) { dequeue Impl ( alarm ) ; queue Current ( alarm ) ; } return is Earliest ; }
@ Override public String generate Label String ( XY Dataset dataset , int series , int item ) { String result ; Object [ ] items ; if ( dataset instanceof XYZ Dataset ) { items = create Item Array ( ( XYZ Dataset ) dataset , series , item ) ; } else { items = create Item Array ( dataset , series , item ) ; } result = Message Format . format ( get Format String ( ) , items ) ; return result ; }
protected final boolean match Token ( String match Str , int i ) throws IO Exception , Json Parse Exception { final int len = match Str . length ( ) ; do { if ( input Ptr >= input End ) { if ( ! load More ( ) ) { report Invalid EOF In Value ( ) ; } } if ( input Buffer [ input Ptr ] != match Str . char At ( i ) ) { report Invalid Token ( match Str . substring ( NUM_ , i ) , STR_ ) ; } ++ input Ptr ; } while ( ++ i < len ) ; if ( input Ptr >= input End ) { if ( ! load More ( ) ) { return true ; } } char c = input Buffer [ input Ptr ] ; if ( Character . is Java Identifier Part ( c ) ) { ++ input Ptr ; report Invalid Token ( match Str . substring ( NUM_ , i ) , STR_ ) ; } return true ; }
protected void store State ( ) { System . arraycopy ( intervals , NUM_ , stored Intervals , NUM_ , intervals . length ) ; System . arraycopy ( lineage Counts , NUM_ , stored Lineage Counts , NUM_ , lineage Counts . length ) ; stored Intervals Known = intervals Known ; stored Interval Count = interval Count ; stored Likelihood Known = likelihood Known ; stored Log Likelihood = log Likelihood ; }
@ Override public List < Proxy > select ( URI uri ) { Array List < Proxy > proxies = new Array List < Proxy > ( ) ; proxies . add ( Proxy . NO PROXY ) ; return proxies ; }
public void override Current Time ( long time ) { start Time = System . current Time Millis ( ) ; current Time = NUM_ ; stored Time = time ; }
private void assert Not Variable ( final Term Node t ) throws Visitor Exception { if ( t == null ) return ; if ( ! t . is Variable ( ) ) return ; final Var Node v = ( Var Node ) t ; if ( v . is Anonymous ( ) ) { return ; } throw new Visitor Exception ( STR_ + t ) ; }
private Named List r Query ( int expected Doc Count , String query , Solr Server server ) throws Exception { int time Slept = NUM_ ; Named List res = query ( query , server ) ; while ( expected Doc Count != num Found ( res ) && time Slept < NUM_ ) { log . info ( STR_ + expected Doc Count + STR_ ) ; time Slept += NUM_ ; Thread . sleep ( NUM_ ) ; res = query ( query , server ) ; } log . info ( STR_ , time Slept , num Found ( res ) ) ; return res ; }
@ Override public double [ ] [ ] process Ids ( DBI Ds ids , Relation < ? extends Number Vector > relation ) { final int dim = Relation Util . dimensionality ( relation ) ; final Covariance Matrix cmat = new Covariance Matrix ( dim ) ; final Centroid centroid = Centroid . make ( relation , ids ) ; double maxdist = NUM_ ; double stddev = NUM_ ; { for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; stddev += distance * distance ; if ( distance > maxdist ) { maxdist = distance ; } } if ( maxdist == NUM_ ) { maxdist = NUM_ ; } stddev = Math . sqrt ( stddev / ids . size ( ) ) ; } for ( DBID Iter iter = ids . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Number Vector obj = relation . get ( iter ) ; double distance = weight Distance . distance ( centroid , obj ) ; double weight = weightfunction . get Weight ( distance , maxdist , stddev ) ; cmat . put ( obj , weight ) ; } return cmat . destroy To Naive Matrix ( ) ; }
public I Pv 4 Address Validator ( @ Non Null final Char Sequence error Message ) { super ( error Message , REGEX ) ; }
private void wait ( int ms ) { try { Thread . sleep ( ms ) ; } catch ( Interrupted Exception e ) { } }
Type Simplifier ( Types type Utils , String package Name , Set < Type Mirror > types , Type Mirror base ) { this . type Utils = type Utils ; Set < Type Mirror > types Plus Base = new Type Mirror Set ( types ) ; if ( base != null ) { types Plus Base . add ( base ) ; } Set < Type Mirror > referenced = referenced Class Types ( type Utils , types Plus Base ) ; Set < Type Mirror > defined = non Private Declared Types ( type Utils , base ) ; this . imports = find Imports ( type Utils , package Name , referenced , defined ) ; }
public final void add Clip ( final Area current area ) { if ( T Rmask == null ) { T Rmask = new General Path ( ) ; } T Rmask . append ( current area , false ) ; }
public Reader Accessible Info ( Big Int Array edges , Int To Int Pair Hash Map node Info ) { this . edges = edges ; this . node Info = node Info ; }
public boolean is Transient ( ) { return transient var ; }
public static Injector create Injector ( Stage stage , Module ... modules ) { return create Injector ( stage , Arrays . as List ( modules ) ) ; }
public long insert With On Conflict ( String table , String null Column Hack , Content Values initial Values , int conflict Algorithm ) { acquire Reference ( ) ; try { String Builder sql = new String Builder ( ) ; sql . append ( STR_ ) ; sql . append ( CONFLICT VALUES [ conflict Algorithm ] ) ; sql . append ( STR_ ) ; sql . append ( table ) ; sql . append ( STR_ ) ; Object [ ] bind Args = null ; int size = ( initial Values != null && initial Values . size ( ) > NUM_ ) ? initial Values . size ( ) : NUM_ ; if ( size > NUM_ ) { bind Args = new Object [ size ] ; int i = NUM_ ; for ( String col Name : initial Values . key Set ( ) ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; sql . append ( col Name ) ; bind Args [ i ++ ] = initial Values . get ( col Name ) ; } sql . append ( STR_ ) ; sql . append ( STR_ ) ; for ( i = NUM_ ; i < size ; i ++ ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; } } else { sql . append ( null Column Hack + STR_ ) ; } sql . append ( STR_ ) ; SQ Lite Statement statement = new SQ Lite Statement ( this , sql . to String ( ) , bind Args ) ; try { return statement . execute Insert ( ) ; } finally { statement . close ( ) ; } } finally { release Reference ( ) ; } }
private void submit X Form ( Document doc , String xml , String path Name , boolean archive , boolean propagate Errors ) throws Exception { String xml Original = xml ; try { fill Patient Id If Missing ( doc ) ; save Complex Obs ( doc , true ) ; set Multiple Select Values ( doc . get Document Element ( ) ) ; xml = Xforms Util . doc 2 String ( doc ) ; if ( is Remote Form Entry ( ) ) { Form Entry Wrapper . create Form Entry Queue ( xml ) ; } else { process Doc ( xml , path Name , propagate Errors ) ; String patientid = DOM Util . get Element Value ( doc , Xform Builder . NODE PATIENT PATIENT ID ) ; Patient patient = Xform Obs Patient Edit . update Patient Demographics ( patientid , xml ) ; Relative Submission . submit ( xml , patient ) ; if ( archive ) save Form In Archive ( xml Original , path Name ) ; } } catch ( Exception e ) { log . error ( e . get Message ( ) , e ) ; save Form In Error ( xml Original , path Name , e ) ; throw e ; } }
public static double round ( double number , int decimal Place ) { double multiplier = Math . pow ( NUM_ , decimal Place ) ; return Math . round ( number * multiplier ) / multiplier ; }
public Name File Filter ( String [ ] names , IO Case case Sensitivity ) { if ( names == null ) { throw new Illegal Argument Exception ( STR_ ) ; } this . names = new String [ names . length ] ; System . arraycopy ( names , NUM_ , this . names , NUM_ , names . length ) ; this . case Sensitivity = case Sensitivity == null ? IO Case . SENSITIVE : case Sensitivity ; }
public int [ ] intersect ( int [ ] nums 1 , int [ ] nums 2 ) { Map < Integer , Integer > count = new Hash Map < > ( ) ; for ( int n : nums 1 ) { count . put ( n , count . contains Key ( n ) ? count . get ( n ) + NUM_ : NUM_ ) ; } List < Integer > intersections = new Array List < > ( Math . min ( nums 1 . length , nums 2 . length ) ) ; for ( int n : nums 2 ) { if ( count . contains Key ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - NUM_ ) ; if ( count . get ( n ) == NUM_ ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = NUM_ ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
public boolean lock With Retries ( ) { try { for ( int i = NUM_ ; i < retry Count ; i ++ ) { if ( lock ( ) ) { return true ; } else { Thread . sleep ( retry Timeout * NUM_ ) ; } } } catch ( Interrupted Exception e ) { return false ; } return false ; }
private void make Tunnel ( Tunnel Request tunnel Request ) throws IO Exception { Raw Headers request Headers = tunnel Request . get Request Headers ( ) ; while ( true ) { out . write ( request Headers . to Bytes ( ) ) ; Raw Headers response Headers = Raw Headers . from Bytes ( in ) ; switch ( response Headers . get Response Code ( ) ) { case HTTP OK : return ; case HTTP PROXY AUTH : request Headers = new Raw Headers ( request Headers ) ; URL url = new URL ( STR_ , tunnel Request . host , tunnel Request . port , STR_ ) ; boolean credentials Found = Http Authenticator . process Auth Header ( route . address . authenticator , HTTP PROXY AUTH , response Headers , request Headers , route . proxy , url ) ; if ( credentials Found ) { continue ; } else { throw new IO Exception ( STR_ ) ; } default : throw new IO Exception ( STR_ + response Headers . get Response Code ( ) ) ; } } }
public void put All ( Map data ) { map . put All ( data ) ; }
private String pick Encoding ( Input Source input Source ) { Reader reader = input Source . get Character Stream ( ) ; if ( reader != null ) { return CHARACTER ENCODING ; } String encoding = input Source . get Encoding ( ) ; return encoding == null ? DEFAULT ENCODING : encoding ; }
private void process Worker Exit ( Worker w , boolean completed Abruptly ) { if ( completed Abruptly ) decrement Worker Count ( ) ; final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { completed Task Count += w . completed Tasks ; workers . remove ( w ) ; } finally { main Lock . unlock ( ) ; } try Terminate ( ) ; int c = ctl . get ( ) ; if ( run State Less Than ( c , STOP ) ) { if ( ! completed Abruptly ) { int min = allow Core Thread Time Out ? NUM_ : core Pool Size ; if ( min == NUM_ && ! work Queue . is Empty ( ) ) min = NUM_ ; if ( worker Count Of ( c ) >= min ) return ; } add Worker ( null , false ) ; } }
public Forwarding Telemetry Adapter ( final Sender Factory sender Factory , final int instance No , final int total No Of Instances ) { super ( instance No , total No Of Instances ) ; this . sender Factory = Objects . require Non Null ( sender Factory ) ; }
public void Export Stop List ( String filename , String system Name ) throws IO Exception { Buffered Writer writer = new Buffered Writer ( new File Writer ( filename ) ) ; writer . write ( system Name + STR_ ) ; writer . new Line ( ) ; writer . new Line ( ) ; Array List < String > stops = new Array List < String > ( ) ; for ( Scheduled Route r : this . routes ) { for ( String s : r . get Stop Sequence ( ) ) { if ( ! ( stops . contains ( s ) ) ) stops . add ( s ) ; } } for ( String s : stops ) { writer . write ( s ) ; writer . new Line ( ) ; } writer . close ( ) ; }
private static Input Stream null Input Stream ( ) throws Null Pointer Exception { if ( current Time Millis ( ) > NUM_ ) { return null ; } throw new Null Pointer Exception ( ) ; }
protected void add Service Listener ( SMS Entry Update Listener update Listener ) { service Objects . add ( update Listener ) ; }
private void await Initialization ( ) { if ( init Latch . get Count ( ) > NUM_ ) { try { U . await ( init Latch ) ; if ( init Failed ) throw new Illegal State Exception ( STR_ ) ; } catch ( Ignite Interrupted Checked Exception e ) { throw new Illegal State Exception ( STR_ + STR_ , e ) ; } } }
public static int calculate Reward ( Player player ) { int moneys = NUM_ ; int kills = NUM_ ; for ( int i = NUM_ ; i < RAT TYPES . size ( ) ; i ++ ) { try { final String killed = player . get Quest ( QUEST SLOT , i + NUM_ ) ; if ( killed != null ) { kills = Integer . decode ( killed ) ; } } catch ( Number Format Exception nfe ) { } moneys = moneys + kills * RAT REWARDS . get ( i ) ; } return ( moneys ) ; }
public void fill Default Values ( ) { tf Learning Rate . set Text ( Double . to String ( Hebbian Rule . DEFAULT LEARNING RATE ) ) ; }
public static void main ( String [ ] args ) { int result ; Print Writer out = new Print Writer ( new Output Stream Writer ( System . out , UTF 8 ) ) ; Print Writer err = new Print Writer ( new Output Stream Writer ( System . err , UTF 8 ) ) ; try { Main formatter = new Main ( out , err , System . in ) ; result = formatter . format ( args ) ; } catch ( Usage Exception e ) { err . print ( e . get Message ( ) ) ; result = NUM_ ; } finally { err . flush ( ) ; out . flush ( ) ; } System . exit ( result ) ; }
private void emit Clear ( String field Name , String Builder builder ) { builder . append ( STR_ ) ; builder . append ( get Clear Name ( field Name ) ) ; builder . append ( STR_ ) ; builder . append ( get Ensure Name ( field Name ) ) ; builder . append ( STR_ ) ; builder . append ( field Name ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; }
protected void delete Least Used Entry ( ) { try { pool Lock . lock ( ) ; Basic Pool Entry entry = free Connections . remove ( ) ; if ( entry != null ) { delete Entry ( entry ) ; } else if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ ) ; } } finally { pool Lock . unlock ( ) ; } }
private void remove concave corners at close ( ) { add corner for snap angle ( ) ; if ( corner list . size ( ) < NUM_ ) { return ; } Pla Point Int [ ] corner arr = new Pla Point Int [ corner list . size ( ) ] ; Iterator < Pla Point Int > it = corner list . iterator ( ) ; for ( int i = NUM_ ; i < corner arr . length ; ++ i ) { corner arr [ i ] = it . next ( ) ; } int new length = corner arr . length ; Pla Point Int first corner = corner arr [ NUM_ ] ; Pla Point Int second corner = corner arr [ NUM_ ] ; while ( new length > NUM_ ) { Pla Point Int last corner = corner arr [ new length - NUM_ ] ; if ( last corner . side of ( second corner , first corner ) != Pla Side . ON THE LEFT ) { break ; } -- new length ; } if ( new length != corner arr . length ) { corner list = new java . util . Linked List < Pla Point Int > ( ) ; for ( int i = NUM_ ; i < new length ; ++ i ) { corner list . add ( corner arr [ i ] ) ; } add corner for snap angle ( ) ; } }
public static String xml Single Quoted Escape ( String s ) { String Builder sb = new String Builder ( ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : break ; default : sb . append ( c ) ; } } return sb . to String ( ) ; }
private void collect Pending Versions ( Grid Dht Tx Local dht Tx Loc ) { if ( dht Tx Loc . needs Completed Versions ( ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + dht Tx Loc ) ; Set < Grid Cache Version > vers = new Linked Hash Set < > ( ) ; collect Pending Versions ( dht Tx Loc . read Entries ( ) , dht Tx Loc . xid Version ( ) , vers ) ; collect Pending Versions ( dht Tx Loc . write Entries ( ) , dht Tx Loc . xid Version ( ) , vers ) ; if ( ! vers . is Empty ( ) ) dht Tx Loc . pending Versions ( vers ) ; } }
protected void await Accept ( ) throws IO Exception { final Selector server Selector = Selector . open ( ) ; try { final Selection Key server Key = server . register ( server Selector , Selection Key . OP ACCEPT ) ; try { server Selector . select ( ) ; final Set < Selection Key > keys = server Selector . selected Keys ( ) ; final Iterator < Selection Key > iter = keys . iterator ( ) ; while ( iter . has Next ( ) ) { final Selection Key key = ( Selection Key ) iter . next ( ) ; iter . remove ( ) ; if ( key != server Key ) throw new Assertion Error ( ) ; break ; } } finally { server Key . cancel ( ) ; } } finally { server Selector . close ( ) ; } }
private Stack < Composite Transaction > remove Thread Mappings ( Thread thread ) { Stack < Composite Transaction > ret = null ; synchronized ( threadtotxmap ) { ret = threadtotxmap . remove ( thread ) ; Composite Transaction tx = ret . peek ( ) ; txtothreadmap . remove ( tx ) ; } return ret ; }
public boolean wait For Draw ( long timeout ) throws Interrupted Exception { return draw Lock . try Acquire ( timeout , Time Unit . MILLISECONDS ) ; }
public void add Disconnection Listener ( Disconnection Listener listener ) { listeners . add ( listener ) ; }
public static U 64 compute Entry Cookie ( int user Cookie , String name ) { int prime = NUM_ ; int flow Hash = NUM_ ; for ( int i = NUM_ ; i < name . length ( ) ; i ++ ) { flow Hash = flow Hash * prime + ( int ) name . char At ( i ) ; } return App Cookie . make Cookie ( Static Flow Entry Pusher . STATIC FLOW APP ID , flow Hash ) ; }
@ Override public void populate Frame ( Audio a ) { if ( ! ( a instanceof Audio Listener ) ) { throw new Illegal Argument Exception ( a . get System Name ( ) + STR_ ) ; } super . populate Frame ( a ) ; Audio Listener l = ( Audio Listener ) a ; position . set Value ( l . get Position ( ) ) ; velocity . set Value ( l . get Velocity ( ) ) ; ori At . set Value ( l . get Orientation ( Audio . AT ) ) ; ori Up . set Value ( l . get Orientation ( Audio . UP ) ) ; gain . set Value ( l . get Gain ( ) ) ; meters Per Unit . set Value ( l . get Meters Per Unit ( ) ) ; }
private void populate Cinder Access Profile ( Access Profile access Profile , Storage Provider provider Info ) { access Profile . set System Id ( provider Info . get Id ( ) ) ; access Profile . set System Clazz ( provider Info . get Class ( ) ) ; access Profile . set Ip Address ( provider Info . get IP Address ( ) ) ; access Profile . set User Name ( provider Info . get User Name ( ) ) ; access Profile . set Password ( provider Info . get Password ( ) ) ; access Profile . set System Type ( STR_ ) ; access Profile . set Port Number ( provider Info . get Port Number ( ) ) ; access Profile . set Ssl Enable ( String . value Of ( provider Info . get Use SSL ( ) ) ) ; }
public static boolean above Than ( long a , long b ) { return Long . compare Unsigned ( a , b ) > NUM_ ; }
public Week View Event ( long id , String name , Calendar start Time , Calendar end Time ) { this . m Id = id ; this . m Name = name ; this . m Start Time = start Time ; this . m End Time = end Time ; }
public void characters ( char [ ] ch , int start , int length ) throws SAX Exception { if ( element On && is Item || element On ) { element Value . append ( new String ( ch , start , length ) ) ; } }
protected void compute Reachable Pts ( ) { int i ; I Var Abstraction pn ; off graph edge p ; queue . clear ( ) ; for ( i = NUM_ ; i < n var ; ++ i ) { pn = int 2 var . get ( i ) ; if ( pn . will Update == true ) queue . add ( i ) ; } while ( ! queue . is Empty ( ) ) { i = queue . get First ( ) ; queue . remove First ( ) ; p = var Graph . get ( i ) ; while ( p != null ) { pn = int 2 var . get ( p . t ) ; if ( pn . will Update == false ) { pn . will Update = true ; queue . add ( p . t ) ; } pn = p . base var ; if ( pn != null && pn . will Update == false ) { pn . will Update = true ; queue . add ( pn . id ) ; } p = p . next ; } } }
public void update Alert Definition ( Stat Alert Definition alert Definition ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ ) ; } synchronized ( ALERT DEFINITIONS ) { ALERT DEFINITIONS . put ( Integer . value Of ( alert Definition . get Id ( ) ) , alert Definition ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ , alert Definition . get Id ( ) , alert Definition . get String Representation ( ) ) ; } notify Members For Alert Definition Change ( alert Definition ) ; } if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ ) ; } }
void send Request ( Multiplex Connection Info info , int len ) throws IO Exception { synchronized ( data Out ) { if ( alive && ! info . closed ) try { data Out . write Byte ( REQUEST ) ; data Out . write Short ( info . id ) ; data Out . write Int ( len ) ; data Out . flush ( ) ; } catch ( IO Exception e ) { multiplex Log . log ( Log . BRIEF , STR_ , e ) ; shut Down ( ) ; throw e ; } } }
private void prepare Next Run ( ) { for ( I Var Abstraction pn : pointers ) { if ( pn . will Update == true ) { pn . reconstruct ( ) ; } } System . gc ( ) ; }
protected static Object [ ] concatenate ( Object [ ] a 1 , Object [ ] a 2 ) { int a 1 Len = a 1 . length ; int a 2 Len = a 2 . length ; if ( a 1 Len == NUM_ ) return a 2 ; if ( a 2 Len == NUM_ ) return a 1 ; Object [ ] res = new Object [ a 1 Len + a 2 Len ] ; System . arraycopy ( a 1 , NUM_ , res , NUM_ , a 1 Len ) ; System . arraycopy ( a 2 , NUM_ , res , a 1 Len , a 2 Len ) ; return res ; }
private void read Object ( Object Input Stream in ) throws Class Not Found Exception , IO Exception { in . default Read Object ( ) ; iter = col . iterator ( ) ; }
public static String append Path ( String path To , String path From ) { if ( path To == null || path To . length ( ) == NUM_ ) { return path From ; } else if ( path From == null || path From . length ( ) == NUM_ ) { return path To ; } else { return path To + File . path Separator + path From ; } }
public Pid File ( final File directory , final String filename ) throws File Not Found Exception { if ( ! directory . is Directory ( ) && directory . exists ( ) ) { throw new Illegal Argument Exception ( STR_ + directory + STR_ ) ; } final File file = new File ( directory , filename ) ; if ( ! file . exists ( ) || file . is Directory ( ) ) { throw new File Not Found Exception ( STR_ + filename + STR_ + directory ) ; } this . pid File = file ; }
static private String BYTE Min ( ) { byte temp Value = Byte . MIN VALUE ; return String . value Of ( temp Value ) ; }
public void vertex ( float [ ] v ) { vertex Check ( ) ; curve Vertex Count = NUM_ ; float [ ] vertex = vertices [ vertex Count ] ; System . arraycopy ( v , NUM_ , vertex , NUM_ , VERTEX FIELD COUNT ) ; vertex Count ++ ; }
public static boolean is Http Method Available ( Method method ) { return method . is Annotation Present ( GET . class ) || method . is Annotation Present ( PUT . class ) || method . is Annotation Present ( POST . class ) || method . is Annotation Present ( DELETE . class ) || method . is Annotation Present ( HEAD . class ) || method . is Annotation Present ( OPTIONS . class ) ; }
public static int convert To Color Int ( String argb ) throws Illegal Argument Exception { if ( ! argb . starts With ( STR_ ) ) { argb = STR_ + argb ; } return Color . parse Color ( argb ) ; }
private static Cache Type Metadata meta For Class ( Class cls ) { Cache Type Metadata meta = new Cache Type Metadata ( ) ; meta . set Key Type ( Integer . class ) ; meta . set Value Type ( cls ) ; meta . set Ascending Fields ( Collections . < String , Class < ? > > singleton Map ( STR_ , Integer . class ) ) ; return meta ; }
private static void cache Factory ( Class Loader class Loader , Log Factory factory ) { if ( factory != null ) { if ( class Loader == null ) { null Class Loader Factory = factory ; } else { factories . put ( class Loader , factory ) ; } } }
private boolean is Adaptable To As Return ( Class < ? > from Type , Class < ? > to Type ) { return to Type . equals ( void . class ) || ! from Type . equals ( void . class ) && is Adaptable To ( from Type , to Type , false ) ; }
public static String format Time ( long time ) { Simple Date Format sdf = new Simple Date Format ( STR_ ) ; Calendar c = Calendar . get Instance ( ) ; c . set Time In Millis ( time * NUM_ ) ; return sdf . format ( c . get Time ( ) ) ; }
protected void find Intersection Bounds ( final Planet Model planet Model , final Bounds bounds Info , final Plane q , final Membership ... bounds ) { final double line Vector X = y * q . z - z * q . y ; final double line Vector Y = z * q . x - x * q . z ; final double line Vector Z = x * q . y - y * q . x ; if ( Math . abs ( line Vector X ) < MINIMUM RESOLUTION && Math . abs ( line Vector Y ) < MINIMUM RESOLUTION && Math . abs ( line Vector Z ) < MINIMUM RESOLUTION ) { return ; } final double denom YZ = this . y * q . z - this . z * q . y ; final double denom XZ = this . x * q . z - this . z * q . x ; final double denom XY = this . x * q . y - this . y * q . x ; if ( Math . abs ( denom YZ ) >= Math . abs ( denom XZ ) && Math . abs ( denom YZ ) >= Math . abs ( denom XY ) ) { if ( Math . abs ( denom YZ ) < MINIMUM RESOLUTION SQUARED ) { return ; } final double denom = NUM_ / denom YZ ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , NUM_ , ( - ( this . D + MINIMUM RESOLUTION ) * q . z - this . z * - ( q . D + MINIMUM RESOLUTION ) ) * denom , ( this . y * - ( q . D + MINIMUM RESOLUTION ) + ( this . D + MINIMUM RESOLUTION ) * q . y ) * denom , bounds ) ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , NUM_ , ( - ( this . D - MINIMUM RESOLUTION ) * q . z - this . z * - ( q . D + MINIMUM RESOLUTION ) ) * denom , ( this . y * - ( q . D + MINIMUM RESOLUTION ) + ( this . D - MINIMUM RESOLUTION ) * q . y ) * denom , bounds ) ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , NUM_ , ( - ( this . D + MINIMUM RESOLUTION ) * q . z - this . z * - ( q . D - MINIMUM RESOLUTION ) ) * denom , ( this . y * - ( q . D - MINIMUM RESOLUTION ) + ( this . D + MINIMUM RESOLUTION ) * q . y ) * denom , bounds ) ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , NUM_ , ( - ( this . D - MINIMUM RESOLUTION ) * q . z - this . z * - ( q . D - MINIMUM RESOLUTION ) ) * denom , ( this . y * - ( q . D - MINIMUM RESOLUTION ) + ( this . D - MINIMUM RESOLUTION ) * q . y ) * denom , bounds ) ; } else if ( Math . abs ( denom XZ ) >= Math . abs ( denom XY ) && Math . abs ( denom XZ ) >= Math . abs ( denom YZ ) ) { if ( Math . abs ( denom XZ ) < MINIMUM RESOLUTION SQUARED ) { return ; } final double denom = NUM_ / denom XZ ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , ( - ( this . D + MINIMUM RESOLUTION ) * q . z - this . z * - ( q . D + MINIMUM RESOLUTION ) ) * denom , NUM_ , ( this . x * - ( q . D + MINIMUM RESOLUTION ) + ( this . D + MINIMUM RESOLUTION ) * q . x ) * denom , bounds ) ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , ( - ( this . D - MINIMUM RESOLUTION ) * q . z - this . z * - ( q . D + MINIMUM RESOLUTION ) ) * denom , NUM_ , ( this . x * - ( q . D + MINIMUM RESOLUTION ) + ( this . D - MINIMUM RESOLUTION ) * q . x ) * denom , bounds ) ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , ( - ( this . D + MINIMUM RESOLUTION ) * q . z - this . z * - ( q . D - MINIMUM RESOLUTION ) ) * denom , NUM_ , ( this . x * - ( q . D - MINIMUM RESOLUTION ) + ( this . D + MINIMUM RESOLUTION ) * q . x ) * denom , bounds ) ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , ( - ( this . D - MINIMUM RESOLUTION ) * q . z - this . z * - ( q . D - MINIMUM RESOLUTION ) ) * denom , NUM_ , ( this . x * - ( q . D - MINIMUM RESOLUTION ) + ( this . D - MINIMUM RESOLUTION ) * q . x ) * denom , bounds ) ; } else { if ( Math . abs ( denom XY ) < MINIMUM RESOLUTION SQUARED ) { return ; } final double denom = NUM_ / denom XY ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , ( - ( this . D + MINIMUM RESOLUTION ) * q . y - this . y * - ( q . D + MINIMUM RESOLUTION ) ) * denom , ( this . x * - ( q . D + MINIMUM RESOLUTION ) + ( this . D + MINIMUM RESOLUTION ) * q . x ) * denom , NUM_ , bounds ) ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , ( - ( this . D - MINIMUM RESOLUTION ) * q . y - this . y * - ( q . D + MINIMUM RESOLUTION ) ) * denom , ( this . x * - ( q . D + MINIMUM RESOLUTION ) + ( this . D - MINIMUM RESOLUTION ) * q . x ) * denom , NUM_ , bounds ) ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , ( - ( this . D + MINIMUM RESOLUTION ) * q . y - this . y * - ( q . D - MINIMUM RESOLUTION ) ) * denom , ( this . x * - ( q . D - MINIMUM RESOLUTION ) + ( this . D + MINIMUM RESOLUTION ) * q . x ) * denom , NUM_ , bounds ) ; record Line Bounds ( planet Model , bounds Info , line Vector X , line Vector Y , line Vector Z , ( - ( this . D - MINIMUM RESOLUTION ) * q . y - this . y * - ( q . D - MINIMUM RESOLUTION ) ) * denom , ( this . x * - ( q . D - MINIMUM RESOLUTION ) + ( this . D - MINIMUM RESOLUTION ) * q . x ) * denom , NUM_ , bounds ) ; } }
public void only Samples ( String ... samples ) { m Only Sample = Arrays . as List ( samples ) ; }
public void sort Players ( ) { Collections . sort ( team Q Bs , new Player Comparator ( ) ) ; Collections . sort ( team R Bs , new Player Comparator ( ) ) ; Collections . sort ( team W Rs , new Player Comparator ( ) ) ; Collections . sort ( team Ks , new Player Comparator ( ) ) ; Collections . sort ( team O Ls , new Player Comparator ( ) ) ; Collections . sort ( team C Bs , new Player Comparator ( ) ) ; Collections . sort ( team Ss , new Player Comparator ( ) ) ; Collections . sort ( team F 7 s , new Player Comparator ( ) ) ; Collections . sort ( team R Ss , new Player Comparator ( ) ) ; Collections . sort ( team F Rs , new Player Comparator ( ) ) ; Collections . sort ( team S Os , new Player Comparator ( ) ) ; Collections . sort ( team J Rs , new Player Comparator ( ) ) ; Collections . sort ( team S Rs , new Player Comparator ( ) ) ; }
private void write Object ( Object Output Stream s ) throws IO Exception { if ( actions == null ) get Actions ( ) ; s . default Write Object ( ) ; }
public static void register Fuel Handler ( I Fuel Handler handler , Fuel Type type ) { switch ( type ) { case CRYSTALLIZER : crystallizer Fuel Handlers . add ( handler ) ; break ; case TRANSMUTATOR : transmutator Fuel Handlers . add ( handler ) ; break ; case FURNACE : Game Registry . register Fuel Handler ( handler ) ; } }
private void fetch ( boolean fail On Eof ) throws Parse Exception { if ( null != current ) { return ; } List < Token < T > > filtered = null ; Token < T > t = null ; if ( ! eof ) { while ( tstream . has Next ( ) ) { t = tstream . next ( ) ; if ( token Filter . accept ( t ) ) { break ; } if ( null == filtered ) { filtered = new Array List < Token < T > > ( ) ; } filtered . add ( t ) ; t = null ; } } if ( null == t ) { eof = true ; if ( fail On Eof ) { throw new Parse Exception ( new Message ( Message Type . END OF FILE , ( null != input Range ? this . input Range : this . file ) ) ) ; } return ; } Token List < T > tl = new Token List < T > ( ) ; tl . t = t ; tl . filtered Tokens = null != filtered ? Collections . < Token < T > > unmodifiable List ( filtered ) : Collections . < Token < T > > empty List ( ) ; current = tl ; if ( null != prev ) { prev . next = tl ; } }
public static < Containing Type extends Message Lite , Type > Generated Extension < Containing Type , Type > new Repeated Generated Extension ( final Containing Type containing Type Default Instance , final Message Lite message Default Instance , final Internal . Enum Lite Map < ? > enum Type Map , final int number , final Wire Format . Field Type type , final boolean is Packed , final Class singular Type ) { @ Suppress Warnings ( STR_ ) Type empty List = ( Type ) Collections . empty List ( ) ; return new Generated Extension < Containing Type , Type > ( containing Type Default Instance , empty List , message Default Instance , new Extension Descriptor ( enum Type Map , number , type , true , is Packed ) , singular Type ) ; }
@ Override public String generate Label String ( XY Dataset dataset , int series , int item ) { String result ; Object [ ] items = create Item Array ( ( XYZ Dataset ) dataset , series , item ) ; result = Message Format . format ( get Format String ( ) , items ) ; return result ; }
private Dictionary load Dictionary ( String locale , Settings node Settings , Environment env ) throws Exception { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ , locale ) ; } Path dic Dir = hunspell Dir . resolve ( locale ) ; if ( File System Utils . is Accessible Directory ( dic Dir , logger ) == false ) { throw new Elasticsearch Exception ( String . format ( Locale . ROOT , STR_ , locale ) ) ; } node Settings = load Dictionary Settings ( dic Dir , node Settings . get By Prefix ( STR_ + locale + STR_ ) ) ; boolean ignore Case = node Settings . get As Boolean ( STR_ , default Ignore Case ) ; Path [ ] affix Files = File System Utils . files ( dic Dir , STR_ ) ; if ( affix Files . length == NUM_ ) { throw new Elasticsearch Exception ( String . format ( Locale . ROOT , STR_ , locale ) ) ; } if ( affix Files . length != NUM_ ) { throw new Elasticsearch Exception ( String . format ( Locale . ROOT , STR_ , locale ) ) ; } Input Stream affix Stream = null ; Path [ ] dic Files = File System Utils . files ( dic Dir , STR_ ) ; List < Input Stream > dic Streams = new Array List < > ( dic Files . length ) ; try { for ( int i = NUM_ ; i < dic Files . length ; i ++ ) { dic Streams . add ( Files . new Input Stream ( dic Files [ i ] ) ) ; } affix Stream = Files . new Input Stream ( affix Files [ NUM_ ] ) ; return new Dictionary ( affix Stream , dic Streams , ignore Case ) ; } catch ( Exception e ) { logger . error ( STR_ , e , locale ) ; throw e ; } finally { if ( affix Stream != null ) { try { affix Stream . close ( ) ; } catch ( IO Exception e ) { } } for ( Input Stream in : dic Streams ) { if ( in != null ) { try { in . close ( ) ; } catch ( IO Exception e ) { } } } } }
public static Run Stats delegate Get Bucket For Double ( int buckets ) throws Exception { Long start Time = System . current Time Millis ( ) ; Primary Index Bucket Generator Impl ibg = new Primary Index Bucket Generator Impl ( Field Data Type . DOUBLE , buckets ) ; Primary Index Bucket Locator Impl locator = new Primary Index Bucket Locator Impl ( null , null , ibg . generate Buckets ( ) , null , null , null , null , null , null ) ; logger . debug ( STR_ ) ; Hash Map < Long , List < Object > > hm = new Hash Map < > ( ) ; Summary Statistics stats = new Summary Statistics ( ) ; Normal Distribution dist = new Normal Distribution ( NUM_ , NUM_ ) ; Random r = new Random ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { double normal Random = dist . sample ( ) ; double scale Random = Math . random ( ) ; if ( scale Random < NUM_ ) { normal Random = normal Random * NUM_ ; } else if ( scale Random < NUM_ ) { normal Random = normal Random * NUM_ ; } else if ( scale Random < NUM_ ) { normal Random = normal Random * NUM_ ; } else { normal Random = normal Random * NUM_ ; } Long bucket Id = locator . get Bucket ( normal Random , Field Data Type . DOUBLE ) ; calculate ( hm , stats , bucket Id , normal Random ) ; } Long run Time = System . current Time Millis ( ) - start Time ; Run Stats run Stats = new Run Stats ( STR_ , Field Data Type . DOUBLE , run Time , stats , hm ) ; logger . debug ( run Stats . to String ( ) ) ; return run Stats ; }
private void increase Event Count ( Map < String , Integer > event Counts , Predicate < String > predicate ) { int impression Count = event Counts . get Or Default ( STR_ , NUM_ ) ; int impression Unique Count = Math . min ( impression Count , NUM_ ) ; int joint Counts = NUM_ ; if ( ! predicate . test ( STR_ ) ) { joint Counts += event Counts . get Or Default ( STR_ , NUM_ ) ; } if ( ! predicate . test ( STR_ ) ) { joint Counts += event Counts . get Or Default ( STR_ , NUM_ ) ; } int joint Unique Count = Math . min ( joint Counts , NUM_ ) ; impression Counts . put ( STR_ , impression Counts . get Or Default ( STR_ , NUM_ ) + impression Count ) ; impression Counts . put ( STR_ , impression Counts . get Or Default ( STR_ , NUM_ ) + impression Unique Count ) ; joint Action Counts . put ( STR_ , joint Action Counts . get Or Default ( STR_ , NUM_ ) + joint Counts ) ; joint Action Counts . put ( STR_ , joint Action Counts . get Or Default ( STR_ , NUM_ ) + joint Unique Count ) ; }
public static void over Scroll By ( final Pull To Refresh Base < ? > view , final int delta X , final int scroll X , final int delta Y , final int scroll Y , final int scroll Range , final int fuzzy Threshold , final float scale Factor , final boolean is Touch Event ) { Log . i ( TAG , STR_ + delta Y ) ; Log . i ( TAG , STR_ + scroll Y ) ; Log . i ( TAG , STR_ + scroll Range ) ; Log . i ( TAG , STR_ + fuzzy Threshold ) ; Log . i ( TAG , STR_ + scale Factor ) ; Log . i ( TAG , STR_ + is Touch Event ) ; final int delta Value , current Scroll Value , scroll Value ; switch ( view . get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : delta Value = delta X ; scroll Value = scroll X ; current Scroll Value = view . get Scroll X ( ) ; break ; case VERTICAL : default : delta Value = delta Y ; scroll Value = scroll Y ; current Scroll Value = view . get Scroll Y ( ) ; break ; } if ( view . is Pull To Refresh Over Scroll Enabled ( ) && ! view . is Refreshing ( ) ) { final Mode mode = view . get Mode ( ) ; if ( mode . permits Pull To Refresh ( ) && ! is Touch Event && delta Value != NUM_ ) { final int new Scroll Value = ( delta Value + scroll Value ) ; if ( Pull To Refresh Base . DEBUG ) { Log . d ( LOG TAG , STR_ + delta X + STR_ + scroll X + STR_ + delta Y + STR_ + scroll Y + STR_ + new Scroll Value + STR_ + scroll Range + STR_ + current Scroll Value ) ; } if ( new Scroll Value < ( NUM_ - fuzzy Threshold ) ) { if ( mode . show Header Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( State . OVERSCROLLING ) ; } Log . i ( LOG TAG , STR_ + scale Factor ) ; Log . i ( LOG TAG , STR_ + current Scroll Value ) ; Log . i ( LOG TAG , STR_ + new Scroll Value ) ; view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value ) ) ) ; } } else if ( new Scroll Value > ( scroll Range + fuzzy Threshold ) ) { if ( mode . show Footer Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( State . OVERSCROLLING ) ; } Log . i ( LOG TAG , STR_ + scale Factor ) ; Log . i ( LOG TAG , STR_ + current Scroll Value ) ; Log . i ( LOG TAG , STR_ + new Scroll Value ) ; Log . i ( LOG TAG , STR_ + scroll Range ) ; view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value - scroll Range ) ) ) ; } } else if ( Math . abs ( new Scroll Value ) <= fuzzy Threshold || Math . abs ( new Scroll Value - scroll Range ) <= fuzzy Threshold ) { view . set State ( State . RESET ) ; } } else if ( is Touch Event && State . OVERSCROLLING == view . get State ( ) ) { view . set State ( State . RESET ) ; } } }
private void append Evaluated ( String Buffer buffer , String s ) { boolean escape = false ; boolean dollar = false ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == STR_ && ! escape ) { escape = true ; } else if ( c == STR_ && ! escape ) { dollar = true ; } else if ( c >= STR_ && c <= STR_ && dollar ) { buffer . append ( group ( c - STR_ ) ) ; dollar = false ; } else { buffer . append ( c ) ; dollar = false ; escape = false ; } } if ( escape ) { throw new Array Index Out Of Bounds Exception ( s . length ( ) ) ; } }
private static String make Qualified Method Name ( String name , String [ ] params ) { String Buffer sb = new String Buffer ( name ) ; sb . append ( STR_ ) ; for ( int i = NUM_ ; i < params . length ; i ++ ) { sb . append ( STR_ ) ; sb . append ( params [ i ] ) ; } return sb . to String ( ) ; }
public void add Event Type ( String event Type Name , Class event Class ) { add Event Type ( event Type Name , event Class . get Name ( ) ) ; }
public static I Proposal Computer new Ui Field Attribute Proposal Computer ( Content Assist Request content Assist Request ) { IDOM Node node = ( IDOM Node ) content Assist Request . get Node ( ) ; if ( node . get Node Type ( ) != IDOM Node . ELEMENT NODE ) { return null ; } if ( Xml Utilities . get Attribute ( node , Ui Binder Constants . UI BINDER FIELD ATTRIBUTE NAME , true , Ui Binder Constants . UI BINDER XML NAMESPACE ) != null ) { return null ; } boolean is Widget = Ui Binder Xml Model Utilities . compute Qualified Widget Type Name ( node ) != null ; boolean is Likely Html Element = node . get Namespace URI ( ) == null ; if ( ! ( is Widget || is Likely Html Element ) ) { return null ; } return create Static Text Proposal Computer For Ui Attribute ( Ui Binder Constants . UI BINDER FIELD ATTRIBUTE NAME , node , content Assist Request ) ; }
protected static float [ ] create Gaussian Kernel ( int radius ) { if ( radius < NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } float [ ] data = new float [ radius * NUM_ + NUM_ ] ; float sigma = radius / NUM_ ; float two Sigma Square = NUM_ * sigma * sigma ; float sigma Root = ( float ) Math . sqrt ( two Sigma Square * Math . PI ) ; float total = NUM_ ; for ( int i = - radius ; i <= radius ; i ++ ) { float distance = i * i ; int index = i + radius ; data [ index ] = ( float ) Math . exp ( - distance / two Sigma Square ) / sigma Root ; total += data [ index ] ; } for ( int i = NUM_ ; i < data . length ; i ++ ) { data [ i ] /= total ; } return data ; }
public void scroll To ( float position , boolean decelerate , boolean needs Position Updates ) { m Needs Position Updates = needs Position Updates ; if ( m Scroll Animator != null ) m Scroll Animator . cancel ( ) ; position = Math . round ( position ) ; if ( m Images != null && m Images . length == NUM_ ) { if ( position < NUM_ ) position = NUM_ ; if ( position > NUM_ ) position = NUM_ ; } m Scroll Animator = Object Animator . of Float ( this , POSITION PROPERTY , m Position , position ) ; m Scroll Animator . set Duration ( SCROLL ANIMATION DURATION MS ) ; if ( decelerate ) m Scroll Animator . set Interpolator ( new Decelerate Interpolator ( ) ) ; m Scroll Animator . start ( ) ; }
public void update Labelling ( Label node Label ) { for ( Iterator it = iterator ( ) ; it . has Next ( ) ; ) { Directed Edge de = ( Directed Edge ) it . next ( ) ; Label label = de . get Label ( ) ; label . set All Locations If Null ( NUM_ , node Label . get Location ( NUM_ ) ) ; label . set All Locations If Null ( NUM_ , node Label . get Location ( NUM_ ) ) ; } }
private String generate C Hash ( String algorithm , O Auth 2 Request request , O Auth 2 Provider Settings provider Settings ) throws Server Exception { final Authorization Code authorization Code = request . get Token ( Authorization Code . class ) ; if ( authorization Code == null ) { logger . message ( STR_ ) ; return null ; } final String code Value = authorization Code . get Token Id ( ) ; return generate Hash ( algorithm , code Value , provider Settings ) ; }
@ Caller Sensitive public static < U > Atomic Long Field Updater < U > new Updater ( Class < U > tclass , String field Name ) { Class < ? > caller = Reflection . get Caller Class ( ) ; if ( Atomic Long . VM SUPPORTS LONG CAS ) return new CAS Updater < U > ( tclass , field Name , caller ) ; else return new Locked Updater < U > ( tclass , field Name , caller ) ; }
public Mutable Attribute Set url ( String url ) { Simple Attribute Set url Style = new Simple Attribute Set ( ) ; Style Constants . set Underline ( url Style , true ) ; url Style . add Attribute ( HTML . Attribute . HREF , url ) ; return url Style ; }
public Loco Net Message next Transfer ( ) { if ( transfer Start ) { transfer Start = false ; transfer Index = NUM_ ; byte [ ] header = new byte [ NUM_ ] ; header [ NUM_ ] = ( byte ) transfer Handle ; header [ NUM_ ] = ( byte ) ( transfer Contents . length & NUM_ ) ; header [ NUM_ ] = ( byte ) ( ( transfer Contents . length / NUM_ ) & NUM_ ) ; header [ NUM_ ] = ( byte ) ( ( transfer Contents . length / NUM_ / NUM_ ) & NUM_ ) ; header [ NUM_ ] = NUM_ ; header [ NUM_ ] = NUM_ ; header [ NUM_ ] = NUM_ ; header [ NUM_ ] = NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { header [ i ] = NUM_ ; } if ( transfer Name . length ( ) > NUM_ ) { log . error ( STR_ + transfer Name + STR_ ) ; } for ( int i = NUM_ ; i < Math . min ( NUM_ , transfer Name . length ( ) ) ; i ++ ) { header [ i + NUM_ ] = ( byte ) transfer Name . char At ( i ) ; } return get Send Data Message ( transfer Type , transfer Handle , header ) ; } else { int remaining = transfer Contents . length - transfer Index ; if ( remaining < NUM_ ) { log . error ( STR_ + transfer Contents . length + STR_ + transfer Index ) ; } if ( remaining <= NUM_ ) { return null ; } int send Size = remaining ; if ( remaining > SENDDATASIZE ) { send Size = SENDDATASIZE ; } byte [ ] buffer = new byte [ send Size ] ; for ( int i = NUM_ ; i < send Size ; i ++ ) { buffer [ i ] = transfer Contents [ transfer Index + i ] ; } transfer Index = transfer Index + send Size ; return get Send Data Message ( transfer Type , transfer Handle , buffer ) ; } }
private void fetch Search Service Cards From Server ( String keyword ) { final Map < String , String > params = new Hash Map < String , String > ( NUM_ ) ; params . put ( Http Constants . LATITUDE , Shared Preference Helper . get String ( R . string . pref latitude ) ) ; params . put ( Http Constants . LONGITUDE , Shared Preference Helper . get String ( R . string . pref longitude ) ) ; params . put ( Http Constants . TYPE , Http Constants . Search Type . SERVICE CARD ) ; params . put ( Http Constants . PER , STR_ ) ; params . put ( Http Constants . RADIUS , STR_ ) ; params . put ( Http Constants . TITLE , keyword ) ; Retro Callback retro Callback ; retro Callback = new Retro Callback ( this ) ; retro Callback . set Request Id ( Http Constants . Api Response Codes . SEARCH SERVICES ) ; retro Callback List . add ( retro Callback ) ; params . put ( Http Constants . PAGE , STR_ ) ; m Yelo Api . get Service Cards ( params , retro Callback ) ; m Swipe Refresh Layout . set Refreshing ( true ) ; }
public String rotate Key ( ) { return rotate Key ( false ) ; }
public void report ( Quality Query qq , Top Docs td , String doc Name Field , Index Searcher searcher ) throws IO Exception { if ( logger == null ) { return ; } Score Doc sd [ ] = td . score Docs ; String sep = STR_ ; Doc Name Extractor xt = new Doc Name Extractor ( doc Name Field ) ; for ( int i = NUM_ ; i < sd . length ; i ++ ) { String doc Name = xt . doc Name ( searcher , sd [ i ] . doc ) ; logger . println ( qq . get Query ID ( ) + sep + STR_ + sep + format ( doc Name , NUM_ ) + sep + format ( STR_ + i , NUM_ ) + sep + nf . format ( sd [ i ] . score ) + sep + name ) ; } }
private void create Mapping ( final List < Map Object Type > map Object Type List ) { for ( final Entity Type entity Type : exported Entity Types ) { if ( entity Type != null ) { final Map Object Type map Object Type = new Map Object Type ( ) ; map Object Type . set Int Id ( entity Type . get Id ( ) ) ; map Object Type . set Ext Id ( entity Type . get Id ( ) ) ; final List < Map Attribute Type > map Attribute Types = map Object Type . get Map Attribute Type ( ) ; for ( final Property Type property Type : entity Type . get All Property Types ( ) ) { final Map Attribute Type map Attribute Type = new Map Attribute Type ( ) ; map Attribute Type . set Ext Id ( property Type . get Id ( ) ) ; map Attribute Type . set Int Id ( property Type . get Id ( ) ) ; map Attribute Types . add ( map Attribute Type ) ; } map Object Type List . add ( map Object Type ) ; } } for ( final String type Id : exported Types ) { final Map Object Type map Object Type = new Map Object Type ( ) ; map Object Type . set Int Id ( type Id ) ; map Object Type . set Ext Id ( type Id ) ; map Object Type List . add ( map Object Type ) ; } }
public void ensure Capacity ( int capacity ) { if ( m Garbage && m Size >= m Keys . length ) { gc ( ) ; } if ( m Keys . length < capacity ) { int [ ] nkeys = new int [ capacity ] ; Object [ ] nvalues = new Object [ capacity ] ; System . arraycopy ( m Keys , NUM_ , nkeys , NUM_ , m Keys . length ) ; System . arraycopy ( m Values , NUM_ , nvalues , NUM_ , m Values . length ) ; m Keys = nkeys ; m Values = nvalues ; } }
protected Map < Binding Set Hash Key , List < Binding Set > > make Hash Table ( int initial Size ) { Map < Binding Set Hash Key , List < Binding Set > > next Hash Table ; if ( join Attributes . length > NUM_ ) { next Hash Table = new Hash Map < Binding Set Hash Key , List < Binding Set > > ( initial Size ) ; } else { List < Binding Set > l = ( initial Size > NUM_ ) ? new Array List < Binding Set > ( initial Size ) : null ; next Hash Table = Collections . < Binding Set Hash Key , List < Binding Set > > singleton Map ( Binding Set Hash Key . EMPTY , l ) ; } return next Hash Table ; }
public double local Score ( int i , int [ ] parents ) { double sum = NUM_ ; int count = NUM_ ; for ( Sem Bic Score score : sem Bic Scores ) { double score = score . local Score ( i , parents ) ; if ( ! Double . is Na N ( score ) ) { sum += score ; count ++ ; } } return sum / count ; }
void unexecute NS Decls ( Transformer Impl transformer ) throws Transformer Exception { unexecute NS Decls ( transformer , null ) ; }
@ Suppress Warnings ( { STR_ , STR_ } ) @ Nullable public Class < ? > deployed Class ( String cls Name , String ... alias ) { Class < ? > cls = clss . get ( cls Name ) ; if ( cls == null ) { try { cls = Class . for Name ( cls Name , true , cls Ldr ) ; Class < ? > cur = clss . put If Absent ( cls Name , cls ) ; if ( cur == null ) { for ( String a : alias ) { clss . put If Absent ( a , cls ) ; } on Deployed ( cls ) ; } } catch ( Class Not Found Exception ignored ) { for ( String a : alias ) { cls = clss . get ( a ) ; if ( cls != null ) return cls ; else if ( ! a . equals ( cls Name ) ) { try { cls = Class . for Name ( a , true , cls Ldr ) ; } catch ( Class Not Found Exception ignored 0 ) { continue ; } Class < ? > cur = clss . put If Absent ( a , cls ) ; if ( cur == null ) { for ( String a 1 : alias ) { if ( a 1 != a ) clss . put If Absent ( a 1 , cls ) ; } on Deployed ( cls ) ; } return cls ; } } } } return cls ; }
public static void process Remove Variable Instruction ( Execution Context ec , String varname ) throws DML Runtime Exception { Data input 1 data = ec . remove Variable ( varname ) ; if ( input 1 data == null ) throw new DML Runtime Exception ( STR_ + varname + STR_ ) ; if ( input 1 data instanceof Matrix Object ) { ec . cleanup Matrix Object ( ( Matrix Object ) input 1 data ) ; } }
private boolean user Wants To Convert ( ) { if ( m user Has Been Asked About Conversion ) return true ; m user Has Been Asked About Conversion = true ; return ( J Option Pane . show Confirm Dialog ( this , STR_ + STR_ + STR_ + STR_ , STR_ , J Option Pane . YES NO OPTION , J Option Pane . WARNING MESSAGE ) == J Option Pane . YES OPTION ) ; }
public void check Jvm Thread Cpu Time Monitoring ( Enum Jvm Thread Cpu Time Monitoring x ) throws Snmp Status Exception { if ( Jvm Thread Cpu Time Monitoring Unsupported . int Value ( ) == x . int Value ( ) ) { log . debug ( STR_ , STR_ ) ; throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Wrong Value ) ; } if ( ( Jvm Thread Cpu Time Monitoring Enabled . int Value ( ) == x . int Value ( ) ) || ( Jvm Thread Cpu Time Monitoring Disabled . int Value ( ) == x . int Value ( ) ) ) { Thread MX Bean mbean = get Thread MX Bean ( ) ; if ( mbean . is Thread Cpu Time Supported ( ) ) return ; log . debug ( STR_ , STR_ ) ; throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Inconsistent Value ) ; } log . debug ( STR_ , STR_ ) ; throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Wrong Value ) ; }
private void dag DFS ( Lop root , boolean [ ] marked ) { if ( ! ID Map . contains Key ( root . get ID ( ) ) ) return ; int map ID = ID Map . get ( root . get ID ( ) ) ; if ( marked [ map ID ] ) return ; marked [ map ID ] = true ; for ( Lop lop : root . get Outputs ( ) ) { dag DFS ( lop , marked ) ; } }
@ Override protected void finalize ( ) throws Throwable { shutdown Now ( ) ; super . finalize ( ) ; }
private static void append Double Type ( String Builder sb ) { sb . append ( STR_ ) ; }
public void insert Chars ( String c ) { String current Text = get Text ( ) ; if ( ! valid Char ( c ) ) { return ; } int pos = get Cursor Position ( ) + NUM_ ; if ( overwrite Mode && pos <= current Text . length ( ) ) { set Text ( current Text . substring ( NUM_ , pos - NUM_ ) + c + current Text . substring ( pos , current Text . length ( ) ) ) ; } else { if ( current Text . length ( ) + c . length ( ) > get Max Size ( ) ) { return ; } set Text ( current Text . substring ( NUM_ , pos - NUM_ ) + c + current Text . substring ( pos - NUM_ , current Text . length ( ) ) ) ; } if ( c . length ( ) > NUM_ ) { pos += c . length ( ) - NUM_ ; set Cursor Position ( pos ) ; return ; } increase Cursor ( ) ; }
@ Override public void add Property Change Listener ( Property Change Listener pcl ) { m pcs . add Property Change Listener ( pcl ) ; }
protected boolean logged Into Valid Realm ( String requested Realm , String logged In Realm ) { return requested Realm . equals Ignore Case ( logged In Realm ) || Realm Utils . is Parent Realm ( logged In Realm , requested Realm ) ; }
protected void index Polygons ( Input Stream is , long ptr , List < Entry > entries ) { boolean more Records = true ; byte r Hdr [ ] = new byte [ SHAPE RECORD HEADER LENGTH ] ; int result ; int shape Type ; int n Records = NUM_ ; int rec Length Words , rec Length Bytes ; long rec Offset ; int rec Buf Size = NUM_ ; byte rec Buf [ ] = new byte [ rec Buf Size ] ; ESRI Bounding Box poly Bounds ; try { while ( more Records ) { result = is . read ( r Hdr , NUM_ , SHAPE RECORD HEADER LENGTH ) ; if ( result < NUM_ ) { more Records = false ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + n Records + STR_ ) ; logger . fine ( STR_ + rec Buf Size ) ; } } else { n Records ++ ; rec Offset = ptr ; read BE Int ( r Hdr , NUM_ ) ; rec Length Words = read BE Int ( r Hdr , NUM_ ) ; rec Length Bytes = rec Length Words * NUM_ ; if ( rec Length Bytes > rec Buf Size ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + rec Length Bytes ) ; } rec Buf Size = rec Length Bytes ; rec Buf = new byte [ rec Buf Size ] ; } result = is . read ( rec Buf , NUM_ , rec Length Bytes ) ; shape Type = read LE Int ( rec Buf , NUM_ ) ; if ( shape Type != SHAPE TYPE NULL ) { poly Bounds = read Box ( rec Buf , NUM_ ) ; } else { poly Bounds = new ESRI Bounding Box ( ) ; } ptr += rec Length Bytes + NUM_ ; Entry entry = new Entry ( poly Bounds . min . x , poly Bounds . min . y , poly Bounds . max . x , poly Bounds . max . y , ( int ) rec Offset ) ; entries . add ( entry ) ; } } } catch ( java . io . IO Exception e ) { e . print Stack Trace ( ) ; } finally { try { is . close ( ) ; } catch ( java . io . IO Exception e ) { } } }
public void append Type Parameter Label ( I Type Parameter type Parameter , long flags ) { try { append Type Parameter With Bounds ( type Parameter , flags ) ; if ( get Flag ( flags , TP POST QUALIFIED ) ) { f Buffer . append ( CONCAT STRING ) ; I Member declaring Member = type Parameter . get Declaring Member ( ) ; append Element Label ( declaring Member , M PARAMETER TYPES | M FULLY QUALIFIED | T FULLY QUALIFIED | ( flags & QUALIFIER FLAGS ) ) ; } } catch ( Java Model Exception e ) { e . print Stack Trace ( ) ; } }
private Recycler View . Item Decoration parse Transforms ( String raw ) { if ( raw == null ) { return null ; } float scale X = NUM_ , scale Y = NUM_ ; int translate X = NUM_ , translate Y = NUM_ ; float opacity = NUM_ ; int rotate = NUM_ ; Matcher matcher = transform Pattern . matcher ( raw ) ; while ( matcher . find ( ) ) { String match = matcher . group ( ) ; String name = matcher . group ( NUM_ ) ; try { switch ( name ) { case STR_ : scale X = Float . parse Float ( matcher . group ( NUM_ ) ) ; scale Y = Float . parse Float ( matcher . group ( NUM_ ) ) ; break ; case STR_ : translate X = Integer . parse Int ( matcher . group ( NUM_ ) ) ; translate Y = Integer . parse Int ( matcher . group ( NUM_ ) ) ; break ; case STR_ : opacity = Float . parse Float ( matcher . group ( NUM_ ) ) ; break ; case STR_ : rotate = Integer . parse Int ( matcher . group ( NUM_ ) ) ; break ; default : WX Log Utils . e ( TAG , STR_ + match ) ; break ; } } catch ( Number Format Exception e ) { WX Log Utils . e ( STR_ , e ) ; WX Log Utils . e ( TAG , STR_ + match ) ; } } return new Transform Item Decoration ( get Orientation ( ) == Constants . Orientation . VERTICAL , opacity , translate X , translate Y , rotate , scale X , scale Y ) ; }
private boolean is Online ( ) { String port = HOST IP . contains ( STR_ ) ? HOST IP . substring ( HOST IP . index Of ( STR_ ) + NUM_ ) : STR_ ; String ip = HOST IP . contains ( STR_ ) ? HOST IP . substring ( NUM_ , HOST IP . index Of ( STR_ ) ) : HOST IP ; Socket socket = null ; try { Socket Address sockaddr = new Inet Socket Address ( ip , new Integer ( port ) ) ; socket = new Socket ( ) ; socket . connect ( sockaddr , NUM_ ) ; } catch ( Number Format Exception | IO Exception e ) { return false ; } finally { try { if ( socket != null ) { socket . close ( ) ; } } catch ( IO Exception ex ) { } } return true ; }
public String process Default Val From State Only ( I State Access state ) throws Install Exception { String result = null ; result = ( String ) state . get ( get Key ( ) ) ; return result ; }
public void register Listeners ( Property Change Support pcs ) { Property Change Listener listener = new HP Change Listener ( ) ; add Property Change Listener With Modified Support ( pcs , STR_ , listener ) ; add Property Change Listener With Modified Support ( pcs , STR_ , listener ) ; listener = new ATK Change Listener ( ) ; add Property Change Listener With Modified Support ( pcs , STR_ , listener ) ; pcs . add Property Change Listener ( STR_ , listener ) ; listener = new DEF Change Listener ( ) ; add Property Change Listener With Modified Support ( pcs , STR_ , listener ) ; pcs . add Property Change Listener ( STR_ , listener ) ; if ( Testing . COMBAT ) { listener = new RATK Change Listener ( ) ; add Property Change Listener With Modified Support ( pcs , STR_ , listener ) ; pcs . add Property Change Listener ( STR_ , listener ) ; } listener = new XP Change Listener ( ) ; pcs . add Property Change Listener ( STR_ , listener ) ; listener = new Level Change Listener ( ) ; add Property Change Listener With Modified Support ( pcs , STR_ , listener ) ; listener = new Weapon Change Listener ( ) ; pcs . add Property Change Listener ( STR_ , listener ) ; listener = new Armor Change Listener ( ) ; pcs . add Property Change Listener ( STR_ , listener ) ; if ( Testing . COMBAT ) { listener = new Ranged Weapon Change Listener ( ) ; pcs . add Property Change Listener ( STR_ , listener ) ; } listener = new Money Change Listener ( ) ; for ( String slot : MONEY SLOTS ) { pcs . add Property Change Listener ( slot , listener ) ; } listener = new Eating Change Listener ( ) ; pcs . add Property Change Listener ( STR_ , listener ) ; pcs . add Property Change Listener ( STR_ , listener ) ; listener = new Status Change Listener ( ) ; for ( Status ID id : Status ID . values ( ) ) { pcs . add Property Change Listener ( id . get Attribute ( ) , listener ) ; } listener = new Away Change Listener ( ) ; pcs . add Property Change Listener ( STR_ , listener ) ; listener = new Grumpy Change Listener ( ) ; pcs . add Property Change Listener ( STR_ , listener ) ; listener = new Karma Change Listener ( ) ; pcs . add Property Change Listener ( STR_ , listener ) ; listener = new Mana Change Listener ( ) ; add Property Change Listener With Modified Support ( pcs , STR_ , listener ) ; add Property Change Listener With Modified Support ( pcs , STR_ , listener ) ; }
public static void run Update Port Associations Process For V Array Change ( Storage Port port , Db Client db Client , Coordinator Client coordinator , List < Storage Pool > pools , Virtual Array Assignment Changes varray Assignment Changes ) { try { URI storage System URI = port . get Storage Device ( ) ; Set < String > varrays To Add Ids = new Hash Set < > ( ) ; Set < String > varrays To Remove Ids = new Hash Set < > ( ) ; Virtual Array Assignments varrays To Add = varray Assignment Changes . get Add ( ) ; if ( varrays To Add != null ) { varrays To Add Ids = varrays To Add . get Varrays ( ) ; } Virtual Array Assignments varrays To Remove = varray Assignment Changes . get Remove ( ) ; if ( varrays To Remove != null ) { varrays To Remove Ids = varrays To Remove . get Varrays ( ) ; } Set < String > varrays With Out Changed Connectivity = new Hash Set < > ( varrays To Add Ids ) ; varrays With Out Changed Connectivity . add All ( varrays To Remove Ids ) ; Set < String > varrays With Changed Connectivity = Storage Port Association Helper . get V Arrays With Changed Connectivity To Storage System ( port , varrays To Add Ids , varrays To Remove Ids , db Client ) ; varrays With Out Changed Connectivity . remove All ( varrays With Changed Connectivity ) ; Collection < Storage Port > ports = Collections . singleton ( port ) ; if ( null == pools ) { pools = new Array List < Storage Pool > ( ) ; } Map < Network Lite , List < Storage Port > > ports By Network = group Ports By Network ( ports , db Client ) ; if ( ! ports By Network . is Empty ( ) ) { update Port Associations ( ports , ports By Network , db Client ) ; Set < URI > pool Uris = get Storage Pool Ids ( pools ) ; List < Storage Pool > modified Pools = Storage Pool Association Helper . get Storage Pools From Ports ( db Client , ports , null ) ; for ( Storage Pool pool : modified Pools ) { if ( ! pool Uris . contains ( pool . get Id ( ) ) ) { pools . add ( pool ) ; } } } if ( ! varrays With Changed Connectivity . is Empty ( ) ) { log . info ( STR_ , storage System URI , varrays With Changed Connectivity ) ; List < URI > vpool UR Is = get Vpools For Varrays ( varrays With Changed Connectivity , db Client ) ; log . info ( STR_ , vpool UR Is . size ( ) , vpool UR Is ) ; String Buffer error Message = new String Buffer ( ) ; Implicit Pool Matcher . match Modified Storage Pools With Virtual Pools ( pools , vpool UR Is , db Client , coordinator , Attribute Matcher . VPOOL MATCHERS , error Message ) ; } if ( ! varrays With Out Changed Connectivity . is Empty ( ) ) { log . info ( STR_ , storage System URI , varrays With Out Changed Connectivity ) ; List < URI > vpool UR Is = get Vpools For Varrays ( varrays With Out Changed Connectivity , db Client ) ; log . info ( STR_ , vpool UR Is . size ( ) , vpool UR Is ) ; String Buffer error Message = new String Buffer ( ) ; Implicit Pool Matcher . match Modified Storage Pools With Virtual Pools ( pools , vpool UR Is , db Client , coordinator , Attribute Matcher . CONNECTIVITY PLACEMENT MATCHERS , error Message ) ; } Hash Set < URI > systems To Process = Storage Pool Association Helper . get Storage Sytems From Ports ( ports , null ) ; Connectivity Util . update Rp Systems Connectivity ( systems To Process , db Client ) ; } catch ( Exception e ) { log . error ( STR_ , e ) ; } }
int find Sync Position ( ) { int count = m Item Count ; if ( count == NUM_ ) { return INVALID POSITION ; } long id To Match = m Sync Row Id ; int seed = m Sync Position ; if ( id To Match == INVALID ROW ID ) { return INVALID POSITION ; } seed = Math . max ( NUM_ , seed ) ; seed = Math . min ( count - NUM_ , seed ) ; long end Time = System Clock . uptime Millis ( ) + SYNC MAX DURATION MILLIS ; long row Id ; int first = seed ; int last = seed ; boolean next = false ; boolean hit First ; boolean hit Last ; T adapter = get Adapter ( ) ; if ( adapter == null ) { return INVALID POSITION ; } while ( System Clock . uptime Millis ( ) <= end Time ) { row Id = adapter . get Item Id ( seed ) ; if ( row Id == id To Match ) { return seed ; } hit Last = last == count - NUM_ ; hit First = first == NUM_ ; if ( hit Last && hit First ) { break ; } if ( hit First || ( next && ! hit Last ) ) { last ++ ; seed = last ; next = false ; } else if ( hit Last ) { first -- ; seed = first ; next = true ; } } return INVALID POSITION ; }
public void retain Progress ( final String title , final String message , final int progress ) { m Title = title ; m Message = message ; m Progress = progress ; }
@ Override public Std Type Resolver Builder type Property ( String type Id Prop Name ) { if ( type Id Prop Name == null || type Id Prop Name . length ( ) == NUM_ ) { type Id Prop Name = id Type . get Default Property Name ( ) ; } type Property = type Id Prop Name ; return this ; }
public void tell Temporal Physics Sentences ( int t ) { if ( t == NUM_ ) { tell ( new Symbol ( LOCATION , NUM_ , NUM_ , NUM_ ) ) ; tell ( new Symbol ( FACING EAST , NUM_ ) ) ; tell ( new Symbol ( HAVE ARROW , NUM_ ) ) ; tell ( new Symbol ( WUMPUS ALIVE , NUM_ ) ) ; } for ( int x = NUM_ ; x <= cave X Dimension ; x ++ ) { for ( int y = NUM_ ; y <= cave Y Dimension ; y ++ ) { tell ( new Complex Sentence ( new Symbol ( LOCATION , t , x , y ) , Connective . IMPLICATION , new Complex Sentence ( new Symbol ( PERCEPT BREEZE , t ) , Connective . BICONDITIONAL , new Symbol ( BREEZE , x , y ) ) ) ) ; tell ( new Complex Sentence ( new Symbol ( LOCATION , t , x , y ) , Connective . IMPLICATION , new Complex Sentence ( new Symbol ( PERCEPT STENCH , t ) , Connective . BICONDITIONAL , new Symbol ( STENCH , x , y ) ) ) ) ; } } for ( int x = NUM_ ; x <= cave X Dimension ; x ++ ) { for ( int y = NUM_ ; y <= cave Y Dimension ; y ++ ) { List < Sentence > loc Disjuncts = new Array List < Sentence > ( ) ; loc Disjuncts . add ( new Complex Sentence ( new Symbol ( LOCATION , t , x , y ) , Connective . AND , new Complex Sentence ( new Complex Sentence ( Connective . NOT , new Symbol ( ACTION FORWARD , t ) ) , Connective . OR , new Symbol ( PERCEPT BUMP , t + NUM_ ) ) ) ) ; if ( x > NUM_ ) { loc Disjuncts . add ( new Complex Sentence ( new Symbol ( LOCATION , t , x - NUM_ , y ) , Connective . AND , new Complex Sentence ( new Symbol ( FACING EAST , t ) , Connective . AND , new Symbol ( ACTION FORWARD , t ) ) ) ) ; } if ( y < cave Y Dimension ) { loc Disjuncts . add ( new Complex Sentence ( new Symbol ( LOCATION , t , x , y + NUM_ ) , Connective . AND , new Complex Sentence ( new Symbol ( FACING SOUTH , t ) , Connective . AND , new Symbol ( ACTION FORWARD , t ) ) ) ) ; } if ( x < cave X Dimension ) { loc Disjuncts . add ( new Complex Sentence ( new Symbol ( LOCATION , t , x + NUM_ , y ) , Connective . AND , new Complex Sentence ( new Symbol ( FACING WEST , t ) , Connective . AND , new Symbol ( ACTION FORWARD , t ) ) ) ) ; } if ( y > NUM_ ) { loc Disjuncts . add ( new Complex Sentence ( new Symbol ( LOCATION , t , x , y - NUM_ ) , Connective . AND , new Complex Sentence ( new Symbol ( FACING NORTH , t ) , Connective . AND , new Symbol ( ACTION FORWARD , t ) ) ) ) ; } tell ( new Complex Sentence ( new Symbol ( LOCATION , t + NUM_ , x , y ) , Connective . BICONDITIONAL , Sentence . new Disjunction ( loc Disjuncts ) ) ) ; tell ( new Complex Sentence ( new Symbol ( OK TO MOVE INTO , t , x , y ) , Connective . BICONDITIONAL , new Complex Sentence ( new Complex Sentence ( Connective . NOT , new Symbol ( PIT , x , y ) ) , Connective . AND , new Complex Sentence ( Connective . NOT , new Complex Sentence ( new Symbol ( WUMPUS , x , y ) , Connective . AND , new Symbol ( WUMPUS ALIVE , t ) ) ) ) ) ) ; } } tell ( new Complex Sentence ( new Symbol ( FACING NORTH , t + NUM_ ) , Connective . BICONDITIONAL , Sentence . new Disjunction ( new Complex Sentence ( new Symbol ( FACING WEST , t ) , Connective . AND , new Symbol ( ACTION TURN RIGHT , t ) ) , new Complex Sentence ( new Symbol ( FACING EAST , t ) , Connective . AND , new Symbol ( ACTION TURN LEFT , t ) ) , new Complex Sentence ( new Symbol ( FACING NORTH , t ) , Connective . AND , new Complex Sentence ( new Complex Sentence ( Connective . NOT , new Symbol ( ACTION TURN LEFT , t ) ) , Connective . AND , new Complex Sentence ( Connective . NOT , new Symbol ( ACTION TURN RIGHT , t ) ) ) ) ) ) ) ; tell ( new Complex Sentence ( new Symbol ( FACING SOUTH , t + NUM_ ) , Connective . BICONDITIONAL , Sentence . new Disjunction ( new Complex Sentence ( new Symbol ( FACING WEST , t ) , Connective . AND , new Symbol ( ACTION TURN LEFT , t ) ) , new Complex Sentence ( new Symbol ( FACING EAST , t ) , Connective . AND , new Symbol ( ACTION TURN RIGHT , t ) ) , new Complex Sentence ( new Symbol ( FACING SOUTH , t ) , Connective . AND , new Complex Sentence ( new Complex Sentence ( Connective . NOT , new Symbol ( ACTION TURN LEFT , t ) ) , Connective . AND , new Complex Sentence ( Connective . NOT , new Symbol ( ACTION TURN RIGHT , t ) ) ) ) ) ) ) ; tell ( new Complex Sentence ( new Symbol ( FACING EAST , t + NUM_ ) , Connective . BICONDITIONAL , Sentence . new Disjunction ( new Complex Sentence ( new Symbol ( FACING NORTH , t ) , Connective . AND , new Symbol ( ACTION TURN RIGHT , t ) ) , new Complex Sentence ( new Symbol ( FACING SOUTH , t ) , Connective . AND , new Symbol ( ACTION TURN LEFT , t ) ) , new Complex Sentence ( new Symbol ( FACING EAST , t ) , Connective . AND , new Complex Sentence ( new Complex Sentence ( Connective . NOT , new Symbol ( ACTION TURN LEFT , t ) ) , Connective . AND , new Complex Sentence ( Connective . NOT , new Symbol ( ACTION TURN RIGHT , t ) ) ) ) ) ) ) ; tell ( new Complex Sentence ( new Symbol ( FACING WEST , t + NUM_ ) , Connective . BICONDITIONAL , Sentence . new Disjunction ( new Complex Sentence ( new Symbol ( FACING NORTH , t ) , Connective . AND , new Symbol ( ACTION TURN LEFT , t ) ) , new Complex Sentence ( new Symbol ( FACING SOUTH , t ) , Connective . AND , new Symbol ( ACTION TURN RIGHT , t ) ) , new Complex Sentence ( new Symbol ( FACING WEST , t ) , Connective . AND , new Complex Sentence ( new Complex Sentence ( Connective . NOT , new Symbol ( ACTION TURN LEFT , t ) ) , Connective . AND , new Complex Sentence ( Connective . NOT , new Symbol ( ACTION TURN RIGHT , t ) ) ) ) ) ) ) ; tell ( new Complex Sentence ( new Symbol ( HAVE ARROW , t + NUM_ ) , Connective . BICONDITIONAL , new Complex Sentence ( new Symbol ( HAVE ARROW , t ) , Connective . AND , new Complex Sentence ( Connective . NOT , new Symbol ( ACTION SHOOT , t ) ) ) ) ) ; tell ( new Complex Sentence ( new Symbol ( WUMPUS ALIVE , t + NUM_ ) , Connective . BICONDITIONAL , new Complex Sentence ( new Symbol ( WUMPUS ALIVE , t ) , Connective . AND , new Complex Sentence ( Connective . NOT , new Symbol ( PERCEPT SCREAM , t + NUM_ ) ) ) ) ) ; }
public void on New Intent With Gesture ( Intent intent ) { m Intent Token = new byte [ NUM_ ] ; m Secure Random . next Bytes ( m Intent Token ) ; intent . put Extra ( EXTRA USER GESTURE TOKEN , m Intent Token ) ; m Uri = Intent Handler . get Url From Intent ( intent ) ; }
static void copy To Foreign Target ( Path source , Path target , Copy Option ... options ) throws IO Exception { Copy Options opts = Copy Options . parse ( options ) ; Link Option [ ] link Options = ( opts . follow Links ) ? new Link Option [ NUM_ ] : new Link Option [ ] { Link Option . NOFOLLOW LINKS } ; Basic File Attributes attrs = Files . read Attributes ( source , Basic File Attributes . class , link Options ) ; if ( attrs . is Symbolic Link ( ) ) throw new IO Exception ( STR_ ) ; if ( opts . replace Existing ) { Files . delete If Exists ( target ) ; } else if ( Files . exists ( target ) ) throw new File Already Exists Exception ( target . to String ( ) ) ; if ( attrs . is Directory ( ) ) { Files . create Directory ( target ) ; } else { try ( Input Stream in = Files . new Input Stream ( source ) ) { Files . copy ( in , target ) ; } } if ( opts . copy Attributes ) { Basic File Attribute View view = Files . get File Attribute View ( target , Basic File Attribute View . class ) ; try { view . set Times ( attrs . last Modified Time ( ) , attrs . last Access Time ( ) , attrs . creation Time ( ) ) ; } catch ( Throwable x ) { try { Files . delete ( target ) ; } catch ( Throwable suppressed ) { x . add Suppressed ( suppressed ) ; } throw x ; } } }
private void enqueue Send ( ) { final int current Outstanding = outstanding . get ( ) ; if ( current Outstanding < concurrency ) { send Batch ( ) ; return ; } pending = true ; pending Topics . offer ( this ) ; listener . topic Pending ( Publisher . this , topic , current Outstanding , concurrency ) ; send Pending ( ) ; }
public double signed Distance To Line Segment ( Lat Long A , Lat Long B ) { double Ax = ( A . lng - lng ) * Math . cos ( NUM_ * radians * ( A . lat + lat ) ) ; double Ay = ( A . lat - lat ) ; double Bx = ( B . lng - lng ) * Math . cos ( NUM_ * radians * ( B . lat + lat ) ) ; double By = ( B . lat - lat ) ; double Ix = ( ( By - Ay ) * ( Ax * By - Ay * Bx ) ) / ( ( Ax - Bx ) * ( Ax - Bx ) + ( Ay - By ) * ( Ay - By ) ) ; return ( ( Bx - Ax ) * Ay - Ax * ( By - Ay ) ) / Math . sqrt ( ( Bx - Ax ) * ( Bx - Ax ) + ( By - Ay ) * ( By - Ay ) ) * Earth Radius * radians ; }
@ Non Null private static List < Rave Error > create New List ( @ Non Null Rave Error error ) { List < Rave Error > errors = new Linked List < > ( ) ; errors . add ( error ) ; return errors ; }
private void interrupt Idle Workers ( boolean only One ) { final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { for ( Worker w : workers ) { Thread t = w . thread ; if ( ! t . is Interrupted ( ) && w . try Lock ( ) ) { try { t . interrupt ( ) ; } catch ( Security Exception ignore ) { } finally { w . unlock ( ) ; } } if ( only One ) break ; } } finally { main Lock . unlock ( ) ; } }
public void queue Shield Frame ( Shield Frame frame ) { if ( frame == null ) throw new Null Pointer Exception ( STR_ ) ; if ( ! is Connected ( ) ) { on Error ( One Sheeld Error . DEVICE NOT CONNECTED ) ; return ; } else if ( is Updating Firmware ( ) ) { on Error ( One Sheeld Error . FIRMWARE UPDATE IN PROGRESS ) ; return ; } queued Frames . add ( frame ) ; callback Entered ( ) ; }
static private String INT Min ( ) { int temp Value = Integer . MIN VALUE ; return String . value Of ( temp Value ) ; }
private static void sleep Impl ( long millis , Closure closure ) { long start = System . current Time Millis ( ) ; long rest = millis ; long current ; while ( rest > NUM_ ) { try { Thread . sleep ( rest ) ; rest = NUM_ ; } catch ( Interrupted Exception e ) { if ( closure != null ) { if ( Default Type Transformation . cast To Boolean ( closure . call ( e ) ) ) { return ; } } current = System . current Time Millis ( ) ; rest = millis + start - current ; } } }
static protected void assert Field ( final String header , final String [ ] fields , final int field , final String expected ) { if ( header == null ) throw new Illegal Argument Exception ( ) ; if ( fields == null ) throw new Illegal Argument Exception ( ) ; if ( expected == null ) throw new Illegal Argument Exception ( ) ; if ( field < NUM_ ) throw new Illegal Argument Exception ( ) ; if ( field >= fields . length ) throw new Assertion Failed Error ( STR_ + fields . length + STR_ + field + STR_ + header ) ; if ( ! expected . equals ( fields [ field ] ) ) { throw new Assertion Failed Error ( STR_ + field + STR_ + expected + STR_ + fields [ field ] + STR_ + header ) ; } }
Hashtable remove User Data Table ( Node n ) { if ( user Data == null ) { return null ; } return ( Hashtable ) user Data . get ( n ) ; }
public Iterator < Record ID > scan ( ) { List < B Entry > valid Entries = get All Valid Entries ( ) ; List < Record ID > rids = new Array List < Record ID > ( ) ; for ( B Entry le : valid Entries ) { rids . add ( le . get Record ID ( ) ) ; } return rids . iterator ( ) ; }
public void action Performed ( Action Event e ) { Swing Utilities . invoke Later ( m tick PB ) ; }
synchronized void send Packed Midi Message ( int packed Msg , long time Stamp ) { if ( is Open ( ) && id != NUM_ ) { n Send Short Message ( id , packed Msg , time Stamp ) ; } }
private void calc Coordinates ( ) { if ( ( CTM [ NUM_ ] [ NUM_ ] == NUM_ ) & ( ( CTM [ NUM_ ] [ NUM_ ] == NUM_ ) ) ) { i x = ( int ) CTM [ NUM_ ] [ NUM_ ] ; i y = ( int ) CTM [ NUM_ ] [ NUM_ ] ; i w = ( int ) CTM [ NUM_ ] [ NUM_ ] ; i h = ( int ) CTM [ NUM_ ] [ NUM_ ] ; if ( i w < NUM_ ) { i w = - i w ; } if ( i h < NUM_ ) { i h = - i h ; } } else { i w = ( int ) ( Math . sqrt ( ( CTM [ NUM_ ] [ NUM_ ] * CTM [ NUM_ ] [ NUM_ ] ) + ( CTM [ NUM_ ] [ NUM_ ] * CTM [ NUM_ ] [ NUM_ ] ) ) ) ; i h = ( int ) ( Math . sqrt ( ( CTM [ NUM_ ] [ NUM_ ] * CTM [ NUM_ ] [ NUM_ ] ) + ( CTM [ NUM_ ] [ NUM_ ] * CTM [ NUM_ ] [ NUM_ ] ) ) ) ; if ( ( CTM [ NUM_ ] [ NUM_ ] > NUM_ ) & ( CTM [ NUM_ ] [ NUM_ ] < NUM_ ) ) { i x = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; i y = ( int ) ( CTM [ NUM_ ] [ NUM_ ] + CTM [ NUM_ ] [ NUM_ ] ) ; } else if ( ( CTM [ NUM_ ] [ NUM_ ] < NUM_ ) & ( CTM [ NUM_ ] [ NUM_ ] > NUM_ ) ) { i x = ( int ) ( CTM [ NUM_ ] [ NUM_ ] + CTM [ NUM_ ] [ NUM_ ] ) ; i y = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; } else if ( ( CTM [ NUM_ ] [ NUM_ ] > NUM_ ) & ( CTM [ NUM_ ] [ NUM_ ] > NUM_ ) ) { i x = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; i y = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; } else { i x = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; i y = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; } } if ( CTM [ NUM_ ] [ NUM_ ] < NUM_ ) { i y -= i h ; } if ( CTM [ NUM_ ] [ NUM_ ] < NUM_ ) { i x -= i w ; } }
public final void update Data Store ( I Source S ) throws Ade Exception { logger . info ( String . format ( STR_ , S . get Source Id ( ) ) ) ; try { final Update Managed System Atomic Transaction atomic Trans = new Update Managed System Atomic Transaction ( S ) ; atomic Trans . execute ( ) ; } catch ( Ade Exception e ) { throw e ; } catch ( Throwable t ) { final String msg = String . format ( STR_ , S . get Source Id ( ) , t . get Message ( ) ) ; logger . info ( msg ) ; throw new Ade Internal Exception ( msg , t ) ; } logger . info ( STR_ ) ; }
@ Override public Long call ( ) throws Exception { final boolean TRACE = log . is Trace Enabled ( ) ; if ( push Down Apply ( ) ) { program . apply ( gas State , u , null ) ; } if ( ! program . is Changed ( gas State , u ) ) { return NUM_ ; } long nedges = NUM_ ; final IGAS Scheduler sch = scheduler ( ) ; final Iterator < Statement > eitr = graph Accessor . get Edges ( GAS Context . this , u , get Edges Enum ( ) ) ; try { while ( eitr . has Next ( ) ) { final Statement e = eitr . next ( ) ; nedges ++ ; if ( TRACE ) log . trace ( STR_ + gas State . to String ( e ) ) ; program . scatter ( gas State , sch , u , e ) ; } } finally { } return nedges ; }
@ Safe Varargs public static < X extends Throwable > Init < X > catch Exceptions ( final Class < ? extends X > ... classes ) { return new My Init < X > ( ( Class [ ] ) classes ) ; }
public static String generate CQL Statement For Where Clauses ( String CQL , Index index ) { String i Table To Update = Utils . calculate I Table Name ( index ) ; return String . format ( CQL , i Table To Update , get Where Clause Helper ( index ) ) ; }
protected void graph Tree ( String Buffer text ) throws Exception { text . append ( STR_ + m cluster Num + STR_ + ( ( m children == null ) ? STR_ : STR_ ) + m cluster Num + STR_ + STR_ + m cluster Instances . num Instances ( ) + STR_ + ( ( m children == null ) ? STR_ : STR_ ) + ( m save Instances ? STR_ + dump Data ( ) + STR_ : STR_ ) + STR_ ) ; if ( m children != null ) { for ( int i = NUM_ ; i < m children . size ( ) ; i ++ ) { C Node temp = m children . get ( i ) ; text . append ( STR_ + m cluster Num + STR_ + STR_ + temp . m cluster Num + STR_ ) ; } for ( int i = NUM_ ; i < m children . size ( ) ; i ++ ) { C Node temp = m children . get ( i ) ; temp . graph Tree ( text ) ; } } }
private void insert Heap Variables ( IR ir , boolean backwards ) { register Heap Variables ( ir ) ; register Calls ( ir ) ; if ( backwards ) { register Exits ( ir ) ; } insert Heap Phi Functions ( ir ) ; }
@ Override public void clear ( ) { symbol To Index Map . clear ( ) ; index To Symbol Map . clear ( ) ; }
public static double incomplete Beta Fraction 2 ( double a , double b , double x ) { double xk , pk , pkm 1 , pkm 2 , qk , qkm 1 , qkm 2 ; double k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 ; double r , t , ans , z , thresh ; int n ; k 1 = a ; k 2 = b - NUM_ ; k 3 = a ; k 4 = a + NUM_ ; k 5 = NUM_ ; k 6 = a + b ; k 7 = a + NUM_ ; ; k 8 = a + NUM_ ; pkm 2 = NUM_ ; qkm 2 = NUM_ ; pkm 1 = NUM_ ; qkm 1 = NUM_ ; z = x / ( NUM_ - x ) ; ans = NUM_ ; r = NUM_ ; n = NUM_ ; thresh = NUM_ * MACHEP ; do { xk = - ( z * k 1 * k 2 ) / ( k 3 * k 4 ) ; pk = pkm 1 + pkm 2 * xk ; qk = qkm 1 + qkm 2 * xk ; pkm 2 = pkm 1 ; pkm 1 = pk ; qkm 2 = qkm 1 ; qkm 1 = qk ; xk = ( z * k 5 * k 6 ) / ( k 7 * k 8 ) ; pk = pkm 1 + pkm 2 * xk ; qk = qkm 1 + qkm 2 * xk ; pkm 2 = pkm 1 ; pkm 1 = pk ; qkm 2 = qkm 1 ; qkm 1 = qk ; if ( qk != NUM_ ) r = pk / qk ; if ( r != NUM_ ) { t = Math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = NUM_ ; if ( t < thresh ) return ans ; k 1 += NUM_ ; k 2 -= NUM_ ; k 3 += NUM_ ; k 4 += NUM_ ; k 5 += NUM_ ; k 6 += NUM_ ; k 7 += NUM_ ; k 8 += NUM_ ; if ( ( Math . abs ( qk ) + Math . abs ( pk ) ) > big ) { pkm 2 *= biginv ; pkm 1 *= biginv ; qkm 2 *= biginv ; qkm 1 *= biginv ; } if ( ( Math . abs ( qk ) < biginv ) || ( Math . abs ( pk ) < biginv ) ) { pkm 2 *= big ; pkm 1 *= big ; qkm 2 *= big ; qkm 1 *= big ; } } while ( ++ n < NUM_ ) ; return ans ; }
protected int ask Port ( Localizable Message prompt , int default Value , Localized Logger logger ) { while ( true ) { try { int port = read Port ( prompt , default Value ) ; if ( port != - NUM_ ) { return port ; } } catch ( Client Exception ce ) { logger . warn ( Localizable Message . raw ( STR_ + ce , ce ) ) ; } } }
public String build Local File Path ( int x , int y , int z , String file Ext ) { if ( local Tile Path Builder == null ) { local Tile Path Builder = new Tile Path Builder ( local Cache Dir ) ; } return local Tile Path Builder . build Tile Path ( x , y , z , file Ext ) ; }
public static JNI Writer instance ( Context context ) { JNI Writer instance = context . get ( jni Writer Key ) ; if ( instance == null ) instance = new JNI Writer ( context ) ; return instance ; }
@ Rpc Method public void copy Image ( String image Id , String source , String destination , Async Method Callback < Host . Async Client . copy image call > handler ) throws Rpc Exception { ensure Client ( ) ; Copy Image Request copy Image Request = new Copy Image Request ( ) ; copy Image Request . set Source ( Util . construct Image ( source , image Id ) ) ; copy Image Request . set Destination ( Util . construct Image ( destination , image Id ) ) ; logger . info ( STR_ , get Host Ip ( ) , copy Image Request ) ; try { client Proxy . copy image ( copy Image Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public static String create ( mx I Cell cell ) { String result = STR_ ; if ( cell != null ) { mx I Cell parent = cell . get Parent ( ) ; while ( parent != null ) { int index = parent . get Index ( cell ) ; result = index + mx Cell Path . PATH SEPARATOR + result ; cell = parent ; parent = cell . get Parent ( ) ; } } return ( result . length ( ) > NUM_ ) ? result . substring ( NUM_ , result . length ( ) - NUM_ ) : STR_ ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; if ( policy == null ) { throw new Invalid Object Exception ( STR_ ) ; } if ( classpath == null ) { throw new Invalid Object Exception ( STR_ ) ; } if ( log == null ) { throw new Invalid Object Exception ( STR_ ) ; } if ( server Options == null ) { throw new Invalid Object Exception ( STR_ ) ; } if ( server Properties == null ) { throw new Invalid Object Exception ( STR_ ) ; } if ( host == null ) { throw new Invalid Object Exception ( STR_ ) ; } if ( port <= NUM_ ) { throw new Invalid Object Exception ( STR_ + port ) ; } }
public Selection Builder reset ( ) { m Table = null ; m Group By = null ; m Having = null ; m Selection . set Length ( NUM_ ) ; m Selection Args . clear ( ) ; return this ; }
public Result Formatter ( Object result ) { this . result = result ; print Header = true ; }
private Remote Operation Result refresh Shares For Folder ( Own Cloud Client client ) { Remote Operation Result result = null ; Get Remote Shares For File Operation operation = new Get Remote Shares For File Operation ( m Local Folder . get Remote Path ( ) , true , true ) ; result = operation . execute ( client ) ; if ( result . is Success ( ) ) { Array List < OC Share > shares = new Array List < OC Share > ( ) ; for ( Object obj : result . get Data ( ) ) { shares . add ( ( OC Share ) obj ) ; } m Storage Manager . save Shares In Folder ( shares , m Local Folder ) ; } return result ; }
public I Resource [ ] prompt For Multiple ( ) throws Interrupted Exception { List target Resources = new Array List ( ) ; for ( int i = NUM_ ; i < resources . length ; i ++ ) { I Resource resource = resources [ i ] ; if ( condition . needs Prompt ( resource ) && confirm Overwrite ) { if ( confirm Overwrite ( condition . prompt Message ( resource ) ) ) { target Resources . add ( resource ) ; } } else { target Resources . add ( resource ) ; } } return ( I Resource [ ] ) target Resources . to Array ( new I Resource [ target Resources . size ( ) ] ) ; }
protected void add Field Config ( Field Config Base field Config ) { field Config List . add ( field Config ) ; }
public static String tag Swap Report ( Map < String , String > report Contents , String key ) { return tag Swap ( report Contents , BUNDLE . get String ( key ) ) ; }
private Completable Future < String > send ( final Message message ) { final Completable Future < String > future = new Completable Future < > ( ) ; int current Size ; int new Size ; do { current Size = size . get ( ) ; new Size = current Size + NUM_ ; if ( new Size > queue Size ) { future . complete Exceptionally ( new Queue Full Exception ( ) ) ; return future ; } } while ( ! size . compare And Set ( current Size , new Size ) ) ; queue . add ( new Queued Message ( message , future ) ) ; schedule Send ( new Size ) ; return future ; }
private void assert Services Still Joined ( final Quorum < HA Glue , Quorum Service < HA Glue > > quorum ) throws Quorum Exception { final UUID [ ] tmp = quorum . get Joined ( ) ; for ( UUID service Id : joined Service Ids ) { boolean found = false ; for ( UUID t : tmp ) { if ( service Id . equals ( t ) ) { found = true ; break ; } } if ( ! found ) { throw new Quorum Exception ( STR_ + service Id ) ; } } }
private Point 2 D transform ( Point 2 D graph Point ) { if ( graph Point == null ) return null ; Point 2 D view Center = get View Center ( ) ; double view Radius = get View Radius ( ) ; double ratio = get Ratio ( ) ; Point 2 D view Point = graph Point ; double dx = view Point . get X ( ) - view Center . get X ( ) ; double dy = view Point . get Y ( ) - view Center . get Y ( ) ; dx *= ratio ; Point 2 D point From Center = new Point 2 D . Double ( dx , dy ) ; Polar Point polar = Polar Point . cartesian To Polar ( point From Center ) ; double theta = polar . get Theta ( ) ; double radius = polar . get Radius ( ) ; if ( radius > view Radius ) return view Point ; double mag = Math . tan ( Math . PI / NUM_ * magnification ) ; radius *= mag ; radius = Math . min ( radius , view Radius ) ; radius /= view Radius ; radius *= Math . PI / NUM_ ; radius = Math . abs ( Math . atan ( radius ) ) ; radius *= view Radius ; Point 2 D projected Point = Polar Point . polar To Cartesian ( theta , radius ) ; projected Point . set Location ( projected Point . get X ( ) / ratio , projected Point . get Y ( ) ) ; Point 2 D translated Back = new Point 2 D . Double ( projected Point . get X ( ) + view Center . get X ( ) , projected Point . get Y ( ) + view Center . get Y ( ) ) ; return translated Back ; }
public static boolean create Order ( M Acct Schema as , int AD Org ID , int M Product ID , int M Attribute Set Instance ID , int C Order Line ID , int M Cost Element ID , Big Decimal Amt , Big Decimal Qty , String Description , String trx Name ) { String sql = STR_ + STR_ + STR_ + C Order Line ID + STR_ + as . get C Acct Schema ID ( ) + STR_ + M Attribute Set Instance ID ; int no = DB . execute Update ( sql , trx Name ) ; if ( no != NUM_ ) s log . config ( STR_ + no ) ; M Cost Detail cd = get ( as . get Ctx ( ) , STR_ , C Order Line ID , M Attribute Set Instance ID , as . get C Acct Schema ID ( ) , trx Name ) ; if ( cd == null ) { cd = new M Cost Detail ( as , AD Org ID , M Product ID , M Attribute Set Instance ID , M Cost Element ID , Amt , Qty , Description , trx Name ) ; cd . set C Order Line ID ( C Order Line ID ) ; } else { cd . set Delta Amt ( Amt . subtract ( cd . get Amt ( ) ) ) ; cd . set Delta Qty ( Qty . subtract ( cd . get Qty ( ) ) ) ; if ( cd . is Delta ( ) ) { cd . set Processed ( false ) ; cd . set Amt ( Amt ) ; cd . set Qty ( Qty ) ; } else return true ; } boolean ok = cd . save ( ) ; if ( ok && ! cd . is Processed ( ) ) { M Client client = M Client . get ( as . get Ctx ( ) , as . get AD Client ID ( ) ) ; if ( client . is Cost Immediate ( ) ) cd . process ( ) ; } s log . config ( STR_ + ok + STR_ + cd ) ; return ok ; }
public static boolean valid System Name Format ( String system Name , char type ) { Matcher matcher = get All Pattern ( ) . matcher ( system Name ) ; if ( ! matcher . matches ( ) ) { return false ; } if ( matcher . group ( NUM_ ) . char At ( NUM_ ) != type ) { log . error ( STR_ + system Name + STR_ + type ) ; return false ; } Pattern p ; if ( type == STR_ ) { p = get Light Pattern ( ) ; } else if ( type == STR_ ) { p = get Turnout Pattern ( ) ; } else if ( type == STR_ ) { p = get Head Pattern ( ) ; } else if ( type == STR_ ) { p = get Sensor Pattern ( ) ; } else { log . error ( STR_ + system Name + STR_ ) ; return false ; } Matcher m 2 = p . matcher ( system Name ) ; if ( ! m 2 . matches ( ) ) { log . error ( STR_ + system Name + STR_ + type ) ; return ( false ) ; } int node = - NUM_ ; int bit = - NUM_ ; if ( matcher . group ( NUM_ ) != null ) { int num = Integer . value Of ( matcher . group ( NUM_ ) ) . int Value ( ) ; if ( num > NUM_ ) { node = num / NUM_ ; bit = num % NUM_ ; } else { log . error ( STR_ + system Name ) ; return false ; } } else { node = Integer . value Of ( matcher . group ( NUM_ ) ) . int Value ( ) ; bit = Integer . value Of ( matcher . group ( NUM_ ) ) . int Value ( ) ; } if ( ( node < NUM_ ) || ( node > NUM_ ) ) { log . error ( STR_ + node + STR_ + system Name ) ; return false ; } if ( ( type == STR_ ) || ( type == STR_ ) || ( type == STR_ ) ) { if ( ! ( ( bit >= NUM_ && bit <= NUM_ ) || ( bit >= NUM_ && bit <= NUM_ ) || ( bit >= NUM_ && bit <= NUM_ ) || ( bit >= NUM_ && bit <= NUM_ ) ) ) { log . error ( STR_ + bit + STR_ + system Name ) ; return false ; } } else { assert type == STR_ ; String subtype = matcher . group ( NUM_ ) ; if ( subtype == null ) { if ( ( bit < NUM_ ) || ( bit > NUM_ ) ) { log . error ( STR_ + bit + STR_ + system Name ) ; return false ; } else { return true ; } } subtype = subtype . to Upper Case ( ) ; if ( subtype . equals ( STR_ ) ) { if ( ( bit < NUM_ ) || ( bit > NUM_ ) ) { log . error ( STR_ + bit + STR_ + system Name ) ; return false ; } } else if ( subtype . equals ( STR_ ) ) { if ( ( bit < NUM_ ) || ( bit > NUM_ ) ) { log . error ( STR_ + bit + STR_ + system Name ) ; return false ; } } else if ( subtype . equals ( STR_ ) ) { if ( ( bit < NUM_ ) || ( bit > NUM_ ) ) { log . error ( STR_ + bit + STR_ + system Name ) ; return false ; } } else if ( subtype . equals ( STR_ ) ) { if ( ( bit < NUM_ ) || ( bit > NUM_ ) ) { log . error ( STR_ + bit + STR_ + system Name ) ; return false ; } } } return true ; }
private void release Plock ( int ps ) { plock = ps ; synchronized ( this ) { notify All ( ) ; } }
public void delete Observers ( ) { observers . clear ( ) ; }
public Rectangle 2 D scale ( Rectangle 2 D rect ) { Insets insets = get Insets ( ) ; double x = rect . get X ( ) * get Scale X ( ) + insets . left ; double y = rect . get Y ( ) * get Scale Y ( ) + insets . top ; double w = rect . get Width ( ) * get Scale X ( ) ; double h = rect . get Height ( ) * get Scale Y ( ) ; return new Rectangle 2 D . Double ( x , y , w , h ) ; }
private void ensure Capacity ( int num Mappings ) { int new Capacity = Collections . round Up To Power Of Two ( capacity For Init Size ( num Mappings ) ) ; Hash Map Entry < K , V > [ ] old Table = table ; int old Capacity = old Table . length ; if ( new Capacity <= old Capacity ) { return ; } if ( new Capacity == old Capacity * NUM_ ) { double Capacity ( ) ; return ; } Hash Map Entry < K , V > [ ] new Table = make Table ( new Capacity ) ; if ( size != NUM_ ) { int new Mask = new Capacity - NUM_ ; for ( int i = NUM_ ; i < old Capacity ; i ++ ) { for ( Hash Map Entry < K , V > e = old Table [ i ] ; e != null ; ) { Hash Map Entry < K , V > old Next = e . next ; int new Index = e . hash & new Mask ; Hash Map Entry < K , V > new Next = new Table [ new Index ] ; new Table [ new Index ] = e ; e . next = new Next ; e = old Next ; } } } }
@ Override public void write ( int one Byte ) throws IO Exception { Streams . write Single Byte ( this , one Byte ) ; }
public void fill ( Shape s , Color color ) { device Fill ( s . get Path Iterator ( new Affine Transform ( ) ) , color ) ; }
private void generate Locator ( Distribution Locator Config config ) throws SAX Exception { Attributes Impl atts = new Attributes Impl ( ) ; atts . add Attribute ( STR_ , STR_ , PORT , STR_ , String . value Of ( config . get Port ( ) ) ) ; handler . start Element ( STR_ , LOCATOR , LOCATOR , atts ) ; generate Entity Config ( config ) ; handler . end Element ( STR_ , LOCATOR , LOCATOR ) ; }
public void print Comment ( Mark start , Mark stop , char [ ] chars ) { if ( start != null && stop != null ) { println ( STR_ + start ) ; println ( STR_ + stop ) ; } if ( chars != null ) for ( int i = NUM_ ; i < chars . length ; ) { printin ( ) ; print ( STR_ ) ; while ( chars [ i ] != STR_ && i < chars . length ) writer . print ( chars [ i ++ ] ) ; } }
@ Suppress Warnings ( { STR_ , STR_ } ) public void emit Tuple ( int i ) { Hash Map < String , String > stuple ; Hash Map < String , Array List < Key Val Pair > > atuple ; String key = Integer . to String ( i ) ; if ( keys == null ) { if ( string data . is Connected ( ) ) { stuple = new Hash Map < String , String > ( NUM_ ) ; stuple . put ( key , null ) ; string data . emit ( stuple ) ; } if ( keyvalpair list . is Connected ( ) ) { atuple = new Hash Map < String , Array List < Key Val Pair > > ( NUM_ ) ; atuple . put ( key , null ) ; keyvalpair list . emit ( atuple ) ; } return ; } Array List < Key Val Pair > alist = null ; Array List < Integer > vlist = null ; String str = new String ( ) ; String vstr = new String ( ) ; boolean iskv = keyvalpair list . is Connected ( ) ; boolean isvl = val list . is Connected ( ) ; boolean issd = string data . is Connected ( ) ; boolean isvd = val data . is Connected ( ) ; int j = NUM_ ; for ( String s : keys ) { if ( iskv ) { if ( alist == null ) { alist = new Array List < Key Val Pair > ( keys . size ( ) ) ; } alist . add ( new Key Val Pair < String , Integer > ( s , new Integer ( keys min . get ( j ) + random . next Int ( keys range . get ( j ) ) ) ) ) ; } if ( isvl ) { if ( vlist == null ) { vlist = new Array List < Integer > ( keys . size ( ) ) ; } vlist . add ( new Integer ( keys min . get ( j ) + random . next Int ( keys range . get ( j ) ) ) ) ; } if ( issd ) { if ( ! str . is Empty ( ) ) { str += STR_ ; } str += s + STR_ + Integer . to String ( keys min . get ( j ) + random . next Int ( keys range . get ( j ) ) ) ; } if ( isvd ) { if ( ! vstr . is Empty ( ) ) { vstr += STR_ ; } vstr += Integer . to String ( keys min . get ( j ) + random . next Int ( keys range . get ( j ) ) ) ; } j ++ ; } if ( iskv ) { atuple = new Hash Map < String , Array List < Key Val Pair > > ( NUM_ ) ; atuple . put ( key , alist ) ; keyvalpair list . emit ( atuple ) ; } if ( isvl ) { Hash Map < String , Array List < Integer > > ituple = new Hash Map < String , Array List < Integer > > ( NUM_ ) ; ituple . put ( key , vlist ) ; val list . emit ( ituple ) ; } if ( issd ) { stuple = new Hash Map < String , String > ( NUM_ ) ; stuple . put ( key , str ) ; string data . emit ( stuple ) ; } if ( isvd ) { Hash Map vtuple = new Hash Map < String , String > ( NUM_ ) ; vtuple . put ( key , vstr ) ; val data . emit ( vtuple ) ; } }
protected Field find Property Set Field Name ( String property Value ) throws Exception { for ( Class property Set Classe : PROPERTY SET CLASSES ) { Field result = find Property Set Field ( property Value , property Set Classe ) ; if ( result != null ) { return result ; } } return null ; }
private static URL [ ] path To UR Ls ( String path ) throws Malformed URL Exception { String [ ] names = path . split ( File . path Separator ) ; URL [ ] urls = new URL [ names . length ] ; int count = NUM_ ; for ( String f : names ) { URL url = file To URL ( new File ( f ) ) ; urls [ count ++ ] = url ; } return urls ; }
public void do Double Click Action ( ) { do Double Click Action ( null ) ; }
public boolean has Values By Local Path Recursive ( String local Path ) { local Path = Local Path . canonicalize ( local Path ) ; synchronized ( lock ) { final Set < Pending Change > changes = changes By Parent Local Path . get ( local Path ) ; return changes != null && changes . size ( ) > NUM_ ; } }
public long wait Available ( int requested , int wait Millis ) throws IO Exception , Interrupted Exception { if ( available >= requested ) return available ; long timeout Millis = System . current Time Millis ( ) + wait Millis ; long next Report Millis = System . current Time Millis ( ) + NUM_ ; while ( available ( ) < requested && System . current Time Millis ( ) < timeout Millis ) { if ( Thread . interrupted ( ) ) throw new Interrupted Exception ( ) ; Thread . sleep ( NUM_ ) ; if ( System . current Time Millis ( ) > next Report Millis ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ ) ; next Report Millis = System . current Time Millis ( ) + NUM_ ; } } return available ; }
static private String calc Threshold ( double score Threshold , double lambda ) { final double log Prob Threshold = Math . log ( NUM_ - score Threshold / NUM_ ) ; int max Num = NUM_ ; if ( calc Log Prob ( max Num , false , lambda ) > log Prob Threshold ) { return STR_ ; } int min Num = NUM_ ; while ( min Num < max Num ) { final int mid Num = ( max Num + min Num ) / NUM_ ; final boolean pass Threshold = calc Log Prob ( mid Num , false , lambda ) <= log Prob Threshold ; if ( pass Threshold ) { max Num = mid Num ; } else { if ( mid Num == min Num ) { break ; } min Num = mid Num ; } } return Integer . to String ( max Num ) ; }
@ Deprecated public static void debug ( Object msg ) { X . error ( debug Prefix ( ) + msg ) ; }
private void add Link Movement Method ( ) { Movement Method m = text View . get Movement Method ( ) ; if ( ( m == null ) || ! ( m instanceof Touchable Movement Method ) ) { if ( text View . get Links Clickable ( ) ) { text View . set Movement Method ( Touchable Movement Method . get Instance ( ) ) ; } } }
public boolean equals ( Object o ) { if ( ! ( o instanceof Http Path ) ) return false ; Http Path test = ( Http Path ) o ; if ( ! host . equals ( test . host ) ) return false ; else if ( port != test . port ) return false ; else if ( query != null && ! query . equals ( test . query ) ) return false ; else if ( query == null && test . query != null ) return false ; else return true ; }
public Hash Set Node Event Listener exclude ( Node Event e ) { filter . remove ( e ) ; return this ; }
public void audit Config ( Operation Type Enum audit Type , String operational Status , String description , Object ... descparams ) { audit Mgr . record Audit Log ( null , null , EVENT SERVICE TYPE , audit Type , System . current Time Millis ( ) , operational Status , description , descparams ) ; }
@ Override public double [ ] distribution For Instance ( Instance instance ) throws Exception { Decision Table Hash Key thekey ; double [ ] temp Dist ; double [ ] norm Dist ; m dis Transform . input ( instance ) ; m dis Transform . batch Finished ( ) ; instance = m dis Transform . output ( ) ; m del Transform . input ( instance ) ; m del Transform . batch Finished ( ) ; instance = m del Transform . output ( ) ; thekey = new Decision Table Hash Key ( instance , instance . num Attributes ( ) , false ) ; if ( ( temp Dist = m entries . get ( thekey ) ) == null ) { if ( m use I Bk ) { temp Dist = m ibk . distribution For Instance ( instance ) ; } else { if ( ! m class Is Nominal ) { temp Dist = new double [ NUM_ ] ; temp Dist [ NUM_ ] = m majority ; } else { temp Dist = m class Priors . clone ( ) ; } } } else { if ( ! m class Is Nominal ) { norm Dist = new double [ NUM_ ] ; norm Dist [ NUM_ ] = ( temp Dist [ NUM_ ] / temp Dist [ NUM_ ] ) ; temp Dist = norm Dist ; } else { norm Dist = new double [ temp Dist . length ] ; System . arraycopy ( temp Dist , NUM_ , norm Dist , NUM_ , temp Dist . length ) ; Utils . normalize ( norm Dist ) ; temp Dist = norm Dist ; } } return temp Dist ; }
public static int levenshtein Distance ( String o 1 , String o 2 , int prefix , int postfix ) { final int l 1 = o 1 . length ( ) , l 2 = o 2 . length ( ) ; int [ ] buf = new int [ ( l 2 + NUM_ - ( prefix + postfix ) ) << NUM_ ] ; for ( int j = NUM_ ; j < buf . length ; j += NUM_ ) { buf [ j ] = j > > NUM_ ; } int inter = NUM_ ; for ( int i = prefix , e 1 = l 1 - postfix ; i < e 1 ; i ++ , inter ^= NUM_ ) { final char chr = o 1 . char At ( i ) ; buf [ inter ] = i + NUM_ - prefix ; for ( int c = NUM_ + inter , p = NUM_ - inter , j = prefix ; c < buf . length ; c += NUM_ , p += NUM_ ) { buf [ c ] = min ( buf [ p ] + NUM_ , buf [ c - NUM_ ] + NUM_ , buf [ p - NUM_ ] + ( ( chr == o 2 . char At ( j ++ ) ) ? NUM_ : NUM_ ) ) ; } } return buf [ buf . length - NUM_ + ( inter ^ NUM_ ) ] ; }
public static List < Audit > find By Entity ( Entity Manager em , JPA Entity entity , Big Integer limit ) { require Argument ( em != null , STR_ ) ; require Argument ( entity != null , STR_ ) ; Typed Query < Audit > query = em . create Named Query ( STR_ , Audit . class ) ; if ( limit != null ) { query . set Max Results ( limit . int Value ( ) ) ; } try { query . set Parameter ( STR_ , entity ) ; return query . get Result List ( ) ; } catch ( No Result Exception ex ) { return new Array List < Audit > ( NUM_ ) ; } }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj instanceof Elliptic Curve ) { Elliptic Curve curve = ( Elliptic Curve ) obj ; if ( ( field . equals ( curve . field ) ) && ( a . equals ( curve . a ) ) && ( b . equals ( curve . b ) ) ) { return true ; } } return false ; }
public Art Result fanout ( Brd Abit Pin p pin , interactive . Itera Settings p settings , int p ripup costs , Thread Stoppable p stoppable ) { if ( p pin . first layer ( ) != p pin . last layer ( ) || p pin . net count ( ) != NUM_ ) { return Art Result . ALREADY CONNECTED ; } int pin net no = p pin . get net no ( NUM_ ) ; int pin layer = p pin . first layer ( ) ; Set < Brd Item > pin connected set = p pin . get connected set ( pin net no ) ; for ( Brd Item curr item : pin connected set ) { if ( curr item . first layer ( ) != pin layer || curr item . last layer ( ) != pin layer ) { return Art Result . ALREADY CONNECTED ; } } Set < Brd Item > unconnected set = p pin . get unconnected set ( pin net no ) ; if ( unconnected set . is Empty ( ) ) { return Art Result . ALREADY CONNECTED ; } Art Control ctrl settings = new Art Control ( this , pin net no , p settings ) ; ctrl settings . is fanout = true ; ctrl settings . stop remove fanout vias = false ; if ( p ripup costs >= NUM_ ) { ctrl settings . ripup allowed = true ; ctrl settings . ripup costs = p ripup costs ; } Sorted Set < Brd Item > ripped item list = new Tree Set < Brd Item > ( ) ; Art Engine a engine = new Art Engine ( this , pin net no , ctrl settings . trace clearance idx , p stoppable ) ; Art Result result = a engine . autoroute connection ( pin connected set , unconnected set , ctrl settings , ripped item list ) ; if ( result == Art Result . ROUTED ) { Time Limit Stoppable t limit = new Time Limit Stoppable ( s PREVENT ENDLESS LOOP , p stoppable ) ; changed area optimize ( Net Nos List . EMPTY , p settings . trace pullt min move , ctrl settings . trace costs , t limit ) ; } return result ; }
int fp 1 ( int level ) { Object x = null ; if ( level > NUM_ ) x = new Object ( ) ; if ( level > NUM_ ) return x . hash Code ( ) ; return NUM_ ; }
public void scan ( ) { fields Types Values = new Keep First Tree Map < String , Pair < String , String > > ( ) ; if ( object == null ) { return ; } Class < ? > clazz = object . get Class ( ) ; do { list ( clazz ) ; clazz = clazz . get Superclass ( ) ; } while ( clazz != null ) ; }
public void log Velocity Message ( int level , String message ) { if ( message . equals ( Introspector . CACHEDUMP MSG ) ) { saw Cache Dump = true ; } }
@ Override public void execute ( String ... parameters ) throws IO Exception { if ( parameters . length < NUM_ ) { cio . writeln ( Print Help . FEDERATE ) ; } else { Linked List < String > plist = new Linked List < String > ( Arrays . as List ( parameters ) ) ; plist . remove ( ) ; boolean distinct = get Optional Param Value ( plist , STR_ , false ) ; boolean readonly = get Optional Param Value ( plist , STR_ , true ) ; if ( distinct Values ( plist ) ) { String fed ID = plist . pop ( ) ; federate ( distinct , readonly , fed ID , plist ) ; } else { cio . write Error ( STR_ ) ; } } }
protected void add Error ( String error ) { if ( error != null && error . length ( ) > NUM_ ) { if ( error Message == null ) error Message = STR_ ; else error Message += STR_ ; error Message += error ; } }
private void build String ( String Builder sb , Two D Node node ) { if ( node == null ) { return ; } Two D Node left = node . get Below ( ) ; Two D Node right = node . get Above ( ) ; if ( left != null ) { build String ( sb , left ) ; } sb . append ( node . to String ( ) ) ; if ( right != null ) { build String ( sb , right ) ; } }
private Un Managed Consistency Group create Un Managed CG ( Volume Consistency Group driver CG , com . emc . storageos . db . client . model . Storage System storage System , Db Client db Client ) { Un Managed Consistency Group un Managed CG = new Un Managed Consistency Group ( ) ; un Managed CG . set Id ( URI Util . create Id ( Un Managed Consistency Group . class ) ) ; un Managed CG . set Label ( driver CG . get Device Label ( ) ) ; un Managed CG . set Name ( driver CG . get Device Label ( ) ) ; String un Managed CG Native Guid = Native GUID Generator . generate Native Guid For CG ( storage System . get Native Guid ( ) , driver CG . get Native Id ( ) ) ; un Managed CG . set Native Guid ( un Managed CG Native Guid ) ; un Managed CG . set Native Id ( driver CG . get Native Id ( ) ) ; un Managed CG . set Storage System Uri ( storage System . get Id ( ) ) ; db Client . create Object ( un Managed CG ) ; return un Managed CG ; }
public Iterator < Tcp Discovery Abstract Message > iterator ( ) { return new Skip Iterator ( ) ; }
private void rotate Left ( Node < K , V > root ) { Node < K , V > left = root . left ; Node < K , V > pivot = root . right ; Node < K , V > pivot Left = pivot . left ; Node < K , V > pivot Right = pivot . right ; root . right = pivot Left ; if ( pivot Left != null ) { pivot Left . parent = root ; } replace In Parent ( root , pivot ) ; pivot . left = root ; root . parent = pivot ; root . height = Math . max ( left != null ? left . height : NUM_ , pivot Left != null ? pivot Left . height : NUM_ ) + NUM_ ; pivot . height = Math . max ( root . height , pivot Right != null ? pivot Right . height : NUM_ ) + NUM_ ; }
protected int index First Of ( final String s , final String delims ) { return index First Of ( s , delims , - NUM_ ) ; }
public static void write Ml Result To File ( Multilabel Result result , File file ) throws File Not Found Exception , IO Exception { Object Output Stream stream = new Object Output Stream ( new File Output Stream ( file ) ) ; stream . write Object ( result ) ; stream . close ( ) ; }
public static Thread Context new MDC Enabled Context ( ) { return new Thread Context ( new Log 4 j Mdc Bridge ( ) ) ; }
private X Path Factory load From Services File ( String uri , String resource Name , Input Stream in ) { if ( debug ) debug Println ( STR_ + resource Name ) ; Buffered Reader rd ; try { rd = new Buffered Reader ( new Input Stream Reader ( in , STR_ ) , DEFAULT LINE LENGTH ) ; } catch ( java . io . Unsupported Encoding Exception e ) { rd = new Buffered Reader ( new Input Stream Reader ( in ) , DEFAULT LINE LENGTH ) ; } String factory Class Name ; X Path Factory result Factory = null ; while ( true ) { try { factory Class Name = rd . read Line ( ) ; } catch ( IO Exception x ) { break ; } if ( factory Class Name != null ) { int hash Index = factory Class Name . index Of ( STR_ ) ; if ( hash Index != - NUM_ ) { factory Class Name = factory Class Name . substring ( NUM_ , hash Index ) ; } factory Class Name = factory Class Name . trim ( ) ; if ( factory Class Name . length ( ) == NUM_ ) { continue ; } try { X Path Factory found Factory = create Instance ( factory Class Name ) ; if ( found Factory . is Object Model Supported ( uri ) ) { result Factory = found Factory ; break ; } } catch ( Exception ignored ) { } } else { break ; } } Io Utils . close Quietly ( rd ) ; return result Factory ; }
private boolean create Remote Files Support DB Objects ( SQ Lite Database db ) { boolean success = false ; try { create Remotefiles ( db ) ; create Remotefiles 2 Articles ( db ) ; create Remotefiles View ( db ) ; success = true ; } catch ( SQL Exception e ) { Log . e ( TAG , STR_ + e ) ; } return success ; }
public Short read ( String value ) { return Short . value Of ( value ) ; }
public Object create Edge ( Object parent , String id , Object value , Object source , Object target , String style ) { if ( edge Template != null ) { mx Cell edge = ( mx Cell ) clone Cells ( new Object [ ] { edge Template } ) [ NUM_ ] ; edge . set Id ( id ) ; return edge ; } return super . create Edge ( parent , id , value , source , target , style ) ; }
public static Inheritance Tree create From Class List ( Collection < String > class Names ) throws Illegal Argument Exception { if ( class Names == null || class Names . is Empty ( ) ) { throw new Illegal Argument Exception ( STR_ ) ; } Inheritance Tree inheritance Tree = new Inheritance Tree ( ) ; for ( String class Name : class Names ) { if ( class Name == null ) { throw new Illegal Argument Exception ( STR_ ) ; } analyze Class Name ( inheritance Tree , class Name ) ; } Set < String > classes = new Hash Set < > ( inheritance Tree . get All Classes ( ) ) ; for ( String class Name : classes ) { if ( ! class Names . contains ( class Name ) ) inheritance Tree . remove Class ( class Name ) ; } return inheritance Tree ; }
private synchronized void read Object ( java . io . Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; init ( get Name ( ) ) ; }
protected String num 2 Short ID ( int num , char [ ] ID Chars , int ID Width ) { char ID [ ] = new char [ ID Width ] ; int i ; for ( i = ID Width - NUM_ ; i >= NUM_ ; i -- ) { ID [ i ] = ID Chars [ num % ID Chars . length ] ; num = num / ID Chars . length - NUM_ ; if ( num < NUM_ ) { break ; } } for ( i -- ; i >= NUM_ ; i -- ) { ID [ i ] = STR_ ; } return new String ( ID ) ; }
public Cursor new Cursor ( String store Name ) throws Unknown Store Exception { I Store < Byte Array , byte [ ] > store = get Store ( store Name ) ; int cursor Id = rpc Service . get Transaction Id ( ) ; Cursor cursor = new Cursor ( cursor Id , store . entries ( ) ) ; cursor Map . put ( Integer . value Of ( cursor Id ) , cursor ) ; return cursor ; }
protected Instances process ( Instances data ) { return data ; }
public void remove Property Change Listener ( String property Name , Property Change Listener in pcl ) { bean Context Child Support . remove Property Change Listener ( property Name , in pcl ) ; }
@ Override public String generate Label ( Category Dataset dataset , int series ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; String label = Message Format . format ( this . format Pattern , create Item Array ( dataset , series ) ) ; return label ; }
public void add Slider Apply Action Listener ( Action Listener al ) { slider Apply . add Action Listener ( al ) ; }
protected Object evaluate Left Contains Right ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Left Contains Right ( ( Structured Content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM_ ) { return ( Structured Content ) array . get ( NUM_ ) ; } return array ; }
public void update Value ( Column column , Row Id row Id , Object value ) throws IO Exception { Object [ ] row = new Object [ columns . size ( ) ] ; Arrays . fill ( row , Column . KEEP VALUE ) ; column . set Row Value ( row , value ) ; update Row ( row Id , row ) ; }
protected void draw Oval ( int x , int y , int w , int h , Color fill Color , Paint fill Paint , Color pen Color , boolean shadow ) { if ( fill Color != null || fill Paint != null ) { if ( shadow ) { g . set Color ( mx Constants . SHADOW COLOR ) ; g . fill Oval ( x + mx Constants . SHADOW OFFSETX , y + mx Constants . SHADOW OFFSETY , w , h ) ; } if ( fill Paint != null ) { g . set Paint ( fill Paint ) ; } else { g . set Color ( fill Color ) ; } g . fill Oval ( x , y , w , h ) ; } if ( pen Color != null ) { g . set Color ( pen Color ) ; g . draw Oval ( x , y , w , h ) ; } }
@ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof Eager Foreign Collection ) ) { return false ; } @ Suppress Warnings ( STR_ ) Eager Foreign Collection other = ( Eager Foreign Collection ) obj ; return results . equals ( other . results ) ; }
protected void init Debug ( ) { String debug Param = get Init Parameter ( STR_ ) ; set Debug ( ( debug Param == null ) ? false : Boolean . value Of ( debug Param ) ) ; }
void invite ( ) { if ( m Grid . get Checked Item Count ( ) <= NUM_ ) { return ; } List < String > to = null ; int [ ] keys = Sparse Arrays . true Keys ( m Grid . get Checked Item Positions ( ) ) ; for ( int pos : keys ) { Easy Cursor c = ( Easy Cursor ) m Grid . get Item At Position ( pos ) ; if ( c . is Null ( Contacts . GLOBAL ID ) && ! c . is Null ( Contacts . EMAIL ) ) { if ( to == null ) { to = new Array List < > ( keys . length ) ; } String email = c . get String ( Contacts . EMAIL ) ; if ( ! email . contains ( STR_ ) ) { to . add ( email ) ; } else { Collection Utils . add All ( to , email . split ( STR_ ) ) ; } } } if ( to != null ) { send Invite ( to , this ) ; event ( STR_ , STR_ , to . size ( ) ) ; } }
@ Override public synchronized boolean can Unsubscribe ( Consumer consumer ) { return ( consumers . size ( ) == NUM_ ) && Objects . equals ( consumer , active Consumer . get ( ) ) ; }
public Byte Buffer allocate ( int body Size ) { body Size = Math . min ( body Size , max Plaintext Size ) ; int padding = NUM_ ; if ( security Mode == Message Security Mode . Sign And Encrypt ) { int plaintext Size Excluding Padding = body Size + sequence Header + signature Size ; padding = get Minimum Padding ( ) ; int modulo = ( padding + plaintext Size Excluding Padding ) % cipher Block Size ; if ( modulo != NUM_ ) padding += cipher Block Size - modulo ; logger . trace ( STR_ , padding ) ; } int chunk Size = body Size + message Header Size + security Header + sequence Header + signature Size + padding ; logger . trace ( STR_ , chunk Size ) ; assert ( chunk Size <= max Chunk Size ) ; Byte Buffer result = Byte Buffer . allocate ( chunk Size ) ; result . order ( Byte Order . LITTLE ENDIAN ) ; result . position ( NUM_ ) ; result . put Int ( chunk Size ) ; if ( security Mode == Message Security Mode . Sign And Encrypt ) { write Padding ( message Header Size + security Header + sequence Header + body Size , padding , result ) ; } result . position ( message Header Size + security Header + sequence Header ) ; result = result . slice ( ) ; result . order ( Byte Order . LITTLE ENDIAN ) ; result . limit ( body Size ) ; return result ; }
public void end Document ( ) throws IO Exception { writer . flush ( ) ; }
@ Request Mapping ( value = STR_ , method = Request Method . GET ) public void slo Default Tenant ( Locale locale , Model model , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { logger . info ( STR_ + STR_ + locale . to String ( ) + STR_ ) ; slo ( locale , Shared . get Default Tenant ( ) , model , request , response ) ; }
private static int uarimax Lt ( double value , double [ ] bv , int [ ] bvi , Binary Operator b Op ) throws DML Runtime Exception { int ix Max = bv . length ; if ( value < bv [ NUM_ ] || value >= bv [ bv . length - NUM_ ] ) return ix Max ; int ix = Arrays . binary Search ( bv , value ) ; if ( ix < NUM_ ) ix = Math . abs ( ix ) - NUM_ ; ix Max = bvi [ ix ] + NUM_ ; return ix Max ; }
public void zoom ( int wheel ) { double x = current Value ; if ( ( x < min Value ) || ( x > max Value ) ) { x = ( max Value + min Value ) / NUM_ ; } double wid = Math . abs ( max Value - min Value ) ; double x E = ( max Value - x ) / wid ; double x W = ( x - min Value ) / wid ; double w = min Value + wheel * x W ; double e = max Value - wheel * x E ; if ( w >= e ) { return ; } min Value = Math . max ( default Min , w ) ; max Value = Math . min ( default Max , e ) ; scale Canvas . repaint ( ) ; }
public static void print Usage ( final Print Stream print Stream , final boolean print Hidden , Command Lookup info ) { print Stream . print ( get Usage ( print Hidden , info ) ) ; }
private File create Temp File ( String suffix ) throws IO Exception { String prefix = STR_ ; if ( ! Strings . is Null Or Empty ( get Name ( ) ) ) { prefix += get Name ( ) + STR_ ; } File tmp = File . create Temp File ( prefix , suffix ) ; to Cleanup . add ( tmp ) ; return tmp ; }
protected int hash ( Object key 1 , Object key 2 , Object key 3 , Object key 4 , Object key 5 ) { int h = NUM_ ; if ( key 1 != null ) { h ^= key 1 . hash Code ( ) ; } if ( key 2 != null ) { h ^= key 2 . hash Code ( ) ; } if ( key 3 != null ) { h ^= key 3 . hash Code ( ) ; } if ( key 4 != null ) { h ^= key 4 . hash Code ( ) ; } if ( key 5 != null ) { h ^= key 5 . hash Code ( ) ; } h += ~ ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; h += ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; return h ; }
private static Decoder Result create Decoder Result From Ambiguous Values ( int ec Level , int [ ] codewords , int [ ] erasure Array , int [ ] ambiguous Indexes , int [ ] [ ] ambiguous Index Values ) throws Format Exception , Checksum Exception { int [ ] ambiguous Index Count = new int [ ambiguous Indexes . length ] ; int tries = NUM_ ; while ( tries -- > NUM_ ) { for ( int i = NUM_ ; i < ambiguous Index Count . length ; i ++ ) { codewords [ ambiguous Indexes [ i ] ] = ambiguous Index Values [ i ] [ ambiguous Index Count [ i ] ] ; } try { return decode Codewords ( codewords , ec Level , erasure Array ) ; } catch ( Checksum Exception ignored ) { } if ( ambiguous Index Count . length == NUM_ ) { throw Checksum Exception . get Checksum Instance ( ) ; } for ( int i = NUM_ ; i < ambiguous Index Count . length ; i ++ ) { if ( ambiguous Index Count [ i ] < ambiguous Index Values [ i ] . length - NUM_ ) { ambiguous Index Count [ i ] ++ ; break ; } else { ambiguous Index Count [ i ] = NUM_ ; if ( i == ambiguous Index Count . length - NUM_ ) { throw Checksum Exception . get Checksum Instance ( ) ; } } } } throw Checksum Exception . get Checksum Instance ( ) ; }
public static double black Formula Std Dev Derivative ( @ Real double strike , @ Real double forward , @ Std Dev final double stddev , @ Discount Factor final double discount , @ Real final double displacement ) { QL . require ( strike >= NUM_ , STR_ ) ; QL . require ( forward > NUM_ , STR_ ) ; QL . require ( stddev >= NUM_ , STR_ ) ; QL . require ( discount > NUM_ , STR_ ) ; QL . require ( displacement >= NUM_ , STR_ ) ; forward = forward + displacement ; strike = strike + displacement ; final double d 1 = Math . log ( forward / strike ) / stddev + NUM_ * stddev ; final Cumulative Normal Distribution cdf = new Cumulative Normal Distribution ( ) ; return discount * forward * cdf . derivative ( d 1 ) ; }
public void send Registration Id ( ) throws Android Agent Exception { Device Info device Info = new Device Info ( context ) ; Device Info Payload device Info Payload = new Device Info Payload ( context ) ; device Info Payload . build ( ) ; String reply Payload = device Info Payload . get Device Info Payload ( ) ; String ip Saved = Constants . DEFAULT HOST ; String pref IP = Preference . get String ( context , Constants . Preference Flag . IP ) ; if ( pref IP != null ) { ip Saved = pref IP ; } if ( ip Saved != null && ! ip Saved . is Empty ( ) ) { Server Config utils = new Server Config ( ) ; utils . set Server IP ( ip Saved ) ; String url = utils . get API Server URL ( context ) + Constants . DEVICE ENDPOINT + device Info . get Device Id ( ) ; Common Utils . call Secured API ( context , url , org . wso 2 . emm . agent . proxy . utils . Constants . HTTP METHODS . PUT , reply Payload , Registration Activity . this , Constants . GCM REGISTRATION ID SEND CODE ) ; } else { Log . e ( TAG , STR_ ) ; } }
public static boolean protect Against Wrapping Attack ( Node start Node , String value ) { Node start Parent = start Node . get Parent Node ( ) ; Node processed Node = null ; Element found Element = null ; String id = value . trim ( ) ; if ( ! id . is Empty ( ) && id . char At ( NUM_ ) == STR_ ) { id = id . substring ( NUM_ ) ; } while ( start Node != null ) { if ( start Node . get Node Type ( ) == Node . ELEMENT NODE ) { Element se = ( Element ) start Node ; Named Node Map attributes = se . get Attributes ( ) ; if ( attributes != null ) { for ( int i = NUM_ ; i < attributes . get Length ( ) ; i ++ ) { Attr attr = ( Attr ) attributes . item ( i ) ; if ( attr . is Id ( ) && id . equals ( attr . get Value ( ) ) ) { if ( found Element == null ) { found Element = attr . get Owner Element ( ) ; } else { log . log ( java . util . logging . Level . FINE , STR_ ) ; return false ; } } } } } processed Node = start Node ; start Node = start Node . get First Child ( ) ; if ( start Node == null ) { start Node = processed Node . get Next Sibling ( ) ; } while ( start Node == null ) { processed Node = processed Node . get Parent Node ( ) ; if ( processed Node == start Parent ) { return true ; } start Node = processed Node . get Next Sibling ( ) ; } } return true ; }
public static Jvm Arguments parse Arguments ( String arguments ) { Jvm Arguments jvm Arguments = new Jvm Arguments ( ) ; String Buffer generic Args = new String Buffer ( ) ; if ( arguments != null ) { for ( String arg : arguments . split ( STR_ ) ) { if ( arg . starts With ( STR_ ) ) { long initial Heap = get Heap Arg Value In Bytes ( arg ) ; jvm Arguments . set Initial Heap ( initial Heap ) ; } else if ( arg . starts With ( STR_ ) ) { long max Heap = get Heap Arg Value In Bytes ( arg ) ; jvm Arguments . set Max Heap ( max Heap ) ; } else { if ( generic Args . length ( ) > NUM_ ) { generic Args . append ( STR_ ) ; } generic Args . append ( arg ) ; } } } jvm Arguments . set Generic Args ( generic Args . to String ( ) ) ; return jvm Arguments ; }
private Layout Manager create Layout ( ) { Sea Glass Context context = get Context ( this ) ; Layout Manager lm = ( Layout Manager ) style . get ( context , STR_ ) ; context . dispose ( ) ; return ( lm != null ) ? lm : new Sea Glass Title Pane Layout ( ) ; }
private static boolean is Left Outlier ( int index , Array List < Double > values ) { double current Value = values . get ( index ) ; double value To Left = values . get ( index - NUM_ ) ; return Math . abs ( current Value - value To Left ) > NUM_ ; }
public void add File ( String file ) { check File Names ( Collections . singleton ( file ) ) ; set Files . add ( named For This Segment ( file ) ) ; }
public static Value Compresson Holder . Un Compress Value un Compress None ( Data Type comp Data Type , Data Type actual Data Type ) { if ( actual Data Type == Data Type . DATA BIGINT ) { return new Un Compress Default Long ( ) ; } else { switch ( comp Data Type ) { case DATA BYTE : return new Un Compress None Byte ( ) ; case DATA SHORT : return new Un Compress None Short ( ) ; case DATA INT : return new Un Compress None Int ( ) ; case DATA LONG : return new Un Compress None Long ( ) ; case DATA FLOAT : return new Un Compress None Float ( ) ; default : return new Un Compress None Default ( ) ; } } }
public Stash Row Iterable ( ) { initial Iterator = create Stash Row Iterator ( ) ; try { initial Iterator . has Next ( ) ; open Iterators . add ( initial Iterator ) ; } catch ( Exception e ) { try { Closeables . close ( initial Iterator , true ) ; } catch ( IO Exception e 2 ) { } throw Throwables . propagate ( e ) ; } }
public static int rand Range ( int min , int max ) { int mod = max - min ; double val = Math . ceil ( Math . random ( ) * NUM_ ) % mod ; return ( int ) val + min ; }
private String print X Format ( final long x ) { String sx = null ; if ( x == Long . MIN VALUE ) { sx = STR_ ; } else if ( x < NUM_ ) { final String t = Long . to String ( ( ~ ( - x - NUM_ ) ) ^ Long . MIN VALUE , NUM_ ) ; switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : switch ( t . char At ( NUM_ ) ) { case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; } break ; } } else { sx = Long . to String ( x , NUM_ ) ; } return print X Format ( sx ) ; }
public TPS filter ( final long from Time , final long to Time ) { return filter ( from Time , to Time , null ) ; }
protected void serialize Attribute ( Tag Node tag Node , Writer writer , String att Name , String att Value ) throws IO Exception { if ( ! is Forbidden Attribute ( tag Node , att Name , att Value ) ) { writer . write ( STR_ + att Name + STR_ + escape Xml ( att Value ) + STR_ ) ; } }
private static String codegen RSL Root Class ( String base , String root Class Name ) { String line Sep = System . get Property ( STR_ ) ; String [ ] code Pieces = new String [ ] { STR_ , line Sep , STR_ , line Sep , line Sep , STR_ , line Sep , STR_ , line Sep , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , root Class Name , line Sep , STR_ , base , line Sep , STR_ , line Sep , STR_ , root Class Name , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , line Sep , STR_ , line Sep , line Sep , STR_ , line Sep } ; return String Joiner . join ( code Pieces , null ) ; }
@ Override protected boolean check Entry Not Valid ( Region Entry map Entry ) { return ( super . check Entry Not Valid ( map Entry ) || map Entry . get Key ( ) instanceof Thread Identifier ) ; }
@ Override public boolean input ( Instance instance ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = false ; } if ( is First Batch Done ( ) && m dont Filter After First Batch ) { push ( ( Instance ) instance . copy ( ) ) ; return true ; } if ( instance . is Missing ( m Att Index . get Index ( ) ) ) { if ( ! get Match Missing Values ( ) ) { push ( ( Instance ) instance . copy ( ) ) ; return true ; } else { return false ; } } if ( is Numeric ( ) ) { if ( ! m Values . get Invert ( ) ) { if ( instance . value ( m Att Index . get Index ( ) ) < m Value ) { push ( ( Instance ) instance . copy ( ) ) ; return true ; } } else { if ( instance . value ( m Att Index . get Index ( ) ) >= m Value ) { push ( ( Instance ) instance . copy ( ) ) ; return true ; } } } if ( is Nominal ( ) ) { if ( m Values . is In Range ( ( int ) instance . value ( m Att Index . get Index ( ) ) ) ) { Instance temp = ( Instance ) instance . copy ( ) ; if ( get Modify Header ( ) ) { temp . set Value ( m Att Index . get Index ( ) , m Nominal Mapping [ ( int ) instance . value ( m Att Index . get Index ( ) ) ] ) ; } push ( temp ) ; return true ; } } return false ; }
public Binding lookup ( String var Name ) { if ( var Name . equals ( binding . get Var Name ( ) ) ) { return binding ; } return parent != null ? parent . lookup ( var Name ) : null ; }
private static void print Unicode Property Values And Aliases ( String unicode Version ) throws Unicode Properties . Unsupported Unicode Version Exception { Pattern version Pattern = Pattern . compile ( STR_ ) ; Matcher matcher = version Pattern . matcher ( unicode Version ) ; if ( ! matcher . matches ( ) ) { throw new Unicode Properties . Unsupported Unicode Version Exception ( ) ; } String underscore Version = matcher . group ( NUM_ ) + ( null == matcher . group ( NUM_ ) ? STR_ : STR_ + matcher . group ( NUM_ ) ) ; String [ ] property Values ; String [ ] property Value Aliases ; try { Class < ? > clazz = Class . for Name ( STR_ + underscore Version ) ; Field field = clazz . get Field ( STR_ ) ; property Values = ( String [ ] ) field . get ( null ) ; field = clazz . get Field ( STR_ ) ; property Value Aliases = ( String [ ] ) field . get ( null ) ; } catch ( Exception e ) { throw new Unicode Properties . Unsupported Unicode Version Exception ( ) ; } Sorted Map < String , Sorted Set < String > > property Values To Aliases = new Tree Map < String , Sorted Set < String > > ( ) ; for ( String value : property Values ) { property Values To Aliases . put ( value , new Tree Set < String > ( ) ) ; } for ( int i = NUM_ ; i < property Value Aliases . length ; i += NUM_ ) { String alias = property Value Aliases [ i ] ; String value = property Value Aliases [ i + NUM_ ] ; Sorted Set < String > aliases = property Values To Aliases . get ( value ) ; if ( null == aliases ) { aliases = new Tree Set < String > ( ) ; property Values To Aliases . put ( value , aliases ) ; } aliases . add ( alias ) ; } for ( Map . Entry < String , Sorted Set < String > > entry : property Values To Aliases . entry Set ( ) ) { String value = entry . get Key ( ) ; Sorted Set < String > aliases = entry . get Value ( ) ; Out . print ( value ) ; if ( aliases . size ( ) > NUM_ ) { for ( String alias : aliases ) { Out . print ( STR_ + alias ) ; } } Out . println ( STR_ ) ; } }
public void add Listener ( FS Mouse Listener l ) { if ( l == null ) { return ; } if ( ! handlers . contains Key ( l ) ) { handlers . put ( l , l ) ; } if ( ! enabled && handlers . size ( ) > NUM_ ) { panel . add Mouse Listener ( this ) ; panel . add Mouse Motion Listener ( this ) ; enabled = true ; } }
public void state Changed ( Change Event e ) { J Slider j = ( J Slider ) e . get Source ( ) ; Bounded Range Model r = j . get Model ( ) ; for ( int i = NUM_ ; i < n Values ; i ++ ) { if ( r == models [ i ] ) { set Model ( i , r . get Value ( ) ) ; break ; } } prop . fire Property Change ( STR_ , null , j ) ; }
public void detach ( ) { activity . clear ( ) ; }
protected Result Plot create Chart ( String metric ) { if ( metric . equals ( STR_ ) ) { return new Approximation Set Plot ( this , metric ) ; } else { return new Line Plot ( this , metric ) ; } }
public List < String > parse Default ( String ... args ) { return parse Default ( Arrays . as List ( args ) ) ; }
public Serial IO ( String port Name , byte [ ] data Begin , byte [ ] data End ) { this . port Name = port Name ; this . data Begin = Arrays . copy Of ( data Begin , data Begin . length ) ; this . data End = Arrays . copy Of ( data End , data End . length ) ; }
public void add To Bucket ( Basic Block block ) { bucket . add ( block ) ; }
private void dispatch Message ( Distribution Message msg ) { Internal Distributed Member m = msg . get Sender ( ) ; boolean shunned = false ; if ( is Shunned Or New ( m ) ) { latest View Write Lock . lock ( ) ; try { if ( is Shunned ( m ) ) { if ( msg instanceof Startup Message ) { end Shun ( m ) ; } else { shunned = true ; } } if ( ! shunned ) { if ( is New ( m ) ) { shunned = ! add Surprise Member ( m ) ; } } } finally { latest View Write Lock . unlock ( ) ; } } if ( shunned ) { warn Shun ( m ) ; if ( logger . is Trace Enabled ( Log Marker . DISTRIBUTION VIEWS ) ) { logger . trace ( Log Marker . DISTRIBUTION VIEWS , STR_ , m , msg ) ; } throw new Member Shunned Exception ( m ) ; } listener . message Received ( msg ) ; }
public Document List Entry ( ) { super ( ) ; }
public final Byte Array Builder append ( String Builder string Builder , Charset charset ) throws Unsupported Encoding Exception { return append ( string Builder . to String ( ) , charset ) ; }
@ Override public String compile ( final String content , final String name ) { final String precompiled Function = super . compile ( content , STR_ ) ; return String . format ( STR_ , name , precompiled Function ) ; }
@ Override public void draw Background ( Graphics 2 D g 2 , Rectangle 2 D area ) { fill Background ( g 2 , area , this . orientation ) ; draw Quadrants ( g 2 , area ) ; draw Background Image ( g 2 , area ) ; }
protected void tag ( String tag , Array List names , Array List values , int nattr , boolean close ) { spacing ( ) ; m out . print ( STR_ ) ; m out . print ( tag ) ; for ( int i = NUM_ ; i < nattr ; ++ i ) { m out . print ( STR_ ) ; m out . print ( ( String ) names . get ( i ) ) ; m out . print ( STR_ ) ; m out . print ( STR_ ) ; escape String ( ( String ) values . get ( i ) ) ; m out . print ( STR_ ) ; } if ( close ) m out . print ( STR_ ) ; m out . print ( STR_ ) ; println ( ) ; if ( ! close ) { m tag Stack . add ( tag ) ; } }
public Task Convert Image To RGB Preview create Task Convert Image To RGB Preview ( Image To Process image , Executor executor , Image Backend image Backend , Capture Session session , Size target Size , Task Convert Image To RGB Preview . Thumbnail Shape thumbnail Shape ) { return new Task Convert Image To RGB Preview ( image , executor , image Backend , Task Image Container . Processing Priority . FAST , session , m Tiny Thumbnail Target Size , thumbnail Shape ) ; }
@ Override public void on Bind View Holder ( K holder , int positions ) { int view Type = holder . get Item View Type ( ) ; switch ( view Type ) { case NUM_ : convert ( holder , m Data . get ( holder . get Layout Position ( ) - get Header Layout Count ( ) ) ) ; break ; case LOADING VIEW : add Load More ( holder ) ; break ; case HEADER VIEW : break ; case EMPTY VIEW : break ; case FOOTER VIEW : break ; default : convert ( holder , m Data . get ( holder . get Layout Position ( ) - get Header Layout Count ( ) ) ) ; break ; } }
public void find Tax Category ID ( ) { m AD Client ID = Env . get AD Client ID ( Env . get Ctx ( ) ) ; m AD Org ID = Env . get AD Org ID ( Env . get Ctx ( ) ) ; m Created By = Env . get AD User ID ( Env . get Ctx ( ) ) ; String sql = STR_ + STR_ ; m C Tax Category ID = NUM_ ; try { Prepared Statement pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM_ , m AD Client ID ) ; Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) m C Tax Category ID = rs . get Int ( NUM_ ) ; rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } }
public void modifydn ( String dn , String attributes ) throws Naming Exception { Dir Context ctx = new Initial Dir Context ( env ) ; ctx . rename ( dn , attributes ) ; ctx . close ( ) ; }
private Instance update Decision List ( Random random , Instance example ) throws Exception { Array List < Test > Test List ; Instances format = get Dataset Format ( ) ; if ( format == null ) { throw new Exception ( STR_ ) ; } Test List = generate Test List ( random , example ) ; int max Size = get Max Rule Size ( ) < Test List . size ( ) ? get Max Rule Size ( ) : Test List . size ( ) ; int rule Size = ( ( int ) ( random . next Double ( ) * ( max Size - get Min Rule Size ( ) ) ) ) + get Min Rule Size ( ) ; Rule List new Rule = new Rule List ( ) ; for ( int i = NUM_ ; i < rule Size ; i ++ ) { int test Index = ( int ) ( random . next Double ( ) * Test List . size ( ) ) ; Test test = Test List . get ( test Index ) ; new Rule . add Test ( test ) ; Test List . remove ( test Index ) ; } double new Class Value = NUM_ ; if ( m Decision List . size ( ) > NUM_ ) { Rule List r = ( m Decision List . get ( m Decision List . size ( ) - NUM_ ) ) ; double old Class Value = ( r . get Class Value ( ) ) ; new Class Value = ( double ) ( ( int ) old Class Value + NUM_ ) % get Num Classes ( ) ; } new Rule . set Class Value ( new Class Value ) ; m Decision List . add ( new Rule ) ; example = ( Instance ) example . copy ( ) ; example . set Dataset ( format ) ; example . set Class Value ( new Class Value ) ; return example ; }
static String escape String For ASCII ( String s ) { String Builder out = new String Builder ( ) ; char [ ] c Array = s . to Char Array ( ) ; for ( int i = NUM_ ; i < c Array . length ; i ++ ) { char c = c Array [ i ] ; if ( c > NUM_ ) { out . append ( STR_ ) ; String hex = Integer . to Hex String ( c ) ; while ( hex . length ( ) < NUM_ ) hex = STR_ + hex ; out . append ( hex ) ; } else if ( c == STR_ ) { out . append ( STR_ ) ; } else if ( c == STR_ ) { out . append ( STR_ ) ; } else if ( c == STR_ ) { out . append ( STR_ ) ; } else if ( c == STR_ ) { out . append ( STR_ ) ; } else if ( c == STR_ ) { out . append ( STR_ ) ; } else if ( c == STR_ ) { out . append ( STR_ ) ; } else { out . append ( c ) ; } } return out . to String ( ) ; }
public void clear ( ) { change Reports . clear ( ) ; }
protected Set < D > compute Return Flow Function ( Flow Function < D > ret Function , D d 1 , D d 2 , N call Site , Collection < D > caller Side Ds ) { return ret Function . compute Targets ( d 2 ) ; }
@ Rpc Method public void detach Disks ( String vm Id , List < String > disk Ids , Async Method Callback < Host . Async Client . detach disks call > handler ) throws Rpc Exception { ensure Client ( ) ; Vm Disks Detach Request vm Disks Detach Request = new Vm Disks Detach Request ( vm Id , disk Ids ) ; client Proxy . set Timeout ( DETACH DISKS TIMEOUT MS ) ; logger . info ( STR_ , vm Id , disk Ids , get Host Ip ( ) , vm Disks Detach Request ) ; try { client Proxy . detach disks ( vm Disks Detach Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public static void close ( Statement st ) { try { if ( st != null ) st . close ( ) ; } catch ( SQL Exception e ) { ; } }
protected void dispose Drawing Buffer ( ) { Image local Drawing Buffer = drawing Buffer ; drawing Buffer = null ; if ( local Drawing Buffer != null ) { local Drawing Buffer . flush ( ) ; } }
private static String do Normalize ( String filename , char separator , boolean keep Separator ) { if ( filename == null ) return null ; int size = filename . length ( ) ; if ( size == NUM_ ) return filename ; int prefix = get Prefix Length ( filename ) ; if ( prefix < NUM_ ) return null ; char [ ] array = new char [ size + NUM_ ] ; filename . get Chars ( NUM_ , filename . length ( ) , array , NUM_ ) ; char other Separator = separator == SYSTEM SEPARATOR ? OTHER SEPARATOR : SYSTEM SEPARATOR ; for ( int i = NUM_ ; i < array . length ; i ++ ) { if ( array [ i ] == other Separator ) array [ i ] = separator ; } boolean last Is Directory = true ; if ( array [ size - NUM_ ] != separator ) { array [ size ++ ] = separator ; last Is Directory = false ; } for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == separator ) { System . arraycopy ( array , i , array , i - NUM_ , size - i ) ; size -- ; i -- ; } } for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == STR_ && ( i == prefix + NUM_ || array [ i - NUM_ ] == separator ) ) { if ( i == size - NUM_ ) last Is Directory = true ; System . arraycopy ( array , i + NUM_ , array , i - NUM_ , size - i ) ; size -= NUM_ ; i -- ; } } outer : for ( int i = prefix + NUM_ ; i < size ; i ++ ) { if ( array [ i ] == separator && array [ i - NUM_ ] == STR_ && array [ i - NUM_ ] == STR_ && ( i == prefix + NUM_ || array [ i - NUM_ ] == separator ) ) { if ( i == prefix + NUM_ ) return null ; if ( i == size - NUM_ ) last Is Directory = true ; int j ; for ( j = i - NUM_ ; j >= prefix ; j -- ) { if ( array [ j ] == separator ) { System . arraycopy ( array , i + NUM_ , array , j + NUM_ , size - i ) ; size -= i - j ; i = j + NUM_ ; continue outer ; } } System . arraycopy ( array , i + NUM_ , array , prefix , size - i ) ; size -= i + NUM_ - prefix ; i = prefix + NUM_ ; } } if ( size <= NUM_ ) { return STR_ ; } if ( size <= prefix ) { return new String ( array , NUM_ , size ) ; } if ( last Is Directory && keep Separator ) return new String ( array , NUM_ , size ) ; return new String ( array , NUM_ , size - NUM_ ) ; }
protected Transferable create Transferable ( J Component comp ) { export Comp = ( J Text Component ) comp ; should Remove = true ; p 0 = export Comp . get Selection Start ( ) ; p 1 = export Comp . get Selection End ( ) ; return ( p 0 != p 1 ) ? ( new Text Transferable ( export Comp , p 0 , p 1 ) ) : null ; }
private void deactivate Block ( ) { if ( ( m Block Listener != null ) && ( block != null ) ) { block . remove Property Change Listener ( m Block Listener ) ; } m Block Listener = null ; }
private static boolean parse One Value ( Field Def fd , Json Parser p , Document doc ) throws IO Exception { Object o = null ; float boost = NUM_ ; Json Token token = p . next Token ( ) ; if ( token == Json Token . START ARRAY ) { if ( STR_ . equals ( fd . faceted ) || fd . value Type == Field Def . Field Value Type . LAT LON ) { o = get Native Value ( fd , token , p ) ; } else { if ( fd . multi Valued == false ) { fail ( fd . name , STR_ ) ; } while ( true ) { if ( ! parse One Value ( fd , p , doc ) ) { break ; } } return true ; } } else { if ( token == Json Token . END ARRAY ) { assert fd . multi Valued ; return false ; } if ( fd . field Type . index Options ( ) != Index Options . NONE && token == Json Token . START OBJECT ) { while ( true ) { token = p . next Token ( ) ; if ( token == Json Token . END OBJECT ) { break ; } assert token == Json Token . FIELD NAME ; String key = p . get Text ( ) ; if ( key . equals ( STR_ ) ) { token = p . next Token ( ) ; if ( token == Json Token . VALUE NUMBER INT || token == Json Token . VALUE NUMBER FLOAT ) { boost = p . get Float Value ( ) ; } else { fail ( fd . name , STR_ + token ) ; } } else if ( key . equals ( STR_ ) ) { o = get Native Value ( fd , p . next Token ( ) , p ) ; } else { fail ( fd . name , STR_ + key + STR_ ) ; } } if ( o == null ) { fail ( fd . name , STR_ ) ; } } else { o = get Native Value ( fd , token , p ) ; } } parse One Native Value ( fd , doc , o , boost ) ; return true ; }
public Recognition Request ( File ... files ) { for ( File file : files ) { items . add ( new Item ( file ) ) ; } }
protected Int List add Metadata ( Array List < Meta Data > metadata ) { if ( keep Embed ) return super . add Metadata ( metadata ) ; Int List meta Data Indices = null ; if ( ( metadata != null ) && ( metadata . size ( ) > NUM_ ) ) { meta Data Indices = new Int List ( metadata . size ( ) ) ; for ( Meta Data meta Data : metadata ) { String id = meta Data . id ; if ( ! id . equals ( Standard Defs . MD EMBED ) ) { Value [ ] values = meta Data . values ; int meta Data Index = add Metadata Info ( id , values ) ; meta Data Indices . add ( meta Data Index ) ; } } } return meta Data Indices ; }
public void enter ( Object monitor ) { if ( monitor == null ) { throw new Null Pointer Exception ( ) ; } monitors . add ( monitor ) ; }
@ On Message public void on Message ( Byte Buffer buffer ) { if ( message Handler != null ) { message Handler . handle Message ( buffer ) ; } fire WS Heart Bit Monitor Timer ( ) ; }
protected Workflow . Method create CG Method ( URI vplex URI , URI cg URI , List < URI > vplex Volume UR Is ) { return new Workflow . Method ( CREATE CG METHOD NAME , vplex URI , cg URI , vplex Volume UR Is ) ; }
public static Writer left Shift ( Process self , Object value ) throws IO Exception { return IO Groovy Methods . left Shift ( self . get Output Stream ( ) , value ) ; }
public Integer read ( String value ) { return Integer . value Of ( value ) ; }
private static float [ ] derive Rotation Anchor Offsets ( Graphics 2 D g 2 , Attributed String text , Text Anchor anchor ) { float [ ] result = new float [ NUM_ ] ; Text Layout layout = new Text Layout ( text . get Iterator ( ) , g 2 . get Font Render Context ( ) ) ; Rectangle 2 D bounds = layout . get Bounds ( ) ; float ascent = layout . get Ascent ( ) ; float half Ascent = ascent / NUM_ ; float descent = layout . get Descent ( ) ; float leading = layout . get Leading ( ) ; float x Adj = NUM_ ; float y Adj = NUM_ ; if ( is Horizontal Left ( anchor ) ) { x Adj = NUM_ ; } else if ( is Horizontal Center ( anchor ) ) { x Adj = ( float ) bounds . get Width ( ) / NUM_ ; } else if ( is Horizontal Right ( anchor ) ) { x Adj = ( float ) bounds . get Width ( ) ; } if ( is Top ( anchor ) ) { y Adj = descent + leading - ( float ) bounds . get Height ( ) ; } else if ( is Half Height ( anchor ) ) { y Adj = descent + leading - ( float ) ( bounds . get Height ( ) / NUM_ ) ; } else if ( is Half Ascent ( anchor ) ) { y Adj = - half Ascent ; } else if ( is Baseline ( anchor ) ) { y Adj = NUM_ ; } else if ( is Bottom ( anchor ) ) { y Adj = descent + leading ; } result [ NUM_ ] = x Adj ; result [ NUM_ ] = y Adj ; return result ; }
public void reset doors ( ) { for ( Expand Room Obstacle curr room : expansion room arr ) { if ( curr room == null ) continue ; curr room . reset doors ( ) ; } }
private void update Base Matrix ( Drawable d ) { if ( null == d ) { return ; } final float view Width = get Width ( ) ; final float view Height = get Height ( ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( scale Type == Scale Type . CENTER ) { base Matrix . post Translate ( ( view Width - drawable Width ) / NUM_ , ( view Height - drawable Height ) / NUM_ ) ; } else if ( scale Type == Scale Type . CENTER CROP ) { float scale = Math . max ( width Scale , height Scale ) ; base Matrix . post Scale ( scale , scale ) ; base Matrix . post Translate ( ( view Width - ( drawable Width * scale ) ) / NUM_ , ( view Height - ( drawable Height * scale ) ) / NUM_ ) ; } else if ( scale Type == Scale Type . CENTER INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( width Scale , height Scale ) ) ; base Matrix . post Scale ( scale , scale ) ; base Matrix . post Translate ( ( view Width - ( drawable Width * scale ) ) / NUM_ , ( view Height - ( drawable Height * scale ) ) / NUM_ ) ; } else { Rect F m Temp Src = new Rect F ( NUM_ , NUM_ , drawable Width , drawable Height ) ; Rect F m Temp Dst = new Rect F ( NUM_ , NUM_ , view Width , view Height ) ; switch ( scale Type ) { case FIT CENTER : base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Matrix . Scale To Fit . CENTER ) ; break ; case FIT START : base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Matrix . Scale To Fit . START ) ; break ; case FIT END : base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Matrix . Scale To Fit . END ) ; break ; case FIT XY : base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Matrix . Scale To Fit . FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }
private Bitmap decode Preview ( Bitmap Source source , int target Size ) { Bitmap result = source . get Preview Bitmap ( ) ; if ( result == null ) { return null ; } float scale = ( float ) target Size / ( float ) ( Math . max ( result . get Width ( ) , result . get Height ( ) ) ) ; if ( scale <= NUM_ ) { result = Bitmap Utils . resize Bitmap By Scale ( result , scale , true ) ; } return ensure GL Compatible Bitmap ( result ) ; }
public void verify Decision Tables Do Not Share Keys ( Collection < Decision Table Entity > decision Tables ) { Set < String > key Set = new Linked Hash Set < String > ( ) ; for ( Decision Table Entity decision Table : decision Tables ) { if ( key Set . contains ( decision Table . get Key ( ) ) ) { throw new Activiti Dmn Exception ( STR_ ) ; } key Set . add ( decision Table . get Key ( ) ) ; } }
public void remove Vetoable Change Listener ( String property Name , Vetoable Change Listener in vcl ) { bean Context Child Support . remove Vetoable Change Listener ( property Name , in vcl ) ; }
private Node < K , V > find Predecessor Of Last ( ) { for ( ; ; ) { Index < K , V > q = head ; for ( ; ; ) { Index < K , V > d , r ; if ( ( r = q . right ) != null ) { if ( r . indexes Deleted Node ( ) ) { q . unlink ( r ) ; break ; } if ( r . node . next != null ) { q = r ; continue ; } } if ( ( d = q . down ) != null ) q = d ; else return q . node ; } } }
public Object deserialize ( final Type manifest , final byte [ ] body , final int size ) throws IO Exception { if ( manifest instanceof Class < ? > ) { return deserialize ( ( Class < ? > ) manifest , body , size ) ; } if ( is Null ( size , body ) ) { return null ; } final Json Reader json = new Json Reader < T Context > ( body , size , context ) ; json . get Next Token ( ) ; if ( json . was Null ( ) ) { return null ; } final Object result = deserialize With ( manifest , json ) ; if ( result != null ) return result ; if ( fallback != null ) { return fallback . deserialize ( context , manifest , body , size ) ; } throw new IO Exception ( STR_ + manifest + STR_ + STR_ + get Class ( ) ) ; }
public void run Once ( ) { List < Metric Datum With Key < Key Type > > data To Publish = null ; synchronized ( queue ) { long time Since Flush = Math . max ( NUM_ , get Time ( ) - last Flush Time ) ; if ( time Since Flush >= buffer Time Millis || queue . size ( ) >= flush Size || shutting Down ) { data To Publish = queue . drain ( flush Size ) ; LOG . debug ( STR_ , data To Publish . size ( ) ) ; if ( shutting Down ) { LOG . debug ( STR_ , queue . size ( ) ) ; shutdown = queue . is Empty ( ) ; } } else { long wait Time = buffer Time Millis - time Since Flush ; LOG . debug ( STR_ , wait Time , flush Size - queue . size ( ) ) ; try { queue . wait ( wait Time ) ; } catch ( Interrupted Exception e ) { } } } if ( data To Publish != null ) { try { metrics Publisher . publish Metrics ( data To Publish ) ; } catch ( Throwable t ) { LOG . error ( STR_ , t ) ; } last Flush Time = get Time ( ) + next Jitter Value To Use ; if ( max Jitter != NUM_ ) { next Jitter Value To Use = max Jitter - rand . next Int ( NUM_ * max Jitter ) ; } } }
public static String neg Bit Mask ( final long bits ) { return String . value Of ( ( NUM_ << bits ) & NUM_ ) ; }
private void run 2 ( ) throws Interrupted Exception { boolean first Log Iteration = true ; synchronized ( logger Lock ) { while ( true ) { int sleep Millis = get Log Interval ( ) ; if ( first Log Iteration ) { first Log Iteration = false ; sleep Millis /= NUM_ ; } logger Lock . wait ( sleep Millis ) ; PRHA Redundancy Provider rp = region . get Redundancy Provider ( ) ; if ( rp != null && rp . is Persistent Recovery Complete ( ) ) { break ; } if ( missing Children . is Empty ( ) ) { break ; } log Missing Regions ( region ) ; } } }
@ Override protected void before ( ) throws Throwable { previous Threads = Thread . get All Stack Traces ( ) ; }
protected void create Children Widgets ( Source Printer out , Widget Creator Context context ) { JSON Array children = ensure Children ( context . get Widget Element ( ) , true , context . get Widget Id ( ) ) ; if ( children != null ) { for ( int i = NUM_ ; i < children . length ( ) ; i ++ ) { JSON Object child = children . opt JSON Object ( i ) ; if ( is Widget ( child ) ) { String child Widget = create Child Widget ( out , child , context ) ; boolean child Partial Support = has Child Partial Support ( child ) ; if ( child Partial Support ) { out . println ( STR_ + get Child Widget Class Name ( child ) + STR_ ) ; } out . println ( context . get Widget ( ) + STR_ + child Widget + STR_ + Escape Utils . quote ( View Factory Utils . get Enclosing Panel Prefix ( ) ) + STR_ + get View Variable ( ) + STR_ + Escape Utils . quote ( child . opt String ( STR_ ) ) + STR_ ) ; if ( child Partial Support ) { out . println ( STR_ ) ; } } } } }
public boolean generate ( Projection proj ) { if ( ! update Image For Projection ( proj ) ) { if ( get Need To Reposition ( ) ) { position ( proj ) ; set Shape ( ) ; } else { set Shape ( ) ; set Need To Regenerate ( false ) ; return true ; } } set Shape ( null ) ; if ( ! position ( proj ) ) { if ( DEBUG ) { logger . fine ( STR_ ) ; } return false ; } if ( color Model != COLORMODEL IMAGEICON ) { if ( bitmap == null || get Need To Regenerate ( ) ) { if ( DEBUG ) { logger . fine ( STR_ ) ; } super . generate ( proj ) ; set Image ( bitmap ) ; pixels = null ; bits = null ; } } scale To ( proj ) ; if ( bitmap != null ) { if ( corners == null ) { General Path projected Shape = create Box Shape ( point 1 . x , point 1 . y , point 2 . x - point 1 . x , point 2 . y - point 1 . y ) ; int w = bitmap . get Width ( this ) ; int h = bitmap . get Height ( this ) ; double anchor X = point 1 . x + w / NUM_ ; double anchor Y = point 1 . y + h / NUM_ ; set Shape ( adjust Shape For Rotation ( projected Shape , anchor X , anchor Y ) ) ; } else { int num Rects = corners . size ( ) ; General Path projected Shape = null ; for ( int i = NUM_ ; i < num Rects ; i += NUM_ ) { General Path gp = create Shape ( corners . get ( i ) , corners . get ( i + NUM_ ) , true ) ; projected Shape = append Shape Edge ( projected Shape , gp , false ) ; } if ( projected Shape != null ) { Rectangle rect = projected Shape . get Bounds ( ) ; double anchor X = rect . get X ( ) + rect . get Width ( ) / NUM_ ; double anchor Y = rect . get Y ( ) + rect . get Height ( ) / NUM_ ; projected Shape = adjust Shape For Rotation ( projected Shape , anchor X , anchor Y ) ; } set Shape ( projected Shape ) ; } set Label Location ( get Shape ( ) , proj ) ; set Need To Regenerate ( false ) ; } else { has Label = false ; } return true ; }
private void save Nested Variables ( ) { if ( nested Vars != null ) { Iterator < String > iter = nested Vars . iterator ( ) ; while ( iter . has Next ( ) ) { String var Name = iter . next ( ) ; var Name = find Alias ( var Name ) ; Object obj = invoking Jsp Ctxt . get Attribute ( var Name ) ; if ( obj != null ) { original Nested Vars . put ( var Name , obj ) ; } } } }
private String rate Labels 2 Relative Values ( String rate Attribute ) { if ( rate Attribute . equals ( STR_ ) ) { return STR_ ; } else if ( rate Attribute . equals ( STR_ ) ) { return STR_ ; } else if ( rate Attribute . equals ( STR_ ) ) { return STR_ ; } else if ( rate Attribute . equals ( STR_ ) ) { return STR_ ; } else if ( rate Attribute . equals ( STR_ ) ) { return STR_ ; } return STR_ ; }
public void remove From Bucket ( Basic Block block ) { bucket . remove ( block ) ; }
@ Before Class public static void init JFX ( ) { if ( t == null ) { t = new Thread ( null ) ; t . set Daemon ( true ) ; t . start ( ) ; } }
protected void sprint ( boolean boolean Field ) { sprint ( String . value Of ( boolean Field ) ) ; }
public static void clear Image Cache For Media Entity ( Media Entity entity ) { List < Media File > media Files = new Array List < > ( entity . get Media Files ( ) ) ; for ( Media File media File : media Files ) { if ( media File . is Graphic ( ) ) { Path file = Image Cache . get Cached File ( media File . get File As Path ( ) ) ; if ( Files . exists ( file ) ) { Utils . delete File Safely ( file ) ; } } } }
public void mark Key For Preload ( int idx ) { if ( preload Keys == null ) preload Keys = new Bit Set ( ) ; preload Keys . set ( idx , true ) ; }
public static void add Logging Behavior ( Logging Behavior behavior ) { synchronized ( logging Behaviors ) { logging Behaviors . add ( behavior ) ; update Graph Debug Behavior ( ) ; } }
@ Override public void after Authorize Success ( O Auth 2 Request o 2 request , Request request , Response response ) { Series < Cookie Setting > cookies Set In This Response = response . get Cookie Settings ( ) ; Cookie Setting login Hint Cookie Setting = cookies Set In This Response . get First ( LOGIN HINT COOKIE ) ; if ( login Hint Cookie Setting != null && login Hint Cookie Setting . get Max Age ( ) != NUM_ ) { cookies Set In This Response . remove First ( LOGIN HINT COOKIE ) ; } remove Cookie ( request , response ) ; }
static Legacy GWT Host Page Selection Tree Item [ ] build Tree ( Map < String , Set < String > > modules Host Pages ) { List < Legacy GWT Host Page Selection Tree Item > tree Items = new Array List < Legacy GWT Host Page Selection Tree Item > ( ) ; for ( String module Name : modules Host Pages . key Set ( ) ) { Legacy GWT Host Page Selection Tree Item module Item = new Legacy GWT Host Page Selection Tree Item ( Path . from Portable String ( module Name . replace ( STR_ , STR_ ) ) ) ; tree Items . add ( module Item ) ; for ( String host Page : modules Host Pages . get ( module Name ) ) { new Legacy GWT Host Page Selection Tree Item ( Path . from Portable String ( host Page ) , module Item ) ; } } return tree Items . to Array ( new Legacy GWT Host Page Selection Tree Item [ NUM_ ] ) ; }
public Alphabetic Index ( Locale locale ) { peer = create ( locale . to String ( ) ) ; }
private void extract Row Key And Data ( String line , Default Category Dataset dataset , List column Keys ) { Comparable row Key = null ; int field Index = NUM_ ; int start = NUM_ ; for ( int i = NUM_ ; i < line . length ( ) ; i ++ ) { if ( line . char At ( i ) == this . field Delimiter ) { if ( field Index == NUM_ ) { String key = line . substring ( start , i ) ; row Key = remove String Delimiters ( key ) ; } else { Double value = Double . value Of ( remove String Delimiters ( line . substring ( start , i ) ) ) ; dataset . add Value ( value , row Key , ( Comparable ) column Keys . get ( field Index - NUM_ ) ) ; } start = i + NUM_ ; field Index ++ ; } } Double value = Double . value Of ( remove String Delimiters ( line . substring ( start , line . length ( ) ) ) ) ; dataset . add Value ( value , row Key , ( Comparable ) column Keys . get ( field Index - NUM_ ) ) ; }
public static Sam Reader make Sam Reader ( Input Stream stream ) throws IO Exception { return make Sam Reader ( stream , null ) ; }
private void update IM ( Intersection Matrix im ) { for ( Iterator ei = isolated Edges . iterator ( ) ; ei . has Next ( ) ; ) { Edge e = ( Edge ) ei . next ( ) ; e . update IM ( im ) ; } for ( Iterator ni = nodes . iterator ( ) ; ni . has Next ( ) ; ) { Relate Node node = ( Relate Node ) ni . next ( ) ; node . update IM ( im ) ; node . update IM From Edges ( im ) ; } }
static synchronized Jmri Configuration Provider find Provider ( Profile project ) { if ( providers . get ( project ) == null ) { providers . put ( project , new Jmri Configuration Provider ( project ) ) ; } return providers . get ( project ) ; }
public static Stack Trace Element [ ] approx Source Stack Trace Element ( Frame State frame State ) { Array List < Stack Trace Element > elements = new Array List < > ( ) ; Frame State state = frame State ; while ( state != null ) { Bytecode code = state . get Code ( ) ; if ( code != null ) { elements . add ( code . as Stack Trace Element ( state . bci - NUM_ ) ) ; } state = state . outer Frame State ( ) ; } return elements . to Array ( new Stack Trace Element [ NUM_ ] ) ; }
public void add Pass Through Condition ( Pass Through Or Generate Rule Condition condition ) { pass Through Conditions . add ( condition ) ; }
J Menu create View Menu ( ) { J Menu view Menu = new J Menu ( STR_ ) ; J Menu toolbar Menu = new J Menu ( STR_ ) ; toolbar Menu . add ( action Manager . get Show Main Tool Bar Menu Item ( ) ) ; toolbar Menu . add ( action Manager . get Show Run Tool Bar Menu Item ( ) ) ; toolbar Menu . add ( action Manager . get Show Edit Tool Bar Menu Item ( ) ) ; view Menu . add ( toolbar Menu ) ; view Menu . add Separator ( ) ; view Menu . add ( action Manager . get Show Priorities Action ( ) ) ; view Menu . add ( action Manager . get Show Weights Action ( ) ) ; return view Menu ; }
public void create Database Entities For Storage Unit Notification Registration Testing ( String namespace , List < String > notification Event Types , String business Object Definition Namespace , String business Object Definition Name , List < String > file Types , List < String > storage Names , List < String > storage Unit Statuses , List < Job Action > job Actions ) { Namespace Entity namespace Entity = namespace Dao . get Namespace By Cd ( namespace ) ; if ( namespace Entity == null ) { namespace Dao Test Helper . create Namespace Entity ( namespace ) ; } if ( ! Collection Utils . is Empty ( notification Event Types ) ) { for ( String notification Event Type : notification Event Types ) { Notification Event Type Entity notification Event Type Entity = notification Event Type Dao . get Notification Event Type By Code ( notification Event Type ) ; if ( notification Event Type Entity == null ) { notification Registration Dao Test Helper . create Notification Event Type Entity ( notification Event Type ) ; } } } Business Object Definition Entity business Object Definition Entity = business Object Definition Dao . get Business Object Definition By Key ( new Business Object Definition Key ( business Object Definition Namespace , business Object Definition Name ) ) ; if ( business Object Definition Entity == null ) { business Object Definition Dao Test Helper . create Business Object Definition Entity ( business Object Definition Namespace , business Object Definition Name , Abstract Service Test . DATA PROVIDER NAME , Abstract Service Test . BDEF DESCRIPTION ) ; } if ( ! Collection Utils . is Empty ( file Types ) ) { for ( String business Object Format File Type : file Types ) { file Type Dao Test Helper . create File Type Entity ( business Object Format File Type ) ; } } if ( ! Collection Utils . is Empty ( storage Names ) ) { for ( String storage Name : storage Names ) { storage Dao Test Helper . create Storage Entity ( storage Name , Storage Platform Entity . S 3 ) ; } } if ( ! Collection Utils . is Empty ( storage Unit Statuses ) ) { for ( String storage Unit Status : storage Unit Statuses ) { Storage Unit Status Entity storage Unit Status Entity = storage Unit Status Dao . get Storage Unit Status By Code ( storage Unit Status ) ; if ( storage Unit Status Entity == null ) { storage Unit Status Dao Test Helper . create Storage Unit Status Entity ( storage Unit Status ) ; } } } if ( ! Collection Utils . is Empty ( job Actions ) ) { for ( Job Action job Action : job Actions ) { job Definition Dao Test Helper . create Job Definition Entity ( job Action . get Namespace ( ) , job Action . get Job Name ( ) , String . format ( STR_ , job Action . get Namespace ( ) , job Action . get Job Name ( ) ) , String . format ( STR_ , job Action . get Namespace ( ) , job Action . get Job Name ( ) , Abstract Service Test . ACTIVITI ID ) ) ; } } }
private void write Object ( java . io . Object Output Stream s ) throws IO Exception { if ( actions == null ) get Actions ( ) ; s . default Write Object ( ) ; }
private static Integer compute Legacy Id From Camera 2 Id ( @ Nonnull String camera 2 Id ) { try { return Integer . parse Int ( camera 2 Id ) ; } catch ( Number Format Exception ignored ) { } return null ; }
private int decode Code Table Indexes ( ) { if ( ctx . used Quant Units == NUM_ ) { return NUM_ ; } ctx . use Full Table = br . read Bool ( ) ; for ( int ch Num = NUM_ ; ch Num < num Channels ; ch Num ++ ) { Arrays . fill ( ctx . channels [ ch Num ] . qu Tab Idx , NUM_ ) ; int ret = decode Channel Code Tab ( ch Num ) ; if ( ret < NUM_ ) { return ret ; } } return NUM_ ; }
void ensure Own Term Bytes ( ) { NR Cell cell 0 = cells By Level [ NUM_ ] ; if ( cell 0 . term Buf == null ) return ; System . arraycopy ( term . bytes , term . offset , cell 0 . term Buf , NUM_ , term . length ) ; term . bytes = cell 0 . term Buf ; term . offset = NUM_ ; cell 0 . term Buf = null ; }
public static void main ( String [ ] args ) { Log . print Line ( STR_ ) ; try { int num user = NUM_ ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = false ; Cloud Sim . init ( num user , calendar , trace flag ) ; @ Suppress Warnings ( STR_ ) Datacenter datacenter 0 = create Datacenter ( STR_ ) ; Datacenter Broker broker = create Broker ( ) ; int broker Id = broker . get Id ( ) ; vmlist = new Array List < Vm > ( ) ; int vmid = NUM_ ; int mips = NUM_ ; long size = NUM_ ; int ram = NUM_ ; long bw = NUM_ ; int pes Number = NUM_ ; String vmm = STR_ ; Vm vm = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; Vm vm 1 = new Vm ( NUM_ , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; Vm vm 2 = new Vm ( NUM_ , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmlist . add ( vm ) ; vmlist . add ( vm 1 ) ; vmlist . add ( vm 2 ) ; broker . submit Vm List ( vmlist ) ; cloudlet List = new Array List < Cloudlet > ( ) ; int id = NUM_ ; long length = NUM_ ; long file Size = NUM_ ; long output Size = NUM_ ; Utilization Model utilization Model = new Utilization Model Full ( ) ; Cloudlet cloudlet = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet . set User Id ( broker Id ) ; cloudlet . set Vm Id ( vmid ) ; Cloudlet cloudlet 1 = new Cloudlet ( NUM_ , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 1 . set User Id ( broker Id ) ; cloudlet 1 . set Vm Id ( NUM_ ) ; Cloudlet cloudlet 2 = new Cloudlet ( NUM_ , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 2 . set User Id ( broker Id ) ; cloudlet 2 . set Vm Id ( NUM_ ) ; cloudlet List . add ( cloudlet ) ; cloudlet List . add ( cloudlet 1 ) ; cloudlet List . add ( cloudlet 2 ) ; broker . submit Cloudlet List ( cloudlet List ) ; Cloud Sim . start Simulation ( ) ; Cloud Sim . stop Simulation ( ) ; List < Cloudlet > new List = broker . get Cloudlet Received List ( ) ; print Cloudlet List ( new List ) ; Log . print Line ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STR_ ) ; } }
public static synchronized Type Reference find Or Create Internal ( Class Loader cl , Atom tn ) { Type Reference key = new Type Reference ( cl , tn , next Id ) ; Type Reference val = dictionary . get ( key ) ; if ( val == null ) { val = key ; next Id ++ ; int column = val . id > > LOG ROW SIZE ; if ( column == types . length ) { Type Reference [ ] [ ] tmp = new Type Reference [ column + NUM_ ] [ ] ; for ( int i = NUM_ ; i < column ; i ++ ) { tmp [ i ] = types [ i ] ; } types = tmp ; types [ column ] = new Type Reference [ NUM_ << LOG ROW SIZE ] ; } types [ column ] [ val . id & ROW MASK ] = val ; dictionary . add ( val ) ; } return val ; }
public T new Object ( URI uri , Map < String , String > property Overrides , P param ) throws Exception { return internal New Object ( uri , parse Query ( uri . get Query ( ) , property Overrides ) , param ) ; }
private static char unicode To Lower Case ( final char c ) { if ( c < NUM_ ) return c >= STR_ && c <= STR_ ? ( char ) ( c + NUM_ ) : c ; return Character . to Lower Case ( Character . to Upper Case ( c ) ) ; }
private void start Replication Service ( Tungsten Properties repl Props ) throws Replicator Exception { String service Name = repl Props . get String ( Replicator Conf . SERVICE NAME ) ; String service Type = repl Props . get String ( Replicator Conf . SERVICE TYPE ) ; boolean is Detached = repl Props . get Boolean ( Replicator Conf . DETACHED ) ; Open Replicator Manager M Bean orm = null ; try { if ( is Detached ) { throw new Replicator Exception ( STR_ ) ; } else { orm = create Internal Service ( service Name ) ; } replicators . put ( service Name , orm ) ; orm . start ( repl Props . get Boolean ( Replicator Conf . FORCE OFFLINE ) ) ; int listen Port = orm . get Master Listen Port ( ) ; if ( listen Port > master Listen Port Max ) master Listen Port Max = listen Port ; logger . info ( String . format ( STR_ , ( is Detached ? STR_ : STR_ ) , service Type , service Name ) ) ; } catch ( Exception e ) { logger . error ( String . format ( STR_ , service Name ) , e ) ; } }
public Command show Packed ( String position , boolean modal ) { return show Packed Impl ( position , modal , false ) ; }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STR_ + start Id ) ; if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA FILE ) ) { Log OC . e ( TAG , STR_ ) ; return START NOT STICKY ; } else { final Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; final OC File file = intent . get Parcelable Extra ( EXTRA FILE ) ; Abstract List < String > requested Downloads = new Vector < > ( ) ; try { Download File Operation new Download = new Download File Operation ( account , file ) ; new Download . add Datatransfer Progress Listener ( this ) ; new Download . add Datatransfer Progress Listener ( ( File Downloader Binder ) m Binder ) ; Pair < String , String > put Result = m Pending Downloads . put If Absent ( account , file . get Remote Path ( ) , new Download ) ; String download Key = put Result . first ; requested Downloads . add ( download Key ) ; send Broadcast New Download ( new Download , put Result . second ) ; } catch ( Illegal Argument Exception e ) { Log OC . e ( TAG , STR_ + e . get Message ( ) ) ; return START NOT STICKY ; } if ( requested Downloads . size ( ) > NUM_ ) { Message msg = m Service Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = requested Downloads ; m Service Handler . send Message ( msg ) ; } } return START NOT STICKY ; }
public void end Apply Interval ( ) { end Millis = System . current Time Millis ( ) ; total Apply Millis += ( end Millis - interval Start Millis ) ; state = Task State . other ; }
public void execute ( ) { final R Timer timer = new R Timer ( ) ; if ( DATA MODE FILES . equals ( mode ) && args . length > NUM_ ) { do Files Mode ( ) ; } else if ( DATA MODE ARGS . equals ( mode ) && args . length > NUM_ ) { do Args Mode ( ) ; } else if ( DATA MODE WEB . equals ( mode ) && args . length > NUM_ ) { do Web Mode ( ) ; } else if ( DATA MODE STDIN . equals ( mode ) ) { do Stdin Mode ( ) ; } else { usage Short ( ) ; return ; } if ( commit ) commit ( ) ; if ( optimize ) optimize ( ) ; display Timing ( ( long ) timer . get Time ( ) ) ; }
@ Override public int hash Code ( ) { return years + Integer . rotate Left ( months , NUM_ ) + Integer . rotate Left ( days , NUM_ ) ; }
public void fwd Dct In Place Nx N ( double [ ] [ ] coeffs ) { int u = NUM_ ; int v = NUM_ ; double two over sqrtncolsnrows = NUM_ / Math . sqrt ( ( double ) this . N * this . M ) ; for ( u = NUM_ ; u <= this . M - NUM_ ; u ++ ) { fct No Scale ( coeffs [ u ] ) ; } for ( v = NUM_ ; v <= this . N - NUM_ ; v ++ ) { for ( u = NUM_ ; u <= this . M - NUM_ ; u ++ ) { this . nxn Tmp [ u ] = coeffs [ u ] [ v ] ; } fct No Scale ( this . nxn Tmp ) ; for ( u = NUM_ ; u <= this . M - NUM_ ; u ++ ) { coeffs [ u ] [ v ] = this . nxn Tmp [ u ] * two over sqrtncolsnrows ; } } }
public void render Roads ( OM Graphic List gl , boolean force New ) { for ( Enumeration e = roads . elements ( ) ; e . has More Elements ( ) ; ) { Road road = ( Road ) e . next Element ( ) ; if ( road . get First Intersection ( ) == this ) road . render ( gl , force New ) ; } }
public static int calc RWL Count ( int lvl , double factor ) { return ( ( int ) Math . ceil ( factor * Math . log 10 ( NUM_ + rand . next Int ( lvl * lvl ) ) ) ) + rand . next Int ( NUM_ ) ; }
public static Document new Document ( ) throws Parser Configuration Exception { Document Builder Factory dbfac = Document Builder Factory . new Instance ( ) ; Document Builder doc Builder ; doc Builder = dbfac . new Document Builder ( ) ; return doc Builder . new Document ( ) ; }
private void generate Legal Times Tree ( ) { int k 0 = Key Event . KEYCODE 0 ; int k 1 = Key Event . KEYCODE 1 ; int k 2 = Key Event . KEYCODE 2 ; int k 3 = Key Event . KEYCODE 3 ; int k 4 = Key Event . KEYCODE 4 ; int k 5 = Key Event . KEYCODE 5 ; int k 6 = Key Event . KEYCODE 6 ; int k 7 = Key Event . KEYCODE 7 ; int k 8 = Key Event . KEYCODE 8 ; int k 9 = Key Event . KEYCODE 9 ; m Legal Times Tree = new Node ( ) ; if ( ! m Enable Minutes && m Is 24 Hour Mode ) { Node first Digit = new Node ( k 0 , k 1 ) ; m Legal Times Tree . add Child ( first Digit ) ; Node second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; first Digit . add Child ( second Digit ) ; first Digit = new Node ( k 2 ) ; m Legal Times Tree . add Child ( first Digit ) ; second Digit = new Node ( k 0 , k 1 , k 2 , k 3 ) ; first Digit . add Child ( second Digit ) ; return ; } if ( ! m Enable Minutes && ! m Is 24 Hour Mode ) { Node ampm = new Node ( get Am Or Pm Key Code ( AM ) , get Am Or Pm Key Code ( PM ) ) ; Node first Digit = new Node ( k 1 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( ampm ) ; Node second Digit = new Node ( k 0 , k 1 , k 2 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( ampm ) ; first Digit = new Node ( k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( ampm ) ; return ; } if ( m Is 24 Hour Mode ) { Node minute First Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; Node minute Second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; minute First Digit . add Child ( minute Second Digit ) ; if ( m Enable Seconds ) { Node seconds First Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; Node seconds Second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; seconds First Digit . add Child ( seconds Second Digit ) ; minute Second Digit . add Child ( seconds First Digit ) ; } Node first Digit = new Node ( k 0 , k 1 ) ; m Legal Times Tree . add Child ( first Digit ) ; Node second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; Node third Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; second Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; first Digit = new Node ( k 2 ) ; m Legal Times Tree . add Child ( first Digit ) ; second Digit = new Node ( k 0 , k 1 , k 2 , k 3 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; second Digit = new Node ( k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute Second Digit ) ; first Digit = new Node ( k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( minute First Digit ) ; } else { Node ampm = new Node ( get Am Or Pm Key Code ( AM ) , get Am Or Pm Key Code ( PM ) ) ; Node seconds First Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; Node seconds Second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; seconds Second Digit . add Child ( ampm ) ; seconds First Digit . add Child ( seconds Second Digit ) ; Node first Digit = new Node ( k 1 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( ampm ) ; Node second Digit = new Node ( k 0 , k 1 , k 2 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( ampm ) ; Node third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; Node fourth Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; third Digit . add Child ( fourth Digit ) ; fourth Digit . add Child ( ampm ) ; if ( m Enable Seconds ) { fourth Digit . add Child ( seconds First Digit ) ; } third Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; if ( m Enable Seconds ) { third Digit . add Child ( seconds First Digit ) ; } second Digit = new Node ( k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; if ( m Enable Seconds ) { third Digit . add Child ( seconds First Digit ) ; } first Digit = new Node ( k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( ampm ) ; second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; if ( m Enable Seconds ) { third Digit . add Child ( seconds First Digit ) ; } } }
void accept ( int timeout ) throws IO Exception { try { start Threads ( ) ; Pseudo Tcp State state = pseudo Tcp . get State ( ) ; if ( state == Pseudo Tcp State . TCP CLOSED ) { throw new IO Exception ( STR_ ) ; } if ( pseudo Tcp . get State ( ) != Pseudo Tcp State . TCP ESTABLISHED ) { synchronized ( state notify ) { state notify . wait ( timeout ) ; } } if ( pseudo Tcp . get State ( ) != Pseudo Tcp State . TCP ESTABLISHED ) { throw new IO Exception ( STR_ ) ; } } catch ( Interrupted Exception ex ) { IO Exception e = new IO Exception ( STR_ ) ; pseudo Tcp . closedown ( e ) ; throw e ; } }
private static String parse Username ( String authorization Header ) { String decoded Authorization Header = decode Header ( authorization Header ) ; int delimiter Index = decoded Authorization Header . index Of ( STR_ ) ; if ( delimiter Index > - NUM_ ) { return decoded Authorization Header . substring ( NUM_ , delimiter Index ) ; } else { return decoded Authorization Header ; } }
private String print X Format ( final int x ) { String sx = null ; if ( x == Integer . MIN VALUE ) { sx = STR_ ; } else if ( x < NUM_ ) { final String t = Integer . to String ( ( ~ ( - x - NUM_ ) ) ^ Integer . MIN VALUE , NUM_ ) ; switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : switch ( t . char At ( NUM_ ) ) { case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; } break ; } } else { sx = Integer . to String ( x , NUM_ ) ; } return print X Format ( sx ) ; }
public String print List ( My Idx List points ) { if ( points == null || points . length ( ) == NUM_ ) { return STR_ ; } String Buffer bf = new String Buffer ( ) ; try { List Node temp ; for ( int i = NUM_ ; i < points . size ( ) ; i ++ ) { temp = points . get ( i ) ; if ( i == NUM_ ) { bf . append ( STR_ + temp . idx ) ; } else { bf . append ( STR_ + temp . idx ) ; } } } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } return bf . to String ( ) ; }
private Node add Waiter ( Node mode ) { Node node = new Node ( Thread . current Thread ( ) , mode ) ; Node pred = tail ; if ( pred != null ) { node . prev = pred ; if ( compare And Set Tail ( pred , node ) ) { pred . next = node ; return node ; } } enq ( node ) ; return node ; }
public void close ( ) { close Resources ( ) ; valid = false ; LOGGER . info ( STR_ + file . to Absolute Path ( ) ) ; }
J Menu create Insert Menu ( ) { J Menu insert Menu = new J Menu ( STR_ ) ; insert Menu . add ( action Manager . get New Neuron Action ( ) ) ; insert Menu . add ( action Manager . get New Activity Generator Action ( ) ) ; insert Menu . add Separator ( ) ; insert Menu . add ( new Add Neurons Action ( this ) ) ; insert Menu . add Separator ( ) ; insert Menu . add ( action Manager . get New Group Menu ( ) ) ; insert Menu . add ( action Manager . get New Network Menu ( ) ) ; insert Menu . add Separator ( ) ; insert Menu . add ( action Manager . get Test Input Action ( ) ) ; insert Menu . add ( action Manager . get Show Weight Matrix Action ( ) ) ; return insert Menu ; }
public void toggle ( Console Renderer renderer , String ... contexts ) { synchronized ( LOCK ) { stack . add ( new Stack Entry ( renderer , contexts ) ) ; LOCK . notify ( ) ; } }
public synchronized Future < ? > add Indexed Column ( Column Definition cdef ) { if ( indexes By Column . contains Key ( cdef . name . bytes ) ) return null ; assert cdef . get Index Type ( ) != null ; Secondary Index index = Secondary Index . create Instance ( base Cfs , cdef ) ; if ( index instanceof Per Row Secondary Index ) { Secondary Index current Index = row Level Index Map . get ( index . get Class ( ) ) ; if ( current Index == null ) { row Level Index Map . put ( index . get Class ( ) , index ) ; index . init ( ) ; } else { index = current Index ; index . add Column Def ( cdef ) ; logger . info ( STR_ , cdef ) ; } } else { if ( cdef . get Index Type ( ) == Index Type . CUSTOM && index instanceof Abstract Simple Per Column Secondary Index ) throw new Runtime Exception ( STR_ ) ; index . init ( ) ; } indexes By Column . put ( cdef . name . bytes , index ) ; indexes By Name . put ( index . get Index Name ( ) , index ) ; return index . build Index Async ( ) ; }
private static void unsafe Binary Scalar ( Matrix Block m 1 , Matrix Block ret , Scalar Operator op ) throws DML Runtime Exception { if ( m 1 . is Empty Block ( false ) ) { double val = op . execute Scalar ( NUM_ ) ; if ( val != NUM_ ) ret . reset ( ret . rlen , ret . clen , val ) ; return ; } if ( ret . sparse ) throw new DML Runtime Exception ( STR_ ) ; if ( m 1 . sparse ) { ret . allocate Dense Block ( ) ; Sparse Block a = m 1 . sparse Block ; double [ ] c = ret . dense Block ; int m = m 1 . rlen ; int n = m 1 . clen ; double cval 0 = op . execute Scalar ( NUM_ ) ; Arrays . fill ( c , cval 0 ) ; int nnz = m * n ; for ( int i = NUM_ , cix = NUM_ ; i < m ; i ++ , cix += n ) { if ( ! a . is Empty ( i ) ) { int apos = a . pos ( i ) ; int alen = a . size ( i ) ; int [ ] aix = a . indexes ( i ) ; double [ ] avals = a . values ( i ) ; for ( int j = apos ; j < apos + alen ; j ++ ) { double val = op . execute Scalar ( avals [ j ] ) ; c [ cix + aix [ j ] ] = val ; nnz -= ( val == NUM_ ) ? NUM_ : NUM_ ; } } } ret . non Zeros = nnz ; } else { dense Binary Scalar ( m 1 , ret , op ) ; } }
private void update Tab Context ( int index , boolean selected , boolean is Mouse Down , boolean is Mouse Over , boolean has Focus ) { int state = NUM_ ; if ( ! tab Pane . is Enabled ( ) || ! tab Pane . is Enabled At ( index ) ) { state |= Synth Constants . DISABLED ; if ( selected ) { state |= Synth Constants . SELECTED ; } } else if ( selected ) { state |= ( Synth Constants . ENABLED | Synth Constants . SELECTED ) ; if ( is Mouse Over && UI Manager . get Boolean ( STR_ ) ) { state |= Synth Constants . MOUSE OVER ; } } else if ( is Mouse Over ) { state |= ( Synth Constants . ENABLED | Synth Constants . MOUSE OVER ) ; } else { state = Sea Glass Look And Feel . get Component State ( tab Pane ) ; state &= ~ Synth Constants . FOCUSED ; } if ( has Focus && tab Pane . has Focus ( ) ) { state |= Synth Constants . FOCUSED ; } if ( is Mouse Down ) { state |= Synth Constants . PRESSED ; } tab Context . set Component State ( state ) ; }
public static Object [ ] ordinal Array ( Iterator tuples , String field ) { return Data Lib . ordinal Array ( tuples , field , Default Literal Comparator . get Instance ( ) ) ; }
public T invalidate ( String url ) { File file = get Cached File ( url ) ; if ( file != null ) file . delete ( ) ; return self ( ) ; }
private Managed System Info lookup Managed System Info ( I Source S ) throws Ade Exception { Managed System Info M = null ; final String MANAGED QUERY = String . format ( STR_ , S . get Source Internal Id ( ) ) ; Result Set R = null ; String os Name ; int gmt Offset ; logger . trace ( String . format ( STR_ , S . get Source Id ( ) ) ) ; try { R = execute Scroll Insensitive Query ( MANAGED QUERY ) ; if ( R == null ) { final String msg = String . format ( STR_ , S . get Source Id ( ) ) ; logger . error ( msg ) ; throw new Ade Internal Exception ( msg ) ; } if ( Ext Data Store Utils . nonempty Query Result ( R ) ) { try { R . first ( ) ; gmt Offset = R . get Int ( STR_ ) ; os Name = R . get String ( STR_ ) ; M = new Managed System Info ( gmt Offset , os Name ) ; } catch ( Throwable t ) { final String msg = String . format ( STR_ , S . get Source Id ( ) ) ; logger . error ( msg ) ; throw new Ade Internal Exception ( msg , t ) ; } } } catch ( Ade Exception e ) { throw e ; } catch ( Throwable t ) { final String msg = String . format ( STR_ , S . get Source Id ( ) , t . get Message ( ) ) ; logger . error ( msg ) ; throw new Ade Internal Exception ( msg , t ) ; } finally { if ( R != null ) { try { R . close ( ) ; } catch ( SQL Exception ex ) { logger . error ( STR_ , ex ) ; } } } logger . trace ( String . format ( STR_ , S . get Source Id ( ) ) ) ; return M ; }
protected Text do Create Filter Text ( Composite parent ) { if ( use Native Search Field ( parent ) ) { return new Text ( parent , SWT . SINGLE | SWT . BORDER | SWT . SEARCH | SWT . ICON CANCEL ) ; } return new Text ( parent , SWT . SINGLE ) ; }
public static Hashtable copy Hash Table ( Hashtable params Map ) { Hashtable new Table = new Hashtable ( ) ; Enumeration keys = params Map . keys ( ) ; while ( keys . has More Elements ( ) ) { Object key = keys . next Element ( ) ; new Table . put ( key , params Map . get ( key ) ) ; } return new Table ; }
private void append Type Parameters Labels ( I Type Parameter [ ] type Parameters , long flags , String Builder builder ) throws Java Model Exception { if ( type Parameters . length > NUM_ ) { builder . append ( get LT ( ) ) ; for ( int i = NUM_ ; i < type Parameters . length ; i ++ ) { if ( i > NUM_ ) { builder . append ( Java Element Labels . COMMA STRING ) ; } append Type Parameter With Bounds ( type Parameters [ i ] , flags , builder ) ; } builder . append ( get GT ( ) ) ; } }
public Create Request ( Content Format content Format , int object Id , Collection < Lw M 2 m Resource > resources ) { this ( content Format , object Id , resources . to Array ( new Lw M 2 m Resource [ resources . size ( ) ] ) ) ; }
public static int parse Lower Map ( String s ) throws Number Format Exception { int lower Case = MAP UNDEFINED ; int length = s . length ( ) ; if ( length >= NUM_ && length <= NUM_ ) { lower Case = Integer . parse Int ( s , NUM_ ) ; } else if ( s . length ( ) != NUM_ ) { throw new Number Format Exception ( ) ; } return lower Case ; }
static double zetastatic ( long st , long n , double theta , double initialsum ) { double sum = initialsum ; for ( long i = st ; i < n ; i ++ ) { sum += NUM_ / ( Math . pow ( i + NUM_ , theta ) ) ; } return sum ; }
private static void flip Coordinates ( final Phylo Tree View tree View , final SIDE root Side ) { final Phylo Tree tree = tree View . get Phylo Tree ( ) ; for ( Node v = tree . get First Node ( ) ; v != null ; v = tree . get Next Node ( v ) ) { final Point 2 D loc = tree View . get Location ( v ) ; switch ( root Side ) { case TOP : tree View . set Location ( v , loc . get Y ( ) , loc . get X ( ) ) ; break ; case BOTTOM : tree View . set Location ( v , loc . get Y ( ) , - loc . get X ( ) ) ; break ; case RIGHT : tree View . set Location ( v , - loc . get X ( ) , loc . get Y ( ) ) ; break ; default : case LEFT : break ; } } }
private static void write Minor Statistics String ( Buffered Writer output , SA Zone zone ) throws IO Exception { output . write ( zone . get Name ( ) ) ; output . write ( delimiter ) ; output . write ( String . value Of ( zone . get Minor Activity Count ( ) ) ) ; output . write ( delimiter ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { output . write ( String . value Of ( zone . get Minor Activity Count Detail ( i ) ) ) ; output . write ( delimiter ) ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { output . write ( String . value Of ( zone . get Minor Activity Duration Detail ( i ) ) ) ; output . write ( delimiter ) ; } output . write ( String . value Of ( zone . get Minor Activity Duration Detail ( NUM_ ) ) ) ; output . new Line ( ) ; }
synchronized void attach ( Closeable c ) { if ( parent == null ) { parent = c ; } else if ( other Parents == null ) { other Parents = new Array List < > ( ) ; other Parents . add ( parent ) ; other Parents . add ( c ) ; } else { other Parents . add ( c ) ; } }
public static Commit Version Info build ( Index Commit commit ) { long generation = commit . get Generation ( ) ; long version = NUM_ ; try { final Map < String , String > commit Data = commit . get User Data ( ) ; String commit Time = commit Data . get ( Solr Index Writer . COMMIT TIME MSEC KEY ) ; if ( commit Time != null ) { try { version = Long . parse Long ( commit Time ) ; } catch ( Number Format Exception e ) { LOG . warn ( STR_ + commit Time , e ) ; } } } catch ( IO Exception e ) { LOG . warn ( STR_ + commit , e ) ; } return new Commit Version Info ( generation , version ) ; }
@ Override public < T > Provider < T > provider ( Injection Point < T > ip ) { Objects . require Non Null ( ip ) ; Provider < T > provider = lookup Provider ( ip ) ; if ( provider != null ) { return provider ; } provider = auto Provider ( ip ) ; if ( provider != null ) { return provider ; } return new Provider Null ( ip . key ( ) , - NUM_ , new Inject Scope Singleton ( ) ) ; }
public VN Xe Command Job modify Share For Snapshot ( String share Id , Nfs Share Modify For Share Param param ) { String Builder url Builder = new String Builder ( URL NFS ) ; url Builder . append ( share Id ) ; url Builder . append ( URL MODIFY ) ; url = url Builder . to String ( ) ; return post Request Async ( param ) ; }
public static double next Up ( double d ) { if ( d == Double . POSITIVE INFINITY ) return d ; else { d += NUM_ ; return Double . long Bits To Double ( Double . double To Raw Long Bits ( d ) + ( ( d >= NUM_ ) ? + NUM_ : - NUM_ ) ) ; } }
public static Map < String , Object > update Payment Application ( Dispatch Context dctx , Map < String , Object > context ) { if ( ! context . contains Key ( STR_ ) ) { context . put ( STR_ , STR_ ) ; } Big Decimal amount Applied = ( Big Decimal ) context . get ( STR_ ) ; if ( amount Applied != null ) { context . put ( STR_ , amount Applied ) ; } else { context . put ( STR_ , ZERO ) ; } return update Payment Application Def Bd ( dctx , context ) ; }
public void clean Result ( ) { cons G . clear ( ) ; pointers . clear ( ) ; allocations . clear ( ) ; constraints . clear ( ) ; func 2 int . clear ( ) ; int 2 func . clear ( ) ; edge Mapping . clear ( ) ; has Transformed = false ; has Executed = false ; System . gc ( ) ; System . gc ( ) ; System . gc ( ) ; System . gc ( ) ; }
public static String encode From File ( String filename ) { String encoded Data = null ; Base 64 . Input Stream bis = null ; try { java . io . File file = new java . io . File ( filename ) ; byte [ ] buffer = new byte [ ( int ) ( file . length ( ) * NUM_ ) ] ; int length = NUM_ ; int num Bytes = NUM_ ; bis = new Base 64 . Input Stream ( new java . io . Buffered Input Stream ( new java . io . File Input Stream ( file ) ) , Base 64 . ENCODE ) ; while ( ( num Bytes = bis . read ( buffer , length , NUM_ ) ) >= NUM_ ) length += num Bytes ; encoded Data = new String ( buffer , NUM_ , length , Base 64 . PREFERRED ENCODING ) ; } catch ( java . io . IO Exception e ) { logger . error ( STR_ + filename , e ) ; } finally { try { bis . close ( ) ; } catch ( Exception e ) { } } return encoded Data ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Stacked XY Bar Renderer ) ) { return false ; } Stacked XY Bar Renderer that = ( Stacked XY Bar Renderer ) obj ; if ( this . render As Percentages != that . render As Percentages ) { return false ; } return super . equals ( obj ) ; }
public void discard Jobs ( String job Family ) { if ( VERBOSE ) Util . verbose ( STR_ + job Family ) ; try { org . eclipse . jdt . internal . core . search . processing . I Job current Job ; synchronized ( this ) { current Job = current Job ( ) ; disable ( ) ; } if ( current Job != null && ( job Family == null || current Job . belongs To ( job Family ) ) ) { current Job . cancel ( ) ; while ( this . processing Thread != null && this . executing ) { try { if ( VERBOSE ) Util . verbose ( STR_ + current Job ) ; Thread . sleep ( NUM_ ) ; } catch ( Interrupted Exception e ) { } } } int loc = - NUM_ ; synchronized ( this ) { for ( int i = this . job Start ; i <= this . job End ; i ++ ) { current Job = this . awaiting Jobs [ i ] ; if ( current Job != null ) { this . awaiting Jobs [ i ] = null ; if ( ! ( job Family == null || current Job . belongs To ( job Family ) ) ) { this . awaiting Jobs [ ++ loc ] = current Job ; } else { if ( VERBOSE ) Util . verbose ( STR_ + current Job ) ; current Job . cancel ( ) ; } } } this . job Start = NUM_ ; this . job End = loc ; } } finally { enable ( ) ; } if ( VERBOSE ) Util . verbose ( STR_ + job Family ) ; }
public void add Map Listener ( Map Listener listener ) { if ( listeners == null ) { listeners = new Array List < Map Listener > ( ) ; } listeners . add ( listener ) ; }
public static boolean is Processing ( ) { return is Processing ; }
public static String check String For Html Strict None ( String value Name , String value , List < String > error Message List ) { if ( Util Validate . is Empty ( value ) ) return value ; try { value = canonicalize ( value , true ) ; } catch ( Intrusion Exception e ) { Debug . log Error ( STR_ + value Name + STR_ + value + STR_ + e . to String ( ) , module ) ; error Message List . add ( STR_ + value Name + STR_ + e . to String ( ) ) ; } if ( value . index Of ( STR_ ) >= NUM_ || value . index Of ( STR_ ) >= NUM_ ) { error Message List . add ( STR_ + value Name + STR_ ) ; } return value ; }
private Find Result find Node ( final String path , final boolean create ) { check Modified ( ) ; final Array List < String > parts = new Array List < > ( Arrays . as List ( path . split ( STR_ ) ) ) ; JSON Object current = json ; for ( final String item : parts . sub List ( NUM_ , parts . size ( ) - NUM_ ) ) { if ( ! current . has ( item ) && create ) { current . put ( item , new JSON Object ( ) ) ; } current = current . get JSON Object ( item ) ; } return new Find Result ( current , parts . get ( parts . size ( ) - NUM_ ) ) ; }
public static void register Mod Wiki ( String mod , I Wiki Provider provider ) { Wiki Hooks . register Mod Wiki ( mod , provider ) ; }
protected void starve By Fitness ( int limit ) { calculate Fitness And Sort Population ( ) ; for ( int i = population . size ( ) - NUM_ ; i >= limit ; i -- ) { population . remove ( i ) ; } }
public static void unregister Space M Bean ( String space Name , String container Name ) { if ( m M Bean Server == null ) return ; try { String full Space Name = J Space Utilities . create Full Space Name ( container Name , space Name ) ; Object Instance obj Inst = m M Beans Repository . remove ( full Space Name ) ; if ( obj Inst != null ) { m M Bean Server . unregister M Bean ( obj Inst . get Object Name ( ) ) ; } obj Inst = m M Beans Repository . remove ( full Space Name + STR_ ) ; if ( obj Inst != null ) { m M Bean Server . unregister M Bean ( obj Inst . get Object Name ( ) ) ; } if ( logger . is Loggable ( Level . CONFIG ) ) { logger . config ( STR_ + container Name + STR_ + space Name + STR_ ) ; } } catch ( Exception ex ) { if ( logger . is Loggable ( Level . WARNING ) ) { logger . log ( Level . WARNING , STR_ + container Name + STR_ + space Name + STR_ , ex ) ; } } }
public Defined Param Type ( String type , Parameter param ) { this ( type ) ; parameter = Optional . of ( param ) ; }
public static Method Tracepoint create ( Class < ? > cls , String method Name , String ... names For Method Parameters ) { Where where = Where . ENTRY ; String tracepoint Name = String . format ( STR_ , cls . get Simple Name ( ) , method Name ) ; Method m = get Method ( cls , method Name , names For Method Parameters . length ) ; Method Tracepoint tracepoint = new Method Tracepoint ( tracepoint Name , where , m ) ; int param Count = NUM_ ; for ( Type param Type : m . get Generic Parameter Types ( ) ) { String export As = names For Method Parameters [ param Count ] ; String literal = String . format ( STR_ , ++ param Count ) ; if ( Type Utils . is Array Type ( param Type ) ) { Type array Of Type = Type Utils . get Array Component Type ( param Type ) ; String array Of = Type Utils . to String ( array Of Type ) ; tracepoint . add Multi Export ( export As , literal , array Of ) ; } else if ( Type Utils . is Assignable ( param Type , Collection . class ) ) { Parameterized Type pt = ( Parameterized Type ) param Type ; Type collection Of Type = pt . get Actual Type Arguments ( ) [ NUM_ ] ; String collection Of = Type Utils . to String ( collection Of Type ) ; tracepoint . add Multi Export ( export As , literal , collection Of ) ; } else { tracepoint . add Export ( export As , literal ) ; } } return tracepoint ; }
public Merge Join Plan ( Plan p 1 , Plan p 2 , String fld Name 1 , String fld Name 2 , Transaction tx ) { this . fld Name 1 = fld Name 1 ; List < String > sortlist 1 = Arrays . as List ( fld Name 1 ) ; this . sp 1 = new Sort Plan ( p 1 , sortlist 1 , tx ) ; this . fld Name 2 = fld Name 2 ; List < String > sortlist 2 = Arrays . as List ( fld Name 2 ) ; this . sp 2 = new Sort Plan ( p 2 , sortlist 2 , tx ) ; schema . add All ( p 1 . schema ( ) ) ; schema . add All ( p 2 . schema ( ) ) ; hist = join Histogram ( p 1 . histogram ( ) , p 2 . histogram ( ) , fld Name 1 , fld Name 2 ) ; }
Node < K , V > find ( int h , Object k ) { Node < K , V > e = this ; if ( k != null ) { do { K ek ; if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } while ( ( e = e . next ) != null ) ; } return null ; }
@ Override public void on Transfer Progress ( long progress Rate , long total Transferred So Far , long total To Transfer , String file Path ) { int percent = ( int ) ( NUM_ * ( ( double ) total Transferred So Far ) / ( ( double ) total To Transfer ) ) ; if ( percent != m Last Percent ) { m Notification Builder . set Progress ( NUM_ , percent , false ) ; String file Name = file Path . substring ( file Path . last Index Of ( File Utils . PATH SEPARATOR ) + NUM_ ) ; String text = String . format ( get String ( R . string . uploader upload in progress content ) , percent , file Name ) ; m Notification Builder . set Content Text ( text ) ; m Notification Manager . notify ( R . string . uploader upload in progress ticker , m Notification Builder . build ( ) ) ; } m Last Percent = percent ; }
public void init Dct Nx M ( int cols , int rows ) throws Illegal Argument Exception { if ( cols <= NUM_ || rows <= NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } int i = NUM_ ; int j = NUM_ ; double cx = Math . sqrt ( NUM_ / cols ) ; double cy = Math . sqrt ( NUM_ / rows ) ; if ( this . nxm Cos Table X != null && this . N != cols ) { this . nxm Cos Table X = null ; } if ( this . nxm Cos Table Y != null && this . M != rows ) { this . nxm Cos Table Y = null ; } if ( this . nxm Cos Table X == null ) { this . nxm Cos Table X = new double [ cols ] [ cols ] ; } if ( this . nxm Cos Table Y == null ) { this . nxm Cos Table Y = new double [ rows ] [ rows ] ; } this . N = cols ; this . M = rows ; for ( i = NUM_ ; i < cols ; i ++ ) { for ( j = NUM_ ; j < cols ; j ++ ) { this . nxm Cos Table X [ i ] [ j ] = cx * Math . cos ( ( Math . PI * ( ( NUM_ * i + NUM_ ) * j ) ) / ( NUM_ * this . N ) ) ; } } for ( i = NUM_ ; i < rows ; i ++ ) { for ( j = NUM_ ; j < rows ; j ++ ) { this . nxm Cos Table Y [ i ] [ j ] = cy * Math . cos ( ( Math . PI * ( ( NUM_ * i + NUM_ ) * j ) ) / ( NUM_ * this . M ) ) ; } } }
private Protection Set create Protection Set ( String cg Name , URI project URI ) throws Exception { Protection Set protection Set = new Protection Set ( ) ; URI protection Set URI = URI Util . create Id ( Protection Set . class ) ; protection Set . set Id ( protection Set URI ) ; protection Set . set Label ( STR_ + cg Name ) ; protection Set . set Protection Id ( STR_ ) ; protection Set . set Protection Status ( STR_ ) ; protection Set . set Project ( project URI ) ; protection Set . set Protection System ( protection System URI ) ; db Client . create Object ( protection Set ) ; return protection Set ; }
private static double [ ] init Bounding Box ( double number Of Rows , double number Of Columns ) { double [ ] box = new double [ NUM_ ] ; box [ NUM_ ] = NUM_ ; box [ NUM_ ] = NUM_ ; box [ NUM_ ] = number Of Columns - NUM_ ; box [ NUM_ ] = number Of Rows - NUM_ ; logger . info ( STR_ + box [ NUM_ ] + STR_ + box [ NUM_ ] + STR_ + box [ NUM_ ] + STR_ + box [ NUM_ ] ) ; return box ; }
public Age File Filter ( Date cutoff Date , boolean accept Older ) { this ( cutoff Date . get Time ( ) , accept Older ) ; }
public static void update Category ( Context context , Category category ) { if ( m Categories != null && m Categories . contains ( category ) ) { final int location = m Categories . index Of ( category ) ; m Categories . remove ( location ) ; m Categories . add ( location , category ) ; } SQ Lite Database writable Database = get Writable Database ( context ) ; Content Values category Values = create Content Values For ( category ) ; writable Database . update ( Category Table . NAME , category Values , Category Table . COLUMN ID + STR_ , new String [ ] { category . get Id ( ) } ) ; final List < Quiz > quizzes = category . get Quizzes ( ) ; update Quizzes ( writable Database , quizzes ) ; }
public boolean is Valid Regular Expression ( final String expression String ) { Check . not Null ( expression String , STR_ ) ; if ( expression String . length ( ) == NUM_ ) { return false ; } try { Pattern . compile ( expression String , compile Flags ) ; return true ; } catch ( final Pattern Syntax Exception e ) { return false ; } }
public static Map < String , Object > create Data Resource And Text ( Dispatch Context dctx , Map < String , ? extends Object > rcontext ) { Map < String , Object > context = Util Misc . make Map Writable ( rcontext ) ; Map < String , Object > result = Fast Map . new Instance ( ) ; Map < String , Object > this Result = create Data Resource Method ( dctx , context ) ; if ( this Result . get ( Model Service . RESPONSE MESSAGE ) != null ) { return Service Util . return Error ( ( String ) this Result . get ( Model Service . ERROR MESSAGE ) ) ; } result . put ( STR_ , this Result . get ( STR_ ) ) ; context . put ( STR_ , this Result . get ( STR_ ) ) ; String data Resource Type Id = ( String ) context . get ( STR_ ) ; if ( data Resource Type Id != null && data Resource Type Id . equals ( STR_ ) ) { this Result = create Electronic Text ( dctx , context ) ; if ( this Result . get ( Model Service . RESPONSE MESSAGE ) != null ) { return Service Util . return Error ( ( String ) this Result . get ( Model Service . ERROR MESSAGE ) ) ; } } return result ; }
public static void remove Cluster From Host ( Db Client db Client , Host host ) { List < Initiator > initiators = Compute System Helper . query Initiators ( db Client , host . get Id ( ) ) ; for ( Initiator initiator : initiators ) { initiator . set Cluster Name ( STR_ ) ; db Client . persist Object ( initiator ) ; } host . set Cluster ( Null Column Value Getter . get Null URI ( ) ) ; db Client . persist Object ( host ) ; }
private boolean range Contains Reserved ( int rop Range Start , int width ) { for ( int i = rop Range Start ; i < ( rop Range Start + width ) ; i ++ ) { if ( reserved Rop Regs . get ( i ) ) { return true ; } } return false ; }
int compile If Static ( Ct Class type , String name , Bytecode code , Javac drv ) throws Cannot Compile Exception { String desc ; int stacksize = NUM_ ; if ( string Params == null ) desc = STR_ ; else { desc = STR_ ; stacksize += compile String Parameter ( code ) ; } String type Desc = Descriptor . of ( type ) ; code . add Invokestatic ( object Type , method Name , desc + type Desc ) ; code . add Putstatic ( Bytecode . THIS , name , type Desc ) ; return stacksize ; }
protected Element parse Comment Or XML Declaration ( Reader is , String end Tag ) throws IO Exception { char end Tag Chars [ ] = end Tag . to Char Array ( ) ; int end Tag Pos = NUM_ ; String Builder text = new String Builder ( ) ; boolean ended = false ; while ( ! ended ) { int in = read ( is ) ; if ( in == - NUM_ ) { break ; } char c = ( char ) in ; if ( c == end Tag Chars [ end Tag Pos ] ) { end Tag Pos ++ ; if ( end Tag Pos == end Tag Chars . length ) { ended = true ; } } else { if ( end Tag Pos != NUM_ ) { if ( c == end Tag Chars [ NUM_ ] && end Tag Pos > NUM_ ) { text . append ( c ) ; continue ; } text . append ( end Tag Chars , NUM_ , end Tag Pos ) ; end Tag Pos = NUM_ ; } text . append ( c ) ; } } String element Name = null ; if ( end Tag . equals ( STR_ ) ) { element Name = STR_ ; } else if ( end Tag . equals ( STR_ ) ) { element Name = STR_ ; } else { if ( event Parser ) { text Element ( text . to String ( ) ) ; return null ; } return create New Text Element ( text . to String ( ) ) ; } if ( event Parser ) { return null ; } Element comment = create New Element ( element Name ) ; comment . set Attribute ( STR_ , text . to String ( ) ) ; comment . is Comment = true ; return comment ; }
protected void draw Polygon ( Polygon polygon , Color fill Color , Paint fill Paint , Color pen Color , boolean shadow ) { if ( fill Color != null || fill Paint != null ) { if ( shadow ) { g . set Color ( mx Constants . SHADOW COLOR ) ; g . translate ( mx Constants . SHADOW OFFSETX , mx Constants . SHADOW OFFSETY ) ; g . fill Polygon ( polygon ) ; g . translate ( - mx Constants . SHADOW OFFSETX , - mx Constants . SHADOW OFFSETY ) ; } if ( fill Paint != null ) { g . set Paint ( fill Paint ) ; } else { g . set Color ( fill Color ) ; } g . fill Polygon ( polygon ) ; } if ( pen Color != null ) { g . set Color ( pen Color ) ; g . draw Polygon ( polygon ) ; } }
private static void load Package Data ( Context context ) { if ( context != null ) { try { Package Manager package Manager = context . get Package Manager ( ) ; Package Info package Info = package Manager . get Package Info ( context . get Package Name ( ) , NUM_ ) ; Constants . APP PACKAGE = package Info . package Name ; Constants . APP VERSION = STR_ + package Info . version Code ; Constants . APP VERSION NAME = package Info . version Name ; int build Number = load Build Number ( context , package Manager ) ; if ( ( build Number != NUM_ ) && ( build Number > package Info . version Code ) ) { Constants . APP VERSION = STR_ + build Number ; } } catch ( Exception e ) { Log . e ( TAG , STR_ ) ; e . print Stack Trace ( ) ; } } }
public Reference ( String class Name , Ref Addr addr ) { this . class Name = class Name ; addrs = new Vector < > ( ) ; addrs . add Element ( addr ) ; }
@ Override public void run ( ) { logger . finest ( STR_ ) ; int count ; try { if ( delay Flag && ( initial Multicast Request Delay Range > NUM_ ) && ( multicast Request Max >= NUM_ ) ) { Thread . sleep ( ( long ) ( Math . random ( ) * initial Multicast Request Delay Range ) ) ; } for ( count = multicast Request Max ; -- count >= NUM_ && ! is Interrupted ( ) ; ) { Datagram Packet [ ] reqs = encode Multicast Request ( new Multicast Request ( multicast Request Host , response Port , groups , get Service I Ds ( ) ) ) ; send Packet By NIC ( sock , reqs ) ; Thread . sleep ( count > NUM_ ? multicast Request Interval : final Multicast Request Interval ) ; } } catch ( Interrupted Exception e ) { } catch ( Interrupted IO Exception e ) { } catch ( Exception e ) { logger . log ( Level . INFO , STR_ + STR_ , e ) ; } finally { synchronized ( requestors ) { requestors . remove ( Thread . current Thread ( ) ) ; if ( respondee Thread != null && requestors . is Empty ( ) ) { respondee Thread . interrupt ( ) ; respondee Thread = null ; } } sock . close ( ) ; logger . finest ( STR_ ) ; } }
private static Collection < Trust Anchor > sort Potential Anchors ( Set < Trust Anchor > anchors ) { if ( anchors . size ( ) <= NUM_ ) { return anchors ; } List < Trust Anchor > sorted Anchors = new Array List < Trust Anchor > ( anchors ) ; Collections . sort ( sorted Anchors , TRUST ANCHOR COMPARATOR ) ; return sorted Anchors ; }
public static Model create Includes Model ( Model model , String graph URI ) { Set < Graph > graphs = new Hash Set < Graph > ( ) ; Graph base Graph = model . get Graph ( ) ; add Includes ( base Graph , graph URI , graphs , new Hash Set < String > ( ) ) ; if ( graphs . size ( ) == NUM_ ) { return model ; } else { Multi Union union = new Multi Union ( graphs . iterator ( ) ) ; union . set Base Graph ( base Graph ) ; return Model Factory . create Model For Graph ( union ) ; } }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STR_ , justification = STR_ ) protected void purge Stream ( @ Nonnull java . io . Input Stream serial Stream ) throws java . io . IO Exception { int count = serial Stream . available ( ) ; log . debug ( STR_ + count + STR_ ) ; while ( count > NUM_ ) { serial Stream . skip ( count ) ; count = serial Stream . available ( ) ; } }
void create Edges ( String [ ] v ) { graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; }
public static long stop ( @ Non Null String key ) { long now = System . current Time Millis ( ) ; Map < String , Long > current Map = map . get ( ) ; Optional < Long > maybe Previous Instant = Optional . with ( current Map . get ( key ) ) ; if ( maybe Previous Instant . is Empty ( ) ) { Log . warn ( Timer . class , STR_ , key ) ; return NUM_ ; } long duration = now - maybe Previous Instant . get ( ) ; current Map . remove ( key ) ; map . set ( current Map ) ; return duration ; }
private void cleanup Any Backup Snapshots ( final Storage System storage , final Volume volume ) throws Exception { log . info ( String . format ( STR_ , volume . get Label ( ) , volume . get Id ( ) ) ) ; CIM Object Path volume Path = cim Path . get Block Object Path ( storage , volume ) ; if ( helper . check Exists ( storage , volume Path , false , false ) == null ) { log . info ( String . format ( STR_ , storage . get Serial Number ( ) , volume . get Label ( ) ) ) ; return ; } Closeable Iterator < CIM Object Path > settings Iterator = null ; try { settings Iterator = helper . get Reference ( storage , volume Path , Smis Constants . CIM SETTINGS DEFINE STATE , null ) ; if ( settings Iterator != null ) { while ( settings Iterator . has Next ( ) ) { CIM Object Path settings Path = settings Iterator . next ( ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM_ ] ; helper . call Modify Settings Define State ( storage , helper . get Delete Settings For Snapshot Input Arguments ( settings Path , true ) , out Args ) ; } } } finally { if ( settings Iterator != null ) { settings Iterator . close ( ) ; } } }
public void send Request ( Slo Request Settings request Settings , Http Servlet Response response ) throws IO Exception { Validate . not Null ( request Settings , STR_ ) ; Validate . not Null ( response , STR_ ) ; Validate . not Null ( get Message Store ( ) , STR_ ) ; Validate . not Null ( get Metadata Settings ( ) , STR_ ) ; String redirect Url = get Request Url ( request Settings ) ; if ( redirect Url != null ) { response . send Redirect ( redirect Url ) ; } else { if ( Saml Utils . is Idp Support SLO ( get Metadata Settings ( ) , request Settings ) ) { logger . error ( STR_ ) ; } else { logger . warn ( String . format ( STR_ , request Settings . get IDP Alias ( ) ) ) ; } } }
public void add Listener ( Failover Tts Listener listener ) { m Listeners . add ( listener ) ; }
public Visor Log File ( File file ) { this ( file . get Absolute Path ( ) , file . length ( ) , file . last Modified ( ) ) ; }
String compute Description ( I Method method ) { String Buffer buf = new String Buffer ( ) ; buf . append ( STR_ ) ; buf . append ( method . get Element Name ( ) ) ; buf . append ( STR_ ) ; boolean first = true ; for ( String param Type : method . get Parameter Types ( ) ) { if ( first ) first = false ; else buf . append ( STR_ ) ; buf . append ( Signature . to String ( param Type ) ) ; } buf . append ( STR_ ) ; return buf . to String ( ) ; }
public final static Version Info [ ] load Version Info ( String [ ] pckgs , Class Loader clsldr ) { if ( pckgs == null ) { throw new Illegal Argument Exception ( STR_ ) ; } Array List vil = new Array List ( pckgs . length ) ; for ( int i = NUM_ ; i < pckgs . length ; i ++ ) { Version Info vi = load Version Info ( pckgs [ i ] , clsldr ) ; if ( vi != null ) vil . add ( vi ) ; } return ( Version Info [ ] ) vil . to Array ( new Version Info [ vil . size ( ) ] ) ; }
private final boolean eq ( Object o 1 , Object o 2 ) { return o 1 == o 2 || ( ( o 1 != null ) && o 1 . equals ( o 2 ) ) ; }
private Array List < Collection Descriptor > call List Collections ( String start Name , Integer limit , int offset ) throws Oracle Exception { Oracle Callable Statement stmt = null ; Result Set rows = null ; String sqltext = STR_ + STR_ + STR_ + STR_ + STR_ ; boolean result Full = false ; Array List < Collection Descriptor > results = new Array List < Collection Descriptor > ( ) ; try { int row Count = NUM_ ; metrics . start Timing ( ) ; stmt = ( Oracle Callable Statement ) conn . prepare Call ( sqltext ) ; if ( start Name == null ) stmt . set Null ( NUM_ , Types . VARCHAR ) ; else stmt . set N String ( NUM_ , start Name ) ; stmt . register Out Parameter ( NUM_ , Oracle Types . CURSOR ) ; stmt . execute ( ) ; rows = stmt . get Cursor ( NUM_ ) ; if ( Oracle Log . is Logging Enabled ( ) ) log . fine ( STR_ ) ; while ( rows . next ( ) ) { String uri Name = rows . get N String ( NUM_ ) ; String json Descriptor = rows . get String ( NUM_ ) ; String create Time = rows . get String ( NUM_ ) ; Collection Descriptor desc = get Descriptor From Caches ( uri Name ) ; if ( desc == null ) { Builder builder = Collection Descriptor . json To Builder ( json Descriptor ) ; desc = builder . build Descriptor ( uri Name ) ; desc = put Descriptor Into Caches ( desc ) ; } if ( ( row Count >= offset ) && ( ! result Full ) ) results . add ( desc ) ; ++ row Count ; if ( limit != null && limit > NUM_ ) { if ( row Count >= ( offset + limit ) ) { if ( row Count > SODA Constants . BATCH FETCH SIZE ) break ; result Full = true ; } } } rows . close ( ) ; rows = null ; stmt . close ( ) ; stmt = null ; metrics . record Call ( ) ; } catch ( SQL Exception e ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( e . to String ( ) ) ; throw SODA Utils . make Exception With SQL Text ( e , sqltext ) ; } finally { for ( String message : SODA Utils . close Cursor ( stmt , rows ) ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( message ) ; } } return ( results ) ; }
private static boolean can Eliminate Lop ( Lop node , Array List < Lop > exec Nodes ) { if ( ! node . is Aligner ( ) ) return false ; int ret = get Child Alignment ( node , exec Nodes , Exec Location . Map And Reduce ) ; if ( ret == CHILD BREAKS ALIGNMENT ) return false ; else if ( ret == CHILD DOES NOT BREAK ALIGNMENT ) return true ; else if ( ret == MRCHILD NOT FOUND ) return false ; else if ( ret == MR CHILD FOUND BREAKS ALIGNMENT ) return false ; else if ( ret == MR CHILD FOUND DOES NOT BREAK ALIGNMENT ) return true ; else throw new Runtime Exception ( STR_ ) ; }
private String create Workflow Step For Resync Native Full Copy ( Workflow workflow , Storage System native System , List < URI > native Full Copy UR Is , String wait For , Workflow . Method rollback Method ) { URI native System URI = native System . get Id ( ) ; Workflow . Method resync Full Copy Method = new Workflow . Method ( RESYNC FC METHOD NAME , native System URI , native Full Copy UR Is , Boolean . FALSE ) ; workflow . create Step ( RESYNC FULL COPY STEP , String . format ( STR_ , native Full Copy UR Is ) , wait For , native System URI , native System . get System Type ( ) , Block Device Controller . class , resync Full Copy Method , rollback Method , null ) ; log . info ( STR_ , native Full Copy UR Is ) ; return RESYNC FULL COPY STEP ; }
private void read Object ( java . io . Object Input Stream s ) throws java . io . IO Exception , Class Not Found Exception { s . default Read Object ( ) ; key = key . clone ( ) ; }
private Object read Object ( Object Input in ) throws IO Exception , Class Not Found Exception { Object obj = in . read Object ( ) ; return NULL OBJECT . equals ( obj ) ? null : obj ; }
private void prefetch Statement Data ( Statement Data data ) throws Replicator Exception { statements ++ ; String sql Query = null ; try { if ( data . get Query ( ) != null ) sql Query = data . get Query ( ) ; else { try { sql Query = new String ( data . get Query As Bytes ( ) , data . get Charset ( ) ) ; } catch ( Unsupported Encoding Exception e ) { sql Query = new String ( data . get Query As Bytes ( ) ) ; } } statement . clear Batch ( ) ; boolean has Transform = false ; boolean fetch Secondary Indexes = false ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ + sql Query ) ; } Sql Operation parsing = ( Sql Operation ) data . get Parsing Metadata ( ) ; if ( parsing . get Operation ( ) == Sql Operation . INSERT ) { Matcher m = insert . matcher ( sql Query ) ; if ( m . matches ( ) ) { if ( m . group ( NUM_ ) != null ) sql Query = m . group ( NUM_ ) ; else sql Query = m . group ( NUM_ ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + sql Query ) ; transformed ++ ; has Transform = true ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + sql Query ) ; } } else if ( parsing . get Operation ( ) == Sql Operation . DELETE ) { Matcher m = delete . matcher ( sql Query ) ; if ( m . matches ( ) ) { sql Query = STR_ + m . group ( NUM_ ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + sql Query ) ; transformed ++ ; has Transform = true ; fetch Secondary Indexes = true ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + sql Query ) ; } } else if ( parsing . get Operation ( ) == Sql Operation . UPDATE ) { Matcher m = update . matcher ( sql Query ) ; if ( m . matches ( ) ) { sql Query = STR_ + m . group ( NUM_ ) + STR_ + m . group ( NUM_ ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + sql Query ) ; transformed ++ ; has Transform = true ; fetch Secondary Indexes = true ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + sql Query ) ; } } else if ( parsing . get Operation ( ) == Sql Operation . SET ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + sql Query ) ; has Transform = true ; } else { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + sql Query ) ; } String schema = data . get Default Schema ( ) ; Long timestamp = data . get Timestamp ( ) ; List < Repl Option > options = data . get Options ( ) ; apply Use Schema ( schema ) ; apply Set Timestamp ( timestamp ) ; apply Session Variables ( options ) ; try { statement . execute Batch ( ) ; } catch ( SQL Warning e ) { String msg = STR_ + data . to String ( ) + STR_ + e . get Message ( ) ; logger . warn ( msg ) ; } catch ( SQL Exception e ) { if ( data . get Error Code ( ) == NUM_ ) { String msg = STR_ + data . to String ( ) ; SQL Exception sql Exception = new SQL Exception ( msg ) ; sql Exception . init Cause ( e ) ; throw sql Exception ; } } finally { statement . clear Batch ( ) ; } Result Set rs = null ; if ( has Transform ) { if ( prefetch Row Limit > NUM_ ) sql Query = prefetch Transformer . add Limit To Query ( sql Query , prefetch Row Limit ) ; try { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + sql Query ) ; rs = statement . execute Query ( sql Query ) ; prefetched Queries ++ ; if ( fetch Secondary Indexes ) { prefetch Indexes For Statement ( data , parsing , rs ) ; } } finally { close Result Set ( rs ) ; } } } catch ( SQL Exception e ) { log Failed Statement SQL ( data . get Query ( ) , e ) ; throw new Applier Exception ( e ) ; } }
public void create Table ( String name , String ... fields ) throws SQL Exception { if ( fields . length == NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( fields . length % NUM_ != NUM_ ) { throw new Illegal Argument Exception ( STR_ + STR_ ) ; } String Builder statement = new String Builder ( ) ; statement . append ( STR_ ) ; statement . append ( quote Case Sensitive ( name ) ) ; statement . append ( STR_ ) ; for ( int i = NUM_ ; i < fields . length ; i += NUM_ ) { if ( i > NUM_ ) { statement . append ( STR_ ) ; } statement . append ( quote Case Sensitive ( fields [ i ] ) ) ; statement . append ( STR_ ) ; statement . append ( fields [ i + NUM_ ] ) ; } statement . append ( STR_ ) ; Statement stmt = conn . create Statement ( ) ; String statement Str = statement . to String ( ) ; log . debug ( STR_ , name , this . name , statement Str ) ; stmt . execute ( statement Str ) ; }
public Path Extractor Impl ( String path And Feature , boolean want Feature ) { this . path And Feature = path And Feature ; if ( INTERPRET PATHS ) { path = path And Feature ; return ; } if ( want Feature ) { int last Dot = path And Feature . last Index Of ( STR_ ) ; if ( last Dot == - NUM_ ) { feature = path And Feature ; path = null ; } else { feature = path And Feature . substring ( last Dot + NUM_ ) ; path = path And Feature . substring ( NUM_ , last Dot ) ; } this . want Feature = want Feature ; } else { this . path = path And Feature ; } if ( ! LAZY COMPILE ) { compiled Path = compile ( path ) ; } }
@ Override public void run ( ) { try { Server Thread Main ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { try { log . debug ( STR_ ) ; server Socket Channel . close ( ) ; selector . close ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } }
public static String class Name To Resource Name ( String cls Name ) { return cls Name . replace All ( STR_ , STR_ ) + STR_ ; }
protected int hash ( Object key ) { int h = key . hash Code ( ) ; h += ~ ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; h += ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; return h ; }
protected void decode Node ( mx Codec dec , Node node , Object obj ) { if ( node != null ) { decode Attributes ( dec , node , obj ) ; decode Children ( dec , node , obj ) ; } }
private Queue < Method Wrapper > form Conversation Queue ( Queue < Method Wrapper > queue , String method Name ) { Method Wrapper method Wrapper = method Name Map . get ( method Name ) ; queue . add ( method Wrapper ) ; if ( String Utils . is Empty ( method Name ) ) { return queue ; } else { return form Conversation Queue ( queue , method Wrapper . get Next ( ) ) ; } }
private static Bitmap create Padded Bitmap ( Bitmap bitmap In , XMP Meta xmp , int intermediate Width ) { try { int cropped Area Width = get Int ( xmp , CROPPED AREA IMAGE WIDTH PIXELS ) ; int cropped Area Height = get Int ( xmp , CROPPED AREA IMAGE HEIGHT PIXELS ) ; int full Pano Width = get Int ( xmp , CROPPED AREA FULL PANO WIDTH PIXELS ) ; int full Pano Height = get Int ( xmp , CROPPED AREA FULL PANO HEIGHT PIXELS ) ; int left = get Int ( xmp , CROPPED AREA LEFT ) ; int top = get Int ( xmp , CROPPED AREA TOP ) ; if ( full Pano Width == NUM_ || full Pano Height == NUM_ ) { return bitmap In ; } Bitmap padded Bitmap = null ; float scale = intermediate Width / ( float ) full Pano Width ; while ( padded Bitmap == null ) { try { padded Bitmap = Bitmap . create Bitmap ( ( int ) ( full Pano Width * scale ) , ( int ) ( full Pano Height * scale ) , Bitmap . Config . ARGB 8888 ) ; } catch ( Out Of Memory Error e ) { System . gc ( ) ; scale /= NUM_ ; } } Canvas padded Canvas = new Canvas ( padded Bitmap ) ; int right = left + cropped Area Width ; int bottom = top + cropped Area Height ; Rect F dest Rect = new Rect F ( left * scale , top * scale , right * scale , bottom * scale ) ; padded Canvas . draw Bitmap ( bitmap In , null , dest Rect , null ) ; return padded Bitmap ; } catch ( XMP Exception ex ) { } return bitmap In ; }
static private String munge ( final String s ) { return s . replace All ( STR_ , STR_ ) ; }
Unicode Version ( String version , Enum Map < Data File Type , URL > data Files ) { this . data Files = data Files ; set Versions ( version , data Files . get ( Data File Type . UNICODE DATA ) ) ; }
@ Override public double [ ] distribution For Instance ( Instance instance ) throws Exception { double [ ] prob Of Class Given Doc = new double [ m num Classes ] ; double [ ] log Doc Given Class = new double [ m num Classes ] ; for ( int c = NUM_ ; c < m num Classes ; c ++ ) { log Doc Given Class [ c ] += Math . log ( m prob Of Class [ c ] ) ; int all Words = NUM_ ; for ( int i = NUM_ ; i < instance . num Values ( ) ; i ++ ) { if ( instance . index ( i ) == instance . class Index ( ) ) { continue ; } double frequencies = instance . value Sparse ( i ) ; all Words += frequencies ; log Doc Given Class [ c ] += frequencies * Math . log ( m prob Of Word Given Class [ c ] [ instance . index ( i ) ] ) ; } log Doc Given Class [ c ] -= all Words * Math . log ( m words Per Class [ c ] ) ; } double max = log Doc Given Class [ Utils . max Index ( log Doc Given Class ) ] ; for ( int i = NUM_ ; i < m num Classes ; i ++ ) { prob Of Class Given Doc [ i ] = Math . exp ( log Doc Given Class [ i ] - max ) ; } Utils . normalize ( prob Of Class Given Doc ) ; return prob Of Class Given Doc ; }
static private String BYTE Max Plus ( ) { long temp Value = Byte . MAX VALUE + NUM_ ; return String . value Of ( temp Value ) ; }
private int add Labels Internal ( GL 10 gl , Paint text Paint , boolean draw To Canvas , Label Data [ ] labels ) { int u = NUM_ ; int v = NUM_ ; int line Height = NUM_ ; for ( Label Data label : labels ) { int ascent = NUM_ ; int descent = NUM_ ; int measured Text Width = NUM_ ; int height = NUM_ ; int width = NUM_ ; int font Size = label . get Font Size ( ) ; do { text Paint . set Color ( NUM_ | label . get Color ( ) ) ; text Paint . set Text Size ( font Size * m Res . get Display Metrics ( ) . density ) ; ascent = ( int ) Math . ceil ( - text Paint . ascent ( ) ) ; descent = ( int ) Math . ceil ( text Paint . descent ( ) ) ; measured Text Width = ( int ) Math . ceil ( text Paint . measure Text ( label . get Text ( ) ) ) ; height = ascent + descent ; width = measured Text Width ; font Size -- ; } while ( font Size > NUM_ && width > m Res . get Display Metrics ( ) . width Pixels ) ; int next U ; if ( u + width > m Strike Width ) { u = NUM_ ; next U = width ; v += line Height ; line Height = NUM_ ; } else { next U = u + width ; } line Height = Math . max ( line Height , height ) ; if ( v + line Height > m Strike Height && draw To Canvas ) { throw new Illegal Argument Exception ( STR_ ) ; } int v Base = v + ascent ; if ( draw To Canvas ) { m Canvas . draw Text ( label . get Text ( ) , u , v Base , text Paint ) ; label . set Texture Data ( width , height , u , v + height , width , - height , m Texel Width , m Texel Height ) ; } u = next U ; } return v + line Height ; }
public static Map < String , Object > update Data Resource And Text ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > this Result = update Data Resource Method ( dctx , context ) ; if ( this Result . get ( Model Service . RESPONSE MESSAGE ) != null ) { return Service Util . return Error ( ( String ) this Result . get ( Model Service . ERROR MESSAGE ) ) ; } String data Resource Type Id = ( String ) context . get ( STR_ ) ; if ( data Resource Type Id != null && data Resource Type Id . equals ( STR_ ) ) { this Result = update Electronic Text ( dctx , context ) ; if ( this Result . get ( Model Service . RESPONSE MESSAGE ) != null ) { return Service Util . return Error ( ( String ) this Result . get ( Model Service . ERROR MESSAGE ) ) ; } } return Service Util . return Success ( ) ; }
public static long long from julian ( String s ) throws SQ Lite . Exception { try { double d = Double . parse Double ( s ) ; return long from julian ( d ) ; } catch ( java . lang . Exception ee ) { throw new SQ Lite . Exception ( STR_ ) ; } }
public Plain Sasl Authenticator ( final Vertx vertx ) { this . vertx = Objects . require Non Null ( vertx ) ; }
synchronized Set < K > key Set ( ) { Hash Set < K > set = new Hash Set < K > ( ) ; for ( Entry < K , V > e = stack . stack Next ; e != stack ; e = e . stack Next ) { set . add ( e . key ) ; } for ( Entry < K , V > e = queue . queue Next ; e != queue ; e = e . queue Next ) { set . add ( e . key ) ; } return set ; }
private String generate Screen On Or Off Utternace ( int feedback Index ) { int resource Id = ( feedback Index == INDEX SCREEN ON ) ? R . string . template screen on : R . string . template screen off ; String template = m Context . get String ( resource Id ) ; int current Ringer Volume = m Audio Manager . get Stream Volume ( Audio Manager . STREAM RING ) ; int max Ringer Volume = m Audio Manager . get Stream Max Volume ( Audio Manager . STREAM RING ) ; int volume Percent = ( NUM_ / max Ringer Volume ) * current Ringer Volume ; int adjustment = volume Percent % NUM_ ; if ( adjustment < NUM_ ) { volume Percent -= adjustment ; } else if ( adjustment > NUM_ ) { volume Percent += ( NUM_ - adjustment ) ; } return String . format ( template , volume Percent ) ; }
protected String generate Other Features Text ( String container Id ) { String Builder output = new String Builder ( ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; return output . to String ( ) ; }
@ Override public void property Change ( java . beans . Property Change Event e ) { log . debug ( STR_ + e . get Property Name ( ) + STR_ + e . get Old Value ( ) + STR_ + e . get New Value ( ) ) ; }
private String hash Key From Url ( String url ) { String key ; try { final Message Digest m Digest = Message Digest . get Instance ( STR_ ) ; m Digest . update ( url . get Bytes ( ) ) ; key = bytes To Hex String ( m Digest . digest ( ) ) ; } catch ( No Such Algorithm Exception ex ) { key = String . value Of ( url . hash Code ( ) ) ; } return key ; }
public String html tooltip ( String short txt , String popup txt ) { String out = STR_ ; if ( jquery ) { out = String . format ( STR_ , popup txt , short txt ) ; } else if ( jquery Mobile ) { String popup = String . format ( STR_ + STR_ + STR_ , popup Id , popup txt ) ; String txt = String . format ( STR_ , popup Id ++ , short txt ) ; out = popup + txt ; } return out ; }
private Map < String , String > check For Errors And Return Response ( Https URL Connection connection ) { try { if ( connection . get Response Code ( ) >= SC MULTIPLE CHOICES ) { String message ; if ( connection . get Error Stream ( ) != null ) { message = read Response ( connection . get Error Stream ( ) ) ; } else { message = STR_ ; } if ( message . contains ( HTML TAG ) ) { message = message . substring ( message . index Of ( BODY OPENING TAG ) + NUM_ , message . index Of ( BODY CLOSING TAG ) ) ; } throw new MC Api Runtime Exception ( message , connection . get Response Code ( ) ) ; } else { Map < String , String > response Map = new Hash Map < String , String > ( ) ; response Map . put ( MESSAGE , read Response ( connection . get Input Stream ( ) ) ) ; response Map . put ( HTTP CODE , String . value Of ( connection . get Response Code ( ) ) ) ; return response Map ; } } catch ( IO Exception e ) { throw new MC Api Runtime Exception ( read Response ( connection . get Error Stream ( ) ) ) ; } }
public String print Logic RPU ( ) { String s = String . format ( STR_ , scores . get score ( ) ) ; s += STR_ + String . format ( STR_ , Toxicity . most Toxic Row ( this ) ) ; s += STR_ ; for ( Gate gate : Gates ) { s += print Logic RPU ( gate ) ; } return s ; }
public final Bean Event Type create Bean Type ( String name , Class clazz , boolean is Preconfigured Static , boolean is Preconfigured , boolean is Configured ) { if ( clazz == null ) { throw new Illegal Argument Exception ( STR_ ) ; } Bean Event Type event Type = null ; types Per Java Bean Lock . lock ( ) ; try { event Type = types Per Java Bean . get ( clazz ) ; if ( event Type != null ) { event Type Id Generator . assigned Type ( name , event Type ) ; return event Type ; } Configuration Event Type Legacy legacy Def = class To Legacy Configs . get ( clazz . get Name ( ) ) ; if ( ( legacy Def == null ) && ( default Accessor Style != Configuration Event Type Legacy . Accessor Style . JAVABEAN ) ) { legacy Def = new Configuration Event Type Legacy ( ) ; legacy Def . set Accessor Style ( default Accessor Style ) ; } int type Id = event Type Id Generator . get Type Id ( name ) ; Event Type Metadata metadata = Event Type Metadata . create Bean Type ( name , clazz , is Preconfigured Static , is Preconfigured , is Configured , Event Type Metadata . Type Class . APPLICATION ) ; event Type = new Bean Event Type ( metadata , type Id , clazz , event Adapter Service , legacy Def ) ; types Per Java Bean . put ( clazz , event Type ) ; } catch ( Runtime Exception ex ) { throw ex ; } finally { types Per Java Bean Lock . unlock ( ) ; } return event Type ; }
int find Group Position ( long group Id To Match , int seed Group Position ) { int count = m Expandable List Adapter . get Group Count ( ) ; if ( count == NUM_ ) { return android . widget . Adapter View . INVALID POSITION ; } if ( group Id To Match == android . widget . Adapter View . INVALID ROW ID ) { return android . widget . Adapter View . INVALID POSITION ; } seed Group Position = Math . max ( NUM_ , seed Group Position ) ; seed Group Position = Math . min ( count - NUM_ , seed Group Position ) ; long end Time = System Clock . uptime Millis ( ) + Adapter View . SYNC MAX DURATION MILLIS ; long row Id ; int first = seed Group Position ; int last = seed Group Position ; boolean next = false ; boolean hit First ; boolean hit Last ; Expandable List Adapter adapter = get Adapter ( ) ; if ( adapter == null ) { return android . widget . Adapter View . INVALID POSITION ; } while ( System Clock . uptime Millis ( ) <= end Time ) { row Id = adapter . get Group Id ( seed Group Position ) ; if ( row Id == group Id To Match ) { return seed Group Position ; } hit Last = last == count - NUM_ ; hit First = first == NUM_ ; if ( hit Last && hit First ) { break ; } if ( hit First || ( next && ! hit Last ) ) { last ++ ; seed Group Position = last ; next = false ; } else if ( hit Last || ( ! next && ! hit First ) ) { first -- ; seed Group Position = first ; next = true ; } } return android . widget . Adapter View . INVALID POSITION ; }
public void stop Watching ( ) { watching . set ( false ) ; }
private void problem Edge Prep ( ) { for ( int i = NUM_ ; i < num Tree Roots ; i ++ ) { Abstract BURS Tree Node n = tree Roots [ i ] ; problem Edge Prep ( n , n . dg node ) ; } }
protected void add View Version ( Distributed Region dr , long version ) { view Versions . put ( dr , Long . value Of ( version ) ) ; }
public static String [ ] split String ( final String str , final char split Char ) { final int length = str . length ( ) ; final String Builder bulder = new String Builder ( Math . max ( NUM_ , length ) ) ; int counter = NUM_ ; for ( int i = NUM_ ; i < length ; i ++ ) { if ( str . char At ( i ) == split Char ) { counter ++ ; } } final String [ ] result = new String [ counter ] ; int position = NUM_ ; for ( int i = NUM_ ; i < length ; i ++ ) { final char chr = str . char At ( i ) ; if ( chr == split Char ) { result [ position ++ ] = bulder . to String ( ) ; bulder . set Length ( NUM_ ) ; } else { bulder . append ( chr ) ; } } if ( position < result . length ) { result [ position ] = bulder . to String ( ) ; } return result ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || get Class ( ) != o . get Class ( ) ) { return false ; } final Scalar Reading that = ( Scalar Reading ) o ; if ( m Timestamp Millis != that . m Timestamp Millis ) { return false ; } return Double . compare ( that . m Value , m Value ) == NUM_ ; }
public void delete Existing Results ( ) { Array List < Key > keys = new Array List < Key > ( ) ; List < Entity > results = get Results ( ) ; for ( Entity entity : results ) { keys . add ( entity . get Key ( ) ) ; } service . delete ( keys ) ; }
protected void write Data To File ( Node Holder node Holder ) throws Carbon Data Writer Exception { long offset = write Data To File ( node Holder , file Channel ) ; Blocklet Info Columnar blocklet Info = get Blocklet Info ( node Holder , offset ) ; blocklet Info List . add ( blocklet Info ) ; }
public static double sum Of Mean Differences One Point ( double [ ] vector ) { double mean = sum ( vector ) / vector . length ; double ret = NUM_ ; for ( int i = NUM_ ; i < vector . length ; i ++ ) { double vec 1 Diff = Math . pow ( vector [ i ] - mean , NUM_ ) ; ret += vec 1 Diff ; } return ret ; }
public Prefix File Filter ( String [ ] prefixes , IO Case case Sensitivity ) { if ( prefixes == null ) { throw new Illegal Argument Exception ( STR_ ) ; } this . prefixes = new String [ prefixes . length ] ; System . arraycopy ( prefixes , NUM_ , this . prefixes , NUM_ , prefixes . length ) ; this . case Sensitivity = case Sensitivity == null ? IO Case . SENSITIVE : case Sensitivity ; }
public static void apply Pinch Zoom Image ( Image View m Image View ) { m Image View . set On Touch Listener ( new Pinch Zoom ( ) ) ; }
public boolean ping ( Host Address address , int timeout ) throws Host Exception { notes = STR_ ; Inet Address inet Address = address . get Inet Address ( ) ; try { return inet Address . is Reachable ( timeout ) ; } catch ( IO Exception e ) { throw new Host Exception ( STR_ , e ) ; } }
private void allow Deallocate ( ) { state Updater . lazy Set ( this , STATE MAY DEALLOCATE ) ; }
protected void init ( ) { Date date = calendar . get Time ( ) ; calendar = Calendar . get Instance ( locale ) ; calendar . set Time ( date ) ; draw Day Names ( ) ; draw Days ( ) ; }
private void load Files ( String input Path ) { this . root = input Path ; try { log . info ( STR_ + root ) ; load Stops ( ) ; load Calendar ( ) ; load Calendar Dates ( ) ; load Shapes ( ) ; load Routes ( ) ; load Trips ( ) ; load Stop Times ( ) ; load Frequencies ( ) ; log . info ( STR_ ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public static void main ( String [ ] args ) throws Exception { System . exit ( compile ( args ) ) ; }
private void create The User For Single User Mode ( ) { if ( ! is In Single User Mode ( ) ) { return ; } try { final User user = db Logic . get Or Create User ( single User Name ) ; if ( user == null ) { logger . log ( Level . SEVERE , STR_ ) ; return ; } if ( ! user . get Is Single User ( ) ) { user . set Is Single User ( true ) ; } if ( ! user . get Is Admin ( ) ) { user . set Is Admin ( true ) ; } db Logic . commit ( ) ; } catch ( final Persistence Exception e ) { logger . log ( Level . SEVERE , STR_ , e ) ; } }
public String generate Short Upgrade Report ( SSO Token admin Token , boolean html ) { String delimiter = html ? HTML BR : TXT LF ; String Builder report = new String Builder ( ) ; for ( Upgrade Step upgrade Step : upgrade Steps ) { report . append ( upgrade Step . get Short Report ( delimiter ) ) ; } return report . to String ( ) ; }
private void append Option Group ( final String Buffer buff , final Option Group group ) { if ( ! group . is Required ( ) ) { buff . append ( STR_ ) ; } List opt List = new Array List ( group . get Options ( ) ) ; Collections . sort ( opt List , get Option Comparator ( ) ) ; for ( Iterator i = opt List . iterator ( ) ; i . has Next ( ) ; ) { append Option ( buff , ( Option ) i . next ( ) , true ) ; if ( i . has Next ( ) ) { buff . append ( STR_ ) ; } } if ( ! group . is Required ( ) ) { buff . append ( STR_ ) ; } }
@ Override public Class < ? > find Class ( String class Name ) throws Class Not Found Exception { final boolean DBG = false ; if ( ! VM . running VM ) { return super . find Class ( class Name ) ; } if ( class Name . starts With ( STR_ ) ) { Type Reference type Ref = Type Reference . find Or Create ( this , Atom . find Or Create Ascii Atom ( class Name . replace ( STR_ , STR_ ) ) ) ; RVM Type ans = type Ref . resolve ( ) ; loaded . put ( class Name , ans ) ; return ans . get Class For Type ( ) ; } else { if ( ! VM . fully Booted ) { VM . sys Write ( STR_ ) ; VM . sys Write ( class Name ) ; VM . sys Write ( STR_ ) ; VM . sys Writeln ( STR_ ) ; VM . sys Fail ( STR_ ) ; } try { if ( class Name . starts With ( STR_ ) && class Name . ends With ( STR_ ) ) { class Name = class Name . substring ( NUM_ , class Name . length ( ) - NUM_ ) ; } Input Stream is = get Resource As Stream ( class Name . replace ( STR_ , File . separator Char ) + STR_ ) ; if ( is == null ) throw new Class Not Found Exception ( class Name ) ; Data Input Stream data Input Stream = new Data Input Stream ( is ) ; Class < ? > cls = null ; try { RVM Type type = RVM Class Loader . define Class Internal ( class Name , data Input Stream , this ) ; loaded . put ( class Name , type ) ; cls = type . get Class For Type ( ) ; } finally { try { data Input Stream . close ( ) ; } catch ( IO Exception e ) { } } return cls ; } catch ( Class Not Found Exception e ) { throw e ; } catch ( Throwable e ) { if ( DBG ) { VM . sys Write ( STR_ , class Name , STR_ ) ; e . print Stack Trace ( ) ; } throw new Class Not Found Exception ( class Name , e ) ; } } }
public void update Deltas ( int delta X , int delta Y ) { if ( m Left Border Active ) { m Delta X = Math . max ( - m Baseline X , delta X ) ; m Delta X = Math . min ( m Baseline Width - NUM_ * m Touch Target Width , m Delta X ) ; } else if ( m Right Border Active ) { m Delta X = Math . min ( m Drag Layer . get Width ( ) - ( m Baseline X + m Baseline Width ) , delta X ) ; m Delta X = Math . max ( - m Baseline Width + NUM_ * m Touch Target Width , m Delta X ) ; } if ( m Top Border Active ) { m Delta Y = Math . max ( - m Baseline Y , delta Y ) ; m Delta Y = Math . min ( m Baseline Height - NUM_ * m Touch Target Width , m Delta Y ) ; } else if ( m Bottom Border Active ) { m Delta Y = Math . min ( m Drag Layer . get Height ( ) - ( m Baseline Y + m Baseline Height ) , delta Y ) ; m Delta Y = Math . max ( - m Baseline Height + NUM_ * m Touch Target Width , m Delta Y ) ; } }
public Standard Pie Tool Tip Generator ( String label Format ) { this ( label Format , Locale . get Default ( ) ) ; }
public boolean enable Image Access Step ( URI rp System Id , Map < URI , Integer > snapshots , String token ) throws Controller Exception { try { Workflow Step Completer . step Executing ( token ) ; URI device = null ; for ( URI snapshot ID : snapshots . key Set ( ) ) { Block Snapshot snapshot = db Client . query Object ( Block Snapshot . class , snapshot ID ) ; if ( device == null ) { device = snapshot . get Storage Controller ( ) ; } } enable Image For Snapshots ( rp System Id , device , new Array List < URI > ( snapshots . key Set ( ) ) , token ) ; Workflow Step Completer . step Succeded ( token ) ; } catch ( Exception e ) { step Failed ( token , e , STR_ ) ; return false ; } return true ; }
protected Boolean compute ( double value ) { if ( Double . is Na N ( value ) ) { return true ; } else { return false ; } }
@ Override public void add Layout Complete Event Listener ( Layout Complete Event Listener l ) { if ( layout Complete Listeners == null ) { layout Complete Listeners = new Array List < Layout Complete Event Listener > ( ) ; } layout Complete Listeners . add ( l ) ; }
protected char check Zone ( char zone ) { zone = Character . to Upper Case ( zone ) ; if ( zone != STR_ && zone != STR_ ) { throw new Number Format Exception ( STR_ + zone ) ; } return zone ; }
public static void register Dynamic Type Converter ( Java Dynamic Type Converter the Converter ) { if ( ! m dyn Converters . contains ( the Converter ) ) { m dyn Converters . add Element ( the Converter ) ; } }
public static String retrieve Generic Display Name ( String id , int style , Locale locale ) { String [ ] names = retrieve Display Names Impl ( id , locale ) ; if ( Objects . non Null ( names ) ) { return names [ NUM_ - style ] ; } else { return null ; } }
public I Element Type ( @ Not Null @ Non Nls String debug Name , @ Nullable Language language ) { this ( debug Name , language , true ) ; }
public static int next Message ID ( ) { int next ID = next Message ID . get And Increment ( ) ; if ( next ID == Integer . MAX VALUE ) { next Message ID . set ( NUM_ ) ; } return next ID ; }
private Image create Packed Image 8 ( ) throws IO Exception { int size = input . read Byte ( ) & NUM_ ; if ( size == NUM_ ) { size = NUM_ ; } int [ ] palette = new int [ size ] ; int plen = palette . length ; for ( int iter = NUM_ ; iter < plen ; iter ++ ) { palette [ iter ] = input . read Int ( ) ; } int width = input . read Short ( ) ; int height = input . read Short ( ) ; byte [ ] data = new byte [ width * height ] ; input . read Fully ( data , NUM_ , data . length ) ; return Image . create Indexed ( width , height , palette , data ) ; }
private int import Tables ( Referenceable database Referenceable , String database Name , final boolean fail On Error ) throws Exception { int tables Imported = NUM_ ; List < String > hive Tables = hive Client . get All Tables ( database Name ) ; LOG . info ( STR_ , hive Tables . to String ( ) , database Name ) ; for ( String table Name : hive Tables ) { int imported = import Table ( database Referenceable , database Name , table Name , fail On Error ) ; tables Imported += imported ; } if ( tables Imported == hive Tables . size ( ) ) { LOG . info ( STR_ , tables Imported , database Name ) ; } else { LOG . error ( STR_ , tables Imported , hive Tables . size ( ) , database Name ) ; } return tables Imported ; }
private Handshake Status run Tasks ( ) { Runnable runnable ; while ( ( runnable = ssl Engine . get Delegated Task ( ) ) != null ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + runnable + STR_ ) ; runnable . run ( ) ; } if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + ssl Engine . get Handshake Status ( ) ) ; return ssl Engine . get Handshake Status ( ) ; }
public Event Source ( ) { LOG . entering ( CLASS NAME , STR_ ) ; }
private void dispatch Default Callback Stored Results ( ) { if ( default Callback Stored Results . size ( ) == NUM_ || js Default Callback == null ) { return ; } for ( Plugin Result result : default Callback Stored Results ) { send Message To Default Callback ( result ) ; } default Callback Stored Results . clear ( ) ; }
synchronized public void release XML Reader ( XML Reader reader ) { if ( m reader Manager != null ) { m reader Manager . release XML Reader ( reader ) ; } }
protected void calculate Fitness ( ) { logger . debug ( STR_ + population . size ( ) + STR_ ) ; Iterator < T > iterator = population . iterator ( ) ; while ( iterator . has Next ( ) ) { T c = iterator . next ( ) ; if ( is Finished ( ) ) { if ( c . is Changed ( ) ) iterator . remove ( ) ; } else { calculate Fitness ( c ) ; } } }
@ Override void to XML ( String Builder xml , int level ) { indent ( xml , level ) ; xml . append ( STR_ ) ; for ( int i = NUM_ ; i < bytes . length ; i ++ ) { byte b = bytes [ i ] ; if ( b < NUM_ ) xml . append ( STR_ ) ; xml . append ( Integer . to Hex String ( b ) ) ; } xml . append ( STR_ ) ; }
private boolean configure Connection For Http Post ( Http URL Connection connection ) throws IO Exception { String boundary = read Boundary ( ) ; if ( boundary == null ) { return false ; } connection . set Do Output ( true ) ; connection . set Request Property ( STR_ , STR_ ) ; connection . set Request Property ( STR_ , STR_ ) ; connection . set Request Property ( STR_ , String . format ( CONTENT TYPE TMPL , boundary ) ) ; return true ; }
public static void collect Imports ( final I Java Project project , final AST Node node , final Collection < I Type Binding > type Bindings , final Collection < I Binding > static Bindings , final boolean declarations ) { collect Imports ( project , node , type Bindings , static Bindings , null , declarations ) ; }
private void adjust Day Of Month ( Calendar start Time , int month ) { apply Last Day Of Month ( start Time , month ) ; if ( ! window . get Last Day Of Month ( ) ) { int last Day Of Month = start Time . get ( Calendar . DAY OF MONTH ) ; if ( last Day Of Month > get Day Of Month ( ) ) { start Time . set ( Calendar . DAY OF MONTH , get Day Of Month ( ) ) ; } } }
public File resource Dwca File ( @ Not Null String resource Name , @ Not Null Big Decimal version ) { String fn = STR_ + version . to Plain String ( ) + STR_ ; return data File ( RESOURCES DIR + STR_ + resource Name + STR_ + fn ) ; }
@ Visible For Testing static OMA Entry parse OMA Entry ( String entry ) { int index = entry . index Of ( STR_ ) ; long download Id = Long . parse Long ( entry . substring ( NUM_ , index ) ) ; return new OMA Entry ( download Id , entry . substring ( index + NUM_ ) ) ; }
private Injector create Injector For ( final List < Class < ? extends Abstract Module > > classes ) throws Initialization Error { List < Abstract Module > modules = Lists . new Array List ( ) ; for ( Class < ? extends Abstract Module > clazz : classes ) { try { modules . add ( clazz . new Instance ( ) ) ; } catch ( Instantiation Exception | Illegal Access Exception e ) { throw new Illegal State Exception ( e ) ; } } return Guice . create Injector ( modules ) ; }
public void store State ( ) { if ( intervals Known ) { if ( stored Intervals == null ) { stored Intervals = new double [ intervals . length ] ; } if ( stored Lineage Counts == null ) { stored Lineage Counts = new int [ lineage Counts . length ] ; } if ( super Store ) { if ( stored Indices == null ) { stored Indices = new int [ indices . length ] ; } if ( stored Times == null ) { stored Times = new double [ times . length ] ; } } System . arraycopy ( intervals , NUM_ , stored Intervals , NUM_ , intervals . length ) ; System . arraycopy ( lineage Counts , NUM_ , stored Lineage Counts , NUM_ , lineage Counts . length ) ; if ( super Store ) { System . arraycopy ( indices , NUM_ , stored Indices , NUM_ , indices . length ) ; System . arraycopy ( times , NUM_ , stored Times , NUM_ , times . length ) ; } } stored Intervals Known = intervals Known ; }
public void loop ( Abstract Automaton a ) { int i ; synchronized ( automats ) { i = automats . index Of ( a ) ; } notify ( STR_ , null , Integer . value Of ( i ) ) ; }
public Effect Manager ( List < String > load Paths , List < String > write Paths , Config Factory factory ) { super ( load Paths , write Paths , factory ) ; }
public Default Task Config Router ( ) { this ( System . getenv ( ) ) ; }
private void add Explicit Location Field ( Config Source . Builder builder , Field Descriptor field , Node value ) { builder . add Location ( field , null , helper . get Location ( value ) ) ; }
@ Override protected Enumeration < URL > find Resources ( String res Name ) { init ( ) ; int length = m Paths . length ; Array List < URL > results = new Array List < URL > ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { URL result = find Resource ( res Name , i ) ; if ( result != null ) { results . add ( result ) ; } } return new Enumerate List Array < URL > ( results ) ; }
public static Memcache Client Builder < byte [ ] > new Byte Array Client ( ) { return new Memcache Client Builder < > ( Byte Array Transcoder . INSTANCE ) ; }
private Name reference Bridge Name ( ) { String Builder buf = new String Builder ( ) ; buf . append ( names . lambda ) ; buf . append ( STR_ ) ; buf . append ( enclosing Method Name ( ) ) ; buf . append ( STR_ ) ; buf . append ( synthetic Method Name Component ( tree . sym . name ) ) ; buf . append ( STR_ ) ; String disam = reference Bridge Disambiguation ( ) ; buf . append ( Integer . to Hex String ( disam . hash Code ( ) ) ) ; buf . append ( STR_ ) ; buf . append ( synthetic Method Name Counts . get Index ( buf ) ) ; String result = buf . to String ( ) ; return names . from String ( result ) ; }
public static void main ( String [ ] args ) { Baleen Logging logging = new Baleen Logging ( ) ; logging . configure ( Arrays . as List ( new Baleen Console Logger Builder ( DEFAULT PATTERN , new Min Max Filter ( Level . WARN , Level . ERROR ) ) , new Baleen File Logger Builder ( STR_ , STR_ , DEFAULT PATTERN , new Min Max Filter ( Level . INFO , Level . WARN ) , true , Optional . empty ( ) , Optional . empty ( ) ) ) ) ; org . slf 4 j . Logger logger = Logger Factory . get Logger ( Baleen Logging . class ) ; logger . warn ( STR_ ) ; logger . info ( STR_ ) ; logger . error ( STR_ ) ; logger . trace ( STR_ ) ; }
public int plaline len ( ) { return lines list . size ( ) ; }
protected void clear Caches ( ) { Descriptor Factory . clear Instance ( ) ; Object Type Factory . clear Instance ( ) ; Type Qualifier Applications . clear Instance ( ) ; Type Qualifier Annotation . clear Instance ( ) ; Type Qualifier Value . clear Instance ( ) ; Analysis Context . remove Current Analysis Context ( ) ; Global . remove Analysis Cache For Current Thread ( ) ; if ( class Path != null ) { class Path . close ( ) ; } }
protected String make Suffix ( String path , String content Type ) { String suffix = content Type != null ? WWIO . make Suffix For Mime Type ( content Type ) : null ; String existing Suffix = WWIO . get Suffix ( path ) ; if ( existing Suffix != null && existing Suffix . equals Ignore Case ( STR_ ) ) existing Suffix = STR_ ; if ( suffix != null && ( existing Suffix == null || ! existing Suffix . equals Ignore Case ( suffix . substring ( NUM_ ) ) ) ) return suffix ; else return null ; }
@ Override protected J Tabbed Pane create Plot Tabs ( Plot plot ) { J Tabbed Pane tabs = super . create Plot Tabs ( plot ) ; tabs . insert Tab ( localization Resources . get String ( STR_ ) , null , create Plot Panel ( ) , null , NUM_ ) ; tabs . set Selected Index ( NUM_ ) ; return tabs ; }
public static void store Bug Collection ( I Project project , final Sorted Bug Collection bug Collection , I Progress Monitor monitor ) throws IO Exception , Core Exception { project . set Session Property ( SESSION PROPERTY BUG COLLECTION , bug Collection ) ; if ( bug Collection != null ) { write Bug Collection ( project , bug Collection , monitor ) ; } }
public void attach To Moving Grab Point ( Offset Grab Point gp ) { gp . add Grab Point ( gpo ) ; }
private void disable Operation Buttons ( ) { btn Or . set Enabled ( false ) ; btn And . set Enabled ( false ) ; btn Right Paren . set Enabled ( false ) ; }
private void pin Day Of Month ( Local Gregorian Calendar . Date date ) { int year = date . get Year ( ) ; int dom = date . get Day Of Month ( ) ; if ( year != get Minimum ( YEAR ) ) { date . set Day Of Month ( NUM_ ) ; jcal . normalize ( date ) ; int month Length = jcal . get Month Length ( date ) ; if ( dom > month Length ) { date . set Day Of Month ( month Length ) ; } else { date . set Day Of Month ( dom ) ; } jcal . normalize ( date ) ; } else { Local Gregorian Calendar . Date d = jcal . get Calendar Date ( Long . MIN VALUE , get Zone ( ) ) ; Local Gregorian Calendar . Date real Date = jcal . get Calendar Date ( time , get Zone ( ) ) ; long tod = real Date . get Time Of Day ( ) ; real Date . add Year ( + NUM_ ) ; real Date . set Month ( date . get Month ( ) ) ; real Date . set Day Of Month ( NUM_ ) ; jcal . normalize ( real Date ) ; int month Length = jcal . get Month Length ( real Date ) ; if ( dom > month Length ) { real Date . set Day Of Month ( month Length ) ; } else { if ( dom < d . get Day Of Month ( ) ) { real Date . set Day Of Month ( d . get Day Of Month ( ) ) ; } else { real Date . set Day Of Month ( dom ) ; } } if ( real Date . get Day Of Month ( ) == d . get Day Of Month ( ) && tod < d . get Time Of Day ( ) ) { real Date . set Day Of Month ( Math . min ( dom + NUM_ , month Length ) ) ; } date . set Date ( year , real Date . get Month ( ) , real Date . get Day Of Month ( ) ) ; } }
public static void over Scroll By ( final Pull To Refresh Base < ? > view , final int delta X , final int scroll X , final int delta Y , final int scroll Y , final int scroll Range , final int fuzzy Threshold , final float scale Factor , final boolean is Touch Event ) { final int delta Value , current Scroll Value , scroll Value ; switch ( view . get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : delta Value = delta X ; scroll Value = scroll X ; current Scroll Value = view . get Scroll X ( ) ; break ; case VERTICAL : default : delta Value = delta Y ; scroll Value = scroll Y ; current Scroll Value = view . get Scroll Y ( ) ; break ; } if ( view . is Pull To Refresh Over Scroll Enabled ( ) && ! view . is Refreshing ( ) ) { final Pull To Refresh Base . Mode mode = view . get Mode ( ) ; if ( mode . permits Pull To Refresh ( ) && ! is Touch Event && delta Value != NUM_ ) { final int new Scroll Value = ( delta Value + scroll Value ) ; if ( new Scroll Value < ( NUM_ - fuzzy Threshold ) ) { if ( mode . show Header Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( Pull To Refresh Base . State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value ) ) ) ; } } else if ( new Scroll Value > ( scroll Range + fuzzy Threshold ) ) { if ( mode . show Footer Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( Pull To Refresh Base . State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value - scroll Range ) ) ) ; } } else if ( Math . abs ( new Scroll Value ) <= fuzzy Threshold || Math . abs ( new Scroll Value - scroll Range ) <= fuzzy Threshold ) { view . set State ( Pull To Refresh Base . State . RESET ) ; } } else if ( is Touch Event && Pull To Refresh Base . State . OVERSCROLLING == view . get State ( ) ) { view . set State ( Pull To Refresh Base . State . RESET ) ; } } }
public static AM Identity create A Test User ( SSO Token admin Token , String username , String realm ) throws Id Repo Exception , SSO Exception { AM Identity Repository amir = new AM Identity Repository ( admin Token , realm ) ; Map < String , Set < String > > attr Values = new Hash Map < String , Set < String > > ( ) ; Set < String > set = new Hash Set < String > ( ) ; set . add ( username ) ; attr Values . put ( STR_ , set ) ; attr Values . put ( STR_ , set ) ; attr Values . put ( STR_ , set ) ; attr Values . put ( STR_ , set ) ; return amir . create Identity ( Id Type . USER , username , attr Values ) ; }
private void add To Search Criteria Parameter Map ( String key , String value ) { if ( search Criteria Parameter Map . contains Key ( key ) ) { Array List < String > array List = search Criteria Parameter Map . get ( key ) ; array List . add ( value ) ; search Criteria Parameter Map . put ( key , array List ) ; } else { Array List < String > array List = new Array List < > ( ) ; array List . add ( value ) ; search Criteria Parameter Map . put ( key , array List ) ; } }
public static String format ( long sys Time ) { return LONG DATE FMT . format ( new java . util . Date ( sys Time ) ) ; }
private void grow ( int min Capacity ) { int old Capacity = element Data . length ; int new Capacity = old Capacity + ( old Capacity > > NUM_ ) ; if ( new Capacity - min Capacity < NUM_ ) { new Capacity = min Capacity ; } if ( new Capacity - MAX ARRAY SIZE > NUM_ ) { new Capacity = huge Capacity ( min Capacity ) ; } element Data = Arrays . copy Of ( element Data , new Capacity ) ; }
public static int compare Parent To Child ( String path 1 , String path 2 ) { return path 1 . compare To ( path 2 ) ; }
private String create Workflow Step For Restore Native Snapshot ( Workflow workflow , Storage System parent System , URI parent Volume URI , URI snapshot URI , URI parent Pool URI , String wait For , Workflow . Method rollback Method ) { URI parent System URI = parent System . get Id ( ) ; Workflow . Method restore Volume Method = new Workflow . Method ( RESTORE VOLUME METHOD NAME , parent System URI , parent Pool URI , parent Volume URI , snapshot URI , Boolean . FALSE , null ) ; workflow . create Step ( RESTORE VOLUME STEP , String . format ( STR_ , parent Volume URI , snapshot URI ) , wait For , parent System URI , parent System . get System Type ( ) , Block Device Controller . class , restore Volume Method , rollback Method , null ) ; log . info ( STR_ , parent Volume URI , snapshot URI ) ; return RESTORE VOLUME STEP ; }
public void terminate Timer ( ) { timer . cancel ( ) ; running = false ; }
@ Override public synchronized void add Handshake Completed Listener ( Handshake Completed Listener listener ) { if ( listener == null ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( handshake Listeners == null ) { handshake Listeners = new Hash Map < Handshake Completed Listener , Access Control Context > ( NUM_ ) ; } handshake Listeners . put ( listener , Access Controller . get Context ( ) ) ; }
public static void register Space M Bean ( String space Name , Space Impl space Impl ) { M Bean Server m Bean Server = get M Bean Server ( space Impl . get Container Name ( ) ) ; if ( m Bean Server == null ) return ; if ( m M Beans Repository . contains Key ( space Impl . get Service Name ( ) ) ) return ; try { IJ Space remote Space Proxy = space Impl . get Single Proxy ( ) ; JMX Space mbean = new JMX Space ( remote Space Proxy , JSPACE MBEAN DESCR URL ) ; Object Name obj Name = Object Name Factory . build Object Name ( DEFAULT DOMAIN , mbean . get Type ( ) , space Impl . get Container Name ( ) + STR_ + space Name ) ; m M Beans Repository . put ( space Impl . get Service Name ( ) , m Bean Server . register M Bean ( mbean , obj Name ) ) ; JMX Space Ext mbean Ext = new JMX Space Ext ( remote Space Proxy , mbean . m space Config , JSPACE EXT MBEAN DESCR URL ) ; Object Name obj Name Ext = Object Name Factory . build Object Name ( DEFAULT DOMAIN , mbean Ext . get Type ( ) , space Impl . get Container Name ( ) + STR_ + space Name ) ; m M Beans Repository . put ( space Impl . get Service Name ( ) + STR_ , m Bean Server . register M Bean ( mbean Ext , obj Name Ext ) ) ; if ( logger . is Loggable ( Level . CONFIG ) ) { logger . config ( STR_ + space Impl . get Service Name ( ) + STR_ ) ; } } catch ( Instance Already Exists Exception e ) { if ( logger . is Loggable ( Level . CONFIG ) ) { logger . config ( STR_ + space Impl . get Service Name ( ) + STR_ ) ; } } catch ( Exception ex ) { if ( logger . is Loggable ( Level . WARNING ) ) { logger . log ( Level . WARNING , STR_ + space Impl . get Service Name ( ) + STR_ , ex ) ; } } }
public void remove Property Change Listener ( String property Name , Property Change Listener in pcl ) { pc Support . remove Property Change Listener ( property Name , in pcl ) ; }
private String print O Format ( String sx ) { int n Leading Zeros = NUM_ ; int n Blanks = NUM_ ; if ( sx . equals ( STR_ ) && precision Set && precision == NUM_ ) sx = STR_ ; if ( precision Set ) n Leading Zeros = precision - sx . length ( ) ; if ( alternate Form ) n Leading Zeros ++ ; if ( n Leading Zeros < NUM_ ) n Leading Zeros = NUM_ ; if ( field Width Set ) n Blanks = field Width - n Leading Zeros - sx . length ( ) ; if ( n Blanks < NUM_ ) n Blanks = NUM_ ; int n = n Leading Zeros + sx . length ( ) + n Blanks ; char [ ] ca = new char [ n ] ; int i ; if ( left Justify ) { for ( i = NUM_ ; i < n Leading Zeros ; i ++ ) ca [ i ] = STR_ ; char [ ] csx = sx . to Char Array ( ) ; for ( int j = NUM_ ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; for ( int j = NUM_ ; j < n Blanks ; j ++ , i ++ ) ca [ i ] = STR_ ; } else { if ( leading Zeros ) for ( i = NUM_ ; i < n Blanks ; i ++ ) ca [ i ] = STR_ ; else for ( i = NUM_ ; i < n Blanks ; i ++ ) ca [ i ] = STR_ ; for ( int j = NUM_ ; j < n Leading Zeros ; j ++ , i ++ ) ca [ i ] = STR_ ; char [ ] csx = sx . to Char Array ( ) ; for ( int j = NUM_ ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; } return new String ( ca ) ; }
public Ber Input Stream ( Input Stream in , int initial Size ) throws IO Exception { this . in = in ; buffer = new byte [ initial Size ] ; next ( ) ; if ( length != INDEFINIT LENGTH ) { if ( buffer . length < ( length + offset ) ) { byte [ ] new Buffer = new byte [ length + offset ] ; System . arraycopy ( buffer , NUM_ , new Buffer , NUM_ , offset ) ; buffer = new Buffer ; } } else { is Indefined Length = true ; throw new ASN 1 Exception ( STR_ ) ; } }
public void on Settings ( View v ) { Intent intent = new Intent ( this , Config Prefs Activity . class ) ; intent . put Extra ( Config Prefs . PREFS TYPE , Config Prefs . VIDEO AND CONNECTION ) ; intent . put Extra ( Config Prefs . FIXED FRAME SIZE , true ) ; intent . put Extra ( Config Prefs . FIXED FRAME RATE , true ) ; start Activity ( intent ) ; }
public String command Topic ( String command ) { if ( command == null ) { command = STR_ ; } return cmd Topic . replace ( STR_ , command ) ; }
public Char Pointer ( String s ) { this ( s . to Char Array ( ) . length + NUM_ ) ; put String ( s ) ; }
public static void main ( String [ ] args ) { Client Java Main main = new Client Java Main ( ) ; try { main . run ( ) ; } catch ( Throwable t ) { log . log ( Level . SEVERE , STR_ , t ) ; } }
public static boolean is Middle Mouse Button ( Mouse Event an Event ) { return ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 2 DOWN MASK ) > NUM_ ; }
private Map . Entry < Integer , Integer > add Usage Maps ( int num Maps , Integer first Used Page ) throws IO Exception { Jet Format format = get Format ( ) ; Page Channel page Channel = get Page Channel ( ) ; int umap Row Length = format . OFFSET USAGE MAP START + format . USAGE MAP TABLE BYTE LENGTH ; int total Umap Space Usage = get Row Space Usage ( umap Row Length , format ) * num Maps ; int umap Page Number = Page Channel . INVALID PAGE NUMBER ; int first Row Num = - NUM_ ; int free Space = NUM_ ; Set < Integer > known Pages = new Tree Set < Integer > ( Collections . reverse Order ( ) ) ; collect Usage Map Pages ( known Pages ) ; Byte Buffer umap Buf = page Channel . create Page Buffer ( ) ; for ( Integer page Num : known Pages ) { page Channel . read Page ( umap Buf , page Num ) ; free Space = umap Buf . get Short ( format . OFFSET FREE SPACE ) ; if ( free Space >= total Umap Space Usage ) { umap Page Number = page Num ; first Row Num = get Rows On Data Page ( umap Buf , format ) ; break ; } } if ( umap Page Number == Page Channel . INVALID PAGE NUMBER ) { umap Page Number = page Channel . allocate New Page ( ) ; free Space = format . DATA PAGE INITIAL FREE SPACE ; first Row Num = NUM_ ; umap Buf = create Usage Map Def Page ( page Channel , free Space ) ; } int row Start = find Row End ( umap Buf , first Row Num , format ) - umap Row Length ; int umap Row Num = first Row Num ; for ( int i = NUM_ ; i < num Maps ; ++ i ) { umap Buf . put Short ( get Row Start Offset ( umap Row Num , format ) , ( short ) row Start ) ; umap Buf . put ( row Start , Usage Map . MAP TYPE INLINE ) ; if ( first Used Page != null ) { umap Buf . put Int ( row Start + NUM_ , first Used Page ) ; umap Buf . put ( row Start + NUM_ , ( byte ) NUM_ ) ; } row Start -= umap Row Length ; ++ umap Row Num ; } free Space -= total Umap Space Usage ; umap Buf . put Short ( format . OFFSET FREE SPACE , ( short ) free Space ) ; umap Buf . put Short ( format . OFFSET NUM ROWS ON DATA PAGE , ( short ) umap Row Num ) ; page Channel . write Page ( umap Buf , umap Page Number ) ; return new Abstract Map . Simple Immutable Entry < Integer , Integer > ( umap Page Number , first Row Num ) ; }
@ Override public boolean equals ( Object object ) { if ( object == null ) { return false ; } if ( object == this ) { return true ; } if ( super . equals ( object ) && object instanceof Ship Needle ) { return true ; } return false ; }
public static Object [ ] pad Arguments ( Object [ ] args , int count ) { if ( count < args . length ) return args ; int i ; Object [ ] result = new Object [ count ] ; for ( i = NUM_ ; i < args . length ; i ++ ) { result [ i ] = args [ i ] ; } for ( ; i < count ; i ++ ) { result [ i ] = Undefined . instance ; } return result ; }
public Ranking Image List Provider in Hours ( int hours ) { m Time = Integer . to String ( hours ) + STR_ ; return this ; }
@ POST @ Produces ( Media Type . APPLICATION JSON ) @ Path ( STR_ ) public void post Data ( @ Context Uri Info uri Info , @ Suspended Async Response async Response ) { String Builder b = new String Builder ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { b . append ( ( char ) ( STR_ + i % NUM_ ) ) ; } async Response . resume ( b . to String ( ) ) ; }
public double local Score ( int i , int ... parents ) { Conditional Gaussian Likelihood . Ret ret = likelihood . get Likelihood Ratio ( i , parents ) ; int N = data Set . get Num Rows ( ) ; double lik = ret . get Lik ( ) ; int k = ret . get Dof ( ) ; double prior = get Structure Prior ( parents ) ; return NUM_ * lik - k * Math . log ( N ) + prior ; }
public void send Registration Id ( ) throws Android Agent Exception { Device Info device Info = new Device Info ( get Context ( ) ) ; Device Info Payload device Info Payload = new Device Info Payload ( get Context ( ) ) ; device Info Payload . build ( ) ; String reply Payload = device Info Payload . get Device Info Payload ( ) ; String ip Saved = Constants . DEFAULT HOST ; String pref IP = Preference . get String ( get Context ( ) , Constants . Preference Flag . IP ) ; if ( pref IP != null ) { ip Saved = pref IP ; } if ( ip Saved != null && ! ip Saved . is Empty ( ) ) { Server Config utils = new Server Config ( ) ; utils . set Server IP ( ip Saved ) ; String url = utils . get API Server URL ( get Context ( ) ) + Constants . DEVICE ENDPOINT + device Info . get Device Id ( ) ; Common Utils . call Secured API ( get Context ( ) , url , org . wso 2 . emm . agent . proxy . utils . Constants . HTTP METHODS . PUT , reply Payload , GCM Registration Manager . this , Constants . GCM REGISTRATION ID SEND CODE ) ; } else { Log . e ( TAG , STR_ ) ; } }
public void write ( Entity entity ) throws SAX Exception { String text = entity . get Text ( ) ; if ( lexical Handler != null ) { String name = entity . get Name ( ) ; lexical Handler . start Entity ( name ) ; write ( text ) ; lexical Handler . end Entity ( name ) ; } else { write ( text ) ; } }
public void load Locks ( ) { int AD User ID = Env . get Context As Int ( Env . get Ctx ( ) , STR_ ) ; log . fine ( STR_ + m vo . Tab No + STR_ + AD User ID ) ; if ( ! can Have Attachment ( ) ) return ; String sql = STR_ + STR_ + STR_ + STR_ ; try { if ( m Lock == null ) m Lock = new Array List < Integer > ( ) ; else m Lock . clear ( ) ; Prepared Statement pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM_ , AD User ID ) ; pstmt . set Int ( NUM_ , m vo . AD Table ID ) ; Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { Integer key = new Integer ( rs . get Int ( NUM_ ) ) ; m Lock . add ( key ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } log . fine ( STR_ + m Lock . size ( ) ) ; }
public void add Input ( Lop op ) { inputs . add ( op ) ; }
String find First Matching Key ( T container , String url ) { String t Url = url . contains ( STR_ ) ? url . substring ( NUM_ , url . index Of ( STR_ ) ) : url ; int index = - NUM_ ; while ( ( index = t Url . last Index Of ( STR_ ) ) > - NUM_ ) { if ( contains Key ( container , t Url ) ) { return t Url ; } t Url = t Url . substring ( NUM_ , index ) ; } return url . starts With ( STR_ ) && contains Key ( container , STR_ ) ? STR_ : null ; }
private void elide Events ( ) { if ( ! s event Elission ) { return ; } final Iterator < Quorum State Change Event > events = queue . iterator ( ) ; Quorum State Change Event uce = null ; Quorum State Change Event dce = null ; Quorum State Change Event add = null ; while ( events . has Next ( ) ) { final Quorum State Change Event tst = events . next ( ) ; if ( tst . get Event Type ( ) == Quorum State Change Event Enum . PIPELINE UPSTREAM CHANGE ) { if ( uce != null ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + uce ) ; queue . remove ( uce ) ; } uce = tst ; } else if ( tst . get Event Type ( ) == Quorum State Change Event Enum . PIPELINE CHANGE ) { if ( dce != null ) { tst . get Downstream Old And New ( ) [ NUM_ ] = dce . get Downstream Old And New ( ) [ NUM_ ] ; if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + dce ) ; queue . remove ( dce ) ; } dce = tst ; } else if ( tst . get Event Type ( ) == Quorum State Change Event Enum . PIPELINE ADD ) { add = tst ; } else if ( tst . get Event Type ( ) == Quorum State Change Event Enum . PIPELINE REMOVE ) { if ( add != null ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + add ) ; log . debug ( STR_ + tst ) ; } queue . remove ( add ) ; queue . remove ( tst ) ; add = null ; } if ( dce != null ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + dce ) ; queue . remove ( dce ) ; dce = null ; } if ( uce != null ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + uce ) ; queue . remove ( uce ) ; uce = null ; } } } }
public void add Connection Listener ( Connection Listener listener ) { connection Listeners . add Element ( listener ) ; }
public static void check Equals And Hash Code Methods ( String message , Object lhs , Object rhs , boolean expected Result ) { if ( ( lhs == null ) && ( rhs == null ) ) { Assert . assert True ( STR_ , expected Result ) ; return ; } if ( ( lhs == null ) || ( rhs == null ) ) { Assert . assert False ( STR_ + STR_ , expected Result ) ; } if ( lhs != null ) { Assert . assert Equals ( message , expected Result , lhs . equals ( rhs ) ) ; } if ( rhs != null ) { Assert . assert Equals ( message , expected Result , rhs . equals ( lhs ) ) ; } if ( expected Result ) { String hash Message = STR_ ; if ( message != null ) { hash Message += STR_ + message ; } Assert . assert True ( hash Message , lhs . hash Code ( ) == rhs . hash Code ( ) ) ; } }
public static SPIN Thread Functions register ( Model model ) { SPIN Thread Functions old = local Functions . get ( ) ; SPIN Thread Functions neo = new SPIN Thread Functions ( model ) ; local Functions . set ( neo ) ; return old ; }
private Instances compute Info Gain ( Instances instances , double def Ac Rt , Antd antd ) { Instances data = instances ; Instances [ ] split Data = antd . split Data ( data , def Ac Rt , m Consequent ) ; if ( split Data != null ) { return split Data [ ( int ) antd . get Attr Value ( ) ] ; } else { return null ; } }
private void remove Store ( long id ) { List < Long > list = new Array List < > ( ) ; list . add ( id ) ; remove Stores ( list ) ; }
private Instance State check In ( ) { final Instance State state ; try { logger . debug ( STR_ , instance Id ) ; state = get Instance State ( instance Id ) ; } catch ( Resource Exception e ) { logger . info ( STR_ , instance Id ) ; return null ; } try { if ( first Checkin ) { state . update Startup ( ) ; state . clear Shutdown ( ) ; first Checkin = false ; } switch ( state . get State ( ) ) { case Instance State . STATE RUNNING : state . update Timestamp ( ) ; break ; case Instance State . STATE DOWN : state . set State ( Instance State . STATE RUNNING ) ; logger . debug ( STR_ , instance Id , Instance State . STATE DOWN , Instance State . STATE RUNNING ) ; state . update Timestamp ( ) ; break ; case Instance State . STATE PROCESSING DOWN : logger . debug ( STR_ , instance Id , state . get State ( ) ) ; return state ; } update Instance State ( instance Id , state ) ; logger . debug ( STR_ , instance Id ) ; } catch ( Resource Exception e ) { if ( e . get Code ( ) != Resource Exception . CONFLICT ) { logger . warn ( STR_ , e ) ; } else { logger . info ( STR_ , state . get State ( ) ) ; return null ; } } return state ; }
protected Abstract Format ( final Number Format format ) { this ( format , ( Number Format ) format . clone ( ) ) ; }
public Output Limit Clause add Then Assignment ( Expression assignment Expression ) { then Assignments . add ( new Assignment ( assignment Expression ) ) ; return this ; }
J Panel make Edit Panel ( J Component comp , String label , String hint ) { J Panel panel = new J Panel ( ) ; panel . set Layout ( new Box Layout ( panel , Box Layout . Y AXIS ) ) ; J Panel p = new J Panel ( ) ; p . add ( new J Label ( rbx . get String ( label ) ) ) ; panel . add ( p ) ; if ( hint != null ) { panel . set Tool Tip Text ( rbx . get String ( hint ) ) ; } comp . set Maximum Size ( comp . get Preferred Size ( ) ) ; panel . add ( comp ) ; panel . add ( Box . create Vertical Glue ( ) ) ; return panel ; }
public Confusion Matrix ( Array List < Class Label > labels , int [ ] [ ] confusion ) throws Illegal Argument Exception { for ( int i = NUM_ ; i < confusion . length ; i ++ ) { if ( confusion . length != confusion [ i ] . length ) { throw new Illegal Argument Exception ( STR_ + confusion . length + STR_ + i + STR_ + confusion [ i ] . length ) ; } } if ( confusion . length != labels . size ( ) ) { throw new Illegal Argument Exception ( STR_ ) ; } this . confusion = confusion ; this . labels = labels ; }
static private String SHORT Min ( ) { short temp Value = Short . MIN VALUE ; return String . value Of ( temp Value ) ; }
synchronized void register To Notifications ( ) throws JMS Exception { if ( m closed ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STR_ ) ; } return ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STR_ ) ; } try { event Session = Data Event Session Factory . create ( m space , event Session Config ) ; event Session . add Listener ( m jms Message Template , on Message Event Listener , Notify Action Type . NOTIFY WRITE ) ; } catch ( IO Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , to String 2 ( ) + STR_ + e ) ; } JMS Exception e 1 = new JMS Exception ( STR_ ) ; e 1 . set Linked Exception ( e ) ; throw e 1 ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } if ( ! ( obj instanceof XY Drawable Annotation ) ) { return false ; } XY Drawable Annotation that = ( XY Drawable Annotation ) obj ; if ( this . x != that . x ) { return false ; } if ( this . y != that . y ) { return false ; } if ( this . display Width != that . display Width ) { return false ; } if ( this . display Height != that . display Height ) { return false ; } if ( this . draw Scale Factor != that . draw Scale Factor ) { return false ; } if ( ! Object Utilities . equal ( this . drawable , that . drawable ) ) { return false ; } return true ; }
private void parse Stram Property Tokens ( String [ ] keys , int index , String property Name , String property Value , Conf conf ) { if ( index < keys . length ) { String key = keys [ index ] ; Stram Element element = get Element ( key , conf ) ; if ( ( element == null ) && conf . ignore Unknown Children ( ) ) { return ; } if ( ( element == Stram Element . APPLICATION ) || ( element == Stram Element . OPERATOR ) || ( element == Stram Element . STREAM ) || ( element == Stram Element . PORT ) || ( element == Stram Element . INPUT PORT ) || ( element == Stram Element . OUTPUT PORT ) || ( element == Stram Element . TEMPLATE ) ) { parse App Element ( index , keys , element , conf , property Name , property Value ) ; } else if ( element == Stram Element . GATEWAY ) { parse Gateway Element ( element , conf , keys , index , property Name , property Value ) ; } else if ( ( element == Stram Element . UNIFIER ) ) { parse Unifier Element ( element , conf , keys , index , property Name , property Value ) ; } else if ( ( element == Stram Element . ATTR ) || ( ( element == null ) && ( conf . get Default Child Element ( ) == Stram Element . ATTR ) ) ) { parse Attribute Element ( element , keys , index , conf , property Value , property Name ) ; } else if ( ( element == Stram Element . PROP ) || ( ( element == null ) && ( conf . get Default Child Element ( ) == Stram Element . PROP ) ) ) { parse Property Element ( element , keys , index , conf , property Value , property Name ) ; } else if ( element != null ) { conf . parse Element ( element , keys , index , property Value ) ; } } }
private static Object compress Non Decimal ( Data Type changed Data Type , double [ ] value , int decimal ) { int i = NUM_ ; switch ( changed Data Type ) { case DATA BYTE : byte [ ] result = new byte [ value . length ] ; for ( double a : value ) { result [ i ] = ( byte ) ( Math . round ( Math . pow ( NUM_ , decimal ) * a ) ) ; i ++ ; } return result ; case DATA SHORT : short [ ] short Result = new short [ value . length ] ; for ( double a : value ) { short Result [ i ] = ( short ) ( Math . round ( Math . pow ( NUM_ , decimal ) * a ) ) ; i ++ ; } return short Result ; case DATA INT : int [ ] int Result = new int [ value . length ] ; for ( double a : value ) { int Result [ i ] = ( int ) ( Math . round ( Math . pow ( NUM_ , decimal ) * a ) ) ; i ++ ; } return int Result ; case DATA LONG : long [ ] long Result = new long [ value . length ] ; for ( double a : value ) { long Result [ i ] = ( long ) ( Math . round ( Math . pow ( NUM_ , decimal ) * a ) ) ; i ++ ; } return long Result ; case DATA FLOAT : float [ ] float Result = new float [ value . length ] ; for ( double a : value ) { float Result [ i ] = ( float ) ( Math . round ( Math . pow ( NUM_ , decimal ) * a ) ) ; i ++ ; } return float Result ; default : double [ ] default Result = new double [ value . length ] ; for ( double a : value ) { default Result [ i ] = ( double ) ( Math . round ( Math . pow ( NUM_ , decimal ) * a ) ) ; i ++ ; } return default Result ; } }
protected static Set string Array To Set ( String [ ] strs ) { int count = strs . length ; Set set = ( ( count > NUM_ ) ? new Hash Set ( count ) : new Hash Set ( ) ) ; for ( int i = NUM_ ; i < count ; i ++ ) { set . add ( strs [ i ] ) ; } return set ; }
public boolean is Private ( ) { return Modifier . is Private ( flags ) ; }
public Inet Unix Address ( String path ) { this ( path . get Bytes ( Standard Charsets . UTF 8 ) ) ; }
private synchronized boolean wait Resume ( ) { while ( is Paused ( ) && ! is Cancelled ( ) && ! is Done ( ) ) { try { debug Print ( STR_ ) ; wait ( ) ; } catch ( Interrupted Exception ie ) { } } return ! is Cancelled ( ) && ! is Done ( ) ; }
public static Recipe from Cursor ( Cursor cursor ) { Recipe recipe = new Recipe ( null ) ; for ( int c = NUM_ ; c < cursor . get Column Count ( ) ; c ++ ) { String column Name = cursor . get Column Name ( c ) ; if ( column Name . equals ( Recipe Table . ID COLUMN ) ) { recipe . id = cursor . get String ( c ) ; } else if ( column Name . equals ( Recipe Table . TITLE COLUMN ) ) { recipe . set Title ( cursor . get String ( c ) ) ; } else if ( column Name . equals ( Recipe Table . DESCRIPTION COLUMN ) ) { recipe . set Description ( cursor . get String ( c ) ) ; } else if ( column Name . equals ( Recipe Table . PHOTO COLUMN ) ) { recipe . set Photo ( cursor . get String ( c ) ) ; } else if ( column Name . equals ( Recipe Table . PREP TIME COLUMN ) ) { recipe . set Prep Time ( cursor . get String ( c ) ) ; } } return recipe ; }
public static String to Show Consolidated ( final I Documentation Holder documentation ) { return consolidate ( documentation , true ) ; }
@ Suppress Warnings ( STR_ ) Symbol select Best ( Env < Attr Context > env , Type site , List < Type > argtypes , List < Type > typeargtypes , Symbol sym , Symbol best So Far , boolean allow Boxing , boolean use Varargs , boolean operator ) { if ( sym . kind == ERR || ! sym . is Inherited In ( site . tsym , types ) ) { return best So Far ; } else if ( use Varargs && ( sym . flags ( ) & VARARGS ) == NUM_ ) { return best So Far . kind >= ERRONEOUS ? new Bad Varargs Method ( ( Resolve Error ) best So Far ) : best So Far ; } Assert . check ( sym . kind < AMBIGUOUS ) ; try { Type mt = raw Instantiate ( env , site , sym , null , argtypes , typeargtypes , allow Boxing , use Varargs , types . no Warnings ) ; if ( ! operator || verbose Resolution Mode . contains ( Verbose Resolution Mode . PREDEF ) ) current Resolution Context . add Applicable Candidate ( sym , mt ) ; } catch ( Inapplicable Method Exception ex ) { if ( ! operator ) current Resolution Context . add Inapplicable Candidate ( sym , ex . get Diagnostic ( ) ) ; switch ( best So Far . kind ) { case ABSENT MTH : return new Inapplicable Symbol Error ( current Resolution Context ) ; case WRONG MTH : if ( operator ) return best So Far ; best So Far = new Inapplicable Symbols Error ( current Resolution Context ) ; default : return best So Far ; } } if ( ! is Accessible ( env , site , sym ) ) { return ( best So Far . kind == ABSENT MTH ) ? new Access Error ( env , site , sym ) : best So Far ; } return ( best So Far . kind > AMBIGUOUS ) ? sym : most Specific ( argtypes , sym , best So Far , env , site , allow Boxing && operator , use Varargs ) ; }
public static void init Urban Sim Person Writer ( Urban Sim Parameter Config Module V 3 module ) { try { log . info ( STR_ ) ; person Writer = IO Utils . get Buffered Writer ( module . get MAT Sim 4 Opus Temp ( ) + FILE NAME ) ; log . info ( STR_ + module . get MAT Sim 4 Opus Temp ( ) + FILE NAME + STR_ ) ; person Writer . write ( Internal Constants . PERSON ID + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ) ; person Writer . new Line ( ) ; log . info ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
private Classifier Split Model local Model ( ) { return m local Model ; }
public static Http Response execute Post Request ( String entity Name , String pay Load , boolean secure ) throws Malformed URL Exception , IO Exception , Protocol Exception { URL url = ( secure ) ? new URL ( SERVICE ROOT URI + STR_ + entity Name ) : new URL ( SERVICE ROOT URI + entity Name ) ; Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; try { connection . set Request Method ( STR_ ) ; connection . set Do Input ( true ) ; connection . set Do Output ( true ) ; connection . set Use Caches ( false ) ; if ( secure ) { connection . set Request Property ( STR_ , AUTHORIZATION ) ; } connection . set Request Property ( STR_ , STR_ ) ; connection . set Request Property ( STR_ , STR_ ) ; Data Output Stream out Stream = new Data Output Stream ( connection . get Output Stream ( ) ) ; try { out Stream . write Bytes ( pay Load ) ; out Stream . close ( ) ; return new Http Response ( connection ) ; } finally { out Stream . close ( ) ; } } finally { connection . disconnect ( ) ; } }
protected final void fire Property Change ( String property Name , double old Value , double new Value ) { fire Property Change ( property Name , Double . value Of ( old Value ) , Double . value Of ( new Value ) ) ; }
public List < Resource > scan ( ) { List < Resource > found Resources = new Linked List < > ( ) ; List < Class < ? extends Object > > classes ; try { if ( jar Url == null ) { if ( this . clazz != null ) { classes = get Classes In Package ( this . package Name , this . clazz ) ; } else { classes = get Classes In Package ( this . package Name ) ; } } else { classes = get Classes In Jar File ( jar Url ) ; } } catch ( IO Exception e ) { return found Resources ; } for ( Class clazz : classes ) { found Resources . add All ( get Resources From Class Recursive ( clazz ) ) ; } return found Resources ; }
private List < Datastore Service . State > create Datastore Descriptions ( int num Datastores ) { List < Datastore Service . State > datastores = new Array List < > ( ) ; for ( int i = NUM_ ; i < num Datastores ; i ++ ) { String datastore Name = STR_ + UUID . random UUID ( ) ; String datastore Tag = STR_ + i ; String datastore Tag 2 = STR_ + i ; Datastore Service . State datastore = new Datastore Service . State ( ) ; datastore . id = datastore Name ; datastore . name = datastore Name ; datastore . type = STR_ ; datastore . tags = new Hash Set < > ( Arrays . as List ( datastore Tag , datastore Tag 2 ) ) ; datastore . document Self Link = datastore Name ; datastores . add ( datastore ) ; } return datastores ; }
public boolean equals ( Object obj ) { if ( obj instanceof Namespace Specification ) { Namespace Specification other = ( Namespace Specification ) obj ; return ns . equals ( other . ns ) && wildcard . equals ( other . wildcard ) ; } return false ; }
public void compute X Axis ( ) { x Stops . num Stops = visible X Range ; if ( x Stops . stops . length < visible X Range ) { x Stops . stops = new float [ visible X Range ] ; } int value = ( int ) Math . ceil ( viewport Rect . left ) ; for ( int i = NUM_ ; i < visible X Range ; i ++ , value += x Interval ) { x Stops . stops [ i ] = value ; } }
private static String swizzle Class Name For Write ( String name , Data Output out ) { String old Package = STR_ ; String new Package = STR_ ; if ( name . starts With ( new Package ) ) { return old Package + name . substring ( new Package . length ( ) ) ; } Old Client Support Service svc = Internal Data Serializer . get Old Client Support Service ( ) ; if ( svc != null ) { return svc . process Outgoing Class Name ( name , out ) ; } return name ; }
public void call Arg Visitors ( X Path Visitor visitor ) { for ( int i = NUM_ ; i < m arg Vec . size ( ) ; i ++ ) { Expression exp = ( Expression ) m arg Vec . element At ( i ) ; exp . call Visitors ( new Arg Ext Owner ( exp ) , visitor ) ; } }
public boolean cancel Transfer ( String username , String submission ID ) { if ( cancel Upload ( username , submission ID ) ) return true ; return cancel Download ( username , submission ID ) ; }
public void close ( ) { if ( datagram Socket != null ) { datagram Socket . close ( ) ; } }
private Priority Queue < Score Term > retrieve Terms ( int doc Num ) throws IO Exception { Map < String , Int > term Freq Map = new Hash Map < > ( ) ; for ( String field Name : field Names ) { final Fields vectors = ir . get Term Vectors ( doc Num ) ; final Terms vector ; if ( vectors != null ) { vector = vectors . terms ( field Name ) ; } else { vector = null ; } if ( vector == null ) { Document d = ir . document ( doc Num ) ; Indexable Field fields [ ] = d . get Fields ( field Name ) ; for ( Indexable Field field : fields ) { final String string Value = field . string Value ( ) ; if ( string Value != null ) { add Term Frequencies ( new Fast String Reader ( string Value ) , term Freq Map , field Name ) ; } } } else { add Term Frequencies ( term Freq Map , vector , field Name ) ; } } return create Queue ( term Freq Map ) ; }
public static String build Download Url ( String server , int size , String device Id , String timestamp ) { String download Url = server + STR_ + size + STR_ + device Id + STR_ + timestamp ; return download Url ; }
@ Override public void put ( long index , int value ) { index <<= NUM_ ; if ( index < file Length ) { final Byte Buffer buf = buffers [ get Which Buffer ( index ) ] ; int index Buffer = get Index In Buffer ( index ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > NUM_ ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > NUM_ ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > NUM_ ) ) ; buf . put ( index Buffer , ( byte ) ( value ) ) ; } else { throw new Array Index Out Of Bounds Exception ( STR_ + index ) ; } }
protected Events Envelope make Event Envelope ( Assignment assignment , Event event ) { return new Events Envelope ( assignment , event , transaction Factory . new Transaction ( ) ) ; }
private Annotated Type Variable create Annotated Type Var ( final Type Variable type Variable , final Annotated Type Factory type Factory ) { return ( Annotated Type Variable ) type Factory . get Annotated Type ( type Variable . as Element ( ) ) ; }
public void add Recent File ( File f ) { if ( null != f ) { recent Files . add ( f ) ; } }
boolean reserve For Become Primary ( ) { synchronized ( Bucket Advisor . this ) { if ( this . volunteering Thread != null ) { return false ; } this . aggressive = true ; return true ; } }
public void add Edit Pop Up Menu ( J Menu Item menu ) { if ( ! edit Additional Menu . contains ( menu ) ) { edit Additional Menu . add ( menu ) ; } }
public static void append Connections ( Vector < Bean Connection > connections , int tab ) { if ( tab < TABBED CONNECTIONS . size ( ) ) { Vector < Bean Connection > cons = TABBED CONNECTIONS . get ( tab ) ; for ( int i = NUM_ ; i < connections . size ( ) ; i ++ ) { cons . add ( connections . get ( i ) ) ; } } }
private void safe Damage Range ( int a 0 , int a 1 ) throws Bad Location Exception { Document doc = component . get Document ( ) ; safe Damage Range ( doc . create Position ( a 0 ) , doc . create Position ( a 1 ) ) ; }
protected static void channel Copy ( Readable Byte Channel from , Writable Byte Channel to ) throws IO Exception { Byte Buffer buffer = Byte Buffer . allocate Direct ( NUM_ * NUM_ ) ; try { while ( from . read ( buffer ) != - NUM_ ) { buffer . flip ( ) ; to . write ( buffer ) ; buffer . compact ( ) ; } buffer . flip ( ) ; while ( buffer . has Remaining ( ) ) { to . write ( buffer ) ; } } finally { if ( from != null ) { try { from . close ( ) ; } catch ( Exception ex ) { } } if ( to != null ) { try { to . close ( ) ; } catch ( Exception ex ) { } } } }
public double [ ] distribution For Instance ( Instance instance ) throws Exception { return m Classifier . distribution For Instance ( instance ) ; }
public String printable Unique Key ( org . apache . lucene . document . Document doc ) { Indexable Field f = doc . get Field ( unique Key Field Name ) ; return f == null ? null : unique Key Field Type . to External ( f ) ; }
public void select Cells For Event ( Object [ ] cells , Mouse Event event ) { if ( is Toggle Event ( event ) ) { graph . add Selection Cells ( cells ) ; } else { graph . set Selection Cells ( cells ) ; } }
protected final void print Help ( ) { final Print Writer writer = new Print Writer ( System . out ) ; final Help Formatter help Formatter = new Help Formatter ( ) ; help Formatter . print Help ( writer , HELP LINE WIDTH , name , STR_ , options , HELP LINE PADDING , HELP LINE DESCRIPTION PADDING , STR_ , true ) ; writer . close ( ) ; }
public static void main ( String [ ] args ) { try ( Tee Stream tee Stream = new Tee Stream ( System . out , Paths . get ( STR_ ) ) ; Print Stream out = new Print Stream ( tee Stream ) ) { out . print ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; System . exit ( NUM_ ) ; } }
private static void delete Directory On Exit ( File directory ) throws IO Exception { if ( ! directory . exists ( ) ) { return ; } directory . delete On Exit ( ) ; if ( ! is Symlink ( directory ) ) { clean Directory On Exit ( directory ) ; } }
public Vector < Integer > find Central Tendencies ( double [ ] pred Probs ) { int central T Value = NUM_ ; int current Value = NUM_ ; Vector < Integer > central T Classes ; central T Classes = new Vector < Integer > ( ) ; for ( int i = NUM_ ; i < pred Probs . length ; i ++ ) { current Value = ( int ) pred Probs [ i ] ; if ( current Value > central T Value ) { central T Classes . clear ( ) ; central T Classes . add Element ( new Integer ( i ) ) ; central T Value = current Value ; } else if ( current Value != NUM_ && current Value == central T Value ) { central T Classes . add Element ( new Integer ( i ) ) ; } } if ( central T Value != NUM_ ) { return central T Classes ; } else { return null ; } }
public void register Installation ( ) { try { File timestamp File = new File ( get Extract Dir ( ) , STR_ ) ; Buffered Writer bw = new Buffered Writer ( new File Writer ( timestamp File ) ) ; bw . write ( STR_ ) ; bw . close ( ) ; } catch ( Exception e ) { } }
public void flush ( ) throws IO Exception { if ( print Writer != null ) { print Writer . flush ( ) ; } if ( gzip Output Stream != null ) { gzip Output Stream . flush ( ) ; } }
private void generate Gaussian Examples ( Instances format , int num Instances , Random random , Subspace Cluster Definition cl , String c Name ) { boolean make Integer = cl . is Integer ( ) ; Instance example = null ; int num Atts = m Num Attributes ; if ( get Class Flag ( ) ) { num Atts ++ ; } example = new Dense Instance ( num Atts ) ; example . set Dataset ( format ) ; boolean [ ] attributes = cl . get Attributes ( ) ; double [ ] mean Value = cl . get Mean Value ( ) ; double [ ] stddev Value = cl . get Stddev Value ( ) ; for ( int j = NUM_ ; j < num Instances ; j ++ ) { int num = - NUM_ ; for ( int i = NUM_ ; i < m Num Attributes ; i ++ ) { if ( attributes [ i ] ) { num ++ ; double value = mean Value [ num ] + ( random . next Gaussian ( ) * stddev Value [ num ] ) ; if ( make Integer ) { value = Math . round ( value ) ; } example . set Value ( i , value ) ; } else { example . set Missing ( i ) ; } } if ( get Class Flag ( ) ) { example . set Class Value ( c Name ) ; } format . add ( example ) ; } }
public void delete All Dimension Rows ( ) { try { String dim Row Indexes = key Value Store . get ( Dimension Store Key Utils . get All Values Key ( ) ) ; if ( dim Row Indexes == null ) { LOG . debug ( STR_ , api Name ) ; return ; } String [ ] keys = object Mapper . read Value ( dim Row Indexes , String [ ] . class ) ; Linked Hash Set < String > dim Row Keys = new Linked Hash Set < > ( Arrays . as List ( keys ) ) ; for ( String dim Row Key : dim Row Keys ) { key Value Store . remove ( dim Row Key ) ; } search Provider . set Key Value Store ( key Value Store ) ; key Value Store . put ( Dimension Store Key Utils . get Cardinality Key ( ) , STR_ ) ; String all Values Key = Dimension Store Key Utils . get All Values Key ( ) ; key Value Store . put ( all Values Key , STR_ ) ; } catch ( IO Exception e ) { LOG . error ( STR_ , e ) ; throw new Runtime Exception ( e ) ; } }
synchronized protected void timeout ( ) { J Option Pane . show Message Dialog ( null , STR_ , STR_ , J Option Pane . ERROR MESSAGE ) ; state = State . IDLE ; }
@ Override public Iterator < I Database > iterator ( ) { return m databases . iterator ( ) ; }
private String base phone number ( ) throws Parse Exception { String Buffer s = new String Buffer ( ) ; if ( debug ) dbg enter ( STR_ ) ; try { int lc = NUM_ ; while ( lexer . has More Chars ( ) ) { char w = lexer . look Ahead ( NUM_ ) ; if ( Lexer . is Digit ( w ) || w == STR_ || w == STR_ || w == STR_ || w == STR_ ) { lexer . consume ( NUM_ ) ; s . append ( w ) ; lc ++ ; } else if ( lc > NUM_ ) break ; else throw create Parse Exception ( STR_ + w ) ; } return s . to String ( ) ; } finally { if ( debug ) dbg leave ( STR_ ) ; } }
protected void tear Down ( ) throws Exception { super . tear Down ( ) ; if ( oos != null ) { try { oos . close ( ) ; } catch ( Exception e ) { } } if ( oos ioe != null ) { try { oos ioe . close ( ) ; } catch ( Exception e ) { } } if ( f != null && f . exists ( ) ) { if ( ! f . delete ( ) ) { fail ( STR_ ) ; } } }
public static void main ( String [ ] args ) { Log . print Line ( STR_ ) ; try { int num user = NUM_ ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = false ; Cloud Sim . init ( num user , calendar , trace flag ) ; Datacenter datacenter 0 = create Datacenter ( STR_ ) ; Datacenter Broker broker = create Broker ( ) ; int broker Id = broker . get Id ( ) ; vmlist = new Array List < Vm > ( ) ; int vmid = NUM_ ; int mips = NUM_ ; long size = NUM_ ; int ram = NUM_ ; long bw = NUM_ ; int pes Number = NUM_ ; String vmm = STR_ ; Vm vm 1 = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmlist . add ( vm 1 ) ; broker . submit Vm List ( vmlist ) ; cloudlet List = new Array List < Cloudlet > ( ) ; int id = NUM_ ; long length = NUM_ ; long file Size = NUM_ ; long output Size = NUM_ ; Utilization Model utilization Model = new Utilization Model Full ( ) ; Cloudlet cloudlet 1 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 1 . set User Id ( broker Id ) ; cloudlet List . add ( cloudlet 1 ) ; broker . submit Cloudlet List ( cloudlet List ) ; Network Topology . add Link ( datacenter 0 . get Id ( ) , broker . get Id ( ) , NUM_ , NUM_ ) ; Cloud Sim . start Simulation ( ) ; List < Cloudlet > new List = broker . get Cloudlet Received List ( ) ; Cloud Sim . stop Simulation ( ) ; print Cloudlet List ( new List ) ; Log . print Line ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STR_ ) ; } }
@ Override public synchronized Object execute Task ( Task t ) throws Remote Exception { String task Id = STR_ + System . current Time Millis ( ) + STR_ ; task Id += t . hash Code ( ) ; add Task To Queue ( t , task Id ) ; return task Id ; }
public void render Data For Projection ( Projection proj , Graphics g ) { if ( is Projection OK ( proj ) ) { paint ( g ) ; } }
public double weight Value ( int n ) { if ( n >= m num Inputs || n < - NUM_ ) { return Double . Na N ; } return m weights [ n + NUM_ ] ; }
public void prepare ( ) throws IO Exception { int buffers = number Of Buffers ; if ( buffers < MIN BUFFERS ) { buffers = MIN BUFFERS ; } else if ( buffers > MAX BUFFERS ) { buffers = MAX BUFFERS ; } for ( int i = NUM_ ; i < buffers ; i ++ ) { Byte Buffer byte Buffer = byte Buffer Provider . acquire Byte Buffer ( ) ; empty Buffers . add ( byte Buffer ) ; } }
public static Vector Discard Last Element ( Vector v ) { if ( v . size ( ) > NUM_ ) v . remove ( v . size ( ) - NUM_ ) ; return v ; }
static byte read Extra Flags ( Byte Buffer buffer , int offset , Jet Format format ) { int ext Flags Offset = format . OFFSET COLUMN EXT FLAGS ; return ( ( ext Flags Offset >= NUM_ ) ? buffer . get ( offset + ext Flags Offset ) : NUM_ ) ; }
@ Override public Iterator iterator ( ) { return new Entry Iterator ( set . iterator ( ) ) ; }
private void determine Available Sample Rates ( ) throws Lib Usb Exception , Usb Exception { m Sample Rates . clear ( ) ; try { byte [ ] raw Count = read Array ( Command . GET SAMPLE RATES , NUM_ , NUM_ , NUM_ ) ; if ( raw Count != null ) { int count = Endian Utils . read Swapped Integer ( raw Count , NUM_ ) ; byte [ ] raw Rates = read Array ( Command . GET SAMPLE RATES , NUM_ , count , ( count * NUM_ ) ) ; for ( int x = NUM_ ; x < count ; x ++ ) { int rate = Endian Utils . read Swapped Integer ( raw Rates , ( x * NUM_ ) ) ; m Sample Rates . add ( new Airspy Sample Rate ( x , rate , format Sample Rate ( rate ) ) ) ; } } } catch ( Lib Usb Exception e ) { } if ( m Sample Rates . is Empty ( ) ) { m Sample Rates . add ( DEFAULT SAMPLE RATE ) ; } }
public static void silent Close Output Stream ( Output Stream os ) { try { if ( os != null ) { os . close ( ) ; } } catch ( IO Exception e ) { Log . w ( LOG TAG , STR_ , e ) ; } }
public Query Task wait For Query Task ( URI uri , Task State . Task Stage expected Stage ) { List < Task State . Task Stage > final Task Stages = Arrays . as List ( Task State . Task Stage . CANCELLED , Task State . Task Stage . FAILED , Task State . Task Stage . FINISHED , expected Stage ) ; String error = String . format ( STR_ , expected Stage ) ; Object [ ] r = new Object [ NUM_ ] ; final URI final Uri = uri ; wait For ( error , null ) ; return ( Query Task ) r [ NUM_ ] ; }
public String generate Export Group Remove Volumes Cleanup ( Workflow workflow , String previous Step , Storage System storage , Export Group export Group , List < URI > volume UR Is , List < URI > initiator UR Is ) { URI export Group URI = export Group . get Id ( ) ; URI storage URI = storage . get Id ( ) ; String cleanup Step = workflow . create Step Id ( ) ; Export Task Completer export Task Completer = new Export Group Remove Volumes Cleanup Completer ( export Group URI , cleanup Step ) ; Workflow . Method cleanup Execute Method = new Workflow . Method ( STR_ , storage URI , export Group URI , volume UR Is , initiator UR Is , export Task Completer ) ; cleanup Step = workflow . create Step ( EXPORT GROUP CLEANUP TASK , String . format ( STR_ , export Group . get Label ( ) ) , previous Step , storage URI , storage . get System Type ( ) , Masking Workflow Entry Points . class , cleanup Execute Method , null , cleanup Step ) ; return cleanup Step ; }
public void connect ( String view ) { try { reader = new Net Map Reader ( server , port , this , view ) ; reader . start ( ) ; if ( server Panel != null ) { server Addr Field . set Enabled ( false ) ; server Port Field . set Enabled ( false ) ; control Button . set Text ( Server Disconnect Cmd ) ; control Button . set Action Command ( Server Disconnect Cmd ) ; } } catch ( IO Exception e ) { Debug . message ( STR_ , STR_ + e ) ; disconnect ( ) ; } }
public void and With ( Or Condition other ) { List < And Condition > expanded Expression Children = new Array List < And Condition > ( ) ; for ( And Condition other Expr Term : other . get And Terms ( ) ) { for ( And Condition current Expr : children ) { And Condition current And Condition Copy = current Expr . copy ( ) ; current And Condition Copy . and With ( other Expr Term . get Terms ( ) ) ; expanded Expression Children . add ( current And Condition Copy ) ; } } children = expanded Expression Children ; }
public Collection < Grid Query Type Descriptor > types ( @ Nullable String space ) { Collection < Grid Query Type Descriptor > space Types = new Array List < > ( Math . min ( NUM_ , types . size ( ) ) ) ; for ( Map . Entry < Type Id , Type Descriptor > e : types . entry Set ( ) ) { Type Descriptor desc = e . get Value ( ) ; if ( desc . registered ( ) && F . eq ( e . get Key ( ) . space , space ) ) space Types . add ( desc ) ; } return space Types ; }
private void write Object ( Object Output Stream s ) throws java . io . IO Exception { s . default Write Object ( ) ; s . write Object ( to String ( ) ) ; }
@ Override public void draw Domain Marker ( Graphics 2 D g 2 , Category Plot plot , Category Axis axis , Category Marker marker , Rectangle 2 D data Area ) { Comparable category = marker . get Key ( ) ; Category Dataset dataset = plot . get Dataset ( plot . get Index Of ( this ) ) ; int column Index = dataset . get Column Index ( category ) ; if ( column Index < NUM_ ) { return ; } final Composite saved Composite = g 2 . get Composite ( ) ; g 2 . set Composite ( Alpha Composite . get Instance ( Alpha Composite . SRC OVER , marker . get Alpha ( ) ) ) ; Plot Orientation orientation = plot . get Orientation ( ) ; Rectangle 2 D bounds ; if ( marker . get Draw As Line ( ) ) { double v = axis . get Category Middle ( column Index , dataset . get Column Count ( ) , data Area , plot . get Domain Axis Edge ( ) ) ; Line 2 D line = null ; if ( orientation == Plot Orientation . HORIZONTAL ) { line = new Line 2 D . Double ( data Area . get Min X ( ) , v , data Area . get Max X ( ) , v ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { line = new Line 2 D . Double ( v , data Area . get Min Y ( ) , v , data Area . get Max Y ( ) ) ; } else { throw new Illegal State Exception ( ) ; } g 2 . set Paint ( marker . get Paint ( ) ) ; g 2 . set Stroke ( marker . get Stroke ( ) ) ; g 2 . draw ( line ) ; bounds = line . get Bounds 2 D ( ) ; } else { double v 0 = axis . get Category Start ( column Index , dataset . get Column Count ( ) , data Area , plot . get Domain Axis Edge ( ) ) ; double v 1 = axis . get Category End ( column Index , dataset . get Column Count ( ) , data Area , plot . get Domain Axis Edge ( ) ) ; Rectangle 2 D area = null ; if ( orientation == Plot Orientation . HORIZONTAL ) { area = new Rectangle 2 D . Double ( data Area . get Min X ( ) , v 0 , data Area . get Width ( ) , ( v 1 - v 0 ) ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { area = new Rectangle 2 D . Double ( v 0 , data Area . get Min Y ( ) , ( v 1 - v 0 ) , data Area . get Height ( ) ) ; } g 2 . set Paint ( marker . get Paint ( ) ) ; g 2 . fill ( area ) ; bounds = area ; } String label = marker . get Label ( ) ; Rectangle Anchor anchor = marker . get Label Anchor ( ) ; if ( label != null ) { Font label Font = marker . get Label Font ( ) ; g 2 . set Font ( label Font ) ; g 2 . set Paint ( marker . get Label Paint ( ) ) ; Point 2 D coordinates = calculate Domain Marker Text Anchor Point ( g 2 , orientation , data Area , bounds , marker . get Label Offset ( ) , marker . get Label Offset Type ( ) , anchor ) ; Text Utilities . draw Aligned String ( label , g 2 , ( float ) coordinates . get X ( ) , ( float ) coordinates . get Y ( ) , marker . get Label Text Anchor ( ) ) ; } g 2 . set Composite ( saved Composite ) ; }
public Asic Container Verifier ( String filename ) throws Exception { try ( File Input Stream in = new File Input Stream ( filename ) ) { asic = Asic Container . read ( in ) ; } }
public static Compact Sketch intersect ( Compact Sketch sk A , Compact Sketch sk B ) { final short seed Hash = check Ordered And Seed Hash ( sk A , sk B ) ; long theta Long = Math . min ( sk A . get Theta Long ( ) , sk B . get Theta Long ( ) ) ; int index A = NUM_ ; int index B = NUM_ ; int out Count = NUM_ ; long [ ] cache A = sk A . get Cache ( ) ; long [ ] cache B = sk B . get Cache ( ) ; long [ ] out Cache = new long [ Math . min ( cache A . length , cache B . length ) ] ; while ( ( index A < cache A . length ) && ( index B < cache B . length ) ) { long hash A = cache A [ index A ] ; long hash B = cache B [ index B ] ; if ( hash A >= theta Long || hash B >= theta Long ) { break ; } if ( hash A == hash B ) { out Cache [ out Count ++ ] = hash A ; ++ index A ; ++ index B ; } else if ( hash A < hash B ) { ++ index A ; } else { ++ index B ; } } boolean empty = sk A . is Empty ( ) || sk B . is Empty ( ) ; return new Heap Compact Ordered Sketch ( Arrays . copy Of ( out Cache , out Count ) , empty , seed Hash , out Count , theta Long ) ; }
public void append Local Variable Label ( I Local Variable local Variable , long flags ) { if ( get Flag ( flags , Java Element Labels . F PRE TYPE SIGNATURE ) ) { append Type Signature Label ( local Variable , local Variable . get Type Signature ( ) , flags ) ; f Buffer . append ( STR_ ) ; } if ( get Flag ( flags , Java Element Labels . F FULLY QUALIFIED ) ) { append Element Label ( local Variable . get Declaring Member ( ) , Java Element Labels . M PARAMETER TYPES | Java Element Labels . M FULLY QUALIFIED | Java Element Labels . T FULLY QUALIFIED | ( flags & QUALIFIER FLAGS ) ) ; f Buffer . append ( STR_ ) ; } f Buffer . append ( get Element Name ( local Variable ) ) ; if ( get Flag ( flags , Java Element Labels . F APP TYPE SIGNATURE ) ) { int offset = f Buffer . length ( ) ; f Buffer . append ( Java Element Labels . DECL STRING ) ; append Type Signature Label ( local Variable , local Variable . get Type Signature ( ) , flags ) ; if ( get Flag ( flags , Java Element Labels . COLORIZE ) ) { } } if ( get Flag ( flags , Java Element Labels . F POST QUALIFIED ) ) { f Buffer . append ( Java Element Labels . CONCAT STRING ) ; append Element Label ( local Variable . get Declaring Member ( ) , Java Element Labels . M PARAMETER TYPES | Java Element Labels . M FULLY QUALIFIED | Java Element Labels . T FULLY QUALIFIED | ( flags & QUALIFIER FLAGS ) ) ; } }
public static Set < String > comma Delimited List To Set ( String str ) { Set < String > set = new Tree Set < String > ( ) ; String [ ] tokens = comma Delimited List To String Array ( str ) ; for ( String token : tokens ) { set . add ( token ) ; } return set ; }
public static void app launched ( Context m Context ) { Shared Preferences prefs = m Context . get Shared Preferences ( STR_ , NUM_ ) ; if ( prefs . get Boolean ( STR_ , false ) ) { return ; } Shared Preferences . Editor editor = prefs . edit ( ) ; long launch count = prefs . get Long ( STR_ , NUM_ ) + NUM_ ; editor . put Long ( STR_ , launch count ) ; Long date first Launch = prefs . get Long ( STR_ , NUM_ ) ; if ( date first Launch == NUM_ ) { date first Launch = System . current Time Millis ( ) ; editor . put Long ( STR_ , date first Launch ) ; } if ( launch count >= LAUNCHES UNTIL PROMPT ) { if ( System . current Time Millis ( ) >= date first Launch + ( DAYS UNTIL PROMPT * NUM_ * NUM_ * NUM_ * NUM_ ) ) { show Rate Dialog ( m Context , editor ) ; } } editor . apply ( ) ; }
private String create Workflow Step For Restore Native Full Copy ( Workflow workflow , Storage System native System , List < URI > native Full Copy UR Is , String wait For , Workflow . Method rollback Method ) { URI native System URI = native System . get Id ( ) ; Workflow . Method restore Volume Method = new Workflow . Method ( RESTORE FROM FC METHOD NAME , native System URI , native Full Copy UR Is , Boolean . FALSE ) ; workflow . create Step ( RESTORE VOLUME STEP , String . format ( STR_ , native Full Copy UR Is ) , wait For , native System URI , native System . get System Type ( ) , Block Device Controller . class , restore Volume Method , rollback Method , null ) ; log . info ( STR_ , native Full Copy UR Is ) ; return RESTORE VOLUME STEP ; }
public static double incomplete Beta Fraction 1 ( double a , double b , double x ) { double xk , pk , pkm 1 , pkm 2 , qk , qkm 1 , qkm 2 ; double k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 ; double r , t , ans , thresh ; int n ; k 1 = a ; k 2 = a + b ; k 3 = a ; k 4 = a + NUM_ ; k 5 = NUM_ ; k 6 = b - NUM_ ; k 7 = k 4 ; k 8 = a + NUM_ ; pkm 2 = NUM_ ; qkm 2 = NUM_ ; pkm 1 = NUM_ ; qkm 1 = NUM_ ; ans = NUM_ ; r = NUM_ ; n = NUM_ ; thresh = NUM_ * MACHEP ; do { xk = - ( x * k 1 * k 2 ) / ( k 3 * k 4 ) ; pk = pkm 1 + pkm 2 * xk ; qk = qkm 1 + qkm 2 * xk ; pkm 2 = pkm 1 ; pkm 1 = pk ; qkm 2 = qkm 1 ; qkm 1 = qk ; xk = ( x * k 5 * k 6 ) / ( k 7 * k 8 ) ; pk = pkm 1 + pkm 2 * xk ; qk = qkm 1 + qkm 2 * xk ; pkm 2 = pkm 1 ; pkm 1 = pk ; qkm 2 = qkm 1 ; qkm 1 = qk ; if ( qk != NUM_ ) r = pk / qk ; if ( r != NUM_ ) { t = Math . abs ( ( ans - r ) / r ) ; ans = r ; } else t = NUM_ ; if ( t < thresh ) return ans ; k 1 += NUM_ ; k 2 += NUM_ ; k 3 += NUM_ ; k 4 += NUM_ ; k 5 += NUM_ ; k 6 -= NUM_ ; k 7 += NUM_ ; k 8 += NUM_ ; if ( ( Math . abs ( qk ) + Math . abs ( pk ) ) > big ) { pkm 2 *= biginv ; pkm 1 *= biginv ; qkm 2 *= biginv ; qkm 1 *= biginv ; } if ( ( Math . abs ( qk ) < biginv ) || ( Math . abs ( pk ) < biginv ) ) { pkm 2 *= big ; pkm 1 *= big ; qkm 2 *= big ; qkm 1 *= big ; } } while ( ++ n < NUM_ ) ; return ans ; }
public String trim Coord URI ( String uri ) { if ( ! uri . starts With ( url Prefix ) ) { throw new Geo Spatial Search Exception ( STR_ ) ; } return uri . substring ( url Prefix . length ( ) ) ; }
protected void display Get Summary ( final Get Status status ) { if ( ! should Display Summary ( status ) ) { return ; } display Get Status ( status ) ; for ( final Get Event e : get Warning List ) { display Get Event ( e , e . get Target Local Item ( ) ) ; } display Errors ( ) ; }
public void print Result ( Print Stream output , String title , Histogram other ) { output . println ( title ) ; if ( count == NUM_ ) { output . println ( STR_ ) ; return ; } output . println ( STR_ + count + STR_ + other . count + STR_ ) ; for ( int i = NUM_ ; i < results . length ; i ++ ) { if ( i == NUM_ ) output . printf ( STR_ , limits [ NUM_ ] , results [ i ] , other . results [ i ] ) ; else if ( i == results . length - NUM_ ) { output . printf ( STR_ , limits [ limits . length - NUM_ ] , results [ i ] , other . results [ i ] ) ; } else { output . printf ( STR_ , limits [ i - NUM_ ] , limits [ i ] , results [ i ] , other . results [ i ] ) ; } output . printf ( STR_ , ( double ) results [ i ] * NUM_ / count , ( double ) other . results [ i ] * NUM_ / other . count ) ; } output . println ( ) ; }
protected Vector Format ( final String prefix , final String suffix , final String separator , final Number Format format ) { this . prefix = prefix ; this . suffix = suffix ; this . separator = separator ; trimmed Prefix = prefix . trim ( ) ; trimmed Suffix = suffix . trim ( ) ; trimmed Separator = separator . trim ( ) ; this . format = format ; }
public Pla Point Int round to grid ( int p horizontal grid , int p vertical grid ) { double rounded x ; if ( p horizontal grid > NUM_ ) { rounded x = Math . rint ( v x / p horizontal grid ) * p horizontal grid ; } else { rounded x = v x ; } double rounded y ; if ( p vertical grid > NUM_ ) { rounded y = Math . rint ( v y / p vertical grid ) * p vertical grid ; } else { rounded y = v y ; } return new Pla Point Int ( rounded x , rounded y ) ; }
public Header on Get Initial Header ( ) { for ( int i = NUM_ ; i < m Headers . size ( ) ; i ++ ) { Header h = m Headers . get ( i ) ; if ( h . fragment != null ) { return h ; } } throw new Illegal State Exception ( STR_ ) ; }
public static Integer extract Partition Name ( String file Name , Partitioner Type partitioner ) { if ( partitioner == Partitioner Type . MODULUS || partitioner == Partitioner Type . CASCADING ) { if ( ! file Name . starts With ( Constants . FILE PREFIX ) ) { return null ; } try { return Integer . parse Int ( file Name . substring ( NUM_ , NUM_ ) ) ; } catch ( Number Format Exception e ) { return null ; } } return null ; }
private Map < String , Set < String > > gather Requested Claims ( O Auth 2 Provider Settings provider Settings , String claims Json , String object Name ) { final Map < String , Set < String > > requested Claims = new Hash Map < String , Set < String > > ( ) ; try { if ( provider Settings . get Claims Parameter Supported ( ) && claims Json != null ) { try { final JSON Object claims Object = new JSON Object ( claims Json ) ; JSON Object sub Claims Request = claims Object . get JSON Object ( object Name ) ; Iterator < String > it = sub Claims Request . keys ( ) ; while ( it . has Next ( ) ) { final String key Name = it . next ( ) ; JSON Object opt Obj = sub Claims Request . opt JSON Object ( key Name ) ; final Hash Set < String > options = new Hash Set < String > ( ) ; if ( opt Obj != null ) { final JSON Array opt Array = opt Obj . opt JSON Array ( O Auth 2 Constants . Params . VALUES ) ; if ( opt Array != null ) { for ( int i = NUM_ ; i < opt Array . length ( ) ; i ++ ) { options . add ( opt Array . get String ( i ) ) ; } } final String value = opt Obj . opt String ( O Auth 2 Constants . Params . VALUE ) ; if ( ! String Utils . is Blank ( value ) ) { options . add ( value ) ; } } requested Claims . put ( key Name , options ) ; } } catch ( JSON Exception e ) { } } } catch ( Server Exception e ) { logger . message ( STR_ ) ; } return requested Claims ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! ( obj instanceof RFC 822 Name ) ) return false ; RFC 822 Name other = ( RFC 822 Name ) obj ; return name . equals Ignore Case ( other . name ) ; }
public static String collection To Delimited String ( Collection < String > coll , String delim ) { return collection To Delimited String ( coll , delim , STR_ , STR_ ) ; }
public void create Database Entities For Business Object Data Availability Testing ( String partition Key Group Name , List < Schema Column > columns , List < Schema Column > partition Columns , int partition Column Position , List < String > sub Partition Values , boolean allow Duplicate Business Object Data ) { create Database Entities For Business Object Data Availability Testing ( partition Key Group Name , columns , partition Columns , partition Column Position , sub Partition Values , allow Duplicate Business Object Data , Arrays . as List ( Abstract Dao Test . STORAGE NAME ) ) ; }
public void property Change ( Property Change Event pce ) { if ( pce . get Property Name ( ) == Map Bean . Background Property ) { map Bean . set Bckgrnd ( ( Paint ) pce . get New Value ( ) ) ; } }
public @ Check For Null Block create New Block ( @ Nonnull String system Name , @ Check For Null String user Name ) throws Illegal Argument Exception { Block r ; if ( user Name != null && ! user Name . equals ( STR_ ) ) { r = get By User Name ( user Name ) ; if ( r != null ) { return null ; } } r = get By System Name ( system Name ) ; if ( r != null ) { return null ; } String s Name = system Name . to Upper Case ( ) ; r = new Block ( s Name , user Name ) ; register ( r ) ; if ( system Name . starts With ( STR_ ) ) { try { int auto Number = Integer . parse Int ( system Name . substring ( NUM_ ) ) ; if ( auto Number > last Auto Block Ref ) { last Auto Block Ref = auto Number ; } } catch ( Number Format Exception e ) { log . warn ( STR_ + system Name + STR_ ) ; } } try { r . set Block Speed ( STR_ ) ; } catch ( jmri . Jmri Exception ex ) { log . error ( ex . to String ( ) ) ; } return r ; }
public static String deployment Action In Progress Feedback ( final String id ) throws JSON Exception { return deployment Action Feedback ( id , STR_ ) ; }
private void write Deflated ( byte [ ] b , int offset , int length ) throws IO Exception { if ( length > NUM_ && ! def . finished ( ) ) { entry . bytes Read += length ; if ( length <= DEFLATER BLOCK SIZE ) { def . set Input ( b , offset , length ) ; deflate Until Input Is Needed ( ) ; } else { final int fullblocks = length / DEFLATER BLOCK SIZE ; for ( int i = NUM_ ; i < fullblocks ; i ++ ) { def . set Input ( b , offset + i * DEFLATER BLOCK SIZE , DEFLATER BLOCK SIZE ) ; deflate Until Input Is Needed ( ) ; } final int done = fullblocks * DEFLATER BLOCK SIZE ; if ( done < length ) { def . set Input ( b , offset + done , length - done ) ; deflate Until Input Is Needed ( ) ; } } } }
public static Logger log ( ) { if ( nervous system == null ) nervous system = new Logger ( STR_ , Logger . ATTR TIME | Logger . ATTR COLOR ) ; return nervous system ; }
public synchronized Storage Capability [ ] query Storage Capabilities ( String [ ] cap Ids ) throws Invalid Argument , Invalid Session , Storage Fault , Not Implemented { final String method Name = STR_ ; log . debug ( method Name + STR_ ) ; List < Storage Capability > return List = null ; List < Co S > cos List = null ; try { Boolean supports Capability = new Boolean ( config . get Config Value ( STR_ ) ) ; if ( ! supports Capability ) { log . error ( method Name + STR_ ) ; throw Fault Util . Not Implemented ( STR_ ) ; } if ( Util . is Empty ( cap Ids ) ) { log . debug ( method Name + STR_ + cap Ids ) ; cos List = sync Manager . get Cos Detail List ( ) ; } else { for ( String input Cap Id : cap Ids ) { if ( ! Util . is Empty ( input Cap Id ) ) { if ( ! input Cap Id . starts With ( COS IDENTIFIER PREFIX ) ) { throw Fault Util . Invalid Argument ( STR_ + input Cap Id ) ; } } else { throw Fault Util . Invalid Argument ( STR_ + input Cap Id ) ; } } List < String > input Cap Id List = Arrays . as List ( cap Ids ) ; log . debug ( method Name + STR_ + input Cap Id List ) ; cos List = sync Manager . get Cos Detail List ( input Cap Id List ) ; } return List = new Array List < Storage Capability > ( ) ; for ( Co S cos : cos List ) { Storage Capability capability = new Storage Capability ( ) ; capability . set Unique Identifier ( cos . get Id ( ) ) ; capability . set Capability Name ( cos . get Label ( ) + STR_ + cos . get Type ( ) ) ; capability . set Capability Detail ( cos . get Description ( ) ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( method Name + STR_ + capability . get Unique Identifier ( ) + STR_ + capability . get Capability Name ( ) + STR_ + capability . get Capability Detail ( ) + STR_ ) ; } return List . add ( capability ) ; } } catch ( SOS Failure e ) { log . error ( method Name + STR_ , e ) ; throw Fault Util . Storage Fault ( e ) ; } catch ( Invalid Argument e ) { log . error ( method Name + STR_ , e ) ; throw e ; } catch ( Not Implemented e ) { log . error ( method Name + STR_ , e ) ; throw e ; } return return List . to Array ( new Storage Capability [ NUM_ ] ) ; }
private static void attach To ( J Slider c ) { Mouse Motion Listener [ ] listeners = c . get Mouse Motion Listeners ( ) ; for ( Mouse Motion Listener m : listeners ) { if ( m instanceof Track Listener ) { c . remove Mouse Motion Listener ( m ) ; Snap Listener listen = new Snap Listener ( m , ( Basic Slider UI ) c . get UI ( ) , c ) ; c . add Mouse Motion Listener ( listen ) ; c . add Mouse Listener ( listen ) ; c . add Property Change Listener ( STR_ , listen ) ; } } }
public void cancel Button Action Performed ( ) { edit Mode = false ; cur Node = null ; add Button . set Visible ( true ) ; edit Button . set Visible ( true ) ; delete Button . set Visible ( true ) ; done Button . set Visible ( true ) ; update Button . set Visible ( false ) ; cancel Button . set Visible ( false ) ; node Addr Field . set Visible ( true ) ; node Addr Static . set Visible ( false ) ; status Text 1 . set Text ( std Status 1 ) ; status Text 2 . set Text ( std Status 2 ) ; status Text 3 . set Text ( std Status 3 ) ; }
public Number Validator ( @ Non Null final Char Sequence error Message ) { super ( error Message , REGEX ) ; }
private static Char Set do Parse String ( String s ) { Char Set result = new Char Set ( ) ; int p = NUM_ ; boolean have Dash = false ; boolean have Tilde = false ; boolean w Is Real = false ; int w = NUM_ ; while ( p < s . length ( ) ) { int c = s . code Point At ( p ) ; if ( c == STR_ ) { if ( w Is Real ) { result . internal Union ( new Char Set ( w ) ) ; } int bracket Level = NUM_ ; int q = p + NUM_ ; while ( bracket Level != NUM_ ) { if ( q >= s . length ( ) ) { throw new Illegal Argument Exception ( STR_ + p + STR_ + s ) ; } int ch = s . code Point At ( q ) ; switch ( ch ) { case STR_ : ch = s . code Point At ( ++ q ) ; break ; case STR_ : ++ bracket Level ; break ; case STR_ : -- bracket Level ; break ; } q += Character . char Count ( ch ) ; } -- q ; if ( ! have Tilde ) { result . internal Union ( Char Set . parse String ( s . substring ( p + NUM_ , q ) ) ) ; } else { result . internal Difference ( Char Set . parse String ( s . substring ( p + NUM_ , q ) ) ) ; } have Tilde = false ; have Dash = false ; w Is Real = false ; p = q + NUM_ ; } else if ( c == STR_ ) { if ( w Is Real ) { result . internal Union ( new Char Set ( w ) ) ; } int q = s . index Of ( STR_ , p + NUM_ ) ; if ( q == - NUM_ ) { throw new Illegal Argument Exception ( STR_ + p + STR_ + s ) ; } if ( ! have Tilde ) { result . internal Union ( char Set For Category ( s . substring ( p + NUM_ , q ) ) ) ; } else { result . internal Difference ( char Set For Category ( s . substring ( p + NUM_ , q ) ) ) ; } have Tilde = false ; have Dash = false ; w Is Real = false ; p = q + NUM_ ; } else if ( c == STR_ ) { if ( w Is Real ) { have Dash = true ; } ++ p ; } else if ( c == STR_ ) { if ( w Is Real ) { result . internal Union ( new Char Set ( w ) ) ; w Is Real = false ; } have Tilde = true ; ++ p ; if ( result . empty ( ) ) { result . internal Complement ( ) ; } } else if ( c >= STR_ && c < STR_ && ! Character . is Letter ( ( char ) c ) && ! Character . is Digit ( ( char ) c ) && c != STR_ ) { throw new Illegal Argument Exception ( STR_ + p + STR_ + s ) ; } else { if ( c == STR_ ) { ++ p ; } if ( have Dash ) { if ( s . code Point At ( p ) < w ) { throw new Illegal Argument Exception ( STR_ + Integer . to Hex String ( s . code Point At ( p ) ) + STR_ + Integer . to Hex String ( w ) + STR_ + STR_ ) ; } int ch = s . code Point At ( p ) ; if ( ! have Tilde ) { result . internal Union ( new Char Set ( w , ch ) ) ; } else { result . internal Difference ( new Char Set ( w , ch ) ) ; } p += Character . char Count ( ch ) ; have Dash = false ; have Tilde = false ; w Is Real = false ; } else if ( have Tilde ) { w = s . code Point At ( p ) ; result . internal Difference ( new Char Set ( w ) ) ; p += Character . char Count ( w ) ; have Tilde = false ; w Is Real = false ; } else if ( w Is Real ) { result . internal Union ( new Char Set ( w ) ) ; w = s . code Point At ( p ) ; p += Character . char Count ( w ) ; w Is Real = true ; } else { w = s . code Point At ( p ) ; p += Character . char Count ( w ) ; w Is Real = true ; } } } if ( w Is Real ) { result . internal Union ( new Char Set ( w ) ) ; } return result ; }
public final Char Sequence Translator with ( final Char Sequence Translator ... translators ) { final Char Sequence Translator [ ] new Array = new Char Sequence Translator [ translators . length + NUM_ ] ; new Array [ NUM_ ] = this ; System . arraycopy ( translators , NUM_ , new Array , NUM_ , translators . length ) ; return new Aggregate Translator ( new Array ) ; }
public void notify Query Stopped ( final Bound Entity song ) { synchronized ( m Running Queries ) { m Running Queries . remove ( song ) ; } }
private int find Dest Color ( int color ) { int source R = color > > NUM_ & NUM_ ; int source G = color > > NUM_ & NUM_ ; int source B = color & NUM_ ; if ( source R > NUM_ && source G > NUM_ && source B > NUM_ ) { source R = Math . max ( source R > > NUM_ , NUM_ ) ; source G = Math . max ( source G > > NUM_ , NUM_ ) ; source B = Math . max ( source B > > NUM_ , NUM_ ) ; } else { if ( color == NUM_ ) { return NUM_ ; } source R = Math . min ( source R << NUM_ , NUM_ ) ; source G = Math . min ( source G << NUM_ , NUM_ ) ; source B = Math . min ( source B << NUM_ , NUM_ ) ; } return ( ( source R << NUM_ ) & NUM_ ) | ( ( source G << NUM_ ) & NUM_ ) | ( source B & NUM_ ) ; }
private void post Init View Pager ( ) { try { Class < ? > viewpager = View Pager . class ; Field scroller = viewpager . get Declared Field ( STR_ ) ; scroller . set Accessible ( true ) ; Field interpolator = viewpager . get Declared Field ( STR_ ) ; interpolator . set Accessible ( true ) ; m Scroller = new Scroller Custom Duration ( get Context ( ) , ( Interpolator ) interpolator . get ( null ) ) ; scroller . set ( this , m Scroller ) ; } catch ( Exception e ) { } }
protected static Tuple < String , String > create Tuple ( String one , int two ) { return Matsim Xml Writer . create Tuple ( one , Integer . to String ( two ) ) ; }
private void visit Mop Method List ( List < Method Node > methods , boolean is This , Set < Mop Key > use Only If Declared Here Too , List < String > or Name Mentioned Here ) { Hash Map < Mop Key , Method Node > mops = new Hash Map < Mop Key , Method Node > ( ) ; Linked List < Method Node > mop Calls = new Linked List < Method Node > ( ) ; for ( Method Node mn : methods ) { if ( ( mn . get Modifiers ( ) & ( ACC ABSTRACT | ACC BRIDGE ) ) != NUM_ ) continue ; if ( mn . is Static ( ) ) continue ; boolean is Private = Modifier . is Private ( mn . get Modifiers ( ) ) ; if ( is This ^ is Private ) continue ; String method Name = mn . get Name ( ) ; if ( is Mop Method ( method Name ) ) { mops . put ( new Mop Key ( method Name , mn . get Parameters ( ) ) , mn ) ; continue ; } if ( method Name . starts With ( STR_ ) ) continue ; if ( ! use Only If Declared Here Too . contains ( new Mop Key ( method Name , mn . get Parameters ( ) ) ) && ! or Name Mentioned Here . contains ( method Name ) ) { continue ; } String name = get Mop Method Name ( mn , is This ) ; Mop Key key = new Mop Key ( name , mn . get Parameters ( ) ) ; if ( mops . contains Key ( key ) ) continue ; mops . put ( key , mn ) ; mop Calls . add ( mn ) ; } generate Mop Calls ( mop Calls , is This ) ; mop Calls . clear ( ) ; mops . clear ( ) ; }
private boolean check Ivy Xml File ( File ivy Xml File ) throws Parser Configuration Exception , SAX Exception , IO Exception { log ( STR_ + ivy Xml File . get Path ( ) , verbose Level ) ; XML Reader xml Reader = XML Reader Factory . create XML Reader ( ) ; Dependency Rev Checker rev Checker = new Dependency Rev Checker ( ivy Xml File ) ; xml Reader . set Content Handler ( rev Checker ) ; xml Reader . set Error Handler ( rev Checker ) ; xml Reader . parse ( new Input Source ( ivy Xml File . get Absolute Path ( ) ) ) ; return ! rev Checker . fail ; }
public synchronized void register Client Url ( String client Url ) { registered Clients . add ( client Url ) ; }
public Check Box remove Listener ( Listener listener ) { listeners . remove ( listener ) ; return this ; }
@ Override protected void calculate Thumb Size ( ) { super . calculate Thumb Size ( ) ; upper Thumb Rect . set Size ( thumb Rect . width , thumb Rect . height ) ; }
@ Override public void start Element ( String namespace , String local Name , String prefix , Attributes attributes , Deserialization Context context ) throws SAX Exception { if ( value == null ) { try { value = java Type . new Instance ( ) ; } catch ( Exception e ) { Constructor [ ] constructors = java Type . get Constructors ( ) ; if ( constructors . length > NUM_ ) { constructor To Use = constructors [ NUM_ ] ; } if ( constructor To Use == null ) { throw new SAX Exception ( Messages . get Message ( STR_ , java Type . get Name ( ) , e . to String ( ) ) ) ; } } } super . start Element ( namespace , local Name , prefix , attributes , context ) ; }
private void raise IO Exception ( String host , int port , String protocol ) { IO Exception Event io Error = new IO Exception Event ( this , host , port , protocol ) ; sip Provider . handle Event ( io Error , null ) ; set State ( SIP Dialog . TERMINATED STATE ) ; }
public static void Check For Duplicate Macros ( Vector macros ) throws Parse Algorithm Exception { int i = NUM_ ; while ( i < macros . size ( ) ) { String namei = ( ( AST . Macro ) macros . element At ( i ) ) . name ; int j = i + NUM_ ; while ( j < macros . size ( ) ) { if ( namei . equals ( ( ( AST . Macro ) macros . element At ( j ) ) . name ) ) { throw new Parse Algorithm Exception ( STR_ + namei + STR_ ) ; } j = j + NUM_ ; } i = i + NUM_ ; } }
public void add DTED Directory Handler ( DTED Directory Handler handler ) { directories . add ( handler ) ; }
public void add Handler ( String target , Synchronous Callback handler ) { handlers . put ( target , handler ) ; }
public void prep Confirm Pane ( boolean only Changes ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + only Changes ) ; } just Changes = only Changes ; enable Buttons ( false ) ; if ( is Cv Table Pane ) { set Cv List From Table ( ) ; } if ( just Changes ) { confirm Changes Button . set Enabled ( true ) ; confirm Changes Button . set Selected ( true ) ; } else { confirm All Button . set Selected ( true ) ; confirm All Button . set Enabled ( true ) ; } if ( container . is Busy ( ) == false ) { container . enable Buttons ( false ) ; } set To Read ( just Changes , true ) ; var List Index = NUM_ ; cv List Iterator = cv List . iterator ( ) ; indexed Cv List Index = NUM_ ; }
public void load Headers ( Prepared Statement Wrapper ps ) { if ( m interface . get Header Type ( ) != null && m interface . get Header Types ( ) != null ) { s logger . log ( Level . FINE , STR_ , new Object [ ] { get Header Types ( ) , get Object Type ( ) , m name , m parent . get Direction ( ) } ) ; m headers = new Hash Map < Integer , DB Object Definition > ( ) ; m interface . load Headers ( m headers , s parameters , s logger , s db Engine , m parent , m name , ps ) ; int counter = m headers . size ( ) ; String log Object = get Header Types ( ) ; if ( counter == NUM_ ) log Object = get Header Type ( ) ; s logger . log ( Level . FINE , STR_ , new Object [ ] { Integer . to String ( counter ) , log Object } ) ; } }
public static int parse Title Map ( String s ) throws Number Format Exception { int title Case = MAP UNDEFINED ; int length = s . length ( ) ; if ( length >= NUM_ && length <= NUM_ ) { title Case = Integer . parse Int ( s , NUM_ ) ; } else if ( s . length ( ) != NUM_ ) { throw new Number Format Exception ( ) ; } return title Case ; }
@ Override public void perform Backup ( Parcel File Descriptor old State , Backup Data Output data , Parcel File Descriptor new State ) { if ( VERBOSE ) Log . v ( TAG , STR_ ) ; Journal in = read Journal ( old State ) ; if ( ! launcher Is Ready ( ) ) { write Journal ( new State , in ) ; return ; } Log . v ( TAG , STR_ + in . t ) ; m Keys . clear ( ) ; apply Journal ( in ) ; long new Backup Time = System . current Time Millis ( ) ; try { backup Favorites ( data ) ; backup Screens ( data ) ; backup Icons ( data ) ; backup Widgets ( data ) ; Hash Set < String > valid Keys = new Hash Set < String > ( ) ; for ( Key key : m Keys ) { valid Keys . add ( key To Backup Key ( key ) ) ; } m Existing Keys . remove All ( valid Keys ) ; for ( String deleted : m Existing Keys ) { if ( VERBOSE ) Log . v ( TAG , STR_ + deleted ) ; data . write Entity Header ( deleted , - NUM_ ) ; } m Existing Keys . clear ( ) ; m Last Backup Restore Time = new Backup Time ; Journal state = get Current State Journal ( ) ; write Row To Backup ( JOURNAL KEY , state , data ) ; } catch ( IO Exception e ) { Log . e ( TAG , STR_ , e ) ; } write New State Description ( new State ) ; }
private static byte calculate Checksum ( byte [ ] buffer ) { byte check Sum = ( byte ) NUM_ ; for ( int i = NUM_ ; i < buffer . length - NUM_ ; i ++ ) { check Sum = ( byte ) ( check Sum ^ buffer [ i ] ) ; } logger . trace ( String . format ( STR_ , check Sum ) ) ; return check Sum ; }
public static boolean is Relay State URL Valid ( String meta Alias , String relay State , String role ) { boolean result = false ; if ( meta Alias != null ) { String realm = SAML 2 Meta Utils . get Realm By Meta Alias ( meta Alias ) ; try { String host Entity ID = saml 2 Meta Manager . get Entity By Meta Alias ( meta Alias ) ; if ( host Entity ID != null ) { validate Relay State URL ( realm , host Entity ID , relay State , role ) ; result = true ; } } catch ( SAML 2 Exception e ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + relay State + STR_ + role + STR_ + e . get Message ( ) , e ) ; } result = false ; } } if ( debug . message Enabled ( ) ) { debug . message ( STR_ + relay State + STR_ + role + STR_ + result ) ; } return result ; }
@ Request Mapping ( value = STR_ , method = { Request Method . GET , Request Method . POST } ) public void sso SSL Dummy ( Locale locale , Model model , @ Path Variable ( value = STR_ ) String tenant , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { logger . info ( STR_ + tenant ) ; try { Relying Party rp = validate Relying Party ( request , tenant ) ; if ( rp != null ) { logger . info ( STR_ + rp . get Url ( ) ) ; URL rp Url = new URL ( rp . get Url ( ) ) ; URL redirect Url = new URL ( rp Url . get Protocol ( ) , rp Url . get Host ( ) , rp Url . get Port ( ) , STR_ ) ; String redirect Url Str = redirect Url . to String ( ) + STR_ + sso SSL Dummy Query String ( request ) ; response . send Redirect ( redirect Url Str ) ; } else { logger . error ( STR_ + tenant + STR_ ) ; send Error ( locale , response , STR_ ) ; } } catch ( Exception e ) { logger . error ( STR_ , e ) ; send Error ( locale , response , e . get Localized Message ( ) ) ; } }
private static int convert Linear RG Bto SRGB ( int color ) { float input , output ; input = color / NUM_ ; if ( input <= NUM_ ) { output = input * NUM_ ; } else { output = ( NUM_ * ( ( float ) Math . pow ( input , ( NUM_ / NUM_ ) ) ) ) - NUM_ ; } return Math . round ( output * NUM_ ) ; }
int [ ] determine Dimensions ( int source Code Words , int error Correction Code Words ) throws Writer Exception { float ratio = NUM_ ; int [ ] dimension = null ; for ( int cols = min Cols ; cols <= max Cols ; cols ++ ) { int rows = calculate Number Of Rows ( source Code Words , error Correction Code Words , cols ) ; if ( rows < min Rows ) { break ; } if ( rows > max Rows ) { continue ; } float new Ratio = ( ( NUM_ * cols + NUM_ ) * DEFAULT MODULE WIDTH ) / ( rows * HEIGHT ) ; if ( dimension != null && Math . abs ( new Ratio - PREFERRED RATIO ) > Math . abs ( ratio - PREFERRED RATIO ) ) { continue ; } ratio = new Ratio ; dimension = new int [ ] { cols , rows } ; } if ( dimension == null ) { int rows = calculate Number Of Rows ( source Code Words , error Correction Code Words , min Cols ) ; if ( rows < min Rows ) { dimension = new int [ ] { min Cols , min Rows } ; } } if ( dimension == null ) { throw new Writer Exception ( STR_ ) ; } return dimension ; }
public void insert Update ( Document Event changes , Shape a , View Factory f ) { update Children ( changes , a ) ; Rectangle alloc = ( ( a != null ) && is Allocation Valid ( ) ) ? get Inside Allocation ( a ) : null ; int pos = changes . get Offset ( ) ; View v = get View At Position ( pos , alloc ) ; if ( v != null ) v . insert Update ( changes , alloc , f ) ; }
public void clean ( ) { Arrays . fill ( c , NUM_ , NUM_ , NUM_ ) ; }
private void show Notification Label ( String i 18 n Key , Object ... arguments ) { upper Panel . set Visible ( false ) ; collapsible Error Table . set Visible ( false ) ; Grid Bag Constraints constraint = new Grid Bag Constraints ( ) ; constraint . fill = Grid Bag Constraints . BOTH ; constraint . weightx = NUM_ ; constraint . weighty = NUM_ ; center Panel . remove All ( ) ; center Panel . add ( new J Panel ( ) , constraint ) ; constraint . weightx = NUM_ ; constraint . weighty = NUM_ ; constraint . fill = Grid Bag Constraints . NONE ; constraint . anchor = Grid Bag Constraints . CENTER ; center Panel . add ( new Resource Label ( i 18 n Key , arguments ) , constraint ) ; constraint . weightx = NUM_ ; constraint . weighty = NUM_ ; constraint . fill = Grid Bag Constraints . BOTH ; center Panel . add ( new J Panel ( ) , constraint ) ; center Panel . revalidate ( ) ; center Panel . repaint ( ) ; }
protected static void init ( ) { String notificationfactory Class Name = null ; try { notificationfactory Class Name = System . get Property ( NOTIFICATION FACTORY NAME ) ; } catch ( Security Exception e ) { throw new Runtime Exception ( e ) ; } if ( notificationfactory Class Name != null ) { Class < ? > nfc ; try { nfc = Class . for Name ( notificationfactory Class Name ) ; factory = ( I Notification Manager Factory ) nfc . new Instance ( ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Instantiation Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( e ) ; } } }
public void check Jvm Mem Pool Collect Threshold ( Long x ) throws Snmp Status Exception { if ( ! pool . is Collection Usage Threshold Supported ( ) ) throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Inconsistent Value ) ; final long val = x . long Value ( ) ; if ( val < NUM_ ) throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Wrong Value ) ; }
public static Indexed Lag Graph serializable Instance ( ) { return new Indexed Lag Graph ( Basic Lag Graph . serializable Instance ( ) ) ; }
public static Request Log copy ( ) { Request Log current = RLOG . get ( ) ; return new Request Log ( current ) ; }
private int encrypt Block With IV ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STR_ ) ; } if ( count == NUM_ ) { if ( ( out Off + NUM_ * block Size + NUM_ ) > out . length ) { throw new Data Length Exception ( STR_ ) ; } cipher . process Block ( FR , NUM_ , FRE , NUM_ ) ; for ( int n = NUM_ ; n < block Size ; n ++ ) { out [ out Off + n ] = encrypt Byte ( IV [ n ] , n ) ; } System . arraycopy ( out , out Off , FR , NUM_ , block Size ) ; cipher . process Block ( FR , NUM_ , FRE , NUM_ ) ; out [ out Off + block Size ] = encrypt Byte ( IV [ block Size - NUM_ ] , NUM_ ) ; out [ out Off + block Size + NUM_ ] = encrypt Byte ( IV [ block Size - NUM_ ] , NUM_ ) ; System . arraycopy ( out , out Off + NUM_ , FR , NUM_ , block Size ) ; cipher . process Block ( FR , NUM_ , FRE , NUM_ ) ; for ( int n = NUM_ ; n < block Size ; n ++ ) { out [ out Off + block Size + NUM_ + n ] = encrypt Byte ( in [ in Off + n ] , n ) ; } System . arraycopy ( out , out Off + block Size + NUM_ , FR , NUM_ , block Size ) ; count += NUM_ * block Size + NUM_ ; return NUM_ * block Size + NUM_ ; } else if ( count >= block Size + NUM_ ) { if ( ( out Off + block Size ) > out . length ) { throw new Data Length Exception ( STR_ ) ; } cipher . process Block ( FR , NUM_ , FRE , NUM_ ) ; for ( int n = NUM_ ; n < block Size ; n ++ ) { out [ out Off + n ] = encrypt Byte ( in [ in Off + n ] , n ) ; } System . arraycopy ( out , out Off , FR , NUM_ , block Size ) ; } return block Size ; }
public static String format Temperature ( Context context , double temperature , boolean is Farhenheit ) { if ( is Farhenheit ) temperature = NUM_ * ( temperature - NUM_ ) + NUM_ ; else temperature = temperature - NUM_ ; return String . format ( context . get String ( R . string . format temperature ) , temperature ) ; }
public void record Start Time ( ) { current Request Start Time . set ( System . current Time Millis ( ) ) ; }
public void append Whitespace ( Appendable writer ) throws IO Exception { writer . append ( white Space ) ; }
protected synchronized int determine Minimum Number Of Parent Dirs ( ) { int result ; Hash Set < String > files ; int num ; int i ; int max ; result = - NUM_ ; max = NUM_ ; for ( i = NUM_ ; i < m Recent Items . size ( ) ; i ++ ) max = Math . max ( max , File Utils . get Directory Depth ( m Recent Items . get ( i ) ) ) ; num = NUM_ ; do { files = new Hash Set < String > ( ) ; for ( i = NUM_ ; i < m Recent Items . size ( ) ; i ++ ) files . add ( File Utils . create Partial Filename ( m Recent Items . get ( i ) , num ) ) ; if ( files . size ( ) == m Recent Items . size ( ) ) result = num ; else num ++ ; } while ( ( files . size ( ) < m Recent Items . size ( ) ) && ( num <= max ) ) ; return result ; }
public int hash Code ( ) { return Objects . hash ( x , p , g ) ; }
protected static void append Date Type ( String Builder sb ) { sb . append ( STR_ ) ; }
public void remove Navigation Listener ( Navigation Listener l ) { navigation Listeners . remove ( l ) ; }
private static void adjust For Currency Default Fraction Digits ( Decimal Format format , Decimal Format Symbols symbols ) { Currency currency = symbols . get Currency ( ) ; if ( currency == null ) { try { currency = Currency . get Instance ( symbols . get International Currency Symbol ( ) ) ; } catch ( Illegal Argument Exception e ) { } } if ( currency != null ) { int digits = currency . get Default Fraction Digits ( ) ; if ( digits != - NUM_ ) { int old Min Digits = format . get Minimum Fraction Digits ( ) ; if ( old Min Digits == format . get Maximum Fraction Digits ( ) ) { format . set Minimum Fraction Digits ( digits ) ; format . set Maximum Fraction Digits ( digits ) ; } else { format . set Minimum Fraction Digits ( Math . min ( digits , old Min Digits ) ) ; format . set Maximum Fraction Digits ( digits ) ; } } } }
public static boolean is XML Name ( String name ) { if ( name . length ( ) > NUM_ && ! is Name Start Char ( name . char At ( NUM_ ) ) ) { return false ; } for ( int i = NUM_ ; i < name . length ( ) ; i ++ ) { if ( ! is Name Char ( name . char At ( i ) ) ) { return false ; } } return true ; }
public void stop And Wait For Client On Thread ( long ms ) { if ( client Running On Thread != null && client Running On Thread . is Alive ( ) ) { client Running On Thread . interrupt ( ) ; } long start = System . current Time Millis ( ) ; while ( ( System . current Time Millis ( ) - start ) < ms ) { if ( client Running On Thread != null && client Running On Thread . is Alive ( ) ) { try { client Running On Thread . join ( ms - ( System . current Time Millis ( ) - start ) ) ; break ; } catch ( Interrupted Exception e ) { } } else { break ; } } if ( client Running On Thread != null && client Running On Thread . is Alive ( ) ) { throw new Assertion Error ( STR_ + ms + STR_ ) ; } }
@ Deprecated public Long register User ( String SID , String Username , String Userpass , String lastname , String firstname , String email , Date age , String street , String additionalname , String fax , String zip , long states id , String town , long language id , String phone ) { return user Management . register User ( Username , Userpass , lastname , firstname , email , age , street , additionalname , fax , zip , states id , town , language id , phone , STR_ , true , STR_ ) ; }
private String print O Format ( long x ) { String sx = null ; if ( x == Long . MIN VALUE ) sx = STR_ ; else if ( x < NUM_ ) { String t = Long . to String ( ( ~ ( - x - NUM_ ) ) ^ Long . MIN VALUE , NUM_ ) ; switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; } } else sx = Long . to String ( x , NUM_ ) ; return print O Format ( sx ) ; }
public void parent Explotion ( int PP Product BOM ID ) throws Exception { Prepared Statement stmt = null ; Result Set rs = null ; String sql = STR_ + STR_ ; try { stmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; stmt . set Int ( NUM_ , PP Product BOM ID ) ; rs = stmt . execute Query ( ) ; while ( rs . next ( ) ) { Seq No += NUM_ ; X T BOM Line tboml = new X T BOM Line ( ctx , NUM_ , null ) ; tboml . set PP Product BOM ID ( PP Product BOM ID ) ; tboml . set PP Product BOM Line ID ( rs . get Int ( NUM_ ) ) ; tboml . set M Product ID ( rs . get Int ( NUM_ ) ) ; tboml . set Level No ( Level No ) ; tboml . set Levels ( levels . substring ( NUM_ , Level No ) + Level No ) ; tboml . set Seq No ( Seq No ) ; tboml . set AD P Instance ID ( AD P Instance ID ) ; tboml . set Sel Product ID ( p M Product ID ) ; tboml . set Implosion ( p implosion ) ; tboml . save ( ) ; component ( rs . get Int ( NUM_ ) ) ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , e . get Localized Message ( ) + sql , e ) ; throw new Exception ( STR_ + e . get Localized Message ( ) ) ; } finally { DB . close ( rs , stmt ) ; rs = null ; stmt = null ; } }
private void fire Process Supervision Update ( final Supervision Event supervision Event ) { Set < Supervision Listener > listeners = process Supervision Listeners . get ( supervision Event . get Entity Id ( ) ) ; if ( listeners != null ) { for ( Supervision Listener listener : listeners ) { listener . on Supervision Update ( supervision Event ) ; } } }
public void multiple Linear Regression ( String file Name , int ind Variable , int [ ] c , String [ ] factors , boolean intercept Term , int row Ini , int row End ) { try { Buffered Reader reader = new Buffered Reader ( new File Reader ( file Name ) ) ; Matrix data = Matrix . read ( reader ) ; reader . close ( ) ; int rows = data . get Row Dimension ( ) - NUM_ ; int cols = data . get Column Dimension ( ) - NUM_ ; if ( row Ini < NUM_ || row Ini > rows ) throw new Runtime Exception ( STR_ + row Ini + STR_ + rows ) ; if ( row End < NUM_ || row End > rows ) throw new Runtime Exception ( STR_ + row Ini + STR_ + rows ) ; if ( row Ini > row End ) throw new Runtime Exception ( STR_ + row Ini + STR_ + row End ) ; Matrix ind Var = data . get Matrix ( row Ini , row End , ind Variable , ind Variable ) ; data = data . get Matrix ( row Ini , row End , c ) ; multiple Linear Regression ( ind Var , data , intercept Term ) ; } catch ( Exception e ) { throw new Runtime Exception ( STR_ + file Name , e ) ; } }
@ Override public void push Message Async ( Message msg ) throws org . apache . thrift . T Exception { push Message Sync ( msg ) ; return ; }
public boolean rewrite Exif ( Byte Buffer buf , Collection < Exif Tag > tags ) throws IO Exception { Exif Modifier mod = null ; try { mod = new Exif Modifier ( buf , this ) ; for ( Exif Tag t : tags ) { mod . modify Tag ( t ) ; } return mod . commit ( ) ; } catch ( Exif Invalid Format Exception e ) { throw new IO Exception ( STR_ + e ) ; } }
private void emit Map Put ( Method method , String field Name , String Builder builder ) { builder . append ( STR_ ) ; builder . append ( get Map Putter Name ( field Name ) ) ; builder . append ( STR_ ) ; builder . append ( get Type Argument Impl Name ( ( Parameterized Type ) method . get Generic Return Type ( ) , NUM_ ) ) ; builder . append ( STR_ ) ; builder . append ( get Ensure Name ( field Name ) ) ; builder . append ( STR_ ) ; builder . append ( field Name ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; }
static public J Label create J Label For Table ( ) { J Label label = new J Label ( ) ; set Plain ( label ) ; label . set Opaque ( true ) ; label . set Foreground ( TABLE COMPONENT FG COLOR ) ; label . set Background ( TABLE COMPONENT BG COLOR ) ; return label ; }
public Simple Dominators Finder ( Directed Graph < N > graph ) { this . graph = graph ; Simple Dominators Analysis < N > analysis = new Simple Dominators Analysis < N > ( graph ) ; { node To Dominators = new Hash Map < N , Flow Set < N > > ( graph . size ( ) * NUM_ + NUM_ , NUM_ ) ; for ( Iterator < N > node It = graph . iterator ( ) ; node It . has Next ( ) ; ) { N node = node It . next ( ) ; Flow Set < N > set = analysis . get Flow After ( node ) ; node To Dominators . put ( node , set ) ; } } }
private boolean dynomite Redis Check ( ) { Jedis dynomite Jedis = new Jedis ( LOCAL ADDRESS , DYNO PORT , NUM_ ) ; try { dynomite Jedis . connect ( ) ; if ( ! dynomite Redis Ping ( dynomite Jedis ) ) { sleeper . sleep Quietly ( NUM_ ) ; if ( ! dynomite Redis Ping ( dynomite Jedis ) ) { logger . warn ( STR_ ) ; return false ; } } } catch ( Exception e ) { logger . warn ( STR_ + e . get Message ( ) ) ; return false ; } return true ; }
private static final byte [ ] fill Data ( byte [ ] data ) { RAND . next Bytes ( data ) ; return data ; }
private int encrypt Block ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STR_ ) ; } for ( int i = NUM_ ; i < block Size ; i ++ ) { cbc V [ i ] ^= in [ in Off + i ] ; } int length = cipher . process Block ( cbc V , NUM_ , out , out Off ) ; System . arraycopy ( out , out Off , cbc V , NUM_ , cbc V . length ) ; return length ; }
@ Override public double conf Small M ( double total Weight , double delta ) { double term = Math . log ( NUM_ / delta ) / ( NUM_ * total Weight ) ; return Math . pow ( term , NUM_ ) + NUM_ * term + NUM_ * Math . sqrt ( term ) ; }
@ Override @ Deprecated public List < Linked Notebook > list Notebooks ( ) throws EDAM User Exception , EDAM System Exception , T Exception , EDAM Not Found Exception { List < Linked Notebook > linked Notebooks = new Array List < > ( ) ; for ( Linked Notebook notebook : super . list Notebooks ( ) ) { if ( notebook . is Set Business Id ( ) ) { linked Notebooks . add ( notebook ) ; } } return linked Notebooks ; }
public Map < String , Map < String , Flt > > retrieve Terms ( int doc Num , String [ ] fields , Map < String , Map < String , Flt > > field To Term Freq Map ) throws IO Exception { if ( field To Term Freq Map == null ) { field To Term Freq Map = new Hash Map < String , Map < String , Flt > > ( ) ; } if ( fields == null || fields . length == NUM_ ) { return field To Term Freq Map ; } final Fields vectors = ir . get Term Vectors ( doc Num ) ; final Document document = ir . document ( doc Num ) ; for ( String field Name : fields ) { Map < String , Flt > term Freq Map = null ; if ( field To Term Freq Map . contains Key ( field Name ) ) { term Freq Map = field To Term Freq Map . get ( field Name ) ; } else { term Freq Map = new Hash Map < String , Flt > ( ) ; field To Term Freq Map . put ( field Name , term Freq Map ) ; } Terms vector = null ; if ( vectors != null ) { vector = vectors . terms ( field Name ) ; } if ( vector == null || is Payload Field ( field Name ) ) { Indexable Field doc Fields [ ] = document . get Fields ( field Name ) ; for ( Indexable Field field : doc Fields ) { final String string Value = field . string Value ( ) ; if ( string Value != null ) { add Term Weights ( new String Reader ( string Value ) , term Freq Map , field Name ) ; } } } else { add Term Weights ( term Freq Map , vector ) ; } } return field To Term Freq Map ; }
public Collection values ( ) { return map . values ( ) ; }
public boolean contains Key ( Object name ) { return map . contains Key ( name ) ; }
private void remove Finished Clients ( ) { Connector Handler client = null ; while ( ( client = dead Clients . poll ( ) ) != null ) { try { client . release ( context ) ; } catch ( Exception e ) { logger . warn ( STR_ , e ) ; } clients . remove ( client ) ; } }
public String tag ( int token Id , Text Annotation ta ) { String form = ta . get Token ( token Id ) ; Tree Map < String , Integer > counts = table . get ( form ) ; String l = null ; if ( counts == null ) { if ( form . equals ( STR_ ) ) l = STR_ ; else if ( looks Like Number ( form ) ) l = STR_ ; else l = STR_ ; } else { int best = NUM_ ; for ( Map . Entry < String , Integer > e : counts . entry Set ( ) ) { int c = e . get Value ( ) ; if ( c > best ) { best = c ; l = e . get Key ( ) ; } } } return l ; }
private void extract ( Detail detail , Default Type access ) throws Exception { List < Field Detail > fields = detail . get Fields ( ) ; if ( access == FIELD ) { for ( Field Detail entry : fields ) { Annotation [ ] list = entry . get Annotations ( ) ; Field field = entry . get Field ( ) ; Class real = field . get Type ( ) ; if ( ! is Static ( field ) && ! is Transient ( field ) ) { process ( field , real , list ) ; } } } }
public static UTM Coord from UTM ( int zone , String hemisphere , double easting , double northing ) { return from UTM ( zone , hemisphere , easting , northing , null ) ; }
private Value read Array ( Class type , Node Map node ) throws Exception { Node entry = node . remove ( length ) ; int size = NUM_ ; if ( entry != null ) { String value = entry . get Value ( ) ; size = Integer . parse Int ( value ) ; } return new Array Value ( type , size ) ; }
static < T > T try Eval ( Location location , Class < T > requested Type , Snippet snippet , Context context , List < ? > args ) { if ( snippet . kind ( ) == Snippet Kind . ABSTRACT ) { throw new Eval Exception ( location , STR_ , snippet . display Name ( ) ) ; } Doc result = snippet . eval ( context , args ) ; return requested Type . cast ( Values . convert ( location , requested Type , result ) ) ; }
public String validation For Bifurcation ( final Property Impl property Model , final Basic Property basic Property , final String reason ) { final List < Property Status Values > children = property Status Values DAO . get Property Status Values By Reference Basic Property ( basic Property ) ; final Boolean parent Bifurcated = is Property Bifurcated ( basic Property ) ; final Boolean children Created = ! children . is Empty ( ) ; String error Msg = null ; if ( PROPERTY MODIFY REASON BIFURCATE . equals Ignore Case ( reason ) ) { if ( parent Bifurcated && ! children Created ) error Msg = STR_ ; } else if ( PROPERTY MODIFY REASON ADD OR ALTER . equals Ignore Case ( reason ) ) { if ( ! children Created ) { if ( parent Bifurcated ) error Msg = STR_ ; } else if ( ! parent Bifurcated ) error Msg = STR_ ; } else if ( PROP CREATE RSN BIFUR . equals ( reason ) ) if ( parent Bifurcated ) get Latest History Property ( basic Property . get Upic No ( ) ) ; else basic Property . get Active Property ( ) ; return error Msg ; }
@ Override public Byte String normalize Attribute Value ( final Schema schema , final Byte Sequence value ) throws Decode Exception { final Big Integer serial Number ; final String dnstring ; try { Certificate Factory cert Factory = Certificate Factory . get Instance ( STR_ ) ; Input Stream input Stream = new Byte Array Input Stream ( value . to Byte Array ( ) ) ; X 509 Certificate cert Value = ( X 509 Certificate ) cert Factory . generate Certificate ( input Stream ) ; serial Number = cert Value . get Serial Number ( ) ; X 500 Principal issuer = cert Value . get Issuer X 500 Principal ( ) ; dnstring = issuer . get Name ( X 500 Principal . RFC 2253 ) ; } catch ( Certificate Exception ce ) { final Localizable Message message = ERR MR CERTIFICATE MATCH PARSE ERROR . get ( ce . get Message ( ) ) ; logger . trace ( message ) ; return value . to Byte String ( ) ; } final Byte String certificate Issuer = normalize DN ( schema , dnstring ) ; return create Encoded Value ( serial Number , certificate Issuer ) ; }
Httpmd URL Connection ( URL url ) throws IO Exception , Malformed URL Exception { super ( url ) ; String path = url . get Path ( ) == null ? STR_ : url . get Path ( ) ; int semi Index = path . last Index Of ( STR_ ) ; if ( semi Index < NUM_ ) { throw new Malformed URL Exception ( STR_ ) ; } int equals Index = path . index Of ( STR_ , semi Index ) ; if ( equals Index < NUM_ ) { throw new Malformed URL Exception ( STR_ ) ; } algorithm = path . substring ( semi Index + NUM_ , equals Index ) ; try { Message Digest . get Instance ( algorithm ) ; } catch ( No Such Algorithm Exception e ) { Malformed URL Exception t = new Malformed URL Exception ( STR_ + algorithm ) ; t . init Cause ( e ) ; throw t ; } String digest = path . substring ( equals Index + NUM_ ) ; int comment = digest . index Of ( STR_ ) ; if ( comment >= NUM_ ) { for ( int i = digest . length ( ) ; -- i > comment ; ) { char c = digest . char At ( i ) ; if ( ! Httpmd Util . comment Char ( c ) ) { throw new Malformed URL Exception ( STR_ + c + STR_ ) ; } } digest = digest . substring ( NUM_ , comment ) ; } int length = digest . length ( ) ; if ( length == NUM_ ) { throw new Malformed URL Exception ( STR_ ) ; } try { expected Digest = Httpmd Util . string Digest ( digest ) ; } catch ( Number Format Exception e ) { Malformed URL Exception t = new Malformed URL Exception ( STR_ + digest ) ; t . init Cause ( e ) ; throw t ; } try { content = new URL ( STR_ , url . get Host ( ) , url . get Port ( ) , path . substring ( NUM_ , semi Index ) + ( url . get Query ( ) == null ? STR_ : url . get Query ( ) ) + ( url . get Ref ( ) == null ? STR_ : url . get Ref ( ) ) ) ; } catch ( Malformed URL Exception e ) { Malformed URL Exception t = new Malformed URL Exception ( STR_ ) ; t . init Cause ( e ) ; throw t ; } delegate Connection = ( Http URL Connection ) content . open Connection ( ) ; }
Selection Event Handler ( final Vision World vision World ) { super ( ) ; if ( vision World == null ) { throw new Illegal Argument Exception ( STR_ ) ; } this . vision World = vision World ; this . selection Model = vision World . get Sensor Selection Model ( ) ; }
void write To Byte Buffer ( Byte Buffer buffer , boolean mb , boolean me ) { boolean sr = m Payload . length < NUM_ ; boolean il = m Id . length > NUM_ ; byte flags = ( byte ) ( ( mb ? FLAG MB : NUM_ ) | ( me ? FLAG ME : NUM_ ) | ( sr ? FLAG SR : NUM_ ) | ( il ? FLAG IL : NUM_ ) | m Tnf ) ; buffer . put ( flags ) ; buffer . put ( ( byte ) m Type . length ) ; if ( sr ) { buffer . put ( ( byte ) m Payload . length ) ; } else { buffer . put Int ( m Payload . length ) ; } if ( il ) { buffer . put ( ( byte ) m Id . length ) ; } buffer . put ( m Type ) ; buffer . put ( m Id ) ; buffer . put ( m Payload ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof XY Difference Renderer ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } XY Difference Renderer that = ( XY Difference Renderer ) obj ; if ( ! Paint Utilities . equal ( this . positive Paint , that . positive Paint ) ) { return false ; } if ( ! Paint Utilities . equal ( this . negative Paint , that . negative Paint ) ) { return false ; } if ( this . shapes Visible != that . shapes Visible ) { return false ; } if ( ! Shape Utilities . equal ( this . legend Line , that . legend Line ) ) { return false ; } if ( this . round X Coordinates != that . round X Coordinates ) { return false ; } return true ; }
long clock check ( long now ) { if ( m shutdown == En Shutdown . SD FORCEFUL ) { return - NUM_ ; } long n Timeout ; long snd buffered ; snd buffered = m sbuf . get Buffered ( ) ; if ( ( m shutdown == En Shutdown . SD GRACEFUL ) && ( ( m state != Pseudo Tcp State . TCP ESTABLISHED ) || ( ( snd buffered == NUM_ ) && ( m t ack == NUM_ ) ) ) ) { return - NUM_ ; } if ( m state == Pseudo Tcp State . TCP CLOSED ) { return CLOSED TIMEOUT ; } n Timeout = DEFAULT TIMEOUT ; if ( m t ack > NUM_ ) { n Timeout = Math . min ( n Timeout , time Diff ( m t ack + m ack delay , now ) ) ; } if ( m rto base > NUM_ ) { n Timeout = Math . min ( n Timeout , time Diff ( m rto base + m rx rto , now ) ) ; } if ( get M snd wnd ( ) == NUM_ ) { n Timeout = Math . min ( n Timeout , time Diff ( m lastsend + m rx rto , now ) ) ; } if ( PSEUDO KEEPALIVE ) { if ( m state == Pseudo Tcp State . TCP ESTABLISHED ) { n Timeout = Math . min ( n Timeout , time Diff ( m lasttraffic + ( m b Outgoing ? IDLE PING * NUM_ / NUM_ : IDLE PING ) , now ) ) ; } } return n Timeout <= NUM_ ? NUM_ : n Timeout ; }
protected void suggest Export Masks For Placement ( Storage System storage , Block Storage Device device , List < Initiator > initiators , Export Mask Placement Descriptor descriptor ) { descriptor . set Placement Hint ( Export Mask Placement Descriptor . Placement Hint . VOLUMES TO SINGLE MASK ) ; Map < URI , Export Mask > matching Masks = read Existing Export Masks ( storage , device , initiators ) ; descriptor . set Masks ( matching Masks ) ; for ( URI export Mask URI : matching Masks . key Set ( ) ) { descriptor . place Volumes ( export Mask URI , descriptor . get Volumes To Place ( ) ) ; } }
public static Map < Integer , String > generate Map Of Value Name Integer ( Class < ? > clazz ) { Map < Integer , String > values Name = new Hash Map < > ( ) ; try { for ( Field field : clazz . get Fields ( ) ) { values Name . put ( ( Integer ) field . get ( int . class ) , field . get Name ( ) ) ; } } catch ( Illegal Access Exception e ) { e . print Stack Trace ( ) ; } return values Name ; }
protected Ct Class remove Cached ( String classname ) { return ( Ct Class ) classes . remove ( classname ) ; }
protected long output Offset ( ) { return bytes Written + output Tail ; }
protected void store State ( ) { if ( tree != null ) { System . arraycopy ( intervals , NUM_ , stored Intervals , NUM_ , intervals . length ) ; System . arraycopy ( lineage Counts , NUM_ , stored Lineage Counts , NUM_ , lineage Counts . length ) ; stored Intervals Known = intervals Known ; stored Interval Count = interval Count ; stored Likelihood Known = likelihood Known ; } else if ( trees Set != null ) { trees Set . store The State ( ) ; } stored Log Likelihood = log Likelihood ; }
public void download Artwork ( Media File Type type ) { Movie Artwork Helper . download Artwork ( this , type ) ; }
public File Tree Node ( Path parent ) throws Security Exception , File Not Found Exception { if ( parent == null ) { throw new File Not Found Exception ( ) ; } this . name = parent . to String ( ) ; Path path Path = parent ; path = path Path . to String ( ) ; is Dir = true ; is Root = true ; set User Object ( this . name ) ; }
protected static String encrypt String ( String data ) { crc 32 . reset ( ) ; crc 32 . update ( data . get Bytes ( ) ) ; return Long . to Hex String ( crc 32 . get Value ( ) ) ; }
@ Override protected void add Help Menu ( ) { add Help Menu ( STR_ , true ) ; }
private boolean process Key Up ( int key Code ) { if ( key Code == Key Event . KEYCODE ESCAPE || key Code == Key Event . KEYCODE BACK ) { dismiss ( ) ; return true ; } else if ( key Code == Key Event . KEYCODE TAB ) { if ( m In Kb Mode ) { if ( is Typed Time Fully Legal ( ) ) { finish Kb Mode ( true ) ; } return true ; } } else if ( key Code == Key Event . KEYCODE ENTER ) { if ( m In Kb Mode ) { if ( ! is Typed Time Fully Legal ( ) ) { return true ; } finish Kb Mode ( false ) ; } if ( m Callback != null ) { m Callback . on Time Set ( m Time Picker , m Time Picker . get Hours ( ) , m Time Picker . get Minutes ( ) ) ; } dismiss ( ) ; return true ; } else if ( key Code == Key Event . KEYCODE DEL ) { if ( m In Kb Mode ) { if ( ! m Typed Times . is Empty ( ) ) { int deleted = delete Last Typed Key ( ) ; String deleted Key Str ; if ( deleted == get Am Or Pm Key Code ( AM ) ) { deleted Key Str = m Am Text ; } else if ( deleted == get Am Or Pm Key Code ( PM ) ) { deleted Key Str = m Pm Text ; } else { deleted Key Str = String . format ( STR_ , get Val From Key Code ( deleted ) ) ; } Utils . try Accessibility Announce ( m Time Picker , String . format ( m Deleted Key Format , deleted Key Str ) ) ; update Display ( true ) ; } } } else if ( key Code == Key Event . KEYCODE 0 || key Code == Key Event . KEYCODE 1 || key Code == Key Event . KEYCODE 2 || key Code == Key Event . KEYCODE 3 || key Code == Key Event . KEYCODE 4 || key Code == Key Event . KEYCODE 5 || key Code == Key Event . KEYCODE 6 || key Code == Key Event . KEYCODE 7 || key Code == Key Event . KEYCODE 8 || key Code == Key Event . KEYCODE 9 || ( ! m Is 24 Hour Mode && ( key Code == get Am Or Pm Key Code ( AM ) || key Code == get Am Or Pm Key Code ( PM ) ) ) ) { if ( ! m In Kb Mode ) { if ( m Time Picker == null ) { Log . e ( TAG , STR_ ) ; return true ; } m Typed Times . clear ( ) ; try Starting Kb Mode ( key Code ) ; return true ; } if ( add Key If Legal ( key Code ) ) { update Display ( false ) ; } return true ; } return false ; }
public final int at Ad Pos ( final int pos ) { final int take int = ( int ) Math . floor ( ( pos + NUM_ ) / adfrequency ) ; Log . d ( STR_ , take int + STR_ ) ; return take int ; }
public static int ceil int ( final float a ) { final int intpart = ( int ) a ; if ( a <= intpart || ( CHECK OVERFLOW && intpart == Integer . MAX VALUE ) || CHECK NAN && Float . is Na N ( a ) ) { return intpart ; } return intpart + NUM_ ; }
private void create Config File ( String repository , File config ) { try { Document Builder Factory doc Factory = Document Builder Factory . new Instance ( ) ; Document Builder doc Builder = doc Factory . new Document Builder ( ) ; Document doc = doc Builder . new Document ( ) ; Element root Element = doc . create Element ( STR_ ) ; doc . append Child ( root Element ) ; Element actions = doc . create Element ( STR_ ) ; root Element . append Child ( actions ) ; Element description = doc . create Element ( STR_ ) ; root Element . append Child ( description ) ; Element keep Dependencies = doc . create Element ( STR_ ) ; keep Dependencies . append Child ( doc . create Text Node ( STR_ ) ) ; root Element . append Child ( keep Dependencies ) ; Element properties = doc . create Element ( STR_ ) ; root Element . append Child ( properties ) ; Element scm = doc . create Element ( STR_ ) ; if ( repository . equals ( STR_ ) ) { scm . set Attribute ( STR_ , STR_ ) ; root Element . append Child ( scm ) ; } else { scm . set Attribute ( STR_ , STR_ ) ; scm . set Attribute ( STR_ , STR_ ) ; Element config Version = doc . create Element ( STR_ ) ; config Version . append Child ( doc . create Text Node ( STR_ ) ) ; scm . append Child ( config Version ) ; Element user Remote Configs = doc . create Element ( STR_ ) ; Element user Remote Config = doc . create Element ( STR_ ) ; user Remote Configs . append Child ( user Remote Config ) ; scm . append Child ( user Remote Configs ) ; Element branches = doc . create Element ( STR_ ) ; Element branch Spec = doc . create Element ( STR_ ) ; Element name = doc . create Element ( STR_ ) ; name . append Child ( doc . create Text Node ( STR_ ) ) ; branch Spec . append Child ( name ) ; branches . append Child ( branch Spec ) ; scm . append Child ( branches ) ; Element do Generate Submodule Configurations = doc . create Element ( STR_ ) ; do Generate Submodule Configurations . append Child ( doc . create Text Node ( STR_ ) ) ; scm . append Child ( do Generate Submodule Configurations ) ; Element browser = doc . create Element ( STR_ ) ; browser . set Attribute ( STR_ , STR_ ) ; Element url = doc . create Element ( STR_ ) ; url . append Child ( doc . create Text Node ( repository ) ) ; browser . append Child ( url ) ; Element version = doc . create Element ( STR_ ) ; version . append Child ( doc . create Text Node ( STR_ ) ) ; browser . append Child ( version ) ; scm . append Child ( browser ) ; Element submodule Cfg = doc . create Element ( STR_ ) ; submodule Cfg . set Attribute ( STR_ , STR_ ) ; scm . append Child ( submodule Cfg ) ; Element extensions = doc . create Element ( STR_ ) ; scm . append Child ( extensions ) ; } root Element . append Child ( scm ) ; Element can Roam = doc . create Element ( STR_ ) ; can Roam . append Child ( doc . create Text Node ( STR_ ) ) ; root Element . append Child ( can Roam ) ; Element disabled = doc . create Element ( STR_ ) ; disabled . append Child ( doc . create Text Node ( STR_ ) ) ; root Element . append Child ( disabled ) ; Element block Build When Downstream Building = doc . create Element ( STR_ ) ; block Build When Downstream Building . append Child ( doc . create Text Node ( STR_ ) ) ; root Element . append Child ( block Build When Downstream Building ) ; Element block Build When Upstream Building = doc . create Element ( STR_ ) ; block Build When Upstream Building . append Child ( doc . create Text Node ( STR_ ) ) ; root Element . append Child ( block Build When Upstream Building ) ; Element triggers = doc . create Element ( STR_ ) ; root Element . append Child ( triggers ) ; Element concurrent Build = doc . create Element ( STR_ ) ; concurrent Build . append Child ( doc . create Text Node ( STR_ ) ) ; root Element . append Child ( concurrent Build ) ; Element builders = doc . create Element ( STR_ ) ; root Element . append Child ( builders ) ; Element publishers = doc . create Element ( STR_ ) ; root Element . append Child ( publishers ) ; Element build Wrappers = doc . create Element ( STR_ ) ; root Element . append Child ( build Wrappers ) ; Transformer Factory transformer Factory = Transformer Factory . new Instance ( ) ; Transformer transformer = transformer Factory . new Transformer ( ) ; DOM Source source = new DOM Source ( doc ) ; Stream Result result = new Stream Result ( config ) ; transformer . transform ( source , result ) ; } catch ( Exception e ) { logger . error ( repository + STR_ + config , e ) ; } }
protected final static int rhumb Step ( Point 2 D pt 1 , Point 2 D pt 2 ) { int step = ( int ) Draw Util . distance ( pt 1 . get X ( ) , pt 1 . get Y ( ) , pt 2 . get X ( ) , pt 2 . get Y ( ) ) ; if ( step > NUM_ ) { step = NUM_ ; } else { step >>= NUM_ ; } return ( step == NUM_ ) ? NUM_ : step ; }
protected static byte [ ] input Stream To Byte Array ( Input Stream str ) throws IO Exception { try ( Byte Array Output Stream baos = new Byte Array Output Stream ( ) ) { int len = NUM_ ; byte [ ] buf = new byte [ NUM_ ] ; while ( ( len = str . read ( buf ) ) != - NUM_ ) { baos . write ( buf , NUM_ , len ) ; } return baos . to Byte Array ( ) ; } }
public void start Element ( String uri , String local Name , String q Name , Attributes attributes ) throws SAX Exception { try { if ( q Name . equals ( STR_ ) && packages . size ( ) > NUM_ ) { throw new Runtime Exception ( STR_ ) ; } writer . new Line ( ) ; writer . write ( STR_ + q Name ) ; for ( int i = NUM_ ; i < attributes . get Length ( ) ; i ++ ) { writer . write ( STR_ + attributes . get Q Name ( i ) + STR_ + attributes . get Value ( i ) + STR_ ) ; } writer . write ( STR_ ) ; } catch ( IO Exception ioe ) { throw new SAX Exception ( ioe ) ; } }
static void add Property ( Structural Property Descriptor property , List property List ) { Class node Class = ( Class ) property List . get ( NUM_ ) ; if ( property . get Node Class ( ) != node Class ) { throw new Runtime Exception ( STR_ ) ; } property List . add ( property ) ; }
public void remove Vetoable Change Listener ( String property Name , Vetoable Change Listener listener ) { if ( listener != null ) { synchronized ( this ) { if ( vetoable Support != null ) { vetoable Support . remove Vetoable Change Listener ( property Name , listener ) ; } } } }
static String gravity To String ( int gravity ) { if ( ( gravity & Gravity . LEFT ) == Gravity . LEFT ) { return STR_ ; } if ( ( gravity & Gravity . RIGHT ) == Gravity . RIGHT ) { return STR_ ; } return Integer . to Hex String ( gravity ) ; }
@ Override public Parcelable on Save Instance State ( ) { d ( STR_ ) ; Bundle bundle = new Bundle ( ) ; bundle . put Parcelable ( STR_ , super . on Save Instance State ( ) ) ; bundle . put Boolean ( STR_ , m Open ) ; return bundle ; }
public void read External ( Object Input in ) throws IO Exception , Class Not Found Exception { ref = Live Ref . read ( in , false ) ; }
public static int compute MST ( Graph graph , int numvert ) { int cost = NUM_ ; Vertex inserted = graph . first Node ( ) ; Vertex tmp = inserted . next ( ) ; My Vertex List = tmp ; numvert -- ; while ( numvert != NUM_ ) { Blue Return br = do All Blue Rule ( inserted ) ; inserted = br . vert ( ) ; int dist = br . dist ( ) ; numvert -- ; cost += dist ; } return cost ; }
public boolean request ( Interrupt Request interrupt Request ) { Fr Interrupt Request new Interrupt Request = ( Fr Interrupt Request ) interrupt Request ; synchronized ( interrupt Request Queue ) { for ( Interrupt Request current Interrupt Request : interrupt Request Queue ) { Fr Interrupt Request current Fr Interrupt Request = ( Fr Interrupt Request ) current Interrupt Request ; if ( current Fr Interrupt Request . get Interrupt Number ( ) == new Interrupt Request . get Interrupt Number ( ) ) { if ( ( new Interrupt Request . is NMI ( ) && ! current Fr Interrupt Request . is NMI ( ) ) || ( new Interrupt Request . get ICR ( ) < current Fr Interrupt Request . get ICR ( ) ) ) { interrupt Request Queue . remove ( current Fr Interrupt Request ) ; break ; } else { return false ; } } } interrupt Request Queue . add ( new Interrupt Request ) ; Collections . sort ( interrupt Request Queue ) ; return true ; } }
private void post Process Relationships ( Patch Request Scope request Scope ) { actions . for Each ( null ) ; }
private void initialize Other Information ( Linux Ade Ext Properties ade Ext Properties , String parse Report Filename ) throws Ade Exception { m parser Start Time = System . nano Time ( ) ; m line Parsers = new Linux Syslog Line Parser [ ] { new Linux Syslog 5424 Parser Base ( ) , new Linux Syslog 3164 Parser With Mark ( ) , new Linux Syslog 3164 Parser With Comp And Pid ( ) , new Linux Syslog 3164 Parser Free Form ( ) } ; m ade Ext Properties = ade Ext Properties ; Linux Syslog 3164 Parser Base . set Ade Ext Properties ( m ade Ext Properties ) ; set Parsing Quality Reporter If Requested ( parse Report Filename ) ; try { if ( m ade Ext Properties . is Gmt Offset Defined ( ) ) { m info = new Managed System Info ( m ade Ext Properties . get Gmt Offset ( ) , STR_ ) ; } else { m info = new Managed System Info ( GMT OFFSET INVALID , STR_ ) ; } } catch ( Illegal Argument Exception e ) { throw new Ade Usage Exception ( STR_ , e ) ; } }
public boolean append ( String p button name , String p window title , Printable Info p object ) { Collection < Printable Info > object list = new Linked List < Printable Info > ( ) ; object list . add ( p object ) ; return append objects ( p button name , p window title , object list ) ; }
public static String quote ( String input ) { String output = STR_ ; for ( int i = NUM_ ; i < input . length ( ) ; i ++ ) { output += STR_ + input . char At ( i ) ; } return output ; }
protected void audit Disaster Recovery Ops ( Operation Type Enum audit Type , String operational Status , String operation Stage , Object ... descparams ) { audit Mgr . record Audit Log ( null , null , EVENT SERVICE TYPE , audit Type , System . current Time Millis ( ) , operational Status , operation Stage , descparams ) ; }
protected void tear Down ( ) { try { if ( s != null ) s . close ( ) ; } catch ( Exception e ) { } try { if ( ss != null ) ss . close ( ) ; } catch ( Exception e ) { } try { if ( t != null ) t . interrupt ( ) ; } catch ( Exception e ) { } }
public boolean is Reduced ( ) { return ( ! has Not Reachable Non Terminals ( ) && ! has Not Productive Non Terminals ( ) ) ; }
public J List create List ( ) { J List list = new J List ( m model ) ; list . set Selection Model ( m model ) ; return list ; }
public double eval ( int id 1 , int id 2 , Instance inst 1 ) throws Exception { double div = Math . sqrt ( super . eval ( id 1 , id 1 , inst 1 ) * ( ( m keys != null ) ? super . eval ( id 2 , id 2 , m data . instance ( id 2 ) ) : super . eval ( - NUM_ , - NUM_ , m data . instance ( id 2 ) ) ) ) ; if ( div != NUM_ ) { return super . eval ( id 1 , id 2 , inst 1 ) / div ; } else { return NUM_ ; } }
private void update Base Matrix ( Drawable d ) { Image View image View = get Image View ( ) ; if ( null == image View || null == d ) { return ; } final float view Width = get Image View Width ( image View ) ; final float view Height = get Image View Height ( image View ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; m Base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( m Scale Type == Scale Type . CENTER ) { m Base Matrix . post Translate ( ( view Width - drawable Width ) / NUM_ , ( view Height - drawable Height ) / NUM_ ) ; } else if ( m Scale Type == Scale Type . CENTER CROP ) { float scale = Math . max ( width Scale , height Scale ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM_ , ( view Height - drawable Height * scale ) / NUM_ ) ; } else if ( m Scale Type == Scale Type . CENTER INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( width Scale , height Scale ) ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM_ , ( view Height - drawable Height * scale ) / NUM_ ) ; } else { Rect F m Temp Src = new Rect F ( NUM_ , NUM_ , drawable Width , drawable Height ) ; Rect F m Temp Dst = new Rect F ( NUM_ , NUM_ , view Width , view Height ) ; switch ( m Scale Type ) { case FIT CENTER : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . CENTER ) ; break ; case FIT START : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . START ) ; break ; case FIT END : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . END ) ; break ; case FIT XY : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }
public static Output Stream output Stream ( String out ) throws IO Exception { if ( out . equals ( STR_ ) ) { return Forbidden Ok . system Dot Out ( ) ; } Files . create Parent Dirs ( new File ( out ) ) ; Output Stream stream = new Buffered Output Stream ( new File Output Stream ( out ) ) ; if ( out . ends With ( STR_ ) ) { stream = new GZIP Output Stream ( stream ) ; } return stream ; }
public static void show Contact On Map ( Context ctx , Contact Id contact ) { Set < Contact Id > set = new Hash Set < > ( ) ; set . add ( contact ) ; show Contacts On Map ( ctx , set ) ; }
public Builder index In ( Index Range ... ranges ) { verify Not Null ( ranges ) ; expressions . add ( new Event Filter Expression . Index In ( ranges ) ) ; return this ; }
public void register Wildcard ( Symbol holder , JC Wildcard wildcard ) { if ( wildcard . get Bound ( ) == null ) { return ; } List < JC Wildcard > l = wildcards . get ( holder ) ; if ( l == null ) { l = new Array List < > ( ) ; wildcards . put ( holder , l ) ; } l . add ( wildcard ) ; wildcard Names . put ( wildcard , STR_ + l . size ( ) ) ; }
public void add ( final Banks bank , final Entity entity ) { final List < Entity > bank Access = get List Adding Unknown Banks ( bank ) ; if ( ! bank Access . contains ( entity ) ) { bank Access . add ( entity ) ; } }
private static URL [ ] path To UR Ls ( String path ) { String [ ] components = path . split ( File . path Separator ) ; URL [ ] urls = new URL [ components . length ] ; int count = NUM_ ; while ( count < components . length ) { URL url = file To URL ( new File ( components [ count ] ) ) ; if ( url != null ) { urls [ count ++ ] = url ; } } if ( urls . length != count ) { URL [ ] tmp = new URL [ count ] ; System . arraycopy ( urls , NUM_ , tmp , NUM_ , count ) ; urls = tmp ; } return urls ; }
protected boolean has Project Nature ( Maven Project maven Project , String nature Id ) { if ( nature Id == GWT Nature . NATURE ID || get Gwt Maven Plugin ( maven Project ) != null ) { return true ; } Plugin plugin = get Eclipse Plugin ( maven Project ) ; if ( plugin != null ) { Xpp 3 Dom configuration = ( Xpp 3 Dom ) plugin . get Configuration ( ) ; if ( configuration != null ) { Xpp 3 Dom additional Build Commands = configuration . get Child ( STR_ ) ; if ( additional Build Commands != null ) { for ( Xpp 3 Dom project Nature : additional Build Commands . get Children ( STR_ ) ) { if ( project Nature != null && nature Id . equals ( project Nature . get Value ( ) ) ) { return true ; } } } } } return false ; }
public Object deserialize ( final Type manifest , final Input Stream stream , final byte [ ] buffer ) throws IO Exception { if ( manifest instanceof Class < ? > ) { return deserialize ( ( Class < ? > ) manifest , stream , buffer ) ; } final Json Stream Reader json = new Json Stream Reader < T Context > ( stream , buffer , context ) ; json . get Next Token ( ) ; if ( json . was Null ( ) ) { return null ; } final Object result = deserialize With ( manifest , json ) ; if ( result != null ) return result ; if ( fallback != null ) { return fallback . deserialize ( context , manifest , json . stream From Start ( ) ) ; } throw new IO Exception ( STR_ + manifest + STR_ + STR_ + get Class ( ) ) ; }
protected boolean rem Link ( String field , int len , int n , int e ) { int [ ] array = ( int [ ] ) m links . get ( n , field ) ; for ( int i = NUM_ ; i < len ; ++ i ) { if ( array [ i ] == e ) { System . arraycopy ( array , i + NUM_ , array , i , len - i - NUM_ ) ; return true ; } } return false ; }
public static boolean [ ] identify Dimension Type ( List < Carbon Dimension > table Dimension List ) { List < Boolean > is Dictionary Dimensions = new Array List < Boolean > ( ) ; Set < Integer > processed Column Group = new Hash Set < Integer > ( ) ; for ( Carbon Dimension carbon Dimension : table Dimension List ) { List < Carbon Dimension > childs = carbon Dimension . get List Of Child Dimensions ( ) ; if ( null != childs && childs . size ( ) > NUM_ ) { break ; } if ( carbon Dimension . is Columnar ( ) && has Encoding ( carbon Dimension . get Encoder ( ) , Encoding . DICTIONARY ) ) { is Dictionary Dimensions . add ( true ) ; } else if ( ! carbon Dimension . is Columnar ( ) ) { if ( processed Column Group . add ( carbon Dimension . column Group Id ( ) ) ) { is Dictionary Dimensions . add ( true ) ; } } else { is Dictionary Dimensions . add ( false ) ; } } boolean [ ] primitive = Array Utils . to Primitive ( is Dictionary Dimensions . to Array ( new Boolean [ is Dictionary Dimensions . size ( ) ] ) ) ; return primitive ; }
public void register Share Key ( String share Key ) { share Keys . add ( share Key ) ; }
@ Suppress Warnings ( STR_ ) public void await Last Fut ( ) { Future Holder holder = last Fut . get ( ) ; Ignite Internal Future fut = holder . future ( ) ; if ( fut != null && ! fut . is Done ( ) ) { try { fut . get ( ) ; } catch ( Ignite Checked Exception ignored ) { } } }
public void reset Policy ( ) { m Preferences . put String ( PREF LAST RESPONSE , Integer . to String ( Policy . RETRY ) ) ; set Retry Until ( DEFAULT RETRY UNTIL ) ; set Max Retries ( DEFAULT MAX RETRIES ) ; set Retry Count ( Long . parse Long ( DEFAULT RETRY COUNT ) ) ; set Validity Timestamp ( DEFAULT VALIDITY TIMESTAMP ) ; m Preferences . commit ( ) ; }
@ Override public void clear Selection ( ) { selected Photos . clear ( ) ; }
final boolean complete ( long timeout Millis ) throws Interrupted Exception , Execution Exception { long total Wait = timeout Millis ; if ( total Wait <= NUM_ ) total Wait = NUM_ ; synchronized ( this ) { completer = Thread . current Thread ( ) ; } final long start = System . current Time Millis ( ) ; try { while ( ( System . current Time Millis ( ) - start ) < total Wait ) { if ( Thread . interrupted ( ) ) throw new Interrupted Exception ( ) ; Throwable t = get Last Error ( ) ; if ( t != null ) { throw execution Exception ( t ) ; } if ( ! has Active Tasks ( ) ) { break ; } synchronized ( completer ) { if ( ! completer Notify ) { try { completer . wait ( total Wait ) ; } catch ( Interrupted Exception e ) { if ( ! completer Notify ) { throw e ; } } } completer Notify = false ; } } } finally { synchronized ( this ) { completer = null ; } } return ( ( System . current Time Millis ( ) - start ) < total Wait ) ; }
public void testas Int Buffer ( ) throws IO Exception { File Input Stream fis = new File Input Stream ( tmp File ) ; File Channel fc = fis . get Channel ( ) ; Mapped Byte Buffer mmb = fc . map ( File Channel . Map Mode . READ ONLY , NUM_ , fc . size ( ) ) ; int len = mmb . capacity ( ) ; assert Equals ( STR_ , NUM_ , len ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { byte b = mmb . get ( ) ; assert Equals ( STR_ , ( byte ) STR_ + i , b ) ; } Int Buffer ibuffer = mmb . as Int Buffer ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int val = ibuffer . get ( ) ; assert Equals ( STR_ , i + NUM_ , val ) ; } fc . close ( ) ; }
public static void add Complete To Include Path From Doc ( final File Object doc ) { File Object ci Root = get Ci Root ( doc ) ; if ( ci Root == null ) { return ; } Project project = File Owner Query . get Owner ( ci Root ) ; if ( project == null ) { return ; } add Complete To Include Path ( ci Root , project ) ; }
public void flush ( ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . flush ( ) ; }
public static void launch ( I Project project , String mode ) { launch ( project , mode , null , null ) ; }
public void shutdown ( ) { if ( parallel Executor != null && ! parallel Executor . is Shutdown ( ) ) Executor Util . shutdown And Await Termination ( parallel Executor ) ; }
public void on Settings ( View v ) { if ( s Go Coder SDK == null ) return ; WZ Media Config configs [ ] = ( m WZ Camera View != null ? get Video Configs ( m WZ Camera View ) : new WZ Media Config [ NUM_ ] ) ; WZ Profile Level avc Profile Levels [ ] = WZ Encoder API . get Profile Levels ( ) ; if ( avc Profile Levels . length > NUM_ ) Arrays . sort ( avc Profile Levels ) ; Intent intent = new Intent ( this , Config Prefs Activity . class ) ; intent . put Extra ( Config Prefs . PREFS TYPE , Config Prefs . ALL PREFS ) ; intent . put Extra ( Config Prefs . VIDEO CONFIGS , configs ) ; intent . put Extra ( Config Prefs . H 264 PROFILE LEVELS , avc Profile Levels ) ; start Activity ( intent ) ; }
private void unify Username By Email ( Map < String , List < Log Commit Info > > username Map ) { for ( Entry < String , List < Log Commit Info > > entry : username Map . entry Set ( ) ) { List < String > names = get Names List ( entry . get Value ( ) ) ; String new User Name = names . get ( NUM_ ) ; if ( names . size ( ) > NUM_ ) new User Name = get New Name ( names ) ; for ( Log Commit Info commit : entry . get Value ( ) ) { commit . set User Name ( new User Name ) ; } } }
private void add Parents ( Lop node , Array List < Lop > node v , Array List < Lop > exec n ) { for ( Lop enode : exec n ) { if ( is Child ( node , enode , ID Map ) ) { if ( ! node v . contains ( enode ) ) { if ( LOG . is Trace Enabled ( ) ) LOG . trace ( STR_ + enode . to String ( ) ) ; node v . add ( enode ) ; } } } }
boolean validate Password ( final String username , final String password ) { if ( password . length ( ) > NUM_ ) { boolean all Numbers = true ; try { Integer . parse Int ( password ) ; } catch ( final Number Format Exception e ) { all Numbers = false ; } if ( all Numbers ) { bad Password Reason = STR_ + STR_ ; } boolean has Username = false ; if ( password . contains ( username ) ) { has Username = true ; } if ( ! has Username ) { debug ( STR_ ) ; final int min User Length = NUM_ ; for ( int i = NUM_ ; i < username . length ( ) ; i ++ ) { final String subuser = username . substring ( NUM_ , username . length ( ) - i ) ; debug ( STR_ + subuser + STR_ ) ; if ( subuser . length ( ) <= min User Length ) { break ; } if ( password . contains ( subuser ) ) { has Username = true ; debug ( STR_ ) ; break ; } } if ( ! has Username ) { debug ( STR_ ) ; for ( int i = NUM_ ; i < username . length ( ) ; i ++ ) { final String subuser = username . substring ( i ) ; debug ( STR_ + subuser + STR_ ) ; if ( subuser . length ( ) <= min User Length ) { break ; } if ( password . contains ( subuser ) ) { has Username = true ; debug ( STR_ ) ; break ; } } } } if ( has Username ) { bad Password Reason = STR_ + STR_ ; return false ; } } else { final String text = STR_ ; if ( is Visible ( ) ) { J Option Pane . show Message Dialog ( get Owner ( ) , text ) ; } else { LOGGER . warn ( text ) ; } return false ; } return true ; }
public void resume ( String id ) { try { suspended State Lock . lock ( ) ; Trace State ts = suspended State . get ( id ) ; if ( ts != null ) { clear Expire ( ts ) ; if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( STR_ + ts + STR_ + id ) ; } if ( trace State . get ( ) != null && log . is Loggable ( Level . FINEST ) ) { log . finest ( STR_ + trace State . get ( ) ) ; } trace State . set ( ts ) ; suspended State . remove ( id ) ; } } finally { suspended State Lock . unlock ( ) ; } }
@ Override public void do Run Keys ( int run ) throws Exception { if ( m Instances == null ) { throw new Exception ( STR_ ) ; } Object [ ] se Key = m Split Evaluator . get Key ( ) ; Object [ ] key = new Object [ se Key . length + NUM_ ] ; key [ NUM_ ] = Utils . back Quote Chars ( m Instances . relation Name ( ) ) ; key [ NUM_ ] = STR_ + run ; System . arraycopy ( se Key , NUM_ , key , NUM_ , se Key . length ) ; if ( m Result Listener . is Result Required ( this , key ) ) { try { m Result Listener . accept Result ( this , key , null ) ; } catch ( Exception ex ) { throw ex ; } } }
public Set key Set ( ) { return map . key Set ( ) ; }
private boolean is Ready To Be Executed Locked ( Job Status job ) { final boolean job Ready = job . is Ready ( ) ; final boolean job Pending = m Pending Jobs . contains ( job ) ; final boolean job Active = is Currently Active Locked ( job ) ; final boolean user Running = m Started Users . contains ( job . get User Id ( ) ) ; return user Running && job Ready && ! job Pending && ! job Active ; }
void get Chars ( int start , int end , char [ ] buffer , int index ) { System . arraycopy ( value , start + offset , buffer , index , end - start ) ; }
public void uncollapse ( Set < Integer > to Uncollapse , Set < Integer > collapsed Ids ) { Set < Integer > new Collapsed = new Hash Set < > ( ) ; for ( Node v = get First Node ( ) ; v != null ; v = v . get Next ( ) ) { int v Id = ( Integer ) v . get Info ( ) ; if ( to Uncollapse . contains ( v Id ) && collapsed Ids . contains ( v Id ) ) { for ( Edge e = v . get First Out Edge ( ) ; e != null ; e = v . get Next Out Edge ( e ) ) { Node w = e . get Target ( ) ; new Collapsed . add ( ( Integer ) w . get Info ( ) ) ; } } } collapsed Ids . remove All ( to Uncollapse ) ; collapsed Ids . add All ( new Collapsed ) ; }
public void write Paths To Stream ( final Object Output os ) throws IO Exception { final byte [ ] dvr = glyph Display . serialize To Byte Array ( null ) ; os . write Object ( dvr ) ; os . write Int ( max Width ) ; os . write Int ( max Height ) ; os . write Boolean ( lock Colours ) ; }
private void internal Group Snap Copy To Target ( Storage System storage , Block Snapshot snapshot , List < URI > snapshot List ) throws Exception { String snap Group Name = snapshot . get Replication Group Instance ( ) ; CIM Object Path target Group = cim Path . get Replication Group Path ( storage , snap Group Name ) ; CIM Object Path settings State = helper . get Settings Define State For Source Group ( storage , snapshot . get Settings Group Instance ( ) ) ; CIM Argument [ ] in Args = helper . get VNX Copy To Target Group Input Arguments ( settings State , target Group ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM_ ] ; helper . call Modify Settings Define State ( storage , in Args , out Args ) ; List < Block Snapshot > snapshots = db Client . query Object ( Block Snapshot . class , snapshot List ) ; for ( Block Snapshot it : snapshots ) { it . set Needs Copy To Target ( false ) ; } db Client . persist Object ( snapshots ) ; }
public synchronized void add Vetoable Change Listener ( Vetoable Change Listener l ) { m vetoable Change Support . add Vetoable Change Listener ( l ) ; }
public void create Accrual Based Journal Entries And Reversals For Loan ( final Office office , final String currency Code , final Integer account Type To Be Debited , final Integer account Type To Be Credited , final Long loan Product Id , final Long payment Type Id , final Long loan Id , final String transaction Id , final Date transaction Date , final Big Decimal amount , final Boolean is Reversal ) { int account Type To Debit Id = account Type To Be Debited ; int account Type To Credit Id = account Type To Be Credited ; if ( is Reversal ) { account Type To Debit Id = account Type To Be Credited ; account Type To Credit Id = account Type To Be Debited ; } create Journal Entries For Loan ( office , currency Code , account Type To Debit Id , account Type To Credit Id , loan Product Id , payment Type Id , loan Id , transaction Id , transaction Date , amount ) ; }
private static int calculate Checksum ( final String tag String , final Byte Buffer data ) { int sum = NUM_ ; data . mark ( ) ; if ( tag String . equals ( STR_ ) ) { data . put Int ( NUM_ , NUM_ ) ; } for ( int i = NUM_ , nlongs = ( data . remaining ( ) + NUM_ ) / NUM_ ; i < nlongs ; ++ i ) { switch ( data . remaining ( ) ) { case NUM_ : sum += ( ( data . get Short ( ) << NUM_ ) + ( data . get ( ) << NUM_ ) ) ; break ; case NUM_ : sum += ( data . get Short ( ) << NUM_ ) ; break ; case NUM_ : sum += ( ( data . get ( ) & NUM_ ) << NUM_ ) ; break ; default : sum += data . get Int ( ) ; } } data . reset ( ) ; return sum ; }
public void close Entry ( ) throws IO Exception { ensure Open ( ) ; if ( current != null ) { Zip Entry e = current . entry ; switch ( e . method ) { case DEFLATED : def . finish ( ) ; while ( ! def . finished ( ) ) { deflate ( ) ; } if ( ( e . flag & NUM_ ) == NUM_ ) { if ( e . size != def . get Bytes Read ( ) ) { throw new Zip Exception ( STR_ + e . size + STR_ + def . get Bytes Read ( ) + STR_ ) ; } if ( e . csize != def . get Bytes Written ( ) ) { throw new Zip Exception ( STR_ + e . csize + STR_ + def . get Bytes Written ( ) + STR_ ) ; } if ( e . crc != crc . get Value ( ) ) { throw new Zip Exception ( STR_ + Long . to Hex String ( e . crc ) + STR_ + Long . to Hex String ( crc . get Value ( ) ) + STR_ ) ; } } else { e . size = def . get Bytes Read ( ) ; e . csize = def . get Bytes Written ( ) ; e . crc = crc . get Value ( ) ; write EXT ( e ) ; } def . reset ( ) ; written += e . csize ; break ; case STORED : if ( e . size != written - locoff ) { throw new Zip Exception ( STR_ + e . size + STR_ + ( written - locoff ) + STR_ ) ; } if ( e . crc != crc . get Value ( ) ) { throw new Zip Exception ( STR_ + Long . to Hex String ( e . crc ) + STR_ + Long . to Hex String ( crc . get Value ( ) ) + STR_ ) ; } break ; default : throw new Zip Exception ( STR_ ) ; } crc . reset ( ) ; current = null ; } }
public Monetary Format code ( int code Shift , String code ) { check Argument ( code Shift >= NUM_ ) ; final String [ ] codes = null == this . codes ? new String [ MAX DECIMALS ] : Arrays . copy Of ( this . codes , this . codes . length ) ; codes [ code Shift ] = code ; return new Monetary Format ( negative Sign , positive Sign , zero Digit , decimal Mark , min Decimals , decimal Groups , shift , rounding Mode , codes , code Separator , code Prefixed ) ; }
@ Transactional public long create Pre Approved Voucher From Bill For PJV ( final int bill Id , final List < Pre Approved Voucher > voucherdetail List , final List < Pre Approved Voucher > sub Ledger List ) throws Application Runtime Exception { String voucher Status = null ; long vh = - NUM_ ; try { final List v Status List = app Config Values Service . get Config Values By Module And Key ( STR_ , STR_ ) ; if ( ! v Status List . is Empty ( ) && v Status List . size ( ) == NUM_ ) { final App Config Values app Val = ( App Config Values ) v Status List . get ( NUM_ ) ; voucher Status = app Val . get Value ( ) ; } else throw new Application Runtime Exception ( STR_ + MISSINGMSG ) ; vh = create Voucher . create Voucher From Bill For PJV ( bill Id , voucher Status , voucherdetail List , sub Ledger List ) ; } catch ( final Exception e ) { LOGGER . error ( e . get Message ( ) ) ; throw new Application Runtime Exception ( e . get Message ( ) ) ; } return vh ; }
public Reflective Property ( Class < T > property Holder , Class < V > value Type , String name ) { super ( value Type , name ) ; char first Letter = Character . to Upper Case ( name . char At ( NUM_ ) ) ; String the Rest = name . substring ( NUM_ ) ; String capitalized Name = first Letter + the Rest ; String getter Name = PREFIX GET + capitalized Name ; try { m Getter = property Holder . get Method ( getter Name , ( Class < ? > [ ] ) null ) ; } catch ( No Such Method Exception e ) { try { m Getter = property Holder . get Declared Method ( getter Name , ( Class < ? > [ ] ) null ) ; m Getter . set Accessible ( true ) ; } catch ( No Such Method Exception e 2 ) { getter Name = PREFIX IS + capitalized Name ; try { m Getter = property Holder . get Method ( getter Name , ( Class < ? > [ ] ) null ) ; } catch ( No Such Method Exception e 3 ) { try { m Getter = property Holder . get Declared Method ( getter Name , ( Class < ? > [ ] ) null ) ; m Getter . set Accessible ( true ) ; } catch ( No Such Method Exception e 4 ) { try { m Field = property Holder . get Field ( name ) ; Class field Type = m Field . get Type ( ) ; if ( ! types Match ( value Type , field Type ) ) { throw new No Such Property Exception ( STR_ + field Type + STR_ + STR_ + value Type + STR_ ) ; } return ; } catch ( No Such Field Exception e 5 ) { throw new No Such Property Exception ( STR_ + STR_ + name ) ; } } } } } Class getter Type = m Getter . get Return Type ( ) ; if ( ! types Match ( value Type , getter Type ) ) { throw new No Such Property Exception ( STR_ + getter Type + STR_ + STR_ + value Type + STR_ ) ; } String setter Name = PREFIX SET + capitalized Name ; try { m Setter = property Holder . get Declared Method ( setter Name , getter Type ) ; m Setter . set Accessible ( true ) ; } catch ( No Such Method Exception ignored ) { } }
public Host Scsi Disk find Lun Disk ( int hlu , Collection < String > source Names , Collection < String > target Names ) { Map < String , Host Host Bus Adapter > hbas = get Host Bus Adapters ( ) ; String disk Key = null ; for ( Host Scsi Topology Interface adapter : list Scsi Topology Interfaces ( ) ) { Host Host Bus Adapter hba = hbas . get ( adapter . get Adapter ( ) ) ; String source Name = get Source Name ( hba ) ; if ( ! source Names . contains ( source Name ) || ( adapter . get Target ( ) == null ) ) { continue ; } for ( Host Scsi Topology Target target : adapter . get Target ( ) ) { String target Name = get Target Name ( target ) ; if ( ! target Names . contains ( target Name ) ) { continue ; } Host Scsi Topology Lun lun = find Lun ( target , hlu ) ; if ( lun != null ) { String key = lun . get Scsi Lun ( ) ; if ( disk Key == null ) { disk Key = key ; } else if ( ! String Utils . equals ( disk Key , key ) ) { throw new Illegal Argument Exception ( STR_ + hlu + STR_ + target Names ) ; } } } } if ( disk Key == null ) { return null ; } Host Scsi Disk disk = get Scsi Disk By Key ( disk Key ) ; return disk ; }
public void register Share Key ( String share Key ) { connection Directory . register Share Key ( share Key ) ; }
public void run Update Now ( ) { synchronized ( this ) { if ( done || screen Updater == null || d 3 dw Surfaces == null || d 3 dw Surfaces . size ( ) == NUM_ ) { return ; } } synchronized ( run Lock ) { needs Update Now = true ; run Lock . notify All ( ) ; while ( needs Update Now ) { try { run Lock . wait ( ) ; } catch ( Interrupted Exception e ) { } } } }
protected void write Tld Description ( ) throws IO Exception { writer . start Element ( STR_ ) ; writer . write Comment ( STR_ ) ; writer . start Element ( STR_ ) ; writer . write Text ( JSF TLIB VERSION ) ; writer . close Element ( ) ; writer . start Element ( STR_ ) ; writer . write Text ( JSP VERSION ) ; writer . close Element ( ) ; writer . start Element ( STR_ ) ; writer . write Text ( prop Manager . get Property ( Property Manager . TAGLIB SHORT NAME ) ) ; writer . close Element ( ) ; writer . start Element ( STR_ ) ; writer . write Text ( prop Manager . get Property ( Property Manager . TAGLIB URI ) ) ; writer . close Element ( ) ; String description = prop Manager . get Property ( Property Manager . TAGLIB DESCRIPTION ) ; if ( description != null && description . length ( ) > NUM_ ) { writer . start Element ( STR_ ) ; writer . write Text ( description ) ; writer . close Element ( ) ; } }
private void add Listener ( final Engine Change Listener listener ) { if ( ! listeners . contains ( listener ) ) listeners . add ( listener ) ; }
public int alloc ( int size ) { int index = n ; int len = array . length ; if ( n + size >= len ) { char [ ] aux = new char [ len + block Size ] ; System . arraycopy ( array , NUM_ , aux , NUM_ , len ) ; array = aux ; } n += size ; return index ; }
public void add Ok Listener ( Action Listener a ) { m ok But . add Action Listener ( a ) ; }
public static void over Scroll By ( final Pull To Refresh Base < ? > view , final int delta X , final int scroll X , final int delta Y , final int scroll Y , final int scroll Range , final int fuzzy Threshold , final float scale Factor , final boolean is Touch Event ) { final int delta Value , current Scroll Value , scroll Value ; switch ( view . get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : delta Value = delta X ; scroll Value = scroll X ; current Scroll Value = view . get Scroll X ( ) ; break ; case VERTICAL : default : delta Value = delta Y ; scroll Value = scroll Y ; current Scroll Value = view . get Scroll Y ( ) ; break ; } if ( view . is Pull To Refresh Over Scroll Enabled ( ) && ! view . is Refreshing ( ) ) { final Pull To Refresh Base . Mode mode = view . get Mode ( ) ; if ( mode . permits Pull To Refresh ( ) && ! is Touch Event && delta Value != NUM_ ) { final int new Scroll Value = ( delta Value + scroll Value ) ; if ( Pull To Refresh Base . DEBUG ) { Log . d ( LOG TAG , STR_ + delta X + STR_ + scroll X + STR_ + delta Y + STR_ + scroll Y + STR_ + new Scroll Value + STR_ + scroll Range + STR_ + current Scroll Value ) ; } if ( new Scroll Value < ( NUM_ - fuzzy Threshold ) ) { if ( mode . show Header Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( Pull To Refresh Base . State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value ) ) ) ; } } else if ( new Scroll Value > ( scroll Range + fuzzy Threshold ) ) { if ( mode . show Footer Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( Pull To Refresh Base . State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value - scroll Range ) ) ) ; } } else if ( Math . abs ( new Scroll Value ) <= fuzzy Threshold || Math . abs ( new Scroll Value - scroll Range ) <= fuzzy Threshold ) { view . set State ( Pull To Refresh Base . State . RESET ) ; } } else if ( is Touch Event && Pull To Refresh Base . State . OVERSCROLLING == view . get State ( ) ) { view . set State ( Pull To Refresh Base . State . RESET ) ; } } }
protected void handle Special Substitution ( String replace , String replace With , int start Pos , String description ) { super . handle Special Substitution ( replace , replace With , start Pos , description ) ; if ( replace . equals ( STR_ ) ) { if ( replace With . char At ( NUM_ ) == STR_ ) { error ( STR_ , start Pos , description ) ; } dictionary Expression = replace With ; dictionary Chars = Char Set . parse String ( replace With ) ; } }
public int compare To ( Date another Date ) { long this Time = get Millis Of ( this ) ; long another Time = get Millis Of ( another Date ) ; return ( this Time < another Time ? - NUM_ : ( this Time == another Time ? NUM_ : NUM_ ) ) ; }
public Triangle ( ) { Byte Buffer bb = Byte Buffer . allocate Direct ( triangle Coords . length * NUM_ ) ; bb . order ( Byte Order . native Order ( ) ) ; vertex Buffer = bb . as Float Buffer ( ) ; vertex Buffer . put ( triangle Coords ) ; vertex Buffer . position ( NUM_ ) ; }
protected void fire Property Change ( String property Name , int old Value , int new Value ) { Property Change Support change Support = this . change Support ; if ( change Support == null || old Value == new Value ) { return ; } change Support . fire Property Change ( property Name , old Value , new Value ) ; }
private Rectangle 2 D create Shadow ( Rectangular Shape bar , double x Offset , double y Offset , Rectangle Edge base , boolean peg Shadow ) { double x 0 = bar . get Min X ( ) ; double x 1 = bar . get Max X ( ) ; double y 0 = bar . get Min Y ( ) ; double y 1 = bar . get Max Y ( ) ; if ( base == Rectangle Edge . TOP ) { x 0 += x Offset ; x 1 += x Offset ; if ( ! peg Shadow ) { y 0 += y Offset ; } y 1 += y Offset ; } else if ( base == Rectangle Edge . BOTTOM ) { x 0 += x Offset ; x 1 += x Offset ; y 0 += y Offset ; if ( ! peg Shadow ) { y 1 += y Offset ; } } else if ( base == Rectangle Edge . LEFT ) { if ( ! peg Shadow ) { x 0 += x Offset ; } x 1 += x Offset ; y 0 += y Offset ; y 1 += y Offset ; } else if ( base == Rectangle Edge . RIGHT ) { x 0 += x Offset ; if ( ! peg Shadow ) { x 1 += x Offset ; } y 0 += y Offset ; y 1 += y Offset ; } return new Rectangle 2 D . Double ( x 0 , y 0 , ( x 1 - x 0 ) , ( y 1 - y 0 ) ) ; }
@ Override protected Change configure Cache Object ( Sub Equipment sub Equipment , Properties properties ) { Sub Equipment Cache Object sub Equipment Cache Object = ( Sub Equipment Cache Object ) sub Equipment ; Equipment Configuration Update update = set Common Properties ( sub Equipment , properties ) ; String tmp Str = properties . get Property ( STR_ ) ; if ( tmp Str == null ) { tmp Str = properties . get Property ( STR_ ) ; } if ( tmp Str != null ) { try { sub Equipment Cache Object . set Parent Id ( Long . value Of ( tmp Str ) ) ; } catch ( Number Format Exception e ) { throw new Configuration Exception ( Configuration Exception . INVALID PARAMETER VALUE , STR_ + tmp Str ) ; } } return update ; }
@ Override protected void prepare Builders ( @ Nullable String cache Name , Collection < Jdbc Type > types ) throws Cache Exception { Map < String , Pojo Properties Cache > pojo Props = U . new Hash Map ( types . size ( ) * NUM_ ) ; for ( Jdbc Type type : types ) { String key Type Name = type . get Key Type ( ) ; Type Kind key Kind = kind For Name ( key Type Name ) ; if ( key Kind == Type Kind . POJO ) { if ( pojo Props . contains Key ( key Type Name ) ) throw new Cache Exception ( STR_ + U . mask Name ( cache Name ) + STR_ + key Type Name + STR_ ) ; pojo Props . put ( key Type Name , new Pojo Properties Cache ( key Type Name , type . get Key Fields ( ) ) ) ; } String val Type Name = type . get Value Type ( ) ; Type Kind val Kind = kind For Name ( val Type Name ) ; if ( val Kind == Type Kind . POJO ) pojo Props . put ( val Type Name , new Pojo Properties Cache ( val Type Name , type . get Value Fields ( ) ) ) ; } if ( ! pojo Props . is Empty ( ) ) { Map < String , Map < String , Pojo Properties Cache > > new Pojos Props = new Hash Map < > ( pojos Props ) ; new Pojos Props . put ( cache Name , pojo Props ) ; pojos Props = new Pojos Props ; } }
public static String normalize Wwn ( long wwn ) { return normalize Wwn ( Long . to Hex String ( wwn ) ) ; }
protected List create Parent Boundables ( List child Boundables , int new Level ) { Assert . is True ( ! child Boundables . is Empty ( ) ) ; int min Leaf Count = ( int ) Math . ceil ( ( child Boundables . size ( ) / ( double ) get Node Capacity ( ) ) ) ; Array List sorted Child Boundables = new Array List ( child Boundables ) ; Collections . sort ( sorted Child Boundables , x Comparator ) ; List [ ] vertical Slices = vertical Slices ( sorted Child Boundables , ( int ) Math . ceil ( Math . sqrt ( min Leaf Count ) ) ) ; return create Parent Boundables From Vertical Slices ( vertical Slices , new Level ) ; }
public Map < String , Integer > types For Columns ( List < Query Source > relations ) { Hash Map < String , Integer > col Type = new Hash Map < String , Integer > ( ) ; col Type . put ( Heading . ID , Types . VARCHAR ) ; col Type . put ( Heading . TYPE , Types . VARCHAR ) ; col Type . put ( Heading . INDEX , Types . VARCHAR ) ; for ( Query Source table : relations ) { if ( ! table Column Info . contains Key ( table . get Source ( ) ) ) continue ; col Type . put All ( table Column Info . get ( table . get Source ( ) ) ) ; } return col Type ; }
private void remove Keys ( Hashtable theme Res , String uiid ) { if ( uiid == null || uiid . length ( ) == NUM_ ) { for ( Object k : theme Res . key Set ( ) ) { String key = ( String ) k ; if ( key . index Of ( STR_ ) > - NUM_ || key . index Of ( STR_ ) > - NUM_ || key . index Of ( STR_ ) > - NUM_ ) { continue ; } theme Res . remove ( key ) ; remove Keys ( theme Res , uiid ) ; return ; } return ; } for ( Object k : theme Res . key Set ( ) ) { String key = ( String ) k ; if ( key . starts With ( uiid ) ) { if ( prefix . length ( ) == NUM_ && key . index Of ( STR_ ) > NUM_ ) { continue ; } theme Res . remove ( key ) ; remove Keys ( theme Res , uiid ) ; return ; } } }
public Domain Content load Static Content ( Space space ) { Universe univ = space . get Universe ( ) ; Domain domain = space . get Domain ( ) ; List < Dimension > dimensions = dimension DAO . find By Domain ( univ . get Context ( ) , domain . get Id ( ) ) ; List < Metric > metrics = metric DAO . find By Domain ( univ . get Context ( ) , domain . get Id ( ) ) ; Domain Content content = new Domain Content ( domain , dimensions , metrics ) ; return content ; }
public static final double [ ] resize ( double [ ] a , int size ) { if ( a . length >= size ) return a ; double [ ] b = new double [ size ] ; System . arraycopy ( a , NUM_ , b , NUM_ , a . length ) ; return b ; }
private void print Class ( Type Element type Element ) { print Class ( type Element , null ) ; }
public void add Return Hotspot ( String signature ) { List < Value Box > sig Spots = String Analysis . get Return Expressions ( signature ) ; logger . debug ( STR_ + signature + STR_ + sig Spots . size ( ) + STR_ ) ; if ( ! sig Spots . is Empty ( ) ) { add Signature To Hotspot Map ( signature , new Hotspot ( signature , sig Spots ) ) ; hotspots . add All ( sig Spots ) ; } }
private String decrypt Image URL Password ( String image Url ) { String password = extract Password From Image Url ( image Url ) ; if ( String Utils . is Not Blank ( password ) ) { String enc Pwd = null ; try { Encryption Provider Impl encryption Provider Impl = new Encryption Provider Impl ( ) ; encryption Provider Impl . set Coordinator ( coordinator ) ; encryption Provider Impl . start ( ) ; Encryption Provider encryption Provider = encryption Provider Impl ; enc Pwd = URL Encoder . encode ( encryption Provider . decrypt ( Base 64 . decode Base 64 ( password ) ) , STR_ ) ; return String Utils . replace ( image Url , STR_ + password + STR_ , STR_ + enc Pwd + STR_ ) ; } catch ( Unsupported Encoding Exception e ) { log . warn ( STR_ + STR_ , image Url , e . get Message ( ) ) ; } catch ( Exception e ) { log . error ( STR_ + e . get Localized Message ( ) ) ; e . print Stack Trace ( ) ; throw e ; } } return image Url ; }
protected Class find Class ( String name ) throws Class Not Found Exception { Class Manager Impl bcm = ( Class Manager Impl ) get Class Manager ( ) ; Class Loader cl = bcm . get Loader For Class ( name ) ; Class c ; if ( cl != null && cl != this ) try { return cl . load Class ( name ) ; } catch ( Class Not Found Exception e ) { throw new Class Not Found Exception ( STR_ + e ) ; } if ( get UR Ls ( ) . length > NUM_ ) try { return super . find Class ( name ) ; } catch ( Class Not Found Exception e ) { } cl = bcm . get Base Loader ( ) ; if ( cl != null && cl != this ) try { return cl . load Class ( name ) ; } catch ( Class Not Found Exception e ) { } return bcm . plain Class For Name ( name ) ; }
static String parse Prefix ( String key ) { if ( key == null ) return null ; boolean inquotes = false ; for ( int i = NUM_ ; i < key . length ( ) ; i ++ ) { char c = key . char At ( i ) ; if ( c == STR_ ) { inquotes = ! inquotes ; } else if ( ( c == STR_ || c == STR_ ) && ! inquotes ) { return key . substring ( NUM_ , i ) ; } } return null ; }
@ Override public String [ ] apply ( String [ ] words ) { if ( ! is Applicable ( ) ) return words ; for ( int i = NUM_ ; i < col List . length ; i ++ ) { int col ID = col List [ i ] ; try { double val = Util Functions . parse To Double ( words [ col ID - NUM_ ] ) ; int binid = NUM_ ; double tmp = min [ i ] + bin Widths [ i ] ; while ( val > tmp && binid < num Bins [ i ] ) { tmp += bin Widths [ i ] ; binid ++ ; } words [ col ID - NUM_ ] = Integer . to String ( binid ) ; } catch ( Number Format Exception e ) { throw new Runtime Exception ( STR_ + words [ col ID - NUM_ ] + STR_ + col ID + STR_ + words [ col ID - NUM_ ] + STR_ ) ; } } return words ; }
public int add Missing Columns ( M Print Format pf ) { log . config ( pf . to String ( ) ) ; String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; Prepared Statement pstmt = null ; Result Set rs = null ; int counter = NUM_ ; try { pstmt = DB . prepare Statement ( sql , pf . get Trx Name ( ) ) ; pstmt . set Int ( NUM_ , pf . get AD Print Format ID ( ) ) ; pstmt . set Int ( NUM_ , pf . get AD Table ID ( ) ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { int AD Column ID = rs . get Int ( NUM_ ) ; String Column Name = rs . get String ( NUM_ ) ; M Print Format Item pfi = M Print Format Item . create From Column ( pf , AD Column ID , NUM_ ) ; if ( pfi . get ID ( ) != NUM_ ) log . fine ( STR_ + ++ counter + STR_ + Column Name ) ; else log . warning ( STR_ + Column Name ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( counter == NUM_ ) log . fine ( STR_ ) ; else log . fine ( STR_ + counter ) ; return counter ; }
public void add Scroll View Listener ( WX Scroll View Listener scroll View Listener ) { if ( ! m Scroll View Listeners . contains ( scroll View Listener ) ) { m Scroll View Listeners . add ( scroll View Listener ) ; } }
public synchronized void record Statistics ( Query Statistic statistic ) { query Statistics . add ( statistic ) ; }
public void register ( Abstract Automaton a ) { synchronized ( automats ) { automats . add ( a ) ; } notify ( STR_ , null , Integer . value Of ( index Of ( a ) ) ) ; }
static void calculate Tiled Layout ( Layout Iterator iter , int target Span ) { long preferred = NUM_ ; long current Preferred ; int last Margin = NUM_ ; int total Spacing = NUM_ ; int n = iter . get Count ( ) ; int adjustment Weights Count = Layout Iterator . Worst Adjustment Weight + NUM_ ; long gain [ ] = new long [ adjustment Weights Count ] ; long loss [ ] = new long [ adjustment Weights Count ] ; for ( int i = NUM_ ; i < adjustment Weights Count ; i ++ ) { gain [ i ] = loss [ i ] = NUM_ ; } for ( int i = NUM_ ; i < n ; i ++ ) { iter . set Index ( i ) ; int margin 0 = last Margin ; int margin 1 = ( int ) iter . get Leading Collapse Span ( ) ; iter . set Offset ( Math . max ( margin 0 , margin 1 ) ) ; total Spacing += iter . get Offset ( ) ; current Preferred = ( long ) iter . get Preferred Span ( target Span ) ; iter . set Span ( ( int ) current Preferred ) ; preferred += current Preferred ; gain [ iter . get Adjustment Weight ( ) ] += ( long ) iter . get Maximum Span ( target Span ) - current Preferred ; loss [ iter . get Adjustment Weight ( ) ] += current Preferred - ( long ) iter . get Minimum Span ( target Span ) ; last Margin = ( int ) iter . get Trailing Collapse Span ( ) ; } total Spacing += last Margin ; total Spacing += NUM_ * iter . get Border Width ( ) ; for ( int i = NUM_ ; i < adjustment Weights Count ; i ++ ) { gain [ i ] += gain [ i - NUM_ ] ; loss [ i ] += loss [ i - NUM_ ] ; } int allocated = target Span - total Spacing ; long desired Adjustment = allocated - preferred ; long adjustments Array [ ] = ( desired Adjustment > NUM_ ) ? gain : loss ; desired Adjustment = Math . abs ( desired Adjustment ) ; int adjustment Level = NUM_ ; for ( ; adjustment Level <= Layout Iterator . Worst Adjustment Weight ; adjustment Level ++ ) { if ( adjustments Array [ adjustment Level ] >= desired Adjustment ) { break ; } } float adjustment Factor = NUM_ ; if ( adjustment Level <= Layout Iterator . Worst Adjustment Weight ) { desired Adjustment -= ( adjustment Level > NUM_ ) ? adjustments Array [ adjustment Level - NUM_ ] : NUM_ ; if ( desired Adjustment != NUM_ ) { float maximum Adjustment = adjustments Array [ adjustment Level ] - ( ( adjustment Level > NUM_ ) ? adjustments Array [ adjustment Level - NUM_ ] : NUM_ ) ; adjustment Factor = desired Adjustment / maximum Adjustment ; } } int total Offset = ( int ) iter . get Border Width ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { iter . set Index ( i ) ; iter . set Offset ( iter . get Offset ( ) + total Offset ) ; if ( iter . get Adjustment Weight ( ) < adjustment Level ) { iter . set Span ( ( int ) ( ( allocated > preferred ) ? Math . floor ( iter . get Maximum Span ( target Span ) ) : Math . ceil ( iter . get Minimum Span ( target Span ) ) ) ) ; } else if ( iter . get Adjustment Weight ( ) == adjustment Level ) { int available Span = ( allocated > preferred ) ? ( int ) iter . get Maximum Span ( target Span ) - iter . get Span ( ) : iter . get Span ( ) - ( int ) iter . get Minimum Span ( target Span ) ; int adj = ( int ) Math . floor ( adjustment Factor * available Span ) ; iter . set Span ( iter . get Span ( ) + ( ( allocated > preferred ) ? adj : - adj ) ) ; } total Offset = ( int ) Math . min ( ( long ) iter . get Offset ( ) + ( long ) iter . get Span ( ) , Integer . MAX VALUE ) ; } int round Error = target Span - total Offset - ( int ) iter . get Trailing Collapse Span ( ) - ( int ) iter . get Border Width ( ) ; int adj = ( round Error > NUM_ ) ? NUM_ : - NUM_ ; round Error *= adj ; boolean can Adjust = true ; while ( round Error > NUM_ && can Adjust ) { can Adjust = false ; int offset Adjust = NUM_ ; for ( int i = NUM_ ; i < n ; i ++ ) { iter . set Index ( i ) ; iter . set Offset ( iter . get Offset ( ) + offset Adjust ) ; int cur Span = iter . get Span ( ) ; if ( round Error > NUM_ ) { int bound Gap = ( adj > NUM_ ) ? ( int ) Math . floor ( iter . get Maximum Span ( target Span ) ) - cur Span : cur Span - ( int ) Math . ceil ( iter . get Minimum Span ( target Span ) ) ; if ( bound Gap >= NUM_ ) { can Adjust = true ; iter . set Span ( cur Span + adj ) ; offset Adjust += adj ; round Error -- ; } } } } }
private static String escape String ( String s , char quote , String doublequote Escape , String singlequote Escape , String backslash Escape ) { String Builder sb = new String Builder ( s . length ( ) + NUM_ ) ; sb . append ( quote ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; switch ( c ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( backslash Escape ) ; break ; case STR_ : sb . append ( doublequote Escape ) ; break ; case STR_ : sb . append ( singlequote Escape ) ; break ; case STR_ : if ( i >= NUM_ && ( ( s . char At ( i - NUM_ ) == STR_ && s . char At ( i - NUM_ ) == STR_ ) || ( s . char At ( i - NUM_ ) == STR_ && s . char At ( i - NUM_ ) == STR_ ) ) ) { sb . append ( STR_ ) ; } else { sb . append ( c ) ; } break ; case STR_ : final String END SCRIPT = STR_ ; final String START COMMENT = STR_ ; if ( s . region Matches ( true , i + NUM_ , END SCRIPT , NUM_ , END SCRIPT . length ( ) ) ) { sb . append ( STR_ ) ; } else if ( s . region Matches ( false , i + NUM_ , START COMMENT , NUM_ , START COMMENT . length ( ) ) ) { sb . append ( STR_ ) ; } else { sb . append ( c ) ; } break ; default : if ( c > NUM_ && c <= NUM_ ) { sb . append ( c ) ; } else { append Hex Java Script Representation ( sb , c ) ; } } } sb . append ( quote ) ; return sb . to String ( ) ; }
public boolean update ( Cache Object key , Cache Object val , long expiration Time , boolean rmv ) throws Ignite Checked Exception { assert desc != null ; Grid H 2 Row row = desc . create Row ( key , val , expiration Time ) ; if ( ! rmv ) ( ( Grid H 2 Abstract Key Value Row ) row ) . values Cache ( new Value [ get Columns ( ) . length ] ) ; try { return do Update ( row , rmv ) ; } finally { if ( ! rmv ) ( ( Grid H 2 Abstract Key Value Row ) row ) . values Cache ( null ) ; } }
public static String [ ] create Tags ( String c Name ) { String short Tag = Classification . create Short Tag ( c Name ) ; String long Tag = c Name . to Lower Case ( ) + STR_ ; if ( short Tag . equals ( long Tag ) ) return new String [ ] { short Tag } ; else return new String [ ] { short Tag , long Tag } ; }
public static void init Tables ( ) { int anti Optim = NUM_ ; anti Optim += My T Sin Cos . sin Tab . length ; anti Optim += My T Tan . tan Tab . length ; anti Optim += My T Asin . asin Tab . length ; anti Optim += My T Asin Pow . asin Pow Tab . length ; anti Optim += My T Atan . atan Tab . length ; anti Optim += My T Exp . exp Hi Tab . length ; anti Optim += My T Log . log X Tab . length ; anti Optim += My T Two Pow . two Pow Tab . length ; anti Optim += My T Sqrt . sqrt X Sqrt Hi Tab . length ; anti Optim += My T Cbrt . cbrt X Cbrt Hi Tab . length ; if ( Strict Math . cos ( anti Optim ) == NUM_ ) { throw new Assertion Error ( ) ; } }
public int purge ( ) { if ( capacity >= NUM_ ) { int start = size ( ) ; Object [ ] cache = message Cache . to Array ( ) ; for ( int i = start - NUM_ ; i >= capacity ; i -- ) { message Cache . remove ( ( I Message ) cache [ i ] ) ; } return start - size ( ) ; } return NUM_ ; }
public ASRP Directory ( String path ) { dir = new File ( path ) ; if ( dir . exists ( ) ) { try { initialize ( dir . get Path ( ) , dir . get Name ( ) , STR_ ) ; } catch ( IO Exception ioe ) { Debug . error ( ioe . get Message ( ) ) ; ioe . print Stack Trace ( ) ; return ; } } else { Debug . error ( STR_ + path + STR_ ) ; } }
public void add To List ( FP Tree Node to Add ) { m header List . add ( to Add ) ; }
private int [ ] make Reordered Buffer ( int col First , int last Value , int [ ] last Expansion , boolean forward ) { int [ ] result ; int first Value = ordering . get Unicode Order ( col First ) ; if ( first Value >= Rule Based Collator . CONTRACTCHARINDEX ) { first Value = forward ? next Contract Char ( col First ) : prev Contract Char ( col First ) ; } int [ ] first Expansion = null ; if ( first Value >= Rule Based Collator . EXPANDCHARINDEX ) { first Expansion = ordering . get Expand Value List ( first Value ) ; } if ( ! forward ) { int temp 1 = first Value ; first Value = last Value ; last Value = temp 1 ; int [ ] temp 2 = first Expansion ; first Expansion = last Expansion ; last Expansion = temp 2 ; } if ( first Expansion == null && last Expansion == null ) { result = new int [ NUM_ ] ; result [ NUM_ ] = first Value ; result [ NUM_ ] = last Value ; } else { int first Length = first Expansion == null ? NUM_ : first Expansion . length ; int last Length = last Expansion == null ? NUM_ : last Expansion . length ; result = new int [ first Length + last Length ] ; if ( first Expansion == null ) { result [ NUM_ ] = first Value ; } else { System . arraycopy ( first Expansion , NUM_ , result , NUM_ , first Length ) ; } if ( last Expansion == null ) { result [ first Length ] = last Value ; } else { System . arraycopy ( last Expansion , NUM_ , result , first Length , last Length ) ; } } return result ; }
@ Override @ Nullable protected Object extract Parameter ( @ Nullable String cache Name , String type Name , Type Kind type Kind , String fld Name , Object obj ) throws Cache Exception { switch ( type Kind ) { case BUILT IN : return obj ; case POJO : return extract Pojo Parameter ( cache Name , type Name , fld Name , obj ) ; default : return extract Binary Parameter ( fld Name , obj ) ; } }
private String linkify Monitor ( String line ) { if ( line != null && line . index Of ( STR_ ) >= NUM_ ) { String begin = line . substring ( NUM_ , line . index Of ( STR_ ) ) ; String monitor = line . substring ( line . index Of ( STR_ ) , line . index Of ( STR_ ) + NUM_ ) ; String end = line . substring ( line . index Of ( STR_ ) + NUM_ ) ; monitor = monitor . replace All ( STR_ , STR_ + monitor + STR_ ) ; monitor = monitor . substring ( NUM_ , monitor . length ( ) - NUM_ ) + STR_ ; return ( begin + monitor + end ) ; } else if ( line != null && line . index Of ( STR_ ) >= NUM_ ) { String begin = line . substring ( NUM_ , line . index Of ( STR_ ) + NUM_ ) ; String monitor = line . substring ( line . index Of ( STR_ ) ) ; monitor = monitor . replace All ( STR_ , STR_ + monitor . substring ( NUM_ ) + STR_ ) ; monitor = monitor . substring ( NUM_ , monitor . length ( ) - NUM_ ) + STR_ ; return ( begin + monitor ) ; } else { return ( line ) ; } }
public static Endpoint Entry lookup ( Endpoint ep ) { synchronized ( endpoint Table ) { Endpoint Entry entry = endpoint Table . get ( ep ) ; if ( entry == null ) { entry = new Endpoint Entry ( ep ) ; endpoint Table . put ( ep , entry ) ; if ( gc Latency Request == null ) { gc Latency Request = GC . request Latency ( gc Interval ) ; } } return entry ; } }
public static void over Scroll By ( final com . handmark . pulltorefresh . library . Pull To Refresh Base < ? > view , final int delta X , final int scroll X , final int delta Y , final int scroll Y , final int scroll Range , final int fuzzy Threshold , final float scale Factor , final boolean is Touch Event ) { final int delta Value , current Scroll Value , scroll Value ; switch ( view . get Pull To Refresh Scroll Direction ( ) ) { case HORIZONTAL : delta Value = delta X ; scroll Value = scroll X ; current Scroll Value = view . get Scroll X ( ) ; break ; case VERTICAL : default : delta Value = delta Y ; scroll Value = scroll Y ; current Scroll Value = view . get Scroll Y ( ) ; break ; } if ( view . is Pull To Refresh Over Scroll Enabled ( ) && ! view . is Refreshing ( ) ) { final Pull To Refresh Base . Mode mode = view . get Mode ( ) ; if ( mode . permits Pull To Refresh ( ) && ! is Touch Event && delta Value != NUM_ ) { final int new Scroll Value = ( delta Value + scroll Value ) ; if ( com . handmark . pulltorefresh . library . Pull To Refresh Base . DEBUG ) { Log . d ( LOG TAG , STR_ + delta X + STR_ + scroll X + STR_ + delta Y + STR_ + scroll Y + STR_ + new Scroll Value + STR_ + scroll Range + STR_ + current Scroll Value ) ; } if ( new Scroll Value < ( NUM_ - fuzzy Threshold ) ) { if ( mode . show Header Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( Pull To Refresh Base . State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value ) ) ) ; } } else if ( new Scroll Value > ( scroll Range + fuzzy Threshold ) ) { if ( mode . show Footer Loading Layout ( ) ) { if ( current Scroll Value == NUM_ ) { view . set State ( Pull To Refresh Base . State . OVERSCROLLING ) ; } view . set Header Scroll ( ( int ) ( scale Factor * ( current Scroll Value + new Scroll Value - scroll Range ) ) ) ; } } else if ( Math . abs ( new Scroll Value ) <= fuzzy Threshold || Math . abs ( new Scroll Value - scroll Range ) <= fuzzy Threshold ) { view . set State ( Pull To Refresh Base . State . RESET ) ; } } else if ( is Touch Event && Pull To Refresh Base . State . OVERSCROLLING == view . get State ( ) ) { view . set State ( Pull To Refresh Base . State . RESET ) ; } } }
public Amqp Client ( URI remote URI , String username , String password ) { this . remote URI = remote URI ; this . password = password ; this . username = username ; }
public void do Get Json ( Http Servlet Request request , Http Servlet Response response , String type , String location , String id ) throws Servlet Exception , IO Exception { response . set Content Type ( STR_ ) ; Print Writer writer = response . get Writer ( ) ; if ( id != null ) { } else { String tmp = request . get Parameter ( PG START PARAM ) ; int pg Start = ( tmp == null ? - NUM_ : Integer . parse Int ( tmp . trim ( ) ) ) ; tmp = request . get Parameter ( PG SIZE PARAM ) ; int pg Size = ( tmp == null ? - NUM_ : Integer . parse Int ( tmp . trim ( ) ) ) ; Uri media Uri = Media Type . get Content Uri By Type ( type , location ) ; String Builder builder = new String Builder ( ) ; Media Collection collection = null ; writer . println ( STR_ ) ; try { collection = new Media Collection ( resolver . query ( media Uri , null , null , null , Media Store . Media Columns . TITLE + STR_ ) , pg Start , pg Size ) ; writer . println ( STR_ + collection . get Total ( ) + STR_ ) ; writer . println ( STR_ ) ; writer . print ( STR_ ) ; Content Values media = null ; int count = pg Size ; while ( ( pg Size <= NUM_ || count -- > NUM_ ) && ( media = collection . next ( ) ) != null ) { builder . set Length ( NUM_ ) ; to Json ( media , media Uri , builder , type , location ) ; Log . d ( TAG , builder . to String ( ) ) ; writer . print ( builder . to String ( ) ) ; if ( collection . has Next ( ) ) { writer . print ( STR_ ) ; } } writer . print ( STR_ ) ; } finally { writer . println ( STR_ ) ; collection . close ( ) ; } } }
public void remove Notify ( ) { synchronized ( get Tree Lock ( ) ) { List Peer peer = ( List Peer ) this . peer ; if ( peer != null ) { selected = peer . get Selected Indexes ( ) ; } super . remove Notify ( ) ; } }
private static boolean discard Stream ( Http Engine http Engine , Input Stream response Body In ) { Connection connection = http Engine . connection ; if ( connection == null ) return false ; Socket socket = connection . get Socket ( ) ; if ( socket == null ) return false ; try { int socket Timeout = socket . get So Timeout ( ) ; socket . set So Timeout ( DISCARD STREAM TIMEOUT MILLIS ) ; try { Util . skip All ( response Body In ) ; return true ; } finally { socket . set So Timeout ( socket Timeout ) ; } } catch ( IO Exception e ) { return false ; } }
protected Elem Variable create Global Pseudo Var Decl ( Q Name unique Pseudo Var Name , Stylesheet Root stylesheet Root , Loc Path Iterator lpi ) throws org . w 3 c . dom . DOM Exception { Elem Variable psuedo Var = new Elem Variable ( ) ; psuedo Var . set Is Top Level ( true ) ; X Path xpath = new X Path ( lpi ) ; psuedo Var . set Select ( xpath ) ; psuedo Var . set Name ( unique Pseudo Var Name ) ; Vector global Vars = stylesheet Root . get Variables And Params Composed ( ) ; psuedo Var . set Index ( global Vars . size ( ) ) ; global Vars . add Element ( psuedo Var ) ; return psuedo Var ; }
private static String strip Whitespace ( final String mosname ) { final String Buffer sb = new String Buffer ( ) ; final int size = mosname . length ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { final char ch = mosname . char At ( i ) ; if ( ! Character . is Whitespace ( ch ) ) { sb . append ( ch ) ; } } return sb . to String ( ) ; }
public static boolean class Exists ( String name ) { Object c = classes . get ( name ) ; if ( c == null ) { try { c = Class . for Name ( name ) ; } catch ( Class Not Found Exception e ) { } if ( c != null ) classes . put ( c , STR_ ) ; } return c != null ; }
private static int calculate Delay For Success ( ) { float error Percent = VARIANCE PCT / NUM_ ; float lower Bound = NUM_ - error Percent ; float upper Bound = NUM_ + error Percent ; float bound = upper Bound - lower Bound ; float delay Percent = ( random . next Float ( ) * bound ) + lower Bound ; return ( int ) ( DELAY MS * delay Percent ) ; }
public static double quantile ( double q , double [ ] x , int [ ] indices ) { if ( q < NUM_ || q > NUM_ ) throw new Illegal Argument Exception ( STR_ ) ; if ( q == NUM_ ) { return x [ indices [ NUM_ ] ] - NUM_ ; } return x [ indices [ ( int ) Math . ceil ( q * indices . length ) - NUM_ ] ] ; }
protected void add Column ( String name , Column col ) { int idx = get Column Number ( name ) ; if ( idx >= NUM_ && idx < m columns . size ( ) ) { throw new Illegal Argument Exception ( STR_ + name + STR_ ) ; } m columns . add ( col ) ; m names . add ( name ) ; m last Col = m columns . size ( ) - NUM_ ; Column Entry entry = new Column Entry ( m last Col , col , new Column Metadata ( this , name ) ) ; Column Entry old Entry = ( Column Entry ) m entries . put ( name , entry ) ; if ( old Entry != null ) old Entry . dispose ( ) ; invalidate Schema ( ) ; col . add Column Listener ( this ) ; fire Table Event ( m rows . get Minimum Row ( ) , m rows . get Maximum Row ( ) , m last Col , Table Model Event . INSERT ) ; }
@ Nonnull @ Override public Node Provisioner . Strategy Decision apply ( @ Nonnull Node Provisioner . Strategy State strategy State ) { LOG . debug ( STR_ ) ; final Label label = strategy State . get Label ( ) ; Load Statistics Snapshot snapshot = strategy State . get Snapshot ( ) ; for ( Docker Cloud docker Cloud : get Docker Clouds ( ) ) { for ( Docker Slave Template template : docker Cloud . get Templates ( label ) ) { if ( not Allowed Strategy ( template ) ) { continue ; } int available Capacity = snapshot . get Available Executors ( ) + snapshot . get Connecting Executors ( ) + strategy State . get Additional Planned Capacity ( ) ; int current Demand = snapshot . get Queue Length ( ) ; LOG . debug ( STR_ , available Capacity , current Demand ) ; if ( available Capacity < current Demand ) { Collection < Planned Node > planned Nodes = docker Cloud . provision ( label , current Demand - available Capacity ) ; LOG . debug ( STR_ , planned Nodes . size ( ) ) ; strategy State . record Pending Launches ( planned Nodes ) ; available Capacity += planned Nodes . size ( ) ; LOG . debug ( STR_ , docker Cloud , available Capacity , current Demand ) ; } if ( available Capacity >= current Demand ) { LOG . debug ( STR_ ) ; return Node Provisioner . Strategy Decision . PROVISIONING COMPLETED ; } else { LOG . debug ( STR_ ) ; } } LOG . debug ( STR_ ) ; } LOG . debug ( STR_ ) ; return Node Provisioner . Strategy Decision . CONSULT REMAINING STRATEGIES ; }
synchronized void executed ( RT Edit Text editor , Operation op ) { Stack < Operation > undo Stack = get Undo Stack ( editor ) ; Stack < Operation > redo Stack = get Redo Stack ( editor ) ; while ( ! undo Stack . empty ( ) && op . can Merge ( undo Stack . peek ( ) ) ) { Operation previous Op = undo Stack . pop ( ) ; op . merge ( previous Op ) ; } push ( op , undo Stack ) ; redo Stack . clear ( ) ; }
private String split Name Without Gzip Extension ( String split ) throws IO Exception { if ( split == null ) { throw new IO Exception ( STR_ ) ; } if ( split . ends With ( STR_ ) ) { return split . substring ( NUM_ , split . length ( ) - NUM_ ) ; } return split ; }
public Style add Menu Item ( String description , Pending Intent pending Intent ) { menu Item Array List . add ( new Menu Item ( description , pending Intent ) ) ; return this ; }
protected Text Anchor calculate Text Anchor ( double angle Degrees ) { Text Anchor ta = Text Anchor . CENTER ; double offset = this . angle Offset ; while ( offset < NUM_ ) { offset += NUM_ ; } double normalized Angle = ( ( ( this . counter Clockwise ? - NUM_ : NUM_ ) * angle Degrees ) + offset ) % NUM_ ; while ( this . counter Clockwise && ( normalized Angle < NUM_ ) ) { normalized Angle += NUM_ ; } if ( normalized Angle == NUM_ ) { ta = Text Anchor . CENTER LEFT ; } else if ( normalized Angle > NUM_ && normalized Angle < NUM_ ) { ta = Text Anchor . TOP LEFT ; } else if ( normalized Angle == NUM_ ) { ta = Text Anchor . TOP CENTER ; } else if ( normalized Angle > NUM_ && normalized Angle < NUM_ ) { ta = Text Anchor . TOP RIGHT ; } else if ( normalized Angle == NUM_ ) { ta = Text Anchor . CENTER RIGHT ; } else if ( normalized Angle > NUM_ && normalized Angle < NUM_ ) { ta = Text Anchor . BOTTOM RIGHT ; } else if ( normalized Angle == NUM_ ) { ta = Text Anchor . BOTTOM CENTER ; } else if ( normalized Angle > NUM_ && normalized Angle < NUM_ ) { ta = Text Anchor . BOTTOM LEFT ; } return ta ; }
public void run ( ) { while ( go ) { try { Thread . sleep ( NUM_ ) ; } catch ( Exception ex ) { Uu . p ( ex ) ; } J Scroll Bar sb = scroll . get Vertical Scroll Bar ( ) ; sb . set Value ( sb . get Value ( ) + NUM_ ) ; } }
private String Buffer prepare Optimized Delete Statement ( One Row Change one Row Change , String key Name ) { String Buffer stmt = new String Buffer ( ) ; stmt . append ( STR_ ) ; stmt . append ( conn . get Database Object Name ( one Row Change . get Schema Name ( ) ) + STR_ + conn . get Database Object Name ( one Row Change . get Table Name ( ) ) ) ; stmt . append ( STR_ ) ; stmt . append ( conn . get Database Object Name ( key Name ) ) ; stmt . append ( STR_ ) ; Array List < Array List < Column Val > > values = one Row Change . get Key Values ( ) ; Array List < Column Spec > key Spec = one Row Change . get Key Spec ( ) ; boolean first Row = true ; for ( Array List < Column Val > one Key Values : values ) { if ( first Row ) first Row = false ; else stmt . append ( STR_ ) ; print Column Spec ( stmt , key Spec , null , one Key Values , Print Mode . PLACE HOLDER , STR_ ) ; } stmt . append ( STR_ ) ; return stmt ; }
public Osm Agent App ( ) { Locale . set Default ( Locale . US ) ; }
private void println ( Level level , String msg ) { if ( log Level != Level . OFF ) { if ( config Logger == null ) { startup Log Records . add ( new Log Record ( level , msg ) ) ; } else { config Logger . log ( level , msg ) ; } } }
public int lookup Id ( String feature Name ) { int feature Hash = get Feature Hash ( feature Name ) ; return feature 2 Id . get ( feature Hash ) ; }
public static Long truncate Op CRC 32 ( String stream , DLSN dlsn ) { CRC 32 crc = request CRC . get ( ) ; try { crc . update ( stream . get Bytes ( UTF 8 ) ) ; crc . update ( dlsn . serialize Bytes ( ) ) ; return crc . get Value ( ) ; } finally { crc . reset ( ) ; } }
private static Simple Node rotate Node By Name ( Tree tree , Node Ref node ) { if ( tree . is External ( node ) ) { return new Simple Node ( tree , node ) ; } else { Simple Node parent = new Simple Node ( tree , node ) ; Node Ref child 1 = tree . get Child ( node , NUM_ ) ; Node Ref child 2 = tree . get Child ( node , NUM_ ) ; String subtree 1 = unique Newick ( tree , child 1 ) ; String subtree 2 = unique Newick ( tree , child 2 ) ; if ( subtree 1 . compare To ( subtree 2 ) > NUM_ ) { parent . add Child ( rotate Node By Name ( tree , child 2 ) ) ; parent . add Child ( rotate Node By Name ( tree , child 1 ) ) ; } else { parent . add Child ( rotate Node By Name ( tree , child 1 ) ) ; parent . add Child ( rotate Node By Name ( tree , child 2 ) ) ; } return parent ; } }
public VN Xe Command Job delete Nfs Share For Snapshot ( String share Id ) throws VN Xe Exception { Nfs Share Requests req = new Nfs Share Requests ( kh Client ) ; return req . delete Share For Snapshot ( share Id ) ; }
public static void push Predicate ( int distance , int branch Id ) { last Distance . put ( branch Id , Math . abs ( distance ) ) ; }
public static Custom Format create Instance ( String pattern , Map < String , String > regex Map ) { Custom Format format = new Custom Format ( ) ; format . m name List = extract Names ( pattern ) ; format . m name Set = new Hash Set < String > ( format . m name List ) ; format . m pattern = pattern ; Map < String , String > var Map = new Hash Map < String , String > ( ) ; for ( String name : format . m name Set ) { String regex = String . format ( STR_ , regex Map . contains Key ( name ) ? regex Map . get ( name ) : VALUE REGEX ) ; var Map . put ( name , regex ) ; } format . m regex = Str Substitutor . replace ( pattern , var Map ) ; return format ; }
@ Override public void write ( byte [ ] buffer , int offset , int byte Count ) throws IO Exception { Arrays . check Offset And Count ( buffer . length , offset , byte Count ) ; if ( current Entry == null ) { throw new Zip Exception ( STR_ ) ; } if ( current Entry . get Method ( ) == STORED ) { out . write ( buffer , offset , byte Count ) ; } else { super . write ( buffer , offset , byte Count ) ; } crc . update ( buffer , offset , byte Count ) ; }
public void remove Property Change Listener ( String property Name , Property Change Listener listener ) { if ( listener != null ) { synchronized ( this ) { if ( change Support != null ) { change Support . remove Property Change Listener ( property Name , listener ) ; } } } }
private double determine Max Zoom Factor ( ) { if ( image Data != null ) { final double max Width = ( double ) Integer . MAX VALUE / image Data . width ; final double max Height = ( double ) Integer . MAX VALUE / image Data . height ; return Math . min ( max Width , max Height ) ; } return NUM_ ; }
@ Override public double conf ( double total Weight , double total Positive Weight , Hypothesis hypo , double delta ) { double g = hypo . get Covered Weight ( ) / total Weight ; double p = hypo . get Positive Weight ( ) / hypo . get Covered Weight ( ) ; double sg = variance ( g , total Weight ) ; double sp = variance ( p , hypo . get Covered Weight ( ) ) ; double inverse Normal = inverse Normal ( NUM_ - delta / NUM_ ) ; return NUM_ * sg * inverse Normal + sg * sg * Math . pow ( inverse Normal , NUM_ ) + sp * inverse Normal + NUM_ * sg * sp * Math . pow ( inverse Normal , NUM_ ) + sp * sg * sg * Math . pow ( inverse Normal , NUM_ ) ; }
public void create Index ( String in File ) { String ssx File = null ; String shp File = null ; if ( in File . ends With ( STR_ ) ) { shp File = in File ; ssx File = ssx ( shp File ) ; } else if ( in File . ends With ( STR_ ) ) { ssx File = in File ; shp File = ssx File . substring ( NUM_ , ssx File . index Of ( STR_ ) ) + STR_ ; } else { return ; } byte file Header [ ] = new byte [ SHAPE FILE HEADER LENGTH ] ; File Input Stream shp = null ; File Output Stream ssx = null ; int shape Type ; try { shp = new File Input Stream ( shp File ) ; ssx = new File Output Stream ( ssx File ) ; shp . read ( file Header , NUM_ , SHAPE FILE HEADER LENGTH ) ; ssx . write ( file Header , NUM_ , SHAPE FILE HEADER LENGTH ) ; shape Type = read LE Int ( file Header , NUM_ ) ; switch ( shape Type ) { case SHAPE TYPE NULL : index Nulls ( shp , SHAPE FILE HEADER LENGTH , ssx ) ; break ; case SHAPE TYPE POINT : case SHAPE TYPE POINTZ : case SHAPE TYPE POINTM : index Points ( shp , SHAPE FILE HEADER LENGTH , ssx ) ; break ; case SHAPE TYPE MULTIPOINT : case SHAPE TYPE MULTIPOINTZ : case SHAPE TYPE MULTIPOINTM : case SHAPE TYPE POLYLINE : case SHAPE TYPE POLYLINEZ : case SHAPE TYPE POLYLINEM : case SHAPE TYPE POLYGON : case SHAPE TYPE POLYGONZ : case SHAPE TYPE POLYGONM : index Polygons ( shp , SHAPE FILE HEADER LENGTH , ssx ) ; break ; default : logger . warning ( STR_ + shape Type ) ; } } catch ( java . io . IO Exception e ) { e . print Stack Trace ( ) ; } finally { try { if ( shp != null ) shp . close ( ) ; if ( ssx != null ) ssx . close ( ) ; } catch ( java . io . IO Exception e ) { } } }
private static void print Matrix ( int [ ] [ ] matrix ) { Log . v ( TAG , STR_ ) ; int m = matrix . length ; int n = matrix [ NUM_ ] . length ; for ( int j = NUM_ ; j < n ; j ++ ) { String col Y = STR_ ; for ( int i = NUM_ ; i < m ; i ++ ) { col Y += String . format ( STR_ , matrix [ i ] [ j ] ) ; } Log . v ( TAG , col Y ) ; } }
public Flat Buffer Builder init ( Byte Buffer existing bb ) { bb = existing bb ; bb . clear ( ) ; bb . order ( Byte Order . LITTLE ENDIAN ) ; minalign = NUM_ ; space = bb . capacity ( ) ; vtable in use = NUM_ ; nested = false ; finished = false ; object start = NUM_ ; num vtables = NUM_ ; vector num elems = NUM_ ; return this ; }
public static Properties convert Bundle To Properties ( Resource Bundle rb ) { Properties props = new Properties ( ) ; for ( Enumeration < String > keys = rb . get Keys ( ) ; keys . has More Elements ( ) ; ) { String key = keys . next Element ( ) ; props . put ( key , rb . get String ( key ) ) ; } return props ; }
public int nice ( ) { return Integer . parse Int ( fields [ NUM_ ] ) ; }
public void add Listener ( Air Map Traffic Listener listener ) { if ( listeners . is Empty ( ) ) { listeners . add ( listener ) ; connect ( ) ; } else { listeners . add ( listener ) ; } }
public String TO CHAR ( String column Name , int display Type , String AD Language ) { String Buffer ret Value = new String Buffer ( STR_ ) ; ret Value . append ( column Name ) ; ret Value . append ( STR_ ) ; return ret Value . to String ( ) ; }
public void process All ( ) throws IO Exception { for ( Iterator < Entry > i = image List . iterator ( ) ; i . has Next ( ) ; ) { Entry entry = ( Entry ) i . next ( ) ; if ( ! entry . written ) { entry . written = true ; PDF Stream img = pdf . open Stream ( entry . name ) ; img . entry ( STR_ , pdf . name ( STR_ ) ) ; if ( entry . mask Name != null ) img . entry ( STR_ , pdf . ref ( entry . mask Name ) ) ; img . image ( entry . image , entry . bkg , entry . write As ) ; pdf . close ( img ) ; if ( entry . mask Name != null ) { PDF Stream mask = pdf . open Stream ( entry . mask Name ) ; mask . entry ( STR_ , pdf . name ( STR_ ) ) ; mask . image Mask ( entry . image , entry . write As ) ; pdf . close ( mask ) ; } } } }
private static boolean str Contains ( Set < String > messages , String message Key ) { String key = message Key ; do { if ( messages . contains ( key ) ) { return true ; } int dot = key . index Of ( STR_ ) ; if ( dot < NUM_ ) return false ; key = key . substring ( dot + NUM_ ) ; } while ( true ) ; }
private Grid Router Client Impl create Client ( Grid Tcp Router Configuration router Cfg ) throws Grid Client Exception { UUID client Id = UUID . random UUID ( ) ; return new Grid Router Client Impl ( client Id , router Cfg ) ; }
public static SSL Server Socket Factory make SSL Socket Factory ( Key Store loaded Key Store , Key Manager Factory loaded Key Factory ) throws IO Exception { SSL Server Socket Factory res = null ; try { Trust Manager Factory trust Manager Factory = Trust Manager Factory . get Instance ( Trust Manager Factory . get Default Algorithm ( ) ) ; trust Manager Factory . init ( loaded Key Store ) ; SSL Context ctx = SSL Context . get Instance ( STR_ ) ; ctx . init ( loaded Key Factory . get Key Managers ( ) , trust Manager Factory . get Trust Managers ( ) , null ) ; res = ctx . get Server Socket Factory ( ) ; } catch ( Exception e ) { throw new IO Exception ( e . get Message ( ) ) ; } return res ; }
private String Part create String Part ( final String name , final String value ) { final String Part string Part = new String Part ( name , value ) ; string Part . set Transfer Encoding ( null ) ; string Part . set Content Type ( null ) ; return string Part ; }
private void DT Dprolog ( ) throws SAX Exception , IO Exception { final java . io . Writer writer = m writer ; if ( m need To Output Doc Type Decl ) { output Doc Type Decl ( m elem Context . m element Name , false ) ; m need To Output Doc Type Decl = false ; } if ( m in Doctype ) { writer . write ( STR_ ) ; writer . write ( m line Sep , NUM_ , m line Sep Len ) ; m in Doctype = false ; } }
private String sign ( String base String , Private Key private Key ) { try { Signature signer = Signature . get Instance ( SHA 1 WITH RSA ) ; signer . init Sign ( private Key ) ; signer . update ( base String . get Bytes ( UTF 8 ) ) ; return Datatype Converter . print Base 64 Binary ( signer . sign ( ) ) ; } catch ( Invalid Key Exception e ) { throw new MC Api Runtime Exception ( e ) ; } catch ( Signature Exception e ) { throw new MC Api Runtime Exception ( e ) ; } catch ( Unsupported Encoding Exception e ) { throw new MC Api Runtime Exception ( e ) ; } catch ( No Such Algorithm Exception e ) { throw new MC Api Runtime Exception ( e ) ; } }
public void convert String Atts To Nominal ( ) { Instances mining Schema I = get Fields As Instances ( ) ; if ( mining Schema I . check For String Attributes ( ) ) { Array List < Attribute > att Info = new Array List < Attribute > ( ) ; for ( int i = NUM_ ; i < mining Schema I . num Attributes ( ) ; i ++ ) { Attribute temp A = mining Schema I . attribute ( i ) ; if ( temp A . is String ( ) ) { Array List < String > value Vector = new Array List < String > ( ) ; for ( int j = NUM_ ; j < temp A . num Values ( ) ; j ++ ) { value Vector . add ( temp A . value ( j ) ) ; } Attribute new Att = new Attribute ( temp A . name ( ) , value Vector ) ; att Info . add ( new Att ) ; } else { att Info . add ( temp A ) ; } } Instances new I = new Instances ( STR_ , att Info , NUM_ ) ; if ( m field Instances Structure . class Index ( ) >= NUM_ ) { new I . set Class Index ( m field Instances Structure . class Index ( ) ) ; } m field Instances Structure = new I ; } }
private static void add Trackers ( Entity Player MP watcher , Entity target ) { List < Entity Capability < ? , ? , Entity > > entity Capabilities = get Entity Capabilities ( target ) ; for ( Entity Capability < ? , ? , Entity > capability : entity Capabilities ) { if ( capability . get Tracking Time ( ) >= NUM_ ) { List < Entity Capability Tracker > trackers = TRACKER MAP . get ( watcher ) ; if ( trackers == null ) TRACKER MAP . put ( watcher , trackers = new Array List < Entity Capability Tracker > ( ) ) ; trackers . add ( new Entity Capability Tracker ( capability , watcher ) ) ; } } }
public static void open Imdb For Movie ( Context context , String imdb Number ) { if ( context == null || Text Utils . is Empty ( imdb Number ) ) { return ; } Intent intent = new Intent ( Intent . ACTION VIEW , Uri . parse ( String . format ( IMDB APP MOVIE URI , imdb Number ) ) ) ; intent . add Flags ( Intent . FLAG ACTIVITY CLEAR WHEN TASK RESET ) ; if ( ! Utils . try Start Activity ( context , intent ) ) { intent = new Intent ( Intent . ACTION VIEW , Uri . parse ( String . format ( IMDB MOVIE URL , imdb Number ) ) ) ; intent . add Flags ( Intent . FLAG ACTIVITY CLEAR WHEN TASK RESET ) ; context . start Activity ( intent ) ; } }
private void write Serial Data ( Object obj , Object Stream Class desc ) throws IO Exception { Object Stream Class . Class Data Slot [ ] slots = desc . get Class Data Layout ( ) ; for ( int i = NUM_ ; i < slots . length ; i ++ ) { Object Stream Class slot Desc = slots [ i ] . desc ; if ( slot Desc . has Write Object Method ( ) ) { Put Field Impl old Put = cur Put ; cur Put = null ; Serial Callback Context old Context = cur Context ; if ( extended Debug Info ) { debug Info Stack . push ( STR_ + slot Desc . get Name ( ) + STR_ ) ; } try { cur Context = new Serial Callback Context ( obj , slot Desc ) ; bout . set Block Data Mode ( true ) ; slot Desc . invoke Write Object ( obj , this ) ; bout . set Block Data Mode ( false ) ; bout . write Byte ( TC ENDBLOCKDATA ) ; } finally { cur Context . set Used ( ) ; cur Context = old Context ; if ( extended Debug Info ) { debug Info Stack . pop ( ) ; } } cur Put = old Put ; } else { default Write Fields ( obj , slot Desc ) ; } } }
public static void add To Parser Table ( String header Name , Class < ? extends Header Parser > parser Class ) { parser Table . put ( header Name . to Lower Case ( ) , parser Class ) ; }
void ensure Prestart ( ) { int wc = worker Count Of ( ctl . get ( ) ) ; if ( wc < core Pool Size ) add Worker ( null , true ) ; else if ( wc == NUM_ ) add Worker ( null , false ) ; }
@ Override public void process Authorize ( Web Socket Channel channel , String authorize Token ) { LOG . entering ( CLASS NAME , STR_ ) ; Web Socket Native Channel native Channel = ( Web Socket Native Channel ) channel ; Proxy proxy = native Channel . get Proxy ( ) ; proxy . process Event ( Xoa Event Kind . AUTHORIZE , new String [ ] { authorize Token } ) ; }
private static Snap Candidate create Snap Candidate ( Constraint Widget widget , Constraint Anchor . Type type , int x , int y ) { Snap Candidate candidate = new Snap Candidate ( ) ; candidate . source = widget . get Anchor ( type ) ; Constraint Widget owner = widget . get Parent ( ) ; Constraint Anchor anchor = new Constraint Anchor ( owner , type ) ; candidate . x = x ; candidate . y = y ; candidate . target = anchor ; return candidate ; }
public String switch Stage Path ( ) { return STR_ + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ ) + STR_ + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + Rel Coordinates . get Rel Coords ( NUM_ , NUM_ , NUM_ , NUM_ ) + STR_ ; }
public static boolean is Right Mouse Button ( Mouse Event an Event ) { return ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 3 DOWN MASK ) > NUM_ ; }
@ Suppress Warnings ( STR_ ) protected synchronized V remove Internal ( Object key , boolean count Remove ) { if ( key == null ) { if ( Debug . verbose On ( ) ) Debug . log Verbose ( STR_ + this . name , module ) ; } Object nulled Key = from Key ( key ) ; Cache Line < V > old Cache Line ; V old Value ; if ( file Table != null ) { try { synchronized ( this ) { try { old Value = file Table . get ( nulled Key ) ; } catch ( IO Exception e ) { old Value = null ; throw e ; } file Table . remove ( nulled Key ) ; jdbm Mgr . commit ( ) ; } } catch ( IO Exception e ) { old Value = null ; Debug . log Error ( e , module ) ; } old Cache Line = memory Table . remove ( nulled Key ) ; } else { old Cache Line = memory Table . remove ( nulled Key ) ; old Value = old Cache Line != null ? old Cache Line . get Value ( ) : null ; } if ( old Cache Line != null ) { cancel ( old Cache Line ) ; } if ( old Value != null ) { note Removal ( ( K ) key , old Value ) ; if ( count Remove ) remove Hit Count . increment And Get ( ) ; return old Value ; } else { if ( count Remove ) remove Miss Count . increment And Get ( ) ; return null ; } }
@ Override public void on Start Input ( Editor Info attribute , boolean restarting ) { super . on Start Input ( attribute , restarting ) ; m Composing . set Length ( NUM_ ) ; update Candidates ( ) ; if ( ! restarting ) { m Meta State = NUM_ ; } m Prediction On = false ; m Completion On = false ; m Completions = null ; switch ( attribute . input Type & Input Type . TYPE MASK CLASS ) { case Input Type . TYPE CLASS NUMBER : case Input Type . TYPE CLASS DATETIME : m Cur Keyboard = m Symbols Keyboard ; break ; case Input Type . TYPE CLASS PHONE : m Cur Keyboard = m Symbols Keyboard ; break ; case Input Type . TYPE CLASS TEXT : m Cur Keyboard = m Qwerty Keyboard ; m Prediction On = true ; int variation = attribute . input Type & Input Type . TYPE MASK VARIATION ; if ( variation == Input Type . TYPE TEXT VARIATION PASSWORD || variation == Input Type . TYPE TEXT VARIATION VISIBLE PASSWORD ) { m Prediction On = false ; } if ( variation == Input Type . TYPE TEXT VARIATION EMAIL ADDRESS || variation == Input Type . TYPE TEXT VARIATION URI || variation == Input Type . TYPE TEXT VARIATION FILTER ) { m Prediction On = false ; } if ( ( attribute . input Type & Input Type . TYPE TEXT FLAG AUTO COMPLETE ) != NUM_ ) { m Prediction On = false ; m Completion On = is Fullscreen Mode ( ) ; } update Shift Key State ( attribute ) ; break ; default : m Cur Keyboard = m Qwerty Keyboard ; update Shift Key State ( attribute ) ; } m Cur Keyboard . set Ime Options ( get Resources ( ) , attribute . ime Options ) ; }
protected Array List < Array List < DBI Ds > > build Ranges ( Relation < V > relation ) { final int dim = Relation Util . dimensionality ( relation ) ; final int size = relation . size ( ) ; final Array List < Array List < DBI Ds > > ranges = new Array List < > ( ) ; Array Modifiable DBI Ds ids = DBID Util . new Array ( relation . get DBI Ds ( ) ) ; Sort DBI Ds By Single Dimension sorter = new Sort DBI Ds By Single Dimension ( relation ) ; final double part = size * NUM_ / phi ; for ( int d = NUM_ ; d < dim ; d ++ ) { sorter . set Dimension ( d ) ; ids . sort ( sorter ) ; Array List < DBI Ds > dimranges = new Array List < > ( phi + NUM_ ) ; int start = NUM_ ; DBID Array Iter iter = ids . iter ( ) ; for ( int r = NUM_ ; r <= phi ; r ++ ) { int end = ( r < phi ) ? ( int ) ( part * r ) : size ; Array Modifiable DBI Ds currange = DBID Util . new Array ( end - start ) ; for ( iter . seek ( start ) ; iter . get Offset ( ) < end ; iter . advance ( ) ) { currange . add ( iter ) ; } start = end ; dimranges . add ( currange ) ; } ranges . add ( dimranges ) ; } return ranges ; }
@ Override public void add Property Change Listener ( String property Name , Property Change Listener listener ) { property Change Support . add Property Change Listener ( property Name , listener ) ; }
private static String [ ] add Element To Array ( String [ ] array , String element ) { Arrays . copy Of ( array , array . length + NUM_ ) ; array [ array . length - NUM_ ] = element ; return array ; }
public static < T extends Object & java . lang . Comparable < ? super T > > T max ( Collection < ? extends T > collection ) { Iterator < ? extends T > it = collection . iterator ( ) ; T max = it . next ( ) ; while ( it . has Next ( ) ) { T next = it . next ( ) ; if ( max . compare To ( next ) < NUM_ ) { max = next ; } } return max ; }
private Char Sequence create Ticker Text ( String title , String body ) { Spannable String Builder spannable String Builder = new Spannable String Builder ( ) ; spannable String Builder . append ( title ) ; spannable String Builder . append ( STR_ ) ; spannable String Builder . append ( body ) ; spannable String Builder . set Span ( new Style Span ( android . graphics . Typeface . BOLD ) , NUM_ , title . length ( ) , Spannable . SPAN INCLUSIVE INCLUSIVE ) ; return spannable String Builder ; }
@ Visible For Testing int exact Binary Search ( long search X , int start Search Index ) { return approximate Binary Search ( search X , start Search Index , m Data . size ( ) - NUM_ , true , NUM_ ) ; }
public void modify ( Attr attr , Modification Type modification Type ) { Modification modification = new Modification ( modification Type , attr . to LDAP Attribute ( ) ) ; modify ( Collections . singleton ( modification ) ) ; }
@ Override public void on Nested Pre Scroll ( View target , int dx , int dy , int [ ] consumed ) { if ( ( ! m Pull Refresh Enable && ! m Pull Load Enable ) ) { return ; } if ( Math . abs ( dy ) > NUM_ ) { return ; } if ( ! is Confirm ) { if ( dy < NUM_ && ! can Child Scroll Up ( ) ) { m Current Action = PULL REFRESH ; is Confirm = true ; } else if ( dy > NUM_ && ! can Child Scroll Down ( ) ) { m Current Action = LOAD MORE ; is Confirm = true ; } } if ( move Spinner ( - dy ) ) { consumed [ NUM_ ] += dy ; } }
private Datagram Socket create Or Get Relay Socket ( Socket Address original Socket Address ) { if ( ! proxy Sockets By Original Address . contains Key ( original Socket Address ) ) { try { Datagram Socket relay Socket = new Datagram Socket ( new Inet Socket Address ( get Loopback Address ( ) , NUM_ ) ) ; logger . debug ( STR_ , original Socket Address , relay Socket . get Local Socket Address ( ) ) ; proxy Sockets By Original Address . put ( original Socket Address , relay Socket ) ; read Socket ( thread Pool Executor , relay Socket , null ) ; } catch ( Socket Exception e ) { throw new Runtime Exception ( e ) ; } } return proxy Sockets By Original Address . get ( original Socket Address ) ; }
public Tree Map < Float , List < List < Integer > > > pack First Fit Shuffled ( ) { Random Data Generator rnd = new Random Data Generator ( ) ; int [ ] permutation = rnd . next Permutation ( items . size ( ) , items . size ( ) ) ; List < Integer > shuffled Items = new Array List < Integer > ( items . size ( ) ) ; List < Float > shuffled Weights = new Array List < Float > ( items . size ( ) ) ; for ( int ix : permutation ) { shuffled Items . add ( items . get ( ix ) ) ; shuffled Weights . add ( item Weights . get ( ix ) ) ; } return pack First Fit ( shuffled Items , shuffled Weights ) ; }
public int show ( Fragment Transaction transaction , @ Id Res int bottom Sheet Layout Id ) { dismissed = false ; shown By Me = true ; this . bottom Sheet Layout Id = bottom Sheet Layout Id ; transaction . add ( fragment , String . value Of ( bottom Sheet Layout Id ) ) ; view Destroyed = false ; back Stack Id = transaction . commit ( ) ; return back Stack Id ; }
public Builder add Listen Url ( String url ) { if ( Url Util . is Url ( url ) ) { if ( m Listen Urls == null ) { m Listen Urls = new Hash Set < String > ( ) ; } m Listen Urls . add ( url ) ; } return this ; }
private void write Chunks ( Output Stream output Stream , byte [ ] bytes , int length ) throws IO Exception { synchronized ( output Stream ) { int chunksize = NUM_ * NUM_ ; for ( int p = NUM_ ; p < length ; p += chunksize ) { int chunk = p + chunksize < length ? chunksize : length - p ; output Stream . write ( bytes , p , chunk ) ; } } output Stream . flush ( ) ; }
public boolean handle Token ( Json Parser jp , Deserialization Context ctxt , String prop Name , Object bean ) throws IO Exception , Json Processing Exception { Integer I = name To Property Index . get ( prop Name ) ; if ( I == null ) { return false ; } int index = I . int Value ( ) ; Ext Typed Property prop = properties [ index ] ; boolean can Deserialize ; if ( prop . has Type Property Name ( prop Name ) ) { type Ids [ index ] = jp . get Text ( ) ; jp . skip Children ( ) ; can Deserialize = ( bean != null ) && ( tokens [ index ] != null ) ; } else { Token Buffer tokens = new Token Buffer ( jp . get Codec ( ) ) ; tokens . copy Current Structure ( jp ) ; tokens [ index ] = tokens ; can Deserialize = ( bean != null ) && ( type Ids [ index ] != null ) ; } if ( can Deserialize ) { deserialize ( jp , ctxt , bean , index ) ; type Ids [ index ] = null ; tokens [ index ] = null ; } return true ; }
public void start ( ) { running = true ; start Time Millis = System . current Time Millis ( ) ; thread = new Thread ( this , THREAD NAME PREFIX + get Port ( ) ) ; thread . start ( ) ; }
public static void assert Chi Square Accept ( double [ ] expected , long [ ] observed , double alpha ) { String [ ] labels = new String [ expected . length ] ; for ( int i = NUM_ ; i < labels . length ; i ++ ) { labels [ i ] = Integer . to String ( i + NUM_ ) ; } assert Chi Square Accept ( labels , expected , observed , alpha ) ; }
private void interrupt Idle Workers ( boolean only One ) { final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { Iterator < Worker > it = workers . iterator ( ) ; while ( it . has Next ( ) ) { Worker w = it . next ( ) ; Thread t = w . thread ; if ( ! t . is Interrupted ( ) && w . try Lock ( ) ) { try { t . interrupt ( ) ; } catch ( Security Exception ignore ) { } finally { w . unlock ( ) ; } } if ( only One ) break ; } } finally { main Lock . unlock ( ) ; } }
private void authorize Domain ( Registration registration , String domain ) { try { val authorization = get Authorization ( registration , domain ) ; val challenge = prepare Dns Challenge ( authorization ) ; complete Challenge ( challenge ) ; } catch ( Acme Exception e ) { e . print Stack Trace ( ) ; throw new Letsencrypt Exception ( e . get Message ( ) ) ; } }
private static void process One Line ( Line Number Reader in , String title , double [ ] value Holder ) throws IO Exception { String s = in . read Line ( ) ; if ( VM . Verify Assertions ) VM . assert ( s != null ) ; String Tokenizer parser = new String Tokenizer ( s ) ; String token = parser . next Token ( ) ; if ( VM . Verify Assertions ) VM . assert ( token . equals ( title ) ) ; for ( int i = NUM_ ; parser . has More Tokens ( ) && i < value Holder . length ; i ++ ) { token = parser . next Token ( ) ; value Holder [ i ] = Double . parse Double ( token ) ; } }
void use Pull Parse ( ) { try { Lite Pal Attr lite Pal Attr = Lite Pal Attr . get Instance ( ) ; Xml Pull Parser Factory factory = Xml Pull Parser Factory . new Instance ( ) ; Xml Pull Parser xml Pull Parser = factory . new Pull Parser ( ) ; xml Pull Parser . set Input ( get Config Input Stream ( ) , STR_ ) ; int event Type = xml Pull Parser . get Event Type ( ) ; while ( event Type != Xml Pull Parser . END DOCUMENT ) { String node Name = xml Pull Parser . get Name ( ) ; switch ( event Type ) { case Xml Pull Parser . START TAG : { if ( NODE DB NAME . equals ( node Name ) ) { String db Name = xml Pull Parser . get Attribute Value ( STR_ , ATTR VALUE ) ; lite Pal Attr . set Db Name ( db Name ) ; } else if ( NODE VERSION . equals ( node Name ) ) { String version = xml Pull Parser . get Attribute Value ( STR_ , ATTR VALUE ) ; lite Pal Attr . set Version ( Integer . parse Int ( version ) ) ; } else if ( NODE MAPPING . equals ( node Name ) ) { String class Name = xml Pull Parser . get Attribute Value ( STR_ , ATTR CLASS ) ; lite Pal Attr . add Class Name ( class Name ) ; } else if ( NODE CASES . equals ( node Name ) ) { String cases = xml Pull Parser . get Attribute Value ( STR_ , ATTR VALUE ) ; lite Pal Attr . set Cases ( cases ) ; } break ; } default : break ; } event Type = xml Pull Parser . next ( ) ; } } catch ( Xml Pull Parser Exception e ) { throw new Parse Configuration File Exception ( Parse Configuration File Exception . FILE FORMAT IS NOT CORRECT ) ; } catch ( IO Exception e ) { throw new Parse Configuration File Exception ( Parse Configuration File Exception . IO EXCEPTION ) ; } }
private List < String > query Cluster Initiators ( URI host Id ) { List < String > initiator Names = new Array List < String > ( ) ; Host host = db Client . query Object ( Host . class , host Id ) ; if ( host == null ) { return initiator Names ; } if ( host . get Cluster ( ) == null ) { return initiator Names ; } List < URI > host Uris = Compute System Helper . get Children Uris ( db Client , host . get Cluster ( ) , Host . class , STR_ ) ; for ( URI hosturi : host Uris ) { initiator Names . add All ( query Host Initiators ( hosturi ) ) ; } return initiator Names ; }
public void flip ( W Component Peer peer , Component target , Volatile Image back Buffer , int x 1 , int y 1 , int x 2 , int y 2 , Buffer Capabilities . Flip Contents flip Action ) { if ( flip Action == Buffer Capabilities . Flip Contents . COPIED || flip Action == Buffer Capabilities . Flip Contents . UNDEFINED ) { Graphics g = peer . get Graphics ( ) ; try { g . draw Image ( back Buffer , x 1 , y 1 , x 2 , y 2 , x 1 , y 1 , x 2 , y 2 , null ) ; } finally { g . dispose ( ) ; } } else if ( flip Action == Buffer Capabilities . Flip Contents . BACKGROUND ) { Graphics g = back Buffer . get Graphics ( ) ; try { g . set Color ( target . get Background ( ) ) ; g . fill Rect ( NUM_ , NUM_ , back Buffer . get Width ( ) , back Buffer . get Height ( ) ) ; } finally { g . dispose ( ) ; } } }
synchronized void undo ( RT Edit Text editor ) { Stack < Operation > undo Stack = get Undo Stack ( editor ) ; if ( ! undo Stack . empty ( ) ) { Stack < Operation > redo Stack = get Redo Stack ( editor ) ; Operation op = undo Stack . pop ( ) ; push ( op , redo Stack ) ; op . undo ( editor ) ; while ( ! undo Stack . empty ( ) && op . can Merge ( undo Stack . peek ( ) ) ) { op = undo Stack . pop ( ) ; push ( op , redo Stack ) ; op . undo ( editor ) ; } } }
public void update Tag Key Options ( ) { String current Text = key Box . get Text ( ) ; List < String > tag Keys = influx Service . get Tags ( measurement Box . get Text ( ) ) ; if ( null != tag Keys ) { key Box . set Items ( tag Keys . to Array ( new String [ tag Keys . size ( ) ] ) ) ; } key Box . set Text ( current Text ) ; }
private void calculate Intervals ( ) { int node Count = tree . get Node Count ( ) ; times = new double [ node Count ] ; int [ ] child Counts = new int [ node Count ] ; collect Times ( tree , times , child Counts ) ; indices = new int [ node Count ] ; Heap Sort . sort ( times , indices ) ; if ( intervals == null || intervals . length != node Count ) { intervals = new double [ node Count ] ; lineage Counts = new int [ node Count ] ; lineages Added = new List [ node Count ] ; lineages Removed = new List [ node Count ] ; lineages = new List [ node Count ] ; } double start = times [ indices [ NUM_ ] ] ; int num Lines = NUM_ ; int node No = NUM_ ; interval Count = NUM_ ; while ( node No < node Count ) { int lineages Removed = NUM_ ; int lineages Added = NUM_ ; double finish = times [ indices [ node No ] ] ; double next ; do { final int child Index = indices [ node No ] ; final int child Count = child Counts [ child Index ] ; node No += NUM_ ; if ( child Count == NUM_ ) { add Lineage ( interval Count , tree . get Node ( child Index ) ) ; lineages Added += NUM_ ; } else { lineages Removed += ( child Count - NUM_ ) ; final Node Ref parent = tree . get Node ( child Index ) ; for ( int j = NUM_ ; j < child Count ; j ++ ) { Node Ref child = tree . get Child ( parent , j ) ; remove Lineage ( interval Count , child ) ; } add Lineage ( interval Count , parent ) ; if ( multifurcation Limit == NUM_ ) { break ; } } if ( node No < node Count ) { next = times [ indices [ node No ] ] ; } else break ; } while ( Math . abs ( next - finish ) <= multifurcation Limit ) ; if ( lineages Added > NUM_ ) { if ( interval Count > NUM_ || ( ( finish - start ) > multifurcation Limit ) ) { intervals [ interval Count ] = finish - start ; lineage Counts [ interval Count ] = num Lines ; interval Count += NUM_ ; } start = finish ; } num Lines += lineages Added ; if ( lineages Removed > NUM_ ) { intervals [ interval Count ] = finish - start ; lineage Counts [ interval Count ] = num Lines ; interval Count += NUM_ ; start = finish ; } num Lines -= lineages Removed ; } intervals Known = true ; }
public void update Timers And Events ( Process Definition Entity process Definition , Process Definition Entity previous Process Definition , Parsed Deployment parsed Deployment ) { Process process = parsed Deployment . get Process Model For Process Definition ( process Definition ) ; Bpmn Model bpmn Model = parsed Deployment . get Bpmn Model For Process Definition ( process Definition ) ; event Subscription Manager . remove Obsolete Message Event Subscriptions ( previous Process Definition ) ; event Subscription Manager . add Message Event Subscriptions ( process Definition , process , bpmn Model ) ; event Subscription Manager . remove Obsolete Signal Event Sub Scription ( previous Process Definition ) ; event Subscription Manager . add Signal Event Subscriptions ( Context . get Command Context ( ) , process Definition , process , bpmn Model ) ; timer Manager . remove Obsolete Timers ( process Definition ) ; timer Manager . schedule Timers ( process Definition , process ) ; }
public static Label create Name Value Label ( final String label , final String ... values ) { final String value Str = String Utils . join ( Arrays . as List ( values ) , STR_ ) ; final Label name Value Label = new Label ( get Bold HTML Text ( label ) + value Str , Content Mode . HTML ) ; name Value Label . set Size Full ( ) ; name Value Label . add Style Name ( SPUI Definitions . TEXT STYLE ) ; name Value Label . add Style Name ( STR_ ) ; return name Value Label ; }
public static General Path append Shape Edge ( General Path to Shape , General Path add Shape , boolean line To ) { boolean DEBUG = Debug . debugging ( STR_ ) ; int point Count = NUM_ ; if ( add Shape == null ) { return to Shape ; } if ( to Shape == null ) { return add Shape ; } to Shape . append ( add Shape , line To ) ; return to Shape ; }
public void send ( Destination destination , Message message , int delivery Mode , int priority , long time To Live ) throws JMS Exception { if ( destination == null || ! ( destination instanceof Queue || destination instanceof Topic ) ) { throw new Invalid Destination Exception ( STR_ + STR_ + destination ) ; } if ( delivery Mode != Delivery Mode . NON PERSISTENT && delivery Mode != Delivery Mode . PERSISTENT ) throw new JMS Exception ( STR_ + delivery Mode + STR_ + STR_ + Delivery Mode . NON PERSISTENT + STR_ + Delivery Mode . PERSISTENT + STR_ ) ; if ( NUM_ > priority || priority > NUM_ ) { throw new JMS Exception ( STR_ + priority + STR_ + STR_ ) ; } GS Message Impl message = ( GS Message Impl ) message ; try { prepare Message To Send ( message , delivery Mode , priority , time To Live , destination ) ; m session . handle Send Message ( message ) ; } catch ( Remote Exception re ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STR_ + re . to String ( ) , re ) ; } JMS Exception e = new JMS Exception ( STR_ + re . to String ( ) ) ; e . set Linked Exception ( re ) ; throw e ; } catch ( Transaction Exception te ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STR_ + te . to String ( ) , te ) ; } JMS Exception e = new JMS Exception ( STR_ + te . to String ( ) ) ; e . set Linked Exception ( te ) ; throw e ; } catch ( Entry Already In Space Exception eaine ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . severe ( STR_ + message . Destination Name + STR_ + destination + STR_ + message . get Entry Info ( ) . m UID ) ; } JMS Exception e = new JMS Exception ( STR_ + eaine . to String ( ) ) ; e . set Linked Exception ( eaine ) ; throw e ; } catch ( Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , STR_ , e ) ; } if ( ! ( e instanceof Interrupted Exception ) ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . log ( Level . FINE , e . to String ( ) , e ) ; } JMS Exception jmse = new JMS Exception ( STR_ + e . to String ( ) ) ; jmse . set Linked Exception ( e ) ; throw jmse ; } } }
public Singleton Relationship Provider ( final Connection Factory connection Factory , final Resource Path resource Path , final Schema Field schema Field , final Activity Logger activity Logger , final Managed Object Set Service managed Object Sync Service ) { super ( connection Factory , resource Path , schema Field , activity Logger , managed Object Sync Service ) ; final Router router = new Router ( ) ; router . add Route ( STARTS WITH , uri Template ( String . format ( STR_ , PARAM MANAGED OBJECT ID , schema Field . get Name ( ) ) ) , Resources . new Handler ( this ) ) ; this . request Handler = router ; }
private static void init Usable Display Sizes ( ) { display Sizes . add ( new Dimension ( NUM_ , NUM_ ) ) ; display Sizes . add ( new Dimension ( NUM_ , NUM_ ) ) ; display Sizes . add ( new Dimension ( NUM_ , NUM_ ) ) ; }
static public Interest Rate implied Rate ( final double c , final double time , final Day Counter result DC , final Compounding comp , final Frequency freq ) { final double t = time ; final double f = freq . to Integer ( ) ; QL . require ( c > NUM_ , STR_ ) ; QL . require ( t > NUM_ , STR_ ) ; double rate ; switch ( comp ) { case Simple : rate = ( c - NUM_ ) / t ; break ; case Compounded : rate = ( Math . pow ( c , ( NUM_ / ( f * t ) ) ) - NUM_ ) * f ; break ; case Continuous : rate = Math . log ( c ) / t ; break ; case Simple Then Compounded : if ( t <= ( NUM_ / f ) ) { rate = ( c - NUM_ ) / t ; } else { rate = ( Math . pow ( c , ( NUM_ / ( f * t ) ) ) - NUM_ ) * f ; } break ; default : throw new Library Exception ( STR_ ) ; } return new Interest Rate ( rate , result DC , comp , freq ) ; }
@ Suppress Warnings ( STR_ ) public static void main ( String [ ] args ) { Log . print Line ( STR_ ) ; try { int num user = NUM_ ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = false ; Cloud Sim . init ( num user , calendar , trace flag ) ; Datacenter datacenter 0 = create Datacenter ( STR_ ) ; Datacenter Broker broker = create Broker ( ) ; int broker Id = broker . get Id ( ) ; vmlist = new Array List < Vm > ( ) ; int vmid = NUM_ ; int mips = NUM_ ; long size = NUM_ ; int ram = NUM_ ; long bw = NUM_ ; int pes Number = NUM_ ; String vmm = STR_ ; Vm vm = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmlist . add ( vm ) ; broker . submit Vm List ( vmlist ) ; cloudlet List = new Array List < Cloudlet > ( ) ; int id = NUM_ ; long length = NUM_ ; long file Size = NUM_ ; long output Size = NUM_ ; Utilization Model utilization Model = new Utilization Model Full ( ) ; Cloudlet cloudlet = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet . set User Id ( broker Id ) ; cloudlet . set Vm Id ( vmid ) ; cloudlet List . add ( cloudlet ) ; broker . submit Cloudlet List ( cloudlet List ) ; Cloud Sim . start Simulation ( ) ; Cloud Sim . stop Simulation ( ) ; List < Cloudlet > new List = broker . get Cloudlet Received List ( ) ; print Cloudlet List ( new List ) ; Log . print Line ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STR_ ) ; } }
public boolean is Ivr Enabled ( ) throws Network Device Controller Exception { boolean ivr Enabled = false ; boolean ivr Distribute Enabled = false ; ; boolean ivr Vsan Topology Active = false ; SSH Prompt [ ] prompts = { SSH Prompt . MDS POUND , SSH Prompt . MDS CONFIG , SSH Prompt . MDS CONFIG IVR ZONE , SSH Prompt . MDS CONFIG IVR ZONESET } ; String Builder buf = new String Builder ( ) ; send Wait For ( MDS Dialog Properties . get String ( STR_ ) , NUM_ , prompts , buf ) ; String [ ] lines = get Lines ( buf ) ; for ( String line : lines ) { if ( line . index Of ( MDS Dialog Properties . get String ( STR_ ) ) >= NUM_ ) { ivr Enabled = true ; } else if ( line . index Of ( MDS Dialog Properties . get String ( STR_ ) ) >= NUM_ ) { ivr Distribute Enabled = true ; } else if ( line . index Of ( MDS Dialog Properties . get String ( STR_ ) ) >= NUM_ ) { ivr Vsan Topology Active = true ; } if ( ivr Enabled && ivr Vsan Topology Active && ivr Distribute Enabled ) { break ; } } return ivr Enabled && ivr Vsan Topology Active && ivr Distribute Enabled ; }
protected void print Attribute Summary ( Attr Types attr Types , int class Type ) { String str = STR_ ; if ( attr Types . numeric ) { str += STR_ ; } if ( attr Types . nominal ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( attr Types . string ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( attr Types . date ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( attr Types . relational ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } str += STR_ ; switch ( class Type ) { case Attribute . NUMERIC : str = STR_ + str ; break ; case Attribute . NOMINAL : str = STR_ + str ; break ; case Attribute . STRING : str = STR_ + str ; break ; case Attribute . DATE : str = STR_ + str ; break ; case Attribute . RELATIONAL : str = STR_ + str ; break ; } print ( str ) ; }
public boolean is Static ( ) { return Modifier . is Static ( flags ) ; }
@ Override protected void on Size Changed ( int w , int h , int oldw , int oldh ) { super . on Size Changed ( w , h , oldw , oldh ) ; m Center X = w / NUM_ ; m Center Y = h / NUM_ ; m Radius = Math . min ( m Center X , m Center Y ) ; m Progress Rect F . top = m Center Y - m Radius ; m Progress Rect F . bottom = m Center Y + m Radius ; m Progress Rect F . left = m Center X - m Radius ; m Progress Rect F . right = m Center X + m Radius ; update Progress Shader ( ) ; m Progress Rect F . inset ( m Progress Stroke Width / NUM_ , m Progress Stroke Width / NUM_ ) ; }
public void update Button Action Performed ( ) { if ( ! read Poll Timeout ( ) ) { return ; } if ( ! read Send Delay ( ) ) { return ; } if ( ! read Num Input Bits ( ) ) { return ; } if ( ! read Num Output Bits ( ) ) { return ; } set Node Parameters ( ) ; changed Node = true ; edit Mode = false ; cur Node = null ; add Button . set Visible ( true ) ; edit Button . set Visible ( true ) ; delete Button . set Visible ( true ) ; done Button . set Visible ( true ) ; update Button . set Visible ( false ) ; cancel Button . set Visible ( false ) ; node Addr Field . set Visible ( true ) ; node Addr Static . set Visible ( false ) ; status Text 2 . set Text ( std Status 2 ) ; status Text 3 . set Text ( std Status 3 ) ; status Text 1 . set Text ( rb . get String ( STR_ ) + STR_ + Integer . to String ( node Address ) ) ; error In Status 1 = true ; }
private void process Consumers For Inputs ( Lop node , Array List < Instruction > inst , Array List < Instruction > delte Inst ) throws DML Runtime Exception { for ( Lop in : node . get Inputs ( ) ) { if ( DML Script . ENABLE DEBUG MODE ) { process Consumers ( in , inst , delte Inst , node ) ; } else { process Consumers ( in , inst , delte Inst , null ) ; } } }
private void terminate Task Mgr ( Task Manager task Mgr ) { synchronized ( task Mgr ) { List pending Tasks = task Mgr . get Pending ( ) ; for ( int i = NUM_ ; i < pending Tasks . size ( ) ; i ++ ) { task Mgr . remove ( ( Task Manager . Task ) pending Tasks . get ( i ) ) ; } task Mgr . terminate ( ) ; } }
@ Post Mapping ( consumes = STR_ ) public Response Entity < File Info > upload File ( Http Servlet Request request , @ Request Param ( required = false ) String name ) { try { String content Length = request . get Header ( STR_ ) ; long size = NUM_ ; try { size = Long . value Of ( content Length ) ; } catch ( Number Format Exception ignored ) { } File Descriptor fd = create File Descriptor ( name , size ) ; Servlet Input Stream is = request . get Input Stream ( ) ; upload To Middleware ( is , fd ) ; save File Descriptor ( fd ) ; return create File Info Response Entity ( request , fd ) ; } catch ( Exception e ) { log . error ( STR_ , e ) ; throw new Rest API Exception ( STR_ , STR_ , Http Status . INTERNAL SERVER ERROR ) ; } }
private void define Tool Tips ( UI Defaults d ) { String p = STR_ ; d . put ( STR_ , new Color ( NUM_ ) ) ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , Boolean . FALSE ) ; d . put ( p + STR_ , new Color UI Resource ( NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , new Tool Tip Painter ( Tool Tip Painter . Which . BORDER ENABLED ) ) ; }
public String attributes Tip Text ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; }
private long file Channel Read ( Int Buffer slab Buffer ) throws IO Exception { long file Pos = file Channel . position ( ) ; long count = file Channel . transfer To ( file Pos , slab Buffer . remaining ( ) << NUM_ , INT BUFFER WRAPPER . init ( slab Buffer ) ) ; file Channel . position ( file Pos += count ) ; return count ; }
private void disconnect Internal ( ) { response Code = - NUM_ ; input Stream = null ; if ( pi != null ) { pi . finish Tracking ( ) ; pi = null ; } if ( http != null ) { http . close Server ( ) ; http = null ; connected = false ; } }
@ Override public int hash Code ( ) { final int prime = NUM_ ; int result = ( operation == null ) ? NUM_ : operation . hash Code ( ) ; result += prime * ( ( text == null ) ? NUM_ : text . hash Code ( ) ) ; return result ; }
private void check State ( final boolean uses Middles ) throws Illegal State Exception { if ( beginnings == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( uses Middles && middles == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( endings == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( beginnings . size ( ) == NUM_ ) { throw new Illegal State Exception ( STR_ ) ; } if ( uses Middles && middles . size ( ) == NUM_ ) { throw new Illegal State Exception ( STR_ ) ; } if ( endings . size ( ) == NUM_ ) { throw new Illegal State Exception ( STR_ ) ; } }
public void send Exception ( final Exception exception , final Map < String , String > properties ) { final Property Map Builder builder = new Property Map Builder ( properties ) ; logger . debug ( String . format ( STR_ , exception . get Message ( ) , builder . to String ( ) ) ) ; if ( telemetry Client != null ) { telemetry Client . track Exception ( exception , builder . build ( ) , null ) ; } }
private static External System reset Basic Fields ( External System input ) { input . set Username ( null ) ; input . set Password ( null ) ; return input ; }
public static Color correct Readability ( Color foreground , Color background ) { int bd = get Brightness Difference ( foreground , background ) ; if ( Math . abs ( bd ) < NUM_ ) { if ( get Brightness ( background ) > NUM_ ) { foreground = make Darker ( foreground , NUM_ ) ; } else { foreground = make Brighter ( foreground , NUM_ ) ; } } return foreground ; }
public void roll Out ( Operator operator ) { map . put ( operator , new Interpolated Value ( true , NUM_ ) ) ; if ( ! timer . is Running ( ) ) { timer . start ( ) ; } }
private int decode Channel Wordlen ( int ch Num ) { int ret ; Channel chan = ctx . channels [ ch Num ] ; Channel ref Chan = ctx . channels [ NUM_ ] ; int weight Idx = NUM_ ; chan . fill Mode = NUM_ ; switch ( br . read ( NUM_ ) ) { case NUM_ : for ( int i = NUM_ ; i < ctx . num Quant Units ; i ++ ) { chan . qu Wordlen [ i ] = br . read ( NUM_ ) ; } break ; case NUM_ : if ( ch Num > NUM_ ) { ret = num Coded Units ( chan ) ; if ( ret < NUM_ ) { return ret ; } if ( chan . num Coded Vals > NUM_ ) { VLC vlc Tab = wl vlc tabs [ br . read ( NUM_ ) ] ; for ( int i = NUM_ ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Wordlen [ i ] = ( ref Chan . qu Wordlen [ i ] + delta ) & NUM_ ; } } } else { weight Idx = br . read ( NUM_ ) ; ret = num Coded Units ( chan ) ; if ( ret < NUM_ ) { return ret ; } if ( chan . num Coded Vals > NUM_ ) { int pos = br . read ( NUM_ ) ; if ( pos > chan . num Coded Vals ) { log . error ( String . format ( STR_ , pos ) ) ; return AT 3 P ERROR ; } int delta Bits = br . read ( NUM_ ) ; int min Val = br . read ( NUM_ ) ; for ( int i = NUM_ ; i < pos ; i ++ ) { chan . qu Wordlen [ i ] = br . read ( NUM_ ) ; } for ( int i = pos ; i < chan . num Coded Vals ; i ++ ) { chan . qu Wordlen [ i ] = ( min Val + get Delta ( delta Bits ) ) & NUM_ ; } } } break ; case NUM_ : ret = num Coded Units ( chan ) ; if ( ret < NUM_ ) { return ret ; } if ( ch Num > NUM_ && chan . num Coded Vals > NUM_ ) { VLC vlc Tab = wl vlc tabs [ br . read ( NUM_ ) ] ; int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Wordlen [ NUM_ ] = ( ref Chan . qu Wordlen [ NUM_ ] + delta ) & NUM_ ; for ( int i = NUM_ ; i < chan . num Coded Vals ; i ++ ) { int diff = ref Chan . qu Wordlen [ i ] - ref Chan . qu Wordlen [ i - NUM_ ] ; delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i - NUM_ ] + diff + delta ) & NUM_ ; } } else if ( chan . num Coded Vals > NUM_ ) { boolean flag = br . read Bool ( ) ; VLC vlc Tab = wl vlc tabs [ br . read ( NUM_ ) ] ; int start Val = br . read ( NUM_ ) ; unpack Vq Shape ( start Val , atrac 3 p wl shapes [ start Val ] [ br . read ( NUM_ ) ] , chan . qu Wordlen , chan . num Coded Vals ) ; if ( ! flag ) { for ( int i = NUM_ ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + delta ) & NUM_ ; } } else { int i ; for ( i = NUM_ ; i < ( chan . num Coded Vals & - NUM_ ) ; i += NUM_ ) { if ( ! br . read Bool ( ) ) { chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + vlc Tab . get VLC 2 ( br ) ) & NUM_ ; chan . qu Wordlen [ i + NUM_ ] = ( chan . qu Wordlen [ i + NUM_ ] + vlc Tab . get VLC 2 ( br ) ) & NUM_ ; } } if ( ( chan . num Coded Vals & NUM_ ) != NUM_ ) { chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i ] + vlc Tab . get VLC 2 ( br ) ) & NUM_ ; } } } break ; case NUM_ : weight Idx = br . read ( NUM_ ) ; ret = num Coded Units ( chan ) ; if ( ret < NUM_ ) { return ret ; } if ( chan . num Coded Vals > NUM_ ) { VLC vlc Tab = wl vlc tabs [ br . read ( NUM_ ) ] ; chan . qu Wordlen [ NUM_ ] = br . read ( NUM_ ) ; for ( int i = NUM_ ; i < chan . num Coded Vals ; i ++ ) { int delta = vlc Tab . get VLC 2 ( br ) ; chan . qu Wordlen [ i ] = ( chan . qu Wordlen [ i - NUM_ ] + delta ) & NUM_ ; } } break ; } if ( chan . fill Mode == NUM_ ) { for ( int i = chan . num Coded Vals ; i < ctx . num Quant Units ; i ++ ) { chan . qu Wordlen [ i ] = ( ch Num > NUM_ ? br . read 1 ( ) : NUM_ ) ; } } else if ( chan . fill Mode == NUM_ ) { int pos = ( ch Num > NUM_ ? chan . num Coded Vals + chan . split Point : ctx . num Quant Units - chan . split Point ) ; for ( int i = chan . num Coded Vals ; i < pos ; i ++ ) { chan . qu Wordlen [ i ] = NUM_ ; } } if ( weight Idx != NUM_ ) { return add Wordlen Weights ( chan , weight Idx ) ; } return NUM_ ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Pointer Needle ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } return true ; }
public static void reduce Method List ( Array List < Integer > values , Array List < String > labels , String allowed Methods ) { String [ ] allowed Strings = allowed Methods . split ( STR_ ) ; int [ ] allowed Values = new int [ allowed Strings . length ] ; for ( int i = NUM_ ; i < allowed Values . length ; i ++ ) { try { allowed Values [ i ] = Integer . parse Int ( allowed Strings [ i ] , NUM_ ) ; } catch ( Number Format Exception nfe ) { Log . w ( TAG , STR_ + allowed Strings [ i ] + STR_ + allowed Methods + STR_ ) ; return ; } } for ( int i = values . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { int val = values . get ( i ) ; int j ; for ( j = allowed Values . length - NUM_ ; j >= NUM_ ; j -- ) { if ( val == allowed Values [ j ] ) { break ; } } if ( j < NUM_ ) { values . remove ( i ) ; labels . remove ( i ) ; } } }
private boolean check For Enhanced Zone Session ( String [ ] lines , Integer retry Count ) throws Network Device Controller Exception { return check For Zone Session ( lines , retry Count , false ) ; }
private void verify Replication Mode On Distributed Transaction Processing Configuration ( Logger specific Logger ) { if ( distributed Transaction Processing Configuration . is Overriden ( ) ) { if ( specific Logger . is Loggable ( Level . WARNING ) ) specific Logger . log ( Level . WARNING , STR_ + MULTI SOURCE MODE + STR_ ) ; } }
void draw Letter ( Graphics g , char letter , int ax , int ay , int aw , int ah , float align , int index ) { String str = format Item Num ( index , letter ) ; str = is Left To Right ? str + STR_ : STR_ + str ; Font Metrics fm = Swing Utilities 2 . get Font Metrics ( null , g ) ; int stringwidth = Swing Utilities 2 . string Width ( null , fm , str ) ; int gap = is Left To Right ? - ( stringwidth + bulletgap ) : ( aw + bulletgap ) ; int x = ax + gap ; int y = Math . max ( ay + fm . get Ascent ( ) , ay + ( int ) ( ah * align ) ) ; Swing Utilities 2 . draw String ( null , g , str , x , y ) ; }
private void initialize ( Atlas Graph graph ) throws Repository Exception , Index Exception { Atlas Graph Management management = graph . get Management System ( ) ; try { if ( management . contains Property Key ( Constants . VERTEX TYPE PROPERTY KEY ) ) { LOG . info ( STR_ ) ; management . commit ( ) ; return ; } LOG . info ( STR_ ) ; management . create Vertex Index ( Constants . VERTEX INDEX , Constants . BACKING INDEX , Collections . < Atlas Property Key > empty List ( ) ) ; management . create Edge Index ( Constants . EDGE INDEX , Constants . BACKING INDEX ) ; create Indexes ( management , Constants . GUID PROPERTY KEY , String . class , true , Atlas Cardinality . SINGLE , true , true ) ; create Indexes ( management , Constants . TIMESTAMP PROPERTY KEY , Long . class , false , Atlas Cardinality . SINGLE , true , true ) ; create Indexes ( management , Constants . STATE PROPERTY KEY , String . class , false , Atlas Cardinality . SINGLE , false , false ) ; create Indexes ( management , Constants . MODIFICATION TIMESTAMP PROPERTY KEY , Long . class , false , Atlas Cardinality . SINGLE , false , false ) ; create Indexes ( management , Constants . ENTITY TYPE PROPERTY KEY , String . class , false , Atlas Cardinality . SINGLE , true , true ) ; create Indexes ( management , Constants . SUPER TYPES PROPERTY KEY , String . class , false , Atlas Cardinality . SET , true , true ) ; create Indexes ( management , Constants . TRAIT NAMES PROPERTY KEY , String . class , false , Atlas Cardinality . SET , true , true ) ; create Full Text Index ( management ) ; create Type Store Indexes ( management ) ; commit ( management ) ; LOG . info ( STR_ ) ; } catch ( Throwable t ) { rollback ( management ) ; throw new Repository Exception ( t ) ; } }
public void add Update Listener ( Preference Update Listener listener ) { update Listeners . add ( listener ) ; }
public void add Mount Expand Rollback ( Block Object Rest Rep volume , Mount Point mount Point ) { Execution Utils . add Rollback ( new Set Block Volume Machine Tag ( volume . get Id ( ) , get Mount Point Tag Name ( ) , mount Point . get Path ( ) ) ) ; add Rollback ( new Mount Path ( mount Point . get Path ( ) ) ) ; add Rollback ( new Add To FS Tab ( mount Point . get Device ( ) , mount Point . get Path ( ) , mount Point . get Fs Type ( ) , mount Point . get Options ( ) ) ) ; }
private String build Task 1 Token JSON ( String Builder text Builder , Named Entity named Entity , Map < Integer , Integer > char Offset Start Mapping , Map < Integer , Integer > char Offset End Mapping ) throws Crowd Exception { if ( ! char Offset Start Mapping . contains Key ( named Entity . get Begin ( ) ) || ! char Offset End Mapping . contains Key ( named Entity . get End ( ) ) ) { throw new Crowd Exception ( STR_ ) ; } int start = char Offset Start Mapping . get ( named Entity . get Begin ( ) ) ; int end = char Offset End Mapping . get ( named Entity . get End ( ) ) ; text Builder . set Length ( NUM_ ) ; text Builder . append ( STR_ ) ; text Builder . append ( start ) ; text Builder . append ( STR_ ) ; text Builder . append ( end ) ; text Builder . append ( STR_ ) ; return new String ( text Builder ) ; }
private void initialize Path ( String p uri Spec , int p n Start Index ) throws Malformed URI Exception { if ( p uri Spec == null ) { throw new Malformed URI Exception ( STR_ ) ; } int index = p n Start Index ; int start = p n Start Index ; int end = p uri Spec . length ( ) ; char test Char = STR_ ; if ( start < end ) { if ( get Scheme ( ) == null || p uri Spec . char At ( start ) == STR_ ) { while ( index < end ) { test Char = p uri Spec . char At ( index ) ; if ( test Char == STR_ ) { if ( index + NUM_ >= end || ! is Hex ( p uri Spec . char At ( index + NUM_ ) ) || ! is Hex ( p uri Spec . char At ( index + NUM_ ) ) ) { throw new Malformed URI Exception ( STR_ ) ; } index += NUM_ ; } else if ( ! is Path Character ( test Char ) ) { if ( test Char == STR_ || test Char == STR_ ) { break ; } throw new Malformed URI Exception ( STR_ + test Char ) ; } ++ index ; } } else { while ( index < end ) { test Char = p uri Spec . char At ( index ) ; if ( test Char == STR_ || test Char == STR_ ) { break ; } if ( test Char == STR_ ) { if ( index + NUM_ >= end || ! is Hex ( p uri Spec . char At ( index + NUM_ ) ) || ! is Hex ( p uri Spec . char At ( index + NUM_ ) ) ) { throw new Malformed URI Exception ( STR_ ) ; } index += NUM_ ; } else if ( ! is URI Character ( test Char ) ) { throw new Malformed URI Exception ( STR_ + test Char ) ; } ++ index ; } } } m path = p uri Spec . substring ( start , index ) ; if ( test Char == STR_ ) { index ++ ; start = index ; while ( index < end ) { test Char = p uri Spec . char At ( index ) ; if ( test Char == STR_ ) { break ; } if ( test Char == STR_ ) { if ( index + NUM_ >= end || ! is Hex ( p uri Spec . char At ( index + NUM_ ) ) || ! is Hex ( p uri Spec . char At ( index + NUM_ ) ) ) { throw new Malformed URI Exception ( STR_ ) ; } index += NUM_ ; } else if ( ! is URI Character ( test Char ) ) { throw new Malformed URI Exception ( STR_ + test Char ) ; } index ++ ; } m query String = p uri Spec . substring ( start , index ) ; } if ( test Char == STR_ ) { index ++ ; start = index ; while ( index < end ) { test Char = p uri Spec . char At ( index ) ; if ( test Char == STR_ ) { if ( index + NUM_ >= end || ! is Hex ( p uri Spec . char At ( index + NUM_ ) ) || ! is Hex ( p uri Spec . char At ( index + NUM_ ) ) ) { throw new Malformed URI Exception ( STR_ ) ; } index += NUM_ ; } else if ( ! is URI Character ( test Char ) ) { throw new Malformed URI Exception ( STR_ + test Char ) ; } index ++ ; } m fragment = p uri Spec . substring ( start , index ) ; } }
private void update IP Address ( String ip Address , Storage Port port ) { if ( null != ip Address && ! ip Address . equals Ignore Case ( port . get Port Network Id ( ) ) ) { port . set Ip Address ( ip Address ) ; } }
public void render List Head ( List Head head ) { Component header ; W Table Column column ; for ( int column Index = NUM_ ; column Index < m table Columns . size ( ) ; column Index ++ ) { column = m table Columns . get ( column Index ) ; header = get List Header Component ( column . get Header Value ( ) , column Index , column . get Column Class ( ) ) ; head . append Child ( header ) ; } head . set Sizable ( true ) ; return ; }
private static boolean is Sparse Array ( Element array E ) { String name = array E . get Tag Name ( ) ; if ( name . equals ( STR_ ) || name . equals ( STR_ ) ) { return true ; } return false ; }
private static String swizzle Class Name For Read ( String name , Data Input in ) { String old Package = STR_ ; String new Package = STR_ ; if ( name . starts With ( old Package ) ) { return new Package + name . substring ( old Package . length ( ) ) ; } Old Client Support Service svc = Internal Data Serializer . get Old Client Support Service ( ) ; if ( svc != null ) { return svc . process Incoming Class Name ( name , in ) ; } return name ; }
public int eval ( I Node state ) { Eight Puzzle Node node = ( Eight Puzzle Node ) state ; int Pn = NUM_ ; for ( int r = NUM_ ; r <= Eight Puzzle Node . Max R ; r ++ ) { for ( int c = NUM_ ; c <= Eight Puzzle Node . Max C ; c ++ ) { if ( node . is Empty ( r , c ) ) { continue ; } int digit = node . cell ( r , c ) ; Pn += Math . abs ( diffs [ digit ] [ NUM_ ] - r ) ; Pn += Math . abs ( diffs [ digit ] [ NUM_ ] - c ) ; } } int gn = NUM_ ; Depth Transition t = ( Depth Transition ) state . stored Data ( ) ; if ( t != null ) { gn = t . depth ; } return gn + Pn ; }
protected void calculate Offset ( T entity , final int swidth , final int sheight ) { final Rectangle 2 D area = entity . get Area ( ) ; calculate Offset ( swidth , sheight , ( int ) ( I Game Screen . SIZE UNIT PIXELS * area . get Width ( ) ) , ( int ) ( I Game Screen . SIZE UNIT PIXELS * area . get Height ( ) ) ) ; }
public boolean validation ( ) throws Parallel Task Invalid Exception { Parallel Task task = new Parallel Task ( ) ; target Host Meta = new Target Host Meta ( target Hosts ) ; task = new Parallel Task ( request Protocol , concurrency , http Meta , target Host Meta , ssh Meta , tcp Meta , udp Meta , ping Meta , null , response Context , replacement Var Map Node Specific , replacement Var Map , request Replacement Type , config ) ; boolean valid = false ; try { valid = task . validate With Fill Default ( ) ; } catch ( Parallel Task Invalid Exception e ) { logger . info ( STR_ + e ) ; } return valid ; }
public synchronized void open Read ( ) throws Replicator Exception , Interrupted Exception { if ( ! file . exists ( ) ) { throw new THL Exception ( STR_ + file . get Name ( ) ) ; } try { data Input = new Buffered File Data Input ( file , buffer Size ) ; } catch ( IO Exception e ) { throw new THL Exception ( STR_ + file . get Name ( ) , e ) ; } mode = Access Mode . read ; check File Header ( data Input ) ; }
public void print ( ) { print ( System . out ) ; }
public void cleanup ( ) { if ( cleanup Records != null ) { Iterator < Long > iter Record = cleanup Records . iterator ( ) ; while ( iter Record . has Next ( ) ) { Long record = iter Record . next ( ) ; if ( iter Record . has Next ( ) ) { delete ID ( record . long Value ( ) ) ; } } cleanup Records . clear ( ) ; cleanup Records = null ; } }
private Allocation Outcome allocate ( final long size , final boolean incoming Update Peak , final boolean force Allocation ) { final long new Local = locally Held Memory . add And Get ( size ) ; final long beyond Reservation = new Local - reservation ; final boolean beyond Limit = new Local > allocation Limit . get ( ) ; final boolean update Peak = force Allocation || ( incoming Update Peak && ! beyond Limit ) ; Allocation Outcome parent Outcome = Allocation Outcome . SUCCESS ; if ( beyond Reservation > NUM_ && parent != null ) { final long parent Request = Math . min ( beyond Reservation , size ) ; parent Outcome = parent . allocate ( parent Request , update Peak , force Allocation ) ; } final Allocation Outcome final Outcome = beyond Limit ? Allocation Outcome . FAILED LOCAL : parent Outcome . ok ? Allocation Outcome . SUCCESS : Allocation Outcome . FAILED PARENT ; if ( update Peak ) { update Peak ( ) ; } return final Outcome ; }
private Point 2 D inverse Transform ( Point 2 D view Point ) { view Point = delegate . inverse Transform ( view Point ) ; Point 2 D view Center = get View Center ( ) ; double view Radius = get View Radius ( ) ; double ratio = get Ratio ( ) ; double dx = view Point . get X ( ) - view Center . get X ( ) ; double dy = view Point . get Y ( ) - view Center . get Y ( ) ; dx *= ratio ; Point 2 D point From Center = new Point 2 D . Double ( dx , dy ) ; Polar Point polar = Polar Point . cartesian To Polar ( point From Center ) ; double radius = polar . get Radius ( ) ; if ( radius > view Radius ) return view Point ; double mag = magnification ; radius /= mag ; polar . set Radius ( radius ) ; Point 2 D projected Point = Polar Point . polar To Cartesian ( polar ) ; projected Point . set Location ( projected Point . get X ( ) / ratio , projected Point . get Y ( ) ) ; Point 2 D translated Back = new Point 2 D . Double ( projected Point . get X ( ) + view Center . get X ( ) , projected Point . get Y ( ) + view Center . get Y ( ) ) ; return translated Back ; }
public void remove Chat Session Listener ( Chat Session Listener listener ) { m Listeners . remove ( listener ) ; }
static byte [ ] hex To Bytes ( String hex ) { if ( hex == null ) { return EMPTY BYTES ; } hex = hex . replace All ( STR_ , STR_ ) ; if ( hex . length ( ) == NUM_ ) { return EMPTY BYTES ; } Byte Array Output Stream baos = new Byte Array Output Stream ( hex . length ( ) / NUM_ ) ; byte b ; for ( int i = NUM_ ; i < hex . length ( ) ; i ++ ) { int high = char To Nibble ( hex . char At ( i ) ) ; int low = NUM_ ; if ( i < hex . length ( ) - NUM_ ) { i ++ ; low = char To Nibble ( hex . char At ( i ) ) ; } b = ( byte ) ( high << NUM_ | low ) ; baos . write ( b ) ; } return baos . to Byte Array ( ) ; }
protected void sprint ( char char Field ) { sprint ( String . value Of ( char Field ) ) ; }
private static void autofit ( Text View view , Text Paint paint , float min Text Size , float max Text Size , int max Lines , float precision ) { if ( max Lines <= NUM_ || max Lines == Integer . MAX VALUE ) { return ; } int target Width = view . get Width ( ) - view . get Padding Left ( ) - view . get Padding Right ( ) ; if ( target Width <= NUM_ ) { return ; } Char Sequence text = view . get Text ( ) ; Transformation Method method = view . get Transformation Method ( ) ; if ( method != null ) { text = method . get Transformation ( text , view ) ; } Context context = view . get Context ( ) ; Resources r = Resources . get System ( ) ; Display Metrics display Metrics ; float size = max Text Size ; float high = size ; float low = NUM_ ; if ( context != null ) { r = context . get Resources ( ) ; } display Metrics = r . get Display Metrics ( ) ; paint . set ( view . get Paint ( ) ) ; paint . set Text Size ( size ) ; if ( ( max Lines == NUM_ && paint . measure Text ( text , NUM_ , text . length ( ) ) > target Width ) || get Line Count ( text , paint , size , target Width , display Metrics ) > max Lines ) { size = get Autofit Text Size ( text , paint , target Width , max Lines , low , high , precision , display Metrics ) ; } if ( size < min Text Size ) { size = min Text Size ; } view . set Text Size ( Typed Value . COMPLEX UNIT PX , size ) ; }
private float calc Angle ( float value ) { return value / m Data . get Y Value Sum ( ) * NUM_ ; }
synchronized protected void fast Display Timeout ( ) { if ( Math . abs ( target Speed - current Speed ) < Math . abs ( inc Speed ) ) { current Speed = target Speed ; } else { current Speed += inc Speed ; } if ( current Speed < NUM_ ) { current Speed = NUM_ ; } show Speed ( ) ; }
public static I Covariance Matrix serializable Instance ( ) { List < Node > variables = new Array List < > ( ) ; Node x = new Continuous Variable ( STR_ ) ; variables . add ( x ) ; Tetrad Matrix matrix = Tetrad Algebra . identity ( NUM_ ) ; return new Covariance Matrix ( variables , matrix , NUM_ ) ; }
public Mim Search Editor 2 ( Mim Build Runner runner ) { this ( runner , STR_ ) ; }
protected String Buffer construct Statement ( Row Change Data . Action Type action , String schema Name , String table Name , Array List < One Row Change . Column Spec > columns , Array List < One Row Change . Column Spec > keys , Array List < One Row Change . Column Val > key Values , Array List < One Row Change . Column Val > col Values ) { String Buffer stmt = new String Buffer ( ) ; if ( action == Row Change Data . Action Type . INSERT ) { stmt . append ( STR_ ) ; stmt . append ( conn . get Database Object Name ( schema Name ) + STR_ + conn . get Database Object Name ( table Name ) ) ; stmt . append ( STR_ ) ; print Column Spec ( stmt , columns , null , col Values , Print Mode . NAMES ONLY , STR_ ) ; stmt . append ( STR_ ) ; stmt . append ( STR_ ) ; print Column Spec ( stmt , columns , null , col Values , Print Mode . PLACE HOLDER , STR_ ) ; stmt . append ( STR_ ) ; } else if ( action == Row Change Data . Action Type . UPDATE ) { stmt . append ( STR_ ) ; stmt . append ( conn . get Database Object Name ( schema Name ) + STR_ + conn . get Database Object Name ( table Name ) ) ; stmt . append ( STR_ ) ; print Column Spec ( stmt , columns , null , col Values , Print Mode . ASSIGNMENT , STR_ ) ; stmt . append ( STR_ ) ; print Column Spec ( stmt , keys , key Values , col Values , Print Mode . ASSIGNMENT , STR_ ) ; } else if ( action == Row Change Data . Action Type . DELETE ) { stmt . append ( STR_ ) ; stmt . append ( conn . get Database Object Name ( schema Name ) + STR_ + conn . get Database Object Name ( table Name ) ) ; stmt . append ( STR_ ) ; print Column Spec ( stmt , keys , key Values , col Values , Print Mode . ASSIGNMENT , STR_ ) ; } return stmt ; }
private void update Pseudo References ( int epoch ) { if ( nbest List Writer != null ) { nbest List Writer . close ( ) ; Evaluation Metric < I String , String > metric = new BLEU Metric < I String , String > ( references ) ; Multi Translation Metric Max < I String , String > search Algorithm = new Hill Climbing Multi Translation Metric Max < I String , String > ( metric ) ; N Best List Container < I String , String > nbest Lists = null ; try { nbest Lists = new Flat N Best List ( nbest Filename , references . size ( ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; logger . error ( STR_ , nbest Filename ) ; throw new Runtime Exception ( STR_ + nbest Filename ) ; } List < Scored Featurized Translation < I String , String > > max Featurized Translations = search Algorithm . maximize ( nbest Lists ) ; assert max Featurized Translations . size ( ) == tune Source . size ( ) : STR_ ; int num Translations = max Featurized Translations . size ( ) ; for ( int i = NUM_ ; i < num Translations ; ++ i ) { Sequence < I String > translation = max Featurized Translations . get ( i ) . translation ; if ( pseudo References . get ( i ) . size ( ) >= num Pseudo References ) pseudo References . get ( i ) . remove ( NUM_ ) ; pseudo References . get ( i ) . add ( translation ) ; } logger . info ( STR_ , pseudo References . get ( NUM_ ) . size ( ) ) ; File file = new File ( nbest Filename ) ; file . delete ( ) ; reference Weights = new double [ num References + pseudo References . get ( NUM_ ) . size ( ) ] ; Arrays . fill ( reference Weights , NUM_ ) ; } if ( epoch >= pseudo Reference Burn In ) { nbest Filename = String . format ( STR_ , temp Directory , epoch ) ; logger . info ( STR_ , nbest Filename ) ; nbest List Writer = IO Tools . get Writer From File ( nbest Filename ) ; } }
public void add Method ( Method m ) { m . resolve ( this ) ; methods . add Element ( m ) ; }
private void generate ( Class c , String element ) throws SAX Exception { if ( c != null ) { handler . start Element ( STR_ , element , element , EMPTY ) ; String class Name = c . get Name ( ) ; handler . characters ( class Name . to Char Array ( ) , NUM_ , class Name . length ( ) ) ; handler . end Element ( STR_ , element , element ) ; } }
public String delete Work Flow Matrix ( ) { LOGGER . info ( STR_ ) ; final Hash Map workflowsearchparams = get Search Params ( ) ; delete Work Flow Matrix Object ( workflowsearchparams ) ; final Hash Map workflowheaderparams = get Header Params ( ) ; get Work Flow Matrix Object ( workflowheaderparams ) ; set Mode ( RESULTS ) ; add Action Message ( STR_ ) ; LOGGER . info ( STR_ ) ; return STR_ ; }
public static java . sql . Date to Sql Date ( String month Str , String day Str , String year Str ) { java . util . Date new Date = to Date ( month Str , day Str , year Str , STR_ , STR_ , STR_ ) ; if ( new Date != null ) { return new java . sql . Date ( new Date . get Time ( ) ) ; } else { return null ; } }
public URI create Tenant ( Keystone Tenant tenant ) { Tenant Org Rest Rep tenant Resp = internal Tenant Service Client . create Tenant ( keystone Utils Service . prepare Tenant Param ( tenant ) ) ; return tenant Resp . get Id ( ) ; }
private void update Min Max ( Instance instance ) { for ( int j = NUM_ ; j < m the Instances . num Attributes ( ) ; j ++ ) { if ( ! instance . is Missing ( j ) ) { if ( Double . is Na N ( m min Values [ j ] ) ) { m min Values [ j ] = instance . value ( j ) ; m max Values [ j ] = instance . value ( j ) ; } else { if ( instance . value ( j ) < m min Values [ j ] ) { m min Values [ j ] = instance . value ( j ) ; } else { if ( instance . value ( j ) > m max Values [ j ] ) { m max Values [ j ] = instance . value ( j ) ; } } } } } }
private void check Buffer ( M Tree Node new Node ) { if ( ! new Node . is Summary ( ) || ! new Node . get Allows Children ( ) ) return ; for ( int i = NUM_ ; i < m buffer . size ( ) ; i ++ ) { M Tree Node node = ( M Tree Node ) m buffer . get ( i ) ; if ( node . get Parent ID ( ) == new Node . get Node ID ( ) ) { try { new Node . add ( node ) ; } catch ( Exception e ) { log . severe ( STR_ + node . get Name ( ) + STR_ + new Node . get Name ( ) + STR_ + e . get Message ( ) ) ; } m buffer . remove ( i ) ; i -- ; } } }
static void add Special Key ( String special Key Name , int special Key Code ) { if ( special Keys == null ) { special Keys = new Hashtable ( ) ; } special Keys . put ( special Key Name , new Integer ( special Key Code ) ) ; }
protected void image Submit ( String image Data ) { String Builder data Buffer = new String Builder ( ) ; Element elem = get Element ( ) ; HTML Document hdoc = ( HTML Document ) elem . get Document ( ) ; get Form Data ( data Buffer ) ; if ( data Buffer . length ( ) > NUM_ ) { data Buffer . append ( STR_ ) ; } data Buffer . append ( image Data ) ; submit Data ( data Buffer . to String ( ) ) ; return ; }
public boolean is Required ( final Attribute Type attribute Type ) { return required Attributes . contains ( attribute Type ) ; }
protected void init Max Pings ( ) { String max Pings Param = get Init Parameter ( STR_ ) ; set Max Pings ( ( max Pings Param == null ) ? DEFAULT MAX PINGS : Integer . parse Int ( max Pings Param ) ) ; if ( is Debug ( ) ) { log ( STR_ + get Max Pings ( ) ) ; } }
public boolean frame Available Soon ( ) { synchronized ( m Sync ) { if ( ! m Is Capturing || m Request Stop ) { return false ; } m Request Drain ++ ; m Sync . notify All ( ) ; } return true ; }
public Proper Fraction Format ( Number Format format ) { this ( format , ( Number Format ) format . clone ( ) , ( Number Format ) format . clone ( ) ) ; }
protected void initialize ( ) { exist Stmt = Prepared Statement Factory . get Prepared Statement ( String . format ( EXISTENCE CQL , get Table ( ) ) , get Session ( ) ) ; read Stmt = Prepared Statement Factory . get Prepared Statement ( String . format ( READ CQL , get Table ( ) ) , get Session ( ) ) ; create Stmt = Prepared Statement Factory . get Prepared Statement ( String . format ( CREATE CQL , get Table ( ) , Columns . NAME ) , get Session ( ) ) ; delete Stmt = Prepared Statement Factory . get Prepared Statement ( String . format ( DELETE CQL , get Table ( ) ) , get Session ( ) ) ; mark Active Stmt = Prepared Statement Factory . get Prepared Statement ( String . format ( MARK ACTIVE CQL , get Table ( ) ) , get Session ( ) ) ; read All Stmt = Prepared Statement Factory . get Prepared Statement ( String . format ( READ ALL CQL , get Table ( ) ) , get Session ( ) ) ; read All Count Stmt = Prepared Statement Factory . get Prepared Statement ( String . format ( READ ALL COUNT CQL , get Table ( ) ) , get Session ( ) ) ; }
private void compute Split Values ( ) { float lat Mid = ( bb . get Lat Min ( ) + bb . get Lat Max ( ) ) / NUM_ ; double width = ( bb . get Lon Max ( ) - bb . get Lon Min ( ) ) * Math . cos ( lat Mid * Math . PI / NUM_ ) ; double height = bb . get Lat Max ( ) - bb . get Lat Min ( ) ; if ( height > width ) { split At Lat = true ; split Value = lat Mid ; } else { split At Lat = false ; split Value = ( bb . get Lon Min ( ) + bb . get Lon Max ( ) ) / NUM_ ; } }
private Permission Request submit ( ) { int show Rationale = NUM_ ; Array List < String > requests = new Array List < > ( ) ; for ( final String permission : m Permissions ) { if ( m Activity . check Self Permission ( permission ) != Package Manager . PERMISSION GRANTED ) { requests . add ( permission ) ; if ( Activity Compat . should Show Request Permission Rationale ( m Activity , permission ) ) { show Rationale ++ ; } } } m Request Code = m Request Id . add And Get ( NUM_ ) ; if ( requests . is Empty ( ) ) { if ( m Callback != null ) { m Callback . on Permissions Granted ( ) ; } } else { if ( show Rationale == NUM_ ) { Activity Compat . request Permissions ( m Activity , m Permissions , m Request Code ) ; } else { show Rationale ( ) ; } } return this ; }
@ Override public void reset Frame ( ) { synchronized ( lock ) { sys Name . set Text ( STR_ + counter ++ ) ; } user Name . set Text ( null ) ; assigned Buffer . set Selected Index ( NUM_ ) ; loop Infinite . set Selected ( false ) ; loop Min . set Value ( Audio Source . LOOP NONE ) ; loop Max . set Value ( Audio Source . LOOP NONE ) ; position . set Value ( new Vector 3 f ( NUM_ , NUM_ , NUM_ ) ) ; position Relative . set Selected ( false ) ; velocity . set Value ( new Vector 3 f ( NUM_ , NUM_ , NUM_ ) ) ; gain . set Value ( NUM_ ) ; pitch . set Value ( NUM_ ) ; ref Distance . set Value ( NUM_ ) ; max Distance . set Value ( Audio . MAX DISTANCE ) ; roll Off Factor . set Value ( NUM_ ) ; fade In Time . set Value ( NUM_ ) ; fade Out Time . set Value ( NUM_ ) ; this . new Source = true ; }
public Abstract Network Connection Config ( Network Port Adapter p ) { adapter = p ; }
private static boolean array Member Equals ( final Class < ? > component Type , final Object o 1 , final Object o 2 ) { if ( component Type . is Annotation ( ) ) { return annotation Array Member Equals ( ( Annotation [ ] ) o 1 , ( Annotation [ ] ) o 2 ) ; } if ( component Type . equals ( Byte . TYPE ) ) { return Arrays . equals ( ( byte [ ] ) o 1 , ( byte [ ] ) o 2 ) ; } if ( component Type . equals ( Short . TYPE ) ) { return Arrays . equals ( ( short [ ] ) o 1 , ( short [ ] ) o 2 ) ; } if ( component Type . equals ( Integer . TYPE ) ) { return Arrays . equals ( ( int [ ] ) o 1 , ( int [ ] ) o 2 ) ; } if ( component Type . equals ( Character . TYPE ) ) { return Arrays . equals ( ( char [ ] ) o 1 , ( char [ ] ) o 2 ) ; } if ( component Type . equals ( Long . TYPE ) ) { return Arrays . equals ( ( long [ ] ) o 1 , ( long [ ] ) o 2 ) ; } if ( component Type . equals ( Float . TYPE ) ) { return Arrays . equals ( ( float [ ] ) o 1 , ( float [ ] ) o 2 ) ; } if ( component Type . equals ( Double . TYPE ) ) { return Arrays . equals ( ( double [ ] ) o 1 , ( double [ ] ) o 2 ) ; } if ( component Type . equals ( Boolean . TYPE ) ) { return Arrays . equals ( ( boolean [ ] ) o 1 , ( boolean [ ] ) o 2 ) ; } return Arrays . equals ( ( Object [ ] ) o 1 , ( Object [ ] ) o 2 ) ; }
@ Override public double [ ] distribution For Instance ( Instance instance ) throws Exception { m Replace Missing Values . input ( instance ) ; instance = m Replace Missing Values . output ( ) ; m Att Filter . input ( instance ) ; instance = m Att Filter . output ( ) ; m Nominal To Binary . input ( instance ) ; instance = m Nominal To Binary . output ( ) ; double [ ] inst Dat = new double [ m Num Predictors + NUM_ ] ; int j = NUM_ ; inst Dat [ NUM_ ] = NUM_ ; for ( int k = NUM_ ; k <= m Num Predictors ; k ++ ) { if ( k != m Class Index ) { inst Dat [ j ++ ] = instance . value ( k ) ; } } double [ ] distribution = evaluate Probability ( inst Dat ) ; return distribution ; }
private void assert Resource Parser ( ) { if ( scanner == null ) { throw new Illegal State Exception ( STR_ ) ; } }
private void increment Counter ( Class < ? extends Joint > clazz ) { Integer n = N . get ( clazz ) ; if ( n == null ) { N . put ( clazz , NUM_ ) ; } else { N . put ( clazz , n . int Value ( ) + NUM_ ) ; } }
private void validate Port Assignment ( Storage System storage System , URI varray , Block Storage Scheduler block Scheduler , List < Initiator > initiators , Collection < URI > volumes , URI export Group URI , Export Path Parameters export Path Parameters ) { try { Export Path Params path Params = block Scheduler . calculate Export Path Param For Volumes ( volumes , NUM_ , storage System . get Id ( ) , export Group URI ) ; if ( export Path Parameters != null ) { if ( export Path Parameters . get Max Paths ( ) != null ) { path Params . set Max Paths ( export Path Parameters . get Max Paths ( ) ) ; } if ( export Path Parameters . get Min Paths ( ) != null ) { path Params . set Min Paths ( export Path Parameters . get Min Paths ( ) ) ; } if ( export Path Parameters . get Paths Per Initiator ( ) != null ) { path Params . set Paths Per Initiator ( export Path Parameters . get Paths Per Initiator ( ) ) ; } } block Scheduler . assign Storage Ports ( storage System , varray , initiators , path Params , null , volumes ) ; } catch ( Controller Exception ex ) { log . error ( ex . get Localized Message ( ) ) ; throw ( ex ) ; } }
private String generate Fitting Text ( Method method , Rectangle 2 D rect , Font Metrics font Metrics ) { if ( rect . get Width ( ) < font Metrics . string Width ( STR_ ) ) { return STR_ ; } String fully Qualified = method . get Name Space ( ) + STR_ + method . get Name ( ) ; if ( font Metrics . string Width ( fully Qualified ) < rect . get Width ( ) ) { return fully Qualified ; } String abbrev Package = get Short Package Name ( method . get Name Space ( ) ) + STR_ + method . get Name ( ) ; if ( font Metrics . string Width ( abbrev Package ) < rect . get Width ( ) ) { return abbrev Package ; } if ( font Metrics . string Width ( method . get Name ( ) ) < rect . get Width ( ) ) { return method . get Name ( ) ; } return STR_ ; }
private static void find Outer Shells ( List shell List ) { for ( Iterator i = shell List . iterator ( ) ; i . has Next ( ) ; ) { Edge Ring er = ( Edge Ring ) i . next ( ) ; Edge Ring outer Hole ER = er . get Outer Hole ( ) ; if ( outer Hole ER != null && ! outer Hole ER . is Processed ( ) ) { er . set Included ( true ) ; outer Hole ER . set Processed ( true ) ; } } }
public static int main Init ( final Output Stream out Stream , Command Lookup info ) { final Print Stream psout Stream = new Print Stream ( out Stream ) ; try { print License ( psout Stream , info ) ; } finally { psout Stream . flush ( ) ; } return NUM_ ; }
public static Result download ( long id ) { Content Resolver cr = cr ( ) ; Uri uri = Content Uris . with Appended Id ( Restaurants . CONTENT URI , id ) ; String [ ] proj = { Restaurants . GLOBAL ID , Restaurants . PLACE ID } ; Easy Cursor c = new Easy Cursor ( cr . query ( uri , proj , null , null , null ) ) ; Restaurant restaurant = new Restaurant ( ) ; restaurant . local Id = id ; if ( c . move To First ( ) ) { restaurant . global Id = c . get Long ( Restaurants . GLOBAL ID ) ; restaurant . place Id = c . get String ( Restaurants . PLACE ID ) ; } c . close ( ) ; if ( restaurant . global Id > NUM_ && Text Utils . is Empty ( restaurant . place Id ) ) { restaurant = Server . restaurant ( restaurant ) ; } Result result = null ; if ( restaurant != null && ! Text Utils . is Empty ( restaurant . place Id ) ) { try { Content Values vals = new Content Values ( NUM_ ) ; vals . put ( Restaurants . PLACE ID , restaurant . place Id ) ; result = details ( id , vals ) ; if ( STATUS NOT FOUND . equals ( result . status ) ) { return result ; } if ( result . place != null ) { photo ( result . photo Id , id , result . place ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STR_ , e ) ; exception ( e ) ; } } if ( restaurant != null && restaurant . status == null ) { restaurant = Server . restaurant ( restaurant ) ; } if ( restaurant != null ) { restaurant . status = ACTIVE ; Content Values vals = Restaurants . values ( restaurant ) ; Restaurants . delete Conflict ( restaurant . local Id , restaurant . global Id ) ; try { cr . update ( uri , vals , null , null ) ; } catch ( SQ Lite Constraint Exception e ) { Log . e ( TAG , STR_ , e ) ; exception ( e ) ; } try { photo ( id , vals ) ; } catch ( IO Exception e ) { Log . e ( TAG , STR_ , e ) ; exception ( e ) ; } List < Review > reviews = Server . reviews ( restaurant ) ; if ( reviews != null ) { boolean has Own = false ; int size = reviews . size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { Review review = reviews . get ( i ) ; vals = Reviews . values ( review ) ; String sel = Reviews . GLOBAL ID + STR_ ; String [ ] args = { String . value Of ( review . global Id ) } ; if ( cr . update ( Reviews . CONTENT URI , vals , sel , args ) == NUM_ ) { review . local Id = Content Uris . parse Id ( cr . insert ( Reviews . CONTENT URI , vals ) ) ; if ( review . local Id > NUM_ && review . user Id == NUM_ ) { has Own = true ; } } } String restaurant Id = String . value Of ( id ) ; cr . call ( AUTHORITY URI , CALL UPDATE RESTAURANT RATING , restaurant Id , null ) ; if ( has Own ) { cr . call ( AUTHORITY URI , CALL UPDATE RESTAURANT LAST VISIT , restaurant Id , null ) ; } } } return result ; }
public Cache Span touch ( ) { long now = System . current Time Millis ( ) ; File new Cache File = get Cache File Name ( file . get Parent File ( ) , key , position , now ) ; file . rename To ( new Cache File ) ; return Cache Span . create Cache Entry ( key , position , now , new Cache File ) ; }
public static Link Properties read ( Data Input dis , Link Properties props ) throws IO Exception { int num Args = dis . read Int ( ) ; if ( num Args == NUM_ ) { return EMPTY PROPERTIES ; } if ( props == null ) { props = new Link Properties ( ) ; } props . read Args ( num Args , dis ) ; return props ; }
public Collection < String > list Snapshots ( String volume Name ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + volume Name ) ; } Volume vol = new Volume ( server . get Na Server ( ) , volume Name ) ; Collection < String > attrs = new Array List < String > ( ) ; attrs . add ( STR_ ) ; return vol . list Snapshots ( attrs ) ; }
public static final float [ ] resize ( float [ ] a , int size ) { if ( a . length >= size ) return a ; float [ ] b = new float [ size ] ; System . arraycopy ( a , NUM_ , b , NUM_ , a . length ) ; return b ; }
public void calculate Sources Sinks Entrypoints ( String source Sink File ) throws IO Exception , Xml Pull Parser Exception { I Source Sink Definition Provider parser = null ; String file Extension = source Sink File . substring ( source Sink File . last Index Of ( STR_ ) ) ; file Extension = file Extension . to Lower Case ( ) ; if ( file Extension . equals ( STR_ ) ) parser = XML Source Sink Parser . from File ( source Sink File ) ; else if ( file Extension . equals ( STR_ ) ) parser = Permission Method Parser . from File ( source Sink File ) ; else throw new Unsupported Data Type Exception ( STR_ ) ; calculate Sources Sinks Entrypoints ( parser ) ; }
private static void s ua Col Sum Eq Ne ( Matrix Block in , Matrix Block out , double [ ] bv , Binary Operator b Op ) throws DML Runtime Exception { int agg 0 = sum Eq Ne ( NUM_ , bv , b Op ) ; out . allocate Dense Block ( true ) ; Arrays . fill ( out . get Dense Block ( ) , NUM_ , out . get Num Columns ( ) , agg 0 ) ; if ( agg 0 != NUM_ ) out . set Non Zeros ( out . get Num Columns ( ) ) ; if ( in . is Empty Block ( false ) ) return ; Sparse Block sblock = in . get Sparse Block ( ) ; for ( int j = NUM_ ; j < sblock . num Rows ( ) ; j ++ ) if ( ! sblock . is Empty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i ++ ) { int cnt = sum Eq Ne ( avals [ i ] , bv , b Op ) ; out . quick Set Value ( NUM_ , aix [ i ] , cnt ) ; } } }
public static Stack Trace Element [ ] approx Source Stack Trace Element ( Bytecode Position bytecode Position ) { Array List < Stack Trace Element > elements = new Array List < > ( ) ; Bytecode Position position = bytecode Position ; while ( position != null ) { Resolved Java Method method = position . get Method ( ) ; if ( method != null ) { elements . add ( method . as Stack Trace Element ( position . get BCI ( ) ) ) ; } position = position . get Caller ( ) ; } return elements . to Array ( new Stack Trace Element [ NUM_ ] ) ; }
public My Sql Ddl Parser ( ) { super ( STR_ ) ; }
private void nuke Symbols ( ) { count = NUM_ ; Arrays . fill ( main Hash , NUM_ ) ; Arrays . fill ( main Names , null ) ; Arrays . fill ( coll List , null ) ; coll Count = NUM_ ; coll End = NUM_ ; }
@ Override protected int size Of ( String key , Bitmap bitmap ) { return get Bitmap Size ( bitmap ) ; }
public synchronized void add ( Integer i ) { value . add ( i ) ; set Value ( value ) ; }
public boolean is Optional ( final Attribute Type attribute Type ) { return is Extensible Object || optional Attributes . contains ( attribute Type ) ; }
private void read Header ( int image Index , boolean reset ) throws IO Exception { goto Image ( image Index ) ; read Native Header ( reset ) ; current Image = image Index ; }
private boolean launch Info Bar If File Exists ( final Download Info info ) { final String file Name = info . get File Name ( ) ; File dir = Environment . get External Storage Public Directory ( Environment . DIRECTORY DOWNLOADS ) ; if ( ! dir . mkdir ( ) && ! dir . is Directory ( ) ) return false ; String dir Name = dir . get Name ( ) ; final File file = new File ( dir , info . get File Name ( ) ) ; String full Dir Path = file . get Parent ( ) ; if ( ! file . exists ( ) ) return false ; if ( Text Utils . is Empty ( file Name ) || Text Utils . is Empty ( dir Name ) || Text Utils . is Empty ( full Dir Path ) ) { return false ; } native Launch Download Overwrite Info Bar ( this , m Tab , info , info . get File Name ( ) , dir Name , full Dir Path ) ; return true ; }
@ Request Mapping ( value = STR_ , method = { Request Method . GET , Request Method . POST } ) public void sso Default Tenant ( Locale locale , Model model , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { logger . info ( STR_ + STR_ + locale . to String ( ) + STR_ ) ; sso ( locale , Shared . get Default Tenant ( ) , model , request , response ) ; }
private void handle Simple Resource ( final String target Uri , final Handler < Resource Node > handler , final Buffer data , final String e Tag ) { String resource Name = Expansion Delta Util . extract Collection From Path ( target Uri ) ; if ( log . is Trace Enabled ( ) ) { log . trace ( STR_ + resource Name ) ; } handler . handle ( new Resource Node ( resource Name , data , e Tag , target Uri ) ) ; }
private int compare Label ( Json Object json Obj 1 , Json Object json Obj 2 ) { String label 1 = get Label ( json Obj 1 ) ; String label 2 = get Label ( json Obj 2 ) ; return label 1 . compare To ( label 2 ) ; }
public void hide Tree Item Control Decoration ( Tree Viewer tree Viewer , Object data ) { if ( null == tree Viewer ) { return ; } for ( Tree Item Control Decoration decoration : tree Item Control Decorations ) { if ( data == decoration . get Data ( ) ) { decoration . hide ( ) ; return ; } } }
@ Override Observed Object create Observed Object ( Object Name object ) { final Gauge Monitor Observed Object gmo = new Gauge Monitor Observed Object ( object ) ; gmo . set Status ( RISING OR FALLING ) ; gmo . set Previous Scan Gauge ( null ) ; return gmo ; }
public Known Arguments Info ( @ Not Null final Collection < Argument > arguments ) { this ( arguments , arguments . size ( ) , arguments . size ( ) ) ; }
public Program Rewriter ( Hop Rewrite Rule rewrite ) { dag Rule Set = new Array List < Hop Rewrite Rule > ( ) ; dag Rule Set . add ( rewrite ) ; sb Rule Set = new Array List < Statement Block Rewrite Rule > ( ) ; }
private void move Staged Events To Dispatch Queue ( ) { synchronized ( m Events Staging Lock ) { synchronized ( m Events To Dispatch Lock ) { for ( int i = NUM_ ; i < m Event Staging . size ( ) ; i ++ ) { Event event = m Event Staging . get ( i ) ; if ( ! event . can Coalesce ( ) ) { add Event To Events To Dispatch ( event ) ; continue ; } long event Cookie = get Event Cookie ( event . get View Tag ( ) , event . get Event Name ( ) , event . get Coalescing Key ( ) ) ; Event event To Add = null ; Event event To Dispose = null ; Integer last Event Idx = m Event Cookie To Last Event Idx . get ( event Cookie ) ; if ( last Event Idx == null ) { event To Add = event ; m Event Cookie To Last Event Idx . put ( event Cookie , m Events To Dispatch Size ) ; } else { Event last Event = m Events To Dispatch [ last Event Idx ] ; Event coalesced Event = event . coalesce ( last Event ) ; if ( coalesced Event != last Event ) { event To Add = coalesced Event ; m Event Cookie To Last Event Idx . put ( event Cookie , m Events To Dispatch Size ) ; event To Dispose = last Event ; m Events To Dispatch [ last Event Idx ] = null ; } else { event To Dispose = event ; } } if ( event To Add != null ) { add Event To Events To Dispatch ( event To Add ) ; } if ( event To Dispose != null ) { event To Dispose . dispose ( ) ; } } } m Event Staging . clear ( ) ; } }
public static final boolean is Logging Behavior Enabled ( Logging Behavior behavior ) { synchronized ( logging Behaviors ) { return Settings . is Debug Enabled ( ) && logging Behaviors . contains ( behavior ) ; } }
public static Collection < Handler > add Java No Op Logger ( ) { Collection < Handler > saved Hnds = new Array List < > ( ) ; Logger log = Logger . get Logger ( STR_ ) ; for ( Handler h : log . get Handlers ( ) ) { log . remove Handler ( h ) ; saved Hnds . add ( h ) ; } Console Handler hnd = new Console Handler ( ) ; hnd . set Level ( Level . OFF ) ; log . add Handler ( hnd ) ; return saved Hnds ; }
public Intent Share add Extra Provider ( @ Non Null Extra Provider extra Provider ) { if ( extra Provider == null ) { throw new Illegal Argument Exception ( STR_ ) ; } else if ( package With Extra Provider . contains ( extra Provider . package Name ) ) { throw new Illegal Argument Exception ( STR_ + extra Provider . package Name ) ; } extra Providers . add ( extra Provider ) ; return this ; }
public void remove Check Box Listener ( Change Listener listener ) { listener List . remove ( Change Listener . class , listener ) ; }
public static void each File Recurse ( final Path self , final File Type file Type , @ Closure Params ( value = Simple Type . class , options = STR_ ) final Closure closure ) throws IO Exception { check Dir ( self ) ; try ( Directory Stream < Path > stream = Files . new Directory Stream ( self ) ) { for ( Path path : stream ) { if ( Files . is Directory ( path ) ) { if ( file Type != File Type . FILES ) closure . call ( path ) ; each File Recurse ( path , file Type , closure ) ; } else if ( file Type != File Type . DIRECTORIES ) { closure . call ( path ) ; } } } }
@ Override public double utility ( double total Weight , double total Positive Weight , Hypothesis hypo ) { double g = hypo . get Covered Weight ( ) / total Weight ; double p = hypo . get Positive Weight ( ) / hypo . get Covered Weight ( ) ; if ( hypo . get Prediction ( ) == Hypothesis . POSITIVE CLASS ) { return Math . sqrt ( g ) * ( p - this . priors [ Hypothesis . POSITIVE CLASS ] ) ; } else { return Math . sqrt ( g ) * ( p - this . priors [ Hypothesis . NEGATIVE CLASS ] ) ; } }
public Brd From Side calc from side ( Shape Tile p shape , Pla Point Int p shape center , int p layer , int p offset , int p cl class ) { Net Nos List empty arr = Net Nos List . EMPTY ; Shape Tile offset shape = p shape . offset ( p offset ) ; for ( int index = NUM_ ; index < offset shape . border line count ( ) ; ++ index ) { Shape Tile check shape = calc check chape for from side ( p shape , p shape center , offset shape . border line ( index ) ) ; if ( r board . check trace ( check shape , p layer , empty arr , p cl class , null ) ) { return new Brd From Side ( index , null ) ; } } for ( int index = NUM_ ; index < offset shape . border line count ( ) ; ++ index ) { Shape Tile check shape = calc check chape for from side ( p shape , p shape center , offset shape . border line ( index ) ) ; if ( r board . check trace ( check shape , p layer , empty arr , NUM_ , null ) ) { return new Brd From Side ( index , null ) ; } } return Brd From Side . NOT CALCULATED ; }
private void create And Send Message ( Client Membership Event event , int type ) { Internal Distributed System ds = null ; Cache cache Instance = Abstract Cache Server . this . cache ; if ( cache Instance != null && ! ( cache Instance instanceof Cache Creation ) ) { ds = ( Internal Distributed System ) cache Instance . get Distributed System ( ) ; } else { ds = Internal Distributed System . get Any Instance ( ) ; } if ( ds != null && ds . is Connected ( ) ) { DM dm = ds . get Distribution Manager ( ) ; Set admin Member Set = dm . get Admin Member Set ( ) ; if ( ! admin Member Set . is Empty ( ) ) { Distributed Member member = event . get Member ( ) ; Client Membership Message msg = new Client Membership Message ( event . get Member Id ( ) , member == null ? null : member . get Host ( ) , type ) ; msg . set Recipients ( admin Member Set ) ; dm . put Outgoing ( msg ) ; } } }
public void fill Minified ( final Map < String , Object > data Model ) { switch ( Latkes . get Runtime Mode ( ) ) { case DEVELOPMENT : data Model . put ( Common . MINI POSTFIX , STR_ ) ; break ; case PRODUCTION : data Model . put ( Common . MINI POSTFIX , Common . MINI POSTFIX VALUE ) ; break ; default : throw new Assertion Error ( ) ; } }
protected void paint Horizontal Label ( Graphics g , int value , Component label ) { int label Center = x Position For Value ( value ) ; int label Left = label Center - ( label . get Preferred Size ( ) . width / NUM_ ) ; g . translate ( label Left , NUM_ ) ; label . paint ( g ) ; g . translate ( - label Left , NUM_ ) ; }
protected File ensure Directory Exists ( final Logger default Log , final Logger shop Log , final File shop Dir , final Shop shop , final String dirname ) throws IO Exception { final File dir = new File ( shop Dir , dirname ) ; if ( ! dir . exists ( ) ) { default Log . info ( STR_ , dir . get Absolute Path ( ) , shop . get Code ( ) ) ; shop Log . info ( STR_ , dir . get Absolute Path ( ) , shop . get Code ( ) ) ; if ( ! dir . mkdirs ( ) ) { throw new IO Exception ( STR_ + dir . get Absolute Path ( ) + STR_ + shop . get Code ( ) ) ; } } return dir ; }
public void clean Domain Map ( String canon Org DN ) { synchronized ( canonical Domain Map ) { canonical Domain Map . remove ( canon Org DN ) ; } synchronized ( domain Map ) { domain Map . remove ( canon Org DN ) ; } }
private void create Info Window ( ) { info Window = new J Window ( Swing Utilities . get Window Ancestor ( text Field ) ) ; info Label = new J Label ( ) ; info Window . add ( info Label ) ; J Panel content Pane = ( J Panel ) info Window . get Content Pane ( ) ; Border border = Border Factory . create Compound Border ( Border Factory . create Line Border ( Color . GRAY ) , Border Factory . create Empty Border ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; content Pane . set Border ( border ) ; content Pane . set Background ( Html Colors . decode ( STR_ ) ) ; info Label . set Font ( text Field . get Font ( ) ) ; containing Window = Swing Utilities . get Window Ancestor ( text Field ) ; if ( containing Window != null ) { containing Window . add Component Listener ( component Listener ) ; } text Field . add Component Listener ( component Listener ) ; }
public static void unregister M Bean ( String name ) throws Exception { Object Name mbean Object Name = MBEANS . remove ( name ) ; if ( mbean Object Name != null ) { M Bean Server mbean Server = Management Factory . get Platform M Bean Server ( ) ; mbean Server . unregister M Bean ( mbean Object Name ) ; } }
protected void draw Path ( General Path path , Color fill Color , Paint fill Paint , Color pen Color , boolean shadow ) { if ( fill Color != null || fill Paint != null ) { if ( shadow ) { g . set Color ( mx Constants . SHADOW COLOR ) ; g . translate ( mx Constants . SHADOW OFFSETX , mx Constants . SHADOW OFFSETY ) ; g . fill ( path ) ; g . translate ( - mx Constants . SHADOW OFFSETX , - mx Constants . SHADOW OFFSETY ) ; } if ( fill Paint != null ) { g . set Paint ( fill Paint ) ; } else { g . set Color ( fill Color ) ; } g . fill ( path ) ; } if ( pen Color != null ) { g . set Color ( pen Color ) ; g . draw ( path ) ; } }
public static Explanation no Match ( String description , Explanation ... details ) { return new Explanation ( false , NUM_ , description , Arrays . as List ( details ) ) ; }
public static Zip Output Stream create Zip Output Stream ( String file Path , String zip Entry Name ) throws IO Exception { Output Stream os = new File Output Stream ( file Path ) ; Zip Output Stream zos = new Zip Output Stream ( new Buffered Output Stream ( os ) ) ; Zip Entry entry = new Zip Entry ( zip Entry Name ) ; zos . put Next Entry ( entry ) ; return zos ; }
public double max ( ) { double max Val = this . vector [ NUM_ ] ; for ( final double val : this . vector ) { max Val = Math . max ( max Val , val ) ; } return max Val ; }
public static Byte Buffer read File ( File file ) throws IO Exception { File Input Stream fis = new File Input Stream ( file ) ; File Channel fc = fis . get Channel ( ) ; Byte Buffer read Buffer = Byte Buffer . allocate ( ( int ) fc . size ( ) ) ; fc . read ( read Buffer ) ; fis . close ( ) ; read Buffer . rewind ( ) ; return read Buffer ; }
private String generate Fitting Text ( Method Usage method , Rectangle 2 D rect , Font Metrics font Metrics ) { if ( rect . get Width ( ) < font Metrics . string Width ( STR_ ) ) { return STR_ ; } String fully Qualified = method . get Name Space ( ) + STR_ + method . get Name ( ) ; if ( font Metrics . string Width ( fully Qualified ) < rect . get Width ( ) ) { return fully Qualified ; } String abbrev Package = get Short Package Name ( method . get Name Space ( ) ) + STR_ + method . get Name ( ) ; if ( font Metrics . string Width ( abbrev Package ) < rect . get Width ( ) ) { return abbrev Package ; } if ( font Metrics . string Width ( method . get Name ( ) ) < rect . get Width ( ) ) { return method . get Name ( ) ; } return STR_ ; }
public static void main ( String [ ] args ) { Log . print Line ( STR_ ) ; try { int num user = NUM_ ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = false ; Cloud Sim . init ( num user , calendar , trace flag ) ; Container Allocation Policy container Allocation Policy = new Power Container Allocation Policy Simple ( ) ; Power Container Vm Selection Policy vm Selection Policy = new Power Container Vm Selection Policy Maximum Usage ( ) ; Host Selection Policy host Selection Policy = new Host Selection Policy First Fit ( ) ; double over Utilization Threshold = NUM_ ; double under Utilization Threshold = NUM_ ; host List = new Array List < Container Host > ( ) ; host List = create Host List ( Constants Examples . NUMBER HOSTS ) ; cloudlet List = new Array List < Container Cloudlet > ( ) ; vm List = new Array List < Container Vm > ( ) ; Container Vm Allocation Policy vm Allocation Policy = new Power Container Vm Allocation Policy Migration Abstract Host Selection ( host List , vm Selection Policy , host Selection Policy , over Utilization Threshold , under Utilization Threshold ) ; int over Booking Factor = NUM_ ; Container Datacenter Broker broker = create Broker ( over Booking Factor ) ; int broker Id = broker . get Id ( ) ; cloudlet List = create Container Cloudlet List ( broker Id , Constants Examples . NUMBER CLOUDLETS ) ; container List = create Container List ( broker Id , Constants Examples . NUMBER CLOUDLETS ) ; vm List = create Vm List ( broker Id , Constants Examples . NUMBER VMS ) ; String log Address = STR_ ; @ Suppress Warnings ( STR_ ) Power Container Datacenter e = ( Power Container Datacenter ) create Datacenter ( STR_ , Power Container Datacenter CM . class , host List , vm Allocation Policy , container Allocation Policy , get Experiment Name ( STR_ , String . value Of ( over Booking Factor ) ) , Constants Examples . SCHEDULING INTERVAL , log Address , Constants Examples . VM STARTTUP DELAY , Constants Examples . CONTAINER STARTTUP DELAY ) ; broker . submit Cloudlet List ( cloudlet List . sub List ( NUM_ , container List . size ( ) ) ) ; broker . submit Container List ( container List ) ; broker . submit Vm List ( vm List ) ; Cloud Sim . terminate Simulation ( NUM_ ) ; Cloud Sim . start Simulation ( ) ; Cloud Sim . stop Simulation ( ) ; List < Container Cloudlet > new List = broker . get Cloudlet Received List ( ) ; print Cloudlet List ( new List ) ; Log . print Line ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STR_ ) ; } }
public static boolean are Conditions Met ( final List < I Condition > rules To Test , final Hash Map < I Condition , Boolean > tested Conditions , final String condition Type ) { boolean met = false ; if ( condition Type . equals ( STR_ ) ) { for ( final I Condition c : rules To Test ) { met = tested Conditions . get ( c ) ; if ( ! met ) { break ; } } } else if ( condition Type . equals ( STR_ ) ) { for ( final I Condition c : rules To Test ) { met = tested Conditions . get ( c ) ; if ( met ) { break ; } } } else { final String [ ] nums = condition Type . split ( STR_ ) ; if ( nums . length == NUM_ ) { final int start = Integer . parse Int ( nums [ NUM_ ] ) ; int count = NUM_ ; for ( final I Condition c : rules To Test ) { met = tested Conditions . get ( c ) ; if ( met ) { count ++ ; } } met = ( count == start ) ; } else if ( nums . length == NUM_ ) { final int start = Integer . parse Int ( nums [ NUM_ ] ) ; final int end = Integer . parse Int ( nums [ NUM_ ] ) ; int count = NUM_ ; for ( final I Condition c : rules To Test ) { met = tested Conditions . get ( c ) ; if ( met ) { count ++ ; } } met = ( count >= start && count <= end ) ; } } return met ; }
@ Override public final K acquire ( ) { K ctx = null ; Reference < K > ref = null ; while ( ( ctx == null ) && ( ( ref = ctx Queue . poll ( ) ) != null ) ) { ctx = ref . get ( ) ; } if ( ctx == null ) { ctx = new Context ( ) ; ctx . usage = USAGE CLQ ; } return ctx ; }
private String create Start Choice Moment Xml ( String moment Id , double timeout Length Minutes , String choice Description , String default Choice Id ) { String xml = STR_ ; xml += create Start Moment Xml ( STR_ , moment Id ) ; xml += STR_ + Double . to String ( timeout Length Minutes ) + STR_ ; xml += STR_ + choice Description + STR_ ; xml += STR_ + default Choice Id + STR_ ; return xml ; }
private Cluster < Dendrogram Model > to Cluster ( Clustering < Dendrogram Model > clustering , DBID Ref lead ) { final String name ; if ( children . size ( ) > NUM_ ) { name = STR_ + DBID Util . to String ( lead ) + STR_ + depth ; } else if ( newids . size ( ) == NUM_ ) { name = STR_ + DBID Util . to String ( lead ) ; } else if ( ! Double . is Na N ( depth ) ) { name = STR_ + DBID Util . to String ( lead ) + STR_ + depth ; } else { name = STR_ + DBID Util . to String ( lead ) ; } Cluster < Dendrogram Model > cluster = new Cluster < > ( name , DBID Util . new Array ( newids ) , new Dendrogram Model ( depth ) ) ; for ( Cluster < Dendrogram Model > child : children ) { clustering . add Child Cluster ( cluster , child ) ; } newids . clear ( ) ; children . clear ( ) ; return cluster ; }
static protected boolean log Warning ( String name , String s , Throwable t ) { return log Std Err ( STR_ , name , s , t ) ; }
public long [ ] [ ] initialize Hash Functions ( ) { int number Of Hash Functions ; int big Prime Int = ( int ) big Prime ; number Of Hash Functions = ( int ) Math . floor ( Math . log ( NUM_ ) * bit Set . length ( ) / expected Number Of Objects ) ; if ( number Of Hash Functions == NUM_ ) number Of Hash Functions = NUM_ ; long [ ] [ ] hash Functions = new long [ number Of Hash Functions ] [ NUM_ ] ; for ( long [ ] h : hash Functions ) { h [ NUM_ ] = ( long ) RANDOM . next Int ( big Prime Int ) + NUM_ ; h [ NUM_ ] = ( long ) RANDOM . next Int ( big Prime Int ) + NUM_ ; } return hash Functions ; }
public void remove Update Listener ( Animator Update Listener listener ) { if ( m Update Listeners == null ) { return ; } m Update Listeners . remove ( listener ) ; if ( m Update Listeners . size ( ) == NUM_ ) { m Update Listeners = null ; } }
@ Override public Polynomial Function Newton Form interpolate ( double x [ ] , double y [ ] ) throws Math Illegal Argument Exception { Polynomial Function Lagrange Form . verify Interpolation Array ( x , y , true ) ; final double [ ] c = new double [ x . length - NUM_ ] ; System . arraycopy ( x , NUM_ , c , NUM_ , c . length ) ; final double [ ] a = compute Divided Difference ( x , y ) ; return new Polynomial Function Newton Form ( a , c ) ; }
public JC Diagnostic fragment ( String key , Object ... args ) { return create ( FRAGMENT , null , Enum Set . none Of ( Diagnostic Flag . class ) , null , null , key , args ) ; }
private void process Worker Exit ( Worker w , boolean completed Abruptly ) { if ( completed Abruptly ) decrement Worker Count ( ) ; final Reentrant Lock main Lock = this . main Lock ; main Lock . lock ( ) ; try { completed Task Count += w . completed Tasks ; workers . remove ( w ) ; } finally { main Lock . unlock ( ) ; } try Terminate 2 ( ) ; if ( ! completed Abruptly ) { int min = allow Core Thread Time Out ? NUM_ : core Pool Size ; if ( min == NUM_ && ! work Queue . is Empty ( ) ) min = NUM_ ; int c = ctl . get ( ) ; if ( worker Count Of ( c ) >= min || run State Of ( c ) >= STOP ) return ; } add Worker ( null , false ) ; }
private void draw Magnify Mask ( Graphics 2 D g ) { double view Width = viewport . get Width In View ( ) ; double view Height = viewport . get Height In View ( ) ; float min Extent = ( float ) Math . min ( view Width , view Height ) ; float mask Width = ( float ) ( min Extent * App Constants . MASK WIDTH FRAC / NUM_ ) ; Area mask = new Area ( new Rectangle 2 D . Float ( ( float ) NUM_ , ( float ) NUM_ , ( float ) view Width , ( float ) view Height ) ) ; Area mask Hole = new Area ( new Rectangle 2 D . Float ( ( float ) mask Width , ( float ) mask Width , ( ( float ) view Width ) - NUM_ * mask Width , ( ( float ) view Height ) - NUM_ * mask Width ) ) ; mask . subtract ( mask Hole ) ; g . set Color ( App Constants . MASK CLR ) ; g . fill ( mask ) ; }
public static Object [ ] ordinal Array ( Tuple Set tuples , String field ) { return ordinal Array ( tuples , field , Default Literal Comparator . get Instance ( ) ) ; }
public synchronized Class define Class ( String name , byte [ ] bytecode , Protection Domain domain ) { in Define = true ; Class c = define Class ( name , bytecode , NUM_ , bytecode . length , domain ) ; loaded Classes . put ( name , c ) ; resolve Class ( c ) ; in Define = false ; return c ; }
public void clear ( ) { items . clear ( ) ; Iterator siter = springs . iterator ( ) ; Spring . Spring Factory f = Spring . get Factory ( ) ; while ( siter . has Next ( ) ) f . reclaim ( ( Spring ) siter . next ( ) ) ; springs . clear ( ) ; }
public Region Version Vector ( T owner Id ) { this ( owner Id , null ) ; }
protected void create Renderers ( Combined Chart chart , Chart Animator animator , View Port Handler view Port Handler ) { m Renderers = new Array List < Data Renderer > ( ) ; Draw Order [ ] orders = chart . get Draw Order ( ) ; for ( Draw Order order : orders ) { switch ( order ) { case BAR : if ( chart . get Bar Data ( ) != null ) m Renderers . add ( new Bar Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case BUBBLE : if ( chart . get Bubble Data ( ) != null ) m Renderers . add ( new Bubble Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case LINE : if ( chart . get Line Data ( ) != null ) m Renderers . add ( new Line Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case CANDLE : if ( chart . get Candle Data ( ) != null ) m Renderers . add ( new Candle Stick Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case SCATTER : if ( chart . get Scatter Data ( ) != null ) m Renderers . add ( new Scatter Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; } } }
private void show Popup Menu ( final Mouse Event event ) { final int [ ] rows = m event Table . get Converted Selected Rows ( ) ; final List < I Trace Event > traces = get Traces ( rows ) ; final C Event Table Menu menu = new C Event Table Menu ( m event Table , m model , traces ) ; menu . show ( m event Table , event . get X ( ) , event . get Y ( ) ) ; }
public static Active Requestor Exception new Receiver Exception ( Throwable throwable ) { return new Active Requestor Exception ( SOAP Constants . SOAP RECEIVER FAULT , STR_ , throwable . get Message ( ) ) ; }
public byte [ ] to Byte Array ( ) { try { Byte Array Output Stream array = new Byte Array Output Stream ( ) ; Data Output Stream out = new Data Output Stream ( array ) ; out . write Short ( width ) ; out . write Short ( height ) ; out . write Byte ( palette . length ) ; int plen = palette . length ; for ( int iter = NUM_ ; iter < plen ; iter ++ ) { out . write Int ( palette [ iter ] ) ; } out . write ( image Data Byte ) ; out . close ( ) ; return array . to Byte Array ( ) ; } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; return null ; } }
protected Metric reduce ( List < Metric > metrics ) { System Assert . require Argument ( metrics != null , STR_ ) ; Metric Distiller distiller = new Metric Distiller ( ) ; distiller . distill ( metrics ) ; Map < Long , List < String > > collated = collate ( metrics ) ; Map < Long , String > min Datapoints = reduce ( collated , metrics ) ; String new Metric Name = distiller . get Metric ( ) == null ? default Metric Name : distiller . get Metric ( ) ; Metric new Metric = new Metric ( default Scope , new Metric Name ) ; new Metric . set Display Name ( distiller . get Display Name ( ) ) ; new Metric . set Units ( distiller . get Units ( ) ) ; new Metric . set Tags ( distiller . get Tags ( ) ) ; new Metric . set Datapoints ( min Datapoints ) ; return new Metric ; }
public static Executor Service Closer of ( Executor Service executor Service ) { return new Executor Service Closer ( executor Service , Optional . empty ( ) ) ; }
public static void audit File ( Db Client db Client , Operation Type Enum audit Type , boolean operational Status , String description , Object ... descparams ) { Audit Log Manager audit Mgr = Audit Log Manager Factory . get Audit Log Manager ( ) ; audit Mgr . set Db Client ( db Client ) ; audit Mgr . record Audit Log ( null , null , EVENT SERVICE TYPE , audit Type , System . current Time Millis ( ) , operational Status ? Audit Log Manager . AUDITLOG SUCCESS : Audit Log Manager . AUDITLOG FAILURE , description , descparams ) ; }
public void start ( ) throws JMS Exception { synchronized ( this ) { ensure Open ( ) ; set Modified ( ) ; try { if ( stopped ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + to String ( ) ) ; } for ( int i = NUM_ ; i < sessions . size ( ) ; i ++ ) { GS Session Impl session = ( GS Session Impl ) sessions . get ( i ) ; session . start ( ) ; } stopped = false ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + to String ( ) ) ; } } } catch ( JMS Exception exception ) { throw exception ; } } }
public static double quantile ( double p , double k , double theta , double shift ) { return Math . log ( Gamma Distribution . quantile ( p , k , theta ) ) + shift ; }
private static String definition List To Html ( Definition List dl ) { if ( dl == null ) { return STR_ ; } String Builder result = new String Builder ( ) ; result . append ( STR_ + STR_ + STR_ ) ; if ( dl . get Defined Term ( ) != null ) { result . append ( content Element To Html ( dl . get Defined Term ( ) ) + STR_ ) ; } result . append ( STR_ ) ; for ( Content Element ce : dl . get Definitions ( ) ) { result . append ( STR_ + content Element To Html ( ce ) + STR_ ) ; } result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; return result . to String ( ) ; }
public static final int binary Search ( Object [ ] a , Object key , Comparator cp , int length ) { int x 1 = NUM_ ; int x 2 = length ; int i = x 2 / NUM_ , c ; while ( x 1 < x 2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == NUM_ ) { return i ; } else if ( c < NUM_ ) { x 1 = i + NUM_ ; } else { x 2 = i ; } i = x 1 + ( x 2 - x 1 ) / NUM_ ; } return - NUM_ * ( i + NUM_ ) ; }
public void pan And Zoom ( int min X , int min Y , int max X , int max Y ) { float curr Zoom = map Controller . get Zoom ( ) ; Lng Lat tl = Util . normalize Lng Lat ( map Controller . coordinates At Screen Position ( NUM_ , NUM_ ) ) ; Lng Lat br = Util . normalize Lng Lat ( map Controller . coordinates At Screen Position ( window Width , window Height ) ) ; int from Min X = Area Panel . convert Lon To X ( tl . longitude ) ; int from Min Y = Area Panel . convert Lat To Y ( tl . latitude ) ; int from Max X = Area Panel . convert Lon To X ( br . longitude ) ; int from Max Y = Area Panel . convert Lat To Y ( br . latitude ) ; max Y = ( int ) ( ( ( float ) max Y - min Y ) * window Height / point Area Height ) + min Y ; float zoom Multiplier = Math . min ( ( ( float ) from Max X - from Min X ) / ( max X - min X ) , ( ( float ) from Max Y - from Min Y ) / ( max Y - min Y ) ) ; float new Zoom = ( float ) ( curr Zoom + Math . log ( zoom Multiplier ) / Math . log ( NUM_ ) ) ; Lng Lat new Pos = new Lng Lat ( Area Panel . convert X To Lon ( ( max X - min X ) / NUM_ + min X ) , Area Panel . convert Y To Lat ( ( max Y - min Y ) / NUM_ + min Y ) ) ; map Controller . set Position Eased ( new Pos , AUTOZOOM PAN EASE MS ) ; map Controller . set Zoom Eased ( new Zoom , AUTOZOOM ZOOM EASE MS ) ; notify Screen Moved ( ) ; }
public static String sanitize Method Name ( String method Name ) { assert ( method Name != null && method Name . length ( ) > NUM_ ) ; String Builder sb = new String Builder ( ) ; char first Char = method Name . char At ( NUM_ ) ; if ( Character . is Java Identifier Start ( first Char ) ) { if ( Character . is Upper Case ( first Char ) ) { first Char = Character . to Lower Case ( first Char ) ; } sb . append ( first Char ) ; } boolean previous Char Was Dropped = false ; for ( int i = NUM_ ; i < method Name . length ( ) ; i ++ ) { char ch = method Name . char At ( i ) ; if ( Character . is Letter Or Digit ( ch ) ) { if ( previous Char Was Dropped ) { ch = Character . to Upper Case ( ch ) ; } sb . append ( ch ) ; previous Char Was Dropped = false ; } else { previous Char Was Dropped = true ; } } if ( sb . length ( ) == NUM_ ) { sb . append ( STR_ ) ; } return sb . to String ( ) ; }
static private String LONG Min ( ) { long temp Value = Long . MIN VALUE ; return String . value Of ( temp Value ) ; }
public void reset ( ) { start Time ns = System . nano Time ( ) ; total Pkt Cnt = NUM_ ; total Proc Time Ns = NUM_ ; avg Total Proc Time Ns = NUM_ ; sum Squared Proc Time Ns 2 = NUM_ ; max Total Proc Time Ns = Long . MIN VALUE ; min Total Proc Time Ns = Long . MAX VALUE ; sigma Total Proc Time Ns = NUM_ ; for ( One Component Time oct : comp Stats . values ( ) ) { oct . reset All Counters ( ) ; } }
private Set < Cluster Node > replicated Unstable Data Nodes ( Grid Cache Context < ? , ? > cctx ) { assert cctx . is Replicated ( ) : cctx . name ( ) + STR_ ; String space = cctx . name ( ) ; Set < Cluster Node > data Nodes = new Hash Set < > ( data Nodes ( space , NONE ) ) ; if ( data Nodes . is Empty ( ) ) throw new Cache Exception ( STR_ + space ) ; for ( int p = NUM_ , parts = cctx . affinity ( ) . partitions ( ) ; p < parts ; p ++ ) { List < Cluster Node > owners = cctx . topology ( ) . owners ( p ) ; if ( F . is Empty ( owners ) ) return null ; data Nodes . retain All ( owners ) ; if ( data Nodes . is Empty ( ) ) return null ; } return data Nodes ; }
public void receive ( boolean bit 1 , boolean bit 2 ) { m Bits = Long . rotate Left ( m Bits , NUM_ ) ; m Bits &= m Mask ; if ( bit 1 ) { m Bits += NUM_ ; } m Bits = Long . rotate Left ( m Bits , NUM_ ) ; m Bits &= m Mask ; if ( bit 2 ) { m Bits += NUM_ ; } for ( I Sync Processor processor : m Sync Processors ) { processor . check Sync ( m Bits ) ; } }
public Properties add Genome ( String genome ) { if ( m Genomes . add ( genome ) ) { m Genome Properties . put ( genome , new Properties ( ) ) ; } return m Genome Properties . get ( genome ) ; }
private void update VMAX 3 Auto Tiering Policy ( Storage System storage , List < URI > volume UR Is , Virtual Pool new Virtual Pool , boolean rollback , Task Completer task Completer ) throws Exception { log . info ( STR_ ) ; String new Policy Name = Controller Utils . get Fast Policy Name From Virtual Pool ( db Client , storage , new Virtual Pool ) ; if ( null == new Policy Name ) { new Policy Name = Constants . NONE ; } Set < String > volume Device Ids = new Hash Set < String > ( ) ; String fast Setting = null ; for ( URI vol URI : volume UR Is ) { Volume volume = db Client . query Object ( Volume . class , vol URI ) ; volume Device Ids . add ( volume . get Native Id ( ) ) ; if ( null == fast Setting ) { fast Setting = helper . get VMAX 3 Fast Setting For Volume ( vol URI , new Policy Name ) ; } boolean force Flag = Export Utils . use EMC Force Flag ( db Client , vol URI ) ; helper . remove Volume From Parking SLO Storage Group ( storage , volume . get Native Id ( ) , force Flag ) ; } add Volumes To Parking Storage Group ( storage , fast Setting , volume Device Ids ) ; }
public static void main ( String [ ] args ) { Log . print Line ( STR_ ) ; try { int num user = NUM_ ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = false ; Cloud Sim . init ( num user , calendar , trace flag ) ; Datacenter datacenter 0 = create Datacenter ( STR_ ) ; Datacenter datacenter 1 = create Datacenter ( STR_ ) ; Datacenter Broker broker 1 = create Broker ( NUM_ ) ; int broker Id 1 = broker 1 . get Id ( ) ; Datacenter Broker broker 2 = create Broker ( NUM_ ) ; int broker Id 2 = broker 2 . get Id ( ) ; vmlist 1 = new Array List < Vm > ( ) ; vmlist 2 = new Array List < Vm > ( ) ; int vmid = NUM_ ; long size = NUM_ ; int mips = NUM_ ; int ram = NUM_ ; long bw = NUM_ ; int pes Number = NUM_ ; String vmm = STR_ ; Vm vm 1 = new Vm ( vmid , broker Id 1 , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; Vm vm 2 = new Vm ( vmid , broker Id 2 , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmlist 1 . add ( vm 1 ) ; vmlist 2 . add ( vm 2 ) ; broker 1 . submit Vm List ( vmlist 1 ) ; broker 2 . submit Vm List ( vmlist 2 ) ; cloudlet List 1 = new Array List < Cloudlet > ( ) ; cloudlet List 2 = new Array List < Cloudlet > ( ) ; int id = NUM_ ; long length = NUM_ ; long file Size = NUM_ ; long output Size = NUM_ ; Utilization Model utilization Model = new Utilization Model Full ( ) ; Cloudlet cloudlet 1 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 1 . set User Id ( broker Id 1 ) ; Cloudlet cloudlet 2 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 2 . set User Id ( broker Id 2 ) ; cloudlet List 1 . add ( cloudlet 1 ) ; cloudlet List 2 . add ( cloudlet 2 ) ; broker 1 . submit Cloudlet List ( cloudlet List 1 ) ; broker 2 . submit Cloudlet List ( cloudlet List 2 ) ; Network Topology . build Network Topology ( STR_ ) ; int brite Node = NUM_ ; Network Topology . map Node ( datacenter 0 . get Id ( ) , brite Node ) ; brite Node = NUM_ ; Network Topology . map Node ( datacenter 1 . get Id ( ) , brite Node ) ; brite Node = NUM_ ; Network Topology . map Node ( broker 1 . get Id ( ) , brite Node ) ; brite Node = NUM_ ; Network Topology . map Node ( broker 2 . get Id ( ) , brite Node ) ; Cloud Sim . start Simulation ( ) ; List < Cloudlet > new List 1 = broker 1 . get Cloudlet Received List ( ) ; List < Cloudlet > new List 2 = broker 2 . get Cloudlet Received List ( ) ; Cloud Sim . stop Simulation ( ) ; Log . print ( STR_ + broker Id 1 + STR_ ) ; print Cloudlet List ( new List 1 ) ; Log . print ( STR_ + broker Id 2 + STR_ ) ; print Cloudlet List ( new List 2 ) ; Log . print Line ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STR_ ) ; } }
protected double variance ( double [ ] s , double [ ] s S , double [ ] sum Of Weights ) { double var = NUM_ ; for ( int i = NUM_ ; i < s . length ; i ++ ) { if ( sum Of Weights [ i ] > NUM_ ) { var += single Variance ( s [ i ] , s S [ i ] , sum Of Weights [ i ] ) ; } } return var ; }
public String put ( String key , String value , boolean percent Encode ) { Sorted Set < String > values = wrapped Map . get ( key ) ; if ( values == null ) { values = new Tree Set < String > ( ) ; wrapped Map . put ( percent Encode ? O Auth . percent Encode ( key ) : key , values ) ; } if ( value != null ) { value = percent Encode ? O Auth . percent Encode ( value ) : value ; values . add ( value ) ; } return value ; }
void draw Divider ( Canvas canvas , Rect bounds , int child Index ) { final Drawable divider = m Divider ; final boolean clip Divider = m Clip Divider ; if ( ! clip Divider ) { divider . set Bounds ( bounds ) ; } else { canvas . save ( ) ; canvas . clip Rect ( bounds ) ; } divider . draw ( canvas ) ; if ( clip Divider ) { canvas . restore ( ) ; } }
void write ( Image Output Stream ios ) throws IO Exception { length = NUM_ ; write Tag ( ios ) ; byte [ ] id = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; ios . write ( id ) ; write 2 bytes ( ios , version ) ; write 2 bytes ( ios , flags 0 ) ; write 2 bytes ( ios , flags 1 ) ; ios . write ( transform ) ; }
private Chart Span < Integer > calculate All Pairs Shortest Path ( ) { Chart Span < Integer > distance = new Chart Span < > ( nodes . size ( ) - NUM_ , Integer . MAX VALUE ) ; distance . set Diagonal ( NUM_ ) ; for ( Node < Value > tail : nodes ) { for ( Arc < Value > arc : tail . get Outgoing Arcs ( ) ) { Node < Value > head = arc . get Head ( ) ; distance . set ( tail . id ( ) , head . id ( ) , NUM_ ) ; } } int size = nodes . size ( ) ; for ( int width = NUM_ ; width <= size ; width ++ ) { for ( int i = NUM_ ; i < size - width ; i ++ ) { int j = i + width ; for ( int k = i + NUM_ ; k < j ; k ++ ) { distance . set ( i , j , Math . min ( distance . get ( i , j ) , distance . get ( i , k ) + distance . get ( k , j ) ) ) ; } } } return distance ; }
public void queue Hint ( String store Name , Byte Array key , Versioned < byte [ ] > value ) { try { Hint Key hk = new Hint Key ( store Name , key ) ; hint Lock . lock ( ) ; try { boolean needed = ! hints . contains Key ( hk ) ; needed &= hints . doput ( hk , value ) ; if ( needed ) { hint Queue . add ( hk ) ; hints Available . signal ( ) ; } } finally { hint Lock . unlock ( ) ; } } catch ( Sync Exception e ) { logger . error ( STR_ + store Name , e ) ; } }
private int convert Surrogate ( int second Part ) throws IO Exception { int first Part = surrogate ; surrogate = NUM_ ; if ( second Part < SURR 2 FIRST || second Part > SURR 2 LAST ) { throw new IO Exception ( STR_ + Integer . to Hex String ( first Part ) + STR_ + Integer . to Hex String ( second Part ) + STR_ ) ; } return NUM_ + ( ( first Part - SURR 1 FIRST ) << NUM_ ) + ( second Part - SURR 2 FIRST ) ; }
protected void cache Ct Class ( String classname , Ct Class c , boolean dynamic ) { classes . put ( classname , c ) ; }
public void add Game Listener ( Game Listener listener ) { if ( game Listeners == null ) { game Listeners = new Vector < Game Listener > ( ) ; } game Listeners . add Element ( listener ) ; }
public boolean is Undefined ( ) { return ( lat == NUM_ && lng == NUM_ ) || lat < - NUM_ || lat > NUM_ || lng < - NUM_ || lng > NUM_ || Double . is Na N ( lat ) || Double . is Na N ( lng ) ; }
public static Element make Style Element ( Document document ) { Element style = SVG Util . svg Element ( document , SVG Constants . SVG STYLE TAG ) ; style . set Attribute ( SVG Constants . SVG TYPE ATTRIBUTE , SVG Constants . CSS MIME TYPE ) ; return style ; }
public void add Patch Resource ( Resource resource ) { resources . add ( resource ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Statistical Line And Shape Renderer ) ) { return false ; } Statistical Line And Shape Renderer that = ( Statistical Line And Shape Renderer ) obj ; if ( ! Paint Utilities . equal ( this . error Indicator Paint , that . error Indicator Paint ) ) { return false ; } if ( ! Object Utilities . equal ( this . error Indicator Stroke , that . error Indicator Stroke ) ) { return false ; } return super . equals ( obj ) ; }
public void add Hyperedges In Node ( List < Hyper Edge > hyperedges ) { hyperedges . for Each ( null ) ; }
public Big Integer calculate Fee ( Wallet wallet ) { Big Integer total Out = Big Integer . ZERO ; Big Integer total In = Big Integer . ZERO ; for ( Transaction Input input : get Inputs ( ) ) { Transaction Output connected = input . get Connected Output ( wallet . unspent ) ; if ( connected == null ) connected = input . get Connected Output ( wallet . spent ) ; if ( connected == null ) connected = input . get Connected Output ( wallet . pending ) ; if ( connected == null ) continue ; total In = total In . add ( connected . get Value ( ) ) ; } List < Transaction Output > outputs = get Outputs ( ) ; for ( Transaction Output output : outputs ) { total Out = total Out . add ( output . get Value ( ) ) ; } return total In . subtract ( total Out ) ; }
public static String find Common Prefix ( String ... strings ) { String Builder prefix = new String Builder ( ) ; int index = NUM_ ; char c = NUM_ ; loop : while ( true ) { for ( int i = NUM_ ; i < strings . length ; i ++ ) { String s = strings [ i ] ; if ( index == s . length ( ) ) { break loop ; } if ( i == NUM_ ) { c = s . char At ( index ) ; } else { if ( s . char At ( index ) != c ) { break loop ; } } } index ++ ; prefix . append ( c ) ; } return prefix . length ( ) == NUM_ ? String Pool . EMPTY : prefix . to String ( ) ; }
public static void mark Text ( J Text Component pane , int start , int end , Simple Marker marker ) { try { Highlighter hiliter = pane . get Highlighter ( ) ; int sel Start = pane . get Selection Start ( ) ; int sel End = pane . get Selection End ( ) ; if ( sel Start == sel End || end < sel Start || start > sel Start ) { hiliter . add Highlight ( start , end , marker ) ; return ; } if ( sel Start > start && sel Start < end ) { hiliter . add Highlight ( start , sel Start , marker ) ; } if ( sel End > start && sel End < end ) { hiliter . add Highlight ( sel End , end , marker ) ; } } catch ( Bad Location Exception ex ) { LOG . log ( Level . SEVERE , null , ex ) ; } }
public boolean is Static ( ) { return Modifier . is Static ( modifier ) ; }
void load Event Days In Background ( int start Day , int num Days , boolean [ ] event Days , final Runnable ui Callback ) { Load Event Days Request request = new Load Event Days Request ( start Day , num Days , event Days , ui Callback ) ; try { m Loader Queue . put ( request ) ; } catch ( Interrupted Exception ex ) { Log . e ( STR_ , STR_ ) ; } }
protected String meta Option ( ) { return STR_ + STR_ ; }
private byte [ ] create Preview Buffer ( Size preview Size ) { int bits Per Pixel = Image Format . get Bits Per Pixel ( Image Format . NV 21 ) ; long size In Bits = preview Size . get Height ( ) * preview Size . get Width ( ) * bits Per Pixel ; int buffer Size = ( int ) Math . ceil ( size In Bits / NUM_ ) + NUM_ ; byte [ ] byte Array = new byte [ buffer Size ] ; Byte Buffer buffer = Byte Buffer . wrap ( byte Array ) ; if ( ! buffer . has Array ( ) || ( buffer . array ( ) != byte Array ) ) { throw new Illegal State Exception ( STR_ ) ; } m Bytes To Byte Buffer . put ( byte Array , buffer ) ; return byte Array ; }
public X Pattern Tokenizer ( Attribute Factory factory , Pattern pattern , int group ) { super ( factory ) ; this . group = group ; matcher = pattern . matcher ( STR_ ) ; if ( group >= NUM_ && group > matcher . group Count ( ) ) { throw new Illegal Argument Exception ( STR_ + matcher . group Count ( ) + STR_ ) ; } }
public void load First Page ( ) { m Page = NUM_ ; if ( m Post Array List . is Empty ( ) ) { show Loading View ( ) ; m Previous Post Num = NUM_ ; load Post ( m Page , false ) ; } else hide Loading View ( ) ; }
private void prepare Data Set ( ) { data Set 1 = Arrays . as List ( new String [ ] { STR_ , STR_ } ) ; data Set 2 = Arrays . as List ( new String [ ] { STR_ , STR_ } ) ; data Set 3 = Arrays . as List ( new String [ ] { STR_ , STR_ } ) ; }
public void stop Thread ( ) { run Status = false ; }
protected void draw Horizontal Item ( Graphics 2 D g 2 , Category Item Renderer State state , Rectangle 2 D data Area , Category Plot plot , Category Axis domain Axis , Value Axis range Axis , Statistical Category Dataset dataset , int visible Row , int row , int column ) { double rect Y = calculate Bar W 0 ( plot , Plot Orientation . HORIZONTAL , data Area , domain Axis , state , visible Row , column ) ; Number mean Value = dataset . get Mean Value ( row , column ) ; if ( mean Value == null ) { return ; } double value = mean Value . double Value ( ) ; double base = NUM_ ; double lclip = get Lower Clip ( ) ; double uclip = get Upper Clip ( ) ; if ( uclip <= NUM_ ) { if ( value >= uclip ) { return ; } base = uclip ; if ( value <= lclip ) { value = lclip ; } } else if ( lclip <= NUM_ ) { if ( value >= uclip ) { value = uclip ; } else { if ( value <= lclip ) { value = lclip ; } } } else { if ( value <= lclip ) { return ; } base = get Lower Clip ( ) ; if ( value >= uclip ) { value = uclip ; } } Rectangle Edge y Axis Location = plot . get Range Axis Edge ( ) ; double trans Y 1 = range Axis . value To Java 2 D ( base , data Area , y Axis Location ) ; double trans Y 2 = range Axis . value To Java 2 D ( value , data Area , y Axis Location ) ; double rect X = Math . min ( trans Y 2 , trans Y 1 ) ; double rect Height = state . get Bar Width ( ) ; double rect Width = Math . abs ( trans Y 2 - trans Y 1 ) ; Rectangle 2 D bar = new Rectangle 2 D . Double ( rect X , rect Y , rect Width , rect Height ) ; Paint item Paint = get Item Paint ( row , column ) ; Gradient Paint Transformer t = get Gradient Paint Transformer ( ) ; if ( t != null && item Paint instanceof Gradient Paint ) { item Paint = t . transform ( ( Gradient Paint ) item Paint , bar ) ; } g 2 . set Paint ( item Paint ) ; g 2 . fill ( bar ) ; if ( is Draw Bar Outline ( ) && state . get Bar Width ( ) > BAR OUTLINE WIDTH THRESHOLD ) { Stroke stroke = get Item Outline Stroke ( row , column ) ; Paint paint = get Item Outline Paint ( row , column ) ; if ( stroke != null && paint != null ) { g 2 . set Stroke ( stroke ) ; g 2 . set Paint ( paint ) ; g 2 . draw ( bar ) ; } } Number n = dataset . get Std Dev Value ( row , column ) ; if ( n != null ) { double value Delta = n . double Value ( ) ; double high Val = range Axis . value To Java 2 D ( mean Value . double Value ( ) + value Delta , data Area , y Axis Location ) ; double low Val = range Axis . value To Java 2 D ( mean Value . double Value ( ) - value Delta , data Area , y Axis Location ) ; if ( this . error Indicator Paint != null ) { g 2 . set Paint ( this . error Indicator Paint ) ; } else { g 2 . set Paint ( get Item Outline Paint ( row , column ) ) ; } if ( this . error Indicator Stroke != null ) { g 2 . set Stroke ( this . error Indicator Stroke ) ; } else { g 2 . set Stroke ( get Item Outline Stroke ( row , column ) ) ; } Line 2 D line ; line = new Line 2 D . Double ( low Val , rect Y + rect Height / NUM_ , high Val , rect Y + rect Height / NUM_ ) ; g 2 . draw ( line ) ; line = new Line 2 D . Double ( high Val , rect Y + rect Height * NUM_ , high Val , rect Y + rect Height * NUM_ ) ; g 2 . draw ( line ) ; line = new Line 2 D . Double ( low Val , rect Y + rect Height * NUM_ , low Val , rect Y + rect Height * NUM_ ) ; g 2 . draw ( line ) ; } Category Item Label Generator generator = get Item Label Generator ( row , column ) ; if ( generator != null && is Item Label Visible ( row , column ) ) { draw Item Label ( g 2 , dataset , row , column , plot , generator , bar , ( value < NUM_ ) ) ; } Entity Collection entities = state . get Entity Collection ( ) ; if ( entities != null ) { add Item Entity ( entities , dataset , row , column , bar ) ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Pin Needle ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } return true ; }
protected void end Prefix Mapping ( Namespace Stack stack , int stack Size ) throws SAX Exception { while ( stack . size ( ) > stack Size ) { Namespace namespace = stack . pop ( ) ; if ( namespace != null ) { content Handler . end Prefix Mapping ( namespace . get Prefix ( ) ) ; } } }
protected String url ( int zoom Level , int x Tile , int y Tile ) { String Builder sb = new String Builder ( url ) ; sb . append ( STR_ ) ; sb . append ( zoom Level ) ; sb . append ( STR_ ) ; sb . append ( x Tile ) ; sb . append ( STR_ ) ; sb . append ( y Tile ) ; sb . append ( STR_ ) ; return sb . to String ( ) ; }
private synchronized void read Object ( java . io . Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; init ( get Name ( ) , get Mask ( actions ) ) ; }
public void add Key ( Object key ) { keys . add ( key ) ; }
private String build Tool Tip ( final List < Navi Node > nodes ) { final String Builder tooltip = new String Builder ( STR_ ) ; boolean first = true ; for ( final Navi Node graph Node : nodes ) { if ( ! first ) { tooltip . append ( STR_ ) ; } tooltip . append ( C Nodes Display String . get Display String ( graph Node ) ) ; first = false ; } return tooltip + STR_ ; }
public boolean await ( long timeout , Time Unit time Unit ) throws Interrupted Exception { boolean await Result = false ; lock . lock ( ) ; boolean local Is Done ; try { await Result = done . await ( timeout , time Unit ) ; } finally { local Is Done = is Done ; is Done = false ; lock . unlock ( ) ; } return await Result && local Is Done ; }
private double second Partial Derivative Ridr ( Fitting Function f , int i , int j , double [ ] args , double delt ) { double [ ] arg = new double [ args . length ] ; double [ ] [ ] a = new double [ NTAB ] [ NTAB ] ; double hh = delt ; double errt ; double ans = NUM_ ; double fac ; System . arraycopy ( args , NUM_ , arg , NUM_ , args . length ) ; double center = f . evaluate ( arg ) ; arg [ i ] += delt ; arg [ j ] += delt ; double ff 1 = f . evaluate ( arg ) ; arg [ j ] -= NUM_ * delt ; double ff 2 = f . evaluate ( arg ) ; arg [ i ] -= NUM_ * delt ; arg [ j ] += NUM_ * delt ; double ff 3 = f . evaluate ( arg ) ; arg [ j ] -= NUM_ * delt ; double ff 4 = f . evaluate ( arg ) ; if ( Double . is Na N ( ff 1 ) ) { ff 1 = center ; } if ( Double . is Na N ( ff 2 ) ) { ff 2 = center ; } if ( Double . is Na N ( ff 3 ) ) { ff 3 = center ; } if ( Double . is Na N ( ff 4 ) ) { ff 4 = center ; } a [ NUM_ ] [ NUM_ ] = ( ff 1 - ff 2 - ff 3 + ff 4 ) / ( NUM_ * delt * delt ) ; double err = BIG ; for ( int ii = NUM_ ; ii < NTAB ; ii ++ ) { hh /= CON ; System . arraycopy ( args , NUM_ , arg , NUM_ , args . length ) ; arg [ i ] += hh ; arg [ j ] += hh ; ff 1 = f . evaluate ( arg ) ; arg [ j ] -= NUM_ * hh ; ff 2 = f . evaluate ( arg ) ; arg [ i ] -= NUM_ * hh ; arg [ j ] += NUM_ * hh ; ff 3 = f . evaluate ( arg ) ; arg [ j ] -= NUM_ * hh ; ff 4 = f . evaluate ( arg ) ; if ( Double . is Na N ( ff 1 ) ) { ff 1 = center ; } if ( Double . is Na N ( ff 2 ) ) { ff 2 = center ; } if ( Double . is Na N ( ff 3 ) ) { ff 3 = center ; } if ( Double . is Na N ( ff 4 ) ) { ff 4 = center ; } a [ NUM_ ] [ ii ] = ( ff 1 - ff 2 - ff 3 + ff 4 ) / ( NUM_ * hh * hh ) ; fac = CON 2 ; for ( int jj = NUM_ ; jj < ii ; jj ++ ) { a [ jj ] [ ii ] = ( a [ jj - NUM_ ] [ ii ] * fac - a [ jj - NUM_ ] [ ii - NUM_ ] ) / ( fac - NUM_ ) ; fac = CON 2 * fac ; errt = Math . max ( Math . abs ( a [ jj ] [ ii ] - a [ jj - NUM_ ] [ ii ] ) , Math . abs ( a [ jj ] [ ii ] - a [ jj - NUM_ ] [ ii - NUM_ ] ) ) ; if ( errt < err ) { err = errt ; ans = a [ jj ] [ ii ] ; } } if ( Math . abs ( a [ ii ] [ ii ] - a [ ii - NUM_ ] [ ii - NUM_ ] ) >= SAFE * err ) { break ; } } return ans ; }
public synchronized static < T > String marshal ( T t ) { String Writer string Writer = new String Writer ( ) ; String str = STR_ ; try { JAXB Context context = JAXB Context . new Instance ( t . get Class ( ) ) ; Marshaller marshaller = context . create Marshaller ( ) ; marshaller . marshal ( t , string Writer ) ; str = string Writer . to String ( ) ; } catch ( JAXB Exception je ) { log . error ( STR_ , je ) ; } return str ; }
@ Suppress Warnings ( STR_ ) public Sorted Set < E > head Set ( E end ) { return head Set ( end , false ) ; }
protected void listen To Layers ( Layer [ ] new Layers ) { if ( Swing Utilities . is Event Dispatch Thread ( ) ) { listen To Layers From EDT ( new Layers ) ; } else { Swing Utilities . invoke Later ( new My Worker ( new Layers ) ) ; } }
public Grid Cache Write Behind Store ( Cache Store Manager store Mgr , String grid Name , String cache Name , Ignite Logger log , Cache Store < K , V > store ) { this . store Mgr = store Mgr ; this . grid Name = grid Name ; this . cache Name = cache Name ; this . log = log ; this . store = store ; }
public String generate Device Specific Delete Workflow ( Workflow workflow , String previous Step , Export Group export Group , Export Mask mask , List < URI > volumes , List < URI > initiators , Storage System storage ) throws Exception { String un Mask Step = generate Export Mask Delete Workflow ( workflow , previous Step , storage , export Group , mask , volumes , initiators , null ) ; return generate Zoning Delete Workflow ( workflow , un Mask Step , export Group , Arrays . as List ( mask ) ) ; }
protected void initialize ( ) { int iwidth = m plot Panel . get Width ( ) ; int iheight = m plot Panel . get Height ( ) ; m osi = m plot Panel . create Image ( iwidth , iheight ) ; Graphics m = m osi . get Graphics ( ) ; m . fill Rect ( NUM_ , NUM_ , iwidth , iheight ) ; }
@ Override public void run ( ) { threads . from New To Running ( Thread . current Thread ( ) ) ; r . run ( ) ; threads . remove Running ( Thread . current Thread ( ) ) ; if ( ! has Active Non Daemon Threads ( ) ) completer . accept ( Thread Factory Tracker . this , null ) ; }
private void create Press Image View ( View v , int x , int y ) { m Window Layout Params = new Window Manager . Layout Params ( ) ; m Window Layout Params . gravity = Gravity . TOP | Gravity . LEFT ; m Window Layout Params . x = x - m Point 2 Item Left + m Offset 2 Left ; m Window Layout Params . y = y - m Point 2 Item Top + m Offset 2 Top - m Status Height ; m Window Layout Params . alpha = NUM_ ; m Window Layout Params . width = Window Manager . Layout Params . WRAP CONTENT ; m Window Layout Params . height = Window Manager . Layout Params . WRAP CONTENT ; m Window Layout Params . flags = Window Manager . Layout Params . FLAG NOT FOCUSABLE | Window Manager . Layout Params . FLAG NOT TOUCHABLE ; m Drag Image View = new Image View ( get Context ( ) ) ; v . set Drawing Cache Enabled ( true ) ; Bitmap bitmap = Bitmap . create Bitmap ( v . get Drawing Cache ( ) ) ; m Drag Image View . set Image Bitmap ( bitmap ) ; v . destroy Drawing Cache ( ) ; m Window Manager . add View ( m Drag Image View , m Window Layout Params ) ; }
private View create View ( Composite parent ) { try { return new View ( parent , SWT . NONE , this ) ; } catch ( Exception err ) { logger . log ( Level . SEVERE , STR_ , err ) ; throw err ; } }
public Partitions prune Partitions ( Set < String > valid Partitions ) { if ( valid Partitions != null && ! valid Partitions . is Empty ( ) ) { partitions . retain All ( valid Partitions ) ; } return this ; }
public String [ ] add Init Next For TE ( List < Simple TLC State > trace , Trace Expression Information Holder [ ] expression Data ) { String init Id = get Valid Identifier ( INIT SCHEME ) ; String next Id = get Valid Identifier ( NEXT SCHEME ) ; add Init Next For TE ( trace , expression Data , init Id , next Id ) ; return new String [ ] { init Id , next Id } ; }
private void init GUI ( ) { J Panel outer Panel = new J Panel ( ) ; outer Panel . set Layout ( new Grid Bag Layout ( ) ) ; Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . gridx = NUM_ ; gbc . gridy = NUM_ ; gbc . weightx = NUM_ ; gbc . fill = Grid Bag Constraints . BOTH ; outer Panel . add ( create Step 1 Panel ( ) , gbc ) ; if ( o Auth . is O Auth 2 ( ) ) { gbc . gridy += NUM_ ; outer Panel . add ( create Step 2 Panel ( ) , gbc ) ; } status Label = new J Label ( ) ; status Label . set Minimum Size ( new Dimension ( NUM_ , NUM_ ) ) ; status Label . set Preferred Size ( new Dimension ( NUM_ , NUM_ ) ) ; status Label . set Horizontal Alignment ( J Label . RIGHT ) ; gbc . gridy += NUM_ ; gbc . insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; outer Panel . add ( status Label , gbc ) ; gbc . gridy += NUM_ ; Component bt Panel = create Buttons ( ) ; outer Panel . add ( bt Panel , gbc ) ; add ( outer Panel ) ; layout Default ( outer Panel , confirm Button , cancel Button ) ; if ( o Auth . is O Auth 2 ( ) ) { set Preferred Size ( new Dimension ( NUM_ , NUM_ ) ) ; } else { set Preferred Size ( new Dimension ( NUM_ , NUM_ ) ) ; } set Resizable ( false ) ; set Modal ( true ) ; pack ( ) ; set Location Relative To ( Application Frame . get Application Frame ( ) ) ; }
public static String quote Hash ( final String str ) { if ( str != null ) { final int idx = str . index Of ( STR_ ) ; if ( ( idx != - NUM_ ) && ( str . index Of ( STR_ , idx ) != - NUM_ ) && ( str . char At ( idx + NUM_ ) != STR_ ) ) { return str . substring ( NUM_ , idx ) + STR_ + str . substring ( idx + NUM_ ) + STR_ ; } } return str ; }
public Resource Queue ( R resource , Tx Dag waits For ) { if ( resource == null ) throw new Null Pointer Exception ( ) ; this . resource = resource ; this . waits For = waits For ; }
private static int calculate Delay For Error ( ) { return random . next Int ( DELAY MS * ERROR DELAY FACTOR ) ; }
private Auto Completion Server . Completion Items find Results ( String type , String prefix , String search ) { return server . get Completion Items ( type , prefix , search ) ; }
public void add Issuer ( X 500 Principal issuer ) { if ( issuer == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( issuer Names == null ) { issuer Names = new Array List < String > ( ) ; } String name = issuer . get Name ( X 500 Principal . CANONICAL ) ; if ( ! issuer Names . contains ( name ) ) { issuer Names . add ( name ) ; } if ( issuer Principals == null ) { issuer Principals = new Array List < X 500 Principal > ( issuer Names . size ( ) ) ; } int size = issuer Names . size ( ) - NUM_ ; for ( int i = issuer Principals . size ( ) ; i < size ; i ++ ) { issuer Principals . add ( new X 500 Principal ( issuer Names . get ( i ) ) ) ; } issuer Principals . add ( issuer ) ; }
public boolean run Repair ( ) throws IO Exception , Interrupted Exception { start Time In Millis = System . current Time Millis ( ) ; List < String Token Range > local Ranges = get Local Ranges ( key Space Name ) ; if ( local Ranges == null ) { success = false ; return false ; } total Repair Sessions = local Ranges . size ( ) ; if ( total Repair Sessions == NUM_ ) { log . info ( STR_ , key Space Name ) ; return success ; } log . info ( STR_ , this . key Space Name , total Repair Sessions ) ; completed Repair Sessions = last Token == null ? NUM_ : index Of Range ( local Ranges , last Token ) ; if ( completed Repair Sessions == - NUM_ ) { log . error ( STR_ , last Token ) ; completed Repair Sessions = NUM_ ; } else { log . info ( STR_ , new Object [ ] { last Token , get Progress ( ) , completed Repair Sessions } ) ; } Scheduled Future < ? > job Monitor Handle = start Monitor ( svc Proxy ) ; lock . lock ( ) ; try { aborted = false ; success = true ; while ( completed Repair Sessions < total Repair Sessions ) { String current Digest = Db Repair Runnable . get Cluster State Digest ( ) ; if ( ! cluster State Digest . equals ( current Digest ) ) { log . error ( STR_ , cluster State Digest , current Digest ) ; success = false ; break ; } String Token Range range = local Ranges . get ( completed Repair Sessions ) ; repair Range ( range ) ; if ( ! success ) { log . error ( STR_ , range . begin , range . end ) ; break ; } last Token = range . end ; completed Repair Sessions ++ ; log . info ( STR_ , completed Repair Sessions , get Progress ( ) ) ; } } finally { lock . unlock ( ) ; job Monitor Handle . cancel ( false ) ; log . info ( STR_ ) ; } if ( success ) { last Token = null ; } long repair Millis = System . current Time Millis ( ) - start Time In Millis ; log . info ( STR_ , repair Millis > MIN MINUTE FOR REPAIR TIME IN LOG * Time Utils . MINUTES ? repair Millis / Time Utils . MINUTES + STR_ : repair Millis / Time Utils . SECONDS + STR_ ) ; return success ; }
public int size ( ) { return points . size ( ) ; }
public boolean remove ( Object obj ) { boolean ret = super . remove ( obj ) ; if ( obj instanceof Bean Context Membership Listener ) { super . remove Bean Context Membership Listener ( ( Bean Context Membership Listener ) obj ) ; } return ret ; }
public Date parse ( String source ) throws Parse Exception { return ( Date ) parse Object ( source ) ; }
private String print D Format ( final short x ) { return print D Format ( Short . to String ( x ) ) ; }
private static char [ ] grow Buffer ( char [ ] dest , int index , int size ) { char [ ] copy = new char [ size ] ; if ( index > NUM_ ) { System . arraycopy ( dest , NUM_ , copy , NUM_ , index ) ; } return copy ; }
public void organization Config Changed ( String service Name , String version , String org Name , String group Name , String service Component , int type ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + service Name + STR_ + org Name + STR_ + group Name + STR_ + service Component + STR_ + type ) ; } if ( ( type == Service Listener . REMOVED ) && ( service Component . length ( ) == NUM_ ) ) { remove Id Repo ( org Name ) ; } else if ( ( service Component . length ( ) != NUM_ ) && ! service Component . equals ( STR_ ) && ! service Component . equals ( STR_ ) ) { String id Repo Name = null ; String Tokenizer st = new String Tokenizer ( service Component , STR_ ) ; if ( st . has More Tokens ( ) ) { id Repo Name = st . next Token ( ) ; } try { if ( type == Service Listener . ADDED ) { add Id Repo ( org Name , id Repo Name ) ; } else if ( type == Service Listener . MODIFIED ) { if ( ! Id Services Impl . is Shutdown Called ( ) ) { remove Id Repo ( org Name , id Repo Name , true ) ; } else { remove Id Repo ( org Name , id Repo Name , false ) ; } } else if ( type == Service Listener . REMOVED ) { remove Id Repo ( org Name , id Repo Name , false ) ; } } catch ( Exception e ) { debug . error ( STR_ + STR_ + service Name + STR_ + org Name + STR_ + group Name + STR_ + service Component + STR_ + type , e ) ; } } }
private void update Arc View Positions ( ) { float half Width = get Width ( ) / NUM_ ; double radius = get Width ( ) * NUM_ ; double pow Radius = radius * radius ; double rotation ; float half View Width ; double delta X ; double delta Y ; int view Position ; for ( int count = get Child Count ( ) , i = NUM_ ; i < count ; i ++ ) { View view = get Child At ( i ) ; rotation = NUM_ ; half View Width = view . get Width ( ) / NUM_ ; view . set Pivot X ( half View Width ) ; view . set Pivot Y ( view . get Height ( ) ) ; if ( settings . is Fan Radius Enable ( ) ) { delta X = half Width - get Decorated Left ( view ) - half View Width ; delta Y = radius - Math . sqrt ( pow Radius - delta X * delta X ) ; view . set Translation Y ( ( float ) delta Y ) ; rotation = ( Math . to Degrees ( Math . asin ( ( radius - delta Y ) / radius ) ) - NUM_ ) * Math . signum ( delta X ) ; } view Position = get Position ( view ) ; Double base View Rotation = view Rotations Map . get ( view Position ) ; if ( base View Rotation == null ) { base View Rotation = random . next Double ( ) * settings . get Angle Item Bounce ( ) * NUM_ - settings . get Angle Item Bounce ( ) ; view Rotations Map . put ( view Position , base View Rotation ) ; } view . set Rotation ( ( float ) ( rotation + base View Rotation ) ) ; } }
public Parse Query < T > where Starts With ( String key , String prefix ) { String regex = STR_ + Pattern . quote ( prefix ) ; where Matches ( key , regex ) ; return this ; }
public static void write Pem String To File ( File file , String pem Data To Write ) { try { File Utils . write ( file , pem Data To Write ) ; } catch ( IO Exception e ) { throw new Export Exception ( STR_ + file . get Name ( ) , e ) ; } }
public void edit Button Action Performed ( ) { String node Address = read Node Address ( ) ; if ( node Address . equals ( STR_ ) ) { return ; } cur Node = ( IEEE 802154 Node ) itc . get Node From Address ( node Address ) ; if ( cur Node == null ) { status Text 1 . set Text ( Bundle . get Message ( STR_ ) ) ; status Text 1 . set Visible ( true ) ; error In Status 1 = true ; reset Notes 2 ( ) ; return ; } jmri . util . Jmri J Frame edit Frame = new Edit Node Frame ( itc , cur Node ) ; try { edit Frame . init Components ( ) ; } catch ( Exception ex ) { log . error ( STR_ , ex . to String ( ) ) ; return ; } edit Frame . set Visible ( true ) ; }
private void maybe Update Stats ( ) { if ( lock . try Lock ( ) ) { try { if ( ( System Clock . uptime Millis ( ) - m Last Restat Time ) > RESTAT INTERVAL MS ) { update Stats ( ) ; } } finally { lock . unlock ( ) ; } } }
public static String format Doc String ( String Literal docstring , Doc String Owner owner ) { String raw = docstring . get String Contents ( ) ; String [ ] lines = raw . split ( STR_ ) ; String Builder output = new String Builder ( ) ; output . append ( STR_ ) ; int initial Indent = - NUM_ ; for ( String line : lines ) { if ( initial Indent == - NUM_ && line . starts With ( STR_ ) ) { initial Indent = String Util . count Chars ( line , STR_ , NUM_ , true ) ; } line = trim Start ( line , initial Indent ) ; if ( ! line . is Empty ( ) ) { output . append ( line ) ; } output . append ( STR_ ) ; } output . append ( STR_ ) ; return output . to String ( ) ; }
public String encode Base 64 ( String value ) { return Base 64 . encode Base 64 String ( value . get Bytes ( ) ) ; }
public void manage ( Subscription subscription ) { m Subscriptions . add ( subscription ) ; }
public static void clear Dns Cache ( ) { try { Inet Address Cache Util . clear Inet Address Cache ( ) ; } catch ( Exception e ) { throw new Dns Cache Manipulator Exception ( STR_ + e . to String ( ) , e ) ; } }
@ Override public boolean input ( Instance instance ) throws Exception { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = false ; } if ( output Format Peek ( ) != null ) { convert Instance ( instance ) ; return true ; } buffer Input ( instance ) ; return false ; }
public void add ( double [ ] preds , double [ ] input ) { if ( m target Category == - NUM_ ) { preds [ NUM_ ] += m coefficient * Math . pow ( input [ m mining Schema Att Index ] , m exponent ) ; } else { preds [ m target Category ] += m coefficient * Math . pow ( input [ m mining Schema Att Index ] , m exponent ) ; } }
public boolean accept ( File dir , String name ) { return extension . equals Ignore Case ( get Extension ( name ) ) ; }
public int update With On Conflict ( String table , Values Storage values , String where Clause , String [ ] where Args , int conflict Algorithm ) { if ( values == null || values . size ( ) == NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } acquire Reference ( ) ; try { String Builder sql = new String Builder ( NUM_ ) ; sql . append ( STR_ ) ; sql . append ( CONFLICT VALUES [ conflict Algorithm ] ) ; sql . append ( table ) ; sql . append ( STR_ ) ; int set Values Size = values . size ( ) ; int bind Args Size = ( where Args == null ) ? set Values Size : ( set Values Size + where Args . length ) ; Object [ ] bind Args = new Object [ bind Args Size ] ; int i = NUM_ ; for ( String col Name : values . key Set ( ) ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; sql . append ( col Name ) ; bind Args [ i ++ ] = values . get ( col Name ) ; sql . append ( STR_ ) ; } if ( where Args != null ) { for ( i = set Values Size ; i < bind Args Size ; i ++ ) { bind Args [ i ] = where Args [ i - set Values Size ] ; } } if ( ! Sql Utils . is Empty ( where Clause ) ) { sql . append ( STR_ ) ; sql . append ( where Clause ) ; } SQ Lite Statement statement = new SQ Lite Statement ( this , sql . to String ( ) , bind Args ) ; try { return statement . execute Update Delete ( ) ; } finally { statement . close ( ) ; } } finally { release Reference ( ) ; } }
String capitalize ( String value ) { char [ ] chars ; int i ; chars = value . to Char Array ( ) ; if ( chars . length > NUM_ ) { chars [ NUM_ ] = Character . to Upper Case ( chars [ NUM_ ] ) ; for ( i = NUM_ ; i < chars . length ; ++ i ) { chars [ i ] = Character . to Lower Case ( chars [ i ] ) ; } return String . value Of ( chars ) ; } return value ; }
@ Nullable private static Help find Help ( @ Not Null final Psi Element element ) { if ( ! ( element instanceof Command Line Part ) ) { return null ; } final Command Line Part command Line Part = ( Command Line Part ) element ; final Command real Command = command Line Part . find Real Command ( ) ; if ( real Command == null ) { return null ; } final Command Line Element command Line Element = Py Util . as ( element , Command Line Element . class ) ; if ( command Line Element == null ) { return null ; } final My Command Help Obtainer help Obtainer = new My Command Help Obtainer ( ) ; command Line Element . accept ( help Obtainer ) ; return help Obtainer . my Result Help ; }
public void start ( ) { start Time = System . current Time Millis ( ) ; super . start ( ) ; }
private static void generate Data File ( String datafile , String rule , String builder ) { Rule Based Break Iterator Builder bld ; if ( builder . equals ( STR_ ) ) { bld = new Rule Based Break Iterator Builder ( rule ) ; } else if ( builder . equals ( STR_ ) ) { bld = new Dictionary Based Break Iterator Builder ( rule ) ; } else { throw new Illegal Argument Exception ( STR_ + builder + STR_ ) ; } bld . make File ( datafile ) ; }
public Multimap < String , String > load Relations ( DB Transaction transaction , String charname ) throws SQL Exception { Hash Multimap < String , String > map = Hash Multimap . create ( ) ; String query = STR_ ; Map < String , Object > params = new Hash Map < String , Object > ( ) ; params . put ( STR_ , charname ) ; Result Set result Set = transaction . query ( query , params ) ; while ( result Set . next ( ) ) { map . put ( result Set . get String ( NUM_ ) , result Set . get String ( NUM_ ) ) ; } return map ; }
public void reset ( ) throws IO Exception { m structure = null ; m Buffer = null ; set Retrieval ( NONE ) ; if ( m File != null ) { set File ( new File ( m File ) ) ; } else if ( ( m URL != null ) && ! m URL . equals ( STR_ ) ) { set URL ( m URL ) ; } }
private boolean ensure Scroll Wheel Adjusted ( ) { int delta = m Initial Scroll Offset - m Current Scroll Offset ; if ( delta != NUM_ ) { if ( Math . abs ( delta ) > m Selector Element Size / NUM_ ) { delta += ( delta > NUM_ ) ? - m Selector Element Size : m Selector Element Size ; } if ( is Horizontal Mode ( ) ) { m Previous Scroller X = NUM_ ; m Adjust Scroller . start Scroll ( NUM_ , NUM_ , delta , NUM_ , SELECTOR ADJUSTMENT DURATION MILLIS ) ; } else { m Previous Scroller Y = NUM_ ; m Adjust Scroller . start Scroll ( NUM_ , NUM_ , NUM_ , delta , SELECTOR ADJUSTMENT DURATION MILLIS ) ; } invalidate ( ) ; return true ; } return false ; }
@ Rpc Method public void create Vm ( String reservation , Map < String , String > environment , Async Method Callback < Host . Async Client . create vm call > handler ) throws Rpc Exception { ensure Client ( ) ; Create Vm Request create Vm Request = new Create Vm Request ( reservation ) ; if ( environment != null && ! environment . is Empty ( ) ) { create Vm Request . set Environment ( environment ) ; } client Proxy . set Timeout ( CREATE VM TIMEOUT MS ) ; logger . info ( STR_ , get Host Ip ( ) , reservation , create Vm Request ) ; try { client Proxy . create vm ( create Vm Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Override protected void fire Property Change ( int action ) { super . fire Property Change ( action ) ; }
public Member Name ( Class < ? > type ) { init ( type . get Declaring Class ( ) , type . get Simple Name ( ) , type , flags Mods ( IS TYPE , type . get Modifiers ( ) , REF NONE ) ) ; init Resolved ( true ) ; }
public Texture Square ( GL 10 gl , Bitmap texture Bitmap ) { Byte Buffer vbb = Byte Buffer . allocate Direct ( square Coords . length * NUM_ ) ; vbb . order ( Byte Order . native Order ( ) ) ; vertex Buffer = vbb . as Float Buffer ( ) ; vertex Buffer . put ( square Coords ) ; vertex Buffer . position ( NUM_ ) ; Byte Buffer tbb = Byte Buffer . allocate Direct ( texture Coords . length * NUM_ ) ; tbb . order ( Byte Order . native Order ( ) ) ; texture Buffer = tbb . as Float Buffer ( ) ; texture Buffer . put ( texture Coords ) ; texture Buffer . position ( NUM_ ) ; Byte Buffer dlb = Byte Buffer . allocate Direct ( draw Order . length * NUM_ ) ; dlb . order ( Byte Order . native Order ( ) ) ; draw List Buffer = dlb . as Short Buffer ( ) ; draw List Buffer . put ( draw Order ) ; draw List Buffer . position ( NUM_ ) ; textures = new int [ NUM_ ] ; gl . gl Gen Textures ( NUM_ , textures , NUM_ ) ; gl . gl Bind Texture ( GL 10 . GL TEXTURE 2 D , textures [ NUM_ ] ) ; GL Utils . tex Image 2 D ( GL 10 . GL TEXTURE 2 D , NUM_ , texture Bitmap , NUM_ ) ; gl . gl Tex Parameterf ( GL 10 . GL TEXTURE 2 D , GL 10 . GL TEXTURE MIN FILTER , GL 10 . GL NEAREST ) ; gl . gl Tex Parameterf ( GL 10 . GL TEXTURE 2 D , GL 10 . GL TEXTURE MAG FILTER , GL 10 . GL NEAREST ) ; gl . gl Bind Texture ( GL 10 . GL TEXTURE 2 D , NUM_ ) ; }
public Say NPC Names For Unstarted Quests Action ( String region ) { this . regions = Arrays . as List ( region ) ; }
@ Override public Move Path clone ( ) { final Move Path copy = new Move Path ( get Game ( ) , get Entity ( ) ) ; copy . steps = new Vector < Move Step > ( steps ) ; copy . careful = careful ; return copy ; }
private static void find Bidirectional Edges ( List < Tuple < Integer , Integer > > edge List , String path , String file Name ) { log . info ( STR_ ) ; List < Tuple < Integer , Integer > > bidirectional List = new Array List < Tuple < Integer , Integer > > ( ) ; List < Tuple < Integer , Integer > > to Remove List = new Array List < Tuple < Integer , Integer > > ( ) ; for ( int i = NUM_ ; i < edge List . size ( ) ; i ++ ) { Tuple < Integer , Integer > this Edge = edge List . get ( i ) ; int source = this Edge . get First ( ) ; int destination = this Edge . get Second ( ) ; Tuple < Integer , Integer > reverse Edge = new Tuple < Integer , Integer > ( destination , source ) ; int reverse Source = reverse Edge . get First ( ) ; int reverse Destination = reverse Edge . get Second ( ) ; if ( to Remove List . contains ( reverse Edge ) ) { } else { for ( int j = NUM_ ; j < edge List . size ( ) ; j ++ ) { Tuple < Integer , Integer > next Edge = edge List . get ( j ) ; int next Source = next Edge . get First ( ) ; int next Destination = next Edge . get Second ( ) ; if ( ( reverse Source == next Source ) && ( reverse Destination == next Destination ) ) { bidirectional List . add ( this Edge ) ; to Remove List . add ( this Edge ) ; to Remove List . add ( next Edge ) ; } } } } edge List . remove All ( to Remove List ) ; String bidirectional File Name = file Name + STR_ ; String onedirectional File Name = file Name + STR_ ; write Output ( bidirectional List , path , file Name , bidirectional File Name ) ; write Output ( edge List , path , file Name , onedirectional File Name ) ; }
public static int hash 1 ( int hash , Object x ) { return NUM_ | ( hash + NUM_ * System . identity Hash Code ( x ) ) ; }
public static final boolean enable Thread Cpu Time Measurement ( ) { if ( tbe . is Thread Cpu Time Supported ( ) ) { tbe . set Thread Cpu Time Enabled ( true ) ; return true ; } return false ; }
final boolean try Write Lock ( ) { Thread current = Thread . current Thread ( ) ; int c = get State ( ) ; if ( c != NUM_ ) { int w = exclusive Count ( c ) ; if ( w == NUM_ || current != get Exclusive Owner Thread ( ) ) return false ; if ( w == MAX COUNT ) throw new Error ( STR_ ) ; } if ( ! compare And Set State ( c , c + NUM_ ) ) return false ; set Exclusive Owner Thread ( current ) ; return true ; }
public void keep Predictions ( boolean keep Predictions ) { this . keep Predictions = keep Predictions ; }
public Access Structure ( String user , jplag Web Service . server . Option usr option ) throws J Plag Exception { dec = new Status Decorator ( new Status ( ) ) ; submission ID = J Plag Central . get Next Submission ID ( ) ; command Line In String = generate CMD ( usr option ) ; username = user ; title = usr option . get Title ( ) ; date = System . current Time Millis ( ) ; generate Structure ( usr option , command Line In String ) ; }
public static boolean is Volume CG Full Copy Source ( Volume volume , Db Client db Client ) { boolean is Full Copy Source = false ; String Set full Copy Ids = volume . get Full Copies ( ) ; if ( ( full Copy Ids != null ) && ( ! full Copy Ids . is Empty ( ) ) ) { Iterator < String > full Copy Ids Iter = full Copy Ids . iterator ( ) ; while ( full Copy Ids Iter . has Next ( ) ) { URI full Copy URI = URI . create ( full Copy Ids Iter . next ( ) ) ; Volume full Copy Volume = db Client . query Object ( Volume . class , full Copy URI ) ; if ( ( full Copy Volume != null ) && ( ! full Copy Volume . get Inactive ( ) ) ) { String group Name = full Copy Volume . get Replication Group Instance ( ) ; if ( Null Column Value Getter . is Not Null Value ( group Name ) || V Plex Util . is Backend Full Copy In Replication Group ( full Copy Volume , db Client ) ) { is Full Copy Source = true ; break ; } } } } return is Full Copy Source ; }
public static void register Flammable ( String fluid Name ) { flammable List . add ( fluid Name ) ; }
public Char Sequence sub Sequence ( int start , int end ) { return substring ( start , end ) ; }
public Exec WSH Script Command ( String playlist , File [ ] files ) { this . playlist = playlist ; this . files = files ; }
protected void subtract Promotion Value ( final Map < String , Object > context , final Big Decimal amount ) { final String promo Code = get Promotion Code ( context ) ; final Total total = get Total ( context ) ; final Big Decimal order Amount Off ; if ( Money Utils . is First Bigger Than Second ( amount , total . get Sub Total ( ) ) ) { order Amount Off = total . get Sub Total ( ) ; } else { order Amount Off = amount ; } set Total ( context , total . add ( new Total Impl ( Money Utils . ZERO , Money Utils . ZERO , Money Utils . ZERO , Money Utils . ZERO , true , promo Code , order Amount Off . negate ( ) , Money Utils . ZERO , Money Utils . ZERO , Money Utils . ZERO , Money Utils . ZERO , false , null , Money Utils . ZERO , Money Utils . ZERO , Money Utils . ZERO , Money Utils . ZERO , Money Utils . ZERO , Money Utils . ZERO ) ) ) ; }
public Object [ ] construct Index Row ( String col Name , Object value ) { return construct Index Row ( Collections . singleton Map ( col Name , value ) ) ; }
public void create ROC Plot Dialog ( ROC Data data ) { ROC Chart Plotter plotter = new ROC Chart Plotter ( ) ; plotter . add ROC Data ( STR_ , data ) ; J Dialog dialog = new J Dialog ( ) ; dialog . set Title ( STR_ ) ; dialog . add ( plotter ) ; dialog . set Size ( NUM_ , NUM_ ) ; dialog . set Location Relative To ( null ) ; dialog . set Visible ( true ) ; }
public int hash Code ( ) { return Objects . hash ( y , p , g ) ; }
public static Block Node traverse While Dominates ( Block Node dom , Block Node start ) { for ( Block Node node : start . get Clean Successors ( ) ) { if ( ! node . is Dominator ( dom ) ) { return node ; } else { Block Node out = traverse While Dominates ( dom , node ) ; if ( out != null ) { return out ; } } } return null ; }
private boolean download Files ( final List < String > files , final int size ) { update Progress Bar = new Update Progress Bar ( size , update Prop . get Property ( STR_ ) , from Version , to Version ) ; update Progress Bar . set Visible ( true ) ; for ( final String file : files ) { boolean res = download File ( file ) ; if ( ! res ) { return false ; } } update Progress Bar . dispose ( ) ; return true ; }
private void calculate Entropy ( double stop , K Star Wrapper params ) { int i , j , k ; Instance train ; double actent = NUM_ , randent = NUM_ ; double pstar , tprob , psum = NUM_ , minprob = NUM_ ; double act Class Prob , rand Class Prob ; double [ ] [ ] pseudo Class Prob = new double [ NUM RAND COLS + NUM_ ] [ m Num Classes ] ; for ( j = NUM_ ; j <= NUM RAND COLS ; j ++ ) { for ( i = NUM_ ; i < m Num Classes ; i ++ ) { pseudo Class Prob [ j ] [ i ] = NUM_ ; } } for ( i = NUM_ ; i < m Num Instances ; i ++ ) { train = m Train Set . instance ( i ) ; if ( ! train . is Missing ( m Attr Index ) ) { pstar = P Star ( m Test , train , m Attr Index , stop ) ; tprob = pstar / m Total Count ; if ( pstar < minprob ) { minprob = pstar ; } psum += tprob ; for ( k = NUM_ ; k <= NUM RAND COLS ; k ++ ) { pseudo Class Prob [ k ] [ m Rand Class Cols [ k ] [ i ] ] += tprob ; } } } for ( j = m Num Classes - NUM_ ; j >= NUM_ ; j -- ) { act Class Prob = pseudo Class Prob [ NUM RAND COLS ] [ j ] / psum ; if ( act Class Prob > NUM_ ) { actent -= act Class Prob * Math . log ( act Class Prob ) / LOG 2 ; } } for ( k = NUM_ ; k < NUM RAND COLS ; k ++ ) { for ( i = m Num Classes - NUM_ ; i >= NUM_ ; i -- ) { rand Class Prob = pseudo Class Prob [ k ] [ i ] / psum ; if ( rand Class Prob > NUM_ ) { randent -= rand Class Prob * Math . log ( rand Class Prob ) / LOG 2 ; } } } randent /= NUM RAND COLS ; params . act Entropy = actent ; params . rand Entropy = randent ; params . avg Prob = psum ; params . min Prob = minprob ; }
private static void paint Shadow ( Graphics 2 D g , Color Set color Set , Connection Drawing drawing ) { Color pre = g . get Color ( ) ; Stroke s = g . get Stroke ( ) ; if ( color Set . get Style ( ) == Widget Decorator . BLUEPRINT STYLE ) { g . set Paint ( color Set . get Background Paint ( ) ) ; g . set Stroke ( s Line Shadow Stroke ) ; } else { g . set Color ( color Set . get Shadow ( ) ) ; g . set Stroke ( color Set . get Shadow Stroke ( ) ) ; } drawing . draw ( g ) ; g . set Color ( pre ) ; g . set Stroke ( s ) ; }
public Import Task [ ] make Import Tasks ( ) { final Import Task [ ] import Tasks = new Import Task [ size ( ) ] ; int ix = NUM_ ; for ( final Import Item Base item : get Items ( ) ) { final Import Folder selected Path = ( Import Folder ) item ; import Tasks [ ix ++ ] = Import Task Factory . create Import Task ( selected Path , import Options ) ; } return import Tasks ; }
public static boolean read Boolean ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Object . get Boolean ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } boolean value = false ; if ( ! json Object . is Null ( key ) ) { value = json Object . get Boolean ( key ) ; } return value ; }
public Client Properties Builder with Client Timeout ( Integer timeout ) { properties . set Property ( CLIENT CONNECTION TIMEOUT , timeout . to String ( ) ) ; return this ; }
public static < E > Fork Join Task < E > for Each ( Collection < E > list , Predicate < E > operation ) { if ( list . size ( ) > NUM_ ) { @ Suppress Warnings ( STR_ ) E [ ] objects = list . to Array ( ( E [ ] ) new Object [ list . size ( ) ] ) ; Counted Completer < E > completer = new For Each < E > ( null , operation , NUM_ , objects . length , objects ) ; return completer ; } return null ; }
public Ltv Verifier ( Pdf Document document ) throws General Security Exception { super ( null ) ; this . document = document ; this . acro Form = Pdf Acro Form . get Acro Form ( document , true ) ; this . sgn Util = new Signature Util ( document ) ; List < String > names = sgn Util . get Signature Names ( ) ; signature Name = names . get ( names . size ( ) - NUM_ ) ; this . sign Date = Date Time Util . get Current Time Date ( ) ; pkcs 7 = covers Whole Document ( ) ; LOGGER . info ( Message Format . format ( STR_ , pkcs 7 . is Tsp ( ) ? STR_ : STR_ , signature Name ) ) ; }
public static Object normalize Int And Long Values ( String data , Data Type actual Data Type ) { if ( null == data ) { return null ; } try { Object parsed Value = null ; switch ( actual Data Type ) { case INT : parsed Value = Integer . parse Int ( data ) ; break ; case LONG : parsed Value = Long . parse Long ( data ) ; break ; default : return data ; } if ( null != parsed Value ) { return data ; } return null ; } catch ( Number Format Exception ex ) { return null ; } }
public void analyse Code ( Class Scope enclosing Class Scope ) { if ( this . ignore Further Investigation ) return ; try { update Max Field Count ( ) ; internal Analyse Code ( null , Flow Info . initial ( this . max Field Count ) ) ; } catch ( Abort Type e ) { this . ignore Further Investigation = true ; } }
public static boolean is G Zip ( Buffered Input Stream instream ) { instream . mark ( NUM_ ) ; byte [ ] b = new byte [ NUM_ ] ; try { instream . read ( b , NUM_ , NUM_ ) ; } catch ( Exception ex ) { throw new Runtime Exception ( STR_ , ex ) ; } try { instream . reset ( ) ; } catch ( Exception ex ) { throw new Runtime Exception ( STR_ , ex ) ; } return ( b [ NUM_ ] == NUM_ && b [ NUM_ ] == - NUM_ ) ; }
public void add Close Client Listener ( Close Client Listener l ) { close Client Listeners . add Element ( l ) ; }
public void init ( long skip Pointer , int df ) throws IO Exception { this . skip Pointer [ NUM_ ] = skip Pointer ; this . doc Count = df ; assert skip Pointer >= NUM_ && skip Pointer <= skip Stream [ NUM_ ] . length ( ) : STR_ + skip Pointer + STR_ + skip Stream [ NUM_ ] . length ( ) ; Arrays . fill ( skip Doc , NUM_ ) ; Arrays . fill ( num Skipped , NUM_ ) ; Arrays . fill ( child Pointer , NUM_ ) ; for ( int i = NUM_ ; i < number Of Skip Levels ; i ++ ) { skip Stream [ i ] = null ; } load Skip Levels ( ) ; }
@ Override public final boolean has Next ( ) throws IO Exception , Collection Exception { while ( ! shutting Down ) { monitor . start Function Trace ( STR_ ) ; boolean next = do Has Next ( ) ; monitor . finish Function Trace ( STR_ ) ; if ( next ) { return true ; } try { Thread . sleep ( sleep Delay ) ; } catch ( Interrupted Exception e ) { shutdown ( ) ; } } return false ; }
public void pre Deregister ( ) throws Exception { try { close ( ) ; if ( ! sequencer . try Acquire ( ) ) throw new Illegal State Exception ( STR_ ) ; try { unregister Scanners ( ) ; unregister Configs ( ) ; unregister Result Log Manager ( ) ; } finally { sequencer . release ( ) ; } } catch ( Exception x ) { LOG . log ( Level . FINEST , STR_ + x , x ) ; throw x ; } }
protected void init Tokenizer ( ) { m Tokenizer . reset Syntax ( ) ; m Tokenizer . whitespace Chars ( NUM_ , STR_ ) ; m Tokenizer . word Chars ( STR_ + NUM_ , STR_ ) ; if ( m field Separator != null ) { m Tokenizer . whitespace Chars ( m field Separator . char At ( NUM_ ) , m field Separator . char At ( NUM_ ) ) ; } else { m Tokenizer . whitespace Chars ( STR_ , STR_ ) ; } m Tokenizer . comment Char ( STR_ ) ; if ( m enclosures != null && m enclosures . size ( ) > NUM_ ) { for ( String e : m enclosures ) { m Tokenizer . quote Char ( e . char At ( NUM_ ) ) ; } } else { m Tokenizer . quote Char ( STR_ ) ; m Tokenizer . quote Char ( STR_ ) ; } m Tokenizer . ordinary Char ( STR_ ) ; m Tokenizer . ordinary Char ( STR_ ) ; m Tokenizer . eol Is Significant ( true ) ; }
public void disconnect From Bean Context ( ) throws Property Veto Exception { Bean Context bc = get Bean Context ( ) ; if ( bc != null ) { bc . remove Bean Context Membership Listener ( this ) ; bean Context Child Support . set Bean Context ( null ) ; } }
public Process execute Async ( final Command Line command , final Map < String , String > environment , final Execute Result Handler handler ) throws IO Exception { if ( working Directory != null && ! working Directory . exists ( ) ) { throw new IO Exception ( working Directory + STR_ ) ; } return execute Internal ( command , environment , working Directory , stream Handler , handler ) ; }
public void gyro Turn ( double speed , double angle ) { while ( op Mode Is Active ( ) && ! on Heading ( speed , angle , P TURN COEFF ) ) { telemetry . update ( ) ; } }
void on Show ( boolean start Dragging ) { m Last Touch X = Float . Na N ; m Last Touch Y = Float . Na N ; m Drag Scroll Offset = NUM_ ; m Drag Scroll Offset Rounded = NUM_ ; m Drag Scrolling Velocity = NUM_ ; m Is Single Tap Canceled = false ; if ( start Dragging ) m Drag Scrolling . start ( ) ; }
protected void add Image To Lists ( Image Tile image Tile , OM Graphic List ret , URL file URL ) { image Tile . generate ( get Projection ( ) ) ; ret . add ( image Tile ) ; add Image Tile To List ( image Tile ) ; image Tile . put Attribute ( FILE PATH ATTRIBUTE , file URL . get Path ( ) ) ; image Tile . put Attribute ( NAME ATTRIBUTE , file URL . get File ( ) ) ; selected Drawing Attributes . set To ( image Tile ) ; repaint ( ) ; if ( results List != null ) { results List . repaint ( ) ; } }
private static String mangled Prefix ( String s ) { return STR_ + Math . abs ( s . hash Code ( ) ) ; }
private String print O Format ( final int x ) { String sx = null ; if ( x == Integer . MIN VALUE ) { sx = STR_ ; } else if ( x < NUM_ ) { final String t = Integer . to String ( ( ~ ( - x - NUM_ ) ) ^ Integer . MIN VALUE , NUM_ ) ; switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t . substring ( NUM_ ) ; break ; } } else { sx = Integer . to String ( x , NUM_ ) ; } return print O Format ( sx ) ; }
protected boolean remove Telegram Listener ( Telegram Listener rem Listener ) { return ( Telegram Listeners . remove ( rem Listener ) ) ; }
public Object plus ( Object o ) { throw new Null Pointer Exception ( STR_ + String . value Of ( o ) ) ; }
private boolean create SCSI Initiators And Storage Ports ( Storage System storage System , String protection Domain Name , Discovered Data Object . Compatibility Status compatibility Status , String installation Id , List < Scale IO Scsi Initiator > all SCSI Initiators , List < Scale IOSDC > all SD Cs , List < Storage Port > ports ) throws IO Exception { boolean has SCSI Initiators = false ; if ( all SD Cs != null && all SCSI Initiators != null && ! all SCSI Initiators . is Empty ( ) ) { List < String > initiators To Add To Network = new Array List < > ( ) ; String network Id = String . format ( STR_ , installation Id ) ; Network network For SCSI Initiators = create IP Network For SCSI Initiators ( network Id ) ; for ( Scale IO Scsi Initiator scsi Init : all SCSI Initiators ) { String id = scsi Init . get Id ( ) ; String iqn = scsi Init . get Iqn ( ) ; Initiator initiator = create SCSI Initiator ( iqn , id ) ; if ( ! network For SCSI Initiators . has Endpoint ( initiator . get Initiator Port ( ) ) ) { initiators To Add To Network . add ( initiator . get Initiator Port ( ) ) ; } has SCSI Initiators = true ; } if ( ! initiators To Add To Network . is Empty ( ) ) { network For SCSI Initiators . add Endpoints ( initiators To Add To Network , true ) ; db Client . update And Reindex Object ( network For SCSI Initiators ) ; } List < Storage Port > i SCSI Ports = create SCSI Storage Ports ( storage System , protection Domain Name , compatibility Status , network For SCSI Initiators , all SD Cs ) ; ports . add All ( i SCSI Ports ) ; } return has SCSI Initiators ; }
public Connection Pool ( ) { this ( NUM_ , NUM_ , Time Unit . MINUTES ) ; }
public void increment Value ( T v , long increment ) { Long count = freq Table . get Or Default ( v , Long . value Of ( NUM_ ) ) ; freq Table . put ( v , Long . value Of ( count . long Value ( ) + increment ) ) ; }
public void exit ( Object monitor ) { if ( monitor == null ) { throw new Null Pointer Exception ( ) ; } List Iterator it = monitors . list Iterator ( monitors . size ( ) ) ; while ( it . has Previous ( ) ) { Object prev = it . previous ( ) ; if ( monitor == prev ) { it . remove ( ) ; return ; } } throw new Illegal Argument Exception ( ) ; }
private static void free Memory Buffers ( ) { Temp Buffers . clear Free Lists ( ) ; }
public synchronized void add Action Listener ( Action Listener listener ) { action Listeners . add Element ( listener ) ; }
@ Suppress Warnings ( { STR_ } ) private void update Local ( int p , UUID node Id , Grid Dht Partition State state , long update Seq ) { assert node Id . equals ( cctx . node Id ( ) ) ; Cluster Node oldest = CU . oldest Alive Cache Server Node ( cctx . shared ( ) , top Ver ) ; assert oldest != null || cctx . kernal Context ( ) . client Node ( ) ; if ( cctx . local Node ( ) . equals ( oldest ) ) { long seq = node 2 part . update Sequence ( ) ; if ( seq != update Seq ) { if ( seq > update Seq ) { if ( this . update Seq . get ( ) < seq ) { boolean b = this . update Seq . compare And Set ( this . update Seq . get ( ) , seq + NUM_ ) ; assert b : STR_ + update Seq + STR_ + seq + STR_ + this . update Seq . get ( ) + STR_ + node 2 part . to Full String ( ) + STR_ ; update Seq = seq + NUM_ ; } else update Seq = seq ; } node 2 part . update Sequence ( update Seq ) ; } } Grid Dht Partition Map 2 map = node 2 part . get ( node Id ) ; if ( map == null ) node 2 part . put ( node Id , map = new Grid Dht Partition Map 2 ( node Id , update Seq , top Ver , Collections . < Integer , Grid Dht Partition State > empty Map ( ) , false ) ) ; map . update Sequence ( update Seq , top Ver ) ; map . put ( p , state ) ; Set < UUID > ids = part 2 node . get ( p ) ; if ( ids == null ) part 2 node . put ( p , ids = U . new Hash Set ( NUM_ ) ) ; ids . add ( node Id ) ; }
@ Override public void draw Outline ( Graphics 2 D g 2 , Category Plot plot , Rectangle 2 D data Area ) { float x 0 = ( float ) data Area . get X ( ) ; float x 1 = x 0 + ( float ) Math . abs ( this . x Offset ) ; float x 3 = ( float ) data Area . get Max X ( ) ; float x 2 = x 3 - ( float ) Math . abs ( this . x Offset ) ; float y 0 = ( float ) data Area . get Max Y ( ) ; float y 1 = y 0 - ( float ) Math . abs ( this . y Offset ) ; float y 3 = ( float ) data Area . get Min Y ( ) ; float y 2 = y 3 + ( float ) Math . abs ( this . y Offset ) ; General Path clip = new General Path ( ) ; clip . move To ( x 0 , y 0 ) ; clip . line To ( x 0 , y 2 ) ; clip . line To ( x 1 , y 3 ) ; clip . line To ( x 3 , y 3 ) ; clip . line To ( x 3 , y 1 ) ; clip . line To ( x 2 , y 0 ) ; clip . close Path ( ) ; Stroke outline Stroke = plot . get Outline Stroke ( ) ; Paint outline Paint = plot . get Outline Paint ( ) ; if ( ( outline Stroke != null ) && ( outline Paint != null ) ) { g 2 . set Stroke ( outline Stroke ) ; g 2 . set Paint ( outline Paint ) ; g 2 . draw ( clip ) ; } }
public static Stats create And Merge From ( Stats model ) { Stats r = new Stats ( model . name , model . unit , NUM_ ) ; r . histogram = new int [ model . histogram . length ] ; System . arraycopy ( model . histogram , NUM_ , r . histogram , NUM_ , model . histogram . length ) ; r . counts = new long [ model . histogram . length ] ; r . merge ( model ) ; return r ; }
protected Map < String , Object > create Aggregate Value For Field ( String field Name , Type field Element Type ) { return Maps . new Hash Map ( ) ; }
@ Override public I Striterator add Filter ( final I Filter filter ) { if ( filters == null ) { synchronized ( this ) { if ( filters == null ) { filters = Collections . synchronized List ( new Linked List < I Filter > ( ) ) ; } } } filters . add ( filter ) ; return this ; }
public static final void remove Logging Behavior ( Logging Behavior behavior ) { synchronized ( logging Behaviors ) { logging Behaviors . remove ( behavior ) ; } }
public static void disable Clear Type ( J Component component ) { if ( System Info Utilities . get Operating System ( ) == Operating System . WINDOWS && AA TEXT PROPERTY != null ) { component . put Client Property ( AA TEXT PROPERTY , null ) ; } }
private String append Classpath ( String app Path , String lib Path ) { String s = ( app Path != null && ! app Path . is Empty ( ) ) ? app Path : STR_ ; if ( lib Path != null && ! lib Path . is Empty ( ) ) { if ( ! s . is Empty ( ) ) s += File . path Separator ; s += lib Path ; } return s ; }
public void request Emoticons ( boolean forced Update ) { if ( forced Update || ! emoticon Manager . load Emoticons ( false ) ) { String url = STR_ ; url = STR_ ; if ( attempt Request ( url , forced Update ? STR_ : STR_ ) ) { Twitch Api Request request = new Twitch Api Request ( this , Request Type . EMOTICONS , url ) ; executor . execute ( request ) ; } } }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { s . write Object ( to String ( ) ) ; }
private static void launch Elevated Creation ( final String regedit File Path ) { try { final String [ ] cmd = { STR_ , STR_ , STR_ , STR_ , regedit File Path } ; final Process Builder process Builder = new Process Builder ( cmd ) ; final Process process = process Builder . start ( ) ; process . wait For ( ) ; } catch ( IO Exception e ) { logger . warn ( STR_ , e . get Message ( ) ) ; } catch ( Exception e ) { logger . warn ( STR_ + e . get Message ( ) ) ; } }
public Wildcard ID ( String value ) { assert ( value != null && value . contains ( WILDCARD ) && value . length ( ) < NUM_ ) ; m Value = value ; try { m Pattern = Pattern . compile ( value . replace ( WILDCARD , REGEX WILDCARD ) ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STR_ + value + STR_ , e ) ; } m Weight = calculate Weight ( ) ; }
final public boolean equals ( final I Resource Metadata o ) { if ( this == o ) return true ; if ( uuid . equals ( o . get UUID ( ) ) && filename . equals ( o . get File ( ) ) && create Time == o . get Create Time ( ) ) { return true ; } return false ; }
public void add Property Change Listener ( Property Change Listener listener ) { props . add Listener ( listener ) ; }
public static List < History > find History By Job And Status ( Entity Manager em , JPA Entity job , Big Integer limit , Job Status job Status ) { require Argument ( em != null , STR_ ) ; require Argument ( job != null , STR_ ) ; Typed Query < History > query = em . create Named Query ( STR_ , History . class ) ; if ( limit != null ) { query . set Max Results ( limit . int Value ( ) ) ; } try { query . set Parameter ( STR_ , job ) ; query . set Parameter ( STR_ , job Status ) ; return query . get Result List ( ) ; } catch ( No Result Exception ex ) { return new Array List < History > ( NUM_ ) ; } }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STR_ + start Id ) ; if ( ! intent . has Extra ( EXTRA ACCOUNT ) || ! intent . has Extra ( EXTRA FILE ) ) { Log OC . e ( TAG , STR_ ) ; return START NOT STICKY ; } else { final Account account = intent . get Parcelable Extra ( EXTRA ACCOUNT ) ; final OC File file = intent . get Parcelable Extra ( EXTRA FILE ) ; Abstract List < String > requested Downloads = new Vector < String > ( ) ; try { Download File Operation new Download = new Download File Operation ( account , file ) ; new Download . add Datatransfer Progress Listener ( this ) ; new Download . add Datatransfer Progress Listener ( ( File Downloader Binder ) m Binder ) ; Pair < String , String > put Result = m Pending Downloads . put If Absent ( account . name , file . get Remote Path ( ) , new Download ) ; if ( put Result != null ) { String download Key = put Result . first ; requested Downloads . add ( download Key ) ; send Broadcast New Download ( new Download , put Result . second ) ; } } catch ( Illegal Argument Exception e ) { Log OC . e ( TAG , STR_ + e . get Message ( ) ) ; return START NOT STICKY ; } if ( requested Downloads . size ( ) > NUM_ ) { Message msg = m Service Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = requested Downloads ; m Service Handler . send Message ( msg ) ; } } return START NOT STICKY ; }
public static String fmt Date ( long ms ) { return DATE TIME . format ( new Date ( ms ) ) ; }
private void update Cell Widths ( ) { int old Cell Width = cell Width ; cell Width = RHS BORDER WIDTH ; if ( text Area != null ) { Font font = get Font ( ) ; if ( font != null ) { Font Metrics font Metrics = get Font Metrics ( font ) ; int count = NUM_ ; int line Count = text Area . get Line Count ( ) ; while ( line Count >= NUM_ ) { line Count = line Count / NUM_ ; count ++ ; } cell Width += font Metrics . char Width ( STR_ ) * ( count + NUM_ ) + NUM_ ; } } if ( cell Width != old Cell Width ) { revalidate ( ) ; } }
public List < List < String > > compute Selected Paths ( ) { List < List < String > > selected Paths = new Array List < > ( ) ; for ( int i = NUM_ , n = selected Nodes . size ( ) ; i < n ; i ++ ) { D node Data = selected Nodes . get ( i ) ; selected Paths . add ( data Adapter . get Node Path ( node Data ) ) ; } return selected Paths ; }
@ Override public boolean check ( final Certificate Token cert Token ) { List < String > extension Id List = DSSASN 1 Utils . get QC Statements Id List ( cert Token ) ; return extension Id List . contains ( qc Statement ASN 1 Id ) ; }
private static double expm 1 ( double x , double hi Prec Out [ ] ) { if ( Double . is Na N ( x ) || x == NUM_ ) { return x ; } if ( x <= - NUM_ || x >= NUM_ ) { double hi Prec [ ] = new double [ NUM_ ] ; exp ( x , NUM_ , hi Prec ) ; if ( x > NUM_ ) { return - NUM_ + hi Prec [ NUM_ ] + hi Prec [ NUM_ ] ; } else { final double ra = - NUM_ + hi Prec [ NUM_ ] ; double rb = - ( ra + NUM_ - hi Prec [ NUM_ ] ) ; rb += hi Prec [ NUM_ ] ; return ra + rb ; } } double base A ; double base B ; double epsilon ; boolean negative = false ; if ( x < NUM_ ) { x = - x ; negative = true ; } { int int Frac = ( int ) ( x * NUM_ ) ; double temp A = Exp Frac Table . EXP FRAC TABLE A [ int Frac ] - NUM_ ; double temp B = Exp Frac Table . EXP FRAC TABLE B [ int Frac ] ; double temp = temp A + temp B ; temp B = - ( temp - temp A - temp B ) ; temp A = temp ; temp = temp A * HEX 40000000 ; base A = temp A + temp - temp ; base B = temp B + ( temp A - base A ) ; epsilon = x - int Frac / NUM_ ; } double zb = NUM_ ; zb = zb * epsilon + NUM_ ; zb = zb * epsilon + NUM_ ; zb = zb * epsilon + NUM_ ; zb *= epsilon ; zb *= epsilon ; double za = epsilon ; double temp = za + zb ; zb = - ( temp - za - zb ) ; za = temp ; temp = za * HEX 40000000 ; temp = za + temp - temp ; zb += za - temp ; za = temp ; double ya = za * base A ; temp = ya + za * base B ; double yb = - ( temp - ya - za * base B ) ; ya = temp ; temp = ya + zb * base A ; yb += - ( temp - ya - zb * base A ) ; ya = temp ; temp = ya + zb * base B ; yb += - ( temp - ya - zb * base B ) ; ya = temp ; temp = ya + base A ; yb += - ( temp - base A - ya ) ; ya = temp ; temp = ya + za ; yb += - ( temp - ya - za ) ; ya = temp ; temp = ya + base B ; yb += - ( temp - ya - base B ) ; ya = temp ; temp = ya + zb ; yb += - ( temp - ya - zb ) ; ya = temp ; if ( negative ) { double denom = NUM_ + ya ; double denomr = NUM_ / denom ; double denomb = - ( denom - NUM_ - ya ) + yb ; double ratio = ya * denomr ; temp = ratio * HEX 40000000 ; final double ra = ratio + temp - temp ; double rb = ratio - ra ; temp = denom * HEX 40000000 ; za = denom + temp - temp ; zb = denom - za ; rb += ( ya - za * ra - za * rb - zb * ra - zb * rb ) * denomr ; rb += yb * denomr ; rb += - ya * denomb * denomr * denomr ; ya = - ra ; yb = - rb ; } if ( hi Prec Out != null ) { hi Prec Out [ NUM_ ] = ya ; hi Prec Out [ NUM_ ] = yb ; } return ya + yb ; }
private void add Registration Req ( Socket Channel sock Ch ) { offer Balanced ( new Nio Operation Future ( sock Ch ) ) ; }
public static Google Analytics initialise Google Analytics ( Context context , String tracker Id , final Exception Parser callback ) { m Analytics = Google Analytics . get Instance ( context ) ; m Analytics . set Local Dispatch Period ( NUM_ ) ; m Tracker = m Analytics . new Tracker ( tracker Id ) ; m Tracker . enable Exception Reporting ( true ) ; m Tracker . enable Auto Activity Tracking ( true ) ; Thread . Uncaught Exception Handler handler = Thread . get Default Uncaught Exception Handler ( ) ; if ( handler != null && handler instanceof Exception Reporter ) { Exception Reporter exception Reporter = ( Exception Reporter ) handler ; exception Reporter . set Exception Parser ( callback ) ; Thread . set Default Uncaught Exception Handler ( exception Reporter ) ; Log . d ( LOG TAG , STR_ ) ; } else { Log . e ( LOG TAG , STR_ ) ; } return m Analytics ; }
public boolean is Local Switcher ( ) { String departure Name = Train Common . split String ( get Train Departs Name ( ) ) ; Route route = get Route ( ) ; if ( route != null ) { for ( Route Location rl : route . get Locations By Sequence List ( ) ) { String name = Train Common . split String ( rl . get Name ( ) ) ; if ( ! departure Name . equals ( name ) ) { return false ; } } } return true ; }
private J Panel create Scatter Plot Dialog ( Continuous Variable y Variable , Continuous Variable x Variable ) { String dialog Title = STR_ ; J Panel panel = new J Panel ( ) ; panel . set Layout ( new Border Layout ( ) ) ; Data Set data Set = ( Data Set ) data Editor . get Selected Data Model ( ) ; Scatter Plot Old scatter Plot = new Scatter Plot Old ( data Set , y Variable , x Variable ) ; Scatter Plot Editor Panel editor Panel = new Scatter Plot Editor Panel ( scatter Plot , data Set ) ; Scatter Plot Display Panel Old display = new Scatter Plot Display Panel Old ( scatter Plot ) ; editor Panel . add Property Change Listener ( new Scatter Plot Listener ( display ) ) ; J Menu Bar bar = new J Menu Bar ( ) ; J Menu menu = new J Menu ( STR_ ) ; menu . add ( new J Menu Item ( new Save Component Image ( display , STR_ ) ) ) ; bar . add ( menu ) ; Box box = Box . create Horizontal Box ( ) ; box . add ( display ) ; box . add ( Box . create Horizontal Strut ( NUM_ ) ) ; box . add ( editor Panel ) ; box . add ( Box . create Horizontal Strut ( NUM_ ) ) ; box . add ( Box . create Horizontal Glue ( ) ) ; Box v Box = Box . create Vertical Box ( ) ; v Box . add ( Box . create Vertical Strut ( NUM_ ) ) ; v Box . add ( box ) ; v Box . add ( Box . create Vertical Strut ( NUM_ ) ) ; panel . add ( bar , Border Layout . NORTH ) ; panel . add ( v Box , Border Layout . CENTER ) ; return panel ; }
protected List < Memory Pool MX Bean > load Raw Datas ( Map < Object , Object > user Data ) { return Management Factory . get Memory Pool MX Beans ( ) ; }
public Byte Buffer create Buffer ( ) { Byte Buffer buffer = create Byte Buffer ( ) ; for ( Field field : fields ) { field . write ( buffer ) ; } buffer . flip ( ) ; return buffer ; }
public Pause Train ( int fast Minutes ) { fast Minutes = fast Minutes ; }
protected void populate ( Iterator < Edge Info > edges ) { info = new Edge Info [ num Vertices ] [ num Vertices ] ; while ( edges . has Next ( ) ) { Edge Info ei = edges . next ( ) ; ei . flow = NUM_ ; info [ ei . start ] [ ei . end ] = ei ; } }
public double local Score ( int i ) { double sum = NUM_ ; for ( B Deu Score score : scores ) { sum += score . local Score ( i ) ; } return sum / scores . size ( ) ; }
@ Override public int hash Code ( ) { return type . hash Code ( ) ; }
public Server Handshaker ( DTLS Session session , Record Layer record Layer , Session Listener session Listener , Dtls Connector Config config , int max Transmission Unit ) throws Handshake Exception { this ( NUM_ , session , record Layer , session Listener , config , max Transmission Unit ) ; }
private void append Stat String ( String text Line ) throws Ade Internal Exception { if ( stats File Path == null ) { throw new Ade Internal Exception ( STR_ ) ; } File Output Stream fos = null ; try { fos = new File Output Stream ( stats File Path , true ) ; final Print Writer writer = new Print Writer ( new Buffered Writer ( new Output Stream Writer ( fos , Standard Charsets . UTF 8 ) ) ) ; writer . println ( text Line ) ; writer . close ( ) ; } catch ( IO Exception t ) { final String msg = String . format ( STR_ , t . to String ( ) , t , stats File Path ) ; logger . error ( msg , t ) ; throw new Ade Internal Exception ( msg , t ) ; } finally { try { if ( fos != null ) { fos . close ( ) ; } } catch ( IO Exception t ) { final String msg = String . format ( STR_ , t , stats File Path ) ; logger . error ( msg , t ) ; } } }
protected void specific Processing ( Storage System storage System , Db Client db Client , WBEM Client client , Volume volume , CIM Instance volume Instance , CIM Object Path volume Path ) { String element Name = CIM Property Factory . get Property Value ( volume Instance , Smis Constants . CP ELEMENT NAME ) ; volume . set Device Label ( element Name ) ; volume . set Compression Ratio ( Smis Utils . get Compression Ratio For Volume ( volume Instance ) ) ; }
public void next Iteration ( double [ ] [ ] means ) { this . means = means ; changed = false ; final int k = means . length ; final int dim = means [ NUM_ ] . length ; centroids = new double [ k ] [ dim ] ; sizes = new int [ k ] ; Arrays . fill ( varsum , NUM_ ) ; }
public void push ( ) { Deque < Task Context > stack = context Stacks . get ( ) ; if ( stack == null ) { stack = new Linked List < > ( ) ; context Stacks . set ( stack ) ; final Thread current Thread = Thread . current Thread ( ) ; synchronized ( context Stacks Map ) { context Stacks Map . put ( current Thread , stack ) ; } } stack . add Last ( this ) ; }
private void append Rtf String ( String Builder result , String value ) { for ( int i = NUM_ ; i < value . length ( ) ; i ++ ) { int code Point = value . code Point At ( i ) ; if ( code Point == NUM_ ) { result . append ( STR_ ) ; } else if ( code Point > NUM_ ) { result . append ( STR_ + code Point + STR_ ) ; } else { result . append ( value . substring ( i , i + NUM_ ) ) ; } } }
public boolean add Journal Rollback Step ( URI rp System Id , String token ) throws Workflow Exception { Workflow Step Completer . step Succeded ( token ) ; return true ; }
boolean may Send Base Page Url ( ) { return ! is User Undecided ( ) ; }
protected int hash Entry ( final Object key , final Object value ) { return ( key == null ? NUM_ : key . hash Code ( ) ) ^ ( value == null ? NUM_ : value . hash Code ( ) ) ; }
@ Override public Instances define Data Format ( ) throws Exception { Array List < Attribute > atts ; m Random = new Random ( get Seed ( ) ) ; m Noise Random = new Random ( get Seed ( ) ) ; set Num Examples Act ( get Num Examples ( ) ) ; atts = new Array List < Attribute > ( ) ; atts . add ( new Attribute ( STR_ ) ) ; atts . add ( new Attribute ( STR_ ) ) ; m Dataset Format = new Instances ( get Relation Name To Use ( ) , atts , NUM_ ) ; return m Dataset Format ; }
public static void show Contacts On Map ( Context ctx , Set < Contact Id > contacts ) { Hash Map < String , Geoloc > map Contact Geoloc = new Hash Map < > ( ) ; Rcs Contact Util rcs Contact Util = Rcs Contact Util . get Instance ( ctx ) ; for ( Contact Id contact : contacts ) { Geoloc geoloc = get Last Geoloc ( ctx , contact ) ; if ( geoloc != null ) { map Contact Geoloc . put ( rcs Contact Util . get Display Name ( contact ) , geoloc ) ; } } Geoloc my Geoloc = get My Last Geoloc ( ctx ) ; if ( my Geoloc != null ) { map Contact Geoloc . put ( ctx . get String ( R . string . label me ) , my Geoloc ) ; } if ( map Contact Geoloc . is Empty ( ) ) { Utils . display Long Toast ( ctx , ctx . get String ( R . string . label geoloc not found ) ) ; return ; } Intent intent = new Intent ( ctx , Display Geoloc . class ) ; intent . put Extra ( Display Geoloc . EXTRA GEOLOC , map Contact Geoloc ) ; ctx . start Activity ( intent ) ; }
void write ( Image Output Stream ios ) throws IO Exception { length = NUM_ + ( ( data != null ) ? data . length : NUM_ ) ; write Tag ( ios ) ; if ( data != null ) { ios . write ( data ) ; } }
public String build Tweet Message ( Item i , int q , int p ) { String Builder message = new String Builder ( ) ; message . append ( STR_ ) ; message . append ( Grammar . quantityplnoun ( q , i . get Name ( ) , STR_ ) ) ; message . append ( STR_ ) ; message . append ( p ) ; message . append ( STR_ ) ; String stats = STR_ ; String description = i . describe ( ) ; int start = description . index Of ( STR_ ) ; if ( start > - NUM_ ) { stats = description . substring ( start ) ; } message . append ( stats ) ; return message . to String ( ) ; }
@ Deprecated public static String escape String ( String string ) { List < String > urls = new Array List < > ( ) ; Matcher matcher = URL PATTERN . matcher ( string ) ; while ( matcher . find ( ) ) { int match Start = matcher . start ( NUM_ ) ; int match End = matcher . end ( ) ; String url = string . substring ( match Start , match End ) ; urls . add ( url ) ; string = matcher . replace First ( STR_ + ( urls . size ( ) - NUM_ ) + STR_ ) ; } string = String Escape Utils . escape Json ( string ) ; for ( int i = NUM_ ; i < urls . size ( ) ; i ++ ) { string = string . replace ( STR_ + i + STR_ , STR_ + urls . get ( i ) ) ; } return string ; }
Element create Api Map ( Tree Set < String > package Names , Document output Object ) { Array List < String > already Added = new Array List < String > ( ) ; Element api Map = output Object . create Element ( STR_ ) ; String added Package = null ; String current Package = null ; Iterator < String > packages = package Names . iterator ( ) ; if ( packages == null ) { return api Map ; } while ( packages . has Next ( ) ) { current Package = packages . next ( ) ; boolean found = false ; for ( int ix = NUM_ ; ix < already Added . size ( ) ; ix ++ ) { added Package = already Added . get ( ix ) ; if ( current Package . index Of ( added Package ) == NUM_ && current Package . char At ( added Package . length ( ) ) == STR_ ) { Element api Item Ref = get Package Node ( api Map , added Package ) ; Element new Api Item Ref = output Object . create Element ( STR_ ) ; new Api Item Ref . set Attribute ( STR_ , current Package + STR_ ) ; api Item Ref . append Child ( new Api Item Ref ) ; already Added . add ( current Package ) ; found = true ; break ; } } if ( ! found ) { Element api Item Ref = output Object . create Element ( STR_ ) ; api Item Ref . set Attribute ( STR_ , current Package + STR_ ) ; api Map . append Child ( api Item Ref ) ; already Added . add ( current Package ) ; } } return api Map ; }
private void open Context Menu ( Mouse Event e ) { if ( e . is Popup Trigger ( ) ) { select Clicked ( e , false ) ; List < Stream Info > selected = get Selected Values List ( ) ; Stream Infos Context Menu m = new Stream Infos Context Menu ( selected , true ) ; for ( Context Menu Listener cml : context Menu Listeners ) { m . add Context Menu Listener ( cml ) ; } last Context Menu = m ; m . show ( this , e . get X ( ) , e . get Y ( ) ) ; } }
protected String compute ( double value ) { if ( Double . is Na N ( value ) ) { return null ; } return Tools . format Integer If Possible ( value ) ; }
private Map < UUID , Collection < Hadoop Input Split > > mappers ( Collection < Cluster Node > top , Collection < UUID > top Ids , Iterable < Hadoop Input Split > splits ) throws Ignite Checked Exception { Map < UUID , Collection < Hadoop Input Split > > mappers = new Hash Map < > ( ) ; Map < String , Collection < UUID > > nodes = group By Host ( top ) ; Map < UUID , Integer > node Loads = new Hash Map < > ( top . size ( ) , NUM_ ) ; for ( UUID node Id : top Ids ) node Loads . put ( node Id , NUM_ ) ; for ( Hadoop Input Split split : splits ) { UUID node Id = node For Split ( split , top Ids , nodes , node Loads ) ; if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + split + STR_ + node Id + STR_ ) ; Collection < Hadoop Input Split > node Splits = mappers . get ( node Id ) ; if ( node Splits == null ) { node Splits = new Array List < > ( ) ; mappers . put ( node Id , node Splits ) ; } node Splits . add ( split ) ; node Loads . put ( node Id , node Loads . get ( node Id ) + NUM_ ) ; } return mappers ; }
public Element store ( Object o ) { Portal Icon p = ( Portal Icon ) o ; if ( ! p . is Active ( ) ) { return null ; } Element element = new Element ( STR_ ) ; store Common Attributes ( p , element ) ; element . set Attribute ( STR_ , String . value Of ( p . get Scale ( ) ) ) ; element . set Attribute ( STR_ , String . value Of ( p . get Degrees ( ) ) ) ; Portal portal = p . get Portal ( ) ; if ( portal == null ) { log . info ( STR_ ) ; return null ; } element . set Attribute ( STR_ , portal . get Name ( ) ) ; if ( portal . get To Block ( ) != null ) { element . set Attribute ( STR_ , portal . get To Block Name ( ) ) ; } if ( portal . get From Block Name ( ) != null ) { element . set Attribute ( STR_ , portal . get From Block Name ( ) ) ; } element . set Attribute ( STR_ , STR_ + ( p . get Arrow Switch ( ) ? STR_ : STR_ ) ) ; element . set Attribute ( STR_ , STR_ + ( p . get Arrow Hide ( ) ? STR_ : STR_ ) ) ; element . set Attribute ( STR_ , STR_ ) ; return element ; }
public Serializable process Command ( String session ID , String command Line ) throws Exception { Command cmd = parser . parse One ( command Line ) ; if ( cmd == null ) { throw new Exception ( STR_ ) ; } String command = cmd . get Tokens ( ) [ NUM_ ] ; String [ ] params = get Params ( cmd . get Tokens ( ) , true ) ; String result = null ; if ( command . equals ( CD ) ) { String path = ( params != null ? params [ NUM_ ] : null ) ; cd ( session ID , path ) ; } else if ( command . equals ( LIST ) ) { String path = ( params != null ? params [ NUM_ ] : null ) ; Resource Node start Node = get Start Node ( session ID , path ) ; List < Resource Node > entries = ls ( session ID , path , cmd . is Recursive ( ) ) ; result = format Entries ( entries , start Node , cmd . is Long ( ) , cmd . is Absolute ( ) ) ; } else if ( command . equals ( CREATE ) ) { String path = ( params != null ? params [ NUM_ ] : null ) ; create ( session ID , path , cmd . include Parents ( ) ) ; } else if ( command . equals ( RM ) ) { String path = ( params != null ? params [ NUM_ ] : null ) ; rm ( session ID , path ) ; } else if ( command . equals ( CP ) ) { String source = ( params != null ? params [ NUM_ ] : null ) ; String destination = ( source != null && params . length == NUM_ ) ? params [ NUM_ ] : null ; cp ( session ID , source , destination ) ; } else if ( command . equals ( PWD ) ) { result = pwd ( session ID ) ; } else if ( command . equals ( CHKEXEC ) ) { String path = ( params != null ? params [ NUM_ ] : null ) ; return String . format ( STR_ , is Executable ( session ID , path ) ) ; } else if ( command . equals ( WHICH ) ) { String path = ( params != null ? params [ NUM_ ] : null ) ; return String . format ( STR_ , which ( session ID , path ) ) ; } else if ( command . equals ( CONNECT ) ) { throw new Exception ( STR_ ) ; } else if ( command . equals ( SERVICE ) ) { String service Spec = ( params != null ? params [ NUM_ ] : null ) ; String service Cmd = ( params != null && params . length > NUM_ ? params [ NUM_ ] : null ) ; return execute Extension ( Resource Type . SERVICE , service Spec , STR_ , service Cmd , null ) ; } else if ( command . equals ( LOCATE SERVICE ) ) { String service Spec = ( params != null ? params [ NUM_ ] : null ) ; String service Cmd = ( params != null && params . length > NUM_ ? params [ NUM_ ] : null ) ; return execute Extension ( Resource Type . SERVICE , service Spec , STR_ , service Cmd , null ) ; } else if ( command . equals ( EXECUTE ) ) { cmd = parser . parse One ( command Line , false ) ; params = get Params ( cmd . get Tokens ( ) , false ) ; String type = ( params != null ? params [ NUM_ ] : null ) ; String extension Name = ( params != null ? params [ NUM_ ] : null ) ; String the Command = ( params != null && params . length > NUM_ ? params [ NUM_ ] : null ) ; if ( type == null || extension Name == null || the Command == null ) { throw new Directory Exception ( String . format ( STR_ , command ) ) ; } Resource Type extension Type = Resource Type . value Of ( type . to Upper Case ( ) ) ; String arg List [ ] = null ; if ( params != null && params . length > NUM_ ) { arg List = new String [ params . length - NUM_ ] ; for ( int i = NUM_ ; i < params . length ; i ++ ) arg List [ i - NUM_ ] = params [ i ] ; } return execute Extension ( extension Type , extension Name , KEY COMMAND , the Command , arg List ) ; } else { if ( is Executable ( session ID , command ) ) { throw new Directory Exception ( String . format ( STR_ , command ) ) ; } } return result ; }
private void place Relevant Adb ( ) throws ADB Manager Exception , IO Exception { if ( OS . contains ( STR_ ) ) { String windows Path = STR_ ; adb Path = copy Assets ( windows Path , STR_ ) ; copy Assets ( windows Path , STR_ ) ; copy Assets ( windows Path , STR_ ) ; } else if ( OS . contains ( STR_ ) ) { String linux Path = STR_ ; adb Path = copy Assets ( linux Path , STR_ ) ; } else if ( OS . contains ( STR_ ) ) { String mac Path = STR_ ; adb Path = copy Assets ( mac Path , STR_ ) ; } else { throw new ADB Manager Exception ( STR_ ) ; } }
public void register On Toolbar Group Changed Listener ( On Toolbar Group Changed Listener listener ) { for ( int i = m Listeners . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Weak Reference < On Toolbar Group Changed Listener > ref = m Listeners . get ( i ) ; if ( ref . get ( ) == null ) m Listeners . remove ( i ) ; else if ( ref . get ( ) == listener ) return ; } m Listeners . add ( new Weak Reference < On Toolbar Group Changed Listener > ( listener ) ) ; }
public static void register Provider ( Crash Info Provider prov ) { providers . add ( prov ) ; }
@ Caller Sensitive public static < U > Atomic Integer Field Updater < U > new Updater ( Class < U > tclass , String field Name ) { return new Atomic Integer Field Updater Impl < U > ( tclass , field Name , Reflection . get Caller Class ( ) ) ; }
public Month Date Format ( Locale locale ) { this ( Time Zone . get Default ( ) , locale , NUM_ , true , false ) ; }
public static synchronized String generate Segment Name ( ) { try { Thread . sleep ( NUM_ ) ; } catch ( Throwable t ) { } return sdf . format ( new Date ( System . current Time Millis ( ) ) ) ; }
static String to Hex ( byte [ ] data ) { String Buffer sb = new String Buffer ( data . length * NUM_ ) ; for ( int i = NUM_ ; i < data . length ; i ++ ) { sb . append ( hexc [ ( data [ i ] > > NUM_ ) & NUM_ ] ) ; sb . append ( hexc [ data [ i ] & NUM_ ] ) ; } return sb . to String ( ) ; }
public boolean do Mouse Dragged ( Positionable selection , Mouse Event event ) { if ( edit Circuit Frame != null || edit Paths Frame != null ) { return true ; } if ( edit Portal Frame != null || edit Direction Frame != null ) { if ( selection instanceof Portal Icon ) { editor . highlight ( selection ) ; return false ; } return true ; } return false ; }
JSON Object to Rest ( Parse Encoder encoder ) { State state ; List < Parse Operation Set > operation Set Queue Copy ; synchronized ( mutex ) { state = get State ( ) ; int operation Set Queue Size = operation Set Queue . size ( ) ; operation Set Queue Copy = new Array List < > ( operation Set Queue Size ) ; for ( int i = NUM_ ; i < operation Set Queue Size ; i ++ ) { Parse Operation Set original = operation Set Queue . get ( i ) ; Parse Operation Set copy = new Parse Operation Set ( original ) ; operation Set Queue Copy . add ( copy ) ; } } return to Rest ( state , operation Set Queue Copy , encoder ) ; }
public void draw Node ( Graphics g , int w , int h ) { if ( ( m type & OUTPUT ) == OUTPUT ) { g . set Color ( Color . orange ) ; } else { g . set Color ( Color . red ) ; } g . fill Oval ( ( int ) ( m x * w ) - NUM_ , ( int ) ( m y * h ) - NUM_ , NUM_ , NUM_ ) ; g . set Color ( Color . gray ) ; g . fill Oval ( ( int ) ( m x * w ) - NUM_ , ( int ) ( m y * h ) - NUM_ , NUM_ , NUM_ ) ; }
public static Forbidden Graph Model serializable Instance ( ) { return new Forbidden Graph Model ( new Parameters ( ) , Graph Wrapper . serializable Instance ( ) ) ; }
public void init ( ) { if ( ! initialized ) { super . init ( ) ; detect Panel = new Detection Panel ( this ) ; J Panel panel = new J Panel ( ) ; panel . set Layout ( new Box Layout ( panel , Box Layout . Y AXIS ) ) ; panel . add ( Box . create Vertical Glue ( ) ) ; panel . add ( detect Panel ) ; add ( panel , NUM_ ) ; } }
private String lookup Local Address ( ) { long timeout = NUM_ * NUM_ ; long expire Time = Current Time . current Time ( ) + timeout ; String address ; while ( ( address = allocate Local Address ( ) ) == null && Current Time . current Time ( ) < expire Time ) { try { Thread . sleep ( NUM_ ) ; } catch ( Exception e ) { } } if ( address == null ) { throw new Config Exception ( L . l ( STR_ + STR_ + STR_ , server Bartender . get Id ( ) , server Bartender . get Address ( ) ) ) ; } return address ; }
public Object Analysis analyze Object ( Mat object ) throws Illegal Argument Exception { Mat descriptors = new Mat ( ) ; Mat Of Key Point keypoints = new Mat Of Key Point ( ) ; Log . d ( STR_ , STR_ ) ; if ( object == null || object . empty ( ) ) { throw new Illegal Argument Exception ( STR_ ) ; } detector . detect ( object , keypoints ) ; extractor . compute ( object , keypoints , descriptors ) ; return new Object Analysis ( keypoints , descriptors , object ) ; }
public Analyze Graph ( Analyze Type analyze Type , mx Analysis Graph a Graph ) { this . analyze Type = analyze Type ; this . a Graph = a Graph ; }
private Tombstone Service . State create Tomb Stone State ( String availability Zone ) { Tombstone Service . State tomb Stone State = new Tombstone Service . State ( ) ; tomb Stone State . entity Id = Service Utils . get ID From Document Self Link ( availability Zone ) ; tomb Stone State . entity Kind = AVAILABILITY ZONE ENTITY KIND ; tomb Stone State . tombstone Time = System . current Time Millis ( ) ; return tomb Stone State ; }
public static float round Decimal ( float value , double places ) { double multiplier = Math . pow ( NUM_ , places ) ; value *= multiplier ; return ( float ) ( Math . round ( value ) / multiplier ) ; }
public void connection Error Occurred ( Connection Event event ) { if ( is Active ) { Managed Connection conn = ( Managed Connection ) event . get Source ( ) ; XA Resource xar = ( XA Resource ) xa Resources Map . get ( conn ) ; xa Resources Map . remove ( conn ) ; Transaction Manager Impl trans Manager = Transaction Manager Impl . get Transaction Manager ( ) ; try { Transaction txn = trans Manager . get Transaction ( ) ; if ( txn != null && xar != null ) txn . delist Resource ( xar , XA Resource . TMSUCCESS ) ; } catch ( System Exception se ) { se . print Stack Trace ( ) ; } try { mann Pool Cache . expire Pooled Connection ( conn ) ; } catch ( Exception ex ) { String exception = STR_ + ex ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( exception , ex ) ; } } } }
public List simulate ( ) { List [ ] val = new List [ NUM_ ] ; for ( int i = NUM_ ; i >= NUM_ ; i -- ) { Village v = forward [ i ] ; if ( v != null ) { val [ i ] = v . simulate ( ) ; } } for ( int i = NUM_ ; i >= NUM_ ; i -- ) { List l = val [ i ] ; if ( l != null ) { for ( Enumeration e = l . elements ( ) ; e . has More Elements ( ) ; ) { Patient p = ( Patient ) e . next Element ( ) ; hospital . put In Hospital ( p ) ; } } } hospital . check Patients Inside ( returned ) ; List up = hospital . check Patients Assess ( this ) ; hospital . check Patients Waiting ( ) ; Patient p = generate Patient ( ) ; if ( p != null ) { hospital . put In Hospital ( p ) ; } return up ; }
public void initialize ( Callbacks callbacks ) { synchronized ( m Lock ) { unbind Item Infos And Clear Queued Bind Runnables ( ) ; m Callbacks = new Weak Reference < Callbacks > ( callbacks ) ; } }
public static Print Writer new Print Writer ( Path self ) throws IO Exception { return new Groovy Print Writer ( new Writer ( self ) ) ; }
void confirm Adapter Available ( Object o ) { String adapter = adapter Name ( o ) ; log . debug ( STR_ , o , adapter ) ; if ( adapter != null ) { try { Class . for Name ( adapter ) ; } catch ( Class Not Found Exception ex ) { locate Class Failed ( ex , adapter , o ) ; } catch ( No Class Def Found Error ex ) { locate Class Failed ( ex , adapter , o ) ; } } }
public Element parse ( Reader is ) { buff Offset = NUM_ ; buff Size = - NUM_ ; event Parser = false ; Element root Element = create New Element ( STR_ ) ; try { parse Tag Content ( root Element , is ) ; } catch ( IO Exception ioe ) { ioe . print Stack Trace ( ) ; } if ( root Element . get Num Children ( ) == NUM_ ) { notify Error ( Parser Callback . ERROR NO ROOTS , null , null , null , STR_ ) ; return null ; } else if ( root Element . get Num Children ( ) > NUM_ ) { String roots = STR_ ; for ( int i = NUM_ ; i < root Element . get Num Children ( ) ; i ++ ) { Element elem = root Element . get Child At ( i ) ; if ( elem . is Text Element ( ) ) { roots += STR_ + elem . get Text ( ) + STR_ ; } else { roots += elem . get Tag Name ( ) + STR_ ; } } if ( roots . ends With ( STR_ ) ) { roots = roots . substring ( NUM_ , roots . length ( ) - NUM_ ) ; } Element first Root = root Element . get Child At ( NUM_ ) ; String str = null ; if ( first Root . is Text Element ( ) ) { str = STR_ + first Root . get Text ( ) ; } else { str = first Root . get Tag Name ( ) ; } notify Error ( Parser Callback . ERROR MULTIPLE ROOTS , null , null , null , STR_ + str + STR_ + roots ) ; } root Element = root Element . get Child At ( NUM_ ) ; return root Element ; }
public void unload Queue ( Response response ) { for ( Cookie cookie : this . queue ) { response . add Header ( STR_ , cookie . get HTTP Header ( ) ) ; } }
private void adjust Children To Group Change ( ) { int index = NUM_ ; Decimal Rectangle temp Bounds ; for ( Math Object math Obj : get Objects ( ) ) { temp Bounds = object Bounds . get ( index ) ; math Obj . setx Pos ( getx Pos ( ) + ( int ) Math . round ( temp Bounds . get X ( ) * get Width ( ) ) ) ; math Obj . sety Pos ( gety Pos ( ) + ( int ) Math . round ( temp Bounds . get Y ( ) * get Height ( ) ) ) ; math Obj . set Width ( ( int ) Math . round ( temp Bounds . get Width ( ) * get Width ( ) ) ) ; math Obj . set Height ( ( int ) Math . round ( temp Bounds . get Height ( ) * get Height ( ) ) ) ; if ( math Obj . get Width ( ) == NUM_ ) { math Obj . set Width ( NUM_ ) ; } if ( math Obj . get Height ( ) == NUM_ ) { math Obj . set Height ( NUM_ ) ; } index ++ ; } }
private J List < Configurable > create New Configurable J List ( String source ) { final J List < Configurable > created Config List = new J List < > ( ) ; created Config List . set Model ( source == null ? local Config List Model : remote Config List Models . get ( source ) ) ; created Config List . set Cell Renderer ( new Configurable Renderer ( ) ) ; created Config List . set Fixed Cell Height ( NUM_ ) ; created Config List . set Selection Mode ( List Selection Model . SINGLE SELECTION ) ; created Config List . set Background ( LIGHTER GRAY ) ; return created Config List ; }
@ Override public Buffered Image create Drop Shadow ( Buffered Image source ) { Buffered Image subject = new Buffered Image ( source . get Width ( ) + this . shadow Size * NUM_ , source . get Height ( ) + this . shadow Size * NUM_ , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g 2 = subject . create Graphics ( ) ; g 2 . draw Image ( source , null , this . shadow Size , this . shadow Size ) ; g 2 . dispose ( ) ; apply Shadow ( subject ) ; return subject ; }
boolean bind Element ( String ns , String wildcard , Action Set actions ) { Namespace Specification nss = new Namespace Specification ( ns , wildcard ) ; if ( nss Element Map . get ( nss ) != null ) return false ; for ( Enumeration e = nss Element Map . keys ( ) ; e . has More Elements ( ) ; ) { Namespace Specification nss I = ( Namespace Specification ) e . next Element ( ) ; if ( nss . compete ( nss I ) ) { return false ; } } nss Element Map . put ( nss , actions ) ; return true ; }
public void write Entity To NBT ( NBT Tag Compound p 70014 1 ) { p 70014 1 . set Short ( STR_ , ( short ) this . field 145791 d ) ; p 70014 1 . set Short ( STR_ , ( short ) this . field 145792 e ) ; p 70014 1 . set Short ( STR_ , ( short ) this . field 145789 f ) ; p 70014 1 . set Short ( STR_ , ( short ) this . ticks In Ground ) ; p 70014 1 . set Byte ( STR_ , ( byte ) Block . get Id From Block ( this . field 145790 g ) ) ; p 70014 1 . set Byte ( STR_ , ( byte ) this . in Data ) ; p 70014 1 . set Byte ( STR_ , ( byte ) this . arrow Shake ) ; p 70014 1 . set Byte ( STR_ , ( byte ) ( this . in Ground ? NUM_ : NUM_ ) ) ; p 70014 1 . set Byte ( STR_ , ( byte ) this . can Be Picked Up ) ; p 70014 1 . set Double ( STR_ , this . damage ) ; }
protected void visiting URL ( String url ) { if ( track Visited UR Ls ) { if ( visited UR Ls == null ) { visited UR Ls = new Vector ( ) ; } if ( ! visited UR Ls . contains ( url ) ) { visited UR Ls . add Element ( url ) ; } } }
protected void scale To ( Projection this Proj ) { if ( DEBUG ) { logger . fine ( STR_ ) ; } if ( bitmap == null ) { if ( DEBUG ) { logger . fine ( STR_ ) ; } return ; } if ( no Scaling Required ) { return ; } Rectangle proj Rect = new Rectangle ( ) ; proj Rect . set Location ( point 1 ) ; proj Rect . set Size ( point 2 . x - point 1 . x , point 2 . y - point 1 . y ) ; Rectangle source Rect = new Rectangle ( ) ; source Rect . width = width ; source Rect . height = height ; clip Rect = null ; if ( ! proj Rect . is Empty ( ) ) { if ( ( proj Rect . width >= NUM_ ) && ( proj Rect . height >= NUM_ ) ) { if ( source Rect . width <= NUM_ ) { source Rect . width = NUM_ ; } if ( source Rect . height <= NUM_ ) { source Rect . height = NUM_ ; } double width Adj = ( double ) proj Rect . width / ( double ) source Rect . width ; double height Adj = ( double ) proj Rect . height / ( double ) source Rect . height ; Affine Transform xform = new Affine Transform ( ) ; xform . set To Scale ( width Adj , height Adj ) ; this . scaling X Form Op = new Affine Transform Op ( xform , get Scale Transform Type ( ) ) ; } } }
public static String escape String ( final String string ) { if ( string . index Of ( DELIMITER COMPONENT ) < NUM_ ) { final int length = string . length ( ) ; final String Buffer buffer = new String Buffer ( length + NUM_ ) ; for ( int index = NUM_ ; index < length ; index ++ ) { final char character = string . char At ( index ) ; if ( DELIMITER COMPONENT == character ) buffer . append ( DELIMITER COMPONENT ) ; buffer . append ( character ) ; } return buffer . to String ( ) ; } return string ; }
public void add Active Handler ( Content Handler handler , Mode Usage attribute Mode Usage ) { active Handlers . add Element ( handler ) ; active Handlers Attribute Mode Usage . add Element ( attribute Mode Usage ) ; attribute Processing = Math . max ( attribute Processing , attribute Mode Usage . get Attribute Processing ( ) ) ; if ( attribute Mode Usage . is Context Dependent ( ) ) context Dependent = true ; }
private boolean is Zookeeper Leader ( String node IP , int port ) { try { Socket sock = new Socket ( ) ; sock . connect ( new Inet Socket Address ( node IP , port ) , NUM_ ) ; sock . close ( ) ; return true ; } catch ( IO Exception ex ) { log . warn ( STR_ , ex . to String ( ) ) ; } return false ; }
protected void notify Measurement Period ( ) { trim Time = System . current Time Millis ( ) ; trim Values = read Values ( ( int [ ] ) null ) ; }
private String print D Format ( String sx ) { int n Leading Zeros = NUM_ ; int n Blanks = NUM_ , n = NUM_ ; int i = NUM_ , j First = NUM_ ; boolean neg = sx . char At ( NUM_ ) == STR_ ; if ( sx . equals ( STR_ ) && precision Set && precision == NUM_ ) sx = STR_ ; if ( ! neg ) { if ( precision Set && sx . length ( ) < precision ) n Leading Zeros = precision - sx . length ( ) ; } else { if ( precision Set && ( sx . length ( ) - NUM_ ) < precision ) n Leading Zeros = precision - sx . length ( ) + NUM_ ; } if ( n Leading Zeros < NUM_ ) n Leading Zeros = NUM_ ; if ( field Width Set ) { n Blanks = field Width - n Leading Zeros - sx . length ( ) ; if ( ! neg && ( leading Sign || leading Space ) ) n Blanks -- ; } if ( n Blanks < NUM_ ) n Blanks = NUM_ ; if ( leading Sign ) n ++ ; else if ( leading Space ) n ++ ; n += n Blanks ; n += n Leading Zeros ; n += sx . length ( ) ; char [ ] ca = new char [ n ] ; if ( left Justify ) { if ( neg ) ca [ i ++ ] = STR_ ; else if ( leading Sign ) ca [ i ++ ] = STR_ ; else if ( leading Space ) ca [ i ++ ] = STR_ ; char [ ] csx = sx . to Char Array ( ) ; j First = neg ? NUM_ : NUM_ ; for ( int j = NUM_ ; j < n Leading Zeros ; i ++ , j ++ ) ca [ i ] = STR_ ; for ( int j = j First ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; for ( int j = NUM_ ; j < n Blanks ; i ++ , j ++ ) ca [ i ] = STR_ ; } else { if ( ! leading Zeros ) { for ( i = NUM_ ; i < n Blanks ; i ++ ) ca [ i ] = STR_ ; if ( neg ) ca [ i ++ ] = STR_ ; else if ( leading Sign ) ca [ i ++ ] = STR_ ; else if ( leading Space ) ca [ i ++ ] = STR_ ; } else { if ( neg ) ca [ i ++ ] = STR_ ; else if ( leading Sign ) ca [ i ++ ] = STR_ ; else if ( leading Space ) ca [ i ++ ] = STR_ ; for ( int j = NUM_ ; j < n Blanks ; j ++ , i ++ ) ca [ i ] = STR_ ; } for ( int j = NUM_ ; j < n Leading Zeros ; j ++ , i ++ ) ca [ i ] = STR_ ; char [ ] csx = sx . to Char Array ( ) ; j First = neg ? NUM_ : NUM_ ; for ( int j = j First ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; } return new String ( ca ) ; }
public static void generate Push All Registers ( final I Translation Environment environment , final long base Offset , final Operand Size size , final List < Reil Instruction > instructions ) throws Illegal Argument Exception { Preconditions . check Not Null ( environment , STR_ ) ; Preconditions . check Not Null ( size , STR_ ) ; Preconditions . check Not Null ( instructions , STR_ ) ; Preconditions . check Argument ( ( size == Operand Size . WORD ) || ( size == Operand Size . DWORD ) , STR_ ) ; long offset = base Offset ; final Operand Size arch Size = environment . get Architecture Size ( ) ; final String temp Esp = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create Str ( offset , arch Size , STR_ , arch Size , temp Esp ) ) ; generate Register Push ( environment , offset + NUM_ , STR_ , size , instructions ) ; offset = base Offset + instructions . size ( ) ; generate Register Push ( environment , offset , STR_ , size , instructions ) ; offset = base Offset + instructions . size ( ) ; generate Register Push ( environment , offset , STR_ , size , instructions ) ; offset = base Offset + instructions . size ( ) ; generate Register Push ( environment , offset , STR_ , size , instructions ) ; offset = base Offset + instructions . size ( ) ; generate Register Push ( environment , offset , temp Esp , size , instructions ) ; offset = base Offset + instructions . size ( ) ; generate Register Push ( environment , offset , STR_ , size , instructions ) ; offset = base Offset + instructions . size ( ) ; generate Register Push ( environment , offset , STR_ , size , instructions ) ; offset = base Offset + instructions . size ( ) ; generate Register Push ( environment , offset , STR_ , size , instructions ) ; offset = base Offset + instructions . size ( ) ; }
private void fully Unlock ( ) { take Lock . unlock ( ) ; put Lock . unlock ( ) ; }
public static boolean create Inventory ( M Acct Schema as , int AD Org ID , int M Product ID , int M Attribute Set Instance ID , int M Inventory Line ID , int M Cost Element ID , Big Decimal Amt , Big Decimal Qty , String Description , String trx Name ) { String sql = STR_ + STR_ + STR_ + M Inventory Line ID + STR_ + as . get C Acct Schema ID ( ) + STR_ + M Attribute Set Instance ID ; int no = DB . execute Update ( sql , trx Name ) ; if ( no != NUM_ ) s log . config ( STR_ + no ) ; M Cost Detail cd = get ( as . get Ctx ( ) , STR_ , M Inventory Line ID , M Attribute Set Instance ID , as . get C Acct Schema ID ( ) , trx Name ) ; if ( cd == null ) { cd = new M Cost Detail ( as , AD Org ID , M Product ID , M Attribute Set Instance ID , M Cost Element ID , Amt , Qty , Description , trx Name ) ; cd . set M Inventory Line ID ( M Inventory Line ID ) ; } else { cd . set Delta Amt ( Amt . subtract ( cd . get Amt ( ) ) ) ; cd . set Delta Qty ( Qty . subtract ( cd . get Qty ( ) ) ) ; if ( cd . is Delta ( ) ) { cd . set Processed ( false ) ; cd . set Amt ( Amt ) ; cd . set Qty ( Qty ) ; } else return true ; } boolean ok = cd . save ( ) ; if ( ok && ! cd . is Processed ( ) ) { M Client client = M Client . get ( as . get Ctx ( ) , as . get AD Client ID ( ) ) ; if ( client . is Cost Immediate ( ) ) cd . process ( ) ; } s log . config ( STR_ + ok + STR_ + cd ) ; return ok ; }
private static Event < RP Entity > create Events For RP Entity ( RP Entity entity , RP Event rpevent ) { String name = rpevent . get Name ( ) ; Event < RP Entity > event = null ; if ( name . equals ( Events . PUBLIC TEXT ) ) { event = new Public Text Event ( ) ; } else if ( name . equals ( Events . PRIVATE TEXT ) ) { event = new Private Text Event ( ) ; } else if ( name . equals ( Events . ATTACK ) ) { event = new Attack Event ( ) ; } else if ( name . equals ( Events . TRADE STATE CHANGE ) ) { event = new Trade State Change Event ( ) ; } else if ( name . equals ( Events . GROUP CHANGE ) ) { event = new Group Change Event ( ) ; } else if ( name . equals ( Events . GROUP INVITE ) ) { event = new Group Invite Event ( ) ; } else if ( name . equals ( Events . PROGRESS STATUS CHANGE ) ) { event = new Progress Status Event ( ) ; } else if ( name . equals ( Events . REACHED ACHIEVEMENT ) ) { event = new Reached Achievement Event ( ) ; } if ( event != null ) { event . init ( entity , rpevent ) ; } return event ; }
protected Handshaker ( boolean is Client , DTLS Session session , Record Layer record Layer , Session Listener session Listener , Certificate [ ] root Certificates , int max Transmission Unit ) { this ( is Client , NUM_ , session , record Layer , session Listener , root Certificates , max Transmission Unit ) ; }
protected void init Class ( ) { if ( sample Class == null ) { try { sample Class = Class . for Name ( sample Class Params . class Name ) ; } catch ( Class Not Found Exception e ) { throw new Runtime Exception ( sample Class Params . class Name + STR_ ) ; } } }
private boolean show File Chooser ( ) { Class dst Category = Destination . class ; Destination dst = ( Destination ) as Current . get ( dst Category ) ; if ( dst == null ) { dst = ( Destination ) as Original . get ( dst Category ) ; if ( dst == null ) { dst = ( Destination ) ps Current . get Default Attribute Value ( dst Category ) ; if ( dst == null ) { try { dst = new Destination ( new URI ( STR_ ) ) ; } catch ( URI Syntax Exception e ) { } } } } File file Dest ; if ( dst != null ) { try { file Dest = new File ( dst . get URI ( ) ) ; } catch ( Exception e ) { file Dest = new File ( STR_ ) ; } } else { file Dest = new File ( STR_ ) ; } Validating File Chooser jfc = new Validating File Chooser ( ) ; jfc . set Approve Button Text ( get Msg ( STR_ ) ) ; jfc . set Dialog Title ( get Msg ( STR_ ) ) ; jfc . set Dialog Type ( J File Chooser . SAVE DIALOG ) ; jfc . set Selected File ( file Dest ) ; int return Val = jfc . show Dialog ( this , null ) ; if ( return Val == J File Chooser . APPROVE OPTION ) { file Dest = jfc . get Selected File ( ) ; try { as Current . add ( new Destination ( file Dest . to URI ( ) ) ) ; } catch ( Exception e ) { as Current . remove ( dst Category ) ; } } else { as Current . remove ( dst Category ) ; } return ( return Val == J File Chooser . APPROVE OPTION ) ; }
public State Monitor Tab ( GUI Frame main Frame ) { set Layout ( new Border Layout ( ) ) ; this . main Frame = main Frame ; states = new Hash Map < String , Dialogue State > ( ) ; J Panel left Panel = create Left Side ( ) ; visualisation = new State Viewer ( this ) ; log Area = create Log Area ( ) ; J Scroll Pane log Scroll = new J Scroll Pane ( log Area ) ; log Scroll . set Border ( Border Factory . create Empty Border ( ) ) ; J Split Pane top Panel = new J Split Pane ( J Split Pane . HORIZONTAL SPLIT , left Panel , visualisation . wrap With Scroll Pane ( ) ) ; top Panel . set Divider Location ( NUM_ ) ; J Split Pane full Panel = new J Split Pane ( J Split Pane . VERTICAL SPLIT , top Panel , log Scroll ) ; full Panel . set Divider Location ( NUM_ ) ; add ( full Panel ) ; configure Key Inputs ( ) ; record State ( new Dialogue State ( ) , CURRENT ) ; list Model . add ( NUM_ , STR_ ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Plum Needle ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } return true ; }
@ Request Mapping ( method = Request Method . POST ) Response Entity < Bookmark > add Bookmark ( @ Path Variable ( value = STR_ ) String username , @ Request Body Bookmark bookmark ) throws User Not Found Exception { Optional < User > optional = users Repository . find By Username ( username ) ; if ( optional . is Present ( ) ) { User user = optional . get ( ) ; user . add Bookmark ( bookmark ) ; bookmark . set User ( user ) ; bookmarks Repository . save ( bookmark ) ; return new Response Entity < > ( bookmark , Http Status . CREATED ) ; } else { throw new User Not Found Exception ( username ) ; } }
protected void draw Range Markers ( Graphics 2 D g 2 , Rectangle 2 D data Area , int index , Layer layer ) { Category Item Renderer r = get Renderer ( index ) ; if ( r == null ) { return ; } Collection markers = get Range Markers ( index , layer ) ; Value Axis axis = get Range Axis For Dataset ( index ) ; if ( markers != null && axis != null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . has Next ( ) ) { Marker marker = ( Marker ) iterator . next ( ) ; r . draw Range Marker ( g 2 , this , axis , marker , data Area ) ; } } }
private void calc Coordinates ( ) { if ( CTM [ NUM_ ] [ NUM_ ] == NUM_ && CTM [ NUM_ ] [ NUM_ ] == NUM_ ) { i x = ( int ) CTM [ NUM_ ] [ NUM_ ] ; i y = ( int ) CTM [ NUM_ ] [ NUM_ ] ; i w = ( int ) CTM [ NUM_ ] [ NUM_ ] ; i h = ( int ) CTM [ NUM_ ] [ NUM_ ] ; if ( i w < NUM_ ) { i w = - i w ; } if ( i h < NUM_ ) { i h = - i h ; } } else { i w = ( int ) ( Math . sqrt ( ( CTM [ NUM_ ] [ NUM_ ] * CTM [ NUM_ ] [ NUM_ ] ) + ( CTM [ NUM_ ] [ NUM_ ] * CTM [ NUM_ ] [ NUM_ ] ) ) ) ; i h = ( int ) ( Math . sqrt ( ( CTM [ NUM_ ] [ NUM_ ] * CTM [ NUM_ ] [ NUM_ ] ) + ( CTM [ NUM_ ] [ NUM_ ] * CTM [ NUM_ ] [ NUM_ ] ) ) ) ; if ( CTM [ NUM_ ] [ NUM_ ] > NUM_ && CTM [ NUM_ ] [ NUM_ ] < NUM_ ) { i x = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; i y = ( int ) ( CTM [ NUM_ ] [ NUM_ ] + CTM [ NUM_ ] [ NUM_ ] ) ; } else if ( CTM [ NUM_ ] [ NUM_ ] < NUM_ && CTM [ NUM_ ] [ NUM_ ] > NUM_ ) { i x = ( int ) ( CTM [ NUM_ ] [ NUM_ ] + CTM [ NUM_ ] [ NUM_ ] ) ; i y = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; } else if ( CTM [ NUM_ ] [ NUM_ ] > NUM_ && CTM [ NUM_ ] [ NUM_ ] > NUM_ ) { i x = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; i y = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; } else { i x = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; i y = ( int ) ( CTM [ NUM_ ] [ NUM_ ] ) ; } } if ( CTM [ NUM_ ] [ NUM_ ] < NUM_ ) { i y -= i h ; } if ( CTM [ NUM_ ] [ NUM_ ] < NUM_ ) { i x -= i w ; } }
public SQ Lite Table Builder ( SQ Lite Database database , String table Name ) { if ( database == null ) { throw new Illegal Argument Exception ( STR_ ) ; } else if ( Text Utils . is Empty ( table Name ) ) { throw new Illegal Argument Exception ( STR_ ) ; } else if ( ! table Name . matches ( REGEX SQL IDENTIFIER ) ) { throw new Illegal Argument Exception ( STR_ ) ; } m Database = database ; m String Builder = new String Builder ( ) ; m String Builder . append ( CREATE TABLE ) ; m String Builder . append ( table Name ) ; m String Builder . append ( OPEN PAREN ) ; }
public static Intent create Open Browser Intent ( String url ) { if ( ! url . contains ( STR_ ) ) { url = STR_ + url ; } return new Intent ( Intent . ACTION VIEW , Uri . parse ( url ) ) ; }
public Argument ( final String primary Form , final boolean arg Required , final String ... parameter Names ) { forms . add ( primary Form ) ; param Names = parameter Names ; required = arg Required ; }
public File Process Controller ( final File Controller Parameters arguments , final int pid , final long timeout , final Time Unit units ) { if ( pid < NUM_ ) { throw new Illegal Argument Exception ( STR_ + pid + STR_ ) ; } this . pid = pid ; this . arguments = arguments ; this . status Timeout Millis = units . to Millis ( timeout ) ; }
public static Recipe Brew register Brew Recipe ( Brew brew , Object ... inputs ) { Preconditions . check Argument ( inputs . length <= NUM_ ) ; Recipe Brew recipe = new Recipe Brew ( brew , inputs ) ; brew Recipes . add ( recipe ) ; return recipe ; }
public void add Key Value ( String key , Object value ) { keys . add ( key ) ; resources . set Theme Property ( theme Name , key , value ) ; Collections . sort ( keys ) ; int row = keys . index Of ( key ) ; fire Table Rows Inserted ( row , row ) ; refresh Theme ( ) ; }
void case Action ( Node Representation node Rep ) { make Proof ( node Rep , false , false ) ; }
public static void mark Cacheable Forever ( Http Servlet Response response ) { long expires After Millis = System . current Time Millis ( ) + ONE YEAR MILLIS ; response . set Header ( Servlet Constants . HTTP PRAGMA , STR_ ) ; response . set Date Header ( Servlet Constants . HTTP EXPIRES , expires After Millis ) ; response . set Header ( Servlet Constants . HTTP CACHE CONTROL , Servlet Constants . HTTP CACHE CONTROL PRIVATE ) ; response . add Header ( Servlet Constants . HTTP CACHE CONTROL , Servlet Constants . HTTP CACHE CONTROL MAX AGE + ONE YEAR MILLIS ) ; }
public void unregister Listener ( Js File Loaded Listener listener ) { listeners . remove ( listener ) ; }
public static < U , W > Atomic Reference Field Updater < U , W > new Atomic Reference Field Updater ( Class < U > t Class , Class < W > v Class , String field Name ) { try { return new Unsafe Atomic Reference Field Updater < > ( J Unsafe . get Unsafe ( ) , t Class , field Name ) ; } catch ( Throwable t ) { return Atomic Reference Field Updater . new Updater ( t Class , v Class , field Name ) ; } }
public void smooth Scroll Content To ( int target Offset , float velocity ) { set Current State ( STATE SCROLL ) ; int distance = target Offset - m Current Content Offset ; velocity = Math . abs ( velocity ) ; int duration = NUM_ ; if ( velocity > NUM_ ) { duration = NUM_ * Math . round ( NUM_ * Math . abs ( distance / velocity ) ) ; } duration = Math . min ( duration , MAX DURATION ) ; m Scroller . abort Animation ( ) ; m Scroller . start Scroll ( m Current Content Offset , NUM_ , distance , NUM_ , duration ) ; invalidate ( ) ; }
public void recycle ( boolean initial , int width , int height , int top Margin ) { if ( initial ) { y = rand Range ( top Margin , height ) ; } else { y = height + ( rand Range ( NUM_ , NUM_ ) - NUM_ ) ; } x = rand Range ( NUM_ , width ) ; radius = NUM_ ; max Radius = rand Range ( NUM_ , BUBBLE SIZE ) ; paint . set Alpha ( rand Range ( NUM_ , NUM_ ) ) ; popped = false ; step = NUM_ ; amp = Math . random ( ) * NUM_ ; freq = Math . random ( ) * NUM_ ; skew = Math . random ( ) - NUM_ ; }
private void update Zoning Map ( Un Managed Export Mask mask , List < com . emc . storageos . db . client . model . Initiator > initiators , List < com . emc . storageos . db . client . model . Storage Port > storage Ports ) { Zone Info Map zoning Map = network Device Controller . get Initiators Zone Info Map ( initiators , storage Ports ) ; for ( Zone Info zone Info : zoning Map . values ( ) ) { log . info ( STR_ , zone Info . get Zone Name ( ) , zone Info . get Initiator Wwn ( ) , zone Info . get Port Wwn ( ) ) ; } mask . set Zoning Map ( zoning Map ) ; }
public byte [ ] bitcoin Serialize ( ) { if ( header Bytes Valid && transaction Bytes Valid ) { Preconditions . check Not Null ( bytes , STR_ ) ; if ( length == bytes . length ) { return bytes ; } else { byte [ ] buf = new byte [ length ] ; System . arraycopy ( bytes , offset , buf , NUM_ , length ) ; return buf ; } } Byte Array Output Stream stream = new Unsafe Byte Array Output Stream ( length == UNKNOWN LENGTH ? HEADER SIZE + guess Transactions Length ( ) : length ) ; try { write Header ( stream ) ; write Transactions ( stream ) ; } catch ( IO Exception e ) { } return stream . to Byte Array ( ) ; }
public void add Exclude Glob ( final String pattern ) { exclude Globs . add ( STR_ + pattern ) ; }
public void add Event Listener ( Z Wave Event Listener event Listener ) { synchronized ( zwave Event Listeners ) { if ( zwave Event Listeners . contains ( event Listener ) ) { logger . debug ( STR_ , event Listener ) ; return ; } zwave Event Listeners . add ( event Listener ) ; } }
private void ensure Capacity ( int value ) { if ( value >= Bits . get Max ( bits ) ) { int [ ] new Bits = Bits . make Bit Set ( Math . max ( value + NUM_ , NUM_ * Bits . get Max ( bits ) ) ) ; System . arraycopy ( bits , NUM_ , new Bits , NUM_ , bits . length ) ; bits = new Bits ; } }
public Scale IO Storage Pool query Storage Pool ( String pool Id ) throws Exception { Client Response response = get ( URI . create ( Scale IO Constants . get Storage Pool Stats URI ( pool Id ) ) ) ; Scale IO Storage Pool pool = get Response Object ( Scale IO Storage Pool . class , response ) ; Scale IO Storage Pool pool Stats = get Storage Pool Stats ( pool Id ) ; pool . set Capacity Available For Volume Allocation In Kb ( pool Stats . get Capacity Available For Volume Allocation In Kb ( ) ) ; pool . set Max Capacity In Kb ( pool Stats . get Max Capacity In Kb ( ) ) ; return pool ; }
public static Uri create File Uri ( String path ) { if ( path . starts With ( STR_ ) ) { return Uri . parse ( path ) ; } return Uri . from File ( new File ( path ) ) ; }
private void generate ( Index index ) throws SAX Exception { if ( index == null ) { return ; } Attributes Impl atts = new Attributes Impl ( ) ; if ( index instanceof Index Creation Data ) { Index Creation Data index Data = ( Index Creation Data ) index ; atts . add Attribute ( STR_ , STR_ , NAME , STR_ , index Data . get Index Name ( ) ) ; String index Type = index Data . get Index Type ( ) ; if ( index Type . equals ( STR_ ) ) { atts . add Attribute ( STR_ , STR_ , KEY INDEX , STR_ , STR_ ) ; } else { if ( index Type . equals ( STR_ ) ) { index Type = HASH INDEX TYPE ; } else { index Type = RANGE INDEX TYPE ; } atts . add Attribute ( STR_ , STR_ , KEY INDEX , STR_ , STR_ ) ; atts . add Attribute ( STR_ , STR_ , INDEX TYPE , STR_ , STR_ + index Type ) ; } atts . add Attribute ( STR_ , STR_ , FROM CLAUSE , STR_ , index Data . get Index From Clause ( ) ) ; atts . add Attribute ( STR_ , STR_ , EXPRESSION , STR_ , index Data . get Index Expression ( ) ) ; } else { atts . add Attribute ( STR_ , STR_ , NAME , STR_ , index . get Name ( ) ) ; if ( index instanceof Primary Key Index ) { atts . add Attribute ( STR_ , STR_ , KEY INDEX , STR_ , STR_ ) ; } else { atts . add Attribute ( STR_ , STR_ , KEY INDEX , STR_ , STR_ ) ; String index Type = STR_ ; if ( index instanceof Hash Index ) { index Type = STR_ ; } atts . add Attribute ( STR_ , STR_ , INDEX TYPE , STR_ , STR_ + index Type ) ; } atts . add Attribute ( STR_ , STR_ , FROM CLAUSE , STR_ , index . get From Clause ( ) ) ; atts . add Attribute ( STR_ , STR_ , EXPRESSION , STR_ , index . get Indexed Expression ( ) ) ; } handler . start Element ( STR_ , INDEX , INDEX , atts ) ; handler . end Element ( STR_ , INDEX , INDEX ) ; }
private String linkify Deadlock Info ( String line ) { if ( line != null && line . index Of ( STR_ ) >= NUM_ ) { String begin = line . substring ( NUM_ , line . index Of ( STR_ ) ) ; int object Begin = line . last Index Of ( STR_ ) ; int monitor Begin = line . index Of ( STR_ ) ; String monitor Hex = line . substring ( monitor Begin , monitor Begin + NUM_ ) ; String monitor = line . substring ( object Begin , object Begin + NUM_ ) ; String end = line . substring ( line . index Of ( STR_ ) + NUM_ ) ; monitor = STR_ + monitor + STR_ + monitor Hex + STR_ ; return ( begin + monitor + end ) ; } else { return ( line ) ; } }
private static byte [ ] compute Digest ( File file ) throws IO Exception { Input Stream is = null ; try { is = new File Input Stream ( file ) ; return Digest Utils . md 5 ( is ) ; } finally { if ( is != null ) { is . close ( ) ; } } }
@ Override public void close ( ) { synchronized ( this . lock ) { if ( is Preview ) { page Images . add Element ( preview Image ) ; pagenum = NUM_ ; display Page ( ) ; } if ( page != null ) { page . dispose ( ) ; } if ( job != null ) { job . end ( ) ; } } }
private static boolean is Two Dates Present In Required Range ( Date seg Date 1 , Date seg Date 2 , long number Of Days Allowed To Merge ) { if ( seg Date 1 == null || seg Date 2 == null ) { return false ; } Calendar cal 1 = Calendar . get Instance ( ) ; cal 1 . set ( seg Date 1 . get Year ( ) , seg Date 1 . get Month ( ) , seg Date 1 . get Date ( ) ) ; Calendar cal 2 = Calendar . get Instance ( ) ; cal 2 . set ( seg Date 2 . get Year ( ) , seg Date 2 . get Month ( ) , seg Date 2 . get Date ( ) ) ; long diff = cal 2 . get Time In Millis ( ) - cal 1 . get Time In Millis ( ) ; if ( ( diff / ( NUM_ * NUM_ * NUM_ * NUM_ ) ) < number Of Days Allowed To Merge ) { return true ; } return false ; }
protected Rpf Cache Handler sweep Caches ( ) { if ( caches . size ( ) < max Users ) { return null ; } long diff = Long . MAX VALUE ; Enumeration keys = timestamps . keys ( ) ; Object get Rid = null ; while ( keys . has More Elements ( ) ) { Object tester = keys . next Element ( ) ; Long time = ( Long ) timestamps . get ( tester ) ; if ( time . long Value ( ) < diff ) { get Rid = tester ; diff = time . long Value ( ) ; } } boolean DEBUG = false ; if ( get Rid != null ) { if ( Debug . debugging ( STR_ ) ) { DEBUG = true ; } if ( DEBUG ) Debug . output ( STR_ + caches . size ( ) ) ; caches . remove ( get Rid ) ; timestamps . remove ( get Rid ) ; view Attribute Lists . remove ( get Rid ) ; if ( DEBUG ) Debug . output ( STR_ + caches . size ( ) ) ; } if ( caches . size ( ) >= max Users ) { return sweep Caches ( ) ; } else { return ( Rpf Cache Handler ) get Rid ; } }
private int count Acl By Entry ( final int acl , final ACL Entry entry ) { return entry . count ACL ( ) ^ acl ; }
public String TO CHAR ( String column Name , int display Type , String AD Language ) { String Buffer ret Value = new String Buffer ( STR_ ) ; ret Value . append ( column Name ) ; ret Value . append ( STR_ ) ; return ret Value . to String ( ) ; }
public static String prt Indent ( int indent , String str ) { return ( spaces . substring ( NUM_ , Math . min ( indent * NUM_ , spaces . length ( ) ) ) + str ) ; }
private void launch And Wait ( ) { try { launch Count . increment And Get ( ) ; launcher . execute And Wait ( ) ; } catch ( Throwable e ) { e . print Stack Trace ( ) ; } }
private Pla Line Int smoothen non integer corner ( Pla Line Int Alist p line arr , int p no ) { Pla Line Int prev line = p line arr . get ( p no ) ; Pla Line Int next line = p line arr . get ( p no + NUM_ ) ; if ( prev line . is equal or opposite ( next line ) ) { return null ; } if ( ! ( prev line . is diagonal ( ) && next line . is diagonal ( ) ) ) { return null ; } Pla Point Float curr corner = prev line . intersection approx ( next line ) ; Pla Point Float prev corner = prev line . intersection approx ( p line arr . get ( p no - NUM_ ) ) ; Pla Point Float next corner = next line . intersection approx ( p line arr . get ( p no + NUM_ ) ) ; Pla Line Int result = null ; int new x = NUM_ ; int new y = NUM_ ; boolean new line is vertical = false ; boolean new line is horizontal = false ; if ( prev corner . v x > curr corner . v x && next corner . v x > curr corner . v x ) { new x = ( int ) Math . ceil ( curr corner . v x ) ; new y = ( int ) Math . ceil ( curr corner . v y ) ; new line is vertical = true ; } else if ( prev corner . v x < curr corner . v x && next corner . v x < curr corner . v x ) { new x = ( int ) Math . floor ( curr corner . v x ) ; new y = ( int ) Math . floor ( curr corner . v y ) ; new line is vertical = true ; } else if ( prev corner . v y > curr corner . v y && next corner . v y > curr corner . v y ) { new x = ( int ) Math . ceil ( curr corner . v x ) ; new y = ( int ) Math . ceil ( curr corner . v y ) ; new line is horizontal = true ; } else if ( prev corner . v y < curr corner . v y && next corner . v y < curr corner . v y ) { new x = ( int ) Math . floor ( curr corner . v x ) ; new y = ( int ) Math . floor ( curr corner . v y ) ; new line is horizontal = true ; } Pla Direction new line dir = null ; if ( new line is vertical ) { if ( prev corner . v y < next corner . v y ) { new line dir = Pla Direction . UP ; } else { new line dir = Pla Direction . DOWN ; } } else if ( new line is horizontal ) { if ( prev corner . v x < next corner . v x ) { new line dir = Pla Direction . RIGHT ; } else { new line dir = Pla Direction . LEFT ; } } else { return null ; } Pla Point Int line a = new Pla Point Int ( new x , new y ) ; result = new Pla Line Int ( line a , new line dir ) ; return result ; }
public Point 2 D inverse Transform ( Point 2 D view Point ) { Point 2 D view Center = get View Center ( ) ; double view Radius = get View Radius ( ) ; double ratio = get Ratio ( ) ; double dx = view Point . get X ( ) - view Center . get X ( ) ; double dy = view Point . get Y ( ) - view Center . get Y ( ) ; dx *= ratio ; Point 2 D point From Center = new Point 2 D . Double ( dx , dy ) ; Polar Point polar = Polar Point . cartesian To Polar ( point From Center ) ; double radius = polar . get Radius ( ) ; if ( radius > view Radius ) return delegate . inverse Transform ( view Point ) ; double mag = magnification ; radius /= mag ; polar . set Radius ( radius ) ; Point 2 D projected Point = Polar Point . polar To Cartesian ( polar ) ; projected Point . set Location ( projected Point . get X ( ) / ratio , projected Point . get Y ( ) ) ; Point 2 D translated Back = new Point 2 D . Double ( projected Point . get X ( ) + view Center . get X ( ) , projected Point . get Y ( ) + view Center . get Y ( ) ) ; return delegate . inverse Transform ( translated Back ) ; }
public int hash Code ( ) { return pattern . hash Code ( ) ; }
@ Request Mapping ( value = STR_ , method = Request Method . GET , params = Shared . PASSWORD ENTRY ) public String sso Default Tenant Password Entry ( Locale locale , Model model , Http Servlet Request request , Http Servlet Response response ) throws IO Exception { logger . info ( STR_ + STR_ + locale . to String ( ) + STR_ ) ; return sso Password Entry ( locale , Shared . get Default Tenant ( ) , model , request , response ) ; }
private List < Entry > reduce With Douglas Peuker ( List < Entry > entries , double epsilon ) { if ( epsilon <= NUM_ || entries . size ( ) < NUM_ ) { return entries ; } keep [ NUM_ ] = true ; keep [ entries . size ( ) - NUM_ ] = true ; algorithm Douglas Peucker ( entries , epsilon , NUM_ , entries . size ( ) - NUM_ ) ; List < Entry > reduced Entries = new Array List < Entry > ( ) ; for ( int i = NUM_ ; i < entries . size ( ) ; i ++ ) { if ( keep [ i ] ) { Entry cur Entry = entries . get ( i ) ; reduced Entries . add ( new Entry ( cur Entry . get Val ( ) , cur Entry . get X Index ( ) ) ) ; } } return reduced Entries ; }
public static double ln Func ( double num ) { if ( num <= NUM_ ) { return NUM_ ; } else { if ( num < MAX INT FOR CACHE PLUS ONE ) { int n = ( int ) num ; if ( ( double ) n == num ) { return INT N LOG N CACHE [ n ] ; } } return num * Math . log ( num ) ; } }
private static Object compress Non Decimal Max Min ( Data Type changed Data Type , double [ ] value , int decimal , double max Value ) { int i = NUM_ ; switch ( changed Data Type ) { case DATA BYTE : byte [ ] result = new byte [ value . length ] ; for ( double a : value ) { result [ i ] = ( byte ) ( Math . round ( ( max Value - a ) * Math . pow ( NUM_ , decimal ) ) ) ; i ++ ; } return result ; case DATA SHORT : short [ ] short Result = new short [ value . length ] ; for ( double a : value ) { short Result [ i ] = ( byte ) ( Math . round ( ( max Value - a ) * Math . pow ( NUM_ , decimal ) ) ) ; i ++ ; } return short Result ; case DATA INT : int [ ] int Result = new int [ value . length ] ; for ( double a : value ) { int Result [ i ] = ( byte ) ( Math . round ( ( max Value - a ) * Math . pow ( NUM_ , decimal ) ) ) ; i ++ ; } return int Result ; case DATA LONG : long [ ] long Result = new long [ value . length ] ; for ( double a : value ) { long Result [ i ] = ( byte ) ( Math . round ( ( max Value - a ) * Math . pow ( NUM_ , decimal ) ) ) ; i ++ ; } return long Result ; case DATA FLOAT : float [ ] float Result = new float [ value . length ] ; for ( double a : value ) { float Result [ i ] = ( byte ) ( Math . round ( ( max Value - a ) * Math . pow ( NUM_ , decimal ) ) ) ; i ++ ; } return float Result ; default : double [ ] default Result = new double [ value . length ] ; for ( double a : value ) { default Result [ i ] = ( byte ) ( Math . round ( ( max Value - a ) * Math . pow ( NUM_ , decimal ) ) ) ; i ++ ; } return default Result ; } }
public boolean is Popup Menu Item Selected ( ) { return popup Menu Group . get Selection ( ) != null ; }
default Lazy Future Stream < U > control ( final Function < Supplier < U > , Supplier < U > > fn ) { final Queue queue = to Queue ( ) ; return from Stream ( queue . stream Control ( get Subscription ( ) , fn ) ) ; }
public void unregister Receiver ( Context context ) { m Handler . remove Callbacks ( m Service Runnable ) ; if ( m Is Registered . get And Set ( false ) ) { context . unregister Receiver ( this ) ; m Need To Run Actions . set ( false ) ; } }
public void push ( Namespace namespace ) { namespace Stack . add ( namespace ) ; namespace Cache List . add ( null ) ; current Namespace Cache = null ; String prefix = namespace . get Prefix ( ) ; if ( ( prefix == null ) || ( prefix . length ( ) == NUM_ ) ) { default Namespace = namespace ; } }
private void append Type Parameter Signatures Label ( String [ ] type Param Sigs , String Builder builder ) { if ( type Param Sigs . length > NUM_ ) { builder . append ( get LT ( ) ) ; for ( int i = NUM_ ; i < type Param Sigs . length ; i ++ ) { if ( i > NUM_ ) { builder . append ( Java Element Labels . COMMA STRING ) ; } builder . append ( Signature . get Type Variable ( type Param Sigs [ i ] ) ) ; } builder . append ( get GT ( ) ) ; } }
public < T , X extends Throwable > T reserve Resources ( String account Id , List < Resource Impl > resources , Resource Usage Operation < T , X > operation ) throws X , Not Found Exception , Server Exception , Conflict Exception { final Lock lock = RESOURCES LOCKS . get ( account Id ) ; lock . lock ( ) ; try { List < Resource Impl > available Resources = do Get Available Resources ( account Id ) ; resource Aggregator . deduct ( available Resources , resources ) ; return operation . use ( ) ; } finally { lock . unlock ( ) ; } }
public static void use Internal Frames ( J Root Pane root Pane ) { if ( root Pane != null ) { use Internal Frames ( root Pane . get Layered Pane ( ) ) ; } else { use Internal Frames ( ( J Layered Pane ) null ) ; } }
public static Number Object Data Set serializable Instance ( ) { return new Number Object Data Set ( NUM_ , new Linked List < Node > ( ) ) ; }
protected Injector create Injector ( List < Module > modules ) { return Guice . create Injector ( modules ) ; }
private void start Unsubscription For Monitoring ( Set < String > passive Providers Change Set ) { for ( String smis Provider Uri : passive Providers Change Set ) { if ( connection Factory . unsubscribe SMI Provider Connection ( smis Provider Uri ) ) { ACTIVE SMIS PROVIDERS CACHE . remove ( smis Provider Uri ) ; logger . info ( STR_ , smis Provider Uri ) ; } else { logger . error ( STR_ + STR_ , smis Provider Uri ) ; } } }
public Set < Long > key Set ( ) { Hash Set < Long > set = new Hash Set < Long > ( ) ; for ( Segment < V > s : segments ) { set . add All ( s . key Set ( ) ) ; } return set ; }
public void add Callback Push ( I Callback callback ) { callbacks Push . add ( callback ) ; }
public static void main ( String [ ] args ) { Timer timer = new Timer ( STR_ ) ; Timer overall Timer = new Timer ( STR_ ) ; timer . show Times ( NUM_ ) ; overall Timer . start ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { timer . start ( ) ; try { Thread . sleep ( i * NUM_ ) ; } catch ( Interrupted Exception e ) { } timer . stop ( true ) ; } overall Timer . stop ( ) ; timer . show Times ( overall Timer . get Current Time ( ) ) ; overall Timer . show Times ( ) ; }
public static void save Run Outputs ( Scenario scenario ) { log . info ( STR_ ) ; Urban Sim Parameter Config Module V 3 usp Module = M 4 U Config Utils . get Urban Sim Parameter Config And Possibly Convert ( scenario . get Config ( ) ) ; int current Year = usp Module . get Year ( ) ; String save Directory = STR_ + current Year ; String save Path = Paths . check Path Ending ( usp Module . get MAT Sim 4 Opus Backup ( ) + save Directory ) ; File save Dir = new File ( save Path ) ; if ( ! save Dir . exists ( ) ) if ( ! save Dir . mkdirs ( ) ) log . error ( STR_ + save Path + STR_ ) ; throw new Runtime Exception ( STR_ + STR_ + STR_ ) ; }
public void add Pie Segment ( int data Index , float value , float start Angle , float angle ) { m Pie Segment List . add ( new Pie Segment ( data Index , value , start Angle , angle ) ) ; }
public void add System Properties ( String sys Prop ) { if ( sys Prop == null ) return ; List < String > list Sys Prop = Executor Utils . tokenize ( sys Prop , null ) ; for ( String sp : list Sys Prop ) { String [ ] pv = sp . split ( STR_ ) ; system Prop . put ( pv [ NUM_ ] , pv [ NUM_ ] ) ; } }
public static String format Reddit Url ( String url ) { url = url . replace First ( STR_ , STR_ ) ; if ( url . matches ( STR_ ) ) { String subdomain = url . split ( STR_ , NUM_ ) [ NUM_ ] ; String domain Regex = STR_ + subdomain + STR_ ; if ( subdomain . equals Ignore Case ( STR_ ) ) { url = url . replace First ( domain Regex , STR_ ) ; url = STR_ + url ; } else if ( subdomain . matches ( STR_ ) ) { return STR_ ; } else if ( subdomain . matches ( STR_ ) ) { url = url . replace First ( domain Regex , STR_ ) ; } else { url = url . replace First ( domain Regex , STR_ + subdomain ) ; } } if ( url . starts With ( STR_ ) ) url = STR_ + url ; if ( url . ends With ( STR_ ) ) url = url . substring ( NUM_ , url . length ( ) - NUM_ ) ; if ( url . matches ( STR_ ) ) { url = url . replace First ( STR_ , STR_ ) ; } return url ; }
void flush Edt ( ) { if ( ! is Edt ( ) ) { return ; } while ( ! should EDT Sleep No Form Animation ( ) ) { edt Loop Impl ( ) ; } while ( animation Queue != null && animation Queue . size ( ) > NUM_ ) { edt Loop Impl ( ) ; } }
protected void select Auto Tick Unit ( Graphics 2 D g 2 , Rectangle 2 D data Area , Rectangle Edge edge ) { if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { select Horizontal Auto Tick Unit ( g 2 , data Area , edge ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { select Vertical Auto Tick Unit ( g 2 , data Area , edge ) ; } }
void remove From Free List ( ) { if ( m free List != null ) { m free List . remove ( this ) ; m free Waiting = true ; } }
public static Transformer create Ttml Transformer ( String xslt ) { Transformer Factory tf = Transformer Factory . new Instance ( XSLT 2 TRANSFORMER IMPLEMENTATION , null ) ; Input Stream transformation Stream = Resource Helper . get Resource Input Stream ( xslt ) ; if ( transformation Stream == null ) { throw new Convert Exception ( String . format ( STR_ , xslt ) ) ; } try { return tf . new Transformer ( new Stream Source ( transformation Stream ) ) ; } catch ( Transformer Configuration Exception e ) { throw new Convert Exception ( e ) ; } }
Index Creation Response ( Internal Distributed System ds , Set recipients ) { super ( ds , recipients ) ; }
@ Override public boolean on Touch Event ( Motion Event motionevent ) { if ( motionevent . get Action ( ) == NUM_ ) { request Focus ( ) ; if ( underlined ) { start Animation ( ) ; } show Keyboard ( ) ; } return super . on Touch Event ( motionevent ) ; }
public static boolean equal Or Contain ( String s 1 , String s 2 , boolean contain ) { return contain ? s 1 . contains ( s 2 ) : s 1 . equals ( s 2 ) ; }
protected void do Reset Current Position ( ) { this . current Position = this . position ; }
@ Override public void run ( ) { am I Active = true ; String dem Header = null ; String upslope Area Creek Header = null ; String output Header = null ; int num Rows ; int num Cols ; double elevation , elevation Neighbour ; int x , y ; double slope , max Slope ; int flow Dir ; int i ; List < Stream Flow > stream Flow List = new Array List < > ( ) ; List < Stream Flow > copy Stream Flow List ; Stream Flow stream Flow 2 ; List < Double > upstream Values = new Array List < > ( ) ; float progress = NUM_ ; if ( args . length <= NUM_ ) { show Feedback ( STR_ ) ; return ; } for ( i = NUM_ ; i < args . length ; i ++ ) { if ( i == NUM_ ) { dem Header = args [ i ] ; } else if ( i == NUM_ ) { upslope Area Creek Header = args [ i ] ; } else if ( i == NUM_ ) { output Header = args [ i ] ; } } if ( ( dem Header == null ) || ( upslope Area Creek Header == null ) || ( output Header == null ) ) { show Feedback ( STR_ ) ; return ; } try { dem = new Whitebox Raster ( dem Header , STR_ ) ; upslope Area Creek = new Whitebox Raster ( upslope Area Creek Header , STR_ ) ; num Rows = dem . get Number Rows ( ) ; num Cols = dem . get Number Columns ( ) ; grid Res = dem . get Cell Size X ( ) ; median Upstream Area = new Whitebox Raster ( output Header , STR_ , dem Header , Whitebox Raster . Data Type . FLOAT , NUM_ ) ; median Upstream Area . set Preferred Palette ( STR_ ) ; median Upstream Area . set Data Scale ( Whitebox Raster Base . Data Scale . CONTINUOUS ) ; median Upstream Area . set Z Units ( STR_ ) ; tmp Direct Upstream Creek Cell Count = new Whitebox Raster ( output Header . replace ( STR_ , STR_ ) , STR_ , dem Header , Whitebox Raster . Data Type . FLOAT , NUM_ ) ; tmp Direct Upstream Creek Cell Count . is Temporary File = true ; update Progress ( STR_ , NUM_ ) ; for ( int row = NUM_ ; row < num Rows ; row ++ ) { for ( int col = NUM_ ; col < num Cols ; col ++ ) { if ( upslope Area Creek . get Value ( row , col ) == upslope Area Creek . get No Data Value ( ) ) { median Upstream Area . set Value ( row , col , upslope Area Creek . get No Data Value ( ) ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * row / ( num Rows - NUM_ ) ) ; update Progress ( STR_ , ( int ) progress ) ; } update Progress ( STR_ , NUM_ ) ; for ( int row = NUM_ ; row < num Rows ; row ++ ) { for ( int col = NUM_ ; col < num Cols ; col ++ ) { max Slope = Double . MIN VALUE ; flow Dir = - NUM_ ; if ( upslope Area Creek . get Value ( row , col ) > NUM_ ) { elevation = dem . get Value ( row , col ) ; for ( int c = NUM_ ; c < NUM_ ; c ++ ) { x = col + xd [ c ] ; y = row + yd [ c ] ; elevation Neighbour = dem . get Value ( y , x ) ; if ( upslope Area Creek . get Value ( y , x ) > NUM_ && elevation Neighbour < elevation ) { slope = ( elevation - elevation Neighbour ) / dd [ c ] ; if ( slope > max Slope ) { max Slope = slope ; flow Dir = c ; } } } for ( int c = NUM_ ; c < NUM_ ; c ++ ) { if ( c == flow Dir ) { x = col + xd [ c ] ; y = row + yd [ c ] ; tmp Direct Upstream Creek Cell Count . increment Value ( y , x , NUM_ ) ; stream Flow List . add ( new Stream Flow ( col , row , x , y , elevation ) ) ; } } } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * row / ( num Rows - NUM_ ) ) ; update Progress ( STR_ , ( int ) progress ) ; } stream Flow List = Order Stream Flow List ( stream Flow List ) ; copy Stream Flow List = new Array List < > ( stream Flow List . sub List ( NUM_ , stream Flow List . size ( ) ) ) ; update Progress ( STR_ , NUM_ ) ; for ( Stream Flow stream Flow : stream Flow List ) { i = stream Flow List . index Of ( stream Flow ) ; if ( median Upstream Area . get Value ( stream Flow . Get To Y ( ) , stream Flow . Get To X ( ) ) == NUM_ ) { upstream Values = new Array List < > ( ) ; Filter Stream Flow List ( copy Stream Flow List , stream Flow ) ; Make Upstream List ( copy Stream Flow List , stream Flow . Get To X ( ) , stream Flow . Get To Y ( ) , upstream Values ) ; Collections . sort ( upstream Values ) ; median Upstream Area . set Value ( stream Flow . Get To Y ( ) , stream Flow . Get To X ( ) , Get Median ( upstream Values ) ) ; stream Flow 2 = stream Flow ; while ( ( tmp Direct Upstream Creek Cell Count . get Value ( stream Flow 2 . Get To Y ( ) , stream Flow 2 . Get To X ( ) ) == NUM_ ) & ( upstream Values . size ( ) > NUM_ ) ) { upstream Values . remove ( upslope Area Creek . get Value ( stream Flow 2 . Get To Y ( ) , stream Flow 2 . Get To X ( ) ) ) ; median Upstream Area . set Value ( stream Flow 2 . Get From Y ( ) , stream Flow 2 . Get From X ( ) , Get Median ( upstream Values ) ) ; x = stream Flow 2 . Get From X ( ) ; y = stream Flow 2 . Get From Y ( ) ; for ( Stream Flow temp Stream Flow : copy Stream Flow List ) { if ( temp Stream Flow . Get To X ( ) == x && temp Stream Flow . Get To Y ( ) == y ) { stream Flow 2 = temp Stream Flow ; break ; } } } if ( tmp Direct Upstream Creek Cell Count . get Value ( stream Flow 2 . Get From Y ( ) , stream Flow 2 . Get From X ( ) ) == NUM_ ) { x = stream Flow 2 . Get From X ( ) ; y = stream Flow 2 . Get From Y ( ) ; median Upstream Area . set Value ( y , x , upslope Area Creek . get Value ( y , x ) ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * ( i + NUM_ ) / stream Flow List . size ( ) ) ; update Progress ( STR_ , ( int ) progress ) ; } median Upstream Area . add Metadata Entry ( STR_ + get Descriptive Name ( ) + STR_ ) ; median Upstream Area . add Metadata Entry ( STR_ + new Date ( ) ) ; dem . close ( ) ; upslope Area Creek . close ( ) ; median Upstream Area . close ( ) ; tmp Direct Upstream Creek Cell Count . close ( ) ; return Data ( output Header ) ; } catch ( Exception e ) { show Feedback ( e . get Message ( ) ) ; } finally { update Progress ( STR_ , NUM_ ) ; am I Active = false ; my Host . plugin Complete ( ) ; } }
private void render Axes ( Camera camera ) { gl Push Matrix ( ) ; gl Load Identity ( ) ; float rot X = camera . get Rotation ( ) . x ; float rot Y = camera . get Rotation ( ) . y ; float rot Z = NUM_ ; gl Rotatef ( rot X , NUM_ , NUM_ , NUM_ ) ; gl Rotatef ( rot Y , NUM_ , NUM_ , NUM_ ) ; gl Rotatef ( rot Z , NUM_ , NUM_ , NUM_ ) ; gl Line Width ( NUM_ ) ; gl Begin ( GL LINES ) ; gl Color 3 f ( NUM_ , NUM_ , NUM_ ) ; gl Vertex 3 f ( NUM_ , NUM_ , NUM_ ) ; gl Vertex 3 f ( NUM_ , NUM_ , NUM_ ) ; gl Color 3 f ( NUM_ , NUM_ , NUM_ ) ; gl Vertex 3 f ( NUM_ , NUM_ , NUM_ ) ; gl Vertex 3 f ( NUM_ , NUM_ , NUM_ ) ; gl Color 3 f ( NUM_ , NUM_ , NUM_ ) ; gl Vertex 3 f ( NUM_ , NUM_ , NUM_ ) ; gl Vertex 3 f ( NUM_ , NUM_ , NUM_ ) ; gl End ( ) ; gl Pop Matrix ( ) ; }
@ Override public boolean is Visible ( ) { return false ; }
public Partitioned Region Rebalance Op ( Partitioned Region region , boolean simulate , Rebalance Director director , boolean replace Offline Data , boolean is Rebalance ) { this ( region , simulate , director , replace Offline Data , is Rebalance , new Atomic Boolean ( ) , null ) ; }
private static State next ( final Input Stream stream , final State state , final Byte Array Output Stream line ) throws IO Exception { final int next = stream . read ( ) ; if ( next == - NUM_ ) { throw new IO Exception ( STR_ ) ; } final State result ; switch ( state ) { case NORMAL : result = next Normal ( state , line , next ) ; break ; case R : if ( next == STR_ ) { result = State . END ; } else { throw new IO Exception ( String . format ( STR_ , STR_ , STR_ ) ) ; } break ; case QUOTED STRING : result = next Quoted ( stream , state , line , next ) ; break ; default : throw new Illegal State Exception ( STR_ ) ; } return result ; }
public boolean should Log On Null Set ( String lhs , String rhs ) { if ( lhs . equals ( STR_ ) ) return false ; return true ; }
public Query where Contains ( Contact . Field field , Object value ) { add New Constraint ( field , Where . contains ( field . get Column ( ) , value ) ) ; return this ; }
void lightweight Paint ( Graphics g ) { paint ( g ) ; }
private void check Permissions ( String process Definition Key , Namespace Permission Enum [ ] permissions ) { Job Definition Alternate Key Dto job Definition Key = job Definition Helper . get Job Definition Key ( process Definition Key ) ; namespace Security Helper . check Permission ( job Definition Key . get Namespace ( ) , permissions ) ; }
private Recycler View . Item Decoration parse Transforms ( String raw ) { if ( raw == null ) { return null ; } float scale X = NUM_ , scale Y = NUM_ ; int translate X = NUM_ , translate Y = NUM_ ; float opacity = NUM_ ; int rotate = NUM_ ; Matcher matcher = transform Pattern . matcher ( raw ) ; while ( matcher . find ( ) ) { String match = matcher . group ( ) ; String name = matcher . group ( NUM_ ) ; try { switch ( name ) { case STR_ : scale X = Float . parse Float ( matcher . group ( NUM_ ) ) ; scale Y = Float . parse Float ( matcher . group ( NUM_ ) ) ; break ; case STR_ : translate X = Integer . parse Int ( matcher . group ( NUM_ ) ) ; translate Y = Integer . parse Int ( matcher . group ( NUM_ ) ) ; break ; case STR_ : opacity = Float . parse Float ( matcher . group ( NUM_ ) ) ; break ; case STR_ : rotate = Integer . parse Int ( matcher . group ( NUM_ ) ) ; break ; default : WX Log Utils . e ( TAG , STR_ + match ) ; break ; } } catch ( Number Format Exception e ) { e . print Stack Trace ( ) ; WX Log Utils . e ( TAG , STR_ + match ) ; } } return new Transform Item Decoration ( get Orientation ( ) == VERTICAL , opacity , translate X , translate Y , rotate , scale X , scale Y ) ; }
public Class read ( String target ) throws Exception { Class type = read Primitive ( target ) ; if ( type == null ) { Class Loader loader = get Class Loader ( ) ; if ( loader == null ) { loader = get Caller Class Loader ( ) ; } return loader . load Class ( target ) ; } return type ; }
public void invalidate Layout ( Container parent ) { check Parent ( parent ) ; synchronized ( parent . get Tree Lock ( ) ) { is Valid = false ; } }
public void add PSR ( Piloting Roll Data psr ) { pilot Rolls . add Element ( psr ) ; }
public static < T > List < T > empty List ( final List < T > list ) { return ( list != null ? list : Collections . < T > empty List ( ) ) ; }
private List < Entitlement > evaluate ( String realm ) throws Entitlement Exception { final Debug debug = Policy Constants . DEBUG ; final Subject Attributes Manager sam = Subject Attributes Manager . get Instance ( admin Subject , realm ) ; final Set < String > subject Indexes = sam . get Subject Search Filter ( subject , application Name ) ; final Privilege Index Store index Store = Privilege Index Store . get Instance ( admin Subject , realm ) ; final Iterator < I Privilege > policy Iterator = index Store . search ( realm , indexes , subject Indexes , recursive ) ; int total Count = NUM_ ; I Privilege policy ; final Set < I Privilege > local Batch = new Hash Set < I Privilege > ( NUM_ * TASKS PER THREAD ) ; while ( total Count < TASKS PER THREAD && policy Iterator . has Next ( ) ) { policy = policy Iterator . next ( ) ; if ( policy instanceof Referral Privilege ) { continue ; } if ( debug . message Enabled ( ) ) { debug . message ( STR_ ) ; debug . message ( STR_ + policy . get Name ( ) ) ; } local Batch . add ( policy ) ; total Count ++ ; } final Privilege Evaluator Context context = new Privilege Evaluator Context ( realm , normalised Resource Name , application Name ) ; final Object app Token = App Token Handler . get And Clear ( ) ; final Set < I Privilege > thread Batch = new Hash Set < I Privilege > ( NUM_ * TASKS PER THREAD ) ; boolean tasks Submitted = false ; while ( policy Iterator . has Next ( ) ) { tasks Submitted = true ; policy = policy Iterator . next ( ) ; if ( policy instanceof Referral Privilege ) { continue ; } if ( debug . message Enabled ( ) ) { debug . message ( STR_ ) ; debug . message ( STR_ + policy . get Name ( ) ) ; } thread Batch . add ( policy ) ; total Count ++ ; if ( thread Batch . size ( ) == TASKS PER THREAD ) { final Set < I Privilege > copied Batch = new Hash Set < I Privilege > ( thread Batch ) ; thread Pool . submit ( new Privilege Task ( this , copied Batch , is Multi Threaded , app Token , context ) ) ; thread Batch . clear ( ) ; } } if ( ! thread Batch . is Empty ( ) ) { thread Pool . submit ( new Privilege Task ( this , thread Batch , is Multi Threaded , app Token , context ) ) ; } final Runnable local Task = new Privilege Task ( this , local Batch , tasks Submitted , app Token , context ) ; local Task . run ( ) ; if ( tasks Submitted ) { if ( is Multi Threaded ) { receive Eval Results ( total Count ) ; } else { boolean is Done = false ; while ( ! result Q . is Empty ( ) && ! is Done ) { entitlement Combiner . add ( result Q . remove ( NUM_ ) ) ; is Done = entitlement Combiner . is Done ( ) ; } } } else if ( e Exception == null ) { boolean is Done = false ; while ( ! result Q . is Empty ( ) && ! is Done ) { entitlement Combiner . add ( result Q . remove ( NUM_ ) ) ; is Done = entitlement Combiner . is Done ( ) ; } } if ( e Exception != null ) { throw e Exception ; } return entitlement Combiner . get Results ( ) ; }
private void startlistening ( Coordinator Imp coordinator ) { Set < Tx State > forget States = new Hash Set < Tx State > ( ) ; for ( Tx State tx State : Tx State . values ( ) ) { if ( tx State . is Final State For Oltp ( ) ) { forget States . add ( tx State ) ; } } for ( Tx State tx State : forget States ) { coordinator . add FSM Enter Listener ( this , tx State ) ; } if ( forget States . contains ( coordinator . get State ( ) ) ) remove Coordinator ( coordinator ) ; }
public static int calculate Translation Animation Duration ( int distance Px ) { return calculate Translation Animation Duration ( distance Px , NUM_ ) ; }
static private String SHORT Min Minus ( ) { long temp Value = Short . MIN VALUE - NUM_ ; return String . value Of ( temp Value ) ; }
public static String pos Bit Mask ( final long bits ) { return String . value Of ( ( ( NUM_ << bits ) & NUM_ ) ^ NUM_ ) ; }
public void inc Sso Server Logging Recs Rejected ( ) { long li = Logging Recs Rejected . long Value ( ) ; li ++ ; Logging Recs Rejected = Long . value Of ( li ) ; }
protected void calc Optimal Width ( ) { if ( get Current Table ( ) != null ) { J Table Helper . set Optimal Column Width ( get Current Table ( ) ) ; } }
private void load Animations ( ) { m Animation Timer Alpha = new Alpha Animation ( NUM_ , NUM_ ) ; m Animation Timer Alpha . set Duration ( NUM_ ) ; m Animation Timer Alpha . set Repeat Mode ( Animation . REVERSE ) ; m Animation Timer Alpha . set Repeat Count ( Animation . INFINITE ) ; m Animation Play Again Background = Animation Utils . load Animation ( get Activity ( ) , R . anim . play again bkgrd anim ) ; m Animation Play Again Background . set Fill After ( true ) ; m Animation Play Again Background . set Animation Listener ( this ) ; m Animation Card Cover = Animation Utils . load Animation ( get Activity ( ) , R . anim . card answer flash ) ; m Animation Card Cover . set Fill After ( true ) ; m Animation Play Again Main = Animation Utils . load Animation ( get Activity ( ) , R . anim . play again main anim ) ; m Animation Play Again Main . set Fill After ( true ) ; m Animation Play Again Main . set Animation Listener ( this ) ; m Animation Set Snowman = new Animation Set ( true ) ; m Animation Snowman = new Translate Animation ( NUM_ , NUM_ , NUM_ , NUM_ ) ; m Animation Snowman . set Duration ( NUM_ ) ; m Animation Set Snowman . add Animation ( m Animation Snowman ) ; m Animation Snowman Back = new Translate Animation ( NUM_ , NUM_ , NUM_ , NUM_ ) ; m Animation Snowman Back . set Duration ( NUM_ ) ; m Animation Snowman Back . set Start Offset ( NUM_ ) ; m Animation Snowman Back . set Animation Listener ( this ) ; m Animation Set Snowman . add Animation ( m Animation Snowman Back ) ; m Animation Set Snowman . set Animation Listener ( this ) ; m Animation Right Pane Slide Out = Animation Utils . load Animation ( get Activity ( ) , android . R . anim . slide out right ) ; m Animation Right Pane Slide Out . set Fill After ( true ) ; m Animation Left Pane Slide Out = Animation Utils . load Animation ( get Activity ( ) , R . anim . left pane slide out ) ; m Animation Left Pane Slide Out . set Fill After ( true ) ; m Animation Left Pane Slide In = Animation Utils . load Animation ( get Activity ( ) , android . R . anim . slide in left ) ; m Animation Left Pane Slide In . set Fill After ( true ) ; m Animation Right Pane Slide In = Animation Utils . load Animation ( get Activity ( ) , R . anim . right pane slide in ) ; m Animation Right Pane Slide In . set Fill After ( true ) ; m Animation Scale Level Down = Animation Utils . load Animation ( get Activity ( ) , R . anim . scale level anim down ) ; m Animation Scale Level Down . set Animation Listener ( this ) ; m Animation Level Fade Out = Animation Utils . load Animation ( get Activity ( ) , R . anim . level fade out anim ) ; m Animation Level Fade Out . set Animation Listener ( this ) ; m Animation Level Scale Up = Animation Utils . load Animation ( get Activity ( ) , R . anim . scale up level anim ) ; m Animation Level Scale Up . set Animation Listener ( this ) ; m Animation Right Pane Slide Out . set Animation Listener ( this ) ; m Animation Left Pane Slide Out . set Animation Listener ( this ) ; }
boolean validate ( final Color color , final Composite blend ) { if ( ! validated ) { if ( ! tilesets . is Empty ( ) ) { for ( Tile Set Definition def : tilesets ) { add ( def , color , blend ) ; } tilesets . clear ( ) ; validated = true ; return true ; } return false ; } return true ; }
public static String [ ] executor Command ( Config config , Config runtime , int container Index , List < Integer > free Ports ) { if ( free Ports . size ( ) < PORTS REQUIRED FOR EXECUTOR ) { throw new Runtime Exception ( STR_ ) ; } for ( int port : free Ports ) { if ( port == - NUM_ ) { throw new Runtime Exception ( STR_ ) ; } } List < String > ports = new Linked List < > ( ) ; for ( int port : free Ports ) { ports . add ( Integer . to String ( port ) ) ; } return get Executor Command ( config , runtime , container Index , ports ) ; }
public void handle Exception ( Parse Exception ex , SIP Message sip Message , Class hdr Class , String header , String message ) throws Parse Exception { if ( logger . is Logging Enabled ( ) ) logger . log Exception ( ex ) ; if ( ( hdr Class != null ) && ( hdr Class . equals ( From . class ) || hdr Class . equals ( To . class ) || hdr Class . equals ( C Seq . class ) || hdr Class . equals ( Via . class ) || hdr Class . equals ( Call ID . class ) || hdr Class . equals ( Content Length . class ) || hdr Class . equals ( Request Line . class ) || hdr Class . equals ( Status Line . class ) ) ) { if ( logger . is Logging Enabled ( Log Writer . TRACE DEBUG ) ) { logger . log Debug ( STR_ + sip Message . to String ( ) ) ; } String msg String = sip Message . to String ( ) ; if ( ! msg String . starts With ( STR_ ) && ! msg String . starts With ( STR_ ) ) { if ( my Sock != null ) { if ( logger . is Logging Enabled ( Log Writer . TRACE ERROR ) ) { logger . log Error ( STR_ + my Sock . to String ( ) ) ; } try { my Sock . close ( ) ; } catch ( IO Exception ie ) { if ( logger . is Logging Enabled ( Log Writer . TRACE ERROR ) ) { logger . log Error ( STR_ + my Sock . to String ( ) + STR_ + ie . to String ( ) ) ; } } } } throw ex ; } else { sip Message . add Unparsed ( header ) ; } }
public static Carbon Message create Text Response ( int status , String msg ) { Default Carbon Message response = new Default Carbon Message ( ) ; response . set Property ( Constants . HTTP STATUS CODE , status ) ; if ( msg != null ) { response . set Header ( Http Headers . CONTENT LENGTH , String . value Of ( msg . length ( ) ) ) ; response . set String Message Body ( msg ) ; } else { response . set Header ( Http Headers . CONTENT LENGTH , STR_ ) ; } return response ; }
@ Override public void draw Item ( Graphics 2 D g 2 , XY Item Renderer State state , Rectangle 2 D data Area , Plot Rendering Info info , XY Plot plot , Value Axis domain Axis , Value Axis range Axis , XY Dataset dataset , int series , int item , Crosshair State crosshair State , int pass ) { if ( pass == NUM_ && dataset instanceof Interval XY Dataset && get Item Visible ( series , item ) ) { Interval XY Dataset ixyd = ( Interval XY Dataset ) dataset ; Plot Orientation orientation = plot . get Orientation ( ) ; if ( this . draw X Error ) { double x 0 = ixyd . get Start X Value ( series , item ) ; double x 1 = ixyd . get End X Value ( series , item ) ; double y = ixyd . get Y Value ( series , item ) ; Rectangle Edge edge = plot . get Domain Axis Edge ( ) ; double xx 0 = domain Axis . value To Java 2 D ( x 0 , data Area , edge ) ; double xx 1 = domain Axis . value To Java 2 D ( x 1 , data Area , edge ) ; double yy = range Axis . value To Java 2 D ( y , data Area , plot . get Range Axis Edge ( ) ) ; Line 2 D line ; Line 2 D cap 1 ; Line 2 D cap 2 ; double adj = this . cap Length / NUM_ ; if ( orientation == Plot Orientation . VERTICAL ) { line = new Line 2 D . Double ( xx 0 , yy , xx 1 , yy ) ; cap 1 = new Line 2 D . Double ( xx 0 , yy - adj , xx 0 , yy + adj ) ; cap 2 = new Line 2 D . Double ( xx 1 , yy - adj , xx 1 , yy + adj ) ; } else { line = new Line 2 D . Double ( yy , xx 0 , yy , xx 1 ) ; cap 1 = new Line 2 D . Double ( yy - adj , xx 0 , yy + adj , xx 0 ) ; cap 2 = new Line 2 D . Double ( yy - adj , xx 1 , yy + adj , xx 1 ) ; } if ( this . error Paint != null ) { g 2 . set Paint ( this . error Paint ) ; } else { g 2 . set Paint ( get Item Paint ( series , item ) ) ; } if ( this . error Stroke != null ) { g 2 . set Stroke ( this . error Stroke ) ; } else { g 2 . set Stroke ( get Item Stroke ( series , item ) ) ; } g 2 . draw ( line ) ; g 2 . draw ( cap 1 ) ; g 2 . draw ( cap 2 ) ; } if ( this . draw Y Error ) { double y 0 = ixyd . get Start Y Value ( series , item ) ; double y 1 = ixyd . get End Y Value ( series , item ) ; double x = ixyd . get X Value ( series , item ) ; Rectangle Edge edge = plot . get Range Axis Edge ( ) ; double yy 0 = range Axis . value To Java 2 D ( y 0 , data Area , edge ) ; double yy 1 = range Axis . value To Java 2 D ( y 1 , data Area , edge ) ; double xx = domain Axis . value To Java 2 D ( x , data Area , plot . get Domain Axis Edge ( ) ) ; Line 2 D line ; Line 2 D cap 1 ; Line 2 D cap 2 ; double adj = this . cap Length / NUM_ ; if ( orientation == Plot Orientation . VERTICAL ) { line = new Line 2 D . Double ( xx , yy 0 , xx , yy 1 ) ; cap 1 = new Line 2 D . Double ( xx - adj , yy 0 , xx + adj , yy 0 ) ; cap 2 = new Line 2 D . Double ( xx - adj , yy 1 , xx + adj , yy 1 ) ; } else { line = new Line 2 D . Double ( yy 0 , xx , yy 1 , xx ) ; cap 1 = new Line 2 D . Double ( yy 0 , xx - adj , yy 0 , xx + adj ) ; cap 2 = new Line 2 D . Double ( yy 1 , xx - adj , yy 1 , xx + adj ) ; } if ( this . error Paint != null ) { g 2 . set Paint ( this . error Paint ) ; } else { g 2 . set Paint ( get Item Paint ( series , item ) ) ; } if ( this . error Stroke != null ) { g 2 . set Stroke ( this . error Stroke ) ; } else { g 2 . set Stroke ( get Item Stroke ( series , item ) ) ; } g 2 . draw ( line ) ; g 2 . draw ( cap 1 ) ; g 2 . draw ( cap 2 ) ; } } super . draw Item ( g 2 , state , data Area , info , plot , domain Axis , range Axis , dataset , series , item , crosshair State , pass ) ; }
public static Long truncate Op CRC 32 ( String stream , DLSN dlsn ) { CRC 32 crc = request CRC . get ( ) ; try { crc . update ( stream . get Bytes ( ) ) ; crc . update ( dlsn . serialize Bytes ( ) ) ; long result = crc . get Value ( ) ; return crc . get Value ( ) ; } finally { crc . reset ( ) ; } }
public void darker Color ( int factor ) { int color = get Color ( ) ; int r = color > > NUM_ & NUM_ ; int g = color > > NUM_ & NUM_ ; int b = color & NUM_ ; r = Math . max ( NUM_ , r - factor ) ; g = Math . max ( NUM_ , g - factor ) ; b = Math . max ( NUM_ , b - factor ) ; set Color ( ( ( r << NUM_ ) & NUM_ ) | ( ( g << NUM_ ) & NUM_ ) | ( b & NUM_ ) ) ; }
void next Frame ( ) { Swing Utilities . invoke Later ( next Frame Runner ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Task Series Collection ) ) { return false ; } Task Series Collection that = ( Task Series Collection ) obj ; if ( ! Object Utilities . equal ( this . data , that . data ) ) { return false ; } return true ; }
public static String make Descriptor ( Method m ) { Class [ ] params = m . get Parameter Types ( ) ; return make Descriptor ( params , m . get Return Type ( ) ) ; }
static String decode String ( String source , boolean fail Silently ) { try { return decode String ( source ) ; } catch ( URI Syntax Exception e ) { throw new Illegal Argument Exception ( e . get Message ( ) ) ; } }
private void start Authentication Activity ( ) { if ( Constants . AUTO ENROLLMENT BACKGROUND SERVICE ENABLED == false ) { Intent intent = new Intent ( Server Details . this , Authentication Activity . class ) ; intent . set Flags ( Intent . FLAG ACTIVITY CLEAR TOP ) ; start Activity ( intent ) ; } }
private void add Request Headers ( State state , Http URL Connection conn ) { for ( Pair < String , String > header : original Download Info . get Headers ( ) ) { conn . add Request Property ( header . first , header . second ) ; } if ( conn . get Request Property ( STR_ ) == null ) { conn . add Request Property ( STR_ , user Agent ( ) ) ; } conn . set Request Property ( STR_ , STR_ ) ; if ( state . continuing Download ) { if ( state . header E Tag != null ) { conn . add Request Property ( STR_ , state . header E Tag ) ; } conn . add Request Property ( STR_ , STR_ + state . current Bytes + STR_ ) ; } }
private static String [ ] make Utf 8 Able ( String s ) { if ( s . length ( ) < ( NUM_ / NUM_ ) ) return new String [ ] { s } ; int s Length = s . length ( ) , utf Length = NUM_ ; int from = NUM_ ; List < String > l = new Array List < String > ( ) ; for ( int i = NUM_ ; ; i ++ ) { if ( i == s Length ) { l . add ( s . substring ( from ) ) ; break ; } if ( utf Length >= NUM_ ) { l . add ( s . substring ( from , i ) ) ; if ( i + ( NUM_ / NUM_ ) > s Length ) { l . add ( s . substring ( i ) ) ; break ; } from = i ; utf Length = NUM_ ; } int c = s . char At ( i ) ; if ( c >= NUM_ && c <= NUM_ ) { ++ utf Length ; } else if ( c > NUM_ ) { utf Length += NUM_ ; } else { utf Length += NUM_ ; } } return ( String [ ] ) l . to Array ( new String [ l . size ( ) ] ) ; }
private int generate Custom Activity Request Code ( App Restrictions Preference preference ) { m Custom Request Code ++ ; m Custom Request Map . put ( m Custom Request Code , preference ) ; return m Custom Request Code ; }
public static J Component create Container ( boolean direction ) { J Component container = new Spring ( ) ; container . set Layout ( new S Box Layout ( direction ) ) ; return container ; }
public static Input Stream wrap And Check Compression Format ( Input Stream in ) throws IO Exception { Buffered Input Stream buffered In = new Buffered Input Stream ( in ) ; if ( is Zip ( buffered In ) ) { Zip Input Stream zip In = new Zip Input Stream ( buffered In ) ; zip In . get Next Entry ( ) ; return zip In ; } else if ( is G Zip ( buffered In ) ) { GZIP Input Stream gzip In = new GZIP Input Stream ( buffered In ) ; return gzip In ; } return buffered In ; }
public static double dps For Move ( final Pokemon p , final boolean primary ) { final Pokemon Move move = primary ? p . get Move 1 ( ) : p . get Move 2 ( ) ; return dps For Move ( p . get Pokemon Id ( ) , move , primary ) ; }
public static void wait For Bridge And UI Idle ( React Bridge Idle Signaler idle Signaler , final React Context react Context , long timeout Ms ) { Ui Thread Util . assert Not On Ui Thread ( ) ; long start Time = System Clock . uptime Millis ( ) ; wait Inner ( idle Signaler , timeout Ms ) ; long time To Wait = Math . max ( NUM_ , timeout Ms - ( System Clock . uptime Millis ( ) - start Time ) ) ; wait For Choreographer ( time To Wait ) ; wait For JS Idle ( react Context ) ; time To Wait = Math . max ( NUM_ , timeout Ms - ( System Clock . uptime Millis ( ) - start Time ) ) ; wait Inner ( idle Signaler , time To Wait ) ; time To Wait = Math . max ( NUM_ , timeout Ms - ( System Clock . uptime Millis ( ) - start Time ) ) ; wait For Choreographer ( time To Wait ) ; }
@ Suppress Warnings ( STR_ ) private < T > T construct Subclass ( Class < T > cls , Args mode , Stack < Class > stack ) { T cached Value = get Cached Value ( cls ) ; if ( stack . size ( ) > MAX STACK DEPTH ) { LOG . error ( STR_ , MAX STACK DEPTH , cls . get Simple Name ( ) , cached Value , stack ) ; return cached Value ; } if ( stack . contains ( cls ) ) { LOG . error ( STR_ , cls . get Simple Name ( ) , cached Value , stack ) ; return cached Value ; } stack . push ( cls ) ; try { for ( Class < ? > subclass : get Classes ( ) ) { if ( cls . is Assignable From ( subclass ) && ! Modifier . is Abstract ( subclass . get Modifiers ( ) ) ) { try { @ Suppress Warnings ( STR_ ) T arg = construct Object ( ( Class < T > ) subclass , mode , stack ) ; if ( arg != null ) { return arg ; } } catch ( Instantiation Exception e ) { LOG . debug ( STR_ , e ) ; } } } } catch ( Class Not Found Exception | IO Exception ignore ) { } finally { stack . pop ( ) ; } return cached Value ; }
private void adjust Day Of Week ( Calendar start Time ) { int days Diff = get Day Of Week ( ) - start Time . get ( Calendar . DAY OF WEEK ) ; start Time . add ( Calendar . DAY OF WEEK , days Diff ) ; }
private static synchronized Linked List < Controller Plan > find Plan ( RVM Method method ) { return table . get ( method ) ; }
private void on Format Button Click ( Toggle Button toggle Button , String tag ) { Spannable s = m Content Edit Text . get Text ( ) ; if ( s == null ) return ; int selection Start = m Content Edit Text . get Selection Start ( ) ; m Style Start = selection Start ; int selection End = m Content Edit Text . get Selection End ( ) ; if ( selection Start > selection End ) { int temp = selection End ; selection End = selection Start ; selection Start = temp ; } Class style Class = null ; if ( tag . equals ( TAG FORMAT BAR BUTTON STRONG ) || tag . equals ( TAG FORMAT BAR BUTTON EM ) ) style Class = Style Span . class ; else if ( tag . equals ( TAG FORMAT BAR BUTTON UNDERLINE ) ) style Class = WP Underline Span . class ; else if ( tag . equals ( TAG FORMAT BAR BUTTON STRIKE ) ) style Class = Strikethrough Span . class ; else if ( tag . equals ( TAG FORMAT BAR BUTTON QUOTE ) ) style Class = Quote Span . class ; if ( style Class == null ) return ; Object [ ] all Spans = s . get Spans ( selection Start , selection End , style Class ) ; boolean text Is Selected = selection End > selection Start ; if ( m Is Local Draft ) { boolean should Add Span = true ; for ( Object span : all Spans ) { if ( span instanceof Style Span ) { Style Span style Span = ( Style Span ) span ; if ( ( style Span . get Style ( ) == Typeface . BOLD && ! tag . equals ( TAG FORMAT BAR BUTTON STRONG ) ) || ( style Span . get Style ( ) == Typeface . ITALIC && ! tag . equals ( TAG FORMAT BAR BUTTON EM ) ) ) { continue ; } } if ( ! toggle Button . is Checked ( ) && text Is Selected ) { s . remove Span ( span ) ; should Add Span = false ; break ; } else if ( ! toggle Button . is Checked ( ) ) { Object [ ] spans = s . get Spans ( m Style Start - NUM_ , m Style Start , style Class ) ; for ( Object remove Span : spans ) { selection Start = s . get Span Start ( remove Span ) ; selection End = s . get Span End ( remove Span ) ; s . remove Span ( remove Span ) ; } } } if ( should Add Span ) { if ( tag . equals ( TAG FORMAT BAR BUTTON STRONG ) ) { s . set Span ( new Style Span ( android . graphics . Typeface . BOLD ) , selection Start , selection End , Spannable . SPAN EXCLUSIVE EXCLUSIVE ) ; } else if ( tag . equals ( TAG FORMAT BAR BUTTON EM ) ) { s . set Span ( new Style Span ( android . graphics . Typeface . ITALIC ) , selection Start , selection End , Spannable . SPAN EXCLUSIVE EXCLUSIVE ) ; } else { try { s . set Span ( style Class . new Instance ( ) , selection Start , selection End , Spannable . SPAN EXCLUSIVE EXCLUSIVE ) ; } catch ( java . lang . Instantiation Exception e ) { App Log . e ( T . POSTS , e ) ; } catch ( Illegal Access Exception e ) { App Log . e ( T . POSTS , e ) ; } } } } else { String start Tag = STR_ + tag + STR_ ; String end Tag = STR_ + tag + STR_ ; Editable content = m Content Edit Text . get Text ( ) ; if ( text Is Selected ) { content . insert ( selection Start , start Tag ) ; content . insert ( selection End + start Tag . length ( ) , end Tag ) ; toggle Button . set Checked ( false ) ; m Content Edit Text . set Selection ( selection End + start Tag . length ( ) + end Tag . length ( ) ) ; } else if ( toggle Button . is Checked ( ) ) { content . insert ( selection Start , start Tag ) ; m Content Edit Text . set Selection ( selection End + start Tag . length ( ) ) ; } else if ( ! toggle Button . is Checked ( ) ) { content . insert ( selection End , end Tag ) ; m Content Edit Text . set Selection ( selection End + end Tag . length ( ) ) ; } } }
void create Edges ( Integer [ ] v ) { graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; graph . add Edge ( new Double ( Math . random ( ) ) , v [ NUM_ ] , v [ NUM_ ] , Edge Type . DIRECTED ) ; }
private void ensure FD Capacity ( int idx ) { if ( idx >= failure Detection Ports . length ) { int [ ] p = new int [ idx + NUM_ ] ; if ( failure Detection Ports . length > NUM_ ) { System . arraycopy ( failure Detection Ports , NUM_ , p , NUM_ , failure Detection Ports . length ) ; } Arrays . fill ( p , idx , idx + NUM_ , - NUM_ ) ; failure Detection Ports = p ; } }
private void compute Label Sides ( int geom Index ) { compute Label Side ( geom Index , Position . LEFT ) ; compute Label Side ( geom Index , Position . RIGHT ) ; }
private static String lookup ( String key ) { return amh . get Message ( key ) ; }
protected void add Backups To Backup Request Buffer ( Fb Service service , Service Request Buffer backup SPB ) throws SQL Exception { for ( Iterator < Path Size Struct > iter = backup Paths . iterator ( ) ; iter . has Next ( ) ; ) { Path Size Struct path Size = iter . next ( ) ; backup SPB . add Argument ( isc spb bkp file , path Size . get Path ( ) ) ; if ( iter . has Next ( ) && path Size . get Size ( ) == - NUM_ ) { throw new SQL Exception ( STR_ + path Size . get Path ( ) ) ; } if ( iter . has Next ( ) ) { backup SPB . add Argument ( isc spb bkp length , path Size . get Size ( ) ) ; } } }
protected void layout Minor Axis ( int target Span , int axis , int [ ] offsets , int [ ] spans ) { int n = get View Count ( ) ; Object key = ( axis == X AXIS ) ? CSS . Attribute . WIDTH : CSS . Attribute . HEIGHT ; for ( int i = NUM_ ; i < n ; i ++ ) { View v = get View ( i ) ; int min = ( int ) v . get Minimum Span ( axis ) ; int max ; Attribute Set a = v . get Attributes ( ) ; CSS . Length Value lv = ( CSS . Length Value ) a . get Attribute ( key ) ; if ( ( lv != null ) && lv . is Percentage ( ) ) { min = Math . max ( ( int ) lv . get Value ( target Span ) , min ) ; max = min ; } else { max = ( int ) v . get Maximum Span ( axis ) ; } if ( max < target Span ) { float align = v . get Alignment ( axis ) ; offsets [ i ] = ( int ) ( ( target Span - max ) * align ) ; spans [ i ] = max ; } else { offsets [ i ] = NUM_ ; spans [ i ] = Math . max ( min , target Span ) ; } } }
@ Override public Cache Header put ( String key , Cache Header entry ) { wait For Key ( key ) ; if ( super . contains Key ( key ) ) { m Total Size . get And Add ( entry . size - super . get ( key ) . size ) ; } else { m Total Size . get And Add ( entry . size ) ; } return super . put ( key , entry ) ; }
public void register Span Tag Handler ( Span Tag Handler handler ) { handlers . add ( handler ) ; handlers By Character Style . put ( handler . get Supported Character Style ( ) , handler ) ; }
public static String replace Not Escaped ( String s , String old , String replacement ) { s = s . replace ( ESCAPE CHARACTER + old , TEMP REPLACEMENT ) ; s = s . replace ( old , replacement ) ; s = s . replace ( TEMP REPLACEMENT , old ) ; return s ; }
private void add Diff Viewers To Section ( final Form Toolkit toolkit , final List < Task Attribute > diff Task Attributes , final Section group Section ) { Composite composite = create Diff Viewers ( group Section , toolkit , diff Task Attributes ) ; group Section . set Client ( composite ) ; }
private Collection < Expression > create Unique Trigger Expressions ( final Conversation States state , final Collection < String > trigger Strings , final Expression Matcher matcher , final Chat Condition condition , final String reply , final Chat Action action ) { Collection < Expression > trigger Expressions = new Array List < Expression > ( ) ; for ( final String trigger String : trigger Strings ) { final Expression trigger Expression = Conversation Parser . create Trigger Expression ( trigger String , matcher ) ; final Transition existing = get ( state , trigger Expression , condition ) ; if ( existing != null ) { final String existing Reply = existing . get Reply ( ) ; final Post Transition Action existing Action = existing . get Action ( ) ; if ( ( existing Reply != null ) && ( reply != null ) && ! existing Reply . contains ( reply ) ) { existing . set Reply ( existing Reply + STR_ + reply ) ; } else { existing . set Reply ( reply ) ; } if ( ( ( action == null ) && ( existing Action == null ) ) || ( ( action != null ) && action . equals ( existing Action ) ) ) { return null ; } else { logger . warn ( speaker NPC . get Name ( ) + STR_ + existing + STR_ + existing Action + STR_ + action + STR_ ) ; } } trigger Expressions . add ( trigger Expression ) ; } return trigger Expressions ; }
public void remove Parent Relation ( Relation relation ) { if ( parent Relations != null ) { parent Relations . remove ( relation ) ; } }
private float witten Bell ( int [ ] ngram , int ngram Order ) { int end = ngram . length ; double p = p 0 ; int MAX QCOUNT = get Count ( ngram , ngram . length - NUM_ , ngram . length , max Q ) ; if ( MAX QCOUNT == NUM_ ) return ( float ) p ; double p ML = Math . log ( un Quantize ( MAX QCOUNT ) ) - num Tokens ; p = log Add ( p , ( lambda 0 + p ML ) ) ; if ( ngram . length == NUM_ ) { return ( float ) p ; } for ( int i = end - NUM_ ; i >= end - ngram Order && i >= NUM_ ; i -- ) { int history Cnt = get Count ( ngram , i , end , MAX QCOUNT ) ; if ( history Cnt == NUM_ ) { return ( float ) p ; } int history Types After = get Types After ( ngram , i , end , history Cnt ) ; double HC = un Quantize ( history Cnt ) ; double HTA = NUM_ + un Quantize ( history Types After ) ; double lambda = Math . log ( HTA ) - Math . log ( HTA + HC ) ; double one Minus Lambda = Math . log ( HC ) - Math . log ( HTA + HC ) ; p += one Minus Lambda ; int word Count = get Count ( ngram , i + NUM_ , end , history Types After ) ; double WC = un Quantize ( word Count ) ; if ( WC == NUM_ ) return ( float ) p ; p = log Add ( p , lambda + Math . log ( WC ) - Math . log ( HC ) ) ; MAX QCOUNT = word Count ; } return ( float ) p ; }
protected void calculate Loops ( ) { if ( this . min Loops != this . max Loops ) { Random r = new Random ( ) ; this . num Loops = this . min Loops + r . next Int ( this . max Loops - this . min Loops ) ; } else { this . num Loops = this . min Loops ; } }
private FC Zone Reference find FC Zone Reference For Vol Group Key ( URI export Group URI , URI volume URI , String ref Key , String [ ] new Or Existing ) { Map < String , FC Zone Reference > vol Ref Map = network Scheduler . make Export To Reference Map ( ref Key ) ; String vol Export Key = make 2 Uri Key ( volume URI , export Group URI ) ; if ( vol Ref Map . contains Key ( vol Export Key ) ) { FC Zone Reference ref = vol Ref Map . get ( vol Export Key ) ; if ( ref != null && ref . get Inactive ( ) == false ) { log . info ( String . format ( STR_ , volume URI , export Group URI , ref Key ) ) ; new Or Existing [ NUM_ ] = STR_ ; return ref ; } } return null ; }
private void calculate Term Frequencies ( List < Pattern Reference > patterns , Set < Word > terms ) { patterns . for Each ( null ) ; }
public int scan ( String table , String startkey , int recordcount , Set < String > fields , Vector < Hash Map < String , Byte Iterator > > result ) { long st = System . nano Time ( ) ; int res = db . scan ( table , startkey , recordcount , fields , result ) ; long en = System . nano Time ( ) ; measurements . measure ( STR_ , ( int ) ( ( en - st ) / NUM_ ) ) ; measurements . report Return Code ( STR_ , res ) ; return res ; }
public Obligation Policy Database Entry add Parameter Deletes Obligation Database Entry ( X Method xmethod , Obligation obligation , Obligation Policy Database Entry Type entry Type ) { Obligation Policy Database Entry entry = new Match Method Entry ( xmethod , Obligation Policy Database Action Type . DEL , entry Type , obligation ) ; add Entry ( entry ) ; return entry ; }
public boolean matches Id ( String check Id ) { if ( check Id == null ) { return false ; } else if ( uuid . is Present ( ) && check Id . equals ( uuid . get ( ) ) ) { return true ; } String id = get Id ( ) ; return ! id . equals ( STR_ ) && check Id . equals ( id ) ; }
public static Compute State provision Machine ( Verification Host host , Compute State vm State , boolean is Mock , List < String > instances To Clean Up ) throws Interrupted Exception , Timeout Exception , Throwable { return provision Machine ( host , null , vm State , is Mock , instances To Clean Up ) ; }
protected static List < Endpoint Help Dto > describe Endpoints ( List < Class < ? extends Abstract Resource > > resource Classes ) { List < Endpoint Help Dto > result = new Linked List < > ( ) ; if ( resource Classes != null && ! resource Classes . is Empty ( ) ) { for ( Class < ? extends Abstract Resource > resource Class : resource Classes ) { Endpoint Help Dto dto = Endpoint Help Dto . from Resource Class ( resource Class ) ; if ( dto != null ) { result . add ( dto ) ; } } } return result ; }
static void create Vbo ( ) { int vbo = gl Gen Buffers ( ) ; gl Bind Buffer ( GL ARRAY BUFFER , vbo ) ; Byte Buffer bb = Buffer Utils . create Byte Buffer ( boxes . length * NUM_ * ( NUM_ + NUM_ ) * NUM_ * NUM_ ) ; Float Buffer fv = bb . as Float Buffer ( ) ; for ( int i = NUM_ ; i < boxes . length ; i += NUM_ ) { Demo Utils . triangulate Box ( boxes [ i ] , boxes [ i + NUM_ ] , fv ) ; } gl Buffer Data ( GL ARRAY BUFFER , bb , GL STATIC DRAW ) ; gl Enable Vertex Attrib Array ( NUM_ ) ; gl Vertex Attrib Pointer ( NUM_ , NUM_ , GL FLOAT , false , NUM_ * ( NUM_ + NUM_ ) , NUM_ ) ; gl Enable Vertex Attrib Array ( NUM_ ) ; gl Vertex Attrib Pointer ( NUM_ , NUM_ , GL FLOAT , false , NUM_ * ( NUM_ + NUM_ ) , NUM_ * NUM_ ) ; gl Bind Buffer ( GL ARRAY BUFFER , NUM_ ) ; }
protected void fire End Elem ( String name ) throws org . xml . sax . SAX Exception { if ( m tracer != null ) { flush My Writer ( ) ; m tracer . fire Generate Event ( Serializer Trace . EVENTTYPE ENDELEMENT , name , ( Attributes ) null ) ; } }
public String request Statistics ( ) { if ( interval > NUM_ ) { synchronized ( sbmutex ) { return sb . to String ( ) ; } } else { sb . set Length ( NUM_ ) ; make String Buffer ( sb ) ; return sb . to String ( ) ; } }
private static byte [ ] hmac sha ( String crypto , byte [ ] key Bytes , byte [ ] text ) { try { Mac hmac ; hmac = Mac . get Instance ( crypto ) ; Secret Key Spec mac Key = new Secret Key Spec ( key Bytes , STR_ ) ; hmac . init ( mac Key ) ; return hmac . do Final ( text ) ; } catch ( General Security Exception gse ) { throw new Undeclared Throwable Exception ( gse ) ; } }
public void update Availability Indicators ( ) { for ( String string : availability Indicators . key Set ( ) ) { Command Target command Target = commands . get ( string ) ; if ( command Target != null ) { command Target . set Availability Indicator ( availability Indicators . get ( string ) ) ; } } }
protected final void collect FFDCDB Data ( Connection con ) throws Ade Exception { try { capture Minimal DB Data ( con ) ; final long file Length = archive Exported DB Tables ( ) ; logger . debug ( STR_ + file Length ) ; } catch ( Ade Exception e ) { throw e ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Ade Ext Internal Exception ( STR_ , e ) ; } }
protected boolean is System Admin Or Monitor User ( ) { return permissions Helper . user Has Given Role ( get User From Context ( ) , null , Role . SYSTEM ADMIN , Role . SYSTEM MONITOR ) ; }
public void unregister Client ( Respoke Client client ) { instances . remove ( client ) ; }
public void verify Process Definitions Do Not Share Keys ( Collection < Process Definition Entity > process Definitions ) { Set < String > key Set = new Linked Hash Set < String > ( ) ; for ( Process Definition Entity process Definition : process Definitions ) { if ( key Set . contains ( process Definition . get Key ( ) ) ) { throw new Activiti Exception ( STR_ ) ; } key Set . add ( process Definition . get Key ( ) ) ; } }
public void p 2 ant ( Action < P 2 Ant Runner > ant Modifier ) { this . ant Modifier = Objects . require Non Null ( ant Modifier ) ; }
public void add Terms ( String query String , String field Name , float min Similarity , int prefix Length ) { int max Edits = ( int ) min Similarity ; if ( max Edits != min Similarity || max Edits < NUM_ || max Edits > Levenshtein Automata . MAXIMUM SUPPORTED DISTANCE ) { throw new Illegal Argument Exception ( STR_ + Levenshtein Automata . MAXIMUM SUPPORTED DISTANCE + STR_ + min Similarity ) ; } field Vals . add ( new Field Vals ( field Name , max Edits , prefix Length , query String ) ) ; }
protected Rectangle paint Close Button ( Graphics g , Synth Context tab Context , int tab Index ) { Rectangle tab Rect = new Rectangle ( rects [ tab Index ] ) ; Rectangle bounds = get Close Button Bounds ( tab Index ) ; int offset = bounds . width + text Icon Gap ; boolean on Left = is Close Button On Left ( ) ; if ( on Left ) { tab Rect . x += offset ; tab Rect . width -= offset ; } else { tab Rect . width -= offset ; } Sea Glass Context subcontext = get Context ( tab Pane , Sea Glass Region . TABBED PANE TAB CLOSE BUTTON , get Close Button State ( tab Pane , tab Index , ( tab Context . get Component State ( ) & MOUSE OVER ) != NUM_ ) ) ; Sea Glass Look And Feel . update Subregion ( subcontext , g , bounds ) ; Sea Glass Synth Painter Impl painter = ( Sea Glass Synth Painter Impl ) subcontext . get Painter ( ) ; painter . paint Search Button Foreground ( subcontext , g , bounds . x , bounds . y , bounds . width , bounds . height ) ; subcontext . dispose ( ) ; return tab Rect ; }
public static void release Lock ( Entity Manager em , long type , String key ) { Entity Transaction tx = null ; try { tx = em . get Transaction ( ) ; tx . begin ( ) ; Global Interlock lock = find And Refresh Lock ( em , type ) ; if ( lock == null ) { throw new Global Interlock Exception ( STR_ + type + STR_ + key + STR_ ) ; } String ref = Long . to Hex String ( lock . lock Time ) ; if ( ref . equals Ignore Case ( key ) ) { em . remove ( lock ) ; em . flush ( ) ; tx . commit ( ) ; } else { throw new Global Interlock Exception ( STR_ + type + STR_ + key + STR_ ) ; } } finally { if ( tx != null && tx . is Active ( ) ) { tx . rollback ( ) ; } } }
public Datagram Packet multicast Receive ( ) throws IO Exception { byte [ ] buf = new byte [ NUM_ ] ; Datagram Packet dp = new Datagram Packet ( buf , buf . length ) ; multicast Socket . receive ( dp ) ; return dp ; }
public Thread pause Train ( int fast Minutes ) { if ( pausing Active ) { return ( null ) ; } Runnable pause Train = new Pause Train ( fast Minutes ) ; Thread t Pause = new Thread ( pause Train , STR_ + active Train . get Train Name ( ) ) ; t Pause . start ( ) ; return t Pause ; }
private boolean parse Html ( String html ) { Pattern p = Pattern . compile ( STR_ ) ; Matcher m = p . matcher ( html ) ; if ( ! m . find ( ) ) { p = Pattern . compile ( STR_ ) ; m = p . matcher ( html ) ; } if ( ! m . find ( ) ) { return false ; } delay = Integer . parse Int ( m . group ( NUM_ ) ) ; url = m . group ( NUM_ ) ; return true ; }
private static void append Text Element ( Document doc , Node parent , String name , String value ) { Element e = doc . create Element ( name ) ; e . append Child ( doc . create Text Node ( value ) ) ; parent . append Child ( e ) ; }
public static Class unbox Type ( Class wrapper Type ) { Class c = ( Class ) wrapper Map . get ( wrapper Type ) ; if ( c != null ) return c ; throw new Interpreter Error ( STR_ + wrapper Type ) ; }
protected List < Operation > add Pre Operations ( final Operation < ? , ? > previous Op , final Operation < ? , ? > current Op ) { if ( does Operation Need Validating ( previous Op , current Op ) ) { return Collections . singleton List ( ( Operation ) create Validate Operation ( ( Validatable < ? > ) current Op ) ) ; } return Collections . empty List ( ) ; }
private static void print Err Msg ( int err , String uname ) { switch ( err ) { case Server Err . SUCCESS : break ; case Consistency Err . CHECK PASSED : break ; case Client Utils . INTERNAL CLIENT ERR : print Err ( STR_ + uname + STR_ ) ; break ; case Server Err . INTERNAL SERVER ERR : print Err ( STR_ + uname ) ; break ; case Server Err . NAME EXISTS ERR : print Err ( STR_ + uname + STR_ ) ; break ; case Server Err . NAME NOT FOUND ERR : print Err ( STR_ + uname + STR_ ) ; break ; case Server Err . MALFORMED CLIENT MSG ERR : print Err ( STR_ + uname ) ; break ; case Server Err . MALFORMED SERVER MSG ERR : print Err ( STR_ + uname ) ; break ; case Server Err . SIGNED CHANGE VERIF ERR : print Err ( STR_ + uname + STR_ ) ; break ; case Server Err . SERVER ERR : print Err ( STR_ + uname ) ; break ; case Consistency Err . BAD MAPPING ERR : print Err ( STR_ + uname + STR_ ) ; break ; case Consistency Err . UNEXPECTED KEY ERR : print Err ( STR_ + uname + STR_ ) ; break ; case Consistency Err . BAD STR ERR : print Err ( STR_ + uname ) ; break ; case Consistency Err . BAD SERVER SIG ERR : print Err ( STR_ + uname ) ; break ; case Consistency Err . KEYSTORE ERR : print Err ( STR_ + uname ) ; break ; case Consistency Err . DISALLOWED OP ERR : print Err ( STR_ + uname + STR_ ) ; break ; default : print Err ( STR_ + err ) ; break ; } }
public String create Mono Vdc Id ( ) { return String . format ( STR_ , VDC ID PREFIX , next Vdc Id ( ) ) ; }
@ Suppress Warnings ( STR_ ) private < T > T allow Static Access To Member ( T member , boolean static Only ) { if ( member == null ) return null ; if ( ! static Only ) return member ; boolean is Static ; if ( member instanceof Variable ) { Variable v = ( Variable ) member ; is Static = Modifier . is Static ( v . get Modifiers ( ) ) ; } else if ( member instanceof List ) { List < Method Node > list = ( List < Method Node > ) member ; if ( list . size ( ) == NUM_ ) { return ( T ) Collections . singleton List ( allow Static Access To Member ( list . get ( NUM_ ) , static Only ) ) ; } return ( T ) Collections . empty List ( ) ; } else { Method Node mn = ( Method Node ) member ; is Static = mn . is Static ( ) ; } if ( static Only && ! is Static ) return null ; return member ; }
@ Override public void initialize ( ) throws Scheduler Exception { Initial Context ctx = null ; try { ctx = new Initial Context ( get Context Properties ( ) ) ; server = ( M Bean Server Connection ) ctx . lookup ( RMI ADAPTOR JNDI NAME ) ; } catch ( Exception e ) { throw new Scheduler Exception ( STR_ , e ) ; } finally { if ( ctx != null ) { try { ctx . close ( ) ; } catch ( Naming Exception ignore ) { } } } }
public String to Mutil Line String ( ) { final String new Line = System . get Property ( STR_ ) ; final String Buffer problem Str = new String Buffer ( ) ; for ( final Problem problem : this . problems ) { problem Str . append ( problem . get Message ( ) + new Line ) ; } return problem Str . to String ( ) ; }
protected String create Id From File Name ( Deployable deployable ) { File file = new File ( deployable . get File ( ) ) ; return file . get Name ( ) ; }
public String write ( Object value ) throws Exception { int length = Array . get Length ( value ) ; if ( entry == char . class ) { char [ ] array = ( char [ ] ) value ; return new String ( array ) ; } return write ( value , length ) ; }
public final synchronized Offset find Or Create Jtoc Offset ( ) { if ( VM . Verify Assertions ) VM . assert ( ! is Static ( ) && ! is Object Initializer ( ) ) ; Offset jtoc Offset = get Jtoc Offset ( ) ; ; if ( jtoc Offset . EQ ( Offset . zero ( ) ) ) { jtoc Offset = Statics . allocate Reference Slot ( true ) ; Statics . set Slot Contents ( jtoc Offset , get Current Entry Code Array ( ) ) ; synchronized ( jtoc Offsets ) { jtoc Offsets . put ( this , Integer . value Of ( jtoc Offset . to Int ( ) ) ) ; } } return jtoc Offset ; }
protected void internal Transform ( Body b , String phase Name , Map options ) { Stmt Body stmt Body = ( Stmt Body ) b ; Chain < Unit > units = stmt Body . get Units ( ) ; Iterator < Unit > stmt It = units . snapshot Iterator ( ) ; Normal Unit Printer nup = new Normal Unit Printer ( b ) ; while ( stmt It . has Next ( ) ) { Stmt stmt = ( Stmt ) stmt It . next ( ) ; if ( ! stmt . contains Invoke Expr ( ) ) { continue ; } Invoke Expr expr = ( Invoke Expr ) stmt . get Invoke Expr ( ) ; Assign Stmt assign Stmt = null ; if ( stmt instanceof Assign Stmt ) { assign Stmt = ( Assign Stmt ) stmt ; } else { continue ; } inspect And Replace Calls ( units , assign Stmt , expr ) ; } }
private void write Minor Statistics String ( Buffered Writer output , SA Zone zone ) throws IO Exception { output . write ( zone . get Name ( ) ) ; output . write ( delimiter ) ; output . write ( String . value Of ( zone . get Minor Activity Count ( ) ) ) ; output . write ( delimiter ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { output . write ( String . value Of ( zone . get Minor Activity Count Detail ( i ) ) ) ; output . write ( delimiter ) ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { output . write ( String . value Of ( zone . get Minor Activity Duration Detail ( i ) ) ) ; output . write ( delimiter ) ; } output . write ( String . value Of ( zone . get Minor Activity Duration Detail ( NUM_ ) ) ) ; output . new Line ( ) ; }
protected < H extends Mem Holder < ? extends Common Allocator < ? > , ? , ? > > H create ( Mem Create < H > creator , Performance Level startlevel , long size ) { H ret = null ; boolean eligible = false ; for ( Performance Level lvl : m info . key Set ( ) ) { if ( ! eligible && startlevel == lvl ) { eligible = true ; } if ( eligible ) { int distance = NUM_ ; List < Common Allocator < ? > > bmas = m info . get ( lvl ) ; for ( Common Allocator < ? > bma : bmas ) { ret = creator . create ( bma , size ) ; if ( null == ret ) { distance ++ ; } else { if ( null != m bwlvlchange && m prevbwlevel != lvl ) { m bwlvlchange . changed ( m prevbwlevel , lvl ) ; m prevbwlevel = lvl ; } if ( null != m allocator Change && m prevallocator != bma ) { m allocator Change . changed ( lvl , m prevallocator , bma ) ; m prevallocator = bma ; } break ; } } Collections . rotate ( bmas , distance ) ; } if ( null != ret ) { break ; } } return ret ; }
private void mark As Incomplete ( VM vm ) throws IO Exception { File backup Dir = get Backup Dir For Member ( get Baseline Dir ( ) , get Member Id ( vm ) ) ; assert True ( backup Dir . exists ( ) ) ; File incomplete = new File ( backup Dir , Backup Manager . INCOMPLETE BACKUP ) ; incomplete . create New File ( ) ; }
public void start Clock ( ) { if ( ! timer . is Running ( ) ) { fire Property Change ( TIMER STATUS , Timer Status . STOPPED , ( get Clock Direction ( ) > NUM_ ? Timer Status . FORWARD : Timer Status . BACKWARD ) ) ; fire Clock Update ( get Clock Direction ( ) > NUM_ ? Timer Status . FORWARD : Timer Status . BACKWARD ) ; } if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } timer . restart ( ) ; }
public void add Security Requirement Extension For Entire Service ( Swagger swagger ) { Authentication Rule . Builder builder = Authentication Rule . new Builder ( ) ; if ( convert Security Requirement Extension ( swagger . get Vendor Extensions ( ) , builder , new Simple Location ( STR_ ) ) ) { builder . set Selector ( STR_ ) ; auth Rules . add ( builder . build ( ) ) ; } }
private static int shift Color Space To Swing ( final Color new Col ) { final int r = ( int ) ( new Col . get Red ( ) * NUM_ ) ; final int g = ( int ) ( new Col . get Green ( ) * NUM_ ) ; final int b = ( int ) ( new Col . get Blue ( ) * NUM_ ) ; return ( r << NUM_ ) + ( g << NUM_ ) + b ; }
public boolean created ( URI storage System Uri , String replication Group Name ) { if ( storage System Uri != null && system Consistency Groups != null && ! system Consistency Groups . is Empty ( ) ) { String Set cg Names = system Consistency Groups . get ( storage System Uri . to String ( ) ) ; if ( cg Names != null && ! cg Names . is Empty ( ) ) { if ( replication Group Name != null && ! replication Group Name . is Empty ( ) ) { if ( cg Names . contains ( replication Group Name ) ) { return true ; } else { return false ; } } else { return true ; } } } return false ; }
@ Override public void load Tx Mtd ( Job Conf job , File System fs , Path tx Mtd Dir , Tf Utils agents ) throws IO Exception { if ( ! is Applicable ( ) ) return ; final Maps = new Hash Map < Integer , Hash Map < String , String > > ( ) ; if ( fs . is Directory ( tx Mtd Dir ) ) { for ( int i = NUM_ ; i < col List . length ; i ++ ) { int col ID = col List [ i ] ; Path path = new Path ( tx Mtd Dir + STR_ + agents . get Name ( col ID ) + Tf Utils . TXMTD RCD MAP SUFFIX ) ; Tf Utils . check Valid Input File ( fs , path , true ) ; Hash Map < String , String > map = new Hash Map < String , String > ( ) ; Pair < String , String > pair = new Pair < String , String > ( ) ; Buffered Reader br = new Buffered Reader ( new Input Stream Reader ( fs . open ( path ) ) ) ; String line = null ; while ( ( line = br . read Line ( ) ) != null ) { Decoder Recode . parse Recode Map Entry ( line , pair ) ; map . put ( pair . get Key ( ) , pair . get Value ( ) ) ; } br . close ( ) ; final Maps . put ( col ID , map ) ; } } else { fs . close ( ) ; throw new Runtime Exception ( STR_ + tx Mtd Dir ) ; } }
void free ( Client Socket stream ) { success ( ) ; active Count . decrement And Get ( ) ; synchronized ( this ) { int size = ( idle Head - idle Tail + idle . length ) % idle . length ; if ( state != State . CLOSED && size < idle Size ) { idle Head = ( idle Head + NUM_ ) % idle . length ; idle [ idle Head ] = stream ; stream = null ; } long now = Current Time . current Time ( ) ; long prev Success Time = prev Success Time ; if ( prev Success Time > NUM_ ) { latency Factor = ( NUM_ * latency Factor + NUM_ * ( now - prev Success Time ) ) ; } if ( active Count . get ( ) > NUM_ ) prev Success Time = now ; else prev Success Time = NUM_ ; last Success Time = now ; if ( log . is Loggable ( Level . FINEST ) ) { log Finest ( L . l ( STR_ , now , fail Time ) ) ; } } update Warmup ( ) ; long now = Current Time . current Time ( ) ; long max Idle Time = load Balance Idle Time ; Client Socket old Stream = null ; do { old Stream = null ; synchronized ( this ) { if ( idle Head != idle Tail ) { int next Tail = ( idle Tail + NUM_ ) % idle . length ; old Stream = idle [ next Tail ] ; if ( old Stream != null && old Stream . get Idle Start Time ( ) + max Idle Time < now ) { idle [ next Tail ] = null ; idle Tail = next Tail ; } else old Stream = null ; } } if ( old Stream != null ) old Stream . close Impl ( ) ; } while ( old Stream != null ) ; if ( stream != null ) { stream . close Impl ( ) ; } }
public boolean is True ( String key ) { return options . contains Key ( key ) && Boolean . parse Boolean ( options . get ( key ) ) ; }
@ Override public final Classifier Split Model select Model ( Instances train , Instances test ) { return select Model ( train ) ; }
public String create Message ( Sso Runtime Exception e ) { return create Message ( e . get Message Key ( ) , e . get Message Details ( ) , e . get Message ( ) ) ; }
public void add Surprise Member For Testing ( Distributed Member m , long birth Time ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ , m , birth Time ) ; } latest View Write Lock . lock ( ) ; try { surprise Members . put ( ( Internal Distributed Member ) m , Long . value Of ( birth Time ) ) ; } finally { latest View Write Lock . unlock ( ) ; } }
public boolean created ( URI storage System Uri ) { if ( storage System Uri != null && system Consistency Groups != null && ! system Consistency Groups . is Empty ( ) ) { String Set cg Names = system Consistency Groups . get ( storage System Uri . to String ( ) ) ; if ( cg Names != null && ! cg Names . is Empty ( ) ) { return true ; } } return false ; }
private void populate SMIS Access Profile ( Access Profile access Profile , Storage Provider provider Info ) { access Profile . set System Id ( provider Info . get Id ( ) ) ; access Profile . set System Clazz ( provider Info . get Class ( ) ) ; access Profile . set Ip Address ( provider Info . get IP Address ( ) ) ; access Profile . set User Name ( provider Info . get User Name ( ) ) ; access Profile . set Password ( provider Info . get Password ( ) ) ; access Profile . set System Type ( get System Type ( provider Info ) ) ; access Profile . set Provider Port ( String . value Of ( provider Info . get Port Number ( ) ) ) ; access Profile . set Interop Namespace ( Constants . INTEROP ) ; access Profile . set Ssl Enable ( String . value Of ( provider Info . get Use SSL ( ) ) ) ; }
public void remove Observer ( String notification Name , Object notify Context ) { List < Observer > observers = observer Map . get ( notification Name ) ; if ( observers != null ) { for ( int i = NUM_ ; i < observers . size ( ) ; i ++ ) { Base Observer observer = ( Base Observer ) observers . get ( i ) ; if ( observer . compare Notify Context ( notify Context ) ) { observers . remove ( observer ) ; } } if ( observers . size ( ) == NUM_ ) { observer Map . remove ( notification Name ) ; } } }
public static void preinstall ( File user Settings Dir ) throws Install Failed Exception { if ( ! preinstalled . compare And Set ( false , true ) ) return ; try { Common Utils . set User Settings Dir ( user Settings Dir ) ; Library Settings . reset Library Folders If Portable ( ) ; } catch ( Exception e ) { throw new Install Failed Exception ( STR_ , e ) ; } }
public void read Leaf Block ( Block Id blk ) { lock Tbl . s Lock ( blk , tx Num ) ; read Index Blks . add ( blk ) ; }
public void add Extreme Gravity PSR ( Piloting Roll Data psr ) { extreme Gravity Rolls . add Element ( psr ) ; }
public void cancel Jobs For Uid ( int uid ) { List < Job Status > jobs For Uid ; synchronized ( m Jobs ) { jobs For Uid = m Jobs . get Jobs By Uid ( uid ) ; } for ( int i = NUM_ ; i < jobs For Uid . size ( ) ; i ++ ) { Job Status to Remove = jobs For Uid . get ( i ) ; cancel Job Impl ( to Remove ) ; } }
public boolean check Value ( final Object value ) { if ( value instanceof Double ) { return true ; } else if ( value instanceof String ) { try { Double . parse Double ( ( String ) value ) ; return true ; } catch ( Exception e ) { return false ; } } else { throw new Illegal Argument Exception ( ) ; } }
protected static void append Serializable Type ( String Builder sb ) { sb . append ( STR_ ) ; }
private void notify No Valid Action ( final Political Action Attachment paa ) { send Notification ( STR_ ) ; }
private int [ ] make Def State List ( ) { int [ ] ret Array = new int [ f Elem Map Size ] ; for ( int index = NUM_ ; index < f Elem Map Size ; index ++ ) ret Array [ index ] = - NUM_ ; return ret Array ; }
public void start Sampling ( ) { if ( m Sampling Counter . get And Increment ( ) == NUM_ ) { m Handler . start Sampling Thread ( ) ; m Last Time Reading = System Clock . elapsed Realtime ( ) ; } }
@ Visible For Testing protected Map < String , String > calculate Modified Server Defaults ( Map < String , String > new Defaults , Map < String , String > existing Defaults , Set < String > attr To Modify ) { Map < String , String > modified Values = new Hash Map < String , String > ( ) ; for ( String attr Name : attr To Modify ) { String new Attr = new Defaults . get ( attr Name ) ; String existing Attr = existing Defaults . get ( attr Name ) ; if ( new Attr != null && existing Attr != null && ! new Attr . equals ( existing Attr ) ) { modified Values . put ( attr Name , new Attr ) ; } } return modified Values ; }
private void build String ( String Builder sb , Dimensional Node node ) { if ( node == null ) { return ; } Dimensional Node left = node . get Below ( ) ; Dimensional Node right = node . get Above ( ) ; if ( left != null ) { build String ( sb , left ) ; } sb . append ( node . to String ( ) ) ; if ( right != null ) { build String ( sb , right ) ; } }
public void init ( ) throws Servlet Exception { super . init ( ) ; try { String def = PROVIDER DEFAULT . to String ( ) ; String provider = get Init Parameter ( PARAM PROVIDER , def ) ; this . factory = Identity Services Factory . get Instance ( provider ) ; } catch ( Exception e ) { throw new Servlet Exception ( e ) ; } }
public void merge Interference Set ( int reg , Int Set set ) { if ( reg < interference . size ( ) ) { set . merge ( interference . get ( reg ) ) ; } }
public void read Byte L Enum ( byte [ ] b ) throws IO Exception { input Stream . read Fully ( b ) ; }
public static String gensalt ( final int log rounds , final Secure Random random ) { final String Buffer rs = new String Buffer ( ) ; final byte rnd [ ] = new byte [ BCRYPT SALT LEN ] ; random . next Bytes ( rnd ) ; rs . append ( STR_ ) ; if ( log rounds < NUM_ ) { rs . append ( STR_ ) ; } if ( log rounds > NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } rs . append ( Integer . to String ( log rounds ) ) ; rs . append ( STR_ ) ; rs . append ( encode base 64 ( rnd , rnd . length ) ) ; return rs . to String ( ) ; }
@ Non Null protected static String sortable Title ( @ Nullable String title ) { if ( title == null ) { return STR_ ; } title = title . to Lower Case ( ) ; if ( title . starts With ( STR_ ) ) { return title . substring ( NUM_ ) ; } else if ( title . starts With ( STR_ ) ) { return title . substring ( NUM_ ) ; } else { return title ; } }
private Map clone Marker Map ( Map map ) throws Clone Not Supported Exception { Map clone = new Hash Map ( ) ; Set keys = map . key Set ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Object key = iterator . next ( ) ; List entry = ( List ) map . get ( key ) ; Object to Add = Object Utilities . deep Clone ( entry ) ; clone . put ( key , to Add ) ; } return clone ; }
public int compute Id ( Bit Set active Matches , I Read Block read Block ) { if ( name 2 id != null ) { final String name = read Block . get Read Name ( ) ; final Integer id = name 2 id . get ( name ) ; if ( id != null && id > NUM_ ) return id ; } if ( active Matches . cardinality ( ) == NUM_ ) return Id Mapper . NOHITS ID ; for ( int i = active Matches . next Set Bit ( NUM_ ) ; i != - NUM_ ; i = active Matches . next Set Bit ( i + NUM_ ) ) { I Match Block match = read Block . get Match Block ( i ) ; int id = match . get Id ( c Name ) ; if ( id > NUM_ ) return id ; } return Id Mapper . UNASSIGNED ID ; }
private void check Idle ( Iterable < Selection Key > keys ) { long now = U . current Time Millis ( ) ; for ( Selection Key key : keys ) { Grid Selector Nio Session Impl ses = ( Grid Selector Nio Session Impl ) key . attachment ( ) ; try { long write Timeout 0 = write Timeout ; boolean op Write = key . is Valid ( ) && ( key . interest Ops ( ) & Selection Key . OP WRITE ) != NUM_ ; if ( op Write && now - ses . last Send Time ( ) > write Timeout 0 ) { filter Chain . on Session Write Timeout ( ses ) ; ses . bytes Sent ( NUM_ ) ; continue ; } long idle Timeout 0 = idle Timeout ; if ( ! op Write && now - ses . last Receive Time ( ) > idle Timeout 0 && now - ses . last Send Schedule Time ( ) > idle Timeout 0 ) { filter Chain . on Session Idle Timeout ( ses ) ; ses . reset Send Schedule Time ( ) ; ses . bytes Received ( NUM_ ) ; } } catch ( Ignite Checked Exception e ) { close ( ses , e ) ; } } }
private static void register Service Class ( final Class < ? > type , final Map < String , Class Loader > classloader Map , final Class Loader class Loader , final Set < Class > classes ) { final String class Name = type . get Name ( ) ; final Class Loader registered Class Loader = classloader Map . get ( class Name ) ; if ( registered Class Loader == null ) { classloader Map . put ( class Name , class Loader ) ; classes . add ( type ) ; } else { boolean loaded From Ancestor = false ; Class Loader ancestor Class Loader = class Loader . get Parent ( ) ; while ( ancestor Class Loader != null ) { if ( ancestor Class Loader == registered Class Loader ) { loaded From Ancestor = true ; break ; } ancestor Class Loader = ancestor Class Loader . get Parent ( ) ; } if ( ! loaded From Ancestor ) { logger . warn ( STR_ + class Name + STR_ + class Loader + STR_ + registered Class Loader + STR_ ) ; } } }
public static String create Web Xml Source ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; return sb . to String ( ) ; }
private Pac Script Methods build Parser ( ) { Pac Script Methods result = new Pac Script Methods ( ) ; Calendar cal = Calendar . get Instance ( ) ; cal . set ( Calendar . YEAR , NUM_ ) ; cal . set ( Calendar . MONTH , Calendar . DECEMBER ) ; cal . set ( Calendar . DAY OF MONTH , NUM_ ) ; cal . set ( Calendar . HOUR OF DAY , NUM_ ) ; cal . set ( Calendar . MINUTE , NUM_ ) ; cal . set ( Calendar . SECOND , NUM_ ) ; cal . set ( Calendar . MILLISECOND , NUM_ ) ; result . set Current Time ( cal ) ; return result ; }
public Set < Resource > all Values From ( ) { Set < Resource > targets = new Hash Set < > ( ) ; for ( Owl Class c : avf Classes ) { targets . add ( c . get URI ( ) ) ; } return targets ; }
public void add Input ( Source source ) { source . init ( this ) ; inputs . add ( source ) ; }
public boolean bind ( ) throws Version Exception { boolean bound = false ; if ( m is Connected ) return false ; m is Connected = true ; m protocol . add Listener ( Listener Index . Player Session , this ) ; bound = m protocol . bind ( ) ; send Stop Warning ( ) ; send Stop On Fault ( ) ; send Enumerate Override ( ) ; send Failure Notify ( ) ; send Invoke Setters ( ) ; send Swfload Notify ( ) ; send Getter Timeout ( ) ; send Setter Timeout ( ) ; boolean responded = send Squelch ( true , Isolate . DEFAULT ID ) ; set Preference ( Session Manager . PLAYER SUPPORTS GET , player Supports Get ( ) ? NUM_ : NUM_ ) ; if ( supports Concurrency ( ) ) { send Concurrent Debugger ( ) ; } if ( supports Wide Line Numbers ( ) ) { send Wide Line Debugger ( ) ; } Thread t = new Thread ( this , STR_ ) ; t . set Daemon ( true ) ; t . start ( ) ; if ( ! responded ) throw new Version Exception ( ) ; return bound ; }
@ Override protected void set Bounds ( long native Window Pointer , int x , int y , boolean x Set , boolean y Set , int w , int h , int cw , int ch , float x Gravity , float y Gravity ) { int width ; int height ; if ( w > NUM_ ) { width = w ; } else if ( cw > NUM_ ) { width = cw ; } else { width = get Width ( ) ; } if ( h > NUM_ ) { height = h ; } else if ( cw > NUM_ ) { height = ch ; } else { height = get Height ( ) ; } if ( ! x Set ) { x = get X ( ) ; } if ( ! y Set ) { y = get Y ( ) ; } if ( max W >= NUM_ ) { width = Math . min ( width , max W ) ; } if ( max H >= NUM_ ) { height = Math . min ( height , max H ) ; } width = Math . max ( width , min W ) ; height = Math . max ( height , min H ) ; notify Resize And Move ( x , y , width , height ) ; }
public Parse Query < T > where Ends With ( String key , String suffix ) { String regex = Pattern . quote ( suffix ) + STR_ ; where Matches ( key , regex ) ; return this ; }
public byte [ ] load File From Cache ( final String url String ) { final String file Name = Resource Loader . get Normalized File Name ( url String ) ; final File file = get Cache File ( file Name ) ; if ( file . exists ( ) ) { final byte [ ] bytes = DSS Utils . to Byte Array ( file ) ; return bytes ; } return null ; }
private boolean is Before Dot ( char s [ ] , int pos , int len ) { for ( int i = pos ; i < len ; ) { final int ch = Character . code Point At ( s , i , len ) ; if ( Character . get Type ( ch ) != Character . NON SPACING MARK ) return false ; if ( ch == COMBINING DOT ABOVE ) return true ; i += Character . char Count ( ch ) ; } return false ; }
private void create Photon Map Textures ( ) { Int Buffer textures = Buffer Utils . create Int Buffer ( photon Map Textures . length ) ; gl Gen Textures ( textures ) ; for ( int i = NUM_ ; i < photon Map Textures . length ; i ++ ) { Texture Info info = new Texture Info ( ) ; info . open Gl Handle = textures . get ( i ) ; Vector 3 f min = boxes [ NUM_ * i + NUM_ ] ; Vector 3 f max = boxes [ NUM_ * i + NUM_ ] ; float max Extent = Math . max ( Math . max ( max . x - min . x , max . y - min . y ) , max . z - min . z ) ; int tex Size = ( int ) ( max Extent * texels Per Unit ) ; info . texture Width = tex Size ; info . texture Height = tex Size ; gl Bind Texture ( GL TEXTURE CUBE MAP , info . open Gl Handle ) ; gl Tex Storage 2 D ( GL TEXTURE CUBE MAP , NUM_ , GL RG 16 F , tex Size , tex Size ) ; gl Bind Texture ( GL TEXTURE CUBE MAP , NUM_ ) ; info . bindless Image Handle = ARB Bindless Texture . gl Get Image Handle ARB ( info . open Gl Handle , NUM_ , true , NUM_ , GL RG 16 F ) ; info . bindless Texture And Sampler Handle = ARB Bindless Texture . gl Get Texture Sampler Handle ARB ( info . open Gl Handle , sampler ) ; ARB Bindless Texture . gl Make Image Handle Resident ARB ( info . bindless Image Handle , GL READ WRITE ) ; ARB Bindless Texture . gl Make Texture Handle Resident ARB ( info . bindless Texture And Sampler Handle ) ; photon Map Textures [ i ] = info ; } clear Photon Map Textures ( ) ; update Image Handles Ubo ( ) ; update Sampler Handles Ubo ( ) ; }
private Component create Step 2 Panel ( ) { J Panel panel = new J Panel ( ) ; panel . set Layout ( new Grid Bag Layout ( ) ) ; Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; gbc . gridx = NUM_ ; gbc . gridy = NUM_ ; gbc . weightx = NUM_ ; gbc . fill = Grid Bag Constraints . BOTH ; gbc . insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; code Text = new J Text Field ( ) ; code Text . set Minimum Size ( new Dimension ( NUM_ , NUM_ ) ) ; code Text . set Preferred Size ( new Dimension ( NUM_ , NUM_ ) ) ; panel . add ( code Text , gbc ) ; panel . set Border ( new Round Titled Border ( NUM_ , I 18 N . get Message ( I 18 N . get GUI Bundle ( ) , STR_ ) , false ) ) ; return panel ; }
private boolean application Eligible For Upgrade ( String realm , String app Name , Map < String , Set < String > > app Data ) { if ( ROOT REALM . equals ( realm ) ) { return ! default Application Names . contains ( app Name ) && ! is Not Empty ( app Data . get ( CONFIG RESOURCE TYPE UUIDS ) ) ; } else { return ! is Not Empty ( app Data . get ( CONFIG RESOURCE TYPE UUIDS ) ) ; } }
public static String [ ] word Wrap ( String str , int first Line Size , int non First Line Size ) { String [ ] lines = word Wrap ( str , first Line Size ) ; if ( lines . length > NUM_ && first Line Size != non First Line Size ) { String not First Lines String = String Utils . join ( lines , STR_ , NUM_ , lines . length ) ; String [ ] non First Lines = word Wrap ( not First Lines String , non First Line Size ) ; List < String > non First Line Collection = Arrays . as List ( non First Lines ) ; Array List < String > all Lines = new Array List < String > ( ) ; all Lines . add ( lines [ NUM_ ] ) ; all Lines . add All ( non First Line Collection ) ; lines = all Lines . to Array ( lines ) ; } return lines ; }
public void start ( ) { logger . info ( STR_ ) ; jssc . start ( ) ; try { jssc . await Termination ( ) ; } catch ( Interrupted Exception e ) { Thread . interrupted ( ) ; } }
private boolean nullable Equals ( Object o 1 , Object o 2 ) { if ( o 1 == null || o 2 == null ) { return false ; } return o 1 . equals ( o 2 ) ; }
public synchronized void remove Listener ( final T listener ) { listeners . remove ( listener ) ; }
private void common Precheck ( ) { common Precheck ( new Array List < String > ( ) ) ; }
protected void update Search Bar Text Opacity ( float percentage ) { float overlap Percentage = NUM_ ; float fading Out Percentage = Math . max ( NUM_ - ( percentage / overlap Percentage ) , NUM_ ) ; float fading In Percentage = Math . max ( percentage - ( NUM_ - overlap Percentage ) , NUM_ ) / overlap Percentage ; m Search Bar Context Opacity = fading Out Percentage ; m Search Bar Term Opacity = fading In Percentage ; }
public String encrypt ( Encrypt Data encrypt Data ) { Gson Builder gson Builder = new Gson Builder ( ) ; gson Builder . register Type Adapter ( Encrypt Data . class , new Encrypt Data Json Serializer ( ) ) ; Gson gson = gson Builder . create ( ) ; String payload = gson . to Json ( encrypt Data ) ; try { String protected Header = create Protected Header ( ) ; String encodeded Protected Header = encrypt Util . base 64 Url Encode ( protected Header . get Bytes ( ) ) ; byte [ ] content Encryption Key = encrypt Util . generate Secure Random Bytes ( CONTENT ENCRYPTION KEY SIZE ) ; byte [ ] encrypted Content Encryption Key = encrypt Util . encrypt Content Encryption Key ( content Encryption Key , ( RSA Public Key ) public Key Response . get Public Key ( ) ) ; String encoded Encrypted Content Encryption Key = encrypt Util . base 64 Url Encode ( encrypted Content Encryption Key ) ; byte [ ] mac Key = Arrays . copy Of ( content Encryption Key , CONTENT ENCRYPTION KEY SIZE / NUM_ ) ; byte [ ] enc Key = Arrays . copy Of Range ( content Encryption Key , CONTENT ENCRYPTION KEY SIZE / NUM_ , CONTENT ENCRYPTION KEY SIZE ) ; byte [ ] initialization Vector = encrypt Util . generate Secure Random Bytes ( INITIALIZATION VECTOR ) ; String encodededinitialization Vector = encrypt Util . base 64 Url Encode ( initialization Vector ) ; byte [ ] cipher Text = encrypt Util . encrypt Payload ( payload , enc Key , initialization Vector ) ; String encoded Cipher Text = encrypt Util . base 64 Url Encode ( cipher Text ) ; byte [ ] additional Authenticated Data = encodeded Protected Header . get Bytes ( Charset . for Name ( STR_ ) ) ; byte [ ] al = calculate Additional Authenticated Data Length ( additional Authenticated Data ) ; byte [ ] calculated Hmac = calculate HMAC ( mac Key , additional Authenticated Data , initialization Vector , cipher Text , al ) ; byte [ ] authentication Tag = Arrays . copy Of ( calculated Hmac , calculated Hmac . length / NUM_ ) ; String encoded Authentication Tag = encrypt Util . base 64 Url Encode ( authentication Tag ) ; return build Compact Respresentation ( encodeded Protected Header , encoded Encrypted Content Encryption Key , encodededinitialization Vector , encoded Cipher Text , encoded Authentication Tag ) ; } catch ( Encrypt Data Exception e ) { Log . i ( TAG , STR_ + e . get Message ( ) ) ; } return null ; }
public void paint ( Glyph View v , Graphics g , Shape a , int p 0 , int p 1 ) { if ( g instanceof Graphics 2 D ) { Rectangle 2 D alloc = a . get Bounds 2 D ( ) ; Graphics 2 D g 2 d = ( Graphics 2 D ) g ; float y = ( float ) alloc . get Y ( ) + layout . get Ascent ( ) + layout . get Leading ( ) ; float x = ( float ) alloc . get X ( ) ; if ( p 0 > v . get Start Offset ( ) || p 1 < v . get End Offset ( ) ) { try { Shape s = v . model To View ( p 0 , Position . Bias . Forward , p 1 , Position . Bias . Backward , a ) ; Shape saved Clip = g . get Clip ( ) ; g 2 d . clip ( s ) ; layout . draw ( g 2 d , x , y ) ; g . set Clip ( saved Clip ) ; } catch ( Bad Location Exception e ) { } } else { layout . draw ( g 2 d , x , y ) ; } } }
private static boolean is Right Outlier ( int index , Array List < Double > values ) { double current Value = values . get ( index ) ; double value To Right = values . get ( index + NUM_ ) ; return Math . abs ( current Value - value To Right ) > NUM_ ; }
public final int compare Type Safe ( Value v , Compare Mode mode ) { if ( this == v ) { return NUM_ ; } else if ( this == Value Null . INSTANCE ) { return - NUM_ ; } else if ( v == Value Null . INSTANCE ) { return NUM_ ; } return compare Secure ( v , mode ) ; }
public static int combine Hash Codes ( int hash Code 1 , int hash Code 2 ) { return hash Code 1 * NUM_ + hash Code 2 ; }
private void on Main Content Scrolled ( int current Y , int delta Y ) { if ( delta Y > action Bar Auto Hide Sensitivity ) { delta Y = action Bar Auto Hide Sensitivity ; } else if ( delta Y < - action Bar Auto Hide Sensitivity ) { delta Y = - action Bar Auto Hide Sensitivity ; } if ( Math . signum ( delta Y ) * Math . signum ( action Bar Auto Hide Signal ) < NUM_ ) { action Bar Auto Hide Signal = delta Y ; } else { action Bar Auto Hide Signal += delta Y ; } boolean should Show = current Y < action Bar Auto Hide Min Y || ( action Bar Auto Hide Signal <= - action Bar Auto Hide Sensitivity ) ; auto Show Or Hide Action Bar ( should Show ) ; }
private void select Branch ( ) { presenter . show Branches ( project ) ; presenter . on Branch Selected ( selected Branch ) ; }
public static double standard Normal Quantile ( double d ) { return ( d == NUM_ ) ? Double . NEGATIVE INFINITY : ( d == NUM_ ) ? Double . POSITIVE INFINITY : ( Double . is Na N ( d ) || d < NUM_ || d > NUM_ ) ? Double . Na N : Math Util . SQRT 2 * - erfcinv ( NUM_ * d ) ; }
private int [ ] do Complement ( ) { if ( empty ( ) ) { int [ ] result = new int [ NUM_ ] ; result [ NUM_ ] = NUM_ ; result [ NUM_ ] = NUM_ ; return result ; } int [ ] result = new int [ chars . length + NUM_ ] ; int i = NUM_ ; int index = NUM_ ; if ( chars [ NUM_ ] != NUM_ ) { result [ index ++ ] = NUM_ ; } while ( i < chars . length ) { if ( chars [ i ] != NUM_ ) { result [ index ++ ] = chars [ i ] - NUM_ ; } if ( chars [ i + NUM_ ] != NUM_ ) { result [ index ++ ] = chars [ i + NUM_ ] + NUM_ ; } i += NUM_ ; } if ( chars [ i - NUM_ ] != NUM_ ) { result [ index ++ ] = NUM_ ; } if ( result . length > index ) { int [ ] tmpbuf = new int [ index ] ; System . arraycopy ( result , NUM_ , tmpbuf , NUM_ , index ) ; return tmpbuf ; } return result ; }
public static void sync Modification Times ( Configuration conf , Path src , Path dest , Optional < Path Filter > filter ) throws IO Exception { Set < File Status > src File Statuses = get File Statuses Recursive ( conf , src , filter ) ; Map < String , Long > src File Modification Times = null ; try { src File Modification Times = get Relative Path To Modification Time ( src , src File Statuses ) ; } catch ( Argument Exception e ) { throw new IO Exception ( STR_ , e ) ; } File System dest Fs = dest . get File System ( conf ) ; for ( String file : src File Modification Times . key Set ( ) ) { dest Fs . set Times ( new Path ( dest , file ) , src File Modification Times . get ( file ) , - NUM_ ) ; } }
private static File codegen Resource Module ( File resource Module File , String [ ] locales , List bundle Names ) { String file Name = resource Module File . get Name ( ) ; String class Name = file Name . substring ( NUM_ , file Name . length ( ) - NUM_ ) ; Standard Defs standard Defs = Thread Local Toolkit . get Standard Defs ( ) ; String line Sep = System . get Property ( STR_ ) ; String [ ] code Pieces = new String [ ] { STR_ , line Sep , STR_ , line Sep , line Sep , STR_ , line Sep , STR_ , standard Defs . get Modules Package ( ) , STR_ , line Sep , STR_ , standard Defs . get Resources Package ( ) , STR_ , line Sep , STR_ , standard Defs . get Resources Package ( ) , STR_ , line Sep , line Sep , STR_ , line Sep , line Sep , codegen Resource Bundle Metadata ( bundle Names ) , line Sep , STR_ , class Name , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , codegen Resource Bundle Class Names ( locales , bundle Names ) , line Sep , STR_ , line Sep , line Sep , STR_ , class Name , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , line Sep , STR_ , line Sep , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , line Sep , STR_ , line Sep , STR_ , line Sep , STR_ , line Sep , line Sep , STR_ , line Sep } ; String code = String Joiner . join ( code Pieces , null ) ; try { Buffered Writer buffered Writer = new Buffered Writer ( new Output Stream Writer ( new File Output Stream ( resource Module File ) , STR_ ) ) ; buffered Writer . write ( code ) ; buffered Writer . close ( ) ; } catch ( Exception e ) { } return resource Module File ; }
public void dump PAG For Method ( String f Name , String c Name , String m Name ) throws File Not Found Exception { File Output Stream fos = new File Output Stream ( new File ( f Name ) ) ; Print Stream ps = new Print Stream ( fos ) ; ps . println ( STR_ ) ; ps . println ( STR_ ) ; dump Local PAG ( c Name , m Name , ps ) ; ps . print ( STR_ ) ; try { fos . close ( ) ; } catch ( IO Exception e ) { } ps . close ( ) ; }
public void add Obfuscated Argument ( final Argument argument ) { add Argument ( argument ) ; obfuscated Args . add ( argument ) ; }
public String resolve System Reverse ( String system Id ) throws IO Exception { Vector resolved = resolve All System Reverse ( system Id ) ; if ( resolved != null && resolved . size ( ) > NUM_ ) { return ( String ) resolved . element At ( NUM_ ) ; } else { return null ; } }
private Update Element Entity < ? extends Cn A Tree Element > create Command ( Cn A Tree Element element ) { return new Update Element Entity < Cn A Tree Element > ( element , Change Log Entry . STATION ID ) ; }
private boolean visit Cycle ( Object start , Set < Object > unvisited , Set < Object > finished , Cycle Holder cycle , int depth ) { if ( finished . contains ( start ) ) { return false ; } if ( ! unvisited . remove ( start ) ) { return true ; } cycle . process Depth ( depth ) ; boolean found Cycle = false ; for ( Dependency dep : vertices . get ( start ) ) { found Cycle |= visit Cycle ( dep . get Depends On ( ) , unvisited , finished , cycle , depth + NUM_ ) ; if ( found Cycle ) { cycle . add ( dep ) ; break ; } } finished . add ( start ) ; return found Cycle ; }
void add Label ( Component label ) { if ( labels == null ) { labels = new Vector ( ) ; } labels . add Element ( label ) ; }
private void init Overall Stats For All Intervals ( ) { m overall Stats For All Intervals = new Overall Stats [ m sub Interval Size List . length ] ; for ( int i = NUM_ ; i < m sub Interval Size List . length ; i ++ ) { final short sub Interval Size = m sub Interval Size List [ i ] ; m overall Stats For All Intervals [ i ] = new Overall Stats ( sub Interval Size ) ; } }
@ Override public int on Start Command ( Intent intent , int flags , int start Id ) { Log OC . d ( TAG , STR_ + start Id ) ; if ( ! intent . has Extra ( KEY ACCOUNT ) || ! intent . has Extra ( KEY UPLOAD TYPE ) || ! ( intent . has Extra ( KEY LOCAL FILE ) || intent . has Extra ( KEY FILE ) ) ) { Log OC . e ( TAG , STR_ ) ; return Service . START NOT STICKY ; } int upload Type = intent . get Int Extra ( KEY UPLOAD TYPE , - NUM_ ) ; if ( upload Type == - NUM_ ) { Log OC . e ( TAG , STR_ ) ; return Service . START NOT STICKY ; } Account account = intent . get Parcelable Extra ( KEY ACCOUNT ) ; if ( ! Account Utils . exists ( account , get Application Context ( ) ) ) { return Service . START NOT STICKY ; } String [ ] local Paths = null , remote Paths = null , mime Types = null ; OC File [ ] files = null ; if ( upload Type == UPLOAD SINGLE FILE ) { if ( intent . has Extra ( KEY FILE ) ) { files = new OC File [ ] { intent . get Parcelable Extra ( KEY FILE ) } ; } else { local Paths = new String [ ] { intent . get String Extra ( KEY LOCAL FILE ) } ; remote Paths = new String [ ] { intent . get String Extra ( KEY REMOTE FILE ) } ; mime Types = new String [ ] { intent . get String Extra ( KEY MIME TYPE ) } ; } } else { if ( intent . has Extra ( KEY FILE ) ) { files = ( OC File [ ] ) intent . get Parcelable Array Extra ( KEY FILE ) ; } else { local Paths = intent . get String Array Extra ( KEY LOCAL FILE ) ; remote Paths = intent . get String Array Extra ( KEY REMOTE FILE ) ; mime Types = intent . get String Array Extra ( KEY MIME TYPE ) ; } } File Data Storage Manager storage Manager = new File Data Storage Manager ( account , get Content Resolver ( ) ) ; boolean force Overwrite = intent . get Boolean Extra ( KEY FORCE OVERWRITE , false ) ; boolean is Instant = intent . get Boolean Extra ( KEY INSTANT UPLOAD , false ) ; int local Action = intent . get Int Extra ( KEY LOCAL BEHAVIOUR , LOCAL BEHAVIOUR COPY ) ; if ( intent . has Extra ( KEY FILE ) && files == null ) { Log OC . e ( TAG , STR_ ) ; return Service . START NOT STICKY ; } else if ( ! intent . has Extra ( KEY FILE ) ) { if ( local Paths == null ) { Log OC . e ( TAG , STR_ ) ; return Service . START NOT STICKY ; } if ( remote Paths == null ) { Log OC . e ( TAG , STR_ ) ; return Service . START NOT STICKY ; } if ( local Paths . length != remote Paths . length ) { Log OC . e ( TAG , STR_ ) ; return Service . START NOT STICKY ; } files = new OC File [ local Paths . length ] ; for ( int i = NUM_ ; i < local Paths . length ; i ++ ) { files [ i ] = obtain New OC File To Upload ( remote Paths [ i ] , local Paths [ i ] , ( ( mime Types != null ) ? mime Types [ i ] : null ) , storage Manager ) ; if ( files [ i ] == null ) { return Service . START NOT STICKY ; } } } Own Cloud Version ocv = Account Utils . get Server Version ( account ) ; boolean chunked = File Uploader . chunked Upload Is Supported ( ocv ) ; Abstract List < String > requested Uploads = new Vector < > ( ) ; String upload Key = null ; Upload File Operation new Upload = null ; try { for ( OC File file : files ) { upload Key = build Remote Name ( account , file . get Remote Path ( ) ) ; new Upload = new Upload File Operation ( account , file , chunked , is Instant , force Overwrite , local Action , get Application Context ( ) ) ; if ( is Instant ) { new Upload . set Remote Folder To Be Created ( ) ; } m Pending Uploads . put If Absent ( upload Key , new Upload ) ; new Upload . add Datatransfer Progress Listener ( this ) ; new Upload . add Datatransfer Progress Listener ( ( File Uploader Binder ) m Binder ) ; requested Uploads . add ( upload Key ) ; } } catch ( Illegal Argument Exception e ) { Log OC . e ( TAG , STR_ + e . get Message ( ) ) ; return START NOT STICKY ; } catch ( Illegal State Exception e ) { Log OC . e ( TAG , STR_ + e . get Message ( ) ) ; return START NOT STICKY ; } catch ( Exception e ) { Log OC . e ( TAG , STR_ , e ) ; return START NOT STICKY ; } if ( requested Uploads . size ( ) > NUM_ ) { Message msg = m Service Handler . obtain Message ( ) ; msg . arg 1 = start Id ; msg . obj = requested Uploads ; m Service Handler . send Message ( msg ) ; } Log OC . i ( TAG , STR_ + m Pending Uploads . size ( ) ) ; return Service . START NOT STICKY ; }
private Rectangle 2 D [ ] split Horizontal Bar ( Rectangular Shape bar , double a , double b , double c ) { Rectangle 2 D [ ] result = new Rectangle 2 D [ NUM_ ] ; double y 0 = bar . get Min Y ( ) ; double y 1 = Math . rint ( y 0 + ( bar . get Height ( ) * a ) ) ; double y 2 = Math . rint ( y 0 + ( bar . get Height ( ) * b ) ) ; double y 3 = Math . rint ( y 0 + ( bar . get Height ( ) * c ) ) ; result [ NUM_ ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , bar . get Min Y ( ) , bar . get Width ( ) , y 1 - y 0 ) ; result [ NUM_ ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y 1 , bar . get Width ( ) , y 2 - y 1 ) ; result [ NUM_ ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y 2 , bar . get Width ( ) , y 3 - y 2 ) ; result [ NUM_ ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , y 3 , bar . get Width ( ) , bar . get Max Y ( ) - y 3 ) ; return result ; }
public Weak Table ( ) { if ( DEBUG != null ) DEBUG . println ( STR_ ) ; table = new Hash Map ( ) ; ref Queue = new Reference Queue ( ) ; }
public static String make Descriptor ( Class [ ] params , Class ret Type ) { String Buffer sbuf = new String Buffer ( ) ; sbuf . append ( STR_ ) ; for ( int i = NUM_ ; i < params . length ; i ++ ) make Desc ( sbuf , params [ i ] ) ; sbuf . append ( STR_ ) ; if ( ret Type != null ) make Desc ( sbuf , ret Type ) ; return sbuf . to String ( ) ; }
public Id < Dg Green > convert From Link Id To Link Id 2 Light Id ( Id < Link > from Link Id , Id < Lane > from Lane Id , Id < Link > to Link Id ) { String id = null ; if ( from Lane Id == null ) { id = from Link Id . to String ( ) + STR_ + to Link Id . to String ( ) ; } else { id = from Link Id . to String ( ) + STR_ + from Lane Id . to String ( ) + STR_ + to Link Id . to String ( ) ; } String id String = id . to String ( ) ; return id Pool . create Id ( id String , Dg Green . class ) ; }
public int process Packet ( byte [ ] in , int in Off , int in Len , byte [ ] output , int out Off ) throws Illegal State Exception , Invalid Cipher Text Exception , Data Length Exception { if ( key Param == null ) { throw new Illegal State Exception ( STR_ ) ; } int n = nonce . length ; int q = NUM_ - n ; if ( q < NUM_ ) { int limit Len = NUM_ << ( NUM_ * q ) ; if ( in Len >= limit Len ) { throw new Illegal State Exception ( STR_ ) ; } } byte [ ] iv = new byte [ block Size ] ; iv [ NUM_ ] = ( byte ) ( ( q - NUM_ ) & NUM_ ) ; System . arraycopy ( nonce , NUM_ , iv , NUM_ , nonce . length ) ; Block Cipher ctr Cipher = new SIC Block Cipher ( cipher ) ; ctr Cipher . init ( for Encryption , new Parameters With IV ( key Param , iv ) ) ; int output Len ; int in Index = in Off ; int out Index = out Off ; if ( for Encryption ) { output Len = in Len + mac Size ; if ( output . length < ( output Len + out Off ) ) { throw new Output Length Exception ( STR_ ) ; } calculate Mac ( in , in Off , in Len , mac Block ) ; ctr Cipher . process Block ( mac Block , NUM_ , mac Block , NUM_ ) ; while ( in Index < ( in Off + in Len - block Size ) ) { ctr Cipher . process Block ( in , in Index , output , out Index ) ; out Index += block Size ; in Index += block Size ; } byte [ ] block = new byte [ block Size ] ; System . arraycopy ( in , in Index , block , NUM_ , in Len + in Off - in Index ) ; ctr Cipher . process Block ( block , NUM_ , block , NUM_ ) ; System . arraycopy ( block , NUM_ , output , out Index , in Len + in Off - in Index ) ; System . arraycopy ( mac Block , NUM_ , output , out Off + in Len , mac Size ) ; } else { if ( in Len < mac Size ) { throw new Invalid Cipher Text Exception ( STR_ ) ; } output Len = in Len - mac Size ; if ( output . length < ( output Len + out Off ) ) { throw new Output Length Exception ( STR_ ) ; } System . arraycopy ( in , in Off + output Len , mac Block , NUM_ , mac Size ) ; ctr Cipher . process Block ( mac Block , NUM_ , mac Block , NUM_ ) ; for ( int i = mac Size ; i != mac Block . length ; i ++ ) { mac Block [ i ] = NUM_ ; } while ( in Index < ( in Off + output Len - block Size ) ) { ctr Cipher . process Block ( in , in Index , output , out Index ) ; out Index += block Size ; in Index += block Size ; } byte [ ] block = new byte [ block Size ] ; System . arraycopy ( in , in Index , block , NUM_ , output Len - ( in Index - in Off ) ) ; ctr Cipher . process Block ( block , NUM_ , block , NUM_ ) ; System . arraycopy ( block , NUM_ , output , out Index , output Len - ( in Index - in Off ) ) ; byte [ ] calculated Mac Block = new byte [ block Size ] ; calculate Mac ( output , out Off , output Len , calculated Mac Block ) ; if ( ! Arrays . constant Time Are Equal ( mac Block , calculated Mac Block ) ) { throw new Invalid Cipher Text Exception ( STR_ ) ; } } return output Len ; }
@ Override public int compare To ( Object o ) { Outlier outlier = ( Outlier ) o ; Point 2 D p 1 = get Point ( ) ; Point 2 D p 2 = outlier . get Point ( ) ; if ( p 1 . equals ( p 2 ) ) { return NUM_ ; } else if ( ( p 1 . get X ( ) < p 2 . get X ( ) ) || ( p 1 . get Y ( ) < p 2 . get Y ( ) ) ) { return - NUM_ ; } else { return NUM_ ; } }
public static void add Event Callback ( I Event Callback callback ) { s Event Callback . add ( callback ) ; }
public static boolean is Usable Connection ( Connection C ) { boolean open = false , valid = false ; final int timeout Seconds = MAX CONNECTION PROBE TIME ; logger . trace ( STR_ ) ; if ( C == null ) { logger . error ( STR_ ) ; return false ; } try { open = ! C . is Closed ( ) ; } catch ( Throwable t ) { surface Throwable ( STR_ , t ) ; } try { valid = C . is Valid ( timeout Seconds ) ; } catch ( Throwable t ) { surface Throwable ( STR_ , t ) ; } logger . trace ( String . format ( STR_ , open , valid ) ) ; return open && valid ; }
public static boolean Is In ( String elt , Vector set ) { int i = NUM_ ; boolean result = false ; while ( i < set . size ( ) ) { result = result || elt . equals ( ( String ) set . element At ( i ) ) ; i = i + NUM_ ; } ; return result ; }
private void block RMI ( String method Name , Object ... args ) throws Controller Exception { final URI export = ( URI ) args [ NUM_ ] ; Block Export Controller controller = get Export Controller ( ) ; dispatcher . queue ( export , STR_ , controller , method Name , args ) ; }
public Route provide Route ( String system Name , String user Name ) { Route r ; r = get By User Name ( system Name ) ; if ( r != null ) { return r ; } r = get By System Name ( system Name ) ; if ( r != null ) { return r ; } r = new Default Route ( system Name , user Name ) ; register ( r ) ; if ( system Name . starts With ( STR_ ) ) { try { int auto Number = Integer . parse Int ( system Name . substring ( NUM_ ) ) ; if ( auto Number > last Auto Route Ref ) { last Auto Route Ref = auto Number ; } } catch ( Number Format Exception e ) { log . warn ( STR_ + system Name + STR_ ) ; } } return r ; }
public static Buffered Image make Image Square ( Buffered Image image ) { int max = NUM_ ; max = Common Util . max ( image . get Width ( ) , image . get Height ( ) ) ; return crop Image ( image , max , max ) ; }
public Server Socket Channel next ( ) { Selection Key key = iterator . next ( ) ; if ( key . is Valid ( ) && key . is Acceptable ( ) ) { return ( Server Socket Channel ) key . channel ( ) ; } return null ; }
public Eg Demand Details insert Advance Collection ( final String demand Reason , final Big Decimal advance Collection Amount , final Installment installment ) { Eg Demand Details demand Detail = null ; if ( advance Collection Amount != null && advance Collection Amount . compare To ( Big Decimal . ZERO ) > NUM_ ) { final Eg Demand Reason Master eg Demand Reason Master = demand Generic DAO . get Demand Reason Master By Code ( demand Reason , module ( ) ) ; if ( eg Demand Reason Master == null ) throw new Application Runtime Exception ( STR_ ) ; final Eg Demand Reason eg Demand Reason = demand Generic DAO . get Dmd Reason By Dmd Reason Mster Install And Mod ( eg Demand Reason Master , installment , module ( ) ) ; if ( eg Demand Reason == null ) throw new Application Runtime Exception ( STR_ ) ; demand Detail = create Demand Details ( eg Demand Reason , advance Collection Amount , Big Decimal . ZERO ) ; } return demand Detail ; }
void push ( Register s , Operand name ) { Stack < Operand > stack = get ( s ) ; if ( stack == null ) { stack = new Stack < Operand > ( ) ; put ( s , stack ) ; } stack . push ( name ) ; }
static String compose Sorted Key ( String prefix , int value ) { return String . format ( STR_ , prefix , value ) ; }
public static void remove Explain Hint Annotations From B Op ( final B Op bop ) { final Iterator < B Op > explain Hint Annotated B Ops = Explain Hints . explain Hint Annotated B Op Iterator ( bop ) ; final List < B Op > nodes With Explain Hints = new Array List < B Op > ( ) ; while ( explain Hint Annotated B Ops . has Next ( ) ) { nodes With Explain Hints . add ( explain Hint Annotated B Ops . next ( ) ) ; } for ( final B Op node With Explain Hint : nodes With Explain Hints ) { node With Explain Hint . set Property ( Annotations . EXPLAIN HINTS , null ) ; } }
private boolean calculate Bounds ( Rect F rect ) { float left = Bitmap Utils . get Rect Left ( m Bounds Points ) ; float top = Bitmap Utils . get Rect Top ( m Bounds Points ) ; float right = Bitmap Utils . get Rect Right ( m Bounds Points ) ; float bottom = Bitmap Utils . get Rect Bottom ( m Bounds Points ) ; if ( ! is Non Straight Angle Rotated ( ) ) { m Calc Bounds . set ( left , top , right , bottom ) ; return false ; } else { float x 0 = m Bounds Points [ NUM_ ] ; float y 0 = m Bounds Points [ NUM_ ] ; float x 2 = m Bounds Points [ NUM_ ] ; float y 2 = m Bounds Points [ NUM_ ] ; float x 3 = m Bounds Points [ NUM_ ] ; float y 3 = m Bounds Points [ NUM_ ] ; if ( m Bounds Points [ NUM_ ] < m Bounds Points [ NUM_ ] ) { if ( m Bounds Points [ NUM_ ] < m Bounds Points [ NUM_ ] ) { x 0 = m Bounds Points [ NUM_ ] ; y 0 = m Bounds Points [ NUM_ ] ; x 2 = m Bounds Points [ NUM_ ] ; y 2 = m Bounds Points [ NUM_ ] ; x 3 = m Bounds Points [ NUM_ ] ; y 3 = m Bounds Points [ NUM_ ] ; } else { x 0 = m Bounds Points [ NUM_ ] ; y 0 = m Bounds Points [ NUM_ ] ; x 2 = m Bounds Points [ NUM_ ] ; y 2 = m Bounds Points [ NUM_ ] ; x 3 = m Bounds Points [ NUM_ ] ; y 3 = m Bounds Points [ NUM_ ] ; } } else if ( m Bounds Points [ NUM_ ] > m Bounds Points [ NUM_ ] ) { x 0 = m Bounds Points [ NUM_ ] ; y 0 = m Bounds Points [ NUM_ ] ; x 2 = m Bounds Points [ NUM_ ] ; y 2 = m Bounds Points [ NUM_ ] ; x 3 = m Bounds Points [ NUM_ ] ; y 3 = m Bounds Points [ NUM_ ] ; } float a 0 = ( y 3 - y 0 ) / ( x 3 - x 0 ) ; float a 1 = - NUM_ / a 0 ; float b 0 = y 0 - a 0 * x 0 ; float b 1 = y 0 - a 1 * x 0 ; float b 2 = y 2 - a 0 * x 2 ; float b 3 = y 2 - a 1 * x 2 ; float c 0 = ( rect . center Y ( ) - rect . top ) / ( rect . center X ( ) - rect . left ) ; float c 1 = - c 0 ; float d 0 = rect . top - c 0 * rect . left ; float d 1 = rect . top - c 1 * rect . right ; left = Math . max ( left , ( d 0 - b 0 ) / ( a 0 - c 0 ) < rect . right ? ( d 0 - b 0 ) / ( a 0 - c 0 ) : left ) ; left = Math . max ( left , ( d 0 - b 1 ) / ( a 1 - c 0 ) < rect . right ? ( d 0 - b 1 ) / ( a 1 - c 0 ) : left ) ; left = Math . max ( left , ( d 1 - b 3 ) / ( a 1 - c 1 ) < rect . right ? ( d 1 - b 3 ) / ( a 1 - c 1 ) : left ) ; right = Math . min ( right , ( d 1 - b 1 ) / ( a 1 - c 1 ) > rect . left ? ( d 1 - b 1 ) / ( a 1 - c 1 ) : right ) ; right = Math . min ( right , ( d 1 - b 2 ) / ( a 0 - c 1 ) > rect . left ? ( d 1 - b 2 ) / ( a 0 - c 1 ) : right ) ; right = Math . min ( right , ( d 0 - b 2 ) / ( a 0 - c 0 ) > rect . left ? ( d 0 - b 2 ) / ( a 0 - c 0 ) : right ) ; top = Math . max ( top , Math . max ( a 0 * left + b 0 , a 1 * right + b 1 ) ) ; bottom = Math . min ( bottom , Math . min ( a 1 * left + b 3 , a 0 * right + b 2 ) ) ; m Calc Bounds . left = left ; m Calc Bounds . top = top ; m Calc Bounds . right = right ; m Calc Bounds . bottom = bottom ; return true ; } }
public Raw Public Key Identity ( Public Key key ) { if ( key == null ) { throw new Null Pointer Exception ( STR_ ) ; } else { this . public Key = key ; create Named Information Uri ( public Key . get Encoded ( ) ) ; } }
public My Map ( String map Name , String size , String map Url ) { init ( ) ; this . map Name = map Name ; this . size = size ; init Status ( ) ; set Url ( map Url + map Name + STR_ ) ; generate Continent Name ( map Name ) ; }
private void create ( int size ) { int count = size ; while ( count -- > NUM_ ) { list . add ( new Segment ( ) ) ; } }
public void add Entity Variable ( String variable Name , Jpql Entity Model entity ) { if ( variable Name == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( entity == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( entity Variable Name 2 entity . contains Key ( variable Name ) ) throw new Illegal Argument Exception ( String . format ( STR_ , variable Name ) ) ; entity Variable Name 2 entity . put ( variable Name , entity ) ; }
private static J Value Slider create Field ( Force f , int param ) { double value = f . get Parameter ( param ) ; double min = f . get Min Value ( param ) ; double max = f . get Max Value ( param ) ; String name = f . get Parameter Name ( param ) ; J Value Slider s = new J Value Slider ( name , min , max , value ) ; s . set Background ( Color . WHITE ) ; s . put Client Property ( STR_ , f ) ; s . put Client Property ( STR_ , new Integer ( param ) ) ; s . set Preferred Size ( new Dimension ( NUM_ , NUM_ ) ) ; s . set Maximum Size ( new Dimension ( NUM_ , NUM_ ) ) ; return s ; }
public KNN Distance Order Result run ( Database database , Relation < O > relation ) { final Distance Query < O > distance Query = database . get Distance Query ( relation , get Distance Function ( ) ) ; final KNN Query < O > knn Query = database . get KNN Query ( distance Query , k + NUM_ ) ; final int size = ( int ) ( ( sample <= NUM_ ) ? Math . ceil ( relation . size ( ) * sample ) : sample ) ; DBI Ds sample = DBID Util . random Sample ( relation . get DBI Ds ( ) , size , rnd ) ; Finite Progress prog = LOG . is Verbose ( ) ? new Finite Progress ( STR_ , size , LOG ) : null ; double [ ] knn Distances = new double [ size ] ; int i = NUM_ ; for ( DBID Iter iditer = sample . iter ( ) ; iditer . valid ( ) ; iditer . advance ( ) , i ++ ) { final KNN List neighbors = knn Query . get KNN For DBID ( iditer , k + NUM_ ) ; knn Distances [ i ] = neighbors . get KNN Distance ( ) ; LOG . increment Processed ( prog ) ; } LOG . ensure Completed ( prog ) ; return new KNN Distance Order Result ( knn Distances , k ) ; }
public Abstract RDF Parser ( Value Factory value Factory ) { try { md 5 = Message Digest . get Instance ( STR_ ) ; } catch ( No Such Algorithm Exception e ) { throw new Runtime Exception ( e ) ; } namespace Table = new Hash Map < String , String > ( NUM_ ) ; next B Node Prefix = create Unique B Node Prefix ( ) ; set Value Factory ( value Factory ) ; set Parser Config ( new Parser Config ( ) ) ; }
public Distribution Bean Query ( final Query Definition definition , final Map < String , Object > query Config , final Object [ ] sort Property Ids , final boolean [ ] sort States ) { super ( definition , query Config , sort Property Ids , sort States ) ; if ( Hawkbit Common Util . is Not Null Or Empty ( query Config ) ) { distribution Tags = ( Collection < String > ) query Config . get ( SPUI Definitions . FILTER BY TAG ) ; search Text = ( String ) query Config . get ( SPUI Definitions . FILTER BY TEXT ) ; no Tag Clicked = ( Boolean ) query Config . get ( SPUI Definitions . FILTER BY NO TAG ) ; pinned Controller Id = ( String ) query Config . get ( SPUI Definitions . ORDER BY PINNED TARGET ) ; if ( ! Strings . is Null Or Empty ( search Text ) ) { search Text = String . format ( STR_ , search Text ) ; } } if ( sort States . length > NUM_ ) { sort = new Sort ( sort States [ NUM_ ] ? Direction . ASC : Direction . DESC , ( String ) sort Property Ids [ NUM_ ] ) ; for ( int dist Id = NUM_ ; dist Id < sort Property Ids . length ; dist Id ++ ) { sort . and ( new Sort ( sort States [ dist Id ] ? Direction . ASC : Direction . DESC , ( String ) sort Property Ids [ dist Id ] ) ) ; } } }
public static void assert Equals ( String message , float expected , float actual ) { if ( expected == actual ) return ; final int max Ulps = NUM_ ; int ulps = get Ulps ( expected , actual ) ; if ( ulps <= max Ulps ) { return ; } fail ( STR_ + expected + STR_ + actual + STR_ + Math . abs ( expected - actual ) + STR_ + ulps ) ; }
public static Map < String , Object > create Payment Preference ( Dispatch Context ctx , Map < String , ? extends Object > context ) { Map < String , Object > result = new Hash Map < String , Object > ( ) ; Delegator delegator = ctx . get Delegator ( ) ; String order Id = ( String ) context . get ( STR_ ) ; String status Id = ( String ) context . get ( STR_ ) ; String payment Method Type Id = ( String ) context . get ( STR_ ) ; String payment Method Id = ( String ) context . get ( STR_ ) ; Big Decimal max Amount = ( Big Decimal ) context . get ( STR_ ) ; Generic Value user Login = ( Generic Value ) context . get ( STR_ ) ; Locale locale = ( Locale ) context . get ( STR_ ) ; String pref Id = null ; try { pref Id = delegator . get Next Seq Id ( STR_ ) ; } catch ( Illegal Argument Exception e ) { return Service Util . return Error ( Util Properties . get Message ( resource error , STR_ , locale ) ) ; } Map < String , Object > fields = Util Misc . < String , Object > to Map ( STR_ , pref Id , STR_ , order Id , STR_ , payment Method Type Id , STR_ , payment Method Id , STR_ , max Amount ) ; if ( status Id != null ) { fields . put ( STR_ , status Id ) ; } try { Generic Value v = delegator . make Value ( STR_ , fields ) ; v . set ( STR_ , Util Date Time . now Timestamp ( ) ) ; if ( user Login != null ) { v . set ( STR_ , user Login . get String ( STR_ ) ) ; } delegator . create ( v ) ; } catch ( Generic Entity Exception e ) { result . put ( Model Service . RESPONSE MESSAGE , Model Service . RESPOND ERROR ) ; result . put ( Model Service . ERROR MESSAGE , Util Properties . get Message ( resource , STR_ , Util Misc . to Map ( STR_ , e . get Message ( ) ) , locale ) ) ; return Service Util . return Failure ( ) ; } result . put ( STR_ , pref Id ) ; result . put ( Model Service . RESPONSE MESSAGE , Model Service . RESPOND SUCCESS ) ; return result ; }
public void add Change Listener ( Change Listener cl ) { if ( ! listeners . contains ( cl ) ) listeners . add ( cl ) ; }
private void escape ( String value ) throws Exception { int size = value . length ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { escape ( value . char At ( i ) ) ; } }
private boolean has Other Queued Parent Node ( Lop tmp Node , Array List < Lop > queued Nodes , Lop node ) { if ( queued Nodes . is Empty ( ) ) return false ; boolean [ ] node Marked = node . get reachable ( ) ; boolean [ ] tmp Marked = tmp Node . get reachable ( ) ; long nodeid = ID Map . get ( node . get ID ( ) ) ; long tmpid = ID Map . get ( tmp Node . get ID ( ) ) ; for ( Lop qnode : queued Nodes ) { int id = ID Map . get ( qnode . get ID ( ) ) ; if ( ( id != nodeid && node Marked [ id ] ) && ( id != tmpid && tmp Marked [ id ] ) ) return true ; } return false ; }
public void add Generated File ( File file ) { generated Files . add Element ( file ) ; }
public static < O > Indexed Collection < O > new Auto Indexed Collection ( Iterable < Attribute < O , Comparable > > attributes ) { Indexed Collection < O > auto Indexed Collection = new Concurrent Indexed Collection < O > ( ) ; for ( Attribute < O , ? extends Comparable > attribute : attributes ) { @ Suppress Warnings ( STR_ ) Navigable Index < ? extends Comparable , O > index = Navigable Index . on Attribute ( attribute ) ; auto Indexed Collection . add Index ( index ) ; } return auto Indexed Collection ; }
public Indirect Entry ( int tag , short index ) { this . tag = tag ; this . index 0 = index ; this . index 1 = NUM_ ; }
private boolean limit Label Language ( ) { if ( limit Label Languages == null ) { return true ; } Literal object = object As Literal ( ) ; String language = object . get Language ( ) ; return language != null && limit Label Languages . contains ( language ) ; }
public static int levenshtein ( String [ ] candidate , String [ ] source ) { if ( source . length == NUM_ ) return candidate . length ; if ( candidate . length == NUM_ ) return source . length ; int distances [ ] [ ] = new int [ source . length + NUM_ ] [ candidate . length + NUM_ ] ; for ( int i = NUM_ ; i <= source . length ; i ++ ) distances [ i ] [ NUM_ ] = i ; for ( int j = NUM_ ; j <= candidate . length ; j ++ ) distances [ NUM_ ] [ j ] = j ; for ( int i = NUM_ ; i <= source . length ; i ++ ) { Object source Item = source [ i - NUM_ ] ; for ( int j = NUM_ ; j <= candidate . length ; j ++ ) { Object target Item = candidate [ j - NUM_ ] ; int cost ; if ( source Item . equals ( target Item ) ) cost = NUM_ ; else cost = NUM_ ; int deletion Cost = distances [ i - NUM_ ] [ j ] + NUM_ ; int insertion Cost = distances [ i ] [ j - NUM_ ] + NUM_ ; int substitution Cost = distances [ i - NUM_ ] [ j - NUM_ ] + cost ; distances [ i ] [ j ] = minimum ( insertion Cost , deletion Cost , substitution Cost ) ; } } return distances [ source . length ] [ candidate . length ] ; }
@ Override public void create Connection Factory ( String name , boolean ha , boolean use Discovery , int cf Type , String [ ] connector Names , Object [ ] bindings ) throws Exception { check Started ( ) ; clear IO ( ) ; try { if ( use Discovery ) { if ( connector Names == null || connector Names . length == NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } server . create Connection Factory ( name , ha , JMS Factory Type . value Of ( cf Type ) , connector Names [ NUM_ ] , JMS Server Control Impl . convert ( bindings ) ) ; } else { List < String > connector List = new Array List < > ( connector Names . length ) ; for ( String str : connector Names ) { connector List . add ( str ) ; } server . create Connection Factory ( name , ha , JMS Factory Type . value Of ( cf Type ) , connector List , JMS Server Control Impl . convert ( bindings ) ) ; } } finally { block On IO ( ) ; } }
protected void delay ( long delay Ms , String desc ) { try { Thread . sleep ( delay Ms ) ; } catch ( Interrupted Exception int Exc ) { LOG . warn ( STR_ + desc , int Exc ) ; } }
private static void update Retry Counter ( Weak Reference < Context > weak Context , String filename , int max Retry Attempts ) { if ( max Retry Attempts == - NUM_ ) { return ; } Context context = null ; if ( weak Context != null ) { context = weak Context . get ( ) ; if ( context != null ) { Shared Preferences preferences = context . get Shared Preferences ( ARTISAN SDK , Context . MODE PRIVATE ) ; Shared Preferences . Editor editor = preferences . edit ( ) ; int retry Counter = preferences . get Int ( STR_ + filename , NUM_ ) ; Artisan Log Util . debug Log ( STR_ + retry Counter ) ; if ( retry Counter >= max Retry Attempts ) { Artisan Log Util . debug Log ( STR_ + max Retry Attempts ) ; delete Stack Trace ( weak Context , filename ) ; delete Retry Counter ( weak Context , filename , max Retry Attempts ) ; } else { editor . put Int ( STR_ + filename , retry Counter + NUM_ ) ; editor . apply ( ) ; } } } }
public static boolean contains Env Variables ( String source ) { return ( source . index Of ( STR_ ) >= NUM_ ) ; }
public void remove Change Report ( final Change Report change Report ) { change Reports . remove ( change Report ) ; }
public static boolean below Or Equal ( int a , int b ) { return Integer . compare Unsigned ( a , b ) <= NUM_ ; }
private static int scan Hex Sequence ( String address , int index , int end , int [ ] counter ) { char test Char ; int num Digits = NUM_ ; int start = index ; for ( ; index < end ; ++ index ) { test Char = address . char At ( index ) ; if ( test Char == STR_ ) { if ( num Digits > NUM_ && ++ counter [ NUM_ ] > NUM_ ) { return - NUM_ ; } if ( num Digits == NUM_ || ( ( index + NUM_ < end ) && address . char At ( index + NUM_ ) == STR_ ) ) { return index ; } num Digits = NUM_ ; } else if ( ! is Hex ( test Char ) ) { if ( test Char == STR_ && num Digits < NUM_ && num Digits > NUM_ && counter [ NUM_ ] <= NUM_ ) { int back = index - num Digits - NUM_ ; return ( back >= start ) ? back : ( back + NUM_ ) ; } return - NUM_ ; } else if ( ++ num Digits > NUM_ ) { return - NUM_ ; } } return ( num Digits > NUM_ && ++ counter [ NUM_ ] <= NUM_ ) ? end : - NUM_ ; }
private Method Type remove Wrapper ( Method Type target Type ) { Class [ ] types = target Type . parameter Array ( ) ; for ( int i = NUM_ ; i < types . length ; i ++ ) { if ( types [ i ] == Wrapper . class ) { target Type = target Type . change Parameter Type ( i , Object . class ) ; } } return target Type ; }
public static void add Notification Handler ( String service , Notification Handler handler ) throws Already Registered Exception { if ( notification Handlers . contains Key ( service ) ) { throw new Already Registered Exception ( PLL Bundle . get String ( STR_ ) + service ) ; } notification Handlers . put ( service , handler ) ; }
protected double find Maximum Tick Label Width ( List ticks , Graphics 2 D g 2 , Rectangle 2 D draw Area , boolean vertical ) { Rectangle Insets insets = get Tick Label Insets ( ) ; Font font = get Tick Label Font ( ) ; double max Width = NUM_ ; if ( ! vertical ) { Font Metrics fm = g 2 . get Font Metrics ( font ) ; Iterator iterator = ticks . iterator ( ) ; while ( iterator . has Next ( ) ) { Tick tick = ( Tick ) iterator . next ( ) ; Rectangle 2 D label Bounds = null ; if ( tick instanceof Log Tick ) { Log Tick lt = ( Log Tick ) tick ; if ( lt . get Attributed Label ( ) != null ) { label Bounds = Attr String Utils . get Text Bounds ( lt . get Attributed Label ( ) , g 2 ) ; } } else if ( tick . get Text ( ) != null ) { label Bounds = Text Utilities . get Text Bounds ( tick . get Text ( ) , g 2 , fm ) ; } if ( label Bounds != null && label Bounds . get Width ( ) + insets . get Left ( ) + insets . get Right ( ) > max Width ) { max Width = label Bounds . get Width ( ) + insets . get Left ( ) + insets . get Right ( ) ; } } } else { Line Metrics metrics = font . get Line Metrics ( STR_ , g 2 . get Font Render Context ( ) ) ; max Width = metrics . get Height ( ) + insets . get Top ( ) + insets . get Bottom ( ) ; } return max Width ; }
public String write ( Object value ) throws Exception { int length = Array . get Length ( value ) ; return write ( value , length ) ; }
public void copy Video Data ( Video v , Output Stream out ) throws IO Exception { Path source = get Video Path ( v ) ; if ( ! Files . exists ( source ) ) { throw new File Not Found Exception ( STR_ + v . get Id ( ) ) ; } Files . copy ( source , out ) ; }
public void migrate Volume For Expansion ( URI vplex System URI , URI vplex Volume URI , List < URI > target Volume UR Is , Map < URI , URI > migrations Map , Map < URI , URI > pool Volume Map , String op Id , String step Id ) throws Controller Exception { Workflow Step Completer . step Executing ( step Id ) ; String success Msg = String . format ( STR_ , vplex Volume URI ) ; String fail Msg = String . format ( STR_ , vplex Volume URI ) ; migrate Volumes ( vplex System URI , vplex Volume URI , target Volume UR Is , migrations Map , pool Volume Map , null , null , success Msg , fail Msg , null , op Id , step Id ) ; log . info ( STR_ ) ; }
OF Channel Handler ( @ Nonnull IOF Switch Manager switch Manager , @ Nonnull I New OF Connection Listener new Connection Listener , @ Nonnull Channel Pipeline pipeline , @ Nonnull I Debug Counter Service debug Counters , @ Nonnull Timer timer ) { Preconditions . check Not Null ( switch Manager , STR_ ) ; Preconditions . check Not Null ( new Connection Listener , STR_ ) ; Preconditions . check Not Null ( pipeline , STR_ ) ; Preconditions . check Not Null ( timer , STR_ ) ; Preconditions . check Not Null ( debug Counters , STR_ ) ; this . pipeline = pipeline ; this . debug Counters = debug Counters ; this . new Connection Listener = new Connection Listener ; this . counters = switch Manager . get Counters ( ) ; this . state = new Init State ( ) ; this . timer = timer ; log . debug ( STR_ , String . format ( STR_ , System . identity Hash Code ( this ) ) ) ; }
protected void header To XML ( ) { Element root ; Element node ; Element child ; int i ; root = m Document . get Document Element ( ) ; root . set Attribute ( ATT NAME , valid Content ( m Instances . relation Name ( ) ) ) ; root . set Attribute ( ATT VERSION , Version . VERSION ) ; node = m Document . create Element ( TAG HEADER ) ; root . append Child ( node ) ; child = m Document . create Element ( TAG ATTRIBUTES ) ; node . append Child ( child ) ; for ( i = NUM_ ; i < m Instances . num Attributes ( ) ; i ++ ) { add Attribute ( child , m Instances . attribute ( i ) ) ; } }
protected void marshal Object ( Object item , Hierarchical Stream Writer writer , Marshalling Context context ) { String node Label = mapper . serialized Class ( item . get Class ( ) ) ; writer . start Node ( node Label ) ; context . convert Another ( item ) ; writer . end Node ( ) ; }
@ Override public void on Transfer Progress ( long progress Rate , long total Transferred So Far , long total To Transfer , String file Path ) { int percent = ( int ) ( NUM_ * ( ( double ) total Transferred So Far ) / ( ( double ) total To Transfer ) ) ; if ( percent != m Last Percent ) { m Notification Builder . set Progress ( NUM_ , percent , total To Transfer < NUM_ ) ; String file Name = file Path . substring ( file Path . last Index Of ( File Utils . PATH SEPARATOR ) + NUM_ ) ; String text = String . format ( get String ( R . string . downloader download in progress content ) , percent , file Name ) ; m Notification Builder . set Content Text ( text ) ; m Notification Manager . notify ( R . string . downloader download in progress ticker , m Notification Builder . build ( ) ) ; } m Last Percent = percent ; }
public synchronized void add Listener ( final T listener ) { listeners . add ( listener ) ; }
public static < A extends Abstract Value < A > , S extends Store < S > , T extends Transfer Function < A , S > > void generate DO Tof CFG ( String input File , String output Dir , String method , String clas , boolean pdf , Analysis < A , S , T > analysis ) { Entry < Method Tree , Compilation Unit Tree > m = get Method Tree And Compilation Unit ( input File , method , clas ) ; generate DO Tof CFG ( input File , output Dir , method , clas , pdf , analysis , m . get Key ( ) , m . get Value ( ) ) ; }
public static void wait All ( @ Nullable Iterable < Ignite Future < ? > > futs ) { if ( F . is Empty ( futs ) ) return ; for ( Ignite Future fut : futs ) fut . get ( ) ; }
private static synchronized String format Date As Date ( Date d ) { return format Date In . format ( d ) ; }
private void extract Theme And Criterion Set ( ) { theme Map = new Hash Map ( ) ; criterion Map = new Hash Map ( ) ; for ( Test test : test Set ) { Criterion criterion = test . get Criterion ( ) ; if ( criterion Map . contains Key ( criterion ) ) { Integer test Counter = criterion Map . get ( criterion ) + NUM_ ; criterion Map . put ( criterion , test Counter ) ; } else { criterion Map . put ( criterion , NUM_ ) ; } Theme theme = criterion . get Theme ( ) ; if ( theme Map . contains Key ( theme ) ) { Integer test Counter = theme Map . get ( theme ) + NUM_ ; theme Map . put ( theme , test Counter ) ; } else { theme Map . put ( theme , NUM_ ) ; } } }
private Cim Connection Info create Connection Info ( ) { Cim Connection Info connection Info = new Cim Connection Info ( ) ; connection Info . set Type ( Cim Constants . ECOM CONNECTION TYPE ) ; connection Info . set Host ( PROVIDER IP ) ; connection Info . set Port ( Integer . parse Int ( PROVIDER PORT ) ) ; connection Info . set User ( PROVIDER USER ) ; connection Info . set Password ( PROVIDER PW ) ; connection Info . set Interop NS ( PROVIDER INTEROP NS ) ; connection Info . set Impl NS ( PROVIDER IMPL NS ) ; connection Info . set Use SSL ( is Provider Ssl Enabled ) ; return connection Info ; }
public void remove Minute Change Listener ( Property Change Listener l ) { pc Minutes . remove Property Change Listener ( l ) ; }
private String create New Review ( Task Data task Data , Appraise Plugin Review Client client ) throws Core Exception { boolean can Request Review = client . can Request Review ( task Data ) ; if ( ! can Request Review ) { throw new Core Exception ( Status . CANCEL STATUS ) ; } String task Id = null ; try { Review review = build Review From Task Data ( task Data ) ; review . set Timestamp ( System . current Time Millis ( ) / NUM_ ) ; String review Commit Hash = get Review Commit Hash ( task Data ) ; task Id = client . write Review ( review Commit Hash , review ) ; if ( task Id == null ) { throw new Core Exception ( Status . CANCEL STATUS ) ; } } catch ( Git Client Exception e ) { throw new Core Exception ( new Status ( I Status . ERROR , Appraise Connector Plugin . PLUGIN ID , STR_ , e ) ) ; } return task Id ; }
public static File store Catalog File ( String catalog File Name ) { File folder = null ; String folder Name ; int pos = catalog File Name . index Of ( Constants . FOLDER SEPARATOR ) ; if ( pos != - NUM_ ) { folder Name = catalog File Name . substring ( NUM_ , pos ) ; folder = new File ( get Generate Folder ( ) , folder Name ) ; } else { folder Name = STR_ ; folder = new File ( get Generate Folder ( ) , folder Name ) ; } if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } map Of Catalog Folder Names . put ( catalog File Name , folder Name ) ; File result = new File ( get Generate Folder ( ) , catalog File Name ) ; return result ; }
private void assert Emr Cluster Creation Log Not Exist ( Emr Cluster emr Cluster ) { List < Emr Cluster Creation Log Entity > list = get Emr Cluster Creation Log Entities ( emr Cluster . get Namespace ( ) , emr Cluster . get Emr Cluster Definition Name ( ) , emr Cluster . get Emr Cluster Name ( ) ) ; assert True ( STR_ , list . is Empty ( ) ) ; }
public void remove Selection Listener ( final Selection Listener listener ) { check Widget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR NULL ARGUMENT ) ; } if ( selection Listeners == null ) { return ; } selection Listeners . remove ( listener ) ; }
protected Point 2 D correct ( Point 2 D anchor , Rectangle 2 D bounds ) { if ( anchor == null ) return anchor ; double x = anchor . get X ( ) , y = anchor . get Y ( ) ; double x 1 = bounds . get Min X ( ) , y 1 = bounds . get Min Y ( ) ; double x 2 = bounds . get Max X ( ) , y 2 = bounds . get Max Y ( ) ; x = ( x < x 1 ? x 1 : ( x > x 2 ? x 2 : x ) ) ; y = ( y < y 1 ? y 1 : ( y > y 2 ? y 2 : y ) ) ; m tmp . set Location ( x , y ) ; return m tmp ; }
J Panel make Button Panel ( Action Listener update Listener , Action Listener cancel Listener , Action Listener delete Listener ) { J Panel panel 3 = new J Panel ( ) ; panel 3 . set Layout ( new Box Layout ( panel 3 , Box Layout . X AXIS ) ) ; J Button cancel Action = new J Button ( Bundle . get Message ( STR_ ) ) ; panel 3 . add ( cancel Action ) ; panel 3 . add ( Box . create Horizontal Strut ( STRUT ) ) ; cancel Action . add Action Listener ( cancel Listener ) ; cancel Action . set Tool Tip Text ( rbx . get String ( STR_ ) ) ; J Button update Action = new J Button ( Bundle . get Message ( STR_ ) ) ; panel 3 . add ( update Action ) ; panel 3 . add ( Box . create Horizontal Strut ( STRUT ) ) ; update Action . add Action Listener ( update Listener ) ; update Action . set Tool Tip Text ( rbx . get String ( STR_ ) ) ; J Button delete Action = new J Button ( Bundle . get Message ( STR_ ) ) ; panel 3 . add ( delete Action ) ; delete Action . add Action Listener ( delete Listener ) ; delete Action . set Tool Tip Text ( rbx . get String ( STR_ ) ) ; return panel 3 ; }
public void increment Value ( int v , long increment ) { increment Value ( Long . value Of ( v ) , increment ) ; }
public void register Shield ( int world Id , Siege Shield shield ) { List < Siege Shield > map Shields = registered Shields . get ( world Id ) ; if ( map Shields == null ) { map Shields = new Array List < Siege Shield > ( ) ; registered Shields . put ( world Id , map Shields ) ; } map Shields . add ( shield ) ; }
private void commit Typed ( Input Connection input Connection ) { if ( m Composing . length ( ) > NUM_ ) { input Connection . commit Text ( m Composing , m Composing . length ( ) ) ; m Composing . set Length ( NUM_ ) ; update Candidates ( ) ; } }
private void decorate From Filesystem ( final I Resource resource , final I Decoration decoration , final TFS Repository repository ) { if ( repository == null ) { decoration . add Overlay ( image Helper . get Image Descriptor ( TFS OFFLINE ICON ) ) ; } else if ( resource . get Type ( ) == I Resource . FILE && resource . is Read Only ( ) ) { decoration . add Overlay ( image Helper . get Image Descriptor ( TFS ICON ) ) ; } else if ( resource . get Type ( ) == I Resource . FILE ) { decoration . add Overlay ( image Helper . get Image Descriptor ( UNKNOWN ICON ) ) ; } else { decoration . add Overlay ( image Helper . get Image Descriptor ( TFS ICON ) ) ; } }
public static int find Next Consistency Id ( Database conn , Table ct ) throws Exception { int id = NUM_ ; try { Statement st ; st = conn . create Statement ( ) ; Result Set rs = st . execute Query ( STR_ + Consistency Table . id Column Name + STR_ + ct . get Schema ( ) + STR_ + ct . get Name ( ) ) ; if ( rs . next ( ) ) { id = rs . get Int ( NUM_ ) + NUM_ ; } rs . close ( ) ; st . close ( ) ; } catch ( Exception e ) { logger . error ( STR_ + e . get Message ( ) ) ; throw e ; } return id ; }
protected final void end Of Input ( ) throws IO Exception { if ( cache Request != null ) { cache Body . close ( ) ; } http Engine . release ( false ) ; }
private void enable Recover Point Tag ( Db Client db Client , WBEM Client client , CIM Object Path device Group Path ) { try { boolean is RP Tag Needed = false ; for ( Volume URIHLU vol Uri Hlu : volume URIHL Us ) { URI volume URI = vol Uri Hlu . get Volume URI ( ) ; Block Object bo = null ; if ( URI Util . is Type ( volume URI , Block Snapshot . class ) ) { bo = db Client . query Object ( Block Snapshot . class , volume URI ) ; } else if ( URI Util . is Type ( volume URI , Volume . class ) ) { bo = db Client . query Object ( Volume . class , volume URI ) ; } if ( bo != null && Block Object . check For RP ( db Client , bo . get Id ( ) ) ) { is RP Tag Needed = true ; break ; } } if ( is RP Tag Needed ) { log . info ( STR_ + device Group Path . to String ( ) ) ; CIM Property Factory factory Ref = ( CIM Property Factory ) Controller Service Impl . get Bean ( STR_ ) ; CIM Instance to Update = new CIM Instance ( device Group Path , new CIM Property [ ] { factory Ref . bool ( Smis Constants . EMC RECOVERPOINT ENABLED , true ) } ) ; log . debug ( STR_ + to Update . to String ( ) ) ; client . modify Instance ( to Update , Smis Constants . CP EMC RECOVERPOINT ENABLED ) ; log . info ( String . format ( STR_ ) ) ; } } catch ( WBEM Exception e ) { log . error ( STR_ , e ) ; } catch ( Database Exception e ) { log . error ( STR_ , e ) ; } }
private String print X Format ( short x ) { String sx = null ; if ( x == Short . MIN VALUE ) sx = STR_ ; else if ( x < NUM_ ) { String t ; if ( x == Short . MIN VALUE ) t = STR_ ; else { t = Integer . to String ( ( ~ ( - x - NUM_ ) ) ^ Short . MIN VALUE , NUM_ ) ; if ( t . char At ( NUM_ ) == STR_ || t . char At ( NUM_ ) == STR_ ) t = t . substring ( NUM_ , NUM_ ) ; } switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : switch ( t . char At ( NUM_ ) ) { case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; } break ; } } else sx = Integer . to String ( x , NUM_ ) ; return print X Format ( sx ) ; }
public void populate Frame ( Audio a ) { sys Name . set Text ( a . get System Name ( ) ) ; user Name . set Text ( a . get User Name ( ) ) ; }
public static Class < ? > class For Name ( String class Name ) { try { return Class . for Name ( class Name ) ; } catch ( Class Not Found Exception | Verify Error e ) { return null ; } }
public boolean object Is Checked ( Pdf Object object ) { return checked Objects . contains ( object ) ; }
public static void update Token ( final String oauth Token ) { player . login ( oauth Token ) ; }
private void send Changed ( Service Registrar reg , String [ ] cur Groups ) { Unicast Response resp = ( Unicast Response ) registrars . get ( reg . get Service ID ( ) ) ; registrars . put ( reg . get Service ID ( ) , new Unicast Response ( resp . get Host ( ) , resp . get Port ( ) , cur Groups , resp . get Registrar ( ) ) ) ; if ( ! listeners . is Empty ( ) ) { add Notify ( ( Array List ) listeners . clone ( ) , map Reg To Groups ( reg , cur Groups ) , CHANGED ) ; } }
public final < T > T evaluate ( final Map < Long , Object > p Input Params , Class < T > result Type ) throws Rule Evaluation Exception { try { return Type Converter . cast To Type ( evaluate ( p Input Params ) , result Type ) ; } catch ( Class Cast Exception ce ) { throw new Rule Evaluation Exception ( STR_ + result Type . get Name ( ) ) ; } }
private int recalculate ( String method , Weapon Type Wrapper weapon , int attack Speed , int time ) { int final Time = NUM_ ; Tree Map < Weapon Type , float [ ] > list = new Tree Map < Weapon Type , float [ ] > ( ) ; float dagger [ ] = { NUM_ , NUM_ } ; list . put ( Weapon Type . DAGGER 1 H , dagger ) ; float mace [ ] = { NUM_ , NUM_ } ; list . put ( Weapon Type . MACE 1 H , mace ) ; list . put ( Weapon Type . GUN 1 H , mace ) ; list . put ( Weapon Type . TOOLHOE 1 H , mace ) ; float sword 1 h [ ] = { NUM_ , NUM_ } ; list . put ( Weapon Type . SWORD 1 H , sword 1 h ) ; float bookorb [ ] = { NUM_ , NUM_ } ; list . put ( Weapon Type . BOOK 2 H , bookorb ) ; list . put ( Weapon Type . ORB 2 H , bookorb ) ; float polearm [ ] = { NUM_ , NUM_ } ; list . put ( Weapon Type . POLEARM 2 H , polearm ) ; list . put ( Weapon Type . TOOLPICK 2 H , polearm ) ; list . put ( Weapon Type . TOOLROD 2 H , polearm ) ; list . put ( Weapon Type . CANNON 2 H , polearm ) ; list . put ( Weapon Type . GUN 2 H , polearm ) ; list . put ( Weapon Type . KEYBLADE 2 H , polearm ) ; list . put ( Weapon Type . KEYHAMMER 2 H , polearm ) ; float staff [ ] = { NUM_ , NUM_ } ; list . put ( Weapon Type . STAFF 2 H , staff ) ; list . put ( Weapon Type . HARP 2 H , staff ) ; float swordbow [ ] = { NUM_ , NUM_ } ; list . put ( Weapon Type . SWORD 2 H , swordbow ) ; list . put ( Weapon Type . BOW , swordbow ) ; float speed = NUM_ ; if ( method . equals Ignore Case ( STR_ ) ) { speed = list . get ( weapon . get Main Hand ( ) ) [ NUM_ ] ; if ( weapon . get Off Hand ( ) != null ) { speed += ( list . get ( weapon . get Off Hand ( ) ) [ NUM_ ] * NUM_ ) ; } } else if ( method . equals Ignore Case ( STR_ ) ) { speed = list . get ( weapon . get Main Hand ( ) ) [ NUM_ ] ; if ( weapon . get Off Hand ( ) != null ) { speed += ( list . get ( weapon . get Off Hand ( ) ) [ NUM_ ] * NUM_ ) ; } } else { try { speed = Float . parse Float ( method ) ; } catch ( Exception e ) { } } final Time = Math . round ( ( float ) time / ( float ) attack Speed * speed ) ; return final Time ; }
@ Override public boolean supports Db ( String type ) { return true ; }
private void configure Button ( J Button button ) { Font button Font = ( Font ) Default Lookup . get ( option Pane , this , STR_ ) ; if ( button Font != null ) { button . set Font ( button Font ) ; } }
private static boolean is Empty ( String field ) { if ( field == null || field . is Empty ( ) ) { return true ; } return false ; }
private void prepare Initiator Data ( ) throws Exception { String current Label = STR_ ; Initiator initiator = new Initiator ( ) ; initiator . set Id ( URI Util . create Id ( Initiator . class ) ) ; initiator . set Host Name ( current Label ) ; initiator . set Initiator Port ( STR_ ) ; initiator . set Initiator Node ( STR_ ) ; initiator . set Protocol ( STR_ ) ; initiator . set Is Manual Creation ( false ) ; db Client . create Object ( initiator ) ; rp Test Initiator UR Is . add ( initiator . get Id ( ) ) ; rp Test Initiators . add ( initiator ) ; current Label = STR_ ; initiator = new Initiator ( ) ; initiator . set Id ( URI Util . create Id ( Initiator . class ) ) ; initiator . set Host Name ( current Label ) ; initiator . set Initiator Port ( STR_ ) ; initiator . set Initiator Node ( STR_ ) ; initiator . set Protocol ( STR_ ) ; initiator . set Is Manual Creation ( false ) ; db Client . create Object ( initiator ) ; rp Test Initiator UR Is . add ( initiator . get Id ( ) ) ; rp Test Initiators . add ( initiator ) ; current Label = STR_ ; initiator = new Initiator ( ) ; initiator . set Id ( URI Util . create Id ( Initiator . class ) ) ; initiator . set Host Name ( Null Column Value Getter . get Null Str ( ) ) ; initiator . set Initiator Port ( STR_ ) ; initiator . set Initiator Node ( STR_ ) ; initiator . set Protocol ( STR_ ) ; initiator . set Is Manual Creation ( false ) ; db Client . create Object ( initiator ) ; rp Test Initiator UR Is . add ( initiator . get Id ( ) ) ; rp Test Initiators . add ( initiator ) ; current Label = STR_ ; initiator = new Initiator ( ) ; initiator . set Id ( URI Util . create Id ( Initiator . class ) ) ; initiator . set Host Name ( Null Column Value Getter . get Null Str ( ) ) ; initiator . set Initiator Port ( STR_ ) ; initiator . set Initiator Node ( STR_ ) ; initiator . set Protocol ( STR_ ) ; initiator . set Is Manual Creation ( false ) ; db Client . create Object ( initiator ) ; rp Test Initiator UR Is . add ( initiator . get Id ( ) ) ; rp Test Initiators . add ( initiator ) ; List < URI > initiator UR Is = db Client . query By Type ( Initiator . class , false ) ; int count = NUM_ ; for ( @ Suppress Warnings ( STR_ ) URI ignore : initiator UR Is ) { count ++ ; } Assert . assert True ( STR_ + count , count == NUM_ ) ; }
private Workflow . Method create CG Method ( URI vplex URI , URI cg URI , Collection < URI > vplex Volume URI List ) { return new Workflow . Method ( CREATE CG METHOD NAME , vplex URI , cg URI , vplex Volume URI List ) ; }
public static void validate Key ( String key ) throws State Store Exception { if ( String Utils . is Blank ( key ) ) { throw new State Store Exception ( STR_ ) ; } if ( key . contains ( STR_ ) ) { throw new State Store Exception ( STR_ ) ; } }
protected List < Memory Manager MX Bean > load Raw Datas ( Map < Object , Object > user Data ) { return Management Factory . get Memory Manager MX Beans ( ) ; }
public static Point 2 D find Distanced Point ( double t , Point 2 D sp , Point 2 D c 1 , Point 2 D c 2 , Point 2 D ep ) { double d = NUM_ - t ; double d Cube = d * d * d ; double d Sqr = d * d ; double t Cube = t * t * t ; double t Sqr = t * t ; double x Coord = ( d Cube * sp . get X ( ) ) + ( NUM_ * t * d Sqr * c 1 . get X ( ) ) + ( NUM_ * t Sqr * d * c 2 . get X ( ) ) + ( t Cube * ep . get X ( ) ) ; double y Coord = ( d Cube * sp . get Y ( ) ) + ( NUM_ * t * d Sqr * c 1 . get Y ( ) ) + ( NUM_ * t Sqr * d * c 2 . get Y ( ) ) + ( t Cube * ep . get Y ( ) ) ; return new Point 2 D . Double ( x Coord , y Coord ) ; }
public boolean has Statement ( final Resource s , final URI p , final Value o , final boolean include Inferred , final Resource ... c ) throws Exception { if ( c == null ) { throw new Illegal Argument Exception ( ) ; } final UUID uuid = UUID . random UUID ( ) ; final Connect Options opts = mgr . new Query Connect Options ( sparql Endpoint URL , uuid , tx ) ; opts . add Request Param ( STR_ ) ; opts . add Request Param ( Remote Repository Decls . INCLUDE INFERRED , Boolean . to String ( include Inferred ) ) ; if ( s != null ) { opts . add Request Param ( STR_ , Encode Decode Value . encode Value ( s ) ) ; } if ( p != null ) { opts . add Request Param ( STR_ , Encode Decode Value . encode Value ( p ) ) ; } if ( o != null ) { opts . add Request Param ( STR_ , Encode Decode Value . encode Value ( o ) ) ; } opts . add Request Param ( STR_ , Encode Decode Value . encode Contexts ( c ) ) ; Jetty Response Listener resp = null ; try { opts . set Accept Header ( Connect Options . MIME APPLICATION XML ) ; check Response Code ( resp = do Connect ( opts ) ) ; final Boolean Result result = Remote Repository Manager . boolean Results ( resp ) ; return result . result ; } finally { if ( resp != null ) resp . abort ( ) ; } }
public Type Variable type Variable ( Type Node type Node ) { Type Variable result = type Variable Map . get ( type Node ) ; if ( result == null ) { int id = type Variable List . size ( ) ; type Variable List . add ( null ) ; result = new Type Variable ( id , this , type Node ) ; type Variable List . set ( id , result ) ; type Variable Map . put ( type Node , result ) ; } return result ; }
@ Override public synchronized void update Object ( int column Index , Object x ) throws SQL Exception { super . update Object ( column Index , JDBC 42 Helper . convert Java Time To Java Sql ( x ) ) ; }
void reset ( ) { my Parser Count = NUM_ ; my Parser Files = null ; my Layout Name = null ; my Layout Embedded Parser = null ; }
public int support ( ) { return m counter ; }
public void fill Default Values ( ) { cb Plasticity Type . set Selected Index ( Short Term Plasticity Rule . DEFAULT PLASTICITY TYPE ) ; tf Base Line Strength . set Text ( Double . to String ( Short Term Plasticity Rule . DEFAULT BASE LINE STRENGTH ) ) ; tf Firing Threshold . set Text ( Double . to String ( Short Term Plasticity Rule . DEFAULT FIRING THRESHOLD ) ) ; tf Bump Rate . set Text ( Double . to String ( Short Term Plasticity Rule . DEFAULT BUMP RATE ) ) ; tf Decay Rate . set Text ( Double . to String ( Short Term Plasticity Rule . DEFAULT DECAY RATE ) ) ; }
@ Suppress Warnings ( STR_ ) private void render Connections Background ( final Input Ports input Ports , final Output Ports ports , final Graphics 2 D g 2 ) { for ( int i = NUM_ ; i < ports . get Number Of Ports ( ) ; i ++ ) { Output Port from = ports . get Port By Index ( i ) ; Port to = from . get Destination ( ) ; if ( to != null ) { Shape connector = Process Draw Utils . create Connector ( from , to , model ) ; if ( connector == null ) { return ; } g 2 . set Color ( Color . WHITE ) ; if ( from . get Meta Data ( ) instanceof Collection Meta Data ) { g 2 . set Stroke ( CONNECTION COLLECTION LINE BACKGROUND STROKE ) ; } else { g 2 . set Stroke ( CONNECTION LINE BACKGROUND STROKE ) ; } g 2 . draw ( connector ) ; } } }
public static Workflow . Method relink Block Snapshot Session Target Method ( URI system URI , URI tgt Snap Session URI , URI snapshot URI ) { return new Workflow . Method ( RELINK SNAPSHOT SESSION TARGET METHOD , system URI , tgt Snap Session URI , snapshot URI ) ; }
public Gradient Formatter ( float max Score , String min Foreground Color , String max Foreground Color , String min Background Color , String max Background Color ) { highlight Foreground = ( min Foreground Color != null ) && ( max Foreground Color != null ) ; if ( highlight Foreground ) { if ( min Foreground Color . length ( ) != NUM_ ) { throw new Illegal Argument Exception ( STR_ + STR_ ) ; } if ( max Foreground Color . length ( ) != NUM_ ) { throw new Illegal Argument Exception ( STR_ + STR_ ) ; } fg R Min = hex To Int ( min Foreground Color . substring ( NUM_ , NUM_ ) ) ; fg G Min = hex To Int ( min Foreground Color . substring ( NUM_ , NUM_ ) ) ; fg B Min = hex To Int ( min Foreground Color . substring ( NUM_ , NUM_ ) ) ; fg R Max = hex To Int ( max Foreground Color . substring ( NUM_ , NUM_ ) ) ; fg G Max = hex To Int ( max Foreground Color . substring ( NUM_ , NUM_ ) ) ; fg B Max = hex To Int ( max Foreground Color . substring ( NUM_ , NUM_ ) ) ; } highlight Background = ( min Background Color != null ) && ( max Background Color != null ) ; if ( highlight Background ) { if ( min Background Color . length ( ) != NUM_ ) { throw new Illegal Argument Exception ( STR_ + STR_ ) ; } if ( max Background Color . length ( ) != NUM_ ) { throw new Illegal Argument Exception ( STR_ + STR_ ) ; } bg R Min = hex To Int ( min Background Color . substring ( NUM_ , NUM_ ) ) ; bg G Min = hex To Int ( min Background Color . substring ( NUM_ , NUM_ ) ) ; bg B Min = hex To Int ( min Background Color . substring ( NUM_ , NUM_ ) ) ; bg R Max = hex To Int ( max Background Color . substring ( NUM_ , NUM_ ) ) ; bg G Max = hex To Int ( max Background Color . substring ( NUM_ , NUM_ ) ) ; bg B Max = hex To Int ( max Background Color . substring ( NUM_ , NUM_ ) ) ; } this . max Score = max Score ; }
protected void process Window Event ( Window Event e ) { super . process Window Event ( e ) ; if ( e . get ID ( ) == Window Event . WINDOW CLOSING ) { j Menu File Exit action Performed ( null ) ; } }
protected void sprint ( int int Field ) { sprint ( String . value Of ( int Field ) ) ; }
public static float scale To Fit Target Size ( int [ ] dimensions , int target Width , int target Height ) { if ( dimensions . length < NUM_ || dimensions [ NUM_ ] <= NUM_ || dimensions [ NUM_ ] <= NUM_ ) { throw new Illegal Argument Exception ( STR_ + STR_ ) ; } float scale = Math . max ( ( float ) target Width / dimensions [ NUM_ ] , ( float ) target Height / dimensions [ NUM_ ] ) ; dimensions [ NUM_ ] *= scale ; dimensions [ NUM_ ] *= scale ; return scale ; }
@ Override public void from Data ( Data Input in ) throws IO Exception , Class Not Found Exception { super . from Data ( in ) ; refresh Interval = in . read Long ( ) ; alert Defs = ( Stat Alert Definition [ ] ) Data Serializer . read Object Array ( in ) ; }
public Thread Interrupter ( ) { this ( Thread . current Thread ( ) ) ; }
private void generate Inner Class Handles ( I Type type , I Binary Type type Info , Array List children Handles ) { I Binary Nested Type [ ] inner Types = type Info . get Member Types ( ) ; if ( inner Types != null ) { I Package Fragment pkg = ( I Package Fragment ) type . get Ancestor ( I Java Element . PACKAGE FRAGMENT ) ; for ( int i = NUM_ , type Count = inner Types . length ; i < type Count ; i ++ ) { I Binary Nested Type binary Type = inner Types [ i ] ; I Class File parent Class File = pkg . get Class File ( new String ( Class File . unqualified Name ( binary Type . get Name ( ) ) ) + SUFFIX STRING class ) ; I Type inner Type = new Binary Type ( ( Java Element ) parent Class File , ( ( Java Element ) parent Class File ) . manager , Class File . simple Name ( binary Type . get Name ( ) ) ) ; children Handles . add ( inner Type ) ; } } }
public static String format Month Year ( Context context , Time time ) { int flags = Date Utils . FORMAT SHOW DATE | Date Utils . FORMAT NO MONTH DAY | Date Utils . FORMAT SHOW YEAR ; long millis = time . to Millis ( true ) ; return format Date Range ( context , millis , millis , flags ) ; }
private void notify Db Svc With Obsolete Cassandra Peers ( String svc Name , List < String > peer List ) { String result = String Utils . join ( peer List . iterator ( ) , STR_ ) ; update Db Svc Config ( svc Name , Constants . OBSOLETE CASSANDRA PEERS , result ) ; }
public Future < ? > build Index Async ( ) { return Futures . immediate Checked Future ( null ) ; }
protected void unexpected Message ( int transaction Id , Message Type type , Channel channel ) { String message = STR_ + type ; logger . warn ( STR_ , new Object [ ] { get Local Node Id String ( ) , get Remote Node Id String ( ) , message } ) ; channel . write And Flush ( get Error ( transaction Id , new Sync Exception ( message ) , type ) ) ; }
public int calculate Partition ( char initial Char , int num Partitions ) { final int partition Size = ( int ) ( Math . ceil ( NUM_ / ( double ) num Partitions ) ) ; int initial Char = ( int ) initial Char ; if ( initial Char < STR_ ) return NUM_ ; if ( initial Char > STR_ ) return num Partitions - NUM_ ; return ( initial Char - NUM_ ) / partition Size ; }
public Elapsed Time Collector ( ) { super ( ) ; start Time = System . nano Time ( ) ; }
public boolean language Cost Ignore ( String languagename ) { boolean ignore ; switch ( languagename ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : ignore = true ; break ; default : ignore = false ; break ; } return ignore ; }
private static void log Not Supported Reason For Tiering Policy Change ( Map < String , Change > changes , String Buffer not Supp Reason Buff , String [ ] exclude , String v Pool Type ) { not Supp Reason Buff . append ( String . format ( STR_ , v Pool Type ) ) ; for ( String key : changes . key Set ( ) ) { s logger . info ( STR_ , v Pool Type , key ) ; not Supp Reason Buff . append ( key + STR_ ) ; } s logger . info ( STR_ , not Supp Reason Buff . to String ( ) ) ; s logger . info ( String . format ( STR_ , Arrays . to String ( exclude ) ) ) ; }
public int [ ] check Sum Range ( ) { synchronized ( this . checksum Lock ) { if ( this . checksum Range != null && checksum Range . length > NUM_ ) { return Arrays . copy Of ( this . checksum Range , this . checksum Range . length ) ; } return new int [ NUM_ ] ; } }
private List < Rule > parse Rules ( JSON Array rules ) throws Ade Usage Exception , JSON Exception { if ( rules . length ( ) == NUM_ ) throw new Ade Usage Exception ( STR_ ) ; List < Rule > current Rules = new Array List < Rule > ( ) ; for ( int i = NUM_ ; i < rules . length ( ) ; i ++ ) { JSON Object rule = rules . get JSON Object ( i ) ; String name = rule . get String ( STR_ ) ; String description = rule . get String ( STR_ ) ; String membership Rule = rule . get String ( STR_ ) ; if ( ! verify String Param ( name , NUM_ , STR_ ) || ( description != null && description . length ( ) > NUM_ ) || name . equals Ignore Case ( STR_ ) || ! verify String Param ( membership Rule , NUM_ , STR_ ) ) { throw new Ade Usage Exception ( STR_ ) ; } current Rules . add ( new Rule ( name , membership Rule , description ) ) ; validate Rule Names ( current Rules ) ; } return current Rules ; }
protected void fill Kernel Ordinates ( Complex Array ordinates , double band Width ) { final int length = ordinates . length ; final double a = NUM_ / ( Math . sqrt ( NUM_ * Math . PI ) * band Width ) ; final double precision = - NUM_ / ( band Width * band Width ) ; for ( int i = NUM_ ; i < length ; i ++ ) { final double x = ordinates . real [ i ] ; ordinates . real [ i ] = a * Math . exp ( x * x * precision ) ; } }
static Coder Result overflow ( Char Buffer input , int i , Char Buffer output , int j ) { input . position ( i - input . array Offset ( ) ) ; output . position ( j - output . array Offset ( ) ) ; return Coder Result . OVERFLOW ; }
private String print O Format ( int x ) { String sx = null ; if ( x == Integer . MIN VALUE ) sx = STR_ ; else if ( x < NUM_ ) { String t = Integer . to String ( ( ~ ( - x - NUM_ ) ) ^ Integer . MIN VALUE , NUM_ ) ; switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t . substring ( NUM_ ) ; break ; } } else sx = Integer . to String ( x , NUM_ ) ; return print O Format ( sx ) ; }
private File check Baseline ( File baseline Parent Dir ) throws IO Exception { File baseline Dir = null ; if ( null != baseline Parent Dir ) { baseline Dir = get Backup Dir ( baseline Parent Dir ) ; if ( ! baseline Dir . exists ( ) ) { baseline Dir = find Baseline For This Member ( baseline Parent Dir ) ; } if ( null != baseline Dir ) { File incomplete Backup = new File ( baseline Dir , INCOMPLETE BACKUP ) ; if ( incomplete Backup . exists ( ) ) { baseline Dir = null ; } } } return baseline Dir ; }
private void notify Lines ( final Key output Type , final Iterator < String > lines , final String Builder line Builder ) { if ( ! lines . has Next ( ) ) return ; if ( line Builder . length ( ) > NUM_ ) { line Builder . append ( lines . next ( ) ) ; if ( lines . has Next ( ) ) { final String line = line Builder . to String ( ) ; notify Line ( line , output Type ) ; line Builder . set Length ( NUM_ ) ; } } while ( true ) { String line = null ; if ( lines . has Next ( ) ) { line = lines . next ( ) ; } if ( lines . has Next ( ) ) { notify Line ( line , output Type ) ; } else { if ( line != null && line . length ( ) > NUM_ ) { line Builder . append ( line ) ; } break ; } } }
private < T > Iterator < T > touch ( Iterator < T > iter ) { iter . has Next ( ) ; return iter ; }
@ Override protected byte [ ] encrypt ( byte type , byte [ ] fragment , int offset , int len ) { try { int content mac length = len + hash size ; int padding length = ( block size == NUM_ ) ? NUM_ : get Padding Size ( ++ content mac length ) ; byte [ ] res = new byte [ content mac length + padding length ] ; System . arraycopy ( fragment , offset , res , NUM_ , len ) ; mac material part [ NUM_ ] = type ; mac material part [ NUM_ ] = ( byte ) ( ( NUM_ & len ) > > NUM_ ) ; mac material part [ NUM_ ] = ( byte ) ( NUM_ & len ) ; message Digest . update ( mac write secret ) ; message Digest . update ( pad 1 ) ; message Digest . update ( write seq num ) ; message Digest . update ( mac material part ) ; message Digest . update ( fragment , offset , len ) ; byte [ ] digest = message Digest . digest ( ) ; message Digest . update ( mac write secret ) ; message Digest . update ( pad 2 ) ; message Digest . update ( digest ) ; digest = message Digest . digest ( ) ; System . arraycopy ( digest , NUM_ , res , len , hash size ) ; if ( block size != NUM_ ) { Arrays . fill ( res , content mac length - NUM_ , res . length , ( byte ) ( padding length ) ) ; } if ( logger != null ) { logger . println ( STR_ + ( block size != NUM_ ? STR_ + padding length + STR_ : STR_ ) ) ; logger . print ( res ) ; } byte [ ] rez = new byte [ enc Cipher . get Output Size ( res . length ) ] ; enc Cipher . update ( res , NUM_ , res . length , rez ) ; inc Sequence Number ( write seq num ) ; return rez ; } catch ( General Security Exception e ) { e . print Stack Trace ( ) ; throw new Alert Exception ( Alert Protocol . INTERNAL ERROR , new SSL Protocol Exception ( STR_ ) ) ; } }
private void write UTF Body ( String s ) throws IO Exception { int limit = MAX BLOCK SIZE - NUM_ ; int len = s . length ( ) ; for ( int off = NUM_ ; off < len ; ) { int csize = Math . min ( len - off , CHAR BUF SIZE ) ; s . get Chars ( off , off + csize , cbuf , NUM_ ) ; for ( int cpos = NUM_ ; cpos < csize ; cpos ++ ) { char c = cbuf [ cpos ] ; if ( pos <= limit ) { if ( c <= NUM_ && c != NUM_ ) { buf [ pos ++ ] = ( byte ) c ; } else if ( c > NUM_ ) { buf [ pos + NUM_ ] = ( byte ) ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; buf [ pos + NUM_ ] = ( byte ) ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; buf [ pos + NUM_ ] = ( byte ) ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; pos += NUM_ ; } else { buf [ pos + NUM_ ] = ( byte ) ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; buf [ pos + NUM_ ] = ( byte ) ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; pos += NUM_ ; } } else { if ( c <= NUM_ && c != NUM_ ) { write ( c ) ; } else if ( c > NUM_ ) { write ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; write ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; write ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; } else { write ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; write ( NUM_ | ( ( c > > NUM_ ) & NUM_ ) ) ; } } } off += csize ; } }
public void init Meta Data ( Frame Block meta ) { if ( meta == null || meta . get Num Rows ( ) <= NUM_ ) return ; for ( int j = NUM_ ; j < col List . length ; j ++ ) { int col ID = col List [ j ] ; rcd Maps . put ( col ID , meta . get Recode Map ( col ID - NUM_ ) ) ; } }
@ Override public boolean equals ( Object o ) { if ( o == this ) { return true ; } if ( ! ( o instanceof Type Token < ? > ) ) { return false ; } Type Token < ? > t = ( Type Token < ? > ) o ; return type . equals ( t . type ) ; }
public static long decrypt CTR ( final byte [ ] concatenated Hash Value , final String base 64 Encrypted Turn Over Value , final Secret Key symmetric Key ) throws No Such Algorithm Exception , No Such Provider Exception , No Such Padding Exception , Invalid Key Exception , Invalid Algorithm Parameter Exception , Illegal Block Size Exception , Bad Padding Exception { final Byte Buffer byte Buffer IV = Byte Buffer . allocate ( NUM_ ) ; byte Buffer IV . put ( concatenated Hash Value ) ; final byte [ ] IV = byte Buffer IV . array ( ) ; final byte [ ] encrypted Turn Over Value = Cash Box Utils . base 64 Decode ( base 64 Encrypted Turn Over Value , false ) ; final Iv Parameter Spec iv Spec = new Iv Parameter Spec ( IV ) ; final Cipher cipher = Cipher . get Instance ( STR_ , STR_ ) ; cipher . init ( Cipher . DECRYPT MODE , symmetric Key , iv Spec ) ; final byte [ ] test Plain Turn Over Value Complete = cipher . do Final ( encrypted Turn Over Value ) ; return get Long ( test Plain Turn Over Value Complete ) ; }
boolean add REST Remote Policy Listener ( SSO Token app Token , String service Name , String notification URL , boolean re Register ) { boolean status = false ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + service Name + STR_ + notification URL ) ; } if ( remote Policy Listeners . contains ( service Name ) && ! re Register ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + service Name + STR_ + notification URL + STR_ ) ; } return status ; } if ( app Token != null ) { try { String policy Service Listener URL = null ; policy Service Listener URL = get REST Policy Service Listener URL ( app Token ) ; String root URL = get Root URL ( notification URL ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + STR_ + service Name + STR_ + notification URL + STR_ + root URL + STR_ + policy Service Listener URL ) ; } Set < String > resource Names = new Hash Set < String > ( ) ; resource Names . add ( root URL ) ; String query String = build Register Listener Query String ( app Token , service Name , resource Names ) ; query String += STR_ + URL Encoder . encode ( notification URL , STR_ ) ; String resource Content = post Form ( app Token , policy Service Listener URL , query String ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + STR_ + resource Content ) ; } status = true ; remote Policy Listeners . add ( service Name ) ; } catch ( Unsupported Encoding Exception e ) { debug . error ( STR_ + STR_ , e ) ; } catch ( SSO Exception se ) { debug . error ( STR_ + STR_ , se ) ; } catch ( Policy Exception pe ) { debug . error ( STR_ + STR_ , pe ) ; } } else { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ ) ; } } return status ; }
public static XML Reader create XML Reader ( boolean validating , boolean namespace Aware ) throws Exception { SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; factory . set Validating ( validating ) ; factory . set Namespace Aware ( namespace Aware ) ; SAX Parser parser = factory . new SAX Parser ( ) ; return parser . get XML Reader ( ) ; }
public static Statistics new Instance ( Control Thread parent ) throws Security Exception , No Such Method Exception , Illegal Argument Exception , Instantiation Exception , Illegal Access Exception , Invocation Target Exception { final Constructor < ? extends Statistics > c = statsclazz . get Constructor ( new Class [ ] { Control Thread . class } ) ; Statistics st = c . new Instance ( new Object [ ] { parent } ) ; return st ; }
public Cholesky Decomposition ( Matrix Arg ) { double [ ] [ ] A = Arg . get Array ( ) ; n = Arg . get Row Dimension ( ) ; L = new double [ n ] [ n ] ; isspd = ( Arg . get Column Dimension ( ) == n ) ; for ( int j = NUM_ ; j < n ; j ++ ) { double [ ] Lrowj = L [ j ] ; double d = NUM_ ; for ( int k = NUM_ ; k < j ; k ++ ) { double [ ] Lrowk = L [ k ] ; double s = NUM_ ; for ( int i = NUM_ ; i < k ; i ++ ) { s += Lrowk [ i ] * Lrowj [ i ] ; } Lrowj [ k ] = s = ( A [ j ] [ k ] - s ) / L [ k ] [ k ] ; d = d + s * s ; isspd = isspd & ( A [ k ] [ j ] == A [ j ] [ k ] ) ; } d = A [ j ] [ j ] - d ; isspd = isspd & ( d > NUM_ ) ; L [ j ] [ j ] = Math . sqrt ( Math . max ( d , NUM_ ) ) ; for ( int k = j + NUM_ ; k < n ; k ++ ) { L [ j ] [ k ] = NUM_ ; } } }
protected void tear Down ( ) { obj Array = null ; myobj Array = null ; ll = null ; myll = null ; reversed Linked List = null ; my Reversed Linked List = null ; s = null ; mys = null ; hm = null ; }
public Multimap < String , String > assemble All Watch Keys ( String app Id , String cluster Name , Set < String > namespaces , String data Center ) { Multimap < String , String > watched Keys Map = assemble Watch Keys ( app Id , cluster Name , namespaces , data Center ) ; if ( ! ( namespaces . size ( ) == NUM_ && namespaces . contains ( Config Consts . NAMESPACE APPLICATION ) ) ) { Set < String > namespaces Belong To App Id = namespaces Belong To App Id ( app Id , namespaces ) ; Set < String > public Namespaces = Sets . difference ( namespaces , namespaces Belong To App Id ) ; if ( ! public Namespaces . is Empty ( ) ) { watched Keys Map . put All ( find Public Config Watch Keys ( app Id , cluster Name , public Namespaces , data Center ) ) ; } } return watched Keys Map ; }
public Bounding Box intersect With ( Bounding Box bb ) { lat Min = Math . max ( lat Min , bb . lat Min ) ; lon Min = Math . max ( lon Min , bb . lon Min ) ; lat Max = Math . min ( lat Max , bb . lat Max ) ; lon Max = Math . min ( lon Max , bb . lon Max ) ; return this ; }
private static byte [ ] bytes ( int ... vals ) { final byte [ ] octets = new byte [ vals . length ] ; for ( int i = NUM_ ; i < vals . length ; i ++ ) { octets [ i ] = ( byte ) vals [ i ] ; } return octets ; }
public static final void clear Logging Behaviors ( ) { synchronized ( logging Behaviors ) { logging Behaviors . clear ( ) ; } }
@ Override public int hash Code ( ) { int hash = NUM_ ; hash = NUM_ * hash + Objects . hash Code ( this . id ) ; hash = NUM_ * hash + Objects . hash Code ( this . table ) ; hash = NUM_ * hash + Objects . hash Code ( this . object ) ; return hash ; }
protected final void fire Property Change ( Property Change Event event ) { Property Change Support a Change Support = this . change Support ; if ( a Change Support == null ) { return ; } a Change Support . fire Property Change ( event ) ; }
private static double [ ] copy Of ( final double [ ] values , final int begin , final int length ) { Math Arrays . verify Values ( values , begin , length ) ; return Arrays . copy Of Range ( values , begin , begin + length ) ; }
protected void clean Up ( ) { if ( is Release References ( ) ) { clean Up On Ack ( ) ; if ( logger . is Logging Enabled ( Log Writer . TRACE DEBUG ) ) { logger . log Debug ( STR_ + get Dialog Id ( ) ) ; } if ( event Listeners != null ) { event Listeners . clear ( ) ; } timer Task Lock = null ; ack Sem = null ; contact Header = null ; event Header = null ; first Transaction Id = null ; first Transaction Method = null ; last Response Dialog Id = null ; last Response Method = null ; last Response Top Most Via = null ; if ( original Request Record Route Headers != null ) { original Request Record Route Headers . clear ( ) ; original Request Record Route Headers = null ; original Request Record Route Headers String = null ; } if ( route List != null ) { route List . clear ( ) ; route List = null ; } responses Received In Forking Case . clear ( ) ; } }
static public Print Writer log ( Throwable xcpt , Print Writer out ) { out . println ( STR_ ) ; out . println ( xcpt . to String ( ) ) ; out . println ( STR_ ) ; out . print ( get Stack Trace ( xcpt ) ) ; out . println ( STR_ ) ; out . flush ( ) ; return out ; }
public void expire Lease ( String lease Id ) throws Illegal State Exception { assignable V Ms . expire Lease ( lease Id ) ; }
public static void remove Logging Behavior ( Logging Behavior behavior ) { synchronized ( logging Behaviors ) { logging Behaviors . remove ( behavior ) ; } }
public static void unbind References ( View view ) { try { if ( view != null ) { view . destroy Drawing Cache ( ) ; unbind View References ( view ) ; if ( view instanceof View Group ) { unbind View Group References ( ( View Group ) view ) ; } } } catch ( Throwable e ) { } }
public static void delete Sort Location If Exists ( String temp File Location ) throws Carbon Sort Key And Group By Exception { File file = new File ( temp File Location ) ; if ( file . exists ( ) ) { try { Carbon Util . delete Folders And Files ( file ) ; } catch ( Carbon Util Exception e ) { LOGGER . error ( e ) ; } } }
protected void do Validate Text Contents ( String path , String filename , String contents ) { File in File = new File ( path , filename ) ; Buffered Reader file Reader = null ; Buffered Reader text Reader = null ; Log . i ( LOG TAG , STR_ + filename + STR_ + path ) ; try { file Reader = new Buffered Reader ( new File Reader ( in File ) ) ; text Reader = new Buffered Reader ( new String Reader ( contents ) ) ; String actual = null ; String expected = null ; while ( ( actual = file Reader . read Line ( ) ) != null ) { expected = text Reader . read Line ( ) ; if ( ! actual . equals ( expected ) ) { fail ( STR_ + filename + STR_ + path + STR_ ) ; } } file Reader . close ( ) ; text Reader . close ( ) ; Log . i ( LOG TAG , STR_ + filename + STR_ ) ; } catch ( IO Exception e ) { fail ( STR_ + in File + STR_ + e . to String ( ) ) ; } }
public static void build Where Clause ( Abstract Sql Paging Query Provider provider , boolean remaining Page Query , String Builder sql ) { if ( remaining Page Query ) { sql . append ( STR_ ) ; if ( provider . get Where Clause ( ) != null ) { sql . append ( STR_ ) ; sql . append ( provider . get Where Clause ( ) ) ; sql . append ( STR_ ) ; } } else { sql . append ( provider . get Where Clause ( ) == null ? STR_ : STR_ + provider . get Where Clause ( ) ) ; } }
protected void draw Range Gridlines ( Graphics 2 D g 2 , Rectangle 2 D data Area , List ticks ) { if ( ! is Range Gridlines Visible ( ) && ! is Range Minor Gridlines Visible ( ) ) { return ; } Value Axis axis = get Range Axis ( ) ; if ( axis == null ) { return ; } Category Item Renderer r = get Renderer ( ) ; if ( r == null ) { return ; } Stroke grid Stroke = null ; Paint grid Paint = null ; boolean paint Line ; Iterator iterator = ticks . iterator ( ) ; while ( iterator . has Next ( ) ) { paint Line = false ; Value Tick tick = ( Value Tick ) iterator . next ( ) ; if ( ( tick . get Tick Type ( ) == Tick Type . MINOR ) && is Range Minor Gridlines Visible ( ) ) { grid Stroke = get Range Minor Gridline Stroke ( ) ; grid Paint = get Range Minor Gridline Paint ( ) ; paint Line = true ; } else if ( ( tick . get Tick Type ( ) == Tick Type . MAJOR ) && is Range Gridlines Visible ( ) ) { grid Stroke = get Range Gridline Stroke ( ) ; grid Paint = get Range Gridline Paint ( ) ; paint Line = true ; } if ( ( ( tick . get Value ( ) != NUM_ ) || ! is Range Zero Baseline Visible ( ) ) && paint Line ) { if ( r instanceof Abstract Category Item Renderer ) { Abstract Category Item Renderer aci = ( Abstract Category Item Renderer ) r ; aci . draw Range Line ( g 2 , this , axis , data Area , tick . get Value ( ) , grid Paint , grid Stroke ) ; } else { r . draw Range Gridline ( g 2 , this , axis , data Area , tick . get Value ( ) ) ; } } } }
private static void init ( final String package Name To Cut Off ) { if ( do Package Cut Off = ! Text Utils . is Empty ( package Name To Cut Off ) ) Log . package Name To Cut Off = package Name To Cut Off . last Index Of ( STR_ ) == package Name To Cut Off . length ( ) - NUM_ ? package Name To Cut Off : package Name To Cut Off + STR_ ; }
private static byte [ ] create File Req ( byte [ ] command , byte [ ] path ) { byte [ ] array = new byte [ NUM_ + path . length ] ; System . arraycopy ( command , NUM_ , array , NUM_ , NUM_ ) ; Array Helper . swap 32 bits To Array ( path . length , array , NUM_ ) ; System . arraycopy ( path , NUM_ , array , NUM_ , path . length ) ; return array ; }
private < V > J Component create Property Editor ( Class < V > type , Parameter Getter < Neuron Update Rule , V > getter , Parameter Setter < Neuron Update Rule , V > setter ) { if ( type == Double . class || type == Float . class ) { J Formatted Text Field field = new J Formatted Text Field ( ) ; editor List . add ( new Editor ( type , field , getter , setter ) ) ; return field ; } else if ( type == Boolean . class ) { Yes No Null drop Down = new Yes No Null ( ) ; editor List . add ( new Editor ( type , drop Down , getter , setter ) ) ; return drop Down ; } else if ( type == Integer . class ) { Choices With Null drop Down = new Choices With Null ( ) ; editor List . add ( new Editor ( type , drop Down , getter , setter ) ) ; return drop Down ; } return null ; }
public static Map < String , Integer > extract Wwn To Hlu Map ( Un Managed Export Mask un Managed Export Mask , Db Client db Client ) { Map < String , Integer > wwn To Hlu Map = new Hash Map < String , Integer > ( ) ; Iterator < Un Managed Volume > un Managed Volumes = db Client . query Iterative Objects ( Un Managed Volume . class , Collections 2 . transform ( un Managed Export Mask . get Unmanaged Volume Uris ( ) , Common Transformer Functions . FCTN STRING TO URI ) ) ; while ( un Managed Volumes . has Next ( ) ) { Un Managed Volume vol = un Managed Volumes . next ( ) ; String wwn = vol . get Wwn ( ) ; if ( wwn != null ) { wwn To Hlu Map . put ( wwn , find Hlu ( vol , un Managed Export Mask . get Mask Name ( ) ) ) ; } } logger . info ( STR_ + wwn To Hlu Map , un Managed Export Mask . get Mask Name ( ) ) ; return wwn To Hlu Map ; }
@ Override public void force Refetch ( String url , Web Page page , boolean asap ) { if ( page . get Fetch Interval ( ) > max Interval ) page . set Fetch Interval ( Math . round ( max Interval * NUM_ ) ) ; page . set Status ( ( int ) Crawl Status . STATUS UNFETCHED ) ; page . set Retries Since Fetch ( NUM_ ) ; page . set Modified Time ( NUM_ ) ; if ( asap ) page . set Fetch Time ( System . current Time Millis ( ) ) ; }
@ Override public void create I Table ( Index index ) { logger . info ( STR_ + index . to String ( ) ) ; Prepared Statement create Stmt = Prepared Statement Factory . get Prepared Statement ( generate Table Creation Syntax ( index ) , session ) ; Bound Statement bs = new Bound Statement ( create Stmt ) ; session . execute ( bs ) ; }
public KMZ Writer ( final String out Filename ) { log . set Level ( Level . INFO ) ; String filename = out Filename ; if ( filename . ends With ( STR_ ) || filename . ends With ( STR_ ) ) { filename = filename . substring ( NUM_ , filename . length ( ) - NUM_ ) ; } try { this . zip Out = new Zip Output Stream ( new File Output Stream ( filename + STR_ ) ) ; this . out = new Buffered Writer ( new Output Stream Writer ( this . zip Out , STR_ ) ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } Kml Type doc KML = kml Object Factory . create Kml Type ( ) ; Network Link Type nl = kml Object Factory . create Network Link Type ( ) ; Link Type link = kml Object Factory . create Link Type ( ) ; link . set Href ( STR_ ) ; nl . set Link ( link ) ; doc KML . set Abstract Feature Group ( kml Object Factory . create Network Link ( nl ) ) ; write Kml ( STR_ , doc KML ) ; }
private void create Methods ( I Binary Method [ ] i Methods , long source Level , char [ ] [ ] [ ] missing Type Names ) { int total = NUM_ , initial Total = NUM_ , i Clinit = - NUM_ ; int [ ] to Skip = null ; if ( i Methods != null ) { total = initial Total = i Methods . length ; boolean keep Bridge Methods = source Level < Class File Constants . JDK 1 5 ; for ( int i = total ; -- i >= NUM_ ; ) { I Binary Method method = i Methods [ i ] ; if ( ( method . get Modifiers ( ) & Class File Constants . Acc Synthetic ) != NUM_ ) { if ( keep Bridge Methods && ( method . get Modifiers ( ) & Class File Constants . Acc Bridge ) != NUM_ ) continue ; if ( to Skip == null ) to Skip = new int [ i Methods . length ] ; to Skip [ i ] = - NUM_ ; total -- ; } else if ( i Clinit == - NUM_ ) { char [ ] method Name = method . get Selector ( ) ; if ( method Name . length == NUM_ && method Name [ NUM_ ] == STR_ ) { i Clinit = i ; total -- ; } } } } if ( total == NUM_ ) { this . methods = Binding . NO METHODS ; return ; } boolean has Restricted Access = has Restricted Access ( ) ; this . methods = new Method Binding [ total ] ; if ( total == initial Total ) { for ( int i = NUM_ ; i < initial Total ; i ++ ) { Method Binding method = create Method ( i Methods [ i ] , source Level , missing Type Names ) ; if ( has Restricted Access ) method . modifiers |= Extra Compiler Modifiers . Acc Restricted Access ; this . methods [ i ] = method ; } } else { for ( int i = NUM_ , index = NUM_ ; i < initial Total ; i ++ ) { if ( i Clinit != i && ( to Skip == null || to Skip [ i ] != - NUM_ ) ) { Method Binding method = create Method ( i Methods [ i ] , source Level , missing Type Names ) ; if ( has Restricted Access ) method . modifiers |= Extra Compiler Modifiers . Acc Restricted Access ; this . methods [ index ++ ] = method ; } } } }
private static Pair < String , String > generate Sign Mask ( final I Translation Environment environment , final long offset , final String value , final Operand Size size , final List < Reil Instruction > instructions ) { final String msb Mask = String . value Of ( Translation Helpers . get Msb Mask ( size ) ) ; final String shift Value = String . value Of ( Translation Helpers . get Shift Msb Lsb Mask ( size ) ) ; final String masked Msb = environment . get Next Variable String ( ) ; final String msb In Lsb = environment . get Next Variable String ( ) ; final String sign Mask = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create And ( offset , size , value , size , msb Mask , size , masked Msb ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset + NUM_ , size , masked Msb , size , shift Value , size , msb In Lsb ) ) ; instructions . add ( Reil Helpers . create Sub ( offset + NUM_ , size , STR_ , size , msb In Lsb , size , sign Mask ) ) ; return new Pair < String , String > ( msb In Lsb , sign Mask ) ; }
public void debug stack ( ) { String Buffer sb = new String Buffer ( STR_ ) ; for ( int i = NUM_ ; i < stack . size ( ) ; i ++ ) { Symbol s = ( Symbol ) stack . element At ( i ) ; sb . append ( STR_ + s . parse state + STR_ + s . sym + STR_ ) ; if ( ( i % NUM_ ) == NUM_ || ( i == ( stack . size ( ) - NUM_ ) ) ) { debug message ( sb . to String ( ) ) ; sb = new String Buffer ( STR_ ) ; } } }
public static void parse Result Set To Model ( Result Set query Result , Object model ) { Class < ? > clazz = model . get Class ( ) ; Field [ ] fields = clazz . get Declared Fields ( ) ; Object field Val = null ; Class < ? > field Type = null ; try { for ( Field field : fields ) { if ( field . is Accessible ( ) == false ) field . set Accessible ( true ) ; Column column = field . get Annotation ( Column . class ) ; if ( column == null ) continue ; String column Name = column . name ( ) ; field Val = query Result . get Value ( column Name ) ; field Type = field . get Type ( ) ; if ( field Val != null ) { if ( field Type . equals ( field Val . get Class ( ) ) ) { field . set ( model , field Val ) ; } else if ( field Type . equals ( short . class ) ) { field . set Short ( model , query Result . get Short Value ( column Name ) ) ; } else if ( field Type . equals ( Short . class ) ) { field . set ( model , ( Short ) query Result . get Short Value ( column Name ) ) ; } else if ( field Type . equals ( int . class ) ) { field . set Int ( model , query Result . get Int Value ( column Name ) ) ; } else if ( field Type . equals ( Integer . class ) ) { field . set ( model , ( Integer ) query Result . get Int Value ( column Name ) ) ; } else if ( field Type . equals ( long . class ) ) { field . set Long ( model , query Result . get Long Value ( column Name ) ) ; } else if ( field Type . equals ( Long . class ) ) { field . set ( model , ( Long ) query Result . get Long Value ( column Name ) ) ; } else if ( field Type . equals ( float . class ) ) { field . set Float ( model , query Result . get Float Value ( column Name ) ) ; } else if ( field Type . equals ( Float . class ) ) { field . set ( model , ( Float ) query Result . get Float Value ( column Name ) ) ; } else if ( field Type . equals ( double . class ) ) { field . set Double ( model , query Result . get Double Value ( column Name ) ) ; } else if ( field Type . equals ( Double . class ) ) { field . set ( model , ( Double ) query Result . get Double Value ( column Name ) ) ; } else if ( field Type . equals ( boolean . class ) ) { field . set Boolean ( model , query Result . get Boolean Value ( column Name ) ) ; } else if ( field Type . equals ( Boolean . class ) ) { field . set ( model , ( Boolean ) query Result . get Boolean Value ( column Name ) ) ; } else if ( field Type . equals ( String . class ) ) { field . set ( model , query Result . get String Value ( column Name ) ) ; } else if ( field Type . equals ( Date . class ) ) { field . set ( model , query Result . get Date Value ( column Name ) ) ; } } } } catch ( Illegal Access Exception e ) { e . print Stack Trace ( ) ; } }
protected static void append Byte Type ( String Builder sb ) { sb . append ( STR_ ) ; }
public void add Control Listener ( Control cl ) { m controls . add ( cl ) ; }
public static Keyword create Keyword ( String text , Keyword Match Type match Type ) { Keyword keyword = new Keyword ( ) ; keyword . set Match Type ( match Type ) ; keyword . set Text ( text ) ; return keyword ; }
private static State next Normal ( final State state , final Byte Array Output Stream line , final int next ) { final State result ; switch ( next ) { case STR_ : result = State . R ; break ; case STR_ : result = State . QUOTED STRING ; break ; default : result = state ; line . write ( next ) ; break ; } return result ; }
private static void warn ( String expected Type , String name , Object actual Value ) { log . warn ( STR_ , actual Value , expected Type , name ) ; }
public static void snap Anchor ( Collection < Constraint Widget > widgets , Constraint Widget widget , Constraint Anchor anchor , Snap Candidate candidate ) { if ( widget . get Parent ( ) != null ) { if ( ! anchor . is Vertical Anchor ( ) ) { check Horizontal Parent Margin Snap ( anchor , Constraint Anchor . Type . RIGHT , - DEFAULT MARGIN , candidate ) ; check Horizontal Parent Margin Snap ( anchor , Constraint Anchor . Type . LEFT , DEFAULT MARGIN , candidate ) ; } else { check Vertical Parent Margin Snap ( anchor , Constraint Anchor . Type . BOTTOM , - DEFAULT MARGIN , candidate ) ; check Vertical Parent Margin Snap ( anchor , Constraint Anchor . Type . TOP , DEFAULT MARGIN , candidate ) ; } } for ( Constraint Widget w : widgets ) { if ( w == widget ) { continue ; } Array List < Constraint Anchor > anchors Target = w . get Anchors ( ) ; for ( Constraint Anchor at : anchors Target ) { snap Check ( anchor , at , candidate , CONNECTION SLOPE ) ; } } }
public static void close All ( ) { Full Text Settings . close All ( ) ; }
private J Component create Menu Title ( String title ) { J Label label = new J Label ( title ) ; label . set Border ( Border Factory . create Empty Border ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; return label ; }
public Builder tag Is ( Class < ? > ... tags ) { verify Not Null ( tags ) ; expressions . add ( new Event Filter Expression . Tag Is ( tags ) ) ; return this ; }
private String create Port Attribute ( final int [ ] ports ) { final String Buffer port Value = new String Buffer ( ) ; for ( int i = NUM_ , len = ports . length ; i < len ; i ++ ) { if ( i > NUM_ ) { port Value . append ( STR_ ) ; } port Value . append ( ports [ i ] ) ; } return port Value . to String ( ) ; }
public Boolean read ( String value ) { return Boolean . value Of ( value ) ; }
public void add Listener ( I Frequency Change Processor processor ) { if ( ! m Processors . contains ( processor ) ) { m Processors . add ( processor ) ; } }
public static void write File ( byte [ ] file Data , File file ) throws Open Stego Exception { Output Stream os = null ; try { if ( file == null ) { os = System . out ; } else { os = new File Output Stream ( file ) ; } os . write ( file Data ) ; os . close ( ) ; } catch ( IO Exception io Ex ) { throw new Open Stego Exception ( io Ex ) ; } }
private List < ? extends Element > sort Elements ( final Round Environment env , final Class < ? extends Annotation > annotation Class ) { final Set < ? extends Element > elements = env . get Elements Annotated With ( annotation Class ) ; final List < ? extends Element > result = new Array List ( elements ) ; Collections . sort ( result , null ) ; return result ; }
public void pin Connection ( String host , Integer port ) { connection Lock . lock ( ) ; try { String host And Port = Connection Manager . generate Connection Cache Key ( host , port ) ; if ( connections . contains Key ( host And Port ) ) { Integer count = pinned Connections . get ( host And Port ) ; if ( count == null ) { count = NUM_ ; } else { count ++ ; } pinned Connections . put ( host And Port , count ) ; } s logger . info ( STR_ , host And Port , pinned Connections . get ( host And Port ) ) ; } finally { connection Lock . unlock ( ) ; } }
private J Panel build Panel For Operation ( final Batch Operation operation , final Array List < Pokemon > pokes ) { final J Panel panel = new J Panel ( ) ; panel . set Layout ( new Box Layout ( panel , Box Layout . X AXIS ) ) ; final J Panel inner Panel = new J Panel ( ) ; inner Panel . set Layout ( new Box Layout ( inner Panel , Box Layout . Y AXIS ) ) ; inner Panel . set Alignment X ( CENTER ALIGNMENT ) ; final J Scroll Pane scroll = new J Scroll Pane ( inner Panel ) ; scroll . set Alignment X ( CENTER ALIGNMENT ) ; final int height = Math . min ( NUM_ , pokes . size ( ) * NUM_ + NUM_ ) ; panel . set Preferred Size ( new Dimension ( NUM_ , height ) ) ; pokes . for Each ( null ) ; panel . add ( scroll ) ; return panel ; }
public boolean is Status Check ( ) { return check Status ; }
public void add User Override ( String user Id , Permission Override override ) { user Overrides . put ( user Id , override ) ; }
protected void close Resources ( Connection connection ) { if ( cache Connection ) return ; if ( connection != null && data Source != null ) { try { connection . close ( ) ; } catch ( SQL Exception e ) { LOG . finest ( STR_ + e . get Message ( ) + STR_ ) ; } } }
public List < Validation Error Message > validate Value ( String value ) { error Message Ids . clear ( ) ; if ( data Restrictions . is Required ( ) && value Null Or Empty ( value ) ) { error Message Ids . add ( new Validation Error Message ( STR_ , id , null ) ) ; } else { if ( ! value Null Or Empty ( value ) ) { for ( Abstract Validation Rule rule : data Restrictions . get Validation Rules ( ) ) { if ( ! rule . validate ( value ) ) { error Message Ids . add ( new Validation Error Message ( rule . get Message Id ( ) , id , rule ) ) ; } } } } return error Message Ids ; }
public void add ( Data Source source ) { sources . add ( source ) ; }
public String index Column Family Name ( Column Definition info ) { return cf Name + Directories . SECONDARY INDEX NAME SEPARATOR + ( info . get Index Name ( ) == null ? Byte Buffer Util . bytes To Hex ( info . name . bytes ) : info . get Index Name ( ) ) ; }
public void select Default Option ( ) { action Type Option Group . select ( Action Type Option . FORCED ) ; }
public static boolean decode To File ( String data To Decode , String filename ) { boolean success = false ; Base 64 . Output Stream bos = null ; try { bos = new Base 64 . Output Stream ( new java . io . File Output Stream ( filename ) , Base 64 . DECODE ) ; bos . write ( data To Decode . get Bytes ( PREFERRED ENCODING ) ) ; success = true ; } catch ( java . io . IO Exception e ) { logger . error ( e , e ) ; success = false ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } return success ; }
public Cache Object load ( Object key , int x , int y , int zoom Level , Projection proj ) { if ( key instanceof String ) { if ( verbose ) { logger . fine ( STR_ + key ) ; } byte [ ] image Bytes = null ; Cache Object local Version = super . load ( key , x , y , zoom Level , proj ) ; if ( local Version != null ) { logger . fine ( STR_ + key ) ; return local Version ; } String image Path = build File Path ( x , y , zoom Level , file Ext ) ; image Bytes = get Image Bytes ( image Path , ( String ) key ) ; if ( image Bytes != null && image Bytes . length > NUM_ ) { Image Icon ii = new Image Icon ( image Bytes ) ; try { Buffered Image raster Image = preprocess Image ( ii . get Image ( ) , ii . get Icon Width ( ) , ii . get Icon Height ( ) ) ; OM Graphic raster = create OM Graphic From Buffered Image ( raster Image , x , y , zoom Level , proj ) ; if ( raster != null ) { return new Cache Object ( key , raster ) ; } } catch ( Interrupted Exception ie ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + image Path ) ; } } } return get Empty Tile ( key , x , y , zoom Level , proj ) ; } return null ; }
private void validate Num Cores Block Sort ( ) { String num Cores Str = carbon Properties . get Property ( Carbon Common Constants . NUM CORES BLOCK SORT , Carbon Common Constants . NUM CORES BLOCK SORT DEFAULT VAL ) ; try { int num Cores = Integer . parse Int ( num Cores Str ) ; if ( num Cores < Carbon Common Constants . NUM CORES BLOCK SORT MIN VAL || num Cores > Carbon Common Constants . NUM CORES BLOCK SORT MAX VAL ) { LOGGER . info ( STR_ + num Cores Str + STR_ + Carbon Common Constants . NUM CORES BLOCK SORT DEFAULT VAL ) ; carbon Properties . set Property ( Carbon Common Constants . NUM CORES BLOCK SORT , Carbon Common Constants . NUM CORES BLOCK SORT DEFAULT VAL ) ; } } catch ( Number Format Exception e ) { LOGGER . info ( STR_ + num Cores Str + STR_ + Carbon Common Constants . NUM CORES BLOCK SORT DEFAULT VAL ) ; carbon Properties . set Property ( Carbon Common Constants . NUM CORES BLOCK SORT , Carbon Common Constants . NUM CORES BLOCK SORT DEFAULT VAL ) ; } }
private void paint Lower Thumb ( Graphics g ) { Rectangle knob Bounds = thumb Rect ; int w = knob Bounds . width ; int h = knob Bounds . height ; Graphics 2 D g 2 d = ( Graphics 2 D ) g . create ( ) ; Shape thumb Shape = create Thumb Shape ( w - NUM_ , h - NUM_ , false ) ; g 2 d . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g 2 d . translate ( knob Bounds . x , knob Bounds . y ) ; g 2 d . set Color ( Color . LIGHT GRAY ) ; g 2 d . fill ( thumb Shape ) ; g 2 d . set Color ( Color . GRAY ) ; g 2 d . draw ( thumb Shape ) ; g 2 d . dispose ( ) ; }
public void make Set ( E element ) { if ( ! element To Set . contains Key ( element ) ) { Set < E > set = new Identity Hash Set < E > ( ) ; set . add ( element ) ; element To Set . put ( element , set ) ; disjoint Sets . add ( set ) ; } }
void schedule T Master Container ( ) throws Container Allocation Exception { LOG . log ( Level . INFO , STR_ , topology Name ) ; launch Container For Executor ( new Heron Worker ( TMASTER CONTAINER ID , NUM_ , TM MEM SIZE MB ) ) ; }
@ Suppress Warnings ( STR_ ) public static Class < ? extends Enum < ? > > find Enum Type ( Enum < ? > en ) { Class < ? > ec = en . get Class ( ) ; if ( ec . get Superclass ( ) != Enum . class ) { ec = ec . get Superclass ( ) ; } return ( Class < ? extends Enum < ? > > ) ec ; }
public Sequential Listener Manager update Executor ( Listener listener , Listener Executor executor ) { if ( ! listener Exists ( listener ) ) throw new Runtime Exception ( STR_ + listener + STR_ ) ; int index = listeners . index Of ( listener ) ; listener Executors . set ( index , executor ) ; return this ; }
public Mini Solr Cloud Cluster ( int num Servers , String host Context , File solr Xml , Sorted Map < Servlet Holder , String > extra Servlets , Sorted Map < Class , String > extra Request Filters ) throws Exception { test Dir = Files . create Temp Dir ( ) ; String zk Dir = test Dir . get Absolute Path ( ) + File . separator + STR_ ; zk Server = new Zk Test Server ( zk Dir ) ; zk Server . run ( ) ; Solr Zk Client zk Client = null ; Input Stream is = null ; try { zk Client = new Solr Zk Client ( zk Server . get Zk Host ( ) , Abstract Zk Test Case . TIMEOUT , NUM_ , null ) ; zk Client . make Path ( STR_ , false , true ) ; is = new File Input Stream ( solr Xml ) ; zk Client . create ( STR_ , IO Utils . to Byte Array ( is ) , Zoo Defs . Ids . OPEN ACL UNSAFE , Create Mode . PERSISTENT , true ) ; } finally { IO Utils . close Quietly ( is ) ; if ( zk Client != null ) zk Client . close ( ) ; } System . set Property ( STR_ , STR_ ) ; System . set Property ( STR_ , zk Server . get Zk Address ( ) ) ; jettys = new Linked List < Jetty Solr Runner > ( ) ; for ( int i = NUM_ ; i < num Servers ; ++ i ) { start Jetty Solr Runner ( host Context , extra Servlets , extra Request Filters ) ; } }
public static void perform And Wait For Window Change ( SWT Bot bot , Runnable runnable ) { SWT Bot Shell shell = bot . active Shell ( ) ; runnable . run ( ) ; wait Until Shell Is Not Active ( bot , shell ) ; }
protected void build Profiles ( ) { m Current Profile View . set Visibility ( View . INVISIBLE ) ; m Account Header Text Section . set Visibility ( View . INVISIBLE ) ; m Account Switcher Arrow . set Visibility ( View . INVISIBLE ) ; m Profile First View . set Visibility ( View . GONE ) ; m Profile First View . set On Click Listener ( null ) ; m Profile Second View . set Visibility ( View . GONE ) ; m Profile Second View . set On Click Listener ( null ) ; m Profile Third View . set Visibility ( View . GONE ) ; m Profile Third View . set On Click Listener ( null ) ; m Current Profile Name . set Text ( STR_ ) ; m Current Profile Email . set Text ( STR_ ) ; handle Selection View ( m Current Profile , true ) ; if ( m Current Profile != null ) { if ( ( m Profile Images Visible || m Only Main Profile Image Visible ) && ! m Only Small Profile Images Visible ) { set Image Or Placeholder ( m Current Profile View , m Current Profile . get Icon ( ) ) ; if ( m Profile Images Clickable ) { m Current Profile View . set On Click Listener ( on Current Profile Click Listener ) ; m Current Profile View . set On Long Click Listener ( on Current Profile Long Click Listener ) ; m Current Profile View . disable Touch Feedback ( false ) ; } else { m Current Profile View . disable Touch Feedback ( true ) ; } m Current Profile View . set Visibility ( View . VISIBLE ) ; m Current Profile View . invalidate ( ) ; } else if ( m Compact Style ) { m Current Profile View . set Visibility ( View . GONE ) ; } m Account Header Text Section . set Visibility ( View . VISIBLE ) ; handle Selection View ( m Current Profile , true ) ; m Account Switcher Arrow . set Visibility ( View . VISIBLE ) ; m Current Profile View . set Tag ( R . id . material drawer profile header , m Current Profile ) ; String Holder . apply To ( m Current Profile . get Name ( ) , m Current Profile Name ) ; String Holder . apply To ( m Current Profile . get Email ( ) , m Current Profile Email ) ; if ( m Profile First != null && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile First View , m Profile First . get Icon ( ) ) ; m Profile First View . set Tag ( R . id . material drawer profile header , m Profile First ) ; if ( m Profile Images Clickable ) { m Profile First View . set On Click Listener ( on Profile Click Listener ) ; m Profile First View . set On Long Click Listener ( on Profile Long Click Listener ) ; m Profile First View . disable Touch Feedback ( false ) ; } else { m Profile First View . disable Touch Feedback ( true ) ; } m Profile First View . set Visibility ( View . VISIBLE ) ; m Profile First View . invalidate ( ) ; } if ( m Profile Second != null && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile Second View , m Profile Second . get Icon ( ) ) ; m Profile Second View . set Tag ( R . id . material drawer profile header , m Profile Second ) ; if ( m Profile Images Clickable ) { m Profile Second View . set On Click Listener ( on Profile Click Listener ) ; m Profile Second View . set On Long Click Listener ( on Profile Long Click Listener ) ; m Profile Second View . disable Touch Feedback ( false ) ; } else { m Profile Second View . disable Touch Feedback ( true ) ; } m Profile Second View . set Visibility ( View . VISIBLE ) ; m Profile Second View . invalidate ( ) ; } if ( m Profile Third != null && m Three Small Profile Images && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile Third View , m Profile Third . get Icon ( ) ) ; m Profile Third View . set Tag ( R . id . material drawer profile header , m Profile Third ) ; if ( m Profile Images Clickable ) { m Profile Third View . set On Click Listener ( on Profile Click Listener ) ; m Profile Third View . set On Long Click Listener ( on Profile Long Click Listener ) ; m Profile Third View . disable Touch Feedback ( false ) ; } else { m Profile Third View . disable Touch Feedback ( true ) ; } m Profile Third View . set Visibility ( View . VISIBLE ) ; m Profile Third View . invalidate ( ) ; } } else if ( m Profiles != null && m Profiles . size ( ) > NUM_ ) { I Profile profile = m Profiles . get ( NUM_ ) ; m Account Header Text Section . set Tag ( R . id . material drawer profile header , profile ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; handle Selection View ( m Current Profile , true ) ; m Account Switcher Arrow . set Visibility ( View . VISIBLE ) ; if ( m Current Profile != null ) { String Holder . apply To ( m Current Profile . get Name ( ) , m Current Profile Name ) ; String Holder . apply To ( m Current Profile . get Email ( ) , m Current Profile Email ) ; } } if ( ! m Selection First Line Shown ) { m Current Profile Name . set Visibility ( View . GONE ) ; } if ( ! Text Utils . is Empty ( m Selection First Line ) ) { m Current Profile Name . set Text ( m Selection First Line ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; } if ( ! m Selection Second Line Shown ) { m Current Profile Email . set Visibility ( View . GONE ) ; } if ( ! Text Utils . is Empty ( m Selection Second Line ) ) { m Current Profile Email . set Text ( m Selection Second Line ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; } if ( ! m Selection List Enabled ) { m Account Switcher Arrow . set Visibility ( View . INVISIBLE ) ; handle Selection View ( null , false ) ; } if ( ! m Selection List Enabled For Single Profile && m Profile First == null && ( m Profiles == null || m Profiles . size ( ) == NUM_ ) ) { m Account Switcher Arrow . set Visibility ( View . INVISIBLE ) ; handle Selection View ( null , false ) ; } if ( m On Account Header Selection View Click Listener != null ) { handle Selection View ( m Current Profile , true ) ; } }
private void on Password Focus Changed ( boolean has Focus ) { if ( has Focus ) { show View Password Button ( ) ; } else { hide Password ( ) ; hide Password Button ( ) ; } }
< T > T on Find Last ( Class < T > model Class , boolean is Eager ) { List < T > data List = query ( model Class , null , null , null , null , null , STR_ , STR_ , get Foreign Key Associations ( model Class . get Name ( ) , is Eager ) ) ; if ( data List . size ( ) > NUM_ ) { return data List . get ( NUM_ ) ; } return null ; }
public static Workflow . Method unlink Block Snapshot Session Target Method ( URI system URI , URI snap Session URI , URI snapshot URI , Boolean delete Target ) { return new Workflow . Method ( UNLINK SNAPSHOT SESSION TARGET METHOD , system URI , snap Session URI , snapshot URI , delete Target ) ; }
private static float [ ] derive Text Bounds Anchor Offsets ( Graphics 2 D g 2 , String text , Text Anchor anchor ) { float [ ] result = new float [ NUM_ ] ; Font Render Context frc = g 2 . get Font Render Context ( ) ; Font f = g 2 . get Font ( ) ; Font Metrics fm = g 2 . get Font Metrics ( f ) ; Rectangle 2 D bounds = get Text Bounds ( text , fm ) ; Line Metrics metrics = f . get Line Metrics ( text , frc ) ; float ascent = metrics . get Ascent ( ) ; float half Ascent = ascent / NUM_ ; float descent = metrics . get Descent ( ) ; float leading = metrics . get Leading ( ) ; float x Adj = NUM_ ; float y Adj = NUM_ ; if ( anchor . is Horizontal Center ( ) ) { x Adj = ( float ) - bounds . get Width ( ) / NUM_ ; } else if ( anchor . is Right ( ) ) { x Adj = ( float ) - bounds . get Width ( ) ; } if ( anchor . is Top ( ) ) { y Adj = - descent - leading + ( float ) bounds . get Height ( ) ; } else if ( anchor . is Half Ascent ( ) ) { y Adj = half Ascent ; } else if ( anchor . is Vertical Center ( ) ) { y Adj = - descent - leading + ( float ) ( bounds . get Height ( ) / NUM_ ) ; } else if ( anchor . is Baseline ( ) ) { y Adj = NUM_ ; } else if ( anchor . is Bottom ( ) ) { y Adj = - metrics . get Descent ( ) - metrics . get Leading ( ) ; } result [ NUM_ ] = x Adj ; result [ NUM_ ] = y Adj ; return result ; }
private String pop And Encode As Js ( ) { synchronized ( this ) { int length = queue . size ( ) ; if ( length == NUM_ ) { return null ; } int total Payload Len = NUM_ ; int num Messages To Send = NUM_ ; for ( Js Message message : queue ) { int message Size = message . calculate Encoded Length ( ) + NUM_ ; if ( num Messages To Send > NUM_ && total Payload Len + message Size > MAX PAYLOAD SIZE && MAX PAYLOAD SIZE > NUM_ ) { break ; } total Payload Len += message Size ; num Messages To Send += NUM_ ; } boolean will Send All Messages = num Messages To Send == queue . size ( ) ; String Builder sb = new String Builder ( total Payload Len + ( will Send All Messages ? NUM_ : NUM_ ) ) ; for ( int i = NUM_ ; i < num Messages To Send ; ++ i ) { Js Message message = queue . remove First ( ) ; if ( will Send All Messages && ( i + NUM_ == num Messages To Send ) ) { message . encode As Js Message ( sb ) ; } else { sb . append ( STR_ ) ; message . encode As Js Message ( sb ) ; sb . append ( STR_ ) ; } } if ( ! will Send All Messages ) { sb . append ( STR_ ) ; } for ( int i = will Send All Messages ? NUM_ : NUM_ ; i < num Messages To Send ; ++ i ) { sb . append ( STR_ ) ; } String ret = sb . to String ( ) ; return ret ; } }
public static String array To Hex String ( byte [ ] array , int offset , int limit ) { String ret Val ; if ( array != null ) { String Buffer hex String = new String Buffer ( array . length ) ; int hex Val ; char hex Char ; int length = Math . min ( limit , array . length ) ; for ( int i = offset ; i < length ; i ++ ) { hex Val = ( array [ i ] & NUM_ ) > > NUM_ ; hex Char = ( char ) ( ( hex Val > NUM_ ) ? ( STR_ + ( hex Val - NUM_ ) ) : ( STR_ + hex Val ) ) ; hex String . append ( hex Char ) ; hex Val = array [ i ] & NUM_ ; hex Char = ( char ) ( ( hex Val > NUM_ ) ? ( STR_ + ( hex Val - NUM_ ) ) : ( STR_ + hex Val ) ) ; hex String . append ( hex Char ) ; } ret Val = hex String . to String ( ) ; } else { ret Val = STR_ ; } return ret Val ; }
public void calc Welzl ( Float Buffer points ) { if ( center == null ) { center = new Vector 3 f ( ) ; } Float Buffer buf = Buffer Utils . create Float Buffer ( points . limit ( ) ) ; points . rewind ( ) ; buf . put ( points ) ; buf . flip ( ) ; recurse Mini ( buf , buf . limit ( ) / NUM_ , NUM_ , NUM_ ) ; }
@ Override public boolean input ( Instance instance ) throws Exception { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = false ; } if ( is First Batch Done ( ) ) { Array List < Instance > fv = new Array List < Instance > ( ) ; int first Copy = convert Instancewo Doc Norm ( instance , fv ) ; Instance inst = fv . get ( NUM_ ) ; if ( m filter Type != FILTER NONE ) { normalize Instance ( inst , first Copy ) ; } push ( inst ) ; return true ; } else { buffer Input ( instance ) ; return false ; } }
public static List < URI > ensure One Snapshot Per Replication Group ( List < URI > snapshot UR Is , Db Client db Client ) { List < URI > filtered Snapshot UR Is = new Array List < > ( ) ; Set < String > replication Groups = new Hash Set < > ( ) ; Iterator < Block Snapshot > snapshot Iter = db Client . query Iterative Objects ( Block Snapshot . class , snapshot UR Is ) ; while ( snapshot Iter . has Next ( ) ) { Block Snapshot snapshot = snapshot Iter . next ( ) ; String rep Grp Instance = snapshot . get Replication Group Instance ( ) ; if ( replication Groups . contains ( rep Grp Instance ) ) { continue ; } replication Groups . add ( rep Grp Instance ) ; filtered Snapshot UR Is . add ( snapshot . get Id ( ) ) ; } return filtered Snapshot UR Is ; }
private boolean add Path ( List < O Path > list , O Path path ) { if ( list . contains ( path ) ) { return true ; } String p Name = path . get Name ( ) ; for ( int i = NUM_ ; i < list . size ( ) ; i ++ ) { O Path p = list . get ( i ) ; if ( p Name . equals ( p . get Name ( ) ) ) { log . error ( STR_ + path . get Name ( ) + STR_ + get User Name ( ) + STR_ ) ; return false ; } if ( p . equals ( path ) ) { log . warn ( STR_ + path . get Name ( ) + STR_ + p . get Name ( ) + STR_ + get User Name ( ) + STR_ ) ; return false ; } } list . add ( path ) ; return true ; }
private float [ ] [ ] do Polar Fill Correction ( float [ ] xpoints , float [ ] ypoints , int y 1 ) { float [ ] [ ] ret = new float [ NUM_ ] [ ] ; int len = xpoints . length ; float [ ] alt xpts = new float [ len + NUM_ ] ; float [ ] alt ypts = new float [ len + NUM_ ] ; System . arraycopy ( xpoints , NUM_ , alt xpts , NUM_ , len ) ; System . arraycopy ( ypoints , NUM_ , alt ypts , NUM_ , len ) ; alt xpts [ len ] = alt xpts [ len - NUM_ ] ; alt xpts [ len + NUM_ ] = alt xpts [ NUM_ ] ; alt ypts [ len ] = y 1 ; alt ypts [ len + NUM_ ] = alt ypts [ len ] ; ret [ NUM_ ] = alt xpts ; ret [ NUM_ ] = alt ypts ; return ret ; }
protected String create Request URL ( ) { if ( ! post && request Arguments != null ) { String Builder b = new String Builder ( url ) ; Enumeration e = request Arguments . keys ( ) ; if ( e . has More Elements ( ) ) { b . append ( STR_ ) ; } while ( e . has More Elements ( ) ) { String key = ( String ) e . next Element ( ) ; Object request Val = request Arguments . get ( key ) ; if ( request Val instanceof String ) { String value = ( String ) request Val ; b . append ( key ) ; b . append ( STR_ ) ; b . append ( value ) ; if ( e . has More Elements ( ) ) { b . append ( STR_ ) ; } continue ; } String [ ] val = ( String [ ] ) request Val ; int vlen = val . length ; for ( int iter = NUM_ ; iter < vlen - NUM_ ; iter ++ ) { b . append ( key ) ; b . append ( STR_ ) ; b . append ( val [ iter ] ) ; b . append ( STR_ ) ; } b . append ( key ) ; b . append ( STR_ ) ; b . append ( val [ vlen - NUM_ ] ) ; if ( e . has More Elements ( ) ) { b . append ( STR_ ) ; } } return b . to String ( ) ; } return url ; }
public static boolean above Than ( int a , int b ) { return Integer . compare Unsigned ( a , b ) > NUM_ ; }
public static Http Response execute Delete Request ( String service End Point , boolean secure ) throws IO Exception { URL url = ( secure ) ? new URL ( SERVICE ROOT URI + STR_ + service End Point ) : new URL ( SERVICE ROOT URI + service End Point ) ; Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; try { connection . set Do Input ( true ) ; connection . set Do Output ( true ) ; connection . set Request Property ( STR_ , STR_ ) ; connection . set Request Property ( STR_ , STR_ ) ; connection . set Request Method ( STR_ ) ; if ( secure ) { connection . set Request Property ( STR_ , AUTHORIZATION ) ; } connection . connect ( ) ; return new Http Response ( connection ) ; } finally { connection . disconnect ( ) ; } }
private List < Key Value > filter ( Filter filter , List < Key Value > kvs ) throws IO Exception { filter . reset ( ) ; List < Key Value > tmp = new Array List < Key Value > ( kvs . size ( ) ) ; tmp . add All ( kvs ) ; boolean filtered On Row Key = false ; List < Key Value > nkvs = new Array List < Key Value > ( tmp . size ( ) ) ; for ( Key Value kv : tmp ) { if ( filter . filter Row Key ( kv . get Buffer ( ) , kv . get Row Offset ( ) , kv . get Row Length ( ) ) ) { filtered On Row Key = true ; break ; } Filter . Return Code filter Result = filter . filter Key Value ( kv ) ; if ( filter Result == Filter . Return Code . INCLUDE ) { nkvs . add ( kv ) ; } else if ( filter Result == Filter . Return Code . NEXT ROW ) { break ; } else if ( filter Result == Filter . Return Code . NEXT COL || filter Result == Filter . Return Code . SKIP ) { continue ; } } if ( filter . has Filter Row ( ) && ! filtered On Row Key ) { filter . filter Row ( nkvs ) ; } if ( filter . filter Row ( ) || filtered On Row Key ) { nkvs . clear ( ) ; } tmp = nkvs ; return tmp ; }
@ Override public Token generate Personal Access Token ( final URI target Uri , final Token access Token , final Vso Token Scope token Scope , final boolean require Compact Token ) { Debug . Assert ( target Uri != null , STR_ ) ; Debug . Assert ( access Token != null && ! String Helper . is Null Or White Space ( access Token . Value ) && ( access Token . Type == Token Type . Access || access Token . Type == Token Type . Federated ) , STR_ ) ; Debug . Assert ( token Scope != null , STR_ ) ; Trace . write Line ( STR_ ) ; try { final Http Client client = new Http Client ( Global . get User Agent ( ) ) ; Trace . write Line ( STR_ ) ; access Token . contribute Header ( client . Headers ) ; if ( populate Token Target Id ( target Uri , access Token ) ) { final URI request Url = create Personal Access Token Request Uri ( client , target Uri , require Compact Token ) ; final String Content content = get Access Token Request Body ( target Uri , access Token , token Scope ) ; final Http URL Connection response = client . post ( request Url , content ) ; if ( response . get Response Code ( ) == Http URL Connection . HTTP OK ) { final String response Text = Http Client . read To String ( response ) ; final Token token = parse Personal Access Token From Json ( response Text ) ; if ( token != null ) { Trace . write Line ( STR_ ) ; } return token ; } } } catch ( final IO Exception e ) { throw new Error ( e ) ; } return null ; }
public static Pair < Integer , Integer > stream Read Bytes ( Active MQ Buffer buff , int remaining Bytes , byte [ ] value ) { if ( remaining Bytes == - NUM_ ) { return new Pair < > ( NUM_ , - NUM_ ) ; } else if ( remaining Bytes == NUM_ ) { byte type = buff . read Byte ( ) ; if ( type != Data Constants . BYTES ) { throw new Illegal State Exception ( STR_ ) ; } remaining Bytes = buff . read Int ( ) ; } int read = Math . min ( value . length , remaining Bytes ) ; buff . read Bytes ( value , NUM_ , read ) ; remaining Bytes -= read ; if ( remaining Bytes == NUM_ ) { remaining Bytes = - NUM_ ; } return new Pair < > ( remaining Bytes , read ) ; }
public void add Tab ( Bottom Navigation Item item ) { bottom Navigation Items . add ( item ) ; }
public Channel Change Listener ( String group Name , Sound Group group ) { this . group = group ; this . group Name = group Name ; }
public void add View Pop Up Menu ( J Menu Item menu ) { if ( ! view Additional Menu . contains ( menu ) ) { view Additional Menu . add ( menu ) ; } }
private void configure Auth ( Client Builder client Builder ) { if ( conf . client . auth Type == Authentication Type . OAUTH ) { auth Token = Jersey Client Util . configure O Auth 1 ( conf . client . oauth , client Builder ) ; } else if ( conf . client . auth Type != Authentication Type . NONE ) { Jersey Client Util . configure Password Auth ( conf . client . auth Type , conf . client . basic Auth , client Builder ) ; } }
private void append Phonetic Name Fields ( final Content Values content Values ) { final String phonetic Family Name ; final String phonetic Middle Name ; final String phonetic Given Name ; { final String tmp Phonetic Family Name = content Values . get As String ( Structured Name . PHONETIC FAMILY NAME ) ; final String tmp Phonetic Middle Name = content Values . get As String ( Structured Name . PHONETIC MIDDLE NAME ) ; final String tmp Phonetic Given Name = content Values . get As String ( Structured Name . PHONETIC GIVEN NAME ) ; if ( m Needs To Convert Phonetic String ) { phonetic Family Name = V Card Utils . to Half Width String ( tmp Phonetic Family Name ) ; phonetic Middle Name = V Card Utils . to Half Width String ( tmp Phonetic Middle Name ) ; phonetic Given Name = V Card Utils . to Half Width String ( tmp Phonetic Given Name ) ; } else { phonetic Family Name = tmp Phonetic Family Name ; phonetic Middle Name = tmp Phonetic Middle Name ; phonetic Given Name = tmp Phonetic Given Name ; } } if ( Text Utils . is Empty ( phonetic Family Name ) && Text Utils . is Empty ( phonetic Middle Name ) && Text Utils . is Empty ( phonetic Given Name ) ) { if ( m Is Do Co Mo ) { m Builder . append ( V Card Constants . PROPERTY SOUND ) ; m Builder . append ( VCARD PARAM SEPARATOR ) ; m Builder . append ( V Card Constants . PARAM TYPE X IRMC N ) ; m Builder . append ( VCARD DATA SEPARATOR ) ; m Builder . append ( VCARD ITEM SEPARATOR ) ; m Builder . append ( VCARD ITEM SEPARATOR ) ; m Builder . append ( VCARD ITEM SEPARATOR ) ; m Builder . append ( VCARD ITEM SEPARATOR ) ; m Builder . append ( VCARD END OF LINE ) ; } return ; } if ( V Card Config . is Version 40 ( m V Card Type ) ) { } else if ( V Card Config . is Version 30 ( m V Card Type ) ) { final String sort String = V Card Utils . construct Name From Elements ( m V Card Type , phonetic Family Name , phonetic Middle Name , phonetic Given Name ) ; m Builder . append ( V Card Constants . PROPERTY SORT STRING ) ; if ( V Card Config . is Version 30 ( m V Card Type ) && should Append Charset Param ( sort String ) ) { m Builder . append ( VCARD PARAM SEPARATOR ) ; m Builder . append ( m V Card Charset Parameter ) ; } m Builder . append ( VCARD DATA SEPARATOR ) ; m Builder . append ( escape Characters ( sort String ) ) ; m Builder . append ( VCARD END OF LINE ) ; } else if ( m Is Japanese Mobile Phone ) { m Builder . append ( V Card Constants . PROPERTY SOUND ) ; m Builder . append ( VCARD PARAM SEPARATOR ) ; m Builder . append ( V Card Constants . PARAM TYPE X IRMC N ) ; boolean really Use Quoted Printable = ( ! m Refrains QP To Name Properties && ! ( V Card Utils . contains Only Non Cr Lf Printable Ascii ( phonetic Family Name ) && V Card Utils . contains Only Non Cr Lf Printable Ascii ( phonetic Middle Name ) && V Card Utils . contains Only Non Cr Lf Printable Ascii ( phonetic Given Name ) ) ) ; final String encoded Phonetic Family Name ; final String encoded Phonetic Middle Name ; final String encoded Phonetic Given Name ; if ( really Use Quoted Printable ) { encoded Phonetic Family Name = encode Quoted Printable ( phonetic Family Name ) ; encoded Phonetic Middle Name = encode Quoted Printable ( phonetic Middle Name ) ; encoded Phonetic Given Name = encode Quoted Printable ( phonetic Given Name ) ; } else { encoded Phonetic Family Name = escape Characters ( phonetic Family Name ) ; encoded Phonetic Middle Name = escape Characters ( phonetic Middle Name ) ; encoded Phonetic Given Name = escape Characters ( phonetic Given Name ) ; } if ( should Append Charset Param ( encoded Phonetic Family Name , encoded Phonetic Middle Name , encoded Phonetic Given Name ) ) { m Builder . append ( VCARD PARAM SEPARATOR ) ; m Builder . append ( m V Card Charset Parameter ) ; } m Builder . append ( VCARD DATA SEPARATOR ) ; { boolean first = true ; if ( ! Text Utils . is Empty ( encoded Phonetic Family Name ) ) { m Builder . append ( encoded Phonetic Family Name ) ; first = false ; } if ( ! Text Utils . is Empty ( encoded Phonetic Middle Name ) ) { if ( first ) { first = false ; } else { m Builder . append ( STR_ ) ; } m Builder . append ( encoded Phonetic Middle Name ) ; } if ( ! Text Utils . is Empty ( encoded Phonetic Given Name ) ) { if ( ! first ) { m Builder . append ( STR_ ) ; } m Builder . append ( encoded Phonetic Given Name ) ; } } m Builder . append ( VCARD ITEM SEPARATOR ) ; m Builder . append ( VCARD ITEM SEPARATOR ) ; m Builder . append ( VCARD ITEM SEPARATOR ) ; m Builder . append ( VCARD ITEM SEPARATOR ) ; m Builder . append ( VCARD END OF LINE ) ; } if ( m Uses Defact Property ) { if ( ! Text Utils . is Empty ( phonetic Given Name ) ) { final boolean really Use Quoted Printable = ( m Should Use Quoted Printable && ! V Card Utils . contains Only Non Cr Lf Printable Ascii ( phonetic Given Name ) ) ; final String encoded Phonetic Given Name ; if ( really Use Quoted Printable ) { encoded Phonetic Given Name = encode Quoted Printable ( phonetic Given Name ) ; } else { encoded Phonetic Given Name = escape Characters ( phonetic Given Name ) ; } m Builder . append ( V Card Constants . PROPERTY X PHONETIC FIRST NAME ) ; if ( should Append Charset Param ( phonetic Given Name ) ) { m Builder . append ( VCARD PARAM SEPARATOR ) ; m Builder . append ( m V Card Charset Parameter ) ; } if ( really Use Quoted Printable ) { m Builder . append ( VCARD PARAM SEPARATOR ) ; m Builder . append ( VCARD PARAM ENCODING QP ) ; } m Builder . append ( VCARD DATA SEPARATOR ) ; m Builder . append ( encoded Phonetic Given Name ) ; m Builder . append ( VCARD END OF LINE ) ; } if ( ! Text Utils . is Empty ( phonetic Middle Name ) ) { final boolean really Use Quoted Printable = ( m Should Use Quoted Printable && ! V Card Utils . contains Only Non Cr Lf Printable Ascii ( phonetic Middle Name ) ) ; final String encoded Phonetic Middle Name ; if ( really Use Quoted Printable ) { encoded Phonetic Middle Name = encode Quoted Printable ( phonetic Middle Name ) ; } else { encoded Phonetic Middle Name = escape Characters ( phonetic Middle Name ) ; } m Builder . append ( V Card Constants . PROPERTY X PHONETIC MIDDLE NAME ) ; if ( should Append Charset Param ( phonetic Middle Name ) ) { m Builder . append ( VCARD PARAM SEPARATOR ) ; m Builder . append ( m V Card Charset Parameter ) ; } if ( really Use Quoted Printable ) { m Builder . append ( VCARD PARAM SEPARATOR ) ; m Builder . append ( VCARD PARAM ENCODING QP ) ; } m Builder . append ( VCARD DATA SEPARATOR ) ; m Builder . append ( encoded Phonetic Middle Name ) ; m Builder . append ( VCARD END OF LINE ) ; } if ( ! Text Utils . is Empty ( phonetic Family Name ) ) { final boolean really Use Quoted Printable = ( m Should Use Quoted Printable && ! V Card Utils . contains Only Non Cr Lf Printable Ascii ( phonetic Family Name ) ) ; final String encoded Phonetic Family Name ; if ( really Use Quoted Printable ) { encoded Phonetic Family Name = encode Quoted Printable ( phonetic Family Name ) ; } else { encoded Phonetic Family Name = escape Characters ( phonetic Family Name ) ; } m Builder . append ( V Card Constants . PROPERTY X PHONETIC LAST NAME ) ; if ( should Append Charset Param ( phonetic Family Name ) ) { m Builder . append ( VCARD PARAM SEPARATOR ) ; m Builder . append ( m V Card Charset Parameter ) ; } if ( really Use Quoted Printable ) { m Builder . append ( VCARD PARAM SEPARATOR ) ; m Builder . append ( VCARD PARAM ENCODING QP ) ; } m Builder . append ( VCARD DATA SEPARATOR ) ; m Builder . append ( encoded Phonetic Family Name ) ; m Builder . append ( VCARD END OF LINE ) ; } } }
public Solr Cluster Options ( String cluster Name , Integer cluster Size ) { this . cluster Name = cluster Name ; if ( cluster Size == null ) { this . cluster Size = FREE CLUSTER SIZE ; } else { Validator . is True ( ( cluster Size > NUM_ ) , STR_ ) ; this . cluster Size = cluster Size . to String ( ) ; } }
void open ( ) { if ( ! main Frame . can Navigate Away ( ) ) { return ; } if ( ask To Save ( ) ) { return ; } boolean loading = true ; Save Type file Type ; try Again : while ( loading ) { int value = save Open File Chooser . show Open Dialog ( main Frame ) ; if ( value != J File Chooser . APPROVE OPTION ) { return ; } loading = false ; file Type = convert Filter To Type ( save Open File Chooser . get File Filter ( ) ) ; final File f = save Open File Chooser . get Selected File ( ) ; if ( ! file Type . is Valid ( f ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STR_ , STR_ , J Option Pane . WARNING MESSAGE ) ; loading = true ; continue ; } switch ( file Type ) { case XML ANALYSIS : if ( ! f . get Name ( ) . ends With ( STR_ ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , L 10 N . get Local String ( STR_ , STR_ ) ) ; loading = true ; continue try Again ; } if ( ! main Frame . open Analysis ( f , file Type ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STR_ ) ; loading = true ; continue try Again ; } break ; case FBP FILE : if ( ! open FBP File ( f ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STR_ ) ; loading = true ; continue try Again ; } break ; case FBA FILE : if ( ! open FBA File ( f ) ) { J Option Pane . show Message Dialog ( save Open File Chooser , STR_ ) ; loading = true ; continue try Again ; } break ; default : assert false ; } } }
public void redeploy ( List < Deployable > deployables ) { for ( Deployable deployable : deployables ) { redeploy ( deployable ) ; } }
public boolean has Persistent Lock ( String svc Id , String lock Id ) throws Exception { try { Distributed Persistent Lock lock = coordinator . get Site Local Persistent Lock ( lock Id ) ; if ( lock != null ) { String lock Owner = lock . get Lock Owner ( ) ; if ( lock Owner != null && lock Owner . equals ( svc Id ) ) { log . info ( STR_ , lock Id , lock Owner ) ; return true ; } } } catch ( Exception e ) { log . error ( STR_ , lock Id ) ; } return false ; }
private void on Search Panel First View ( ) { if ( m Is Search Panel Fully Preloaded ) { log Search Panel Load Duration ( true , NUM_ ) ; } else { m Search View Start Time Ns = System . nano Time ( ) ; } }
private Tree Element find Depth First ( Tree Element parent , String name ) { int len = parent . get Num Children ( ) ; for ( int i = NUM_ ; i < len ; ++ i ) { Tree Element e = parent . get Child At ( i ) ; if ( name . equals ( e . get Name ( ) ) ) { return e ; } else if ( e . get Num Children ( ) != NUM_ ) { Tree Element v = find Depth First ( e , name ) ; if ( v != null ) return v ; } } return null ; }
public void start Camel ( ) throws Exception { camel Context . start ( ) ; }
public void remove All Update Listeners ( ) { if ( update Listeners == null ) { return ; } update Listeners . clear ( ) ; update Listeners = null ; }
public void remove Contributor ( Choose By Name Contributor contributor ) { my Goto Class Contributors . remove ( contributor ) ; my Goto Symbol Contributors . remove ( contributor ) ; }
void validate Number ( int i , int ofs , String name , int min , int max ) throws Parse Exception { if ( i < min || i > max ) { throw Invalid ( name , ofs ) ; } }
public static File index File Name ( File data ) { return new File ( data . get Parent File ( ) , data . get Name ( ) + BAM INDEX EXTENSION ) ; }
public double [ ] distribution For Instance ( Instance instance ) throws Exception { if ( m Zero R != null ) { return m Zero R . distribution For Instance ( instance ) ; } return m Distribution [ which Subset ( instance ) ] ; }
@ Override public Table View format Table ( Logical Table logical Table , Uri Info uri Info ) { Table View result Row = new Table View ( ) ; result Row . put ( STR_ , logical Table . get Name ( ) ) ; result Row . put ( STR_ , logical Table . get Long Name ( ) ) ; result Row . put ( STR_ , logical Table . get Description ( ) ) ; result Row . put ( STR_ , logical Table . get Category ( ) ) ; return result Row ; }
private void remove Observed File ( OC File file , Account account ) { Log OC . v ( TAG , STR_ ) ; if ( file == null ) { Log OC . e ( TAG , STR_ ) ; return ; } if ( account == null ) { Log OC . e ( TAG , STR_ ) ; return ; } String local Path = file . get Storage Path ( ) ; if ( local Path == null || local Path . length ( ) <= NUM_ ) { local Path = File Storage Utils . get Default Save Path For ( account . name , file ) ; } remove Observed File ( local Path ) ; }
public Verified Download ( Logger log , Artifact Context context , File Content Store file Content Store , Node node ) { this . log = log ; this . context = context ; parent = Node Utils . first Parent ( node ) ; if ( parent == null ) { throw new Illegal Argument Exception ( STR_ + node ) ; } this . node = node ; this . file Content Store = file Content Store ; File f ; File parent Dir = file Content Store . get File ( parent ) ; parent Dir . mkdirs ( ) ; try { f = File . create Temp File ( node . get Label ( ) + STR_ , STR_ , parent Dir ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; log . debug ( STR_ + e ) ; f = new File ( parent Dir , node . get Label ( ) + Abstract Node Repository Manager . VALIDATING ) ; File Util . delete ( f ) ; } f . delete On Exit ( ) ; temp Node = parent . get Child ( f . get Name ( ) ) ; temp File = file Content Store . get File ( temp Node ) ; }
public byte [ ] encrypt Data With Private Key ( byte [ ] buffer , int length ) { try { Cipher cipher = Cipher . get Instance ( TTT ENCRYPTION ALGORITHM ) ; cipher . init ( Cipher . ENCRYPT MODE , private Key ) ; byte [ ] cipher Data = cipher . do Final ( buffer , NUM_ , length ) ; return cipher Data ; } catch ( General Security Exception e ) { throw new Illegal State Exception ( e ) ; } }
void remove EQ ( Object o ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { for ( Iterator < E > it = q . iterator ( ) ; it . has Next ( ) ; ) { if ( o == it . next ( ) ) { it . remove ( ) ; break ; } } } finally { lock . unlock ( ) ; } }
public boolean remove Telegram Writer ( Telegram Writer rem Writer ) { return ( telegram Writers . remove ( rem Writer ) ) ; }
public static void dispose ( ) { context . remove ( ) ; }
public static int cardinality ( long [ ] v ) { int sum = NUM_ ; for ( int i = NUM_ ; i < v . length ; i ++ ) { sum += Long . bit Count ( v [ i ] ) ; } return sum ; }
public void select Track ( int index ) { selected Track Index = index ; Exposed Track selected Track = tracks . get ( selected Track Index ) ; selected Variant Index = selected Track . default Variant Index ; variants = selected Track . variants ; variant Playlists = new Hls Media Playlist [ variants . length ] ; variant Last Playlist Load Times Ms = new long [ variants . length ] ; variant Blacklist Times = new long [ variants . length ] ; }
public Input Stream response Input Stream ( Http Response response ) throws IO Exception { return response Input Stream ( response , false ) ; }
private void sched ( Timer Task task , long time , long period ) { if ( time < NUM_ ) throw new Illegal Argument Exception ( STR_ ) ; if ( Math . abs ( period ) > ( Long . MAX VALUE > > NUM_ ) ) period >>= NUM_ ; synchronized ( queue ) { if ( ! thread . new Tasks May Be Scheduled ) throw new Illegal State Exception ( STR_ ) ; synchronized ( task . lock ) { if ( task . state != Timer Task . VIRGIN ) throw new Illegal State Exception ( STR_ ) ; task . next Execution Time = time ; task . period = period ; task . state = Timer Task . SCHEDULED ; } queue . add ( task ) ; if ( queue . get Min ( ) == task ) queue . notify ( ) ; } }
public void removes Scan Result ( String uri , String method ) { Spider Scan Result to Remove = new Spider Scan Result ( uri , method ) ; synchronized ( scan Results ) { int index = scan Results . index Of ( to Remove ) ; if ( index >= NUM_ ) { scan Results . remove ( index ) ; fire Table Rows Deleted ( index , index ) ; } } }
public FLV Reader ( Io Buffer buffer , boolean generate Metadata ) { this . generate Metadata = generate Metadata ; in = buffer ; post Initialize ( ) ; }
private void fill Compatible ( int precision , char [ ] digits , int n Digits , int exp , boolean is Negative ) { int start Index = is Negative ? NUM_ : NUM_ ; if ( exp > NUM_ && exp < NUM_ ) { if ( n Digits < exp ) { int extra Zeros = exp - n Digits ; mantissa = create ( is Negative , n Digits + extra Zeros + NUM_ ) ; System . arraycopy ( digits , NUM_ , mantissa , start Index , n Digits ) ; Arrays . fill ( mantissa , start Index + n Digits , start Index + n Digits + extra Zeros , STR_ ) ; mantissa [ start Index + n Digits + extra Zeros ] = STR_ ; mantissa [ start Index + n Digits + extra Zeros + NUM_ ] = STR_ ; } else if ( exp < n Digits ) { int t = Math . min ( n Digits - exp , precision ) ; mantissa = create ( is Negative , exp + NUM_ + t ) ; System . arraycopy ( digits , NUM_ , mantissa , start Index , exp ) ; mantissa [ start Index + exp ] = STR_ ; System . arraycopy ( digits , exp , mantissa , start Index + exp + NUM_ , t ) ; } else { mantissa = create ( is Negative , n Digits + NUM_ ) ; System . arraycopy ( digits , NUM_ , mantissa , start Index , n Digits ) ; mantissa [ start Index + n Digits ] = STR_ ; mantissa [ start Index + n Digits + NUM_ ] = STR_ ; } } else if ( exp <= NUM_ && exp > - NUM_ ) { int zeros = Math . max ( NUM_ , Math . min ( - exp , precision ) ) ; int t = Math . max ( NUM_ , Math . min ( n Digits , precision + exp ) ) ; if ( zeros > NUM_ ) { mantissa = create ( is Negative , zeros + NUM_ + t ) ; mantissa [ start Index ] = STR_ ; mantissa [ start Index + NUM_ ] = STR_ ; Arrays . fill ( mantissa , start Index + NUM_ , start Index + NUM_ + zeros , STR_ ) ; if ( t > NUM_ ) { System . arraycopy ( digits , NUM_ , mantissa , start Index + NUM_ + zeros , t ) ; } } else if ( t > NUM_ ) { mantissa = create ( is Negative , zeros + NUM_ + t ) ; mantissa [ start Index ] = STR_ ; mantissa [ start Index + NUM_ ] = STR_ ; System . arraycopy ( digits , NUM_ , mantissa , start Index + NUM_ , t ) ; } else { this . mantissa = create ( is Negative , NUM_ ) ; this . mantissa [ start Index ] = STR_ ; } } else { if ( n Digits > NUM_ ) { mantissa = create ( is Negative , n Digits + NUM_ ) ; mantissa [ start Index ] = digits [ NUM_ ] ; mantissa [ start Index + NUM_ ] = STR_ ; System . arraycopy ( digits , NUM_ , mantissa , start Index + NUM_ , n Digits - NUM_ ) ; } else { mantissa = create ( is Negative , NUM_ ) ; mantissa [ start Index ] = digits [ NUM_ ] ; mantissa [ start Index + NUM_ ] = STR_ ; mantissa [ start Index + NUM_ ] = STR_ ; } int e , exp Start Intex ; boolean is Neg Exp = ( exp <= NUM_ ) ; if ( is Neg Exp ) { e = - exp + NUM_ ; exp Start Intex = NUM_ ; } else { e = exp - NUM_ ; exp Start Intex = NUM_ ; } if ( e <= NUM_ ) { exponent = create ( is Neg Exp , NUM_ ) ; exponent [ exp Start Intex ] = ( char ) ( e + STR_ ) ; } else if ( e <= NUM_ ) { exponent = create ( is Neg Exp , NUM_ ) ; exponent [ exp Start Intex ] = ( char ) ( e / NUM_ + STR_ ) ; exponent [ exp Start Intex + NUM_ ] = ( char ) ( e % NUM_ + STR_ ) ; } else { exponent = create ( is Neg Exp , NUM_ ) ; exponent [ exp Start Intex ] = ( char ) ( e / NUM_ + STR_ ) ; e %= NUM_ ; exponent [ exp Start Intex + NUM_ ] = ( char ) ( e / NUM_ + STR_ ) ; exponent [ exp Start Intex + NUM_ ] = ( char ) ( e % NUM_ + STR_ ) ; } } }
public BPTT Creation Dialog ( final Network Panel panel ) { this . panel = panel ; set Title ( STR_ ) ; tf Num Inputs Outputs . set Columns ( NUM_ ) ; prefs Panel . add Item ( STR_ , tf Num Inputs Outputs ) ; prefs Panel . add Item ( STR_ , tf Num Hidden ) ; tf Num Inputs Outputs . set Text ( STR_ + NUM_ ) ; tf Num Hidden . set Text ( STR_ + NUM_ ) ; set Content Pane ( prefs Panel ) ; }
private void read Into Buffer ( Input Stream is ) throws IO Exception { if ( is == null ) { throw new IO Exception ( STR_ ) ; } b Size = NUM_ ; while ( true ) { int n = is . read ( b , b Size , b . length - b Size ) ; if ( n == - NUM_ ) { break ; } b Size += n ; if ( b Size >= b . length ) { byte [ ] c = new byte [ b . length << NUM_ ] ; System . arraycopy ( b , NUM_ , c , NUM_ , b . length ) ; b = c ; } } }
public static int parse Decimal Value ( String s ) throws Number Format Exception { int value = - NUM_ ; if ( s . length ( ) > NUM_ ) { value = Integer . parse Int ( s , NUM_ ) ; } return value ; }
public double local Score ( int i ) { double sum = NUM_ ; int count = NUM_ ; for ( Sem Bic Score score : sem Bic Scores ) { double score = score . local Score ( i ) ; if ( ! Double . is Na N ( score ) ) { sum += score ; count ++ ; } } return sum / count ; }
public static Filter Result included If ( boolean included , Supplier < String > inclusion Reason Supplier , Supplier < String > exclusion Reason Supplier ) { return included ? included ( inclusion Reason Supplier . get ( ) ) : excluded ( exclusion Reason Supplier . get ( ) ) ; }
private boolean region Dialing From Matches Number ( Phone Number number , String region Dialing From ) { List < String > region Codes = get Region Codes For Country Code ( number . get Country Code ( ) ) ; return region Codes . contains ( region Dialing From ) ; }
@ Non Null @ Contract ( pure = true ) private < Output > Chronos Operation Result < Output > create Empty Result ( @ Non Null final Chronos Operation < Output > operation , final boolean broadcast Result ) { final Chronos Operation Result < Output > operation Result ; final Class < ? extends Chronos Operation Result < Output > > result Class = operation . get Result Class ( ) ; try { operation Result = result Class . new Instance ( ) ; } catch ( Instantiation Exception e ) { throw new Runtime Exception ( STR_ + result Class . get Name ( ) ) ; } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( result Class . get Name ( ) + STR_ ) ; } operation Result . set Id ( m Last Operation Id . increment And Get ( ) ) ; operation Result . set Operation ( operation ) ; operation Result . set Broadcast ( broadcast Result ) ; return operation Result ; }
public final int feed Bytes ( byte [ ] buf , int off , int len ) { if ( len == NUM_ ) return NUM_ ; if ( len < NUM_ ) throw new Pngj Exception ( STR_ ) ; if ( read == NUM_ && crcn == NUM_ && crc Check ) chunk Raw . update Crc ( chunk Raw . idbytes , NUM_ , NUM_ ) ; int bytes For Data = chunk Raw . len - read ; if ( bytes For Data > len ) bytes For Data = len ; if ( bytes For Data > NUM_ || crcn == NUM_ ) { if ( crc Check && mode != Chunk Reader Mode . BUFFER && bytes For Data > NUM_ ) chunk Raw . update Crc ( buf , off , bytes For Data ) ; if ( mode == Chunk Reader Mode . BUFFER ) { if ( chunk Raw . data != buf && bytes For Data > NUM_ ) { System . arraycopy ( buf , off , chunk Raw . data , read , bytes For Data ) ; } } else if ( mode == Chunk Reader Mode . PROCESS ) { process Data ( read , buf , off , bytes For Data ) ; } else { } read += bytes For Data ; off += bytes For Data ; len -= bytes For Data ; } int crc Read = NUM_ ; if ( read == chunk Raw . len ) { crc Read = NUM_ - crcn ; if ( crc Read > len ) crc Read = len ; if ( crc Read > NUM_ ) { if ( buf != chunk Raw . crcval ) System . arraycopy ( buf , off , chunk Raw . crcval , crcn , crc Read ) ; crcn += crc Read ; if ( crcn == NUM_ ) { if ( crc Check ) { if ( mode == Chunk Reader Mode . BUFFER ) { chunk Raw . update Crc ( chunk Raw . data , NUM_ , chunk Raw . len ) ; } chunk Raw . check Crc ( ) ; } chunk Done ( ) ; } } } return bytes For Data + crc Read ; }
public void Xtest Wild Card Subscription Preserved On Restart ( ) throws Exception { Active MQ Destination dest 1 = new Active MQ Topic ( STR_ ) ; Active MQ Destination dest 2 = new Active MQ Topic ( STR_ ) ; Active MQ Destination dest 3 = new Active MQ Topic ( STR_ ) ; Active MQ Destination wild Dest = new Active MQ Topic ( STR_ ) ; Array List < Message Id > sent Before Restart = new Array List < > ( ) ; Array List < Message Id > sent Before Create Consumer = new Array List < > ( ) ; Array List < Message Id > sent After Create Consumer = new Array List < > ( ) ; { Stub Connection connection 1 = create Connection ( ) ; Connection Info connection Info 1 = create Connection Info ( ) ; connection Info 1 . set Client Id ( STR_ ) ; Session Info session Info 1 = create Session Info ( connection Info 1 ) ; Producer Info producer Info 1 = create Producer Info ( session Info 1 ) ; connection 1 . send ( connection Info 1 ) ; connection 1 . send ( session Info 1 ) ; connection 1 . send ( producer Info 1 ) ; Consumer Info consumer Info 1 = create Consumer Info ( session Info 1 , wild Dest ) ; consumer Info 1 . set Subscription Name ( STR_ ) ; consumer Info 1 . set Prefetch Size ( NUM_ ) ; connection 1 . send ( consumer Info 1 ) ; connection 1 . send ( close Consumer Info ( consumer Info 1 ) ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { Message m = create Message ( producer Info 1 , dest 1 , Delivery Mode . PERSISTENT ) ; connection 1 . send ( m ) ; sent Before Restart . add ( m . get Message Id ( ) ) ; } connection 1 . request ( close Connection Info ( connection Info 1 ) ) ; connection 1 . stop ( ) ; } restart Broker ( ) ; { Stub Connection connection 2 = create Connection ( ) ; Connection Info connection Info 2 = create Connection Info ( ) ; connection Info 2 . set Client Id ( STR_ ) ; Session Info session Info 2 = create Session Info ( connection Info 2 ) ; connection 2 . send ( connection Info 2 ) ; connection 2 . send ( session Info 2 ) ; Producer Info producer Info 2 = create Producer Info ( session Info 2 ) ; connection 2 . send ( producer Info 2 ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { Message m = create Message ( producer Info 2 , dest 2 , Delivery Mode . PERSISTENT ) ; connection 2 . send ( m ) ; sent Before Create Consumer . add ( m . get Message Id ( ) ) ; } Consumer Info consumer Info 2 = create Consumer Info ( session Info 2 , wild Dest ) ; consumer Info 2 . set Subscription Name ( STR_ ) ; consumer Info 2 . set Prefetch Size ( NUM_ ) ; connection 2 . send ( consumer Info 2 ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { Message m = create Message ( producer Info 2 , dest 3 , Delivery Mode . PERSISTENT ) ; connection 2 . send ( m ) ; sent After Create Consumer . add ( m . get Message Id ( ) ) ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { Message m 2 = receive Message ( connection 2 ) ; assert Not Null ( STR_ + i , m 2 ) ; assert Equals ( sent Before Restart . get ( i ) , m 2 . get Message Id ( ) ) ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { Message m 2 = receive Message ( connection 2 ) ; assert Not Null ( STR_ + i , m 2 ) ; assert Equals ( sent Before Create Consumer . get ( i ) , m 2 . get Message Id ( ) ) ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { Message m 2 = receive Message ( connection 2 ) ; assert Not Null ( STR_ + i , m 2 ) ; assert Equals ( STR_ + i , sent After Create Consumer . get ( i ) , m 2 . get Message Id ( ) ) ; } assert No Messages Left ( connection 2 ) ; } }
public boolean add Mouse Listener ( final Map Mouse Listener listener ) { if ( listener == null ) { throw new Illegal Argument Exception ( STR_ ) ; } return listeners . add ( listener ) ; }
public void add Listener ( Resource Notification Listener listener ) { if ( listener == null ) { logger . error ( STR_ ) ; } listeners . add ( listener ) ; }
public Builder add Listen Urls ( List < String > urls ) { List < String > need Add = new Array List < String > ( ) ; for ( String url : urls ) { if ( ! Url Util . is Url ( url ) ) { continue ; } need Add . add ( url ) ; } if ( ! Collection Util . is Empty ( need Add ) ) { if ( m Listen Urls == null ) { m Listen Urls = new Hash Set < String > ( ) ; } m Listen Urls . add All ( need Add ) ; } return this ; }
public final void add Tree Model Listener ( final Tree Model Listener l ) { tree Model Listeners . add ( Tree Model Listener . class , l ) ; }
private void expand All Nodes ( J Tree tree , Tree Path parent Path ) { Tree Node node = ( Tree Node ) parent Path . get Last Path Component ( ) ; for ( int i = NUM_ ; i < node . get Child Count ( ) ; i ++ ) { expand All Nodes ( tree , parent Path . path By Adding Child ( node . get Child At ( i ) ) ) ; } tree . expand Path ( parent Path ) ; }
public static Config History load ( File root , DB Instance Info db ) { File f = new File ( root , db . get Db Group Name ( ) + STR_ + db . get Host Name ( ) + STR_ + db . get Port ( ) + STR_ ) ; if ( ! f . exists ( ) ) return null ; File Input Stream in = null ; try { in = new File Input Stream ( f ) ; Config History ch = new Config History ( ) ; ch . read ( in ) ; return ch ; } catch ( Exception ex ) { } finally { if ( in != null ) try { in . close ( ) ; } catch ( Exception ex ) { } } return null ; }
public static Set < Emoticon > make Emoticons ( String source Id ) { Set < Emoticon > result = new Hash Set < > ( ) ; if ( source Id . equals ( Emoji Set . E 1 . id ) ) { e 1 ( Emoji Set . E 1 , result ) ; } else if ( source Id . equals ( Emoji Set . TWEMOJI . id ) ) { twemoji ( Emoji Set . TWEMOJI , result ) ; } LOGGER . info ( STR_ + result . size ( ) + STR_ + source Id ) ; return result ; }
Variogram Theory Variogram NSGA ( Semivariogram Type semi Type , int n ) { double [ ] y = new double [ bins . length ] ; for ( int i = NUM_ ; i < y . length ; i ++ ) { y [ i ] = bins [ i ] [ n ] . Value ; } int n Nan = NUM_ ; for ( int i = NUM_ ; i < y . length ; i ++ ) { if ( ! Double . is Na N ( y [ i ] ) ) { n Nan ++ ; } } x = new double [ n Nan ] ; double [ ] y 2 = new double [ n Nan ] ; int ntmp = NUM_ ; for ( int i = NUM_ ; i < y . length ; i ++ ) { if ( ! Double . is Na N ( y [ i ] ) ) { y 2 [ ntmp ] = y [ i ] ; x [ ntmp ] = bins [ i ] [ nth S Variogram ] . Distance ; ntmp ++ ; } } y = y 2 ; double [ ] [ ] pnts = new double [ y . length ] [ NUM_ ] ; for ( int i = NUM_ ; i < y . length ; i ++ ) { pnts [ i ] [ NUM_ ] = y [ i ] ; pnts [ i ] [ NUM_ ] = x [ i ] ; } Variogram var = new Variogram ( ) ; var . Type = semi Type ; Semivariogram Curve Fitter svcf = new Semivariogram Curve Fitter ( ) ; try { var = svcf . Run ( pnts , semi Type , Consider Nugget ) ; } catch ( JM Exception ex ) { } catch ( Security Exception ex ) { } catch ( IO Exception ex ) { } catch ( Class Not Found Exception ex ) { } return var ; }
public synchronized boolean remove ( Integer i ) { if ( value . remove ( i ) ) { set Value ( value ) ; return true ; } else { return false ; } }
public static void put At ( String Builder self , Empty Range range , Object value ) { Range Info info = sub List Borders ( self . length ( ) , range ) ; self . replace ( info . from , info . to , value . to String ( ) ) ; }
void add Wait Statement ( ) { if ( is Recording ( ) ) { long t = System . current Time Millis ( ) ; long d = t - wait Timer ; generated Code += STR_ + d + STR_ ; wait Timer = t ; } }
public Id < Tt Path > convert Path Info 2 Path Id ( List < Id < Dg Street > > ks Path , Id < Dg Crossing Node > ks Source Node Id , Id < Dg Crossing Node > ks Drain Node Id ) { String id String = ks Source Node Id . to String ( ) + STR_ ; for ( Id < Dg Street > street Id : ks Path ) { id String += street Id . to String ( ) + STR_ ; } id String . substring ( NUM_ , id String . length ( ) - NUM_ ) ; id String += STR_ + ks Drain Node Id . to String ( ) ; return id Pool . create Id ( id String , Tt Path . class ) ; }
public static final int binary Search ( Object [ ] a , Object key , Comparator cp ) { int x 1 = NUM_ ; int x 2 = a . length ; int i = x 2 / NUM_ , c ; while ( x 1 < x 2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == NUM_ ) { return i ; } else if ( c < NUM_ ) { x 1 = i + NUM_ ; } else { x 2 = i ; } i = x 1 + ( x 2 - x 1 ) / NUM_ ; } return - NUM_ * ( i + NUM_ ) ; }
public void mutate ( List < Aggregation Individual > population ) { List < Aggregation Individual > children = new Array List < Aggregation Individual > ( ) ; Iterator < Aggregation Individual > i = population . iterator ( ) ; while ( i . has Next ( ) ) { Aggregation Individual individual = i . next ( ) ; int [ ] parent = individual . get Individual ( ) ; int [ ] child = new int [ parent . length ] ; for ( int j = NUM_ ; j < child . length ; j ++ ) { child [ j ] = parent [ j ] ; } mutate ( child ) ; if ( is Valid ( child ) ) { children . add ( new Aggregation Individual ( child ) ) ; } } population . add All ( children ) ; }
protected Item Stack filter Item ( Item Stack item Stack , T cosmetic Type , Ultra Player player ) { return item Stack ; }
private void initialize Nodejs Preferences ( I Eclipse Preferences node ) { if ( ! use Bundled Node Js Embedded ( node ) ) { node . put Boolean ( Type Script Core Preference Constants . USE NODEJS EMBEDDED , false ) ; node . put ( Type Script Core Preference Constants . NODEJS PATH , IDE Nodejs Process Helper . get Nodejs Path ( ) ) ; } else { node . put Boolean ( Type Script Core Preference Constants . USE NODEJS EMBEDDED , true ) ; node . put ( Type Script Core Preference Constants . NODEJS PATH , STR_ ) ; } }
public Button Row ( Action [ ] actions , int orientation , int glue ) { this ( actions , orientation , glue , null ) ; }
public static String lower ( String string ) { return string != null ? string . to Lower Case ( ) : null ; }
private boolean calculate Bounds ( Rect F rect ) { float left = Bitmap Utils . get Rect Left ( m Bounds Points ) ; float top = Bitmap Utils . get Rect Top ( m Bounds Points ) ; float right = Bitmap Utils . get Rect Right ( m Bounds Points ) ; float bottom = Bitmap Utils . get Rect Bottom ( m Bounds Points ) ; if ( is Non Straight Angle Rotated ( ) ) { m Calc Bounds . set ( left , top , right , bottom ) ; return false ; } else { float x 0 = m Bounds Points [ NUM_ ] ; float y 0 = m Bounds Points [ NUM_ ] ; float x 2 = m Bounds Points [ NUM_ ] ; float y 2 = m Bounds Points [ NUM_ ] ; float x 3 = m Bounds Points [ NUM_ ] ; float y 3 = m Bounds Points [ NUM_ ] ; if ( m Bounds Points [ NUM_ ] < m Bounds Points [ NUM_ ] ) { if ( m Bounds Points [ NUM_ ] < m Bounds Points [ NUM_ ] ) { x 0 = m Bounds Points [ NUM_ ] ; y 0 = m Bounds Points [ NUM_ ] ; x 2 = m Bounds Points [ NUM_ ] ; y 2 = m Bounds Points [ NUM_ ] ; x 3 = m Bounds Points [ NUM_ ] ; y 3 = m Bounds Points [ NUM_ ] ; } else { x 0 = m Bounds Points [ NUM_ ] ; y 0 = m Bounds Points [ NUM_ ] ; x 2 = m Bounds Points [ NUM_ ] ; y 2 = m Bounds Points [ NUM_ ] ; x 3 = m Bounds Points [ NUM_ ] ; y 3 = m Bounds Points [ NUM_ ] ; } } else if ( m Bounds Points [ NUM_ ] > m Bounds Points [ NUM_ ] ) { x 0 = m Bounds Points [ NUM_ ] ; y 0 = m Bounds Points [ NUM_ ] ; x 2 = m Bounds Points [ NUM_ ] ; y 2 = m Bounds Points [ NUM_ ] ; x 3 = m Bounds Points [ NUM_ ] ; y 3 = m Bounds Points [ NUM_ ] ; } float a 0 = ( y 3 - y 0 ) / ( x 3 - x 0 ) ; float a 1 = - NUM_ / a 0 ; float b 0 = y 0 - a 0 * x 0 ; float b 1 = y 0 - a 1 * x 0 ; float b 2 = y 2 - a 0 * x 2 ; float b 3 = y 2 - a 1 * x 2 ; float c 0 = ( rect . center Y ( ) - rect . top ) / ( rect . center X ( ) - rect . left ) ; float c 1 = - c 0 ; float d 0 = rect . top - c 0 * rect . left ; float d 1 = rect . top - c 1 * rect . right ; left = Math . max ( left , ( d 0 - b 0 ) / ( a 0 - c 0 ) < rect . right ? ( d 0 - b 0 ) / ( a 0 - c 0 ) : left ) ; left = Math . max ( left , ( d 0 - b 1 ) / ( a 1 - c 0 ) < rect . right ? ( d 0 - b 1 ) / ( a 1 - c 0 ) : left ) ; left = Math . max ( left , ( d 1 - b 3 ) / ( a 1 - c 1 ) < rect . right ? ( d 1 - b 3 ) / ( a 1 - c 1 ) : left ) ; right = Math . min ( right , ( d 1 - b 1 ) / ( a 1 - c 1 ) > rect . left ? ( d 1 - b 1 ) / ( a 1 - c 1 ) : right ) ; right = Math . min ( right , ( d 1 - b 2 ) / ( a 0 - c 1 ) > rect . left ? ( d 1 - b 2 ) / ( a 0 - c 1 ) : right ) ; right = Math . min ( right , ( d 0 - b 2 ) / ( a 0 - c 0 ) > rect . left ? ( d 0 - b 2 ) / ( a 0 - c 0 ) : right ) ; top = Math . max ( top , Math . max ( a 0 * left + b 0 , a 1 * right + b 1 ) ) ; bottom = Math . min ( bottom , Math . min ( a 1 * left + b 3 , a 0 * right + b 2 ) ) ; m Calc Bounds . left = left ; m Calc Bounds . top = top ; m Calc Bounds . right = right ; m Calc Bounds . bottom = bottom ; return true ; } }
private Resource Path managed Id ( String resource Id ) { return resource Id != null ? managed Object Path . child ( resource Id ) : managed Object Path ; }
public void make Truthtable Bargraph ( Gate g , String prefix , String suffix ) { String name rpu data = prefix + STR_ + g . Name + STR_ + suffix + STR_ ; Logic Circuit lc = new Logic Circuit ( ) ; String rpu data = lc . print Logic RPU ( g ) ; Util . file Writer ( output directory + name rpu data , rpu data , false ) ; String logic string = Boolean Logic . logic String ( g . get logics ( ) ) ; logic string = logic string . replace All ( STR_ , STR_ ) ; String cmd = STR_ + home + STR_ + output directory + STR_ + date ID + STR_ + name rpu data + STR_ + logic string ; Util . execute Command ( cmd ) ; }
public Cannot Find Method Exception ( Special Invoke Expr invoke , Soot Method method ) { super ( String . format ( STR_ , invoke , method ) ) ; }
public void move ( Mouse Event e ) { Point 2 D pnt = get Projection Point ( e ) ; int x = ( int ) pnt . get X ( ) ; int y = ( int ) pnt . get Y ( ) ; if ( line . get Render Type ( ) == OM Graphic . RENDERTYPE OFFSET ) { gpm = new Offset Grab Point ( x , y ) ; gpm . add Grab Point ( gp 1 ) ; gpm . add Grab Point ( gp 2 ) ; } else { gpm = gpo ; gpm . set ( x , y ) ; gpm . update Offsets ( ) ; } moving Point = gpm ; }
public List < Gsm Service Parameter > create Process Parameter For Organization ( Integer org Id ) { init Graph ( org Id ) ; List < Cn A Tree Element > right Element List = get Right Hand Elements ( org Id ) ; List < Cn A Tree Element > left Element List = get Left Hand Elements ( org Id ) ; if ( LOG . is Info Enabled ( ) ) { LOG . info ( right Element List . size ( ) + STR_ ) ; LOG . info ( left Element List . size ( ) + STR_ ) ; } List < Gsm Service Parameter > all Parameter List = new Linked List < Gsm Service Parameter > ( ) ; for ( Cn A Tree Element control Group : right Element List ) { for ( Cn A Tree Element left Element : left Element List ) { List < Execution Impl > process List = find Processes ( left Element , control Group ) ; if ( process List != null && ! process List . is Empty ( ) ) { delete Processes ( process List ) ; } List < Gsm Service Parameter > parameter List = create Parameter ( left Element , control Group ) ; String uuid Org = load Org Uuid ( org Id ) ; for ( Gsm Service Parameter parameter : parameter List ) { parameter . set Uuid Org ( uuid Org ) ; all Parameter List . add ( parameter ) ; } } } if ( LOG . is Info Enabled ( ) ) { LOG . info ( all Parameter List . size ( ) + STR_ ) ; } return all Parameter List ; }
public Pin Later Job build Job ( ) { Pin Later Job job = new Pin Later Job ( Byte Buffer . wrap ( log Data . get Bytes ( ) ) ) ; job . set Num Attempts Allowed ( NUM_ ) ; return job ; }
int find Sync Position ( ) { int count = m Item Count ; if ( count == NUM_ ) { return INVALID POSITION ; } long id To Match = m Sync Col Id ; int seed = m Sync Position ; if ( id To Match == INVALID COL ID ) { return INVALID POSITION ; } seed = Math . max ( NUM_ , seed ) ; seed = Math . min ( count - NUM_ , seed ) ; long end Time = System Clock . uptime Millis ( ) + SYNC MAX DURATION MILLIS ; long col Id ; int first = seed ; int last = seed ; boolean next = false ; boolean hit First ; boolean hit Last ; T adapter = get Adapter ( ) ; if ( adapter == null ) { return INVALID POSITION ; } while ( System Clock . uptime Millis ( ) <= end Time ) { col Id = adapter . get Item Id ( seed ) ; if ( col Id == id To Match ) { return seed ; } hit Last = last == count - NUM_ ; hit First = first == NUM_ ; if ( hit Last && hit First ) { break ; } if ( hit First || ( next && ! hit Last ) ) { last ++ ; seed = last ; next = false ; } else if ( hit Last || ( ! next && ! hit First ) ) { first -- ; seed = first ; next = true ; } } return INVALID POSITION ; }
public boolean is Whitelist Required ( ) { return whitelist Required . get ( ) ; }
protected void Create FD Select ( Offset Item fdselect Ref , int nglyphs ) { Output List . add Last ( new Marker Item ( fdselect Ref ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM_ ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) NUM_ ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) NUM_ ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM_ ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) nglyphs ) ) ; }
static private String INT Max ( ) { int temp Value = Integer . MAX VALUE ; return String . value Of ( temp Value ) ; }
private Bind Request wait For Bind ( long timeout ) throws Illegal State Exception , Timeout Exception { Session State current Session State = get Session State ( ) ; if ( current Session State . equals ( Session State . OPEN ) ) { try { return bind Request Receiver . wait For Request ( timeout ) ; } catch ( Illegal State Exception e ) { throw new Illegal State Exception ( STR_ , e ) ; } catch ( Timeout Exception e ) { close ( ) ; throw e ; } } else { throw new Illegal State Exception ( STR_ + current Session State ) ; } }
public Datagram Reader ( final byte [ ] byte Array ) { byte Stream = new Byte Array Input Stream ( Arrays . copy Of ( byte Array , byte Array . length ) ) ; current Byte = NUM_ ; current Bit Index = - NUM_ ; }
private Mock Network Table table For Key ( String key ) { if ( key . contains ( STR_ ) ) { return ( Mock Network Table ) get Sub Table ( key . substring ( NUM_ , key . last Index Of ( STR_ ) ) ) ; } else { return this ; } }
public static void validate ( Space URL space URL ) throws Exception { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + space URL ) ; } try { validate URL ( space URL ) ; } catch ( Space URL Validation Exception e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + e . get Message ( ) + STR_ + space URL ) ; } throw e ; } }
@ Override public void on Update Scrollbar ( int dy ) { List < Alphabetical Apps List . Adapter Item > items = m Apps . get Adapter Items ( ) ; if ( items . is Empty ( ) || m Num Apps Per Row == NUM_ ) { m Scrollbar . set Thumb Offset ( - NUM_ , - NUM_ ) ; return ; } int row Count = m Apps . get Num App Rows ( ) ; get Cur Scroll State ( m Scroll Pos State , - NUM_ ) ; if ( m Scroll Pos State . row Index < NUM_ ) { m Scrollbar . set Thumb Offset ( - NUM_ , - NUM_ ) ; return ; } int available Scroll Bar Height = get Available Scroll Bar Height ( ) ; int available Scroll Height = get Available Scroll Height ( m Apps . get Num App Rows ( ) ) ; if ( available Scroll Height <= NUM_ ) { m Scrollbar . set Thumb Offset ( - NUM_ , - NUM_ ) ; return ; } int scroll Y = get Scroll Top ( m Scroll Pos State ) ; int scroll Bar Y = m Background Padding . top + ( int ) ( ( ( float ) scroll Y / available Scroll Height ) * available Scroll Bar Height ) ; if ( m Scrollbar . is Thumb Detached ( ) ) { int scroll Bar X ; if ( Utilities . is Rtl ( get Resources ( ) ) ) { scroll Bar X = m Background Padding . left ; } else { scroll Bar X = get Width ( ) - m Background Padding . right - m Scrollbar . get Thumb Width ( ) ; } if ( m Scrollbar . is Dragging Thumb ( ) ) { m Scrollbar . set Thumb Offset ( scroll Bar X , ( int ) m Scrollbar . get Last Touch Y ( ) ) ; } else { int thumb Scroll Y = m Scrollbar . get Thumb Offset ( ) . y ; int diff Scroll Y = scroll Bar Y - thumb Scroll Y ; if ( diff Scroll Y * dy > NUM_ ) { if ( dy < NUM_ ) { int offset = ( int ) ( ( dy * thumb Scroll Y ) / ( float ) scroll Bar Y ) ; thumb Scroll Y += Math . max ( offset , diff Scroll Y ) ; } else { int offset = ( int ) ( ( dy * ( available Scroll Bar Height - thumb Scroll Y ) ) / ( float ) ( available Scroll Bar Height - scroll Bar Y ) ) ; thumb Scroll Y += Math . min ( offset , diff Scroll Y ) ; } thumb Scroll Y = Math . max ( NUM_ , Math . min ( available Scroll Bar Height , thumb Scroll Y ) ) ; m Scrollbar . set Thumb Offset ( scroll Bar X , thumb Scroll Y ) ; if ( scroll Bar Y == thumb Scroll Y ) { m Scrollbar . reattach Thumb To Scroll ( ) ; } } else { m Scrollbar . set Thumb Offset ( scroll Bar X , thumb Scroll Y ) ; } } } else { synchronize Scroll Bar Thumb Offset To View Scroll ( m Scroll Pos State , row Count ) ; } }
private Workflow . Method rollback Delete CG Method ( URI cg URI , String delete Step Id ) { return new Workflow . Method ( RB DELETE CG METHOD NAME , cg URI , delete Step Id ) ; }
private double psfunc 3 ( double x , double t 1 , double t 2 , int dim ) { dim = dim + NUM_ ; double xy = NUM_ * ( x - NUM_ ) ; if ( l Type == NUM_ ) { double rate = dim / ( double ) number Of Variables ; return xy - NUM_ * ( t 1 * t 1 * rate + t 2 * ( NUM_ - rate ) ) + NUM_ ; } else if ( l Type == NUM_ ) { double theta = NUM_ * Math . PI * t 1 + dim * Math . PI / number Of Variables ; return xy - NUM_ * t 2 * Math . sin ( theta ) ; } else { throw new Illegal State Exception ( ) ; } }
public void add ( boolean priority , Create Marker Task c ) { lock . lock ( ) ; send Empty Message ( BLANK ) ; if ( priority ) { m On Screen Create Marker Tasks . add ( c ) ; } else { m Create Marker Tasks . add ( c ) ; } lock . unlock ( ) ; }
protected void execute Tasks ( final Access Path Task [ ] tasks ) throws Exception { if ( executor == null ) { for ( Access Path Task task : tasks ) { task . call ( ) ; } return ; } final List < Future Task < Void > > future Tasks = new Linked List < Future Task < Void > > ( ) ; for ( Access Path Task task : tasks ) { final Future Task < Void > ft = new Future Task Mon < Void > ( task ) ; future Tasks . add ( ft ) ; } try { for ( Future Task < Void > ft : future Tasks ) { halted ( ) ; executor . execute ( ft ) ; } for ( Future Task < Void > ft : future Tasks ) { if ( ! is Done ( ) ) ft . get ( ) ; } } finally { for ( Future Task < Void > ft : future Tasks ) { ft . cancel ( true ) ; } } }
private synchronized void read Object ( java . io . Object Input Stream s ) throws IO Exception , Class Not Found Exception { Get Field gf = s . read Fields ( ) ; String protocol = ( String ) gf . get ( STR_ , null ) ; if ( get URL Stream Handler ( protocol ) == null ) { throw new IO Exception ( STR_ + protocol ) ; } String host = ( String ) gf . get ( STR_ , null ) ; int port = gf . get ( STR_ , - NUM_ ) ; String authority = ( String ) gf . get ( STR_ , null ) ; String file = ( String ) gf . get ( STR_ , null ) ; String ref = ( String ) gf . get ( STR_ , null ) ; int hash Code = gf . get ( STR_ , - NUM_ ) ; if ( authority == null && ( ( host != null && host . length ( ) > NUM_ ) || port != - NUM_ ) ) { if ( host == null ) host = STR_ ; authority = ( port == - NUM_ ) ? host : host + STR_ + port ; } temp State = new Url Deserialized State ( protocol , host , port , authority , file , ref , hash Code ) ; }
private double calc Level Threshold ( double max Coeff ) { return Math . pow ( NUM_ , Math . floor ( Math . log ( max Coeff ) / Math . log ( NUM_ ) ) - NUM_ ) ; }
public List < String > compact Attribute Value ( String value , int start ) { List < String > result = new Array List < String > ( ) ; if ( start > value . length ( ) ) { result . add ( value ) ; return result ; } Wb Xml Attribute Value Def value Def = new Wb Xml Attribute Value Def ( value . substring ( start ) , ( byte ) NUM_ , ( byte ) NUM_ ) ; for ( Wb Xml Attribute Value Def attr Val : attr Values By Value . tail Set ( value Def ) ) { List < String > found = matches ( value , attr Val . get Value ( ) , start , true ) ; if ( found != null ) { return found ; } } result . add ( value ) ; return result ; }
public static Commit Version Info build ( Index Commit commit ) { long generation = commit . get Generation ( ) ; long version = NUM_ ; try { final Map < String , String > commit Data = commit . get User Data ( ) ; String commit Time = commit Data . get ( Solr Index Writer . COMMIT TIME MSEC KEY ) ; if ( commit Time != null ) { try { version = Long . parse Long ( commit Time ) ; } catch ( Number Format Exception e ) { LOG . warn ( STR_ + commit Time , e ) ; } } } catch ( IO Exception e ) { LOG . warn ( STR_ + commit , e ) ; } return new Commit Version Info ( generation , version ) ; }
public void reset Subsampling Indices ( ) { if ( neuron List != null ) { subsampling Indices = Simbrain Math . rand Permute ( NUM_ , neuron List . size ( ) ) ; } }
public static int generate View Id ( ) { for ( ; ; ) { final int result = s Next Generated Id . get ( ) ; int new Value = result + NUM_ ; if ( new Value > NUM_ ) new Value = NUM_ ; if ( s Next Generated Id . compare And Set ( result , new Value ) ) { return result ; } } }
public static String remove Hidden Markers ( final String contents ) { if ( contents == null ) { return null ; } if ( ! contents . contains ( MARKER ) ) { return contents ; } final String Tokenizer tokens = new String Tokenizer ( contents , MARKER , true ) ; String temp token ; String Builder processed data = new String Builder ( ) ; while ( tokens . has More Tokens ( ) ) { temp token = tokens . next Token ( ) ; if ( temp token . equals ( MARKER ) ) { tokens . next Token ( ) ; tokens . next Token ( ) ; tokens . next Token ( ) ; tokens . next Token ( ) ; processed data = processed data . append ( tokens . next Token ( ) ) ; } else { processed data = processed data . append ( temp token ) ; } } return processed data . to String ( ) ; }
private void draw Spot ( Graphics g , int c , int r , char m ) { if ( m == Tic Tac Toe Board . EMPTY ) { g . set Color ( Color . light Gray ) ; g . fill Rect ( NUM_ + CELLSIZE * c , NUM_ + CELLSIZE * r , NUM_ , NUM_ ) ; return ; } g . set Color ( Color . black ) ; g . draw String ( STR_ + m , NUM_ + CELLSIZE * c , NUM_ + CELLSIZE * r ) ; }
public static Document create Svg Document ( int width , int height ) { Document document = create Document ( ) ; Element root = document . create Element ( STR_ ) ; String w = String . value Of ( width ) ; String h = String . value Of ( height ) ; root . set Attribute ( STR_ , w ) ; root . set Attribute ( STR_ , h ) ; root . set Attribute ( STR_ , STR_ + w + STR_ + h ) ; root . set Attribute ( STR_ , STR_ ) ; root . set Attribute ( STR_ , mx Constants . NS SVG ) ; document . append Child ( root ) ; return document ; }
private Template Druid Query build Inner Query ( Metric Field source Metric , Template Druid Query inner Dependent Query ) { Set < Aggregation > new Inner Aggregations = convert Sketches To Sketch Merges ( inner Dependent Query . get Aggregations ( ) ) ; Set < Post Aggregation > new Inner Post Aggregations = new Linked Hash Set < > ( ) ; if ( source Metric instanceof Post Aggregation ) { new Inner Post Aggregations . add ( ( Post Aggregation ) source Metric ) ; } Template Druid Query inner Query = inner Dependent Query ; inner Query = inner Query . with Aggregations ( new Inner Aggregations ) ; inner Query = inner Query . with Post Aggregations ( new Inner Post Aggregations ) ; inner Query = inner Query . merge ( build Time Grain Counter Query ( ) ) ; return inner Query ; }
public boolean add Selection ( int position ) { return is Selectable ( position ) && m Selected Positions . add ( position ) ; }
public Training Set Panel ( ) { final J Split Pane split = new J Split Pane ( J Split Pane . HORIZONTAL SPLIT ) ; J Panel filler 1 = new J Panel ( ) ; filler 1 . set Background ( Color . light Gray ) ; J Panel filler 2 = new J Panel ( ) ; filler 2 . set Background ( Color . light Gray ) ; split . set Left Component ( filler 1 ) ; split . set Right Component ( filler 2 ) ; split . set Resize Weight ( NUM_ ) ; split . set Border ( null ) ; set Layout ( new Grid Bag Layout ( ) ) ; Grid Bag Constraints whole Panel Constraints = new Grid Bag Constraints ( ) ; whole Panel Constraints . fill = Grid Bag Constraints . BOTH ; whole Panel Constraints . weightx = NUM_ ; whole Panel Constraints . weighty = NUM_ ; whole Panel Constraints . gridx = NUM_ ; whole Panel Constraints . gridy = NUM_ ; add ( split , whole Panel Constraints ) ; }
public void add Session For Given UUID ( String sid , Long exp Time ) { all Sessionsfor Given UUID . put ( sid , exp Time ) ; }
public void remove Connection ( String host , Integer port ) throws Connection Manager Exception { connection Lock . lock ( ) ; try { String host And Port = Connection Manager . generate Connection Cache Key ( host , port ) ; internal Remove Connection ( host And Port ) ; } finally { connection Lock . unlock ( ) ; } }
private static void Token Out ( int type ) throws Tokenizer Exception { if ( parse Expression ) { if ( ( type == Token . BUILTIN ) || ( type == Token . NUMBER ) || ( type == Token . STRING ) || ( type == Token . IDENT ) ) { if ( ( type != Token . STRING ) && ( ( Is Delimiter ( token ) && ! ( ( type == Token . IDENT ) && ( prev Token . equals ( STR_ ) || prev Token . equals ( STR_ ) || prev Token . equals ( STR_ ) ) ) ) || ( ( ( token . equals ( STR_ ) && ! in Quantifier ) || token . equals ( STR_ ) || token . equals ( STR_ ) ) && ( paren Depth == NUM_ ) ) ) ) { if ( paren Depth != NUM_ ) { Tokenizing Error ( STR_ + STR_ ) ; } ; if ( in Quantifier ) { Tokenizing Error ( STR_ + STR_ ) ; } ; expr End = true ; Delimiter = token ; Delimiter Col = col ; Delimiter Line = reader . get Line Number ( ) ; if ( next Char == STR_ ) { Delimiter Line = Delimiter Line - NUM_ ; } ; if ( linev . size ( ) > NUM_ ) { start New Line ( ) ; } } else { if ( type == Token . BUILTIN ) { Symbol sym = Pcal Built In Symbols . Get Built In Symbol ( token ) ; if ( sym . symbol Type == Symbol . LEFT PAREN ) { paren Depth = paren Depth + NUM_ ; } ; if ( sym . symbol Type == Symbol . RIGHT PAREN ) { paren Depth = paren Depth - NUM_ ; if ( paren Depth < NUM_ ) { Tokenizing Error ( STR_ ) ; } ; } } ; if ( type == Token . STRING ) { prev Token = STR_ ; } else { prev Token = token ; } ; if ( ( token . equals ( STR_ ) || token . equals ( STR_ ) ) && ( paren Depth == NUM_ ) ) { in Quantifier = true ; } ; if ( in Quantifier && token . equals ( STR_ ) && ( paren Depth == NUM_ ) ) { in Quantifier = false ; } ; if ( ( ! token . equals ( STR_ ) ) || ( type == Token . STRING ) ) { linev . add Element ( new TLA Token ( token , col , type , reader . get Line Number ( ) + get Line Correction ) ) ; } ; token = STR_ ; } } else { Tokenizing Error ( STR_ ) ; ; } } else { expr End = true ; Delimiter = token ; Delimiter Col = col ; Delimiter Line = reader . get Line Number ( ) ; if ( next Char == STR_ ) { Delimiter Line = Delimiter Line - NUM_ ; } ; token = STR_ ; } }
public void organization Config Changed ( String service Name , String version , String org Name , String group Name , String service Component , int type ) { String cert Module Port Number = null ; String cert Module Level = null ; if ( org Name == null ) { org Name = SMS Entry . get Root Suffix ( ) ; } try { Service Config config = s Config Mgr . get Organization Config ( org Name , null ) ; Map config Attrs = config . get Attributes ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + config Attrs . to String ( ) ) ; } Set attrs = ( Set ) config Attrs . get ( CERT PORT ATTR ) ; if ( attrs == null ) { return ; } Iterator values = attrs . iterator ( ) ; if ( values . has Next ( ) ) { cert Module Port Number = ( String ) values . next ( ) ; } attrs = ( Set ) config Attrs . get ( AM Auth Config Utils . get Auth Level Attribute ( config Attrs , module Name ) ) ; if ( attrs == null ) { return ; } values = attrs . iterator ( ) ; if ( values . has Next ( ) ) { cert Module Level = ( String ) values . next ( ) ; } Auth Service Config Info info = new Auth Service Config Info ( org Name , module Name , cert Module Port Number , cert Module Level ) ; Auth Config Map . put ( org Name , info ) ; } catch ( Exception e ) { debug . error ( STR_ + STR_ , e ) ; } }
protected List < T > create New Row ( final T value ) { Array List < T > row = new Array List < T > ( ) ; for ( int i = NUM_ ; i < get Logical Column Count ( ) ; i ++ ) { row . add ( value ) ; } return row ; }
private void enable Selection Buttons ( ) { if ( ( tbl Weapons . get Selected Row ( ) != - NUM_ ) || ( tbl Equipment . get Selected Row ( ) != - NUM_ ) ) { btn Add . set Enabled ( true ) ; } btn Left Paren . set Enabled ( true ) ; }
public static Set string Array To Set ( String [ ] strs ) { int count = ( strs != null ) ? count = strs . length : NUM_ ; Set set = ( ( count > NUM_ ) ? new Hash Set ( count ) : new Hash Set ( ) ) ; for ( int i = NUM_ ; i < count ; i ++ ) { set . add ( strs [ i ] ) ; } return set ; }
public static double trim To Range ( double untrimmed Value , double min , double max ) { return Math . max ( min , Math . min ( max , untrimmed Value ) ) ; }
private synchronized void check Shut Down Proxy Bridge ( ) { if ( proxy Server != null ) { smtp Requests Phaser . arrive And Deregister ( ) ; LOGGER . trace ( STR_ , smtp Requests Phaser . get Unarrived Parties ( ) ) ; if ( smtp Requests Phaser . get Unarrived Parties ( ) == NUM_ ) { LOGGER . trace ( STR_ ) ; if ( proxy Server . is Running ( ) && ! proxy Server . is Stopping ( ) ) { LOGGER . trace ( STR_ ) ; proxy Server . stop ( ) ; } if ( executor != null ) { executor . shutdown ( ) ; } } } }
private final String [ ] expand Seen Names ( String [ ] old Shared ) { int len = old Shared . length ; String [ ] new Shared ; if ( len == NUM_ ) { new Shared = smile Buffer Recycler . alloc Seen Names Buffer ( ) ; if ( new Shared == null ) { new Shared = new String [ Smile Buffer Recycler . DEFAULT NAME BUFFER LENGTH ] ; } } else if ( len == Smile Constants . MAX SHARED NAMES ) { new Shared = old Shared ; seen Name Count = NUM_ ; } else { int new Size = ( len == Smile Buffer Recycler . DEFAULT STRING VALUE BUFFER LENGTH ) ? NUM_ : Smile Constants . MAX SHARED NAMES ; new Shared = Arrays . copy Of ( old Shared , new Size ) ; } return new Shared ; }
public static int calc Column Width ( J Table table , int col ) { int width = calc Header Width ( table , col ) ; if ( width == - NUM_ ) { return width ; } Table Column Model columns = table . get Column Model ( ) ; Table Model data = table . get Model ( ) ; int row Count = data . get Row Count ( ) ; columns . get Column ( col ) ; try { for ( int row = row Count - NUM_ ; row >= NUM_ ; -- row ) { Component c = table . prepare Renderer ( table . get Cell Renderer ( row , col ) , row , col ) ; width = Math . max ( width , c . get Preferred Size ( ) . width + NUM_ ) ; } } catch ( Exception e ) { e . print Stack Trace ( ) ; } return width ; }
public void update UI ( ) { super . update UI ( ) ; if ( get Find Popup Menu ( ) != null ) { Swing Utilities . update Component Tree UI ( get Find Popup Menu ( ) ) ; } }
public void cancel Deferred Release ( Releasable releasable ) { ensure On Ui Thread ( ) ; m Pending Releasables . remove ( releasable ) ; }
@ Deprecated public List < Reference > list By Time Range ( Date start , Date end ) { Long start Time = null ; if ( start != null ) { start Time = start . get Time ( ) ; } Long end Time = null ; if ( end != null ) { end Time = end . get Time ( ) ; } return list By Time Range ( start Time , end Time ) ; }
public static byte [ ] pattern To Hash ( List < Lock Pattern View . Cell > pattern ) { if ( pattern == null ) { return null ; } else { int size = pattern . size ( ) ; byte [ ] res = new byte [ size ] ; for ( int i = NUM_ ; i < size ; i ++ ) { Lock Pattern View . Cell cell = pattern . get ( i ) ; res [ i ] = ( byte ) cell . get Index ( ) ; } Message Digest md = null ; try { md = Message Digest . get Instance ( STR_ ) ; return md . digest ( res ) ; } catch ( No Such Algorithm Exception e ) { e . print Stack Trace ( ) ; return res ; } } }
public final void add Raw Text Element ( final float character spacing , final int writing Mode , final String font as string , final float current space , final int font Size , final float x 1 , final float y 1 , final float x 2 , final float y 2 , final String Buffer processed line , final int current text length , final String current Color Tag , final boolean is XML Extraction ) { if ( processed line . length ( ) > NUM_ ) { if ( is XML Extraction ) { processed line . insert ( NUM_ , font as string ) ; processed line . append ( Fonts . fe ) ; } if ( is Color Extracted ) { processed line . insert ( NUM_ , current Color Tag ) ; processed line . append ( Generic Color Space . ce ) ; } f writing Mode [ pointer ] = writing Mode ; text length [ pointer ] = current text length ; f character spacing [ pointer ] = character spacing ; f x 1 [ pointer ] = x 1 ; color Tag [ pointer ] = current Color Tag ; f x 2 [ pointer ] = x 2 ; f y 1 [ pointer ] = y 1 ; f y 2 [ pointer ] = y 2 ; contents [ pointer ] = processed line . to String ( ) ; f end font size [ pointer ] = font Size ; space width [ pointer ] = current space * NUM_ ; pointer ++ ; if ( pointer == max ) { resize Arrays ( ) ; } } }
@ Override public final int support ( ) { return m rule Sup Counter ; }
public void add Text ( String str ) { if ( text == null ) text = new String Buffer ( ) ; text . append ( str ) ; }
public static boolean contains Ignore Cases ( Collection < String > collection , String string ) { if ( collection == null ) { return false ; } if ( string == null ) { return collection . contains ( null ) ; } boolean contains = false ; for ( String element : collection ) { if ( string . equals Ignore Case ( element ) ) { contains = true ; break ; } } return contains ; }
public void append Type Parameter Label ( I Type Parameter type Parameter , long flags ) { try { append Type Parameter With Bounds ( type Parameter , flags ) ; if ( get Flag ( flags , Java Element Labels . TP POST QUALIFIED ) ) { f Buffer . append ( Java Element Labels . CONCAT STRING ) ; I Member declaring Member = type Parameter . get Declaring Member ( ) ; append Element Label ( declaring Member , Java Element Labels . M PARAMETER TYPES | Java Element Labels . M FULLY QUALIFIED | Java Element Labels . T FULLY QUALIFIED | ( flags & QUALIFIER FLAGS ) ) ; } } catch ( Java Model Exception e ) { LOG . error ( e . get Message ( ) , e ) ; } }
protected void write Last Chunk ( byte [ ] buffer , long index ) throws File Encryption Exception , Random Data Generation Exception , Invalid Key Exception , Invalid Algorithm Parameter Exception , Illegal Block Size Exception , Bad Padding Exception , IO Exception { byte [ ] iv = generate Random Chunk IV ( ) ; Iv Parameter Spec spec = new Iv Parameter Spec ( iv ) ; last Chunk Cipher . init ( Cipher . ENCRYPT MODE , get File Key ( ) , spec ) ; byte [ ] enc Chunk = last Chunk Cipher . do Final ( buffer ) ; if ( ( enc Chunk == null ) || ( enc Chunk . length != ( buffer . length + CHUNK TLEN ) ) ) { throw new File Encryption Exception ( STR_ ) ; } long oldpos = backing Random Access File . get File Pointer ( ) ; backing Random Access File . seek ( chunk Offset ( index ) ) ; backing Random Access File . write ( iv ) ; backing Random Access File . write ( enc Chunk ) ; backing Random Access File . seek ( oldpos ) ; }
public static byte [ ] flatten Bitmap ( Bitmap bitmap ) { int size = bitmap . get Width ( ) * bitmap . get Height ( ) * NUM_ ; Byte Array Output Stream out = new Byte Array Output Stream ( size ) ; try { bitmap . compress ( Bitmap . Compress Format . PNG , NUM_ , out ) ; out . flush ( ) ; out . close ( ) ; return out . to Byte Array ( ) ; } catch ( IO Exception e ) { Log . w ( TAG , STR_ ) ; return null ; } }
long write ( Output Stream out ) throws IO Exception { if ( content Type . equals ( STR_ ) ) { out = new Mac Binary Decoder Output Stream ( out ) ; } long size = NUM_ ; int read ; byte [ ] buf = new byte [ NUM_ * NUM_ ] ; while ( ( read = part Input . read ( buf ) ) != - NUM_ ) { out . write ( buf , NUM_ , read ) ; size += read ; } return size ; }
@ Override public boolean input ( Instance instance ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = false ; } Instances output Format = output Format Peek ( ) ; double [ ] vals = new double [ output Format . num Attributes ( ) ] ; boolean in Range = false ; double last Val = Utils . missing Value ( ) ; int i , j ; for ( i = NUM_ , j = NUM_ ; j < output Format . num Attributes ( ) ; i ++ ) { if ( m Delta Cols . is In Range ( i ) && ( i != instance . class Index ( ) ) ) { if ( in Range ) { if ( Utils . is Missing Value ( last Val ) || instance . is Missing ( i ) ) { vals [ j ++ ] = Utils . missing Value ( ) ; } else { vals [ j ++ ] = instance . value ( i ) - last Val ; } } else { in Range = true ; } last Val = instance . value ( i ) ; } else { vals [ j ++ ] = instance . value ( i ) ; } } Instance inst = null ; if ( instance instanceof Sparse Instance ) { inst = new Sparse Instance ( instance . weight ( ) , vals ) ; } else { inst = new Dense Instance ( instance . weight ( ) , vals ) ; } inst . set Dataset ( get Output Format ( ) ) ; copy Values ( inst , false , instance . dataset ( ) , get Output Format ( ) ) ; inst . set Dataset ( get Output Format ( ) ) ; push ( inst ) ; return true ; }
private List < I Runtime Classpath Entry > dependencies For Project ( I Java Project project ) throws Core Exception { Array List < I Runtime Classpath Entry > out = new Array List < I Runtime Classpath Entry > ( ) ; String [ ] deps = Java Runtime . compute Default Runtime Class Path ( project ) ; for ( String dep : deps ) { I Runtime Classpath Entry cp Entry = Java Runtime . new Archive Runtime Classpath Entry ( new Path ( dep ) ) ; out . add ( cp Entry ) ; } return out ; }
private View create Custom View Internal ( View parent , View view , String name , Context view Context , Attribute Set attrs ) throws Exception { if ( view == null && name . index Of ( STR_ ) > - NUM_ ) { if ( m Constructor Args == null ) m Constructor Args = Reflection Utils . get Field ( Layout Inflater . class , STR_ ) ; final Object [ ] m Constructor Args Arr = ( Object [ ] ) Reflection Utils . get Value ( m Constructor Args , this ) ; final Object last Context = m Constructor Args Arr [ NUM_ ] ; m Constructor Args Arr [ NUM_ ] = view Context ; Reflection Utils . set Value ( m Constructor Args , this , m Constructor Args Arr ) ; try { view = create View ( name , null , attrs ) ; } catch ( Class Not Found Exception ignored ) { } finally { m Constructor Args Arr [ NUM_ ] = last Context ; Reflection Utils . set Value ( m Constructor Args , this , m Constructor Args Arr ) ; } } return view ; }
protected final void match Token ( String match Str , int i ) throws IO Exception , Json Parse Exception { final int len = match Str . length ( ) ; do { if ( input Ptr >= input End ) { if ( ! load More ( ) ) { report Invalid EOF In Value ( ) ; } } if ( input Buffer [ input Ptr ] != match Str . char At ( i ) ) { report Invalid Token ( match Str . substring ( NUM_ , i ) , STR_ ) ; } ++ input Ptr ; } while ( ++ i < len ) ; if ( input Ptr >= input End ) { if ( ! load More ( ) ) { return ; } } char c = input Buffer [ input Ptr ] ; if ( c < STR_ || c == STR_ || c == STR_ ) { return ; } if ( Character . is Java Identifier Part ( c ) ) { report Invalid Token ( match Str . substring ( NUM_ , i ) , STR_ ) ; } return ; }
@ Rpc Method public void create Disks ( String reservation , Async Method Callback < Host . Async Client . create disks call > handler ) throws Rpc Exception { ensure Client ( ) ; Create Disks Request create Disks Request = new Create Disks Request ( reservation ) ; client Proxy . set Timeout ( CREATE DISKS TIMEOUT MS ) ; logger . info ( STR_ , reservation , get Host Ip ( ) , create Disks Request ) ; try { client Proxy . create disks ( create Disks Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
private static void ensure Packages ( File pkg ) throws IO Exception { if ( ! pkg . exists ( ) && ! pkg . mkdirs ( ) ) throw new IO Exception ( STR_ + pkg ) ; }
protected static void write Version Attribute ( String namespace , String att Name , String att Value , XML Stream Writer xml Writer ) throws XML Stream Exception { if ( namespace . length ( ) == NUM_ ) { xml Writer . write Attribute ( att Name , att Value ) ; } else { reg Prefix ( xml Writer , namespace ) ; xml Writer . write Attribute ( namespace , att Name , att Value ) ; } }
public void take Values From ( Bean < T > bean ) { for ( Property Descriptor property : get Properties ( ) ) { set Value ( property , bean . get Value ( property . get Name ( ) ) ) ; } }
Mutable Attribute Set current Text Attributes ( ) { Mutable Attribute Set attributes = new Simple Attribute Set ( character Attributes ) ; Integer fontnum ; Integer state Item ; fontnum = ( Integer ) parser State . get ( STR_ ) ; String font Family ; if ( fontnum != null ) font Family = font Table . get ( fontnum ) ; else font Family = null ; if ( font Family != null ) Style Constants . set Font Family ( attributes , font Family ) ; else attributes . remove Attribute ( Style Constants . Font Family ) ; if ( color Table != null ) { state Item = ( Integer ) parser State . get ( STR_ ) ; if ( state Item != null ) { Color fg = color Table [ state Item . int Value ( ) ] ; Style Constants . set Foreground ( attributes , fg ) ; } else { attributes . remove Attribute ( Style Constants . Foreground ) ; } } if ( color Table != null ) { state Item = ( Integer ) parser State . get ( STR_ ) ; if ( state Item != null ) { Color bg = color Table [ state Item . int Value ( ) ] ; attributes . add Attribute ( Style Constants . Background , bg ) ; } else { attributes . remove Attribute ( Style Constants . Background ) ; } } Style character Style = ( Style ) parser State . get ( STR_ ) ; if ( character Style != null ) attributes . set Resolve Parent ( character Style ) ; return attributes ; }
public void unlock Portal ( final int ID ) { if ( ! unlocked Portals . contains ( ID ) ) { unlocked Portals . add ( ID ) ; logger . debug ( STR_ + Integer . to String ( ID ) + STR_ + get Name ( ) + STR_ ) ; } }
protected void write Nothing And Flush ( ) throws IO Exception { fos . write Int ( NUM_ ) ; fos . flush ( ) ; }
@ Override public void item State Changed ( Item Event ie ) { Card Layout cl = ( Card Layout ) ( settings Container . get Layout ( ) ) ; cl . show ( settings Container , ( String ) ie . get Item ( ) ) ; }
private static String [ ] tidy Options Array ( String [ ] options ) { if ( options == null || options . length < NUM_ ) { return options ; } Set < String > parsed Options = new Hash Set < String > ( ) ; for ( String options Array Item : options ) { String [ ] options Array Items = options Array Item . split ( STR_ ) ; for ( String option : options Array Items ) { if ( option != null && ! option . equals ( STR_ ) ) { parsed Options . add ( option ) ; } } } return parsed Options . to Array ( new String [ parsed Options . size ( ) ] ) ; }
public final int parse ( String str , T udata ) { return parse ( str . to Char Array ( ) , udata ) ; }
public static boolean does Command Require Security Encapsulation ( Byte command Byte ) { return REQUIRED ENCAPSULATION LIST . contains ( command Byte ) ; }
public Shape Tile Box surrounding box ( ) { if ( is clear ( ) ) return null ; int llx = Integer . MAX VALUE ; int lly = Integer . MAX VALUE ; int urx = Integer . MIN VALUE ; int ury = Integer . MIN VALUE ; for ( int layer idx = NUM_ ; layer idx < layer count ; ++ layer idx ) { Octagon Mutable curr = octa arr [ layer idx ] ; llx = Math . min ( llx , ( int ) Math . floor ( curr . lx ) ) ; lly = Math . min ( lly , ( int ) Math . floor ( curr . ly ) ) ; urx = Math . max ( urx , ( int ) Math . ceil ( curr . rx ) ) ; ury = Math . max ( ury , ( int ) Math . ceil ( curr . uy ) ) ; } if ( llx > urx || lly > ury ) { return Shape Tile Box . EMPTY ; } return new Shape Tile Box ( llx , lly , urx , ury ) ; }
public boolean is Valid ( ) { return valid && ! s . is Closed ( ) && ! s . is Input Shutdown ( ) && ! s . is Output Shutdown ( ) ; }
@ Override public String generate Label ( XY Dataset dataset , int series , int item ) { return generate Label String ( dataset , series , item ) ; }
public Edge Effect ( Context context ) { m Paint . set Anti Alias ( true ) ; final int theme Color = Color . RED ; m Paint . set Color ( ( theme Color & NUM_ ) | NUM_ ) ; m Paint . set Style ( Paint . Style . FILL ) ; m Paint . set Xfermode ( new Porter Duff Xfermode ( Porter Duff . Mode . SRC ATOP ) ) ; m Interpolator = new Decelerate Interpolator ( ) ; }
public void filter ( Geometry g ) { if ( g instanceof Polygon ) { Polygon poly = ( Polygon ) g ; linework . add ( poly . get Exterior Ring ( ) ) ; for ( int i = NUM_ ; i < poly . get Num Interior Ring ( ) ; i ++ ) { linework . add ( poly . get Interior Ring N ( i ) ) ; } } }
private static Class register Type Mapping ( RPC Server server , Class clazz ) { java . lang . reflect . Method [ ] methods = clazz . get Methods ( ) ; java . lang . reflect . Method method ; Class [ ] params ; for ( int i = NUM_ ; i < methods . length ; i ++ ) { method = methods [ i ] ; if ( method . get Declaring Class ( ) == clazz ) { register Type Mapping ( server , method . get Return Type ( ) ) ; params = method . get Parameter Types ( ) ; for ( int y = NUM_ ; y < params . length ; y ++ ) { register Type Mapping ( server , params [ y ] ) ; } } } return clazz ; }
synchronized void notify Client Handler Deleted ( Client Handler h ) { client Handler Vector . remove Element ( h ) ; notify All ( ) ; }
public static void reconcile Export Groups HL Us ( Db Client db Client , Export Group export Group ) { List < String > eg Volumes Without HL Us = find Volumes Without HL Us ( export Group ) ; if ( ! eg Volumes Without HL Us . is Empty ( ) ) { for ( Export Mask this Mask : Export Mask Utils . get Export Masks ( db Client , export Group ) ) { Iterator < String > volume Iter = eg Volumes Without HL Us . iterator ( ) ; while ( volume Iter . has Next ( ) ) { URI volume URI = URI . create ( volume Iter . next ( ) ) ; if ( this Mask . has Volume ( volume URI ) ) { String hlu = this Mask . return Volume HLU ( volume URI ) ; if ( hlu != Export Group . LUN UNASSIGNED DECIMAL STR ) { log . info ( String . format ( STR_ , export Group . get Label ( ) , export Group . get Id ( ) , volume URI , hlu ) ) ; export Group . add Volume ( volume URI , Integer . value Of ( hlu ) ) ; volume Iter . remove ( ) ; } } } } } }
@ Override public void flush ( ) throws IO Exception { for ( Output Stream stream : outs ) stream . flush ( ) ; }
public static String read String ( Data Input Stream in ) throws IO Exception { int llength = in . read Int ( ) ; if ( llength == - NUM_ ) return null ; byte a [ ] = new byte [ llength ] ; in . read Fully ( a , NUM_ , llength ) ; return new String ( a ) ; }
@ Override public void perform Backup ( Parcel File Descriptor old State , Backup Data Output data , Parcel File Descriptor new State ) { if ( VERBOSE ) Log . v ( TAG , STR_ ) ; Backup Protos . Journal in = read Journal ( old State ) ; if ( ! launcher Is Ready ( ) ) { data Changed ( ) ; write Journal ( new State , in ) ; return ; } if ( m Device Profile Data == null ) { Launcher App State app = Launcher App State . get Instance ( ) ; m Idp = app . get Invariant Device Profile ( ) ; m Device Profile Data = init Device Profile Data ( m Idp ) ; m Icon Cache = app . get Icon Cache ( ) ; } Log . v ( TAG , STR_ + in . t ) ; m Keys . clear ( ) ; apply Journal ( in ) ; long new Backup Time = System . current Time Millis ( ) ; m Backup Data Was Updated = false ; try { backup Favorites ( data ) ; backup Screens ( data ) ; backup Icons ( data ) ; backup Widgets ( data ) ; Hash Set < String > valid Keys = new Hash Set < String > ( ) ; for ( Backup Protos . Key key : m Keys ) { valid Keys . add ( key To Backup Key ( key ) ) ; } m Existing Keys . remove All ( valid Keys ) ; for ( String deleted : m Existing Keys ) { if ( VERBOSE ) Log . v ( TAG , STR_ + deleted ) ; data . write Entity Header ( deleted , - NUM_ ) ; m Backup Data Was Updated = true ; } m Existing Keys . clear ( ) ; if ( ! m Backup Data Was Updated ) { m Backup Data Was Updated = ( in . profile == null ) || ! Arrays . equals ( Device Profie Data . to Byte Array ( in . profile ) , Device Profie Data . to Byte Array ( m Device Profile Data ) ) || ( in . backup Version != BACKUP VERSION ) || ( in . app Version != get App Version ( ) ) ; } if ( m Backup Data Was Updated ) { m Last Backup Restore Time = new Backup Time ; Backup Protos . Journal state = get Current State Journal ( ) ; write Row To Backup ( JOURNAL KEY , state , data ) ; } else { if ( DEBUG ) Log . d ( TAG , STR_ ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STR_ , e ) ; } write New State Description ( new State ) ; }
private boolean write Request Headers Eagerly ( ) { return caller Writes Request Body && permits Request Body ( network Request ) && request Body Out == null ; }
public void add Load Constant ( int k ) { switch ( k ) { case NUM_ : add ( Byte Code . ICONST 0 ) ; break ; case NUM_ : add ( Byte Code . ICONST 1 ) ; break ; case NUM_ : add ( Byte Code . ICONST 2 ) ; break ; case NUM_ : add ( Byte Code . ICONST 3 ) ; break ; case NUM_ : add ( Byte Code . ICONST 4 ) ; break ; case NUM_ : add ( Byte Code . ICONST 5 ) ; break ; default : add ( Byte Code . LDC , its Constant Pool . add Constant ( k ) ) ; break ; } }
@ Deprecated static public LIUSB Server Adapter instance ( ) { if ( m Instance == null ) { m Instance = new LIUSB Server Adapter ( ) ; } return m Instance ; }
final Work Queue register Worker ( Fork Join Worker Thread wt ) { Thread . Uncaught Exception Handler handler ; Work Queue [ ] ws ; int s , ps ; wt . set Daemon ( true ) ; if ( ( handler = ueh ) != null ) wt . set Uncaught Exception Handler ( handler ) ; do { } while ( ! U . compare And Swap Int ( this , INDEXSEED , s = index Seed , s += SEED INCREMENT ) || s == NUM_ ) ; Work Queue w = new Work Queue ( this , wt , config > > > NUM_ , s ) ; if ( ( ( ps = plock ) & PL LOCK ) != NUM_ || ! U . compare And Swap Int ( this , PLOCK , ps , ps += PL LOCK ) ) ps = acquire Plock ( ) ; int nps = ( ps & SHUTDOWN ) | ( ( ps + PL LOCK ) & ~ SHUTDOWN ) ; try { if ( ( ws = work Queues ) != null ) { int n = ws . length , m = n - NUM_ ; int r = ( s << NUM_ ) | NUM_ ; if ( ws [ r &= m ] != null ) { int probes = NUM_ ; int step = ( n <= NUM_ ) ? NUM_ : ( ( n > > > NUM_ ) & EVENMASK ) + NUM_ ; while ( ws [ r = ( r + step ) & m ] != null ) { if ( ++ probes >= n ) { work Queues = ws = Arrays . copy Of ( ws , n <<= NUM_ ) ; m = n - NUM_ ; probes = NUM_ ; } } } w . event Count = w . pool Index = r ; ws [ r ] = w ; } } finally { if ( ! U . compare And Swap Int ( this , PLOCK , ps , nps ) ) release Plock ( nps ) ; } wt . set Name ( worker Name Prefix . concat ( Integer . to String ( w . pool Index ) ) ) ; return w ; }
private static Map < String , Dimension Field > build Name To Dimension Field ( @ Not Null Set < Dimension Field > dimension Fields ) { Map < String , Dimension Field > name To Dimension Field = new Hash Map < > ( dimension Fields . size ( ) ) ; for ( Dimension Field dimension Field : dimension Fields ) { name To Dimension Field . put ( dimension Field . get Name ( ) , dimension Field ) ; } return name To Dimension Field ; }
protected String parse Resolvable Prop String ( String unparsed String , Property Resolver resolver , Set < String > visited Replaceable Strings ) { String Builder buf = new String Builder ( unparsed String ) ; int prefix Index = buf . index Of ( property Prefix ) ; while ( prefix Index != - NUM_ ) { int suffix Index = find Suffix Index ( buf , prefix Index + property Prefix . length ( ) ) ; if ( suffix Index != - NUM_ ) { String replaceable String = buf . substring ( prefix Index + property Prefix . length ( ) , suffix Index ) ; if ( ! visited Replaceable Strings . add ( replaceable String ) ) { logger . info ( Localized Message . create ( Localized Strings . Cache Xml Property Resolver Helper SOME UNRESOLVED STRING REPLACED CIRCULAR ERROR 0 , replaceable String ) ) ; throw new Illegal Argument Exception ( STR_ + replaceable String + STR_ ) ; } replaceable String = parse Resolvable Prop String ( replaceable String , resolver , visited Replaceable Strings ) ; String replacement = resolver . resolve Replace String ( replaceable String ) ; if ( replacement != null ) { replacement = parse Resolvable Prop String ( replacement , resolver , visited Replaceable Strings ) ; buf . replace ( prefix Index , suffix Index + property Suffix . length ( ) , replacement ) ; prefix Index = buf . index Of ( property Prefix , prefix Index + replacement . length ( ) ) ; } else if ( resolver . is Ignore Unresolved Properties ( ) ) { prefix Index = buf . index Of ( property Prefix , suffix Index + property Suffix . length ( ) ) ; } else { throw new Illegal Argument Exception ( STR_ + replaceable String ) ; } visited Replaceable Strings . remove ( replaceable String ) ; } else { prefix Index = - NUM_ ; } } return buf . to String ( ) ; }
private static void load Candidates ( Profiler Section section ) { section . start ( STR_ ) ; File [ ] search dirs = new File [ ] { new File ( Toast Bootstrap . toast Home , STR_ ) } ; File [ ] lib dirs = new File [ NUM_ ] ; if ( ! is Core Phase ) { search dirs = Storage . USB Module ( STR_ ) ; lib dirs = Storage . USB Module ( STR_ ) ; } for ( File dir : lib dirs ) { dir . mkdirs ( ) ; search libs ( dir ) ; } for ( File dir : search dirs ) { dir . mkdirs ( ) ; search ( dir ) ; } section . stop ( STR_ ) ; }
private String make Next Link ( int skip ) throws O Data Exception { URI self Lnk = get Service Root ( ) ; URI Builder ub = new URI Builder ( self Lnk ) ; ub . set Parameter ( STR_ , String . value Of ( skip ) ) ; return ub . to String ( ) ; }
protected void make Widgets ( ) { String loc Text ; Grid Bag Layout gridbag = new Grid Bag Layout ( ) ; Grid Bag Constraints c = new Grid Bag Constraints ( ) ; Insets left Insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; Insets right Insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; set Layout ( gridbag ) ; loc Text = i 18 n . get ( MGRS Coord Panel . class , STR_ , STR_ ) ; set Border ( new Titled Border ( new Etched Border ( ) , loc Text ) ) ; loc Text = i 18 n . get ( MGRS Coord Panel . class , STR_ , STR_ ) ; J Label mgrs Label = new J Label ( loc Text ) ; c . gridx = NUM_ ; c . fill = Grid Bag Constraints . NONE ; c . weightx = NUM_ ; c . insets = left Insets ; gridbag . set Constraints ( mgrs Label , c ) ; add ( mgrs Label ) ; mgrs = new J Text Field ( NUM_ ) ; c . gridx = NUM_ ; c . fill = Grid Bag Constraints . HORIZONTAL ; c . weightx = NUM_ ; c . insets = right Insets ; gridbag . set Constraints ( mgrs , c ) ; add ( mgrs ) ; }
public static void cleanup Paragraphs ( RT Edit Text editor , Effect ... exclude ) { cleanup Paragraphs ( editor , Effects . ALIGNMENT , exclude ) ; cleanup Paragraphs ( editor , Effects . INDENTATION , exclude ) ; cleanup Paragraphs ( editor , Effects . BULLET , exclude ) ; cleanup Paragraphs ( editor , Effects . NUMBER , exclude ) ; }
public Id < Dg Commodity > convert Link To Link Pair 2 Commodity Id ( Id < Link > from Link Id , Id < Link > to Link Id ) { String id String = from Link Id + STR_ + to Link Id ; return id Pool . create Id ( id String , Dg Commodity . class ) ; }
public static String create Vlt File Path ( Shell shell , String text , int style , String default File Name ) { return create File Path ( shell , text , Preference Constants . DEFAULT FOLDER VLT , vlt Extensions , style , default File Name ) ; }
public double local Score ( int i , int [ ] parents ) { double sum = NUM_ ; for ( B Deu Score score : scores ) { sum += score . local Score ( i , parents ) ; } return sum / scores . size ( ) ; }
public String resolve URL ( String sync Url , String registration Url ) { if ( String Utils . is Blank ( sync Url ) || sync Url . starts With ( Constants . PROTOCOL NONE ) ) { log . debug ( STR_ ) ; return registration Url ; } try { URI uri = new URI ( sync Url ) ; for ( I Sync Url Extension handler : extension Service . get Extension Point List ( I Sync Url Extension . class ) ) { sync Url = handler . resolve Url ( uri ) ; uri = new URI ( sync Url ) ; } } catch ( URI Syntax Exception e ) { log . error ( e . get Message ( ) , e ) ; } return sync Url ; }
public void remove ( Connection Class State Change Listener listener ) { if ( listener != null ) { m Listener List . remove ( listener ) ; } }
public static byte [ ] decrypt Key ( byte [ ] password , byte [ ] encrypted Key ) { try { Cipher c = Cipher . get Instance ( ENCRYPT KEY ALGORITHM ) ; c . init ( Cipher . DECRYPT MODE , new Secret Key Spec ( password , SECRET KEY ALGORITHM ) , CBC SALT KEY ) ; return c . do Final ( encrypted Key ) ; } catch ( Exception e ) { throw new Illegal State Exception ( ENCRYPT KEY ALGORITHM + STR_ , e ) ; } }
private Object handle Rule With Invalid Tags ( final Map < Long , Object > p Input Params ) throws Rule Evaluation Exception { final Object result = try To Ignore Invalid Tags ( p Input Params ) ; if ( is Result Invalid ( result ) ) { throw new Rule Evaluation Exception ( STR_ ) ; } return result ; }
private void copy Raw To File ( int raw Res Id , File out File ) throws Not Found Exception { Resources res = m Context . get Resources ( ) ; Input Stream is = null ; try { is = res . open Raw Resource ( raw Res Id ) ; } catch ( Not Found Exception e ) { Log . i ( LOG TAG , STR_ + raw Res Id ) ; throw e ; } File Utils . set Permissions ( out File . get Path ( ) , File Utils . S IRWXU | File Utils . S IRWXG | File Utils . S IRWXO , - NUM_ , - NUM_ ) ; assert True ( File Utils . copy To File ( is , out File ) ) ; File Utils . set Permissions ( out File . get Path ( ) , File Utils . S IRWXU | File Utils . S IRWXG | File Utils . S IRWXO , - NUM_ , - NUM_ ) ; }
public final void delete Cert ( final String key Id ) throws IO Exception { Files . delete ( get Cert Path ( key Id ) ) ; }
private String indent String ( ) { String Buffer sb = new String Buffer ( ) ; for ( int i = NUM_ ; i < indent ; ++ i ) { sb . append ( STR_ ) ; } return sb . to String ( ) ; }
public static < T extends Object & Comparable < ? super T > > T max ( Collection < ? extends T > collection ) { Iterator < ? extends T > it = collection . iterator ( ) ; T max = it . next ( ) ; while ( it . has Next ( ) ) { T next = it . next ( ) ; if ( max . compare To ( next ) < NUM_ ) { max = next ; } } return max ; }
@ Override protected Map < String , Object > generate Config ( Http Servlet Request request , Http Servlet Response response , SSO Token sso Token ) throws Authentication Exception { try { final String token Idle Time = sso Token . get Property ( Jwt Session Module . TOKEN IDLE TIME IN MINUTES CLAIM KEY ) ; final String max Token Life = sso Token . get Property ( Jwt Session Module . MAX TOKEN LIFE IN MINUTES KEY ) ; final boolean enforce Client IP = Boolean . parse Boolean ( sso Token . get Property ( ENFORCE CLIENT IP SETTING KEY ) ) ; final String realm = sso Token . get Property ( SSO TOKEN ORGANIZATION PROPERTY KEY ) ; boolean secure Cookie = Boolean . parse Boolean ( sso Token . get Property ( SECURE COOKIE KEY ) ) ; boolean http Only Cookie = Boolean . parse Boolean ( sso Token . get Property ( HTTP ONLY COOKIE KEY ) ) ; String cookie Name = sso Token . get Property ( COOKIE NAME KEY ) ; String cookie Domains String = sso Token . get Property ( COOKIE DOMAINS KEY ) ; Collection < String > cookie Domains ; if ( cookie Domains String . is Empty ( ) ) { cookie Domains = Collections . singleton ( null ) ; } else { cookie Domains = Arrays . as List ( cookie Domains String . split ( STR_ ) ) ; } final String hmac Key = Access Controller . do Privileged ( new Decode Action ( sso Token . get Property ( HMAC KEY ) ) ) ; sso Token . set Property ( HMAC KEY , STR_ ) ; return persistent Cookie Module Wrapper . generate Config ( token Idle Time , max Token Life , enforce Client IP , realm , secure Cookie , http Only Cookie , cookie Name , cookie Domains , hmac Key ) ; } catch ( SSO Exception | SMS Exception e ) { DEBUG . error ( STR_ , e ) ; throw new Authentication Exception ( e . get Localized Message ( ) ) ; } }
public Respoke Client create Client ( Context app Context ) { context = app Context ; Respoke Client new Client = new Respoke Client ( ) ; instances . add ( new Client ) ; return new Client ; }
private void start Item List Item ( String Builder result , String root Id , String item Id ) { result . append ( STR_ ) ; result . append ( STR_ + item Id + STR_ + root Id + STR_ + item Id + STR_ ) ; }
public Data File Footer read Data File Footer ( String file Path , long block Offset , long block Length ) throws IO Exception { Data File Footer data File Footer = new Data File Footer ( ) ; File Holder file Reader = null ; try { long complete Block Length = block Offset + block Length ; long footer Pointer = complete Block Length - NUM_ ; file Reader = File Factory . get File Holder ( File Factory . get File Type ( file Path ) ) ; long actual Footer Offset = file Reader . read Long ( file Path , footer Pointer ) ; Carbon Footer Reader reader = new Carbon Footer Reader ( file Path , actual Footer Offset ) ; File Footer footer = reader . read Footer ( ) ; data File Footer . set Version Id ( footer . get Version ( ) ) ; data File Footer . set Number Of Rows ( footer . get Num rows ( ) ) ; data File Footer . set Segment Info ( get Segment Info ( footer . get Segment info ( ) ) ) ; List < Column Schema > column Schema List = new Array List < Column Schema > ( ) ; List < org . apache . carbondata . format . Column Schema > table columns = footer . get Table columns ( ) ; for ( int i = NUM_ ; i < table columns . size ( ) ; i ++ ) { column Schema List . add ( thrift Column Schmea To Wrapper Column Schema ( table columns . get ( i ) ) ) ; } data File Footer . set Column In Table ( column Schema List ) ; List < org . apache . carbondata . format . Blocklet Index > leaf node indices Thrift = footer . get Blocklet index list ( ) ; List < Blocklet Index > blocklet Index List = new Array List < Blocklet Index > ( ) ; for ( int i = NUM_ ; i < leaf node indices Thrift . size ( ) ; i ++ ) { Blocklet Index blocklet Index = get Blocklet Index ( leaf node indices Thrift . get ( i ) ) ; blocklet Index List . add ( blocklet Index ) ; } List < org . apache . carbondata . format . Blocklet Info > leaf node infos Thrift = footer . get Blocklet info list ( ) ; List < Blocklet Info > blocklet Info List = new Array List < Blocklet Info > ( ) ; for ( int i = NUM_ ; i < leaf node infos Thrift . size ( ) ; i ++ ) { Blocklet Info blocklet Info = get Blocklet Info ( leaf node infos Thrift . get ( i ) ) ; blocklet Info . set Blocklet Index ( blocklet Index List . get ( i ) ) ; blocklet Info List . add ( blocklet Info ) ; } data File Footer . set Blocklet List ( blocklet Info List ) ; data File Footer . set Blocklet Index ( get Blocklet Index For Data File Footer ( blocklet Index List ) ) ; } finally { if ( null != file Reader ) { file Reader . finish ( ) ; } } return data File Footer ; }
public void store Domain For ( Variable var , Domain domain ) { if ( ! affected Variables . contains ( var ) ) { saved Domains . add ( new Pair < Variable , Domain > ( var , domain ) ) ; affected Variables . add ( var ) ; } }
private void adjust For Top Fading Edge ( View child In Selected Row , int top Selection Pixel , int bottom Selection Pixel ) { if ( child In Selected Row . get Top ( ) < top Selection Pixel ) { int space Above = top Selection Pixel - child In Selected Row . get Top ( ) ; int space Below = bottom Selection Pixel - child In Selected Row . get Bottom ( ) ; int offset = Math . min ( space Above , space Below ) ; offset Children Top And Bottom ( offset ) ; } }
public void add Movement Listener ( final Movement Listener listener ) { movement Listeners . add ( listener ) ; }
@ Override public int compare ( final Semi Cluster o 1 , final Semi Cluster o 2 ) { if ( o 1 . score < o 2 . score ) { return - NUM_ ; } else if ( o 1 . score > o 2 . score ) { return NUM_ ; } else { if ( ! o 1 . equals ( o 2 ) ) { return NUM_ ; } } return NUM_ ; }
public Tab Uma ( Tab tab , Tab Creation State creation State , Tab Model model ) { m Tab = tab ; m Tab Creation State = creation State ; m Tab Model = model ; m Last Tab State Change Millis = System . current Time Millis ( ) ; if ( m Tab Creation State == Tab Creation State . LIVE IN FOREGROUND || m Tab Creation State == Tab Creation State . FROZEN ON RESTORE ) { update Tab State ( TAB STATE ACTIVE ) ; } else if ( m Tab Creation State == Tab Creation State . LIVE IN BACKGROUND || m Tab Creation State == Tab Creation State . FROZEN FOR LAZY LOAD ) { update Tab State ( TAB STATE INACTIVE ) ; } }
@ Override public boolean check ( final Certificate Token certificate Token ) { if ( certificate Token == null ) { throw new Null Pointer Exception ( ) ; } List < String > context Policy Identifiers = DSSASN 1 Utils . get Policy Identifiers ( certificate Token ) ; return context Policy Identifiers . contains ( policy Oid ) ; }
protected void calc Angular Bounds ( Node Item r ) { if ( m prev Root == null || ! m prev Root . is Valid ( ) || r == m prev Root ) { m prev Root = r ; return ; } Node Item p = m prev Root ; while ( true ) { Node Item pp = ( Node Item ) p . get Parent ( ) ; if ( pp == r ) { break ; } else if ( pp == null ) { m prev Root = r ; return ; } p = pp ; } double dt = NUM_ ; Iterator iter = sorted Children ( r ) ; while ( iter . has Next ( ) ) { Node n = ( Node ) iter . next ( ) ; if ( n == p ) break ; dt += ( ( Params ) n . get ( PARAMS ) ) . width ; } double rw = ( ( Params ) r . get ( PARAMS ) ) . width ; double pw = ( ( Params ) p . get ( PARAMS ) ) . width ; dt = - Math Lib . TWO PI * ( dt + pw / NUM_ ) / rw ; m theta 1 = dt + Math . atan 2 ( p . get Y ( ) - r . get Y ( ) , p . get X ( ) - r . get X ( ) ) ; m theta 2 = m theta 1 + Math Lib . TWO PI ; m prev Root = r ; }
private Column Error make Duplicate Name Error ( Entry < String , List < Integer > > name Entry ) { String duplicaten Name Message = I 18 N . get GUI Label ( STR_ , name Entry . get Key ( ) , list To String ( name Entry . get Value ( ) ) ) ; return new Column Error ( name Entry . get Value ( ) , name Entry . get Key ( ) , duplicaten Name Message ) ; }
public void clear Partitions ( ) { if ( m Size == NUM_ ) { return ; } for ( int i = NUM_ ; i < m Size ; i ++ ) { List < T > list = m Partitions [ i ] . list ; if ( list != null ) { list . clear ( ) ; m Partitions [ i ] . list = list = null ; } } m Size = NUM_ ; invalidate ( ) ; notify Data Set Changed ( ) ; }
@ Override public final K acquire ( ) { K ctx = null ; final Reference < K > ref = ctx TL . get ( ) ; if ( ref != null ) { ctx = ref . get ( ) ; } if ( ctx == null ) { ctx = new Context ( ) ; ctx TL . set ( get Or Create Reference ( ctx ) ) ; } if ( ctx . usage == USAGE TL INACTIVE ) { ctx . usage = USAGE TL IN USE ; } else { ctx = ctx Provider CLQ . acquire ( ) ; } return ctx ; }
@ Override public boolean create From ( final I Scope scope , final List < Map < String , Object > > inits , final Integer max , final Object input , final Arguments init , final Create Statement statement ) { final Gama Grid File file = ( Gama Grid File ) input ; final int num = max == null ? file . length ( scope ) : Cmn Fast Math . min ( file . length ( scope ) , max ) ; for ( int i = NUM_ ; i < num ; i ++ ) { final I Shape g = file . get ( scope , i ) ; final Map map = g . get Or Create Attributes ( ) ; map . put ( I Keyword . SHAPE , g ) ; statement . fill With User Init ( scope , map ) ; inits . add ( map ) ; } return true ; }
public double find Minimum ( Multivariate Function f , double [ ] xvec , int fx Frac Digits , int x Frac Digits , Minimiser Monitor monitor ) { double tolfx = Math . pow ( NUM_ , - NUM_ - fx Frac Digits ) ; double tolx = Math . pow ( NUM_ , - NUM_ - x Frac Digits ) ; optimize ( f , xvec , tolfx , tolx , monitor ) ; double m = Math . pow ( NUM_ , x Frac Digits ) ; for ( int i = NUM_ ; i < xvec . length ; i ++ ) { xvec [ i ] = Math . round ( xvec [ i ] * m ) / m ; } return Math . round ( f . evaluate ( xvec ) * m ) / m ; }
public void index ( Iterator tuples , String field ) { while ( tuples . has Next ( ) ) { Tuple t = ( Tuple ) tuples . next ( ) ; index ( t , field ) ; } }
public void start Value Scope ( ) { f Values Count = NUM_ ; for ( int i = NUM_ ; i < f Field Count ; i ++ ) { f Local Values [ i ] = null ; f Local Value Types [ i ] = NUM_ ; f Local Item Value Types [ i ] = null ; } }
@ Suppress Warnings ( STR_ ) public static final int convert Name To ID ( final String name ) { int id = - NUM_ ; if ( ( name . contains ( STR_ ) ) ) { id = Indexed ; } else if ( ( name . contains ( STR_ ) ) ) { id = Separation ; } else if ( name . contains ( STR_ ) ) { id = Device N ; } else if ( name . contains ( STR_ ) || name . contains ( STR_ ) ) { id = Device CMYK ; } else if ( name . contains ( STR_ ) ) { id = Cal Gray ; } else if ( name . contains ( STR_ ) ) { id = Cal RGB ; } else if ( name . contains ( STR_ ) ) { id = Lab ; } else if ( name . contains ( STR_ ) ) { id = ICC ; } else if ( name . contains ( STR_ ) ) { id = Pattern ; } else if ( name . contains ( STR_ ) || name . contains ( STR_ ) ) { id = Device RGB ; } else if ( name . contains ( STR_ ) || name . index Of ( STR_ ) != - NUM_ ) { id = Device Gray ; } return id ; }
private void draw Arrows ( final Graphics 2 D g 2 d , final int x , final int y , final int width , final int height , final Enum Set < Direction > directions , final Color line Color ) { int arrow Height = NUM_ + NUM_ * ( height / NUM_ - NUM_ ) ; int arrow Width = NUM_ + ( width / NUM_ - NUM_ ) ; if ( directions . contains ( Direction . LEFT ) ) { g 2 d . set Color ( Color . RED ) ; g 2 d . fill Polygon ( new int [ ] { x + NUM_ , x - arrow Width , x + NUM_ } , new int [ ] { y + ( height / NUM_ ) - ( arrow Height / NUM_ ) , y + ( height / NUM_ ) , y + ( height / NUM_ ) + ( arrow Height / NUM_ ) } , NUM_ ) ; g 2 d . set Color ( line Color ) ; g 2 d . draw Polyline ( new int [ ] { x , x - arrow Width , x } , new int [ ] { y + ( height / NUM_ ) - ( arrow Height / NUM_ ) , y + ( height / NUM_ ) , y + ( height / NUM_ ) + ( arrow Height / NUM_ ) } , NUM_ ) ; } if ( directions . contains ( Direction . RIGHT ) ) { g 2 d . set Color ( Color . RED ) ; g 2 d . fill Polygon ( new int [ ] { x + width , x + width + arrow Width , x + width } , new int [ ] { y + ( height / NUM_ ) - ( arrow Height / NUM_ ) , y + ( height / NUM_ ) , y + ( height / NUM_ ) + ( arrow Height / NUM_ ) } , NUM_ ) ; g 2 d . set Color ( line Color ) ; g 2 d . draw Polyline ( new int [ ] { x + width , x + width + arrow Width , x + width } , new int [ ] { y + ( height / NUM_ ) - ( arrow Height / NUM_ ) , y + ( height / NUM_ ) , y + ( height / NUM_ ) + ( arrow Height / NUM_ ) } , NUM_ ) ; } if ( directions . contains ( Direction . UP ) ) { g 2 d . set Color ( Color . RED ) ; g 2 d . fill Polygon ( new int [ ] { x + ( width / NUM_ ) - ( arrow Height / NUM_ ) , x + ( width / NUM_ ) , x + ( width / NUM_ ) + ( arrow Height / NUM_ ) } , new int [ ] { y + NUM_ , y - arrow Width , y + NUM_ } , NUM_ ) ; g 2 d . set Color ( line Color ) ; g 2 d . draw Polyline ( new int [ ] { x + ( width / NUM_ ) - ( arrow Height / NUM_ ) , x + ( width / NUM_ ) , x + ( width / NUM_ ) + ( arrow Height / NUM_ ) } , new int [ ] { y , y - arrow Width , y } , NUM_ ) ; } if ( directions . contains ( Direction . DOWN ) ) { g 2 d . set Color ( Color . RED ) ; g 2 d . fill Polygon ( new int [ ] { x + ( width / NUM_ ) - ( arrow Height / NUM_ ) , x + ( width / NUM_ ) , x + ( width / NUM_ ) + ( arrow Height / NUM_ ) } , new int [ ] { y + height , y + height + arrow Width , y + height } , NUM_ ) ; g 2 d . set Color ( line Color ) ; g 2 d . draw Polyline ( new int [ ] { x + ( width / NUM_ ) - ( arrow Height / NUM_ ) , x + ( width / NUM_ ) , x + ( width / NUM_ ) + ( arrow Height / NUM_ ) } , new int [ ] { y + height , y + height + arrow Width , y + height } , NUM_ ) ; } }
public Scanner Exception ( File file , Error Messages message ) { this ( file , Error Messages . get ( message ) , message , - NUM_ , - NUM_ ) ; }
public static List < double [ ] > bezier Arc ( double x 1 , double y 1 , double x 2 , double y 2 , double start Ang , double extent ) { double tmp ; if ( x 1 > x 2 ) { tmp = x 1 ; x 1 = x 2 ; x 2 = tmp ; } if ( y 2 > y 1 ) { tmp = y 1 ; y 1 = y 2 ; y 2 = tmp ; } double frag Angle ; int Nfrag ; if ( Math . abs ( extent ) <= NUM_ ) { frag Angle = extent ; Nfrag = NUM_ ; } else { Nfrag = ( int ) Math . ceil ( Math . abs ( extent ) / NUM_ ) ; frag Angle = extent / Nfrag ; } double x cen = ( x 1 + x 2 ) / NUM_ ; double y cen = ( y 1 + y 2 ) / NUM_ ; double rx = ( x 2 - x 1 ) / NUM_ ; double ry = ( y 2 - y 1 ) / NUM_ ; double half Ang = ( frag Angle * Math . PI / NUM_ ) ; double kappa = Math . abs ( NUM_ / NUM_ * ( NUM_ - Math . cos ( half Ang ) ) / Math . sin ( half Ang ) ) ; List < double [ ] > point List = new Array List < > ( ) ; for ( int iter = NUM_ ; iter < Nfrag ; ++ iter ) { double theta 0 = ( ( start Ang + iter * frag Angle ) * Math . PI / NUM_ ) ; double theta 1 = ( ( start Ang + ( iter + NUM_ ) * frag Angle ) * Math . PI / NUM_ ) ; double cos 0 = Math . cos ( theta 0 ) ; double cos 1 = Math . cos ( theta 1 ) ; double sin 0 = Math . sin ( theta 0 ) ; double sin 1 = Math . sin ( theta 1 ) ; if ( frag Angle > NUM_ ) { point List . add ( new double [ ] { x cen + rx * cos 0 , y cen - ry * sin 0 , x cen + rx * ( cos 0 - kappa * sin 0 ) , y cen - ry * ( sin 0 + kappa * cos 0 ) , x cen + rx * ( cos 1 + kappa * sin 1 ) , y cen - ry * ( sin 1 - kappa * cos 1 ) , x cen + rx * cos 1 , y cen - ry * sin 1 } ) ; } else { point List . add ( new double [ ] { x cen + rx * cos 0 , y cen - ry * sin 0 , x cen + rx * ( cos 0 + kappa * sin 0 ) , y cen - ry * ( sin 0 - kappa * cos 0 ) , x cen + rx * ( cos 1 - kappa * sin 1 ) , y cen - ry * ( sin 1 + kappa * cos 1 ) , x cen + rx * cos 1 , y cen - ry * sin 1 } ) ; } } return point List ; }
private void extract ( Document source ) { Node node = source . get Document Element ( ) ; if ( node != null ) { offer ( node ) ; extract ( node ) ; } }
@ Override public void write Expression ( Expression old Exp ) { if ( null == old Exp ) { throw new Null Pointer Exception ( ) ; } boolean old Writing Object = writing Object ; writing Object = true ; Object old Value = expression Value ( old Exp ) ; if ( old Value == null || get ( old Value ) != null && ( old Writing Object || old Value . get Class ( ) != String . class ) ) { return ; } if ( ! is Basic Type ( old Value ) || ( ! old Writing Object && old Value . get Class ( ) == String . class ) ) { record Expression ( old Value , old Exp ) ; } if ( check Dead Loop ( old Value ) ) { return ; } super . write Expression ( old Exp ) ; writing Object = old Writing Object ; }
protected void assert Func Equals ( final String ... inputs ) throws Exception { Solr Query Request req = req ( ) ; try { assert Func Equals ( req , inputs ) ; } finally { req . close ( ) ; } }
public Point 2 D translate To True Arena Coords ( Point 2 D point ) { final double dpi Scale Factor = Shoot OFF Controller . get Dpi Scale Factor For Screen ( ) ; final Point 2 D origin = arena Pane . get Arena Screen Origin ( ) ; return new Point 2 D ( origin . get X ( ) + ( point . get X ( ) * dpi Scale Factor ) , origin . get Y ( ) + ( point . get Y ( ) * dpi Scale Factor ) ) ; }
public static double ulp ( double x ) { if ( Double . is Infinite ( x ) ) { return Double . POSITIVE INFINITY ; } return abs ( x - Double . long Bits To Double ( Double . double To Raw Long Bits ( x ) ^ NUM_ ) ) ; }
public void make Class ( String str , boolean caseless ) { for ( int i = NUM_ ; i < str . length ( ) ; ) { int ch = str . code Point At ( i ) ; make Class ( ch , caseless ) ; i += Character . char Count ( ch ) ; } }
public Table Column Manager ( J Table table , boolean menu Popup ) { this . table = table ; set Menu Popup ( menu Popup ) ; table . add Property Change Listener ( this ) ; reset ( ) ; }
public static void put At ( Date self , int field , int value ) { Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( self ) ; put At ( cal , field , value ) ; self . set Time ( cal . get Time In Millis ( ) ) ; }
@ Nullable private boolean should Align Field In Columns ( @ Not Null AST Node child ) { if ( ! my Settings . ALIGN GROUP FIELD DECLARATIONS ) { return false ; } I Element Type child Type = child . get Element Type ( ) ; AST Node previous Node = Formatter Util . get Previous Non Whitespace Sibling ( child ) ; if ( child Type == Java Token Type . IDENTIFIER && ( previous Node == null || previous Node . get Element Type ( ) == Java Token Type . COMMA ) ) { return false ; } return true ; }
public void stub From Method ( Element elt ) { if ( ! ( elt . get Kind ( ) == Element Kind . CONSTRUCTOR || elt . get Kind ( ) == Element Kind . METHOD ) ) { return ; } String new Package = Element Utils . get Verbose Name ( Element Utils . enclosing Package ( elt ) ) ; if ( ! new Package . equals ( STR_ ) ) { current Package = new Package ; current Indention = STR_ ; indent ( ) ; } Executable Element method = ( Executable Element ) elt ; print Method Decl ( method ) ; }
private boolean verify Types For Parent Child Relationship ( String child Type , String parent Type , String child Id , Errors errors ) { if ( child Type . equals ( Constants . notebook ) && ! ( parent Type . equals ( Constants . tableofcontents ) || parent Type . equals ( Constants . notebook ) ) ) { Errors . add ( errors , error Messages . error Invalid Related Type ( child Type , parent Type , child Id ) ) ; return false ; } if ( ( child Type . equals ( Constants . note ) || child Type . equals ( Constants . quotation ) || child Type . equals ( Constants . source ) ) && ! ( parent Type . equals ( Constants . root ) || parent Type . equals ( Constants . note ) || parent Type . equals ( Constants . quotation ) || parent Type . equals ( Constants . source ) ) ) { Errors . add ( errors , error Messages . error Invalid Related Type ( child Type , parent Type , child Id ) ) ; return false ; } return true ; }
void free Read Lock ( ) { synchronized ( READ LOCK ) { is Read Locked = false ; READ LOCK . notify All ( ) ; } }
@ Override public void logout ( Http Servlet Request request , Http Servlet Response response , Authentication authentication ) { String remember Me Cookie = extract Remember Me Cookie ( request ) ; if ( remember Me Cookie != null && remember Me Cookie . length ( ) != NUM_ ) { try { String [ ] cookie Tokens = decode Cookie ( remember Me Cookie ) ; if ( cookie Tokens . length != NUM_ ) { throw new Invalid Cookie Exception ( STR_ + NUM_ + STR_ + Arrays . as List ( cookie Tokens ) + STR_ ) ; } persistent Token Repository . delete By Id ( cookie Tokens [ NUM_ ] ) ; } catch ( Invalid Cookie Exception ice ) { log . info ( STR_ ) ; } catch ( Remember Me Authentication Exception rmae ) { log . debug ( STR_ ) ; } } super . logout ( request , response , authentication ) ; }
public Square ( ) { Byte Buffer bb = Byte Buffer . allocate Direct ( square Coords . length * NUM_ ) ; bb . order ( Byte Order . native Order ( ) ) ; vertex Buffer = bb . as Float Buffer ( ) ; vertex Buffer . put ( square Coords ) ; vertex Buffer . position ( NUM_ ) ; Byte Buffer dlb = Byte Buffer . allocate Direct ( draw Order . length * NUM_ ) ; dlb . order ( Byte Order . native Order ( ) ) ; draw List Buffer = dlb . as Short Buffer ( ) ; draw List Buffer . put ( draw Order ) ; draw List Buffer . position ( NUM_ ) ; }
@ Override public void do Run Keys ( int run ) throws Exception { if ( m Instances == null ) { throw new Exception ( STR_ ) ; } for ( int fold = NUM_ ; fold < m Num Folds ; fold ++ ) { Object [ ] se Key = m Split Evaluator . get Key ( ) ; Object [ ] key = new Object [ se Key . length + NUM_ ] ; key [ NUM_ ] = Utils . back Quote Chars ( m Instances . relation Name ( ) ) ; key [ NUM_ ] = STR_ + run ; key [ NUM_ ] = STR_ + ( fold + NUM_ ) ; System . arraycopy ( se Key , NUM_ , key , NUM_ , se Key . length ) ; if ( m Result Listener . is Result Required ( this , key ) ) { try { m Result Listener . accept Result ( this , key , null ) ; } catch ( Exception ex ) { throw ex ; } } } }
private void update Bounds For Added Item ( Time Series Data Item item ) { Number y N = item . get Value ( ) ; if ( item . get Value ( ) != null ) { double y = y N . double Value ( ) ; this . min Y = min Ignore Na N ( this . min Y , y ) ; this . max Y = max Ignore Na N ( this . max Y , y ) ; } }
public static Bitmap shrink ( Bitmap src , int jpg Compression , long max Size ) { final float factor = NUM_ ; Byte Array Output Stream stream = new Byte Array Output Stream ( ) ; src . compress ( Bitmap . Compress Format . JPEG , jpg Compression , stream ) ; while ( max Size != - NUM_ && stream . size ( ) > max Size ) { int height = ( int ) ( src . get Height ( ) * factor ) ; int width = ( int ) ( src . get Width ( ) * factor ) ; stream . reset ( ) ; src = Bitmap . create Scaled Bitmap ( src , width , height , false ) ; src . compress ( Bitmap . Compress Format . JPEG , NUM_ , stream ) ; } return src ; }
private void update Position Needs ( ) { need Q Bs = NUM_ - team Q Bs . size ( ) ; need R Bs = NUM_ - team R Bs . size ( ) ; need W Rs = NUM_ - team W Rs . size ( ) ; need O Ls = NUM_ - team O Ls . size ( ) ; need Ks = NUM_ - team Ks . size ( ) ; need Ss = NUM_ - team Ss . size ( ) ; need C Bs = NUM_ - team C Bs . size ( ) ; need F 7 s = NUM_ - team F 7 s . size ( ) ; if ( data Adapter Position != null ) { positions = new Array List < String > ( ) ; positions . add ( STR_ + need Q Bs + STR_ ) ; positions . add ( STR_ + need R Bs + STR_ ) ; positions . add ( STR_ + need W Rs + STR_ ) ; positions . add ( STR_ + need O Ls + STR_ ) ; positions . add ( STR_ + need Ks + STR_ ) ; positions . add ( STR_ + need Ss + STR_ ) ; positions . add ( STR_ + need C Bs + STR_ ) ; positions . add ( STR_ + need F 7 s + STR_ ) ; positions . add ( STR_ ) ; data Adapter Position . clear ( ) ; for ( String p : positions ) { data Adapter Position . add ( p ) ; } data Adapter Position . notify Data Set Changed ( ) ; } }
public void select Media Type ( Named Media Type type ) { J Toggle Button media Type Button = buttons Map . get ( type ) ; if ( media Type Button != null ) { media Type Button . do Click ( ) ; } }
public Perf Data Buffer ( Remote Vm rvm , int lvmid ) throws Monitor Exception { this . rvm = rvm ; try { Byte Buffer buffer = Byte Buffer . allocate ( rvm . get Capacity ( ) ) ; sample ( buffer ) ; create Perf Data Buffer ( buffer , lvmid ) ; } catch ( Remote Exception e ) { throw new Monitor Exception ( STR_ + lvmid , e ) ; } }
public boolean update User Acl ( String username , String dbgroupname , boolean visible ) { Connection conn = null ; Prepared Statement stmt = null ; Result Set rs = null ; try { conn = get Connection ( ) ; String sql = STR_ + USERACL TABLENAME + STR_ ; stmt = conn . prepare Statement ( sql ) ; stmt . set String ( NUM_ , username ) ; stmt . set String ( NUM_ , dbgroupname ) ; rs = stmt . execute Query ( ) ; boolean find One = false ; if ( rs != null && rs . next ( ) ) find One = true ; DB Utils . close ( rs ) ; rs = null ; DB Utils . close ( stmt ) ; stmt = null ; if ( find One ) { sql = STR_ + USERACL TABLENAME + STR_ ; stmt = conn . prepare Statement ( sql ) ; stmt . set Int ( NUM_ , visible ? NUM_ : NUM_ ) ; stmt . set String ( NUM_ , username ) ; stmt . set String ( NUM_ , dbgroupname ) ; stmt . execute ( ) ; DB Utils . close ( stmt ) ; stmt = null ; } else { sql = STR_ + USERACL TABLENAME + STR_ ; stmt = conn . prepare Statement ( sql ) ; stmt . set String ( NUM_ , username ) ; stmt . set String ( NUM_ , dbgroupname ) ; stmt . set Int ( NUM_ , visible ? NUM_ : NUM_ ) ; stmt . execute ( ) ; } DB Utils . close ( stmt ) ; stmt = null ; conn . commit ( ) ; return true ; } catch ( Exception ex ) { logger . log ( Level . SEVERE , STR_ , ex ) ; return false ; } finally { DB Utils . close ( rs ) ; DB Utils . close ( stmt ) ; DB Utils . close ( conn ) ; } }
public Properties strip Prefix ( Properties props ) { Properties result = new Properties ( ) ; for ( String name : props . string Property Names ( ) ) { validate Namespaced ( name ) ; String val = props . get Property ( name ) ; name = strip Prefix ( name ) ; result . set Property ( name , val ) ; } return result ; }
public static Catch Table build ( Rop Method method , int [ ] order , Block Addresses addresses ) { int len = order . length ; Basic Block List blocks = method . get Blocks ( ) ; Array List < Catch Table . Entry > result List = new Array List < Catch Table . Entry > ( len ) ; Catch Handler List current Handlers = Catch Handler List . EMPTY ; Basic Block current Start Block = null ; Basic Block current End Block = null ; for ( int i = NUM_ ; i < len ; i ++ ) { Basic Block block = blocks . label To Block ( order [ i ] ) ; if ( ! block . can Throw ( ) ) { continue ; } Catch Handler List handlers = handlers For ( block , addresses ) ; if ( current Handlers . size ( ) == NUM_ ) { current Start Block = block ; current End Block = block ; current Handlers = handlers ; continue ; } if ( current Handlers . equals ( handlers ) && range Is Valid ( current Start Block , block , addresses ) ) { current End Block = block ; continue ; } if ( current Handlers . size ( ) != NUM_ ) { Catch Table . Entry entry = make Entry ( current Start Block , current End Block , current Handlers , addresses ) ; result List . add ( entry ) ; } current Start Block = block ; current End Block = block ; current Handlers = handlers ; } if ( current Handlers . size ( ) != NUM_ ) { Catch Table . Entry entry = make Entry ( current Start Block , current End Block , current Handlers , addresses ) ; result List . add ( entry ) ; } int result Sz = result List . size ( ) ; if ( result Sz == NUM_ ) { return Catch Table . EMPTY ; } Catch Table result = new Catch Table ( result Sz ) ; for ( int i = NUM_ ; i < result Sz ; i ++ ) { result . set ( i , result List . get ( i ) ) ; } result . set Immutable ( ) ; return result ; }
public int calculate Padding Length ( int data Length ) { return encrypt Cipher . get Block Size ( ) - ( data Length % encrypt Cipher . get Block Size ( ) ) ; }
public void register ( T object ) { if ( invalidated . get ( ) ) { cleanup ( object ) ; return ; } objects . add ( object ) ; if ( invalidated . get ( ) ) cleanup All ( ) ; }
public void clear ( ) { current Output = STR_ ; accrued Input . set Length ( NUM_ ) ; accrued Input Without Formatting . set Length ( NUM_ ) ; formatting Template . set Length ( NUM_ ) ; last Match Position = NUM_ ; current Formatting Pattern = STR_ ; prefix Before National Number . set Length ( NUM_ ) ; extracted National Prefix = STR_ ; national Number . set Length ( NUM_ ) ; able To Format = true ; input Has Formatting = false ; position To Remember = NUM_ ; original Position = NUM_ ; is Complete Number = false ; is Expecting Country Calling Code = false ; possible Formats . clear ( ) ; should Add Space After National Prefix = false ; if ( ! current Metadata . equals ( default Metadata ) ) { current Metadata = get Metadata For Region ( default Country ) ; } }
public static void generate Markers For Security Specification ( Security Spec Model spec , I Project project ) { remove All Droidsafe Markers ( project ) ; List < Method Model > methods = new Array List < Method Model > ( spec . get Entry Points ( ) ) ; Collections . sort ( methods ) ; Map < Method Model , List < Method Model > > input Event Blocks = spec . get Input Event Blocks ( ) ; if ( input Event Blocks != null ) { for ( Method Model input Method : input Event Blocks . key Set ( ) ) { Source Location Tag line = input Method . get Decl Source Location ( ) ; if ( line != null ) { String clz = line . get Clz ( ) ; String class Path = Droidsafe Plugin Utilities . class Name Path ( clz ) ; I File file = project . get File ( class Path ) ; int line Nbr = line . get Line ( ) - NUM_ ; if ( file . exists ( ) ) { try { add Marker For Method ( input Method , file , input Method . get Short Signature ( ) , line Nbr ) ; add Marker For Method ( input Method , file , input Method . get Signature ( ) , line Nbr ) ; if ( input Method . get Receiver Value ( ) != null ) { add Marker For Method ( input Method , file , input Method . get Receiver Value ( ) , line Nbr ) ; } if ( input Method . get Permissions ( ) != null ) { for ( String permission : input Method . get Permissions ( ) ) { String message = STR_ + permission ; add Marker For Method ( input Method , file , message , line Nbr ) ; } } } catch ( Core Exception ex ) { ex . print Stack Trace ( ) ; } } } for ( Method Model output Method : input Event Blocks . get ( input Method ) ) { List < Code Location Model > locations = output Method . get Lines ( ) ; if ( locations != null ) { for ( Code Location Model location : locations ) { String clz = location . get Clz ( ) ; String class Path = Droidsafe Plugin Utilities . class Name Path ( clz ) ; I File file = project . get File ( class Path ) ; int line Nbr = location . get Line ( ) ; if ( file . exists ( ) ) { try { add Marker For Method ( output Method , file , output Method . get Short Signature ( ) , line Nbr ) ; add Marker For Method ( output Method , file , output Method . get Signature ( ) , line Nbr ) ; if ( output Method . get Permissions ( ) != null ) { for ( String permission : output Method . get Permissions ( ) ) { String message = STR_ + permission ; add Marker For Method ( output Method , file , message , line Nbr ) ; } } if ( output Method . get Receiver Value ( ) != null ) { add Marker For Method ( output Method , file , output Method . get Receiver Value ( ) , line Nbr ) ; } List < Hotspot Model > hotspots = location . get Hotspots ( ) ; for ( Hotspot Model hotspot : hotspots ) { add Marker For Method ( output Method , file , hotspot . to String ( ) , line Nbr ) ; } } catch ( Core Exception ex ) { ex . print Stack Trace ( ) ; } } } } } } } }
protected void do Leaf ( Attribute class Att , double [ ] preds ) throws Exception { if ( class Att . is Numeric ( ) ) { preds [ NUM_ ] = m score Numeric ; } else { if ( m score Distributions . size ( ) == NUM_ ) { preds [ m score Index ] = NUM_ ; } else { for ( Score Distribution s : m score Distributions ) { preds [ s . get Class Label Index ( ) ] = s . get Confidence ( ) ; } } } }
private static void process Annotations In Class ( boolean key , Class < ? > cls , Type Descriptor type , @ Nullable Class Property parent ) { if ( U . is Jdk ( cls ) || is Geometry Class ( cls ) ) { if ( parent == null && ! key && is Sql Type ( cls ) ) { String idx Name = VAL + STR_ ; type . add Index ( idx Name , is Geometry Class ( cls ) ? GEO SPATIAL : SORTED ) ; type . add Field To Index ( idx Name , VAL , NUM_ , false ) ; } return ; } if ( parent != null && parent . knows Class ( cls ) ) throw new Cache Exception ( STR_ + cls . get Name ( ) ) ; if ( parent == null ) { Query Text Field txt Ann Cls = cls . get Annotation ( Query Text Field . class ) ; if ( txt Ann Cls != null ) type . value Text Index ( true ) ; Query Group Index grp Idx = cls . get Annotation ( Query Group Index . class ) ; if ( grp Idx != null ) type . add Index ( grp Idx . name ( ) , SORTED ) ; Query Group Index . List grp Idx List = cls . get Annotation ( Query Group Index . List . class ) ; if ( grp Idx List != null && ! F . is Empty ( grp Idx List . value ( ) ) ) { for ( Query Group Index idx : grp Idx List . value ( ) ) type . add Index ( idx . name ( ) , SORTED ) ; } } for ( Class < ? > c = cls ; c != null && ! c . equals ( Object . class ) ; c = c . get Superclass ( ) ) { for ( Field field : c . get Declared Fields ( ) ) { Query Sql Field sql Ann = field . get Annotation ( Query Sql Field . class ) ; Query Text Field txt Ann = field . get Annotation ( Query Text Field . class ) ; if ( sql Ann != null || txt Ann != null ) { Class Property prop = new Class Property ( field ) ; prop . parent ( parent ) ; process Annotation ( key , sql Ann , txt Ann , field . get Type ( ) , prop , type ) ; type . add Property ( prop , true ) ; } } for ( Method mtd : c . get Declared Methods ( ) ) { if ( mtd . is Bridge ( ) ) continue ; Query Sql Field sql Ann = mtd . get Annotation ( Query Sql Field . class ) ; Query Text Field txt Ann = mtd . get Annotation ( Query Text Field . class ) ; if ( sql Ann != null || txt Ann != null ) { if ( mtd . get Parameter Types ( ) . length != NUM_ ) throw new Cache Exception ( STR_ + STR_ + mtd ) ; Class Property prop = new Class Property ( mtd ) ; prop . parent ( parent ) ; process Annotation ( key , sql Ann , txt Ann , mtd . get Return Type ( ) , prop , type ) ; type . add Property ( prop , true ) ; } } } }
public long number Of Value Schema Changes ( ) { return value Schemas . size ( ) ; }
public static Bundle create Fragment Args For Site ( String url ) { Bundle fragment Args = new Bundle ( ) ; String origin = Url Utilities . get Origin For Display ( URI . create ( url ) , true ) ; fragment Args . put String ( Single Website Preferences . EXTRA ORIGIN , origin ) ; return fragment Args ; }
public static Activity Facilities Impl create Grid Layer By Grid Size By Shape File V 2 ( Geometry boundary , double grid Size ) { log . info ( STR_ ) ; int skipped Points = NUM_ ; int set Points = NUM_ ; Geometry Factory factory = new Geometry Factory ( ) ; Activity Facilities Impl measuring Points = new Activity Facilities Impl ( STR_ ) ; Envelope env = boundary . get Envelope Internal ( ) ; for ( double x = env . get Min X ( ) ; x < env . get Max X ( ) ; x += grid Size ) { for ( double y = env . get Min Y ( ) ; y < env . get Max Y ( ) ; y += grid Size ) { double center X = x + ( grid Size / NUM_ ) ; double center Y = y + ( grid Size / NUM_ ) ; Point centroid = factory . create Point ( new Coordinate ( center X , center Y ) ) ; if ( boundary . contains ( centroid ) ) { Coord center = new Coord ( center X , center Y ) ; measuring Points . create And Add Facility ( Id . create ( set Points , Activity Facility . class ) , center ) ; set Points ++ ; } else skipped Points ++ ; } } log . info ( STR_ + set Points + STR_ + skipped Points + STR_ ) ; log . info ( STR_ ) ; return measuring Points ; }
public void submit One ( final R resource , final long retry Millis ) throws Interrupted Exception , Exception { if ( resource == null ) throw new Illegal Argument Exception ( ) ; if ( retry Millis < NUM_ ) throw new Illegal Argument Exception ( ) ; int retry Count = NUM_ ; final long begin = System . current Time Millis ( ) ; long last Log Time = begin ; final Callable < ? > task = new Parser Task ( resource ) ; while ( true ) { try { submit One ( resource , task ) ; return ; } catch ( Rejected Execution Exception ex ) { if ( parser Service . is Shutdown ( ) ) { throw ex ; } if ( retry Millis == NUM_ ) { throw ex ; } Thread . sleep ( retry Millis ) ; retry Count ++ ; if ( log . is Info Enabled ( ) ) { final long now = System . current Time Millis ( ) ; final long elapsed Since Last Log Time = now - last Log Time ; if ( elapsed Since Last Log Time > NUM_ ) { final long elapsed = now - begin ; last Log Time = now ; log . info ( STR_ + retry Count + STR_ + elapsed + STR_ + resource ) ; } } continue ; } catch ( Interrupted Exception ex ) { throw ex ; } catch ( Exception ex ) { log . error ( resource , ex ) ; } } }
private List < Centroid Cluster < T > > choose Initial Centers ( final Collection < T > points ) { final List < T > point List = Collections . unmodifiable List ( new Array List < T > ( points ) ) ; final int num Points = point List . size ( ) ; final boolean [ ] taken = new boolean [ num Points ] ; final List < Centroid Cluster < T > > result Set = new Array List < Centroid Cluster < T > > ( ) ; final int first Point Index = random . next Int ( num Points ) ; final T first Point = point List . get ( first Point Index ) ; result Set . add ( new Centroid Cluster < T > ( first Point ) ) ; taken [ first Point Index ] = true ; final double [ ] min Dist Squared = new double [ num Points ] ; for ( int i = NUM_ ; i < num Points ; i ++ ) { if ( i != first Point Index ) { double d = distance ( first Point , point List . get ( i ) ) ; min Dist Squared [ i ] = d * d ; } } while ( result Set . size ( ) < k ) { double dist Sq Sum = NUM_ ; for ( int i = NUM_ ; i < num Points ; i ++ ) { if ( ! taken [ i ] ) { dist Sq Sum += min Dist Squared [ i ] ; } } final double r = random . next Double ( ) * dist Sq Sum ; int next Point Index = - NUM_ ; double sum = NUM_ ; for ( int i = NUM_ ; i < num Points ; i ++ ) { if ( ! taken [ i ] ) { sum += min Dist Squared [ i ] ; if ( sum >= r ) { next Point Index = i ; break ; } } } if ( next Point Index == - NUM_ ) { for ( int i = num Points - NUM_ ; i >= NUM_ ; i -- ) { if ( ! taken [ i ] ) { next Point Index = i ; break ; } } } if ( next Point Index >= NUM_ ) { final T p = point List . get ( next Point Index ) ; result Set . add ( new Centroid Cluster < T > ( p ) ) ; taken [ next Point Index ] = true ; if ( result Set . size ( ) < k ) { for ( int j = NUM_ ; j < num Points ; j ++ ) { if ( ! taken [ j ] ) { double d = distance ( p , point List . get ( j ) ) ; double d 2 = d * d ; if ( d 2 < min Dist Squared [ j ] ) { min Dist Squared [ j ] = d 2 ; } } } } } else { break ; } } return result Set ; }
public Storage Unit Entity create Database Entities For Business Object Data Ddl Testing ( String partition Value , String s 3 Key Prefix ) { List < Schema Column > schema Columns = new Array List < > ( ) ; schema Columns . add ( new Schema Column ( Abstract Service Test . FIRST PARTITION COLUMN NAME , STR_ , Abstract Service Test . NO COLUMN SIZE , Abstract Service Test . COLUMN REQUIRED , Abstract Service Test . NO COLUMN DEFAULT VALUE , Abstract Service Test . NO COLUMN DESCRIPTION ) ) ; schema Columns . add ( new Schema Column ( Abstract Service Test . COLUMN NAME , STR_ , Abstract Service Test . COLUMN SIZE , Abstract Service Test . NO COLUMN REQUIRED , Abstract Service Test . COLUMN DEFAULT VALUE , Abstract Service Test . COLUMN DESCRIPTION ) ) ; List < Schema Column > partition Columns = schema Columns . sub List ( NUM_ , NUM_ ) ; Business Object Format Entity business Object Format Entity = business Object Format Dao Test Helper . create Business Object Format Entity ( Abstract Service Test . NAMESPACE , Abstract Service Test . BDEF NAME , Abstract Service Test . FORMAT USAGE CODE , File Type Entity . TXT FILE TYPE , Abstract Service Test . FORMAT VERSION , Abstract Service Test . FORMAT DESCRIPTION , Abstract Service Test . LATEST VERSION FLAG SET , Abstract Service Test . FIRST PARTITION COLUMN NAME , Abstract Service Test . NO PARTITION KEY GROUP , Abstract Service Test . NO ATTRIBUTES , Abstract Service Test . SCHEMA DELIMITER PIPE , Abstract Service Test . SCHEMA ESCAPE CHARACTER BACKSLASH , Abstract Service Test . SCHEMA NULL VALUE BACKSLASH N , schema Columns , partition Columns ) ; if ( partition Value != null ) { Business Object Data Entity business Object Data Entity = business Object Data Dao Test Helper . create Business Object Data Entity ( business Object Format Entity , partition Value , Abstract Service Test . NO SUBPARTITION VALUES , Abstract Service Test . DATA VERSION , Abstract Service Test . LATEST VERSION FLAG SET , Business Object Data Status Entity . VALID ) ; Storage Entity storage Entity = storage Dao Test Helper . create Storage Entity ( Abstract Service Test . STORAGE NAME , Storage Platform Entity . S 3 , Arrays . as List ( new Attribute ( configuration Helper . get Property ( Configuration Value . S 3 ATTRIBUTE NAME BUCKET NAME ) , Abstract Service Test . S 3 BUCKET NAME ) , new Attribute ( configuration Helper . get Property ( Configuration Value . S 3 ATTRIBUTE NAME KEY PREFIX VELOCITY TEMPLATE ) , Abstract Service Test . S 3 KEY PREFIX VELOCITY TEMPLATE ) ) ) ; return storage Unit Dao Test Helper . create Storage Unit Entity ( storage Entity , business Object Data Entity , Storage Unit Status Entity . ENABLED , s 3 Key Prefix ) ; } return null ; }
protected static double compute H ( Double Array dist i , double [ ] pij row , double mbeta ) { final int len = dist i . size ( ) ; assert ( pij row . length == len ) ; double sum P = NUM_ ; for ( int j = NUM_ ; j < len ; j ++ ) { sum P += ( pij row [ j ] = Math . exp ( dist i . get ( j ) * mbeta ) ) ; } if ( ! ( sum P > NUM_ ) ) { return Double . NEGATIVE INFINITY ; } final double s = NUM_ / sum P ; double sum = NUM_ ; for ( int j = NUM_ ; j < len ; j ++ ) { sum += dist i . get ( j ) * ( pij row [ j ] *= s ) ; } return Math . log ( sum P ) - mbeta * sum ; }
private void find By Name ( List target , List source , String name ) { for ( int i = NUM_ ; i < source . size ( ) ; i ++ ) { Object o = source . get ( i ) ; if ( o instanceof Map ) { find By Name ( target , ( Map ) o , name ) ; } else if ( o instanceof List ) { find By Name ( target , ( List ) o , name ) ; } } }
private void write Object ( Object Output out , Object obj ) throws IO Exception { out . write Object ( obj == null || ! ( obj instanceof Serializable ) ? NULL OBJECT : obj ) ; }
public Node List select Node List ( Node context Node , Node xpathnode , String str , Node namespace Node ) throws Transformer Exception { if ( ! str . equals ( xpath Str ) || xpath Expression == null ) { if ( xpf == null ) { xpf = X Path Factory . new Instance ( ) ; try { xpf . set Feature ( XML Constants . FEATURE SECURE PROCESSING , Boolean . TRUE ) ; } catch ( X Path Factory Configuration Exception ex ) { throw new Transformer Exception ( STR_ , ex ) ; } } X Path xpath = xpf . new X Path ( ) ; xpath . set Namespace Context ( new DOM Namespace Context ( namespace Node ) ) ; xpath Str = str ; try { xpath Expression = xpath . compile ( xpath Str ) ; } catch ( X Path Expression Exception ex ) { throw new Transformer Exception ( STR_ , ex ) ; } } try { return ( Node List ) xpath Expression . evaluate ( context Node , X Path Constants . NODESET ) ; } catch ( X Path Expression Exception ex ) { throw new Transformer Exception ( STR_ , ex ) ; } }
public static Class box Type ( Class primitive Type ) { Class c = ( Class ) wrapper Map . get ( primitive Type ) ; if ( c != null ) return c ; throw new Interpreter Error ( STR_ + primitive Type ) ; }
protected boolean os Delete File ( File file ) { return file . delete ( ) ; }
public Lexer Node create Lexer Node ( ) { return new Lexer Node ( false ) ; }
private void fix Ctrl H ( ) { Input Map input Map = get Input Map ( ) ; Key Stroke char 010 = Key Stroke . get Key Stroke ( STR_ ) ; Input Map parent = input Map ; while ( parent != null ) { parent . remove ( char 010 ) ; parent = parent . get Parent ( ) ; } Key Stroke backspace = Key Stroke . get Key Stroke ( STR_ ) ; input Map . put ( backspace , Default Editor Kit . delete Prev Char Action ) ; }
public byte [ ] embed Data ( byte [ ] msg , String msg File Name , byte [ ] cover , String cover File Name , String stego File Name ) throws Open Stego Exception { Buffered Image image = null ; Dct LSB Output Stream os = null ; int img Type = NUM_ ; try { if ( cover == null ) { image = Image Util . generate Random Image ( ( DCT Data Header . get Max Header Size ( ) + msg . length ) * NUM_ * DCT . NJPEG * DCT . NJPEG ) ; } else { image = Image Util . byte Array To Image ( cover , cover File Name ) ; } img Type = image . get Type ( ) ; os = new Dct LSB Output Stream ( image , msg . length , msg File Name , this . config ) ; os . write ( msg ) ; os . close ( ) ; return Image Util . image To Byte Array ( os . get Image ( img Type ) , stego File Name , this ) ; } catch ( IO Exception io Ex ) { throw new Open Stego Exception ( io Ex ) ; } }
public static Ingredient from Cursor ( Cursor cursor ) { Ingredient ingredient = new Ingredient ( ) ; for ( int c = NUM_ ; c < cursor . get Column Count ( ) ; c ++ ) { String column Name = cursor . get Column Name ( c ) ; if ( column Name . equals ( Recipe Ingredient Table . AMOUNT COLUMN ) ) { ingredient . set Amount ( cursor . get String ( c ) ) ; } else if ( column Name . equals ( Recipe Ingredient Table . DESCRIPTION COLUMN ) ) { ingredient . set Description ( cursor . get String ( c ) ) ; } } return ingredient ; }
private String compute Md 5 Hash ( String buffer ) { Message Digest md ; try { md = Message Digest . get Instance ( STR_ ) ; return bytes To Hex ( md . digest ( buffer . get Bytes ( STR_ ) ) ) ; } catch ( No Such Algorithm Exception ignore ) { } catch ( Unsupported Encoding Exception e ) { } return STR_ ; }
public void unregister All ( ) { try { Object Name name = new Object Name ( OBJECTNAME PREFIX + STR_ ) ; Set < Object Name > gem Fire Objects = mbean Server . query Names ( name , null ) ; for ( Object Name object Name : gem Fire Objects ) { unregister M Bean ( object Name ) ; } } catch ( Malformed Object Name Exception e ) { throw new Management Exception ( e ) ; } catch ( Null Pointer Exception e ) { throw new Management Exception ( e ) ; } }
public static void inflate Data ( byte [ ] deflated , byte [ ] inflated ) { Inflater inflater = new Inflater ( ) ; inflater . set Input ( deflated ) ; try { inflater . inflate ( inflated ) ; } catch ( Data Format Exception dfe ) { throw new IO Exception ( IO Exception . Cannot Inflate Tiff Image ) ; } }
public static final Collection < Race > find Races ( String stream , Collection < Race > races ) { Collection < Race > result = new Array List < > ( ) ; for ( Race r : races ) { for ( Entrant e : r . get Entrants ( ) ) { if ( stream . equals Ignore Case ( e . twitch ) ) { result . add ( r ) ; } } } return result ; }
public void fires ( double [ ] input , Array List < Simple Rule > rule Collection ) { if ( m predicate . evaluate ( input ) == Tree Model . Predicate . Eval . TRUE ) { for ( Rule r : m child Rules ) { r . fires ( input , rule Collection ) ; } } }
private static int uarimin Gt ( double value , double [ ] bv , int bvi [ ] , Binary Operator b Op ) throws DML Runtime Exception { int ix Min = NUM_ ; if ( value <= bv [ NUM_ ] || value > bv [ bv . length - NUM_ ] ) return ix Min ; int ix = Arrays . binary Search ( bv , value ) ; ix = Math . abs ( ix ) - NUM_ ; ix Min = bvi [ ix ] + NUM_ ; return ix Min ; }
private byte [ ] generate Class File ( ) { add Proxy Method ( hash Code Method , Object . class ) ; add Proxy Method ( equals Method , Object . class ) ; add Proxy Method ( to String Method , Object . class ) ; for ( Class < ? > intf : interfaces ) { for ( Method m : intf . get Methods ( ) ) { add Proxy Method ( m , intf ) ; } } for ( List < Proxy Method > sigmethods : proxy Methods . values ( ) ) { check Return Types ( sigmethods ) ; } try { methods . add ( generate Constructor ( ) ) ; for ( List < Proxy Method > sigmethods : proxy Methods . values ( ) ) { for ( Proxy Method pm : sigmethods ) { fields . add ( new Field Info ( pm . method Field Name , STR_ , ACC PRIVATE | ACC STATIC ) ) ; methods . add ( pm . generate Method ( ) ) ; } } methods . add ( generate Static Initializer ( ) ) ; } catch ( IO Exception e ) { throw new Internal Error ( STR_ , e ) ; } if ( methods . size ( ) > NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( fields . size ( ) > NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } cp . get Class ( dot To Slash ( class Name ) ) ; cp . get Class ( superclass Name ) ; for ( Class < ? > intf : interfaces ) { cp . get Class ( dot To Slash ( intf . get Name ( ) ) ) ; } cp . set Read Only ( ) ; Byte Array Output Stream bout = new Byte Array Output Stream ( ) ; Data Output Stream dout = new Data Output Stream ( bout ) ; try { dout . write Int ( NUM_ ) ; dout . write Short ( CLASSFILE MINOR VERSION ) ; dout . write Short ( CLASSFILE MAJOR VERSION ) ; cp . write ( dout ) ; dout . write Short ( access Flags ) ; dout . write Short ( cp . get Class ( dot To Slash ( class Name ) ) ) ; dout . write Short ( cp . get Class ( superclass Name ) ) ; dout . write Short ( interfaces . length ) ; for ( Class < ? > intf : interfaces ) { dout . write Short ( cp . get Class ( dot To Slash ( intf . get Name ( ) ) ) ) ; } dout . write Short ( fields . size ( ) ) ; for ( Field Info f : fields ) { f . write ( dout ) ; } dout . write Short ( methods . size ( ) ) ; for ( Method Info m : methods ) { m . write ( dout ) ; } dout . write Short ( NUM_ ) ; } catch ( IO Exception e ) { throw new Internal Error ( STR_ , e ) ; } return bout . to Byte Array ( ) ; }
@ Override public Double DBID List reverse KNN Query ( DBID Ref id , int k ) { if ( k > settings . kmax ) { throw new Illegal Argument Exception ( STR_ + STR_ ) ; } Modifiable Double DBID List result = DBID Util . new Distance DBID List ( ) ; Modifiable DBI Ds candidates = DBID Util . new Array ( ) ; do Reverse KNN Query ( k , id , result , candidates ) ; Map < DBID , KNN List > knn Lists = batch NN ( get Root ( ) , candidates , k ) ; result . sort ( ) ; for ( DBID Iter iter = candidates . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { DBID cid = DBID Util . deref ( iter ) ; KNN List cands = knn Lists . get ( cid ) ; for ( Double DBID List Iter iter 2 = cands . iter ( ) ; iter 2 . valid ( ) ; iter 2 . advance ( ) ) { if ( DBID Util . equal ( id , iter 2 ) ) { result . add ( iter 2 . double Value ( ) , cid ) ; break ; } } } result . sort ( ) ; return result ; }
public void remove Progress Listener ( Action Listener < Network Event > al ) { if ( progress Listeners == null ) { return ; } progress Listeners . remove Listener ( al ) ; Collection v = progress Listeners . get Listener Collection ( ) ; if ( v == null || v . size ( ) == NUM_ ) { progress Listeners = null ; } }
public static Run Stats delegate Get Bucket For Greek And English String ( int buckets ) throws Exception { Long start Time = System . current Time Millis ( ) ; Primary Index Bucket Generator Impl ibg = new Primary Index Bucket Generator Impl ( Field Data Type . TEXT , buckets ) ; Primary Index Bucket Locator Impl locator = new Primary Index Bucket Locator Impl ( ibg . generate Buckets ( ) , null , null , null , null , null , null , null , null ) ; logger . debug ( STR_ ) ; String file English = STR_ ; String file Greek = STR_ ; String greek File = Utils . read File ( file Greek ) ; String [ ] greek Lines = greek File . split ( STR_ ) ; String english File = Utils . read File ( file English ) ; String [ ] english Lines = english File . split ( STR_ ) ; try { Hash Map < Long , List < Object > > hm = new Hash Map < > ( ) ; Summary Statistics stats = new Summary Statistics ( ) ; for ( String line : english Lines ) { line = line . trim ( ) ; Long bucket Id = locator . get Bucket ( line , Field Data Type . TEXT ) ; calculate ( hm , stats , bucket Id , line ) ; } for ( String line : greek Lines ) { line = line . trim ( ) ; Long bucket Id = locator . get Bucket ( line , Field Data Type . TEXT ) ; calculate ( hm , stats , bucket Id , line ) ; } Long run Time = System . current Time Millis ( ) - start Time ; Run Stats run Stats = new Run Stats ( STR_ , Field Data Type . TEXT , run Time , stats , hm ) ; logger . debug ( run Stats . to String ( ) ) ; return run Stats ; } catch ( Exception e ) { logger . debug ( e . to String ( ) , e ) ; throw e ; } }
public Thread start New Server ( Socket sock ) { return new Link Server ( sock ) ; }
public static String construct Llcc Key ( String lang , String country ) { String key = lang ; if ( country != null && ! country . equals ( STR_ ) ) { key += STR_ + country ; } return key ; }
private boolean remove If ( Predicate < Tombstone > predicate ) { return remove Unexpired If ( predicate ) || remove Expired If ( predicate ) ; }
public void reset ( ) { Iterator iter = m vis . visible Items ( m node Group ) ; while ( iter . has Next ( ) ) { Visual Item item = ( Visual Item ) iter . next ( ) ; Force Item fitem = ( Force Item ) item . get ( FORCEITEM ) ; if ( fitem != null ) { fitem . location [ NUM_ ] = ( float ) item . get End X ( ) ; fitem . location [ NUM_ ] = ( float ) item . get End Y ( ) ; fitem . force [ NUM_ ] = fitem . force [ NUM_ ] = NUM_ ; fitem . velocity [ NUM_ ] = fitem . velocity [ NUM_ ] = NUM_ ; } } m lasttime = - NUM_ ; }
public long insert ( String table , String null Column Hack , Content Values values ) { verify Db Is Open ( ) ; String Builder sql = new String Builder ( ) ; sql . append ( STR_ ) ; sql . append ( STR_ ) ; sql . append ( table ) ; sql . append ( STR_ ) ; Object [ ] bind Args = null ; int size = ( values != null && values . size ( ) > NUM_ ) ? values . size ( ) : NUM_ ; if ( size > NUM_ ) { bind Args = new Object [ size ] ; int i = NUM_ ; for ( String col Name : values . key Set ( ) ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; sql . append ( col Name ) ; bind Args [ i ++ ] = values . get ( col Name ) ; } sql . append ( STR_ ) ; sql . append ( STR_ ) ; for ( i = NUM_ ; i < size ; i ++ ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; } } else { sql . append ( null Column Hack + STR_ ) ; } sql . append ( STR_ ) ; return execute Sql ( sql . to String ( ) , bind Args ) ; }
public boolean check MMS ( Message message ) { return message . get Images ( ) . length != NUM_ || ( message . get Media ( ) . length != NUM_ && message . get Media Mime Type ( ) != null ) || ( settings . get Send Long As Mms ( ) && Utils . get Num Pages ( settings , message . get Text ( ) ) > settings . get Send Long As Mms After ( ) && message . get Type ( ) != Message . TYPE VOICE ) || ( message . get Addresses ( ) . length > NUM_ && settings . get Group ( ) ) || message . get Subject ( ) != null ; }
private void add External Value Input Patch ( boolean is Shadow , int i , int x To , Input View input View , View Point input Layout Origin ) { m Helper . set Point Maybe Flip ( m Input Connector Offsets . get ( i ) , x To , input Layout Origin . y ) ; final Nine Patch Drawable input Drawable = get Colored Patch Drawable ( is Shadow ? R . drawable . value input external shadow : R . drawable . value input external ) ; final Nine Patch Drawable input Border Drawable = m Patch Manager . get Patch Drawable ( R . drawable . value input external border ) ; final Nine Patch Drawable connection Highlight Drawable = m Patch Manager . get Patch Drawable ( R . drawable . value input external connection ) ; int patch Left = x To - input Drawable . get Intrinsic Width ( ) ; int patch Right = x To ; int connector Top = input Layout Origin . y + m Block Top Padding ; int connector Bottom = input Layout Origin . y + input View . get Measured Height ( ) ; m Helper . set Rtl Aware Bounds ( temp Rect , m Block View Size . x , patch Left , connector Top , patch Right , connector Bottom ) ; input Drawable . set Bounds ( temp Rect ) ; input Border Drawable . set Bounds ( temp Rect ) ; connection Highlight Drawable . set Bounds ( temp Rect ) ; m Block Patches . add ( input Drawable ) ; m Block Border Patches . add ( input Border Drawable ) ; m Input Connection Highlight Patches . set ( i , connection Highlight Drawable ) ; if ( i > NUM_ ) { final Nine Patch Drawable boundary Gap Drawable = get Colored Patch Drawable ( R . drawable . dummy input ) ; final Nine Patch Drawable boundary Gap Border Drawable = m Patch Manager . get Patch Drawable ( R . drawable . dummy input border ) ; m Helper . set Rtl Aware Bounds ( temp Rect , m Block View Size . x , patch Left , input Layout Origin . y , patch Right , connector Top ) ; boundary Gap Drawable . set Bounds ( temp Rect ) ; boundary Gap Border Drawable . set Bounds ( temp Rect ) ; m Block Patches . add ( boundary Gap Drawable ) ; m Block Border Patches . add ( boundary Gap Border Drawable ) ; } }
public Month Date Format ( Time Zone zone , int chars ) { this ( zone , Locale . get Default ( ) , chars , true , false ) ; }
public J Popup Menu create Popup Menu ( ) { return create Popup Menu ( get All Selected Lines ( ) ) ; }
public void store Pairing File ( File output File , String devicename , char [ ] password , Pairing Type type , Device Type dev Type ) { logger . debug ( STR_ + output File . get Absolute Path ( ) ) ; try { Panbox File Pairing Write Return Container ret Con = null ; if ( type == Pairing Type . MASTER ) { ret Con = Panbox File Pairing Utils . store Pairing File ( output File , devicename , password , type , dev Type , my Id . get Email ( ) , my Id . get First Name ( ) , my Id . get Name ( ) , my Id . get Private Key Enc ( password ) , my Id . get Cert Enc ( ) , my Id . get Private Key Sign ( password ) , my Id . get Cert Sign ( ) , get Device Pairing Map ( ) , get Contacts Pairing List ( ) ) ; } else { ret Con = Panbox File Pairing Utils . store Pairing File ( output File , devicename , password , type , dev Type , my Id . get Email ( ) , my Id . get First Name ( ) , my Id . get Name ( ) , null , my Id . get Cert Enc ( ) , null , my Id . get Cert Sign ( ) , get Device Pairing Map ( ) , get Contacts Pairing List ( ) ) ; } logger . debug ( STR_ ) ; device Manager . add Device ( ret Con . get Devicename ( ) , ret Con . get Dev Cert ( ) , ret Con . get Dev Type ( ) ) ; refresh Device List Model ( ) ; } catch ( IO Exception | Key Store Exception | No Such Algorithm Exception | Certificate Exception ex ) { logger . error ( STR_ , ex ) ; J Option Pane . show Message Dialog ( null , bundle . get String ( STR_ ) , bundle . get String ( STR_ ) , J Option Pane . ERROR MESSAGE ) ; } catch ( Unrecoverable Key Exception ex ) { logger . error ( STR_ , ex ) ; J Option Pane . show Message Dialog ( null , bundle . get String ( STR_ ) , bundle . get String ( STR_ ) , J Option Pane . ERROR MESSAGE ) ; } catch ( Device Manager Exception ex ) { logger . warn ( STR_ , ex ) ; J Option Pane . show Message Dialog ( null , bundle . get String ( STR_ ) , bundle . get String ( STR_ ) , J Option Pane . ERROR MESSAGE ) ; } }
public void start New Acceptor ( ) { Thread t = Access Controller . do Privileged ( new New Thread Action ( Connection Acceptor . this , STR_ + ++ thread Num , true ) ) ; t . start ( ) ; }
public clean Gauteng Network ( ) { log = Logger . get Logger ( clean Gauteng Network . class ) ; }
public void add Datatransfer Progress Listener ( On Datatransfer Progress Listener listener , Account account , OC File file ) { if ( account == null || file == null || listener == null ) return ; String target Key = build Remote Name ( account , file ) ; m Bound Listeners . put ( target Key , listener ) ; }
public final void unscheduled For Flush ( ) { scheduled For Flush . set ( false ) ; }
private String read Fully ( Http URL Connection connection ) throws IO Exception { String response Body = STR_ ; if ( connection . get Content Length ( ) != NUM_ ) { try { Input Stream in = connection . get Input Stream ( ) ; if ( in != null ) { response Body = read Stream Data ( in ) ; } } catch ( IO Exception e ) { Input Stream in = connection . get Error Stream ( ) ; if ( in != null ) { response Body = read Stream Data ( in ) ; } else { throw e ; } } } return response Body ; }
public static void put At ( String Builder self , Int Range range , Object value ) { Range Info info = sub List Borders ( self . length ( ) , range ) ; self . replace ( info . from , info . to , value . to String ( ) ) ; }
public double [ ] distribution For Instance ( Instance inst ) throws Exception { m Replace Missing Values . input ( inst ) ; m Replace Missing Values . batch Finished ( ) ; inst = m Replace Missing Values . output ( ) ; m Nominal To Binary . input ( inst ) ; m Nominal To Binary . batch Finished ( ) ; inst = m Nominal To Binary . output ( ) ; double output = NUM_ , sum So Far = NUM_ ; if ( m K > NUM_ ) { for ( int i = NUM_ ; i <= m K ; i ++ ) { if ( sum So Far < NUM_ ) { output -= m Weights [ i ] ; } else { output += m Weights [ i ] ; } if ( m Is Addition [ i ] ) { sum So Far += inner Product ( m Train . instance ( m Additions [ i ] ) , inst ) ; } else { sum So Far -= inner Product ( m Train . instance ( m Additions [ i ] ) , inst ) ; } } } double [ ] result = new double [ NUM_ ] ; result [ NUM_ ] = NUM_ / ( NUM_ + Math . exp ( - output ) ) ; result [ NUM_ ] = NUM_ - result [ NUM_ ] ; return result ; }
public Rotated Problems ( ) { super ( ) ; }
private void generate Chunks For Schema ( String schema Name ) { try { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + schema Name ) ; Array List < Table > tables From Schema = connection . get Tables ( schema Name , true , true ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + tables From Schema ) ; if ( tables From Schema != null && tables From Schema . size ( ) > NUM_ ) { for ( Table table : tables From Schema ) { generate Chunks For Table ( table , - NUM_ , null ) ; } } } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public void update Vdc Target Version ( String site Id , String action , long vdc Target Version ) throws Exception { update Vdc Target Version ( site Id , action , vdc Target Version , null , null ) ; }
protected void options Dialog Property Change ( Property Change Event event ) { log . debug ( STR_ ) ; fire Property Change ( Property Change ID . OPTION CHANGE , event . get Old Value ( ) , event . get New Value ( ) ) ; }
private Object read ( char [ ] list , int length ) throws Exception { Object array = Array . new Instance ( entry , length ) ; for ( int i = NUM_ ; i < length ; i ++ ) { Array . set ( array , i , list [ i ] ) ; } return array ; }
public Email Address Validator ( @ Non Null final Char Sequence error Message ) { super ( error Message , REGEX ) ; }
void initialize Evaluation Weights ( ) { ps Weight = users . size ( ) * subject Weight ; pr Weight = rules . size ( ) * rule Weight ; pc Weight = conditions . size ( ) * condition Weight ; }
private String search Char Set ( String [ ] items ) { String charset ; String Buffer sb = new String Buffer ( ) ; for ( int i = items . length ; i > NUM_ ; i -- ) { charset = search Char Set ( items , sb , i ) ; if ( charset . length ( ) > NUM_ ) { return charset ; } sb . set Length ( NUM_ ) ; } return STR_ ; }
private static void read Op ( byte [ ] out Buffer , int dst buff offset , int count , byte [ ] src Buffer , int read pos , int buff len ) { if ( read pos + count <= buff len ) { System . arraycopy ( src Buffer , read pos , out Buffer , dst buff offset , count ) ; } else { int till End Count = buff len - read pos ; System . arraycopy ( src Buffer , read pos , out Buffer , dst buff offset , till End Count ) ; int from Start Count = count - till End Count ; System . arraycopy ( src Buffer , NUM_ , out Buffer , dst buff offset + till End Count , from Start Count ) ; } }
@ Override public int compare To ( Distance Entry < E > o ) { int comp = Double . compare ( distance , o . distance ) ; if ( comp != NUM_ ) { return comp ; } return NUM_ ; }
private boolean same ( double d 1 , double d 2 , double tolerance ) { return ( Math . abs ( d 1 - d 2 ) < tolerance ) ; }
public static int size ( String Builder builder ) { return builder . length ( ) ; }
public Selection Builder reset ( ) { m Table = null ; m Selection . set Length ( NUM_ ) ; m Selection Args . clear ( ) ; return this ; }
public String pre Process User Input ( String user Input , I State Access state , boolean is Req ) throws Install Exception { String proc Res = null ; if ( is Req ) { proc Res = pre Proc User Input If Required ( user Input , state ) ; } else { proc Res = pre Proc User Input If Optional ( user Input , state ) ; } return proc Res ; }
public void object Added ( Naming Event naming Event ) { Map < String , Set < Role > > new Roles = new Hash Map < > ( ) ; try { process Search Result ( new Roles , ( Search Result ) naming Event . get New Binding ( ) ) ; for ( Map . Entry < String , Set < Role > > entry : new Roles . entry Set ( ) ) { Set < Role > existing Roles = security Repository . get Match ( entry . get Key ( ) ) ; for ( Role role : entry . get Value ( ) ) { existing Roles . add ( role ) ; } } } catch ( Naming Exception e ) { e . print Stack Trace ( ) ; } }
public static long update Smsc Timestamp Drift ( Context context , long timestamp , long smsc Timestamp ) { final int thirty Mins = NUM_ * NUM_ * NUM_ ; long time Drift = NUM_ ; final long time Diff 30 Mins = Math . round ( ( smsc Timestamp - timestamp ) / thirty Mins ) ; if ( Math . abs ( time Diff 30 Mins ) > NUM_ ) { time Drift = time Diff 30 Mins * thirty Mins ; Shared Preferences prefs = Preference Manager . get Default Shared Preferences ( context ) ; Editor editor = prefs . edit ( ) ; editor . put Long ( Manage Preferences . SMSC TIME DRIFT , time Drift ) ; editor . commit ( ) ; } return time Drift ; }
private boolean detect Special Initialization Case ( Faces Context faces Context ) { boolean result = false ; if ( null == faces Context ) { log Null Faces Context . compare And Set ( false , true ) ; } else { log Non Null Faces Context . compare And Set ( false , true ) ; } result = log Null Faces Context . get ( ) && log Non Null Faces Context . get ( ) ; return result ; }
private void on User Removed ( int user Id ) { synchronized ( this ) { m Db Helpers . delete ( user Id ) ; if ( LOCAL LOGV ) Log . d ( TAG , STR_ + user Id + STR_ ) ; } }
private static void update Menus ( Set < Report > tool Results , Set < String > cat Set ) { String Buffer sb = new String Buffer ( ) ; for ( Report tool Report : tool Results ) { if ( ! ( show Ave Only Mode && tool Report . is Commercial ( ) ) ) { sb . append ( STR_ ) ; sb . append ( tool Report . get Filename ( ) ) ; sb . append ( STR_ ) ; sb . append ( tool Report . get Tool Name And Version ( ) ) ; sb . append ( STR_ ) ; sb . append ( System . line Separator ( ) ) ; } } if ( commercial Ave Scorecard Filename != null ) { sb . append ( STR_ ) ; sb . append ( commercial Ave Scorecard Filename ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( System . line Separator ( ) ) ; } String toolmenu = sb . to String ( ) ; sb = new String Buffer ( ) ; for ( String cat : cat Set ) { String filename = STR_ + benchmark Version + STR_ + cat . replace ( STR_ , STR_ ) ; sb . append ( STR_ ) ; sb . append ( filename ) ; sb . append ( STR_ ) ; sb . append ( cat ) ; sb . append ( STR_ ) ; sb . append ( System . line Separator ( ) ) ; } String vulnmenu = sb . to String ( ) ; update Menu Templates ( toolmenu , vulnmenu ) ; }
public static int compute Hash ( byte [ ] key , int mask ) { return Math . abs ( Murmur Hash 3 . murmurhash 3 x 8632 ( key , NUM_ , key . length , NUM_ ) & mask ) ; }
public void run ( ) { allow To Change = false ; synchronized ( actions ) { if ( ! actions . is Empty ( ) ) { for ( Iterator iter = actions . iterator ( ) ; iter . has Next ( ) ; ) { do Group Action ( iter . next ( ) ) ; if ( remove Element After Action ) { iter . remove ( ) ; } } } } reset ( ) ; }
public void write String ( String string ) throws IO Exception { if ( writing Start Tag ) { writer . write ( STR_ ) ; writing Start Tag = false ; } writer . write ( string ) ; }
private Object read Resolve ( ) { synchronized ( levels ) { for ( Level level : levels ) { if ( value != level . value ) { continue ; } if ( ! name . equals ( level . name ) ) { continue ; } if ( Objects . equal ( resource Bundle Name , level . resource Bundle Name ) ) { return level ; } } levels . add ( this ) ; return this ; } }
protected void renumber Columns ( ) { Iterator iter = m names . iterator ( ) ; for ( int idx = NUM_ ; iter . has Next ( ) ; ++ idx ) { String name = ( String ) iter . next ( ) ; Column Entry e = ( Column Entry ) m entries . get ( name ) ; e . colnum = idx ; } }
public void sync ( long amount , Time Unit unit ) throws IO Exception { try { latch . await ( amount , unit ) ; } catch ( Interrupted Exception e ) { Thread . interrupted ( ) ; throw IO Exception Support . create ( e ) ; } fail On Error ( ) ; }
public P Shape find Child ( String target ) { if ( parent == null ) { return get Child ( target ) ; } else { return parent . find Child ( target ) ; } }
public static void assert Entry Absent ( Synonym Map synonyn Map , String word ) throws IO Exception { word = word . replace ( STR_ , Synonym Map . WORD SEPARATOR ) ; Bytes Ref value = Util . get ( synonyn Map . fst , Util . to UTF 32 ( new Chars Ref ( word ) , new Ints Ref Builder ( ) ) ) ; assert Null ( STR_ + word , value ) ; }
protected void update Annotations ( Annotation existing Annotation , Position new Pos , Map additions , List modifications , List deletions ) { if ( existing Annotation instanceof Folding Annotation ) { Folding Annotation folding Annotation = ( Folding Annotation ) existing Annotation ; if ( new Pos != null && new Pos . length > NUM_ && projection Annotation Model != null ) { Position old Pos = projection Annotation Model . get Position ( folding Annotation ) ; if ( ! new Pos . equals ( old Pos ) ) { old Pos . set Offset ( new Pos . offset ) ; old Pos . set Length ( new Pos . length ) ; modifications . add ( folding Annotation ) ; } } else { deletions . add ( folding Annotation ) ; } } }
public void take Snapshot ( String tag , String ... keyspace Names ) throws IO Exception { if ( operation Mode == Mode . JOINING ) throw new IO Exception ( STR_ ) ; if ( tag == null || tag . equals ( STR_ ) ) throw new IO Exception ( STR_ ) ; Iterable < Keyspace > keyspaces ; if ( keyspace Names . length == NUM_ ) { keyspaces = Keyspace . all ( ) ; } else { Array List < Keyspace > t = new Array List < > ( keyspace Names . length ) ; for ( String keyspace Name : keyspace Names ) t . add ( get Valid Keyspace ( keyspace Name ) ) ; keyspaces = t ; } for ( Keyspace keyspace : keyspaces ) if ( keyspace . snapshot Exists ( tag ) ) throw new IO Exception ( STR_ + tag + STR_ ) ; for ( Keyspace keyspace : keyspaces ) keyspace . snapshot ( tag , null ) ; }
public void find And Init ( Object obj ) { if ( obj instanceof DTED Frame Cache ) { logger . fine ( STR_ ) ; set DTED Frame Cache ( ( DTED Frame Cache ) obj ) ; } if ( obj instanceof OM Drawing Tool ) { logger . fine ( STR_ ) ; set Drawing Tool ( ( OM Drawing Tool ) obj ) ; } }
protected void pad Selected Tab ( int tab Placement , int selected Index ) { if ( selected Index >= NUM_ ) { Rectangle sel Rect = rects [ selected Index ] ; Insets pad Insets = get Selected Tab Pad Insets ( tab Placement ) ; sel Rect . x -= pad Insets . left ; sel Rect . width += ( pad Insets . left + pad Insets . right ) ; sel Rect . y -= pad Insets . top ; sel Rect . height += ( pad Insets . top + pad Insets . bottom ) ; } }
public static void add Font ( String font Key , Font font ) { if ( font Key != null ) { font Key = font Key . to Lower Case ( ) ; } else { if ( font . get Charset ( ) != null ) { throw new Illegal Argument Exception ( STR_ ) ; } } fonts . put ( font Key , new HTML Font ( font Key , font ) ) ; }
public Tagged Output Stream ( Output Stream proxy ) { super ( proxy ) ; }
public Sequences Writer ( Sequence Data Source source , File output Dir , long size Limit , Collection < String > names To Exclude , Preread Type type , boolean compressed , Integer trim Quality Threshold ) { m Data Source = source ; m Output Dir = output Dir ; m Preread Type = type ; m Sdf Id = new Sdf Id ( ) ; if ( m Data Source == null ) { throw new Null Pointer Exception ( STR_ ) ; } File Utils . ensure Output Directory ( m Output Dir ) ; m Size Limit = size Limit ; m Names To Exclude = names To Exclude == null ? new Array List < > ( ) : names To Exclude ; m Compressed = compressed ; if ( trim Quality Threshold != null ) { if ( System . get Property ( STR_ ) != null ) { final int window Size = Integer . parse Int ( System . get Property ( STR_ ) ) ; m Read Trimmer = new Default Read Trimmer ( window Size , trim Quality Threshold ) ; Diagnostic . user Log ( STR_ + trim Quality Threshold + STR_ + window Size ) ; } else { m Read Trimmer = new Best Sum Read Trimmer ( trim Quality Threshold ) ; Diagnostic . user Log ( STR_ + trim Quality Threshold ) ; } } else { m Read Trimmer = new Null Read Trimmer ( ) ; } }
protected final void fire Vetoable Change ( Property Change Event event ) throws Property Veto Exception { Vetoable Change Support a Veto Support = this . veto Support ; if ( a Veto Support == null ) { return ; } a Veto Support . fire Vetoable Change ( event ) ; }
void merge Words ( ) { merge Compound Names ( ) ; merge Three Word Expressions ( ) ; if ( merge Two Word Expressions ( ) > NUM_ ) { merge Three Word Expressions ( ) ; } }
public boolean is Left Mouse Button ( Mouse Event me ) { return Swing Utilities . is Left Mouse Button ( me ) ; }
@ Override protected void fire Insert Update ( Document Event evt ) { if ( token Marker != null ) { Document Event . Element Change ch = evt . get Change ( get Default Root Element ( ) ) ; if ( ch != null ) { token Marker . insert Lines ( ch . get Index ( ) + NUM_ , ch . get Children Added ( ) . length - ch . get Children Removed ( ) . length ) ; } } super . fire Insert Update ( evt ) ; }
private void tear Down All Connections ( ) { for ( Network Interface i : net ) { List < Connection > conns = i . get Connections ( ) ; if ( conns . size ( ) == NUM_ ) continue ; List < Network Interface > remove List = new Array List < Network Interface > ( conns . size ( ) ) ; for ( Connection con : conns ) { remove List . add ( con . get Other Interface ( i ) ) ; } for ( Network Interface inf : remove List ) { i . destroy Connection ( inf ) ; } } }
private final short validate Temp Split Factor ( String split Factor , short perm Duration In Minutes , short perm Split Factor ) throws Ade Flow Exception { short temp Split Factor = Short . parse Short ( split Factor ) ; if ( temp Split Factor <= NUM_ || ( perm Duration In Minutes % temp Split Factor != NUM_ ) ) { throw new Ade Flow Exception ( STR_ + STR_ + perm Duration In Minutes ) ; } return ( short ) ( temp Split Factor * perm Split Factor ) ; }
protected Handshake Message ( Inet Socket Address peer Address ) { super ( peer Address ) ; }
public static boolean use Set Mode To Hack Speaker ( ) { return ( is Samsung ( ) && ! is Samsung Galaxy Mini ( ) && get SDK Version ( ) <= NUM_ ) || s Build Model . equals Ignore Case ( STR_ ) || s Build Model . equals Ignore Case ( STR_ ) || s Build Model . equals Ignore Case ( STR_ ) || s Build Model . equals Ignore Case ( STR_ ) ; }
public Builder add String Derived Column ( String column Name , String format , Date Time Zone time Zone ) { derived Columns . add ( new Derived Column ( column Name , Column Type . String , format , time Zone , null ) ) ; return this ; }
public void free Load Balance ( ) { load Balance Allocate Count . decrement And Get ( ) ; }
public void mark For Pending Removal ( ) { m Pending Removal = true ; }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { s . write Object ( to String ( ) ) ; s . write Boolean ( values Case Sensitive ) ; }
public static String mk Stream Id ( String job Id , String oplet Id , int oport ) { Objects . require Non Null ( job Id , STR_ ) ; Objects . require Non Null ( oplet Id , STR_ ) ; if ( oport < NUM_ ) throw new Illegal Argument Exception ( STR_ ) ; return String . format ( STREAMID FMT , job Id , oplet Id , oport ) ; }
protected void load Url Rewriter ( Filter Config filter Config ) throws Servlet Exception { try { load Url Rewriter Local ( ) ; } catch ( Throwable e ) { log . error ( e ) ; throw new Servlet Exception ( e ) ; } }
protected int find Name Point ( String namespace URI , String name ) { if ( nodes == null ) return - NUM_ ; if ( name == null ) return - NUM_ ; final int size = nodes . size ( ) ; for ( int i = NUM_ ; i < size ; ++ i ) { Node Impl a = ( Node Impl ) nodes . get ( i ) ; String a Namespace URI = a . get Namespace URI ( ) ; String a Local Name = a . get Local Name ( ) ; if ( namespace URI == null ) { if ( a Namespace URI == null && ( name . equals ( a Local Name ) || ( a Local Name == null && name . equals ( a . get Node Name ( ) ) ) ) ) return i ; } else { if ( namespace URI . equals ( a Namespace URI ) && name . equals ( a Local Name ) ) return i ; } } return - NUM_ ; }
@ Deprecated public void update Cluster State ( ) throws Keeper Exception , Interrupted Exception { synchronized ( get Update Lock ( ) ) { if ( cluster State == null ) { create Cluster State Watchers And Update ( ) ; return ; } refresh Collection List ( null ) ; refresh Live Nodes ( null ) ; refresh Legacy Cluster State ( null ) ; Collection < String > safe Copy = new Array List < > ( watched Collection States . key Set ( ) ) ; Set < String > updated Collections = new Hash Set < > ( ) ; for ( String coll : safe Copy ) { Doc Collection new State = fetch Collection State ( coll , null ) ; if ( update Watched Collection ( coll , new State ) ) { updated Collections . add ( coll ) ; } } construct State ( updated Collections ) ; } }
private void init Paints ( Resources res ) { final String month Typeface = res . get String ( R . string . sp date picker month typeface ) ; final String day Of Week Typeface = res . get String ( R . string . sp date picker day of week typeface ) ; final String day Typeface = res . get String ( R . string . sp date picker day typeface ) ; final int month Text Size = res . get Dimension Pixel Size ( R . dimen . sp date picker month text size ) ; final int day Of Week Text Size = res . get Dimension Pixel Size ( R . dimen . sp date picker day of week text size ) ; final int day Text Size = res . get Dimension Pixel Size ( R . dimen . sp date picker day text size ) ; m Month Paint . set Anti Alias ( true ) ; m Month Paint . set Text Size ( month Text Size ) ; m Month Paint . set Typeface ( Typeface . create ( month Typeface , NUM_ ) ) ; m Month Paint . set Text Align ( Paint . Align . CENTER ) ; m Month Paint . set Style ( Paint . Style . FILL ) ; m Day Of Week Paint . set Anti Alias ( true ) ; m Day Of Week Paint . set Text Size ( day Of Week Text Size ) ; m Day Of Week Paint . set Typeface ( Typeface . create ( day Of Week Typeface , NUM_ ) ) ; m Day Of Week Paint . set Text Align ( Paint . Align . CENTER ) ; m Day Of Week Paint . set Style ( Paint . Style . FILL ) ; m Day Selector Paint . set Anti Alias ( true ) ; m Day Selector Paint . set Style ( Paint . Style . FILL ) ; m Day Highlight Paint . set Anti Alias ( true ) ; m Day Highlight Paint . set Style ( Paint . Style . FILL ) ; m Day Range Selector Paint . set Anti Alias ( true ) ; m Day Range Selector Paint . set Style ( Paint . Style . FILL ) ; m Day Paint . set Anti Alias ( true ) ; m Day Paint . set Text Size ( day Text Size ) ; m Day Paint . set Typeface ( Typeface . create ( day Typeface , NUM_ ) ) ; m Day Paint . set Text Align ( Paint . Align . CENTER ) ; m Day Paint . set Style ( Paint . Style . FILL ) ; }
private static void check Package Access ( Class type ) { Security Manager sm = System . get Security Manager ( ) ; if ( sm != null ) { String name = type . get Name ( ) ; int i = name . last Index Of ( STR_ ) ; if ( i != - NUM_ ) { sm . check Package Access ( name . substring ( NUM_ , i ) ) ; } } }
public static Long write Op CRC 32 ( String stream , byte [ ] payload ) { CRC 32 crc = request CRC . get ( ) ; try { crc . update ( stream . get Bytes ( ) ) ; crc . update ( payload ) ; return crc . get Value ( ) ; } finally { crc . reset ( ) ; } }
private void update Statistics ( ) { long current Time = System . current Time Millis ( ) ; double diff Time = current Time - last Time ; double diff Seed = current Seed - last Seed ; double diff NFE = current NFE - last NFE ; double percent NFE = Double . POSITIVE INFINITY ; double percent Time = Double . POSITIVE INFINITY ; if ( max NFE >= NUM_ ) { percent NFE = diff NFE / max NFE ; } if ( max Time >= NUM_ ) { percent Time = diff Time / max Time ; } double diff Percent = Math . min ( percent NFE , percent Time ) ; double percent Change = ( diff Seed + diff Percent ) / total Seeds ; if ( ( diff Time > NUM_ ) && ( percent Change > NUM_ ) ) { statistics . add Value ( diff Time / percent Change ) ; last Time = current Time ; last Seed = current Seed ; last NFE = current NFE ; } }
public static void release ( ) { pc Thread Local . set ( null ) ; }
private void log Input Volume ( Operator operator , Input Port port , int rows , int columns ) { log Volume ( TYPE INPUT VOLUME , operator , port , rows , columns ) ; }
private void update Types ( @ Nonnull Turnout Operation op ) { if ( ! initialized ) initialize ( ) ; Linked List < Turnout Operation > new Types = new Linked List < Turnout Operation > ( ) ; Iterator < Turnout Operation > iter = operation Types . iterator ( ) ; boolean found = false ; while ( iter . has Next ( ) ) { Turnout Operation item = iter . next ( ) ; if ( item . get Class ( ) == op . get Class ( ) ) { new Types . add ( op ) ; found = true ; log . debug ( STR_ + item . get Class ( ) ) ; } else { new Types . add ( item ) ; } } if ( ! found ) { new Types . add ( op ) ; log . debug ( STR_ + op . get Class ( ) ) ; } operation Types = new Types ; }
@ Transactional public void delete Work Flowfor Object ( final Map workflowsearchparams ) { final Criteria work Flow Crit = get Criteria For Deleteor Modify ( workflowsearchparams ) ; for ( final Work Flow Matrix matrix : ( List < Work Flow Matrix > ) work Flow Crit . list ( ) ) { workflow Matrix Repository . delete ( matrix ) ; } }
protected synchronized void clear Remaining Actions ( ) { for ( int i = active Action List . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Transit Section Action tsa = active Action List . get ( i ) ; Thread t = tsa . get Waiting Thread ( ) ; if ( t != null ) { t . interrupt ( ) ; } if ( tsa . get Waiting For Sensor ( ) ) { tsa . dispose Sensor Listener ( ) ; } tsa . initialize ( ) ; active Action List . remove ( i ) ; } }
@ Override public void create Redis App Key ( Application application , String docker Manager IP , String server Port , String server Manager Port ) { String suffix Cloud Unit = application . get Suffix Cloud Unit IO ( ) ; Jedis Pool pool = null ; Jedis jedis = null ; try { pool = new Jedis Pool ( new Jedis Pool Config ( ) , redis Ip , Integer . parse Int ( redis Port ) , NUM_ ) ; jedis = pool . get Resource ( ) ; String sub Name Space = concat Sub Name Space ( application ) ; String key = sub Name Space + suffix Cloud Unit ; String frontend = STR_ + key . to Lower Case ( ) ; jedis . rpush ( frontend , key . to Lower Case ( ) ) ; jedis . rpush ( frontend , STR_ + docker Manager IP + STR_ + server Port ) ; String frontend Server Manager = STR_ + key . to Lower Case ( ) ; jedis . rpush ( frontend Server Manager , key . to Lower Case ( ) ) ; jedis . rpush ( frontend Server Manager , STR_ + docker Manager IP + STR_ + server Manager Port ) ; } catch ( Jedis Connection Exception | Unsupported Encoding Exception e ) { logger . error ( STR_ , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }
private void draw Enabled Graphic ( Graphics 2 D g , int width , int height ) { Shape s = shape Generator . create Tab Close Icon ( NUM_ , NUM_ , width - NUM_ , height - NUM_ ) ; g . set Paint ( create Graphic Inner Shadow Gradient ( s ) ) ; g . fill ( s ) ; }
public Security Token Service Config ( Connection Config conn Config , X 509 Certificate [ ] trusted Issuer Certificates , Executor Service executor Service , Holder Of Key Config holder Of Key Config ) { Validate Util . validate Not Null ( conn Config , STR_ ) ; this . conn Config = conn Config ; this . trusted Issuer Certificates = trusted Issuer Certificates ; this . executor Service = ( executor Service != null ) ? executor Service : Executors . new Single Thread Executor ( ) ; this . holder Of Key Config = holder Of Key Config ; }
public Response Entity < List < Recommendation > > default Recommendations ( int product Id ) { LOG . warn ( STR_ ) ; return util . create Response ( Arrays . as List ( new Recommendation ( product Id , NUM_ , STR_ , NUM_ , STR_ ) ) , Http Status . OK ) ; }
protected void Create FD Array ( Offset Item fdarray Ref , Offset Item private Ref , int Font ) { Output List . add Last ( new Marker Item ( fdarray Ref ) ) ; Build Index Header ( NUM_ , NUM_ , NUM_ ) ; Offset Item private Index 1 Ref = new Index Offset Item ( NUM_ ) ; Output List . add Last ( private Index 1 Ref ) ; Index Base Item private Base = new Index Base Item ( ) ; Output List . add Last ( private Base ) ; int New Size = fonts [ Font ] . private Length ; int Org Subrs Offset Size = Calc Subr Offset Size ( fonts [ Font ] . private Offset , fonts [ Font ] . private Length ) ; if ( Org Subrs Offset Size != NUM_ ) New Size += NUM_ - Org Subrs Offset Size ; Output List . add Last ( new Dict Number Item ( New Size ) ) ; Output List . add Last ( private Ref ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM_ ) ) ; Output List . add Last ( new Index Marker Item ( private Index 1 Ref , private Base ) ) ; }
public boolean create Block Snapshot Rollback Step ( String step Id ) { Workflow Step Completer . step Executing ( step Id ) ; log . info ( String . format ( STR_ , step Id ) ) ; Workflow Step Completer . step Succeded ( step Id ) ; return true ; }
protected Object evaluate Left Equals Right ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new Array List ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . has Next ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof Structured Content ) { if ( ( o = evaluate Left Equals Right ( ( Structured Content ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == NUM_ ) { return ( Structured Content ) array . get ( NUM_ ) ; } return array ; }
private void add Debugger Listeners ( final I Debugger debugger ) { final Breakpoint Manager manager = debugger . get Breakpoint Manager ( ) ; manager . add Listener ( m breakpoint Manager Listener ) ; }
@ Benchmark public void no Coding ( ) { run ( ) ; }
public int rob ( Tree Node root ) { int [ ] res = dfs ( root ) ; return Math . max ( res [ NUM_ ] , res [ NUM_ ] ) ; }
public default Utility Table query Util ( B Network network , String query Var ) { return query Util ( new Query . Util Query ( network , Arrays . as List ( query Var ) , new Assignment ( ) ) ) ; }
public static boolean are Equal ( Bundle bundle 1 , Bundle bundle 2 ) { if ( bundle 1 == null ) { return bundle 2 == null ; } else if ( bundle 2 == null ) { return false ; } else if ( bundle 1 == bundle 2 ) { return true ; } Set < String > key Set = bundle 1 . key Set ( ) ; if ( ! key Set . equals ( bundle 2 . key Set ( ) ) ) { return false ; } for ( String key : key Set ) { Object value 1 = bundle 1 . get ( key ) ; Object value 2 = bundle 2 . get ( key ) ; if ( ! ( value 1 == null ? value 2 == null : value 1 . equals ( value 2 ) ) ) { return false ; } } return true ; }
public static File show Open File ( String [ ] extensions , Shell parent ) { return show Open File ( extensions , null , parent ) ; }
public void un Ban ( String the IP ) { my Ban List . remove ( the IP ) ; }
private void add Export Add Volume Steps ( Workflow workflow , Protection System rp System , URI export Group ID , Map < URI , Integer > snapshots ) throws Internal Exception { Export Group export Group = db Client . query Object ( Export Group . class , export Group ID ) ; String export Step = workflow . create Step Id ( ) ; init Task Status ( export Group , export Step , Operation . Status . pending , STR_ ) ; Map < URI , Map < URI , Integer > > storage To Block Objects = get Storage To Block Objects ( snapshots ) ; for ( Map . Entry < URI , Map < URI , Integer > > entry : storage To Block Objects . entry Set ( ) ) { log . info ( String . format ( STR_ , export Group . get Id ( ) , entry . get Key ( ) , entry . get Value ( ) ) ) ; export Wf Utils . generate Export Group Add Volumes ( workflow , null , STEP ENABLE IMAGE ACCESS , entry . get Key ( ) , export Group ID , entry . get Value ( ) ) ; } log . info ( STR_ + export Group . get Id ( ) ) ; }
private static int snap Horizontal ( Collection < Constraint Widget > widgets , Constraint Widget widget , Constraint Anchor anchor , int position , Array List < Snap Candidate > snap Candidates ) { Snap Candidate candidate = new Snap Candidate ( ) ; Constraint Handle handle = Widget Interaction Targets . constraint Handle ( anchor ) ; handle . set Draw X ( position ) ; Snap Placement . snap Anchor ( widgets , widget , anchor , candidate ) ; if ( candidate . target != null ) { Constraint Handle target Handle = Widget Interaction Targets . constraint Handle ( candidate . target ) ; int tx = candidate . x ; if ( target Handle != null ) { tx = target Handle . get Draw X ( ) ; } position = tx + candidate . margin ; snap Candidates . add ( candidate ) ; } return position ; }
public int min Cut ( String s ) { if ( s == null || s . length ( ) == NUM_ ) return NUM_ ; int len = s . length ( ) ; boolean [ ] [ ] p = new boolean [ len ] [ len ] ; for ( int i = NUM_ ; i < len ; i ++ ) Arrays . fill ( p [ i ] , false ) ; int [ ] results = new int [ len ] ; for ( int start = len - NUM_ ; start >= NUM_ ; start -- ) { results [ start ] = len - start - NUM_ ; for ( int end = start ; end < len ; end ++ ) { if ( s . char At ( start ) == s . char At ( end ) ) { if ( end - start < NUM_ ) p [ start ] [ end ] = true ; else p [ start ] [ end ] = p [ start + NUM_ ] [ end - NUM_ ] ; } if ( p [ start ] [ end ] ) { if ( end = len - NUM_ ) results [ start ] = NUM_ ; else results [ start ] = Math . min ( results [ start ] , results [ end + NUM_ ] + NUM_ ) ; } } } return results [ NUM_ ] ; }
private long acquire Read ( boolean interruptible , long deadline ) { W Node node = null , p ; for ( int spins = - NUM_ ; ; ) { W Node h ; if ( ( h = whead ) == ( p = wtail ) ) { for ( long m , s , ns ; ; ) { if ( ( m = ( s = state ) & ABITS ) < RFULL ? U . compare And Swap Long ( this , STATE , s , ns = s + RUNIT ) : ( m < WBIT && ( ns = try Inc Reader Overflow ( s ) ) != NUM_ ) ) return ns ; else if ( m >= WBIT ) { if ( spins > NUM_ ) { if ( Lock Support . next Secondary Seed ( ) >= NUM_ ) -- spins ; } else { if ( spins == NUM_ ) { W Node nh = whead , np = wtail ; if ( ( nh == h && np == p ) || ( h = nh ) != ( p = np ) ) break ; } spins = SPINS ; } } } } if ( p == null ) { W Node hd = new W Node ( WMODE , null ) ; if ( U . compare And Swap Object ( this , WHEAD , null , hd ) ) wtail = hd ; } else if ( node == null ) node = new W Node ( RMODE , p ) ; else if ( h == p || p . mode != RMODE ) { if ( node . prev != p ) node . prev = p ; else if ( U . compare And Swap Object ( this , WTAIL , p , node ) ) { p . next = node ; break ; } } else if ( ! U . compare And Swap Object ( p , WCOWAIT , node . cowait = p . cowait , node ) ) node . cowait = null ; else { for ( ; ; ) { W Node pp , c ; Thread w ; if ( ( h = whead ) != null && ( c = h . cowait ) != null && U . compare And Swap Object ( h , WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null ) U . unpark ( w ) ; if ( h == ( pp = p . prev ) || h == p || pp == null ) { long m , s , ns ; do { if ( ( m = ( s = state ) & ABITS ) < RFULL ? U . compare And Swap Long ( this , STATE , s , ns = s + RUNIT ) : ( m < WBIT && ( ns = try Inc Reader Overflow ( s ) ) != NUM_ ) ) return ns ; } while ( m < WBIT ) ; } if ( whead == h && p . prev == pp ) { long time ; if ( pp == null || h == p || p . status > NUM_ ) { node = null ; break ; } if ( deadline == NUM_ ) time = NUM_ ; else if ( ( time = deadline - System . nano Time ( ) ) <= NUM_ ) return cancel Waiter ( node , p , false ) ; Thread wt = Thread . current Thread ( ) ; U . put Object ( wt , PARKBLOCKER , this ) ; node . thread = wt ; if ( ( h != pp || ( state & ABITS ) == WBIT ) && whead == h && p . prev == pp ) U . park ( false , time ) ; node . thread = null ; U . put Object ( wt , PARKBLOCKER , null ) ; if ( interruptible && Thread . interrupted ( ) ) return cancel Waiter ( node , p , true ) ; } } } } for ( int spins = - NUM_ ; ; ) { W Node h , np , pp ; int ps ; if ( ( h = whead ) == p ) { if ( spins < NUM_ ) spins = HEAD SPINS ; else if ( spins < MAX HEAD SPINS ) spins <<= NUM_ ; for ( int k = spins ; ; ) { long m , s , ns ; if ( ( m = ( s = state ) & ABITS ) < RFULL ? U . compare And Swap Long ( this , STATE , s , ns = s + RUNIT ) : ( m < WBIT && ( ns = try Inc Reader Overflow ( s ) ) != NUM_ ) ) { W Node c ; Thread w ; whead = node ; node . prev = null ; while ( ( c = node . cowait ) != null ) { if ( U . compare And Swap Object ( node , WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null ) U . unpark ( w ) ; } return ns ; } else if ( m >= WBIT && Lock Support . next Secondary Seed ( ) >= NUM_ && -- k <= NUM_ ) break ; } } else if ( h != null ) { W Node c ; Thread w ; while ( ( c = h . cowait ) != null ) { if ( U . compare And Swap Object ( h , WCOWAIT , c , c . cowait ) && ( w = c . thread ) != null ) U . unpark ( w ) ; } } if ( whead == h ) { if ( ( np = node . prev ) != p ) { if ( np != null ) ( p = np ) . next = node ; } else if ( ( ps = p . status ) == NUM_ ) U . compare And Swap Int ( p , WSTATUS , NUM_ , WAITING ) ; else if ( ps == CANCELLED ) { if ( ( pp = p . prev ) != null ) { node . prev = pp ; pp . next = node ; } } else { long time ; if ( deadline == NUM_ ) time = NUM_ ; else if ( ( time = deadline - System . nano Time ( ) ) <= NUM_ ) return cancel Waiter ( node , node , false ) ; Thread wt = Thread . current Thread ( ) ; U . put Object ( wt , PARKBLOCKER , this ) ; node . thread = wt ; if ( p . status < NUM_ && ( p != h || ( state & ABITS ) == WBIT ) && whead == h && node . prev == p ) U . park ( false , time ) ; node . thread = null ; U . put Object ( wt , PARKBLOCKER , null ) ; if ( interruptible && Thread . interrupted ( ) ) return cancel Waiter ( node , node , true ) ; } } } }
public int alloc ( int size ) { int index = n ; int len = array . length ; if ( n + size >= len ) { byte [ ] aux = new byte [ len + block Size ] ; System . arraycopy ( array , NUM_ , aux , NUM_ , len ) ; array = aux ; } n += size ; return index ; }
protected void update Throttle ( ) { long now = Current Time . get Current Time Actual ( ) ; if ( throttle Timestamp + throttle Period < now ) { throttle Timestamp = now ; throttle Count = NUM_ ; is Throttle = false ; return ; } throttle Count ++ ; if ( throttle Count < throttle Limit ) { return ; } if ( ! is Throttle ) { is Throttle = true ; if ( throttle Sleep > NUM_ || log . is Loggable ( Level . FINE ) ) { String msg = ( this + STR_ + throttle Count + STR_ + throttle Period + STR_ + STR_ + throttle Sleep + STR_ ) ; on Throttle ( msg ) ; } } if ( throttle Sleep > NUM_ ) { try { Thread . sleep ( throttle Sleep ) ; } catch ( Exception e ) { } } }
private void make Tree ( int nstep ) { for ( Enumeration < Body > e = bodies Rev ( ) ; e . has More Elements ( ) ; ) { Body q = e . next Element ( ) ; if ( q . mass != NUM_ ) { q . expand Box ( this , nstep ) ; Math Vector xqic = intcoord ( q . pos ) ; if ( root == null ) { root = q ; } else { root = root . load Tree ( q , xqic , Node . IMAX > > NUM_ , this ) ; } } } root . hackcofm ( ) ; }
private float calculate Base Page Target Y ( Panel State expanded State ) { if ( ! is Fullscreen Size Panel ( ) ) return NUM_ ; final float selection Y = m Base Page Selection Y Px * m Px To Dp ; final float expanded Height = get Panel Height From State ( expanded State ) - m Search Bar Padding Top ; final float fullscreen Height = get Fullscreen Height ( ) ; final float available Height = fullscreen Height - expanded Height ; float offset = - selection Y + available Height / NUM_ ; offset = Math . min ( offset , NUM_ ) ; if ( m Is Toolbar Showing ) offset -= m Toolbar Height ; offset = Math . max ( offset , - expanded Height ) ; return offset ; }
public static File show Open File ( File Data Store Factory Spi format , Shell parent ) { return show Open File ( format , null , parent ) ; }
public Js Optimizer add Input ( Statement stmt ) { comp Units . add ( stmt ) ; return this ; }
public static void update Provider Key Info ( String realm , String entity ID , String cert Alias , boolean is Signing , boolean is IDP , String enc Algo , int key Size ) throws IDFF Meta Exception { IDFF Meta Manager meta Manager = FS Utils . get IDFF Meta Manager ( ) ; Entity Config Element config = meta Manager . get Entity Config ( realm , entity ID ) ; if ( ! config . is Hosted ( ) ) { String [ ] args = { entity ID , realm } ; throw new IDFF Meta Exception ( STR_ , args ) ; } Entity Descriptor Element desp = meta Manager . get Entity Descriptor ( realm , entity ID ) ; if ( is IDP ) { IDP Descriptor Config Element idp Config = IDFF Meta Utils . get IDP Descriptor Config ( config ) ; IDP Descriptor Type idp Desp = IDFF Meta Utils . get IDP Descriptor ( desp ) ; if ( ( idp Config == null ) || ( idp Desp == null ) ) { String [ ] args = { entity ID , realm } ; throw new IDFF Meta Exception ( STR_ , args ) ; } if ( ( cert Alias == null ) || ( cert Alias . length ( ) == NUM_ ) ) { remove Key Descriptor ( idp Desp , is Signing ) ; if ( is Signing ) { set Extended Attribute Value ( idp Config , IFS Constants . SIGNING CERT ALIAS , null ) ; } else { set Extended Attribute Value ( idp Config , IFS Constants . ENCRYPTION CERT ALIAS , null ) ; } } else { Key Descriptor Element kde = get Key Descriptor ( cert Alias , is Signing , enc Algo , key Size ) ; update Key Descriptor ( idp Desp , kde ) ; Set value = new Hash Set ( ) ; value . add ( cert Alias ) ; if ( is Signing ) { set Extended Attribute Value ( idp Config , IFS Constants . SIGNING CERT ALIAS , value ) ; } else { set Extended Attribute Value ( idp Config , IFS Constants . ENCRYPTION CERT ALIAS , value ) ; } } meta Manager . set Entity Descriptor ( realm , desp ) ; meta Manager . set Entity Config ( realm , config ) ; } else { SP Descriptor Config Element sp Config = IDFF Meta Utils . get SP Descriptor Config ( config ) ; SP Descriptor Type sp Desp = IDFF Meta Utils . get SP Descriptor ( desp ) ; if ( ( sp Config == null ) || ( sp Desp == null ) ) { String [ ] args = { entity ID , realm } ; throw new IDFF Meta Exception ( STR_ , args ) ; } if ( ( cert Alias == null ) || ( cert Alias . length ( ) == NUM_ ) ) { remove Key Descriptor ( sp Desp , is Signing ) ; if ( is Signing ) { set Extended Attribute Value ( sp Config , IFS Constants . SIGNING CERT ALIAS , null ) ; } else { set Extended Attribute Value ( sp Config , IFS Constants . ENCRYPTION CERT ALIAS , null ) ; } } else { Key Descriptor Element kde = get Key Descriptor ( cert Alias , is Signing , enc Algo , key Size ) ; update Key Descriptor ( sp Desp , kde ) ; Set value = new Hash Set ( ) ; value . add ( cert Alias ) ; if ( is Signing ) { set Extended Attribute Value ( sp Config , IFS Constants . SIGNING CERT ALIAS , value ) ; } else { set Extended Attribute Value ( sp Config , IFS Constants . ENCRYPTION CERT ALIAS , value ) ; } } meta Manager . set Entity Descriptor ( realm , desp ) ; meta Manager . set Entity Config ( realm , config ) ; } }
public static String load Digestes ( Jar File jar File , Jar Entry je ) throws Exception { Input Stream bis = null ; String Builder sb = new String Builder ( ) ; try { Input Stream is = jar File . get Input Stream ( je ) ; byte [ ] bytes = new byte [ Share Constants . BUFFER SIZE ] ; bis = new Buffered Input Stream ( is ) ; int read Bytes ; while ( ( read Bytes = bis . read ( bytes ) ) > NUM_ ) { sb . append ( new String ( bytes , NUM_ , read Bytes ) ) ; } } finally { close Quietly ( bis ) ; } return sb . to String ( ) ; }
private void rebuild ( ) { List < Search Result Data Line > existing = new Array List < Search Result Data Line > ( list ) ; List < Search Result Data Line > hidden = new Array List < Search Result Data Line > ( HIDDEN ) ; simple Clear ( ) ; if ( is Sorted ( ) ) { for ( int i = NUM_ ; i < existing . size ( ) ; i ++ ) { add Sorted ( existing . get ( i ) ) ; } } else { for ( int i = NUM_ ; i < existing . size ( ) ; i ++ ) { add ( existing . get ( i ) ) ; } } Map < String , Search Result Data Line > merge Map = new Hash Map < String , Search Result Data Line > ( ) ; for ( int i = NUM_ ; i < hidden . size ( ) ; i ++ ) { Search Result Data Line tl = hidden . get ( i ) ; if ( is Sorted ( ) ) { add Sorted ( tl ) ; } else { add ( tl ) ; } } if ( is Sorted ( ) ) { for ( Search Result Data Line line : merge Map . values ( ) ) add Sorted ( line ) ; } else { for ( Search Result Data Line line : merge Map . values ( ) ) add ( line ) ; } }
public static < D extends Generic Declaration > Annotated Type [ ] parse Annotated Bounds ( Type [ ] bounds , D decl , int type Var Index ) { return parse Annotated Bounds ( bounds , decl , type Var Index , Location Info . BASE LOCATION ) ; }
private void merge Sections ( ) { if ( m Merge Algorithm == null || m Num Apps Per Row == NUM_ ) { return ; } if ( ! has Filter ( ) ) { int section App Count = NUM_ ; for ( int i = NUM_ ; i < m Sections . size ( ) - NUM_ ; i ++ ) { Section Info section = m Sections . get ( i ) ; section App Count = section . num Apps ; int merge Count = NUM_ ; while ( i < ( m Sections . size ( ) - NUM_ ) && m Merge Algorithm . continue Merging ( section , m Sections . get ( i + NUM_ ) , section App Count , m Num Apps Per Row , merge Count ) ) { Section Info next Section = m Sections . remove ( i + NUM_ ) ; m Adapter Items . remove ( next Section . section Break Item ) ; int pos = m Adapter Items . index Of ( section . first App Item ) ; int next Pos = pos + section . num Apps ; for ( int j = next Pos ; j < ( next Pos + next Section . num Apps ) ; j ++ ) { Adapter Item item = m Adapter Items . get ( j ) ; item . section Info = section ; item . section App Index += section . num Apps ; } pos = m Adapter Items . index Of ( next Section . first App Item ) ; for ( int j = pos ; j < m Adapter Items . size ( ) ; j ++ ) { Adapter Item item = m Adapter Items . get ( j ) ; item . position -- ; } section . num Apps += next Section . num Apps ; section App Count += next Section . num Apps ; if ( DEBUG ) { Log . d ( TAG , STR_ + next Section . first App Item . section Name + STR_ + section . first App Item . section Name + STR_ + ( section App Count / m Num Apps Per Row ) ) ; } merge Count ++ ; } } } }
void await All Acks Received ( Ignite Uuid file Id ) throws Ignite Interrupted Checked Exception { Write Completion Future fut = pending Writes . get ( file Id ) ; if ( fut != null ) fut . await All Acks Received ( ) ; }
public static synchronized boolean execute ( String sql Statement ) { boolean execute Ok = false ; logger . trace ( String . format ( STR_ , sql Statement ) ) ; final Statement S = get Statement ( ) ; if ( S == null ) { logger . error ( STR_ ) ; return false ; } try { execute Ok = S . execute ( sql Statement ) ; } catch ( Throwable t ) { surface Throwable ( String . format ( STR_ , sql Statement ) , t ) ; } finally { cleanup ( S ) ; } logger . trace ( STR_ + execute Ok ) ; return execute Ok ; }
private void schedule Send ( final int queue Size ) { if ( pending ) { return ; } if ( queue Size >= batch Size ) { enqueue Send ( ) ; return ; } if ( scheduled . compare And Set ( false , true ) ) { try { scheduler . schedule ( null , max Latency Ms , MILLISECONDS ) ; scheduler Queue Size . increment And Get ( ) ; } catch ( Rejected Execution Exception ignore ) { } } }
protected void parse Config Parameters ( Properties prop ) { if ( prop == null ) return ; Enumeration < ? > e = prop . property Names ( ) ; while ( e . has More Elements ( ) ) { String key = ( String ) e . next Element ( ) ; String config Value = null ; int last Period = key . last Index Of ( STR_ ) ; String module Name = key . substring ( NUM_ , last Period ) ; String config Key = key . substring ( last Period + NUM_ ) ; String system Key = System . get Property ( key ) ; if ( system Key != null ) { config Value = system Key ; } else { config Value = prop . get Property ( key ) ; } I Floodlight Module mod = module Name Map . get ( module Name ) ; if ( mod == null ) { logger . debug ( STR_ + STR_ , new Object [ ] { module Name , config Key , config Value } ) ; } else { logger . debug ( STR_ , new Object [ ] { config Key , config Value , module Name } ) ; floodlight Module Context . add Config Param ( mod , config Key , config Value ) ; } } }
public static Calendar reduce Calendar Min ( Calendar calendar ) { int rounded Hours = Math . round ( calendar . get ( Calendar . MINUTE ) / NUM_ ) ; calendar . add ( Calendar . HOUR , rounded Hours ) ; calendar . set ( Calendar . MILLISECOND , NUM_ ) ; calendar . set ( Calendar . SECOND , NUM_ ) ; calendar . set ( Calendar . MINUTE , NUM_ ) ; return calendar ; }
public void add To Forward List ( Entry Point ep ) { if ( ep != null ) { m Forward Entry Points . add ( ep ) ; } }
private Class read Value ( Type type , Node Map node ) throws Exception { Node entry = node . remove ( label ) ; Class expect = type . get Type ( ) ; if ( expect . is Array ( ) ) { expect = expect . get Component Type ( ) ; } if ( entry != null ) { String name = entry . get Value ( ) ; expect = loader . load ( name ) ; } return expect ; }
private static void append Float Type ( String Builder sb ) { sb . append ( STR_ ) ; }
private void reset ( ) throws IO Exception { http . reuse = true ; reuse Client = http ; Input Stream is = http . get Input Stream ( ) ; if ( ! method . equals ( STR_ ) ) { try { if ( ( is instanceof Chunked Input Stream ) || ( is instanceof Metered Stream ) ) { while ( is . read ( cdata ) > NUM_ ) { } } else { long cl = NUM_ ; int n = NUM_ ; String cls = responses . find Value ( STR_ ) ; if ( cls != null ) { try { cl = Long . parse Long ( cls ) ; } catch ( Number Format Exception e ) { cl = NUM_ ; } } for ( long i = NUM_ ; i < cl ; ) { if ( ( n = is . read ( cdata ) ) == - NUM_ ) { break ; } else { i += n ; } } } } catch ( IO Exception e ) { http . reuse = false ; reuse Client = null ; disconnect Internal ( ) ; return ; } try { if ( is instanceof Metered Stream ) { is . close ( ) ; } } catch ( IO Exception e ) { } } response Code = - NUM_ ; responses = new Message Header ( ) ; connected = false ; }
public long range Count ( final boolean exact , final Resource s , final URI p , final Value o , final Resource ... c ) throws Exception { if ( c == null ) { throw new Illegal Argument Exception ( ) ; } final UUID uuid = UUID . random UUID ( ) ; final Connect Options opts = mgr . new Query Connect Options ( sparql Endpoint URL , uuid , tx ) ; opts . add Request Param ( STR_ ) ; if ( exact ) { opts . add Request Param ( STR_ , STR_ ) ; } if ( s != null ) { opts . add Request Param ( STR_ , Encode Decode Value . encode Value ( s ) ) ; } if ( p != null ) { opts . add Request Param ( STR_ , Encode Decode Value . encode Value ( p ) ) ; } if ( o != null ) { opts . add Request Param ( STR_ , Encode Decode Value . encode Value ( o ) ) ; } opts . add Request Param ( STR_ , Encode Decode Value . encode Contexts ( c ) ) ; Jetty Response Listener resp = null ; try { opts . set Accept Header ( Connect Options . MIME APPLICATION XML ) ; check Response Code ( resp = do Connect ( opts ) ) ; final Range Count Result result = range Count Results ( resp ) ; return result . range Count ; } finally { if ( resp != null ) resp . abort ( ) ; } }
@ Not Null static Bytes < byte [ ] > expect ( @ Not Null String text ) { return expect ( wrap For Read ( text . get Bytes ( Standard Charsets . ISO 8859 1 ) ) ) ; }
public synchronized void write To SUT ( byte b ) { local Buffer . add ( b ) ; }
@ Override protected void clone Content ( Named Node Map Impl srcmap ) { List srcnodes = srcmap . nodes ; if ( srcnodes != null ) { int size = srcnodes . size ( ) ; if ( size != NUM_ ) { if ( nodes == null ) { nodes = new Array List ( size ) ; } else { nodes . clear ( ) ; } for ( int i = NUM_ ; i < size ; ++ i ) { Node Impl n = ( Node Impl ) srcnodes . get ( i ) ; Node Impl clone = ( Node Impl ) n . clone Node ( true ) ; clone . is Specified ( n . is Specified ( ) ) ; nodes . add ( clone ) ; clone . owner Node = owner Node ; clone . is Owned ( true ) ; } } } }
public void initialize ( String key , String salt ) throws Illegal Argument Exception , No Such Algorithm Exception { if ( ! is Valid Arg Key ( key ) ) { throw new Illegal Argument Exception ( INIT ILLEGAL ARG KEY ) ; } else { this . key = key ; } if ( ! is Valid Arg ( salt ) ) { throw new Illegal Argument Exception ( INIT ILLEGAL ARG SALT ) ; } else { this . salt = hex String To Byte Array ( salt ) ; } this . iv = new byte [ NUM_ ] ; secure Random = Secure Random . get Instance ( SECURE RANDOM ALGORITHM ) ; iv Parameter Spec = new Iv Parameter Spec ( this . iv ) ; }
private static float determine Enemy Blitz Strength ( final Territory blitz Here , final List < Route > blitz Terr Routes , final List < Territory > block Terr , final Game Data data , final Player ID e Player ) { final Hash Set < Integer > ignore = new Hash Set < > ( ) ; ignore . add ( NUM_ ) ; final Composite Match < Unit > blitz Unit = new Composite Match And < > ( Matches . unit Is Owned By ( e Player ) , Matches . Unit Can Blitz , Matches . Unit Can Move ) ; final Composite Match < Territory > valid Blitz Route = new Composite Match And < > ( Matches . territory Has No Enemy Units ( e Player , data ) , Matches . Territory Is Not Impassable To Land Units ( e Player , data ) ) ; final List < Route > routes = new Array List < > ( ) ; final List < Unit > blitz Units = find Attackers ( blitz Here , NUM_ , ignore , e Player , data , blitz Unit , valid Blitz Route , block Terr , routes , false ) ; for ( final Route r : routes ) { if ( r . number Of Steps ( ) == NUM_ ) { blitz Terr Routes . add ( r ) ; } } return strength ( blitz Units , true , false , true ) ; }
public static Refresh Token Credentials create ( Oauth Client oauth Config , String refresh Token Secret , String token Exchange Url ) { Refresh Request Factory request Factory = new Refresh Request Factory ( ) ; Clock clock = Clock . system Default Zone ( ) ; return new Refresh Token Credentials ( request Factory , refresh Token Secret , token Exchange Url , oauth Config , clock ) ; }
public Recognition Request ( String ... urls ) { for ( String url : urls ) { items . add ( new Item ( url ) ) ; } }
static byte [ ] to Bytes ( String source ) { try { return source . get Bytes ( STR_ ) ; } catch ( Unsupported Encoding Exception e ) { throw new Illegal Argument Exception ( e . get Message ( ) ) ; } }
public Tagged Input Stream ( Input Stream proxy ) { super ( proxy ) ; }
@ Nullable public static XML Gregorian Calendar create XML Gregorian Calendar ( ) { XML Gregorian Calendar result = null ; try { Datatype Factory datatype Factory = Datatype Factory . new Instance ( ) ; Time Zone utc = Time Zone . get Time Zone ( STR_ ) ; Gregorian Calendar now = new Gregorian Calendar ( utc ) ; result = datatype Factory . new XML Gregorian Calendar ( now ) ; } catch ( Datatype Configuration Exception e ) { throw new IMF Exception ( STR_ ) ; } return result ; }
public Multiway Pool Builder < K , R > expire After Write ( long duration , Time Unit unit ) { check State ( expire After Write Nanos == UNSET INT , STR_ , expire After Write Nanos ) ; check Argument ( duration >= NUM_ , STR_ , duration , unit ) ; expire After Write Nanos = unit . to Nanos ( duration ) ; return this ; }
public static double incomplete Beta Fraction 1 ( double a , double b , double x ) { double xk , pk , pkm 1 , pkm 2 , qk , qkm 1 , qkm 2 ; double k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 ; double r , t , ans , thresh ; int n ; k 1 = a ; k 2 = a + b ; k 3 = a ; k 4 = a + NUM_ ; k 5 = NUM_ ; k 6 = b - NUM_ ; k 7 = k 4 ; k 8 = a + NUM_ ; pkm 2 = NUM_ ; qkm 2 = NUM_ ; pkm 1 = NUM_ ; qkm 1 = NUM_ ; ans = NUM_ ; r = NUM_ ; n = NUM_ ; thresh = NUM_ * MACHEP ; do { xk = - ( x * k 1 * k 2 ) / ( k 3 * k 4 ) ; pk = pkm 1 + pkm 2 * xk ; qk = qkm 1 + qkm 2 * xk ; pkm 2 = pkm 1 ; pkm 1 = pk ; qkm 2 = qkm 1 ; qkm 1 = qk ; xk = ( x * k 5 * k 6 ) / ( k 7 * k 8 ) ; pk = pkm 1 + pkm 2 * xk ; qk = qkm 1 + qkm 2 * xk ; pkm 2 = pkm 1 ; pkm 1 = pk ; qkm 2 = qkm 1 ; qkm 1 = qk ; if ( qk != NUM_ ) { r = pk / qk ; } if ( r != NUM_ ) { t = Math . abs ( ( ans - r ) / r ) ; ans = r ; } else { t = NUM_ ; } if ( t < thresh ) { return ans ; } k 1 += NUM_ ; k 2 += NUM_ ; k 3 += NUM_ ; k 4 += NUM_ ; k 5 += NUM_ ; k 6 -= NUM_ ; k 7 += NUM_ ; k 8 += NUM_ ; if ( ( Math . abs ( qk ) + Math . abs ( pk ) ) > big ) { pkm 2 *= biginv ; pkm 1 *= biginv ; qkm 2 *= biginv ; qkm 1 *= biginv ; } if ( ( Math . abs ( qk ) < biginv ) || ( Math . abs ( pk ) < biginv ) ) { pkm 2 *= big ; pkm 1 *= big ; qkm 2 *= big ; qkm 1 *= big ; } } while ( ++ n < NUM_ ) ; return ans ; }
public static int parse Code Point ( String s ) throws Number Format Exception { return Integer . parse Int ( s , NUM_ ) ; }
private void execute Without Transaction ( final Executor exec , Command command ) throws Exception { Exception cause = null ; for ( int i = NUM_ ; i < MAXIMUM NUM RETRIES ; i ++ ) { try { exec . execute Command ( command , this ) ; return ; } catch ( Exception e ) { cause = e ; if ( e instanceof Region Destroyed Exception || e instanceof Region Not Found Exception || e . get Cause ( ) instanceof Query Invocation Target Exception ) Thread . sleep ( WAIT REGION DSTRYD MILLIS ) ; } } throw cause ; }
public static void validate SOAP Header ( SOAP Header soap Header ) { Set < Q Name > fields = new Hash Set < > ( ) ; Iterator < ? > it = soap Header . get Child Elements ( ) ; while ( it . has Next ( ) ) { Object next = it . next ( ) ; if ( next instanceof SOAP Element ) { SOAP Element soap Element = ( SOAP Element ) next ; if ( ! fields . add ( soap Element . get Element Q Name ( ) ) ) { throw new Coded Exception ( X DUPLICATE HEADER FIELD , STR_ , soap Element . get Element Q Name ( ) ) ; } } } }
public void compact Buffer ( ) { if ( offset != buffer . length ) { byte [ ] new Buffer = new byte [ offset ] ; System . arraycopy ( buffer , NUM_ , new Buffer , NUM_ , offset ) ; buffer = new Buffer ; } }
public void remove Item Listener ( Item Listener a Listener ) { listener List . remove ( Item Listener . class , a Listener ) ; }
public void group By ( String column ) throws Query Plan Exception { this . group By Column = column ; }
public synchronized boolean image Update ( Image img , int info Flags , int x , int y , int width , int height ) { boolean got Info = false ; if ( ( info Flags & ( WIDTH | HEIGHT ) ) != NUM_ ) { got Info = true ; notify ( ) ; } return got Info ; }
public void add Include Directory ( String directory ) throws IO Exception { if ( ! String Utils . is Empty ( directory ) ) { File dir = new File ( directory ) ; if ( ! dir . exists ( ) || ! dir . is Directory ( ) ) { throw new IO Exception ( STR_ + dir . get Absolute Path ( ) ) ; } include Directories . add ( dir ) ; } }
private void fix End Window Dequeue Times Before Deactivate ( ) { long end Window Dequeue Time = System . current Time Millis ( ) ; for ( Sweepable Reservoir sr : inputs . values ( ) ) { if ( end Window Dequeue Times . get ( sr ) == null ) { end Window Dequeue Times . put ( sr , end Window Dequeue Time ) ; } } }
public void check Career Records ( League Records records ) { for ( Player p : players Leaving ) { if ( p instanceof Player QB ) { Player QB qb = ( Player QB ) p ; records . check Record ( STR_ , qb . stats Pass Yards + qb . career Pass Yards , abbr + STR_ + qb . get Initial Name ( ) , league . get Year ( ) - NUM_ ) ; records . check Record ( STR_ , qb . stats TD + qb . career T Ds , abbr + STR_ + qb . get Initial Name ( ) , league . get Year ( ) - NUM_ ) ; records . check Record ( STR_ , qb . stats Int + qb . career Int , abbr + STR_ + qb . get Initial Name ( ) , league . get Year ( ) - NUM_ ) ; } else if ( p instanceof Player RB ) { Player RB rb = ( Player RB ) p ; records . check Record ( STR_ , rb . stats Rush Yards + rb . career Rush Yards , abbr + STR_ + rb . get Initial Name ( ) , league . get Year ( ) - NUM_ ) ; records . check Record ( STR_ , rb . stats TD + rb . career T Ds , abbr + STR_ + rb . get Initial Name ( ) , league . get Year ( ) - NUM_ ) ; records . check Record ( STR_ , rb . stats Fumbles + rb . career Fumbles , abbr + STR_ + rb . get Initial Name ( ) , league . get Year ( ) - NUM_ ) ; } else if ( p instanceof Player WR ) { Player WR wr = ( Player WR ) p ; records . check Record ( STR_ , wr . stats Rec Yards + wr . career Rec Yards , abbr + STR_ + wr . get Initial Name ( ) , league . get Year ( ) - NUM_ ) ; records . check Record ( STR_ , wr . stats TD + wr . career TD , abbr + STR_ + wr . get Initial Name ( ) , league . get Year ( ) - NUM_ ) ; } } }
public static void main ( String [ ] args ) { int option = Integer . parse Int ( args [ NUM_ ] ) ; Grid Type grid Type = Grid Type . value Of ( args [ NUM_ ] ) ; Kde Type kde Type = Kde Type . value Of ( args [ NUM_ ] ) ; Grid Example example = new Grid Example ( option , grid Type , kde Type ) ; example . run ( ) ; try { Analysis Launcher . open ( example ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( STR_ ) ; } }
Line On Other Info line On Other ( Display Side my Side , int line ) { List < Line Gap > line Gaps = gap List ( my Side ) ; int ret = Collections . binary Search ( line Gaps , new Line Gap ( line ) ) ; if ( ret == - NUM_ ) { return new Line On Other Info ( line , true ) ; } Line Gap lookup = line Gaps . get ( NUM_ <= ret ? ret : - ret - NUM_ ) ; int start = lookup . start ; int end = lookup . end ; int delta = lookup . delta ; if ( start <= line && line <= end && end != - NUM_ ) { return new Line On Other Info ( end + delta , false ) ; } return new Line On Other Info ( line + delta , true ) ; }
public boolean is Equivalent ( Transaction transaction ) { return m Id . equals ( transaction . m Id ) ; }
public static void dump ( String context , Key Store key Store , char [ ] key Password ) throws Key Store Exception , No Such Algorithm Exception { Print Stream out = System . out ; out . println ( STR_ + context ) ; out . println ( STR_ + key Store ) ; out . println ( STR_ + key Store . get Type ( ) ) ; out . println ( STR_ + key Store . get Provider ( ) ) ; out . println ( STR_ + ( ( key Password == null ) ? null : new String ( key Password ) ) ) ; out . println ( STR_ + key Store . size ( ) ) ; for ( String alias : Collections . list ( key Store . aliases ( ) ) ) { out . println ( STR_ + alias ) ; out . println ( STR_ + key Store . get Creation Date ( alias ) ) ; if ( key Store . is Certificate Entry ( alias ) ) { out . println ( STR_ ) ; out . println ( STR_ ) ; out . println ( key Store . get Certificate ( alias ) ) ; out . println ( STR_ ) ; continue ; } if ( key Store . is Key Entry ( alias ) ) { out . println ( STR_ ) ; out . println ( STR_ ) ; String key ; try { key = ( STR_ + key Store . get Key ( alias , key Password ) ) ; } catch ( Unrecoverable Key Exception e 1 ) { try { key = ( STR_ + key Store . get Key ( alias , null ) ) ; } catch ( Unrecoverable Key Exception e 2 ) { key = STR_ ; } } out . println ( key ) ; out . println ( STR_ ) ; Certificate [ ] chain = key Store . get Certificate Chain ( alias ) ; if ( chain == null ) { out . println ( STR_ ) ; out . println ( STR_ ) ; } else { for ( int i = NUM_ ; i < chain . length ; i ++ ) { out . println ( STR_ + i ) ; out . println ( chain [ i ] ) ; out . println ( STR_ ) ; } } continue ; } out . println ( STR_ ) ; } }
protected Date compute ( double value , String locale String ) { if ( Double . is Na N ( value ) || locale String == null ) { return null ; } Locale locale = new Locale ( locale String ) ; long date Long = ( long ) value ; Date date = new Date ( date Long ) ; Calendar cal = Calendar . get Instance ( locale ) ; cal . set Time ( date ) ; return cal . get Time ( ) ; }
private void release Useless Resources ( ) { offline Processor . destroy ( ) ; offline Processor = null ; I Figure Manager . clean Cache ( ) ; System . gc ( ) ; }
public SSL Socket Factory build SSL Socket Factory ( ) throws Key Store Exception { SSL Context ssl Context = null ; try { Key Manager Factory key Manager Factory = Key Manager Factory . get Instance ( Key Manager Factory . get Default Algorithm ( ) ) ; key Manager Factory . init ( key Store , SSL KEYSTORE SECRET ) ; Key Manager [ ] key Managers = key Manager Factory . get Key Managers ( ) ; Trust Manager [ ] trust Managers = new Trust Manager [ ] { create Trust Manager From Default JDK Trust Store ( ) } ; ssl Context = SSL Context . get Instance ( STR_ ) ; ssl Context . init ( key Managers , trust Managers , null ) ; SSL Context . set Default ( ssl Context ) ; } catch ( General Security Exception | IO Exception e ) { throw new Key Store Exception ( STR_ , e ) ; } return ssl Context . get Socket Factory ( ) ; }
@ Override public void do Run Keys ( int run ) throws Exception { Object [ ] template = determine Template ( run ) ; String [ ] new Key = new String [ template . length - NUM_ ] ; System . arraycopy ( template , NUM_ , new Key , NUM_ , m Key Index ) ; System . arraycopy ( template , m Key Index + NUM_ , new Key , m Key Index , template . length - m Key Index - NUM_ ) ; m Result Listener . accept Result ( this , new Key , null ) ; }
private String generate Port Name ( ) { String Buffer port Name = new String Buffer ( STR_ ) ; int port Count = all Storage Ports List . size ( ) ; port Name = port Name . append ( String . value Of ( port Count - NUM_ ) ) ; return port Name . to String ( ) ; }
@ Override public List < Validation Error > validate ( ) { List < Validation Error > error List = new Array List < Validation Error > ( ) ; remove Empty Rates ( ) ; if ( ( error List = check For No Rates Present ( ) ) != null ) return error List ; if ( ( error List = validate Overhead Rates ( ) ) != null ) return error List ; if ( ( error List = validate Date Ranges ( ) ) != null ) return error List ; return error List ; }
protected final Json Token handle Field Name ( ) throws IO Exception { if ( input Ptr >= input End ) { load More Guaranteed ( ) ; } int ch = input Buffer [ input Ptr ++ ] & NUM_ ; type As Int = ch ; switch ( ch > > NUM_ ) { case NUM_ : switch ( ch ) { case NUM_ : parsing Context . set Current Name ( STR_ ) ; return Json Token . FIELD NAME ; case NUM_ : case NUM_ : case NUM_ : case NUM_ : if ( input Ptr >= input End ) { load More Guaranteed ( ) ; } { int index = ( ( ch & NUM_ ) << NUM_ ) + ( input Buffer [ input Ptr ++ ] & NUM_ ) ; if ( index >= seen Name Count ) { report Invalid Shared Name ( index ) ; } parsing Context . set Current Name ( seen Names [ index ] ) ; } return Json Token . FIELD NAME ; case NUM_ : handle Long Field Name ( ) ; return Json Token . FIELD NAME ; } break ; case NUM_ : { int index = ( ch & NUM_ ) ; if ( index >= seen Name Count ) { report Invalid Shared Name ( index ) ; } parsing Context . set Current Name ( seen Names [ index ] ) ; } return Json Token . FIELD NAME ; case NUM_ : { int len = NUM_ + ( ch & NUM_ ) ; String name = find Decoded From Symbols ( len ) ; if ( name != null ) { input Ptr += len ; } else { name = decode Short Ascii Name ( len ) ; name = add Decoded To Symbols ( len , name ) ; } if ( seen Names != null ) { if ( seen Name Count >= seen Names . length ) { seen Names = expand Seen Names ( seen Names ) ; } seen Names [ seen Name Count ++ ] = name ; } parsing Context . set Current Name ( name ) ; } return Json Token . FIELD NAME ; case NUM_ : ch &= NUM_ ; { if ( ch > NUM_ ) { if ( ch == NUM_ ) { if ( ! parsing Context . in Object ( ) ) { report Mismatched End Marker ( STR_ , STR_ ) ; } parsing Context = parsing Context . get Parent ( ) ; return Json Token . END OBJECT ; } } else { final int len = ch + NUM_ ; String name = find Decoded From Symbols ( len ) ; if ( name != null ) { input Ptr += len ; } else { name = decode Short Unicode Name ( len ) ; name = add Decoded To Symbols ( len , name ) ; } if ( seen Names != null ) { if ( seen Name Count >= seen Names . length ) { seen Names = expand Seen Names ( seen Names ) ; } seen Names [ seen Name Count ++ ] = name ; } parsing Context . set Current Name ( name ) ; return Json Token . FIELD NAME ; } } break ; } report Error ( STR_ + Integer . to Hex String ( type As Int ) + STR_ ) ; return null ; }
private void start Intermediate Merging ( File [ ] intermediate Files ) { File file = new File ( this . temp File Location + File . separator + this . table Name + System . nano Time ( ) + Carbon Common Constants . MERGERD EXTENSION ) ; File Merger Parameters parameters = new File Merger Parameters ( ) ; parameters . set Is No Dictionary Dimension Column ( no Dictionary Dimnesion Column ) ; parameters . set Dim Col Count ( dim Col Count ) ; parameters . set Complex Dim Col Count ( complex Dim Col Count ) ; parameters . set Measure Col Count ( measure Col Count ) ; parameters . set Intermediate Files ( intermediate Files ) ; parameters . set File Read Buffer Size ( file Buffer Size ) ; parameters . set File Write Buffer Size ( file Buffer Size ) ; parameters . set Out File ( file ) ; parameters . set Compression Enabled ( is Sort File Compression Enabled ) ; parameters . set No Of Records In Compression ( sort Temp File No OF Records In Compression ) ; parameters . set Prefetch ( prefetch ) ; parameters . set Prefetch Buffer Size ( buffer Size ) ; parameters . set Agg Type ( agg Type ) ; parameters . set No Dictionary Count ( no Dictionary Count ) ; Intermediate File Merger merger = new Intermediate File Merger ( parameters ) ; executor Service . submit ( merger ) ; }
public Naming Enumeration list Bindings ( String name ) throws Naming Exception { return list Bindings ( name Parser . parse ( name ) ) ; }
protected void start Nfc Settings Activity ( ) { if ( android . os . Build . VERSION . SDK INT >= NUM_ ) { start Activity ( new Intent ( ACTION NFC SETTINGS ) ) ; } else { start Activity ( new Intent ( android . provider . Settings . ACTION WIRELESS SETTINGS ) ) ; } }
protected final void check Namespace WF ( String qname , int colon 1 , int colon 2 ) { if ( ! error Checking ) { return ; } if ( colon 1 == NUM_ || colon 1 == qname . length ( ) - NUM_ || colon 2 != colon 1 ) { String msg = DOM Message Formatter . format Message ( DOM Message Formatter . DOM DOMAIN , STR_ , null ) ; throw new DOM Exception ( DOM Exception . NAMESPACE ERR , msg ) ; } }
static Optimized Class Descriptor class Descriptor ( Concurrent Map < Class , Optimized Class Descriptor > cls Map , Class cls , Marshaller Context ctx , Optimized Marshaller Id Mapper mapper ) throws IO Exception { Optimized Class Descriptor desc = cls Map . get ( cls ) ; if ( desc == null ) { int type Id = resolve Type Id ( cls . get Name ( ) , mapper ) ; boolean registered ; try { registered = ctx . register Class ( type Id , cls ) ; } catch ( Ignite Checked Exception e ) { throw new IO Exception ( STR_ + cls . get Name ( ) , e ) ; } desc = new Optimized Class Descriptor ( cls , registered ? type Id : NUM_ , cls Map , ctx , mapper ) ; if ( registered ) { Optimized Class Descriptor old = cls Map . put If Absent ( cls , desc ) ; if ( old != null ) desc = old ; } } return desc ; }
public static Buffered Image render To Image ( String url , int width , int height , int buffered Image Type ) { Graphics 2 D Renderer g 2 r = new Graphics 2 D Renderer ( ) ; g 2 r . set Document ( url ) ; Dimension dim = new Dimension ( width , height ) ; Buffered Image buff = new Buffered Image ( ( int ) dim . get Width ( ) , ( int ) dim . get Height ( ) , buffered Image Type ) ; Graphics 2 D g = ( Graphics 2 D ) buff . get Graphics ( ) ; g 2 r . layout ( g , dim ) ; g 2 r . render ( g ) ; g . dispose ( ) ; return buff ; }
final synchronized void merge Finish ( Merge Policy . One Merge merge ) { notify All ( ) ; if ( merge . register Done ) { final List < Segment Commit Info > source Segments = merge . segments ; for ( Segment Commit Info info : source Segments ) { merging Segments . remove ( info ) ; } merge . register Done = false ; } running Merges . remove ( merge ) ; }
@ Override public void fire ( Player player , Sentence sentence , Event Raiser npc ) { Market market = Trade Center Zone Configurator . get Shop From Zone ( player . get Zone ( ) ) ; RP Slot offers Slot = market . get Slot ( Market . OFFERS SLOT NAME ) ; List < Offer > offers = get Offers ( offers Slot ) ; if ( offers . is Empty ( ) ) { npc . say ( STR_ ) ; } else { String text = build Item List Text ( build Item List ( offers ) ) ; npc . say ( text ) ; } }
public static boolean has Enough Space ( String recording Sdcard ) { boolean ret = false ; try { Stat Fs fs = new Stat Fs ( recording Sdcard ) ; long blocks = fs . get Available Blocks ( ) ; long block Size = fs . get Block Size ( ) ; long space Left = blocks * block Size ; Log . d ( TAG , STR_ + space Left ) ; ret = space Left > LOW SPACE THRESHOLD ? true : false ; } catch ( Illegal Argument Exception e ) { Log . e ( TAG , STR_ + recording Sdcard ) ; } return ret ; }
public static boolean is File Type Supported ( Audio File Format . Type file Type ) { List providers = get Audio File Writers ( ) ; for ( int i = NUM_ ; i < providers . size ( ) ; i ++ ) { Audio File Writer writer = ( Audio File Writer ) providers . get ( i ) ; if ( writer . is File Type Supported ( file Type ) ) { return true ; } } return false ; }
public void display For Team A ( int score ) { Text View score View = ( Text View ) find View By Id ( R . id . team a score ) ; score View . set Text ( String . value Of ( score ) ) ; }
protected final Prepared Statement prepare Statement ( String sql String ) throws SQL Exception { return add And Return Statement ( created Statements , connection . prepare Statement ( sql String ) ) ; }
public static List < Float > calculate ( final float original Size , final int dpi ) { float mdpi = NUM_ ; switch ( dpi ) { case Dpi . XXXHDPI : mdpi = original Size / Dpi Ratio . RATIO XXXHDPI ; break ; case Dpi . XXHDPI : mdpi = original Size / Dpi Ratio . RATIO XHDPI ; break ; case Dpi . XHDPI : mdpi = original Size / Dpi Ratio . RATIO XHDPI ; break ; case Dpi . HDPI : mdpi = original Size / Dpi Ratio . RATIO HDPI ; break ; case Dpi . MDPI : mdpi = original Size / Dpi Ratio . RATIO MDPI ; break ; case Dpi . LDPI : mdpi = original Size / Dpi Ratio . RATIO LDPI ; break ; case Dpi . TVDPI : mdpi = original Size / Dpi Ratio . RATIO TVDPI ; break ; } final List < Float > sizes = new Array List < > ( Constants . DENSITIES COUNT ) ; sizes . add ( Dpi . XXXHDPI , mdpi * Dpi Ratio . RATIO XXXHDPI ) ; sizes . add ( Dpi . XXHDPI , mdpi * Dpi Ratio . RATIO XXHDPI ) ; sizes . add ( Dpi . XHDPI , mdpi * Dpi Ratio . RATIO XHDPI ) ; sizes . add ( Dpi . HDPI , mdpi * Dpi Ratio . RATIO HDPI ) ; sizes . add ( Dpi . MDPI , mdpi ) ; sizes . add ( Dpi . LDPI , mdpi * Dpi Ratio . RATIO LDPI ) ; sizes . add ( Dpi . TVDPI , mdpi * Dpi Ratio . RATIO TVDPI ) ; return sizes ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || get Class ( ) != o . get Class ( ) ) return false ; Deterministic Key other = ( Deterministic Key ) o ; return super . equals ( other ) && Arrays . equals ( this . chain Code , other . chain Code ) && Objects . equal ( this . child Number Path , other . child Number Path ) ; }
public static void register ( Page Source ps ) { local . set ( ps ) ; }
public String turin Name ( ) { return Character . to Upper Case ( name . char At ( NUM_ ) ) + name . substring ( NUM_ ) ; }
public static void swap Pivot ( double [ ] [ ] source , int diag , double [ ] [ ] s , double [ ] [ ] t ) { int swap Row = diag ; int swap Col = diag ; double max Value = Math . abs ( source [ diag ] [ diag ] ) ; int rows = source . length ; int cols = source [ NUM_ ] . length ; double abs = NUM_ ; double [ ] r = null ; for ( int row = diag ; row < rows ; row ++ ) { r = source [ row ] ; for ( int col = diag ; col < cols ; col ++ ) { abs = Math . abs ( r [ col ] ) ; if ( abs > max Value ) { max Value = abs ; swap Row = row ; swap Col = col ; } } } if ( swap Row != diag ) { swap Rows ( source , swap Row , diag ) ; swap Rows ( t , swap Row , diag ) ; } if ( swap Col != diag ) { swap Cols ( source , swap Col , diag ) ; swap Cols ( s , swap Col , diag ) ; } }
private void skip Whitespace ( ) { matcher . use Pattern ( WHITESPACE ) ; if ( matcher . looking At ( ) ) { matcher . region ( matcher . end ( ) , matcher . region End ( ) ) ; } }
private J Component create Style Type Selector ( ) { int pad = S Box Layout . COMMON PADDING ; J Component style Box = S Box Layout . create Container ( S Box Layout . VERTICAL , pad ) ; J Component defined Styles H Box = S Box Layout . create Container ( S Box Layout . HORIZONTAL , pad ) ; J Label selector Label = new J Label ( STR_ ) ; selector Label . set Name ( STR_ ) ; defined Styles H Box . add ( selector Label ) ; J Component selector = create Style Selector ( ) ; selector . set Name ( STR_ ) ; defined Styles H Box . add ( selector ) ; defined Styles H Box . set Tool Tip Text ( STR_ + STR_ ) ; style Box . add ( defined Styles H Box ) ; return style Box ; }
public void extend Parent ( Object cell ) { if ( cell != null ) { Object parent = model . get Parent ( cell ) ; mx Geometry p = model . get Geometry ( parent ) ; if ( parent != null && p != null && ! is Cell Collapsed ( parent ) ) { mx Geometry geo = model . get Geometry ( cell ) ; if ( geo != null && ( p . get Width ( ) < geo . get X ( ) + geo . get Width ( ) || p . get Height ( ) < geo . get Y ( ) + geo . get Height ( ) ) ) { p = ( mx Geometry ) p . clone ( ) ; p . set Width ( Math . max ( p . get Width ( ) , geo . get X ( ) + geo . get Width ( ) ) ) ; p . set Height ( Math . max ( p . get Height ( ) , geo . get Y ( ) + geo . get Height ( ) ) ) ; cells Resized ( new Object [ ] { parent } , new mx Rectangle [ ] { p } ) ; } } } }
protected void update ( Timer Status new Status ) { if ( new Status == Timer Status . FORWARD ) { if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } backward Button . set Icon ( backward Icon ) ; backward Button . set Action Command ( Timer Status . TIMER BACKWARD ) ; forward Button . set Icon ( pause Icon ) ; forward Button . set Action Command ( Timer Status . TIMER STOPPED ) ; } else if ( new Status == Timer Status . BACKWARD ) { if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } forward Button . set Icon ( forward Icon ) ; forward Button . set Action Command ( Timer Status . TIMER FORWARD ) ; backward Button . set Icon ( pause Icon ) ; backward Button . set Action Command ( Timer Status . TIMER STOPPED ) ; } else if ( new Status == Timer Status . STOPPED ) { if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } forward Button . set Icon ( forward Icon ) ; forward Button . set Action Command ( Timer Status . TIMER FORWARD ) ; backward Button . set Icon ( backward Icon ) ; backward Button . set Action Command ( Timer Status . TIMER BACKWARD ) ; } check Clock ( new Status ) ; }
public boolean is Opaque Cube ( I Block State state ) { return false ; }
private void create Record Holder Queue ( File [ ] list Files ) { this . record Holder Heap Local = new Priority Queue < Sort Temp File Chunk Holder > ( list Files . length ) ; }
public void add Tele Missile Attack ( Attack Action ea ) { pending Tele Missile Attacks . add Element ( ea ) ; process Game Event ( new Game New Action Event ( this , ea ) ) ; }
public String format String ( final String str To Format ) { if ( str To Format != null ) { if ( str To Format . equals Ignore Case ( STR_ ) ) return STR_ ; final String valn 1 = str To Format . replace All ( STR_ , STR_ ) ; final String formt Str = valn 1 . replace All ( STR_ , STR_ ) ; return formt Str . replace All ( STR_ , STR_ ) ; } else return STR_ ; }
public void init Port Names ( ) { initialized = false ; cb Port . add Item ( STR_ ) ; Comm Port Identifier curr Port ; Enumeration ports = Comm Port Identifier . get Port Identifiers ( ) ; while ( ports . has More Elements ( ) ) { curr Port = ( Comm Port Identifier ) ports . next Element ( ) ; if ( curr Port . get Port Type ( ) == Comm Port Identifier . PORT SERIAL ) { cb Port . add Item ( curr Port . get Name ( ) ) ; } } initialized = true ; }
public void update ( Graphics g , J Component c ) { if ( c . is Opaque ( ) ) { g . set Color ( new Color UI Resource ( NUM_ , NUM_ , NUM_ ) ) ; g . fill Rect ( NUM_ , NUM_ , c . get Width ( ) , c . get Height ( ) ) ; g . set Color ( new Color UI Resource ( NUM_ , NUM_ , NUM_ ) ) ; g . fill Rect ( NUM_ , get Round Height ( ) , c . get Width ( ) , c . get Height ( ) - get Round Height ( ) ) ; } paint ( g , c ) ; }
private void adjust Day Of Month ( Calendar start Time , int month ) { apply Last Day Of Month ( start Time , month ) ; if ( ! this . last Day Of Month ) { int last Day Of Month = start Time . get ( Calendar . DAY OF MONTH ) ; if ( last Day Of Month > get Day Of Month ( ) ) { start Time . set ( Calendar . DAY OF MONTH , get Day Of Month ( ) ) ; } } }
public synchronized void add Task ( Runnable task ) { if ( worker == null ) { worker = new Layout Thread ( ) ; worker . start ( ) ; } tasks . add Element ( task ) ; notify All ( ) ; }
protected void handle Pre Response ( String ticket , Jobs Api Request api Request , Async Response async Response , Observable < Pre Response > pre Response Observable , boolean is Empty ) { if ( is Empty ) { handle Job Response ( ticket , api Request , async Response ) ; } else { handle Results Response ( pre Response Observable , async Response , api Request ) ; } }
protected final Json Token handle Field Name ( ) throws IO Exception { if ( input Ptr >= input End ) { load More Guaranteed ( ) ; } int ch = input Buffer [ input Ptr ++ ] ; switch ( ( ch > > NUM_ ) & NUM_ ) { case NUM_ : switch ( ch ) { case NUM_ : parsing Context . set Current Name ( STR_ ) ; return Json Token . FIELD NAME ; case NUM_ : case NUM_ : case NUM_ : case NUM_ : { if ( input Ptr >= input End ) { load More Guaranteed ( ) ; } int index = ( ( ch & NUM_ ) << NUM_ ) + ( input Buffer [ input Ptr ++ ] & NUM_ ) ; if ( index >= seen Name Count ) { report Invalid Shared Name ( index ) ; } parsing Context . set Current Name ( seen Names [ index ] ) ; } return Json Token . FIELD NAME ; case NUM_ : handle Long Field Name ( ) ; return Json Token . FIELD NAME ; } break ; case NUM_ : { int index = ( ch & NUM_ ) ; if ( index >= seen Name Count ) { report Invalid Shared Name ( index ) ; } parsing Context . set Current Name ( seen Names [ index ] ) ; } return Json Token . FIELD NAME ; case NUM_ : { int len = NUM_ + ( ch & NUM_ ) ; String name = find Decoded From Symbols ( len ) ; if ( name != null ) { input Ptr += len ; } else { name = decode Short Ascii Name ( len ) ; name = add Decoded To Symbols ( len , name ) ; } if ( seen Names != null ) { if ( seen Name Count >= seen Names . length ) { seen Names = expand Seen Names ( seen Names ) ; } seen Names [ seen Name Count ++ ] = name ; } parsing Context . set Current Name ( name ) ; } return Json Token . FIELD NAME ; case NUM_ : ch &= NUM_ ; { if ( ch > NUM_ ) { if ( ch == NUM_ ) { if ( ! parsing Context . in Object ( ) ) { report Mismatched End Marker ( STR_ , STR_ ) ; } parsing Context = parsing Context . get Parent ( ) ; return Json Token . END OBJECT ; } } else { final int len = ch + NUM_ ; String name = find Decoded From Symbols ( len ) ; if ( name != null ) { input Ptr += len ; } else { name = decode Short Unicode Name ( len ) ; name = add Decoded To Symbols ( len , name ) ; } if ( seen Names != null ) { if ( seen Name Count >= seen Names . length ) { seen Names = expand Seen Names ( seen Names ) ; } seen Names [ seen Name Count ++ ] = name ; } parsing Context . set Current Name ( name ) ; return Json Token . FIELD NAME ; } } break ; } report Error ( STR_ + Integer . to Hex String ( input Buffer [ input Ptr - NUM_ ] ) + STR_ ) ; return null ; }
private void create Scene Vao ( ) { int vao = gl Gen Vertex Arrays ( ) ; int vbo = gl Gen Buffers ( ) ; gl Bind Vertex Array ( vao ) ; gl Bind Buffer ( GL ARRAY BUFFER , vbo ) ; long buffer Size = NUM_ * ( NUM_ + NUM_ ) * mesh . num Vertices ; long normals Offset = NUM_ * NUM_ * mesh . num Vertices ; gl Buffer Data ( GL ARRAY BUFFER , buffer Size , GL STATIC DRAW ) ; gl Buffer Sub Data ( GL ARRAY BUFFER , NUM_ , mesh . positions ) ; gl Buffer Sub Data ( GL ARRAY BUFFER , normals Offset , mesh . normals ) ; gl Enable Vertex Attrib Array ( NUM_ ) ; gl Vertex Attrib Pointer ( NUM_ , NUM_ , GL FLOAT , false , NUM_ , NUM_ ) ; gl Enable Vertex Attrib Array ( NUM_ ) ; gl Vertex Attrib Pointer ( NUM_ , NUM_ , GL FLOAT , false , NUM_ , normals Offset ) ; gl Bind Buffer ( GL ARRAY BUFFER , NUM_ ) ; gl Bind Vertex Array ( NUM_ ) ; this . vao Scene = vao ; }
public synchronized void add ( File file ) { value . add ( file ) ; set Value ( value ) ; }
protected Monitor poll For ( Map < String , Monitor > map , String name , long time Limit ) throws Monitor Exception { Monitor monitor = null ; log ( STR_ + lvmid + STR_ + name + STR_ ) ; poll For Entry = next Entry ; while ( ( monitor = map . get ( name ) ) == null ) { log ( STR_ ) ; try { Thread . sleep ( NUM_ ) ; } catch ( Interrupted Exception e ) { } long t = System . current Time Millis ( ) ; if ( ( t > time Limit ) || ( overflow . int Value ( ) > NUM_ ) ) { lognl ( STR_ + lvmid + STR_ + name ) ; dump All ( map , lvmid ) ; throw new Monitor Exception ( STR_ ) ; } get New Monitors ( map ) ; } lognl ( STR_ + lvmid + STR_ + name ) ; return monitor ; }
private Default Mutable Tree Node build Tree ( ) { Default Mutable Tree Node root = new Default Mutable Tree Node ( STR_ ) ; for ( Module Dependencies Analyzer . Order Path order Path : my Explanation . paths ( ) ) { add Dependency Path ( root , order Path , NUM_ ) ; } return root ; }
public Plain Sasl Authenticator Factory ( final Vertx vertx ) { this . vertx = Objects . require Non Null ( vertx ) ; }
protected void append Char Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
protected void append Byte Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
private static void create Fixed Partition List ( int primary Index ) { fpa List . clear ( ) ; if ( primary Index == NUM_ ) { fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STR_ , true , NUM_ ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STR_ , NUM_ ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STR_ , NUM_ ) ) ; } if ( primary Index == NUM_ ) { fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STR_ , NUM_ ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STR_ , true , NUM_ ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STR_ , NUM_ ) ) ; } if ( primary Index == NUM_ ) { fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STR_ , NUM_ ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STR_ , NUM_ ) ) ; fpa List . add ( Fixed Partition Attributes . create Fixed Partition ( STR_ , true , NUM_ ) ) ; } }
protected Array List < Folding Cell View > prepare Views For Animation ( Array List < Integer > view Heights , Bitmap title View Bitmap , Bitmap content View Bitmap ) { if ( view Heights == null || view Heights . is Empty ( ) ) throw new Illegal State Exception ( STR_ ) ; Array List < Folding Cell View > parts List = new Array List < > ( ) ; int part Width = title View Bitmap . get Width ( ) ; int y Offset = NUM_ ; for ( int i = NUM_ ; i < view Heights . size ( ) ; i ++ ) { int part Height = view Heights . get ( i ) ; Bitmap part Bitmap = Bitmap . create Bitmap ( part Width , part Height , Bitmap . Config . ARGB 8888 ) ; Canvas canvas = new Canvas ( part Bitmap ) ; Rect src Rect = new Rect ( NUM_ , y Offset , part Width , y Offset + part Height ) ; Rect dest Rect = new Rect ( NUM_ , NUM_ , part Width , part Height ) ; canvas . draw Bitmap ( content View Bitmap , src Rect , dest Rect , null ) ; Image View back View = create Image View From Bitmap ( part Bitmap ) ; Image View front View = null ; if ( i < view Heights . size ( ) - NUM_ ) { front View = ( i == NUM_ ) ? create Image View From Bitmap ( title View Bitmap ) : create Back Side View ( view Heights . get ( i + NUM_ ) ) ; } parts List . add ( new Folding Cell View ( front View , back View , get Context ( ) ) ) ; y Offset = y Offset + part Height ; } return parts List ; }
static Class < ? > load Class ( String name ) { for ( Class Loader loader : loaders ( ) ) { try { return loader . load Class ( name ) ; } catch ( Class Not Found Exception ex ) { continue ; } } return null ; }
private void close Wall ( String wall Id ) { Retro Callback retro Callback ; retro Callback = new Retro Callback ( this ) ; retro Callback . set Request Id ( Http Constants . Api Response Codes . CLOSE WALL ) ; Bundle args = new Bundle ( ) ; args . put String ( App Constants . Keys . WALL ID , wall Id ) ; retro Callback . set Extras ( args ) ; retro Callback List . add ( retro Callback ) ; Close Wall Request Model close Wall Request Model = new Close Wall Request Model ( ) ; close Wall Request Model . set Is solved ( STR_ ) ; m Yelo Api . close Wall ( wall Id , close Wall Request Model , retro Callback ) ; }
public static String array To Comma Delimited String ( Object [ ] arr ) { return array To Delimited String ( arr , STR_ ) ; }
public static String build Selector From Elements And Attribute ( Collection < String > element Name List , @ Nullable String attribute Name , boolean not Empty Attribute ) { String Builder selector = new String Builder ( ) ; boolean is First Element = true ; for ( String element Name : element Name List ) { if ( ! is First Element ) { selector . append ( SPACE ) ; selector . append ( COMMA ) ; selector . append ( SPACE ) ; } selector . append ( element Name ) ; if ( String Utils . is Not Blank ( attribute Name ) ) { selector . append ( OPEN BRACKET ) ; selector . append ( attribute Name ) ; selector . append ( CLOSE BRACKET ) ; if ( not Empty Attribute ) { selector . append ( NOT PREFIX ) ; selector . append ( OPEN BRACKET ) ; selector . append ( attribute Name ) ; selector . append ( NOT EMPTY REGEXP ) ; selector . append ( CLOSE BRACKET ) ; selector . append ( CLOSE PARENTHESE ) ; } } is First Element = false ; } return selector . to String ( ) ; }
void add ( Indicator Result result ) { indicator Results . add ( result ) ; }
@ Override public void on Backup ( Parcel File Descriptor old State , Backup Data Output data , Parcel File Descriptor new State ) throws IO Exception { long saved File Size = - NUM_ ; long saved Crc = - NUM_ ; int saved Version = - NUM_ ; Data Input Stream in = new Data Input Stream ( new File Input Stream ( old State . get File Descriptor ( ) ) ) ; try { saved File Size = in . read Long ( ) ; saved Crc = in . read Long ( ) ; saved Version = in . read Int ( ) ; } catch ( EOF Exception e ) { return ; } finally { if ( in != null ) { in . close ( ) ; } } write Backup State ( saved File Size , saved Crc , new State ) ; }
public void add CP Item ( CP cp ) { String uniq = cp . get Uniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public Letter Validator ( @ Non Null final Char Sequence error Message , @ Non Null final Case case Sensitivity , final boolean allow Spaces , @ Non Null final char ... allowed Characters ) { super ( error Message ) ; set Case Sensitivity ( case Sensitivity ) ; allow Spaces ( allow Spaces ) ; set Allowed Characters ( allowed Characters ) ; }
public static void print Raw Lines ( Print Writer writer , String msg ) { int nl ; while ( ( nl = msg . index Of ( STR_ ) ) != - NUM_ ) { writer . println ( msg . substring ( NUM_ , nl ) ) ; msg = msg . substring ( nl + NUM_ ) ; } if ( msg . length ( ) != NUM_ ) writer . println ( msg ) ; }
public static Location from Time Zone ( Time Zone time Zone ) { if ( time Zone == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STR_ , STR_ , STR_ ) ) ; } double millis Per Hour = NUM_ ; int offset Millis = time Zone . get Raw Offset ( ) ; int offset Hours = ( int ) ( offset Millis / millis Per Hour ) ; double lat = time Zone Latitudes . get ( offset Hours , NUM_ ) ; double lon = NUM_ * offset Hours / NUM_ ; return new Location ( lat , lon ) ; }
protected void prepare For Flush ( ) { done Lock = new Reentrant Lock ( ) ; done Condition = done Lock . new Condition ( ) ; done Lock . lock ( ) ; }
private void recalculat Preferred Size ( ) { int max X = NUM_ ; int max Y = NUM_ ; for ( Graphical Node gn : my Graphical Nodes ) { int x = gn . x + NODE WIDTH ; int y = gn . y + NODE HEIGHT ; max X = Math . max ( max X , x ) ; max Y = Math . max ( max Y , y ) ; } set Preferred Size ( new Dimension ( max X , max Y ) ) ; my Max X = max X ; my Max Y = max Y ; }
private String compute Javadoc Indent ( I Document document , int line , Java Heuristic Scanner scanner , I Typed Region partition ) throws Bad Location Exception { if ( line == NUM_ ) return null ; final I Region line Info = document . get Line Information ( line ) ; final int line Start = line Info . get Offset ( ) ; final int line Length = line Info . get Length ( ) ; final int line End = line Start + line Length ; int non WS = scanner . find Non Whitespace Forward In Any Partition ( line Start , line End ) ; if ( non WS == Java Heuristic Scanner . NOT FOUND || document . get Char ( non WS ) != STR_ ) { if ( non WS == Java Heuristic Scanner . NOT FOUND ) return document . get ( line Start , line Length ) ; return document . get ( line Start , non WS - line Start ) ; } I Region previous Line = document . get Line Information ( line - NUM_ ) ; int previous Line Start = previous Line . get Offset ( ) ; int previous Line Length = previous Line . get Length ( ) ; int previous Line End = previous Line Start + previous Line Length ; String Buffer buf = new String Buffer ( ) ; int previous Line Non WS = scanner . find Non Whitespace Forward In Any Partition ( previous Line Start , previous Line End ) ; if ( previous Line Non WS == Java Heuristic Scanner . NOT FOUND || document . get Char ( previous Line Non WS ) != STR_ ) { previous Line = document . get Line Information Of Offset ( partition . get Offset ( ) ) ; previous Line Start = previous Line . get Offset ( ) ; previous Line Length = previous Line . get Length ( ) ; previous Line End = previous Line Start + previous Line Length ; previous Line Non WS = scanner . find Non Whitespace Forward In Any Partition ( previous Line Start , previous Line End ) ; if ( previous Line Non WS == Java Heuristic Scanner . NOT FOUND ) previous Line Non WS = previous Line End ; buf . append ( STR_ ) ; } String indentation = document . get ( previous Line Start , previous Line Non WS - previous Line Start ) ; buf . insert ( NUM_ , indentation ) ; return buf . to String ( ) ; }
public static Array List < String > export Result Variables ( long worker ID , Local Variable Map vars , Array List < String > result Vars ) throws DML Runtime Exception , IO Exception { Array List < String > ret = new Array List < String > ( ) ; for ( String rvar : result Vars ) { Data dat = vars . get ( rvar ) ; if ( dat != null && dat . get Data Type ( ) == Data Type . MATRIX ) { Matrix Object mo = ( Matrix Object ) dat ; if ( mo . is Dirty ( ) ) { mo . export Data ( ) ; ret . add ( Program Converter . serialize Data Object ( rvar , mo ) ) ; } } } return ret ; }
private void parse Bold And Italic Spans ( Span Manager sm , Span line , List < Span > bold Spans , List < Span > italic Spans ) { parse Quoted Spans ( sm , line , bold Spans , STR_ ) ; parse Quoted Spans ( sm , line , italic Spans , STR_ ) ; int open Tag = sm . index Of ( STR_ , line ) ; if ( open Tag != - NUM_ ) { Span qs = new Span ( open Tag , line . get End ( ) ) ; if ( calculate Src Spans ) { qs . set Src Span ( new Src Span ( sm . get Src Pos ( open Tag ) , sm . get Src Pos ( line . get End ( ) ) ) ) ; } if ( sm . index Of ( STR_ , open Tag , open Tag + NUM_ ) != - NUM_ ) { bold Spans . add ( qs ) ; sm . delete ( open Tag , open Tag + NUM_ ) ; } else { italic Spans . add ( qs ) ; sm . delete ( open Tag , open Tag + NUM_ ) ; } } }
private void fields ( Class type ) { Field [ ] list = type . get Declared Fields ( ) ; for ( Field field : list ) { Field Detail detail = new Field Detail ( field ) ; fields . add ( detail ) ; } }
public boolean has Pools ( ) { return pool Hash Table . size ( ) > NUM_ ; }
public boolean acquire ( ) { int [ ] stamp = new int [ NUM_ ] ; while ( true ) { boolean undeployed = usage . get ( stamp ) ; int r = stamp [ NUM_ ] ; if ( undeployed && r == NUM_ ) return false ; if ( usage . compare And Set ( undeployed , undeployed , r , r + NUM_ ) ) return true ; } }
public Event Source Impl ( ) { LOG . entering ( CLASS NAME , STR_ ) ; }
public void incr Stats ( Collection < Graph Node > nodes ) { total Count += nodes . size ( ) ; for ( Graph Node node : nodes ) { Element Kind Descriptor descr = find Descriptor ( node ) ; if ( null == descr ) { other Count ++ ; } else { int count = kind Counts . get ( descr ) ; kind Counts . put ( descr , count + NUM_ ) ; } } }
protected byte [ ] read Last Chunk ( long index ) throws IO Exception , Invalid Key Exception , Invalid Algorithm Parameter Exception , Illegal Block Size Exception , Bad Padding Exception , File Encryption Exception , Short Buffer Exception { long n Remaining = backing Random Access File . length ( ) - ( chunk Offset ( index ) ) ; if ( n Remaining > CHUNK ENC SIZE ) { throw new File Encryption Exception ( STR_ ) ; } else if ( n Remaining <= CHUNK IV SIZE ) { return new byte [ ] { } ; } long oldpos = backing Random Access File . get File Pointer ( ) ; backing Random Access File . seek ( chunk Offset ( index ) ) ; byte [ ] iv = new byte [ CHUNK IV SIZE ] ; int ret = backing Random Access File . read ( iv ) ; if ( ret != CHUNK IV SIZE ) { throw new File Encryption Exception ( STR_ ) ; } Iv Parameter Spec spec = new Iv Parameter Spec ( iv ) ; last Chunk Cipher . init ( Cipher . DECRYPT MODE , get File Key ( ) , spec ) ; n Remaining -= CHUNK IV SIZE ; byte [ ] buf = new byte [ ( int ) n Remaining ] ; byte [ ] res ; ret = backing Random Access File . read ( buf ) ; backing Random Access File . seek ( oldpos ) ; if ( ret != n Remaining ) { throw new File Encryption Exception ( STR_ ) ; } res = last Chunk Cipher . do Final ( buf ) ; if ( ( res == null ) || ( res . length != ( n Remaining - CHUNK TLEN ) ) ) { throw new File Encryption Exception ( STR_ ) ; } else { return res ; } }
public static java . sql . Timestamp to Timestamp ( String month Str , String day Str , String year Str , String hour Str , String minute Str , String second Str ) { java . util . Date new Date = to Date ( month Str , day Str , year Str , hour Str , minute Str , second Str ) ; if ( new Date != null ) { return new java . sql . Timestamp ( new Date . get Time ( ) ) ; } else { return null ; } }
private static String make Field Value ( Object value ) { if ( value == null ) return STR_ ; Class < ? > value Class = value . get Class ( ) ; try { value Class . get Constructor ( String . class ) ; } catch ( No Such Method Exception e ) { final String msg = STR_ + value Class + STR_ + STR_ ; final Runtime Exception iae = new Illegal Argument Exception ( msg ) ; throw new Runtime Operations Exception ( iae , STR_ ) ; } catch ( Security Exception e ) { } final String quoted Value String = quote ( value . to String ( ) ) ; return STR_ + value Class . get Name ( ) + STR_ + quoted Value String + STR_ ; }
public static double coefficient ( double [ ] x , double [ ] y ) { final int xdim = x . length ; final int ydim = y . length ; if ( xdim != ydim ) { throw new Illegal Argument Exception ( STR_ ) ; } double sum XX = NUM_ , sum YY = NUM_ , sum XY = NUM_ ; double mean X = x [ NUM_ ] , mean Y = y [ NUM_ ] ; int i = NUM_ ; while ( i < xdim ) { final double xv = x [ i ] , yv = y [ i ] ; final double delta X = xv - mean X ; final double delta Y = yv - mean Y ; ++ i ; mean X += delta X / i ; mean Y += delta Y / i ; final double nelta X = xv - mean X ; final double nelta Y = yv - mean Y ; sum XX += delta X * nelta X ; sum YY += delta Y * nelta Y ; sum XY += delta X * nelta Y ; } if ( ! ( sum XX > NUM_ && sum YY > NUM_ ) ) { return ( sum XX == sum YY ) ? NUM_ : NUM_ ; } return sum XY / Math . sqrt ( sum XX * sum YY ) ; }
@ Override @ Suppress Forbidden ( reason = STR_ ) public void activate Options ( ) { if ( follow ) { if ( target . equals ( SYSTEM ERR ) ) { set Writer ( create Writer ( new System Err Stream ( ) ) ) ; } else { set Writer ( create Writer ( new System Out Stream ( ) ) ) ; } } else { if ( target . equals ( SYSTEM ERR ) ) { set Writer ( create Writer ( System . err ) ) ; } else { set Writer ( create Writer ( System . out ) ) ; } } super . activate Options ( ) ; }
public int compare To ( Debug Script other ) { return comparable Name . compare To ( other . comparable Name ) ; }
public int length ( List < String > ls ) { return ls . size ( ) ; }
Operand peek ( Register s ) { Stack < Operand > stack = get ( s ) ; if ( stack == null || stack . is Empty ( ) ) { return null ; } else { return stack . peek ( ) ; } }
public String generate Documentation ( String container Id ) throws Exception { String Builder output = new String Builder ( ) ; output . append ( STR_ + STR_ + STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( LINE SEPARATOR ) ; if ( container Id . equals ( STR_ ) ) { output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( LINE SEPARATOR ) ; } else if ( container Id . equals ( STR_ ) ) { output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( LINE SEPARATOR ) ; } else if ( container Id . starts With ( STR_ ) || container Id . starts With ( STR_ ) || container Id . starts With ( STR_ ) ) { output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( LINE SEPARATOR ) ; } else if ( container Id . starts With ( STR_ ) ) { if ( container Id . equals ( STR_ ) ) { output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( LINE SEPARATOR ) ; } output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( LINE SEPARATOR ) ; } else if ( container Id . starts With ( STR_ ) ) { output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( LINE SEPARATOR ) ; } output . append ( generate Container Features Text ( container Id ) ) ; output . append ( LINE SEPARATOR ) ; output . append ( generate Configuration Features Text ( container Id ) ) ; output . append ( LINE SEPARATOR ) ; output . append ( generate Deployer Features Text ( container Id ) ) ; output . append ( LINE SEPARATOR ) ; output . append ( generate Other Features Text ( container Id ) ) ; output . append ( LINE SEPARATOR ) ; output . append ( generate Configuration Properties Text ( container Id ) ) ; output . append ( LINE SEPARATOR ) ; output . append ( generate Samples Info Text ( container Id ) ) ; output . append ( LINE SEPARATOR ) ; return output . to String ( ) ; }
public Number Range Model ( Number lo , Number hi , Number min , Number max ) { m type = Type Lib . get Primitive Type ( min . get Class ( ) ) ; set Value Range ( lo , hi , min , max ) ; }
private void generate Legal Times Tree ( ) { int k 0 = Key Event . KEYCODE 0 ; int k 1 = Key Event . KEYCODE 1 ; int k 2 = Key Event . KEYCODE 2 ; int k 3 = Key Event . KEYCODE 3 ; int k 4 = Key Event . KEYCODE 4 ; int k 5 = Key Event . KEYCODE 5 ; int k 6 = Key Event . KEYCODE 6 ; int k 7 = Key Event . KEYCODE 7 ; int k 8 = Key Event . KEYCODE 8 ; int k 9 = Key Event . KEYCODE 9 ; m Legal Times Tree = new Node ( ) ; if ( m Is 24 Hour Mode ) { Node minute First Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; Node minute Second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; minute First Digit . add Child ( minute Second Digit ) ; Node first Digit = new Node ( k 0 , k 1 ) ; m Legal Times Tree . add Child ( first Digit ) ; Node second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; Node third Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; second Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; first Digit = new Node ( k 2 ) ; m Legal Times Tree . add Child ( first Digit ) ; second Digit = new Node ( k 0 , k 1 , k 2 , k 3 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute First Digit ) ; second Digit = new Node ( k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( minute Second Digit ) ; first Digit = new Node ( k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( minute First Digit ) ; } else { Node ampm = new Node ( get Am Or Pm Key Code ( HALF DAY 1 ) , get Am Or Pm Key Code ( HALF DAY 2 ) ) ; Node first Digit = new Node ( k 1 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( ampm ) ; Node second Digit = new Node ( k 0 , k 1 , k 2 ) ; first Digit . add Child ( second Digit ) ; second Digit . add Child ( ampm ) ; Node third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; Node fourth Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; third Digit . add Child ( fourth Digit ) ; fourth Digit . add Child ( ampm ) ; third Digit = new Node ( k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; second Digit = new Node ( k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; first Digit = new Node ( k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; m Legal Times Tree . add Child ( first Digit ) ; first Digit . add Child ( ampm ) ; second Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 ) ; first Digit . add Child ( second Digit ) ; third Digit = new Node ( k 0 , k 1 , k 2 , k 3 , k 4 , k 5 , k 6 , k 7 , k 8 , k 9 ) ; second Digit . add Child ( third Digit ) ; third Digit . add Child ( ampm ) ; } }
public boolean is Muted ( ) { if ( m Mute Control != null ) { return m Mute Control . get Value ( ) ; } return false ; }
private void step 1 ( ) { final Speaker NPC npc = npcs . get ( STR_ ) ; npc . add ( Conversation States . ATTENDING , Conversation Phrases . QUEST MESSAGES , new Quest In State Condition ( QUEST SLOT , QUEST INDEX STATUS , STR_ ) , Conversation States . ATTENDING , STR_ , new Say Text Action ( STR_ ) ) ; npc . add ( Conversation States . ATTENDING , Conversation Phrases . QUEST MESSAGES , new And Condition ( new Quest Not Active Condition ( QUEST SLOT ) , new Not Condition ( new Time Reached Condition ( QUEST SLOT , QUEST INDEX TIME ) ) ) , Conversation States . ATTENDING , STR_ , null ) ; npc . add ( Conversation States . ATTENDING , Conversation Phrases . QUEST MESSAGES , new And Condition ( new Quest Not Active Condition ( QUEST SLOT ) , new Time Reached Condition ( QUEST SLOT , QUEST INDEX TIME ) ) , Conversation States . QUEST OFFERED , STR_ , null ) ; npc . add ( Conversation States . QUEST OFFERED , STR_ , null , Conversation States . QUEST OFFERED , STR_ , null ) ; npc . add ( Conversation States . QUEST OFFERED , Conversation Phrases . NO MESSAGES , Conversation States . IDLE , STR_ , new Multiple Actions ( new Decrease Karma Action ( NUM_ ) , new Set Quest Action ( QUEST SLOT , QUEST INDEX STATUS , STR_ ) ) ) ; npc . add ( Conversation States . QUEST OFFERED , Conversation Phrases . YES MESSAGES , Conversation States . ATTENDING , null , new Multiple Actions ( new Create And Say Coded Message ( ) , new Set Quest Action ( QUEST SLOT , QUEST INDEX STATUS , STR_ ) ) ) ; }
public static boolean create Normal ( Vector 3 norm , Read Only Vector 3 v 0 , Read Only Vector 3 v 1 , Read Only Vector 3 v 2 ) { if ( Double . is Na N ( v 0 . get Z ( ) ) || Double . is Na N ( v 1 . get Z ( ) ) || Double . is Na N ( v 2 . get Z ( ) ) ) { norm . set ( NUM_ , NUM_ , NUM_ ) ; return ( false ) ; } Vector 3 work = Vector 3 . fetch Temp Instance ( ) ; norm . set ( v 1 ) ; norm . subtract Local ( v 0 ) ; work . set ( v 2 ) ; work . subtract Local ( v 0 ) ; norm . cross Local ( work ) ; norm . normalize Local ( ) ; Vector 3 . release Temp Instance ( work ) ; return ( true ) ; }
public List < Struct > list Trait Definitions ( final String guid ) throws Atlas Service Exception { JSON Object json Response = call API ( API . GET ALL TRAIT DEFINITIONS , null , guid , TRAIT DEFINITIONS ) ; List < JSON Object > trait Def List = extract Results ( json Response , Atlas Client . RESULTS , new Extract Operation < JSON Object , JSON Object > ( ) ) ; Array List < Struct > trait Struct List = new Array List < > ( ) ; for ( JSON Object trait Def : trait Def List ) { Struct trait Struct = Instance Serialization . from Json Struct ( trait Def . to String ( ) , true ) ; trait Struct List . add ( trait Struct ) ; } return trait Struct List ; }
private int assert Pivot Counts Are Correct ( String pivot Name , Solr Params base Params , Pivot Field constraint ) throws Solr Server Exception { Solr Params p = Solr Params . wrap Appended ( base Params , params ( STR_ , build Filter ( constraint ) ) ) ; List < Pivot Field > sub Pivots = null ; try { assert Pivot Data ( pivot Name , constraint , p ) ; sub Pivots = constraint . get Pivot ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( pivot Name + STR_ + p + STR_ + e . get Message ( ) , e ) ; } int depth = NUM_ ; if ( null != sub Pivots ) { assert Trace Ok ( pivot Name , base Params , sub Pivots ) ; for ( Pivot Field sub Pivot : sub Pivots ) { depth = assert Pivot Counts Are Correct ( pivot Name , p , sub Pivot ) ; } } return depth + NUM_ ; }
@ Override public int hash Code ( ) { return date Time . hash Code ( ) ^ offset . hash Code ( ) ^ Integer . rotate Left ( zone . hash Code ( ) , NUM_ ) ; }
void add Listener ( Index Change Listener listener ) { listeners . add ( listener ) ; }
public static void delete ES Test Index ( String index ) { logger . info ( STR_ ) ; Process Builder p Delete = new Process Builder ( STR_ , STR_ , index ) ; try { execute Command ( p Delete ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
protected Business Object Data Ddl Collection Response generate Business Object Data Ddl Collection Impl ( Business Object Data Ddl Collection Request business Object Data Ddl Collection Request ) { validate Business Object Data Ddl Collection Request ( business Object Data Ddl Collection Request ) ; Business Object Data Ddl Collection Response business Object Data Ddl Collection Response = new Business Object Data Ddl Collection Response ( ) ; List < Business Object Data Ddl > business Object Data Ddl Responses = new Array List < > ( ) ; business Object Data Ddl Collection Response . set Business Object Data Ddl Responses ( business Object Data Ddl Responses ) ; List < String > ddls = new Array List < > ( ) ; for ( Business Object Data Ddl Request request : business Object Data Ddl Collection Request . get Business Object Data Ddl Requests ( ) ) { Business Object Data Ddl business Object Data Ddl = generate Business Object Data Ddl Impl ( request , true ) ; business Object Data Ddl Responses . add ( business Object Data Ddl ) ; ddls . add ( business Object Data Ddl . get Ddl ( ) ) ; } business Object Data Ddl Collection Response . set Ddl Collection ( String Utils . join ( ddls , STR_ ) ) ; return business Object Data Ddl Collection Response ; }
public static Dbf Table Model create Default Model ( Esri Graphic List list ) { if ( logger . is Loggable ( Level . FINE ) ) logger . fine ( STR_ ) ; Dbf Table Model model = new Dbf Table Model ( NUM_ ) ; model . set Length ( NUM_ , ( byte ) NUM_ ) ; model . set Column Name ( NUM_ , SHAPE DBF DESCRIPTION ) ; model . set Type ( NUM_ , ( byte ) Dbf Table Model . TYPE CHARACTER ) ; model . set Decimal Count ( NUM_ , ( byte ) NUM_ ) ; model . set Length ( NUM_ , ( byte ) NUM_ ) ; model . set Column Name ( NUM_ , SHAPE DBF LINECOLOR ) ; model . set Type ( NUM_ , ( byte ) Dbf Table Model . TYPE CHARACTER ) ; model . set Decimal Count ( NUM_ , ( byte ) NUM_ ) ; model . set Length ( NUM_ , ( byte ) NUM_ ) ; model . set Column Name ( NUM_ , SHAPE DBF FILLCOLOR ) ; model . set Type ( NUM_ , ( byte ) Dbf Table Model . TYPE CHARACTER ) ; model . set Decimal Count ( NUM_ , ( byte ) NUM_ ) ; model . set Length ( NUM_ , ( byte ) NUM_ ) ; model . set Column Name ( NUM_ , SHAPE DBF SELECTCOLOR ) ; model . set Type ( NUM_ , ( byte ) Dbf Table Model . TYPE CHARACTER ) ; model . set Decimal Count ( NUM_ , ( byte ) NUM_ ) ; model . set Length ( NUM_ , ( byte ) NUM_ ) ; model . set Column Name ( NUM_ , SHAPE DBF LINEWIDTH ) ; model . set Type ( NUM_ , ( byte ) Dbf Table Model . TYPE NUMERIC ) ; model . set Decimal Count ( NUM_ , ( byte ) NUM_ ) ; model . set Length ( NUM_ , ( byte ) NUM_ ) ; model . set Column Name ( NUM_ , SHAPE DBF DASHPATTERN ) ; model . set Type ( NUM_ , ( byte ) Dbf Table Model . TYPE CHARACTER ) ; model . set Decimal Count ( NUM_ , ( byte ) NUM_ ) ; model . set Length ( NUM_ , ( byte ) NUM_ ) ; model . set Column Name ( NUM_ , SHAPE DBF DASHPHASE ) ; model . set Type ( NUM_ , ( byte ) Dbf Table Model . TYPE NUMERIC ) ; model . set Decimal Count ( NUM_ , ( byte ) NUM_ ) ; int count = NUM_ ; for ( OM Graphic omg : list ) { Object index = omg . get Attribute ( SHAPE INDEX ATTRIBUTE ) ; if ( index == null ) { index = new Integer ( count ) ; omg . put Attribute ( SHAPE INDEX ATTRIBUTE , index ) ; } count ++ ; List < Object > record = new Array List < Object > ( ) ; Object obj = omg . get Attribute ( SHAPE DBF DESCRIPTION ) ; if ( obj instanceof String ) { record . add ( obj ) ; } else { record . add ( STR_ ) ; } record . add ( Color Factory . get Hex Color String ( omg . get Line Color ( ) ) ) ; record . add ( Color Factory . get Hex Color String ( omg . get Fill Color ( ) ) ) ; record . add ( Color Factory . get Hex Color String ( omg . get Select Color ( ) ) ) ; Basic Stroke bs = ( Basic Stroke ) omg . get Stroke ( ) ; record . add ( new Double ( bs . get Line Width ( ) ) ) ; String dp = Basic Stroke Editor . dash Array To String ( bs . get Dash Array ( ) ) ; if ( dp == Basic Stroke Editor . NONE ) { dp = STR_ ; } record . add ( dp ) ; record . add ( new Double ( bs . get Dash Phase ( ) ) ) ; model . add Record ( record ) ; if ( logger . is Loggable ( Level . FINER ) ) logger . finer ( STR_ + record ) ; } return model ; }
public boolean init ( ) { m session = m request . get Session ( true ) ; m forward = Web Util . get Parameter ( m request , P Forward To ) ; if ( m forward != null ) m session . set Attribute ( P Forward To , m forward ) ; else m forward = STR_ ; m sales Rep = Web Util . get Parameter ( m request , P Sales Rep ID ) ; if ( m sales Rep != null ) m session . set Attribute ( P Sales Rep ID , m sales Rep ) ; m email = Web Util . get Parameter ( m request , P E Mail ) ; if ( m email == null ) m email = STR_ ; m email = m email . trim ( ) ; if ( m email != null ) m session . set Attribute ( P E Mail , m email ) ; m password = Web Util . get Parameter ( m request , P Password ) ; if ( m password == null ) m password = STR_ ; m password = m password . trim ( ) ; if ( m session . get Attribute ( Web Info . NAME ) != null ) { Web Info wi = ( Web Info ) m session . get Attribute ( Web Info . NAME ) ; m wu = wi . get Web User ( ) ; } return true ; }
public long create Back Buffer ( X 11 Component Peer peer , int num Buffers , Buffer Capabilities caps ) throws AWT Exception { if ( ! X 11 Graphics Device . is DBE Supported ( ) ) { throw new AWT Exception ( STR_ ) ; } if ( num Buffers > NUM_ ) { throw new AWT Exception ( STR_ ) ; } Buffer Capabilities config Caps = get Buffer Capabilities ( ) ; if ( ! config Caps . is Page Flipping ( ) ) { throw new AWT Exception ( STR_ ) ; } long window = peer . get Content Window ( ) ; int swap Action = get Swap Action ( caps . get Flip Contents ( ) ) ; return create Back Buffer ( window , swap Action ) ; }
private J List < String > create New Info Label J List ( String source ) { final J List < String > created Info Label List = new J List < > ( ) ; created Info Label List . set Model ( source == null ? local Info Label List Model : remote Info Label List Models . get ( source ) ) ; created Info Label List . set Cell Renderer ( new Configurable Info Label Renderer ( ) ) ; created Info Label List . set Fixed Cell Height ( NUM_ ) ; created Info Label List . set Background ( LIGHTER GRAY ) ; return created Info Label List ; }
public void union ( Set x ) { Enumeration elements = x . elements ( ) ; while ( elements . has More Elements ( ) ) put ( elements . next Element ( ) ) ; }
private void write Interface Hash ( Indenting Writer p ) throws IO Exception { p . pln ( STR_ + remote Class . interface Hash ( ) + STR_ ) ; }
public void send ( String data ) throws IO Exception { Datagram Packet dp = new Datagram Packet ( data . get Bytes ( ) , data . length ( ) , multicast Group ) ; datagram Socket . send ( dp ) ; }
public static Evaluator create Evaluator ( String text ) { if ( is Numeric ( text ) ) { return new Index Evaluator ( text ) ; } else if ( text . starts With ( STR_ ) ) { return new Attribute Evaluator ( text ) ; } else if ( text . index Of ( Index Evaluator . FUNC LAST ) != - NUM_ ) { return new Index Evaluator ( text ) ; } else if ( text . index Of ( Text Evaluator . FUNC TEXT ) != - NUM_ ) { return new Text Evaluator ( text ) ; } else if ( text . index Of ( Index Evaluator . FUNC POSITION ) != - NUM_ ) { return new Index Evaluator ( text ) ; } else if ( text . starts With ( STR_ ) ) { return new Attribute Evaluator ( text ) ; } else if ( text . index Of ( STR_ ) != - NUM_ ) { return new Contains Evaluator ( text ) ; } else if ( text . index Of ( STR_ ) != - NUM_ ) { return new Text Evaluator ( text ) ; } throw new Illegal State Exception ( STR_ + text ) ; }
public void update Button Action Performed ( ) { if ( ! check Consistency ( ) ) { return ; } set Node Parameters ( ) ; changed Node = true ; edit Mode = false ; cur Node = null ; add Button . set Visible ( true ) ; edit Button . set Visible ( true ) ; delete Button . set Visible ( true ) ; done Button . set Visible ( true ) ; update Button . set Visible ( false ) ; cancel Button . set Visible ( false ) ; status Text 2 . set Text ( std Status 2 ) ; status Text 3 . set Text ( std Status 3 ) ; try { status Text 1 . set Text ( Bundle . get Message ( STR_ ) + STR_ + read Node Address ( ) ) ; } catch ( Illegal Argument Exception iae ) { } error In Status 1 = true ; }
@ Not Null private Flutter Daemon Controller controller For ( String project Dir , String device Id ) { synchronized ( my Lock ) { Flutter Daemon Controller new Controller = new Flutter Daemon Controller ( project Dir ) ; my Controllers . add ( new Controller ) ; new Controller . add Listener ( my Listener ) ; return new Controller ; } }
protected void exit ( int code ) { System . exit ( code ) ; }
public void remove Web Event Listener ( String type , Action Listener listener ) { Event Dispatcher e = get Event Dispatcher ( type , false ) ; if ( e != null ) { e . remove Listener ( listener ) ; if ( ! e . has Listeners ( ) ) { listeners . remove ( type ) ; } } }
private void finalize Additions ( boolean add Home Screen Shortcuts ) { finalize Work Folder ( ) ; if ( add Home Screen Shortcuts && ! m Homescreen Apps . is Empty ( ) ) { m Model . add And Bind Added Workspace Items ( m Context , m Homescreen Apps ) ; } }
public static < T > T show Dialog ( Window Based Text GUI text GUI , String title , String description , int list Box Height , T ... items ) { int width = NUM_ ; for ( T item : items ) { width = Math . max ( width , Terminal Text Utils . get Column Width ( item . to String ( ) ) ) ; } width += NUM_ ; return show Dialog ( text GUI , title , description , new Terminal Size ( width , list Box Height ) , items ) ; }
public static void assert Equals ( String message , Nominal Mapping expected , Nominal Mapping actual , boolean ignore Order ) { if ( expected == actual ) { return ; } Assert . assert True ( expected == null && actual == null || expected != null && actual != null ) ; if ( expected == null || actual == null ) { return ; } Assert . assert Equals ( message + STR_ , expected . size ( ) , actual . size ( ) ) ; List < String > expected Values = expected . get Values ( ) ; List < String > actual Values = actual . get Values ( ) ; Set < String > expected Values Set = new Hash Set < String > ( expected Values ) ; Set < String > actual Values Set = new Hash Set < String > ( actual Values ) ; Assert . assert Equals ( message + STR_ , expected Values Set , actual Values Set ) ; if ( ! ignore Order ) { Iterator < String > expected It = expected Values . iterator ( ) ; while ( expected It . has Next ( ) ) { String expected Value = expected It . next ( ) ; Assert . assert Equals ( message + STR_ + expected Value + STR_ , expected . map String ( expected Value ) , actual . map String ( expected Value ) ) ; } } }
@ Override public boolean contains ( Object object ) { return index Of ( object , NUM_ ) != - NUM_ ; }
@ Override public void persist ( Collection < Raw Protein < Panther Raw Match > > filtered Proteins , Map < String , Signature > model Id To Signature Map , Map < String , Protein > protein Id To Protein Map ) { for ( Raw Protein < Panther Raw Match > raw Protein : filtered Proteins ) { Protein protein = protein Id To Protein Map . get ( raw Protein . get Protein Identifier ( ) ) ; if ( protein == null ) { throw new Illegal State Exception ( STR_ + STR_ + raw Protein . get Protein Identifier ( ) + STR_ ) ; } Set < Panther Match . Panther Location > locations = null ; String current Signature Ac = null ; Signature current Signature = null ; Panther Raw Match last Raw Match = null ; Panther Match match = null ; for ( Panther Raw Match raw Match : raw Protein . get Matches ( ) ) { if ( raw Match == null ) { continue ; } if ( current Signature Ac == null || ! current Signature Ac . equals ( raw Match . get Model Id ( ) ) ) { if ( current Signature Ac != null ) { if ( match != null ) { entity Manager . persist ( match ) ; } match = new Panther Match ( current Signature , locations , last Raw Match . get Evalue ( ) , last Raw Match . get Family Name ( ) , last Raw Match . get Score ( ) ) ; protein . add Match ( match ) ; } locations = new Hash Set < Panther Match . Panther Location > ( ) ; current Signature Ac = raw Match . get Model Id ( ) ; current Signature = model Id To Signature Map . get ( current Signature Ac ) ; if ( current Signature == null ) { throw new Illegal State Exception ( STR_ + current Signature Ac + STR_ ) ; } } LOGGER . debug ( STR_ + protein . get Sequence Length ( ) + STR_ + raw Match . get Location Start ( ) + STR_ + raw Match . get Location End ( ) ) ; if ( ! panther Location Within Range ( protein , raw Match ) ) { LOGGER . error ( STR_ + STR_ + protein . get Sequence Length ( ) + STR_ + raw Match . to String ( ) ) ; throw new Illegal State Exception ( STR_ + current Signature Ac + STR_ + protein . get Sequence Length ( ) + STR_ + raw Match . to String ( ) ) ; } locations . add ( new Panther Match . Panther Location ( raw Match . get Location Start ( ) , raw Match . get Location End ( ) ) ) ; last Raw Match = raw Match ; } if ( last Raw Match != null ) { match = new Panther Match ( current Signature , locations , last Raw Match . get Evalue ( ) , last Raw Match . get Family Name ( ) , last Raw Match . get Score ( ) ) ; protein . add Match ( match ) ; entity Manager . persist ( match ) ; } } }
public void process ( J Cas jcas ) throws Analysis Engine Process Exception { if ( annotate tokens ) if ( language . equals ( Language . CHINESE ) ) tokenize Chinese ( jcas ) ; else tokenize ( jcas ) ; if ( annotate partofspeech ) do Tree Tag ( jcas ) ; if ( this . language == Language . GERMAN ) improve German Sentences ( jcas ) ; if ( this . language == Language . FRENCH ) improve French Sentences ( jcas ) ; }
public static boolean equals ( Char Sequence a , Char Sequence b ) { if ( a . length ( ) != b . length ( ) ) { return false ; } int length = a . length ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { if ( a . char At ( i ) != b . char At ( i ) ) { return false ; } } return true ; }
public void store Stack For Exception ( Throwable t , int current Stack Frame ) { if ( ! exception Stack . contains Key ( t ) ) { int [ ] s = new int [ stack Pointer + NUM_ ] ; System . arraycopy ( stack , NUM_ , s , NUM_ , stack Pointer ) ; s [ stack Pointer ] = current Stack Frame ; exception Stack . put ( t , s ) ; } }
public static boolean create Movement ( M Acct Schema as , int AD Org ID , int M Product ID , int M Attribute Set Instance ID , int M Movement Line ID , int M Cost Element ID , Big Decimal Amt , Big Decimal Qty , boolean from , String Description , String trx Name ) { String sql = STR_ + STR_ + STR_ + M Movement Line ID + STR_ + ( from ? STR_ : STR_ ) + STR_ + as . get C Acct Schema ID ( ) + STR_ + M Attribute Set Instance ID ; int no = DB . execute Update ( sql , trx Name ) ; if ( no != NUM_ ) s log . config ( STR_ + no ) ; M Cost Detail cd = get ( as . get Ctx ( ) , STR_ + ( from ? STR_ : STR_ ) , M Movement Line ID , M Attribute Set Instance ID , as . get C Acct Schema ID ( ) , trx Name ) ; if ( cd == null ) { cd = new M Cost Detail ( as , AD Org ID , M Product ID , M Attribute Set Instance ID , M Cost Element ID , Amt , Qty , Description , trx Name ) ; cd . set M Movement Line ID ( M Movement Line ID ) ; cd . set Is SO Trx ( from ) ; } else { cd . set Delta Amt ( Amt . subtract ( cd . get Amt ( ) ) ) ; cd . set Delta Qty ( Qty . subtract ( cd . get Qty ( ) ) ) ; if ( cd . is Delta ( ) ) { cd . set Processed ( false ) ; cd . set Amt ( Amt ) ; cd . set Qty ( Qty ) ; } else return true ; } boolean ok = cd . save ( ) ; if ( ok && ! cd . is Processed ( ) ) { M Client client = M Client . get ( as . get Ctx ( ) , as . get AD Client ID ( ) ) ; if ( client . is Cost Immediate ( ) ) cd . process ( ) ; } s log . config ( STR_ + ok + STR_ + cd ) ; return ok ; }
public void draw Background ( Graphics 2 D g , java . awt . Paint paint ) { g . set Paint ( paint ) ; draw Background ( g ) ; }
@ Deprecated public static void create ( M Client client ) { M Acct Schema [ ] ass = M Acct Schema . get Client Acct Schema ( client . get Ctx ( ) , client . get AD Client ID ( ) ) ; String trx Name = client . get Trx Name ( ) ; String trx Name Used = trx Name ; Trx trx = null ; if ( trx Name == null ) { trx Name Used = Trx . create Trx Name ( STR_ ) ; trx = Trx . get ( trx Name Used , true ) ; } boolean success = true ; String sql = STR_ + STR_ + STR_ + STR_ ; Prepared Statement pstmt = null ; try { pstmt = DB . prepare Statement ( sql , trx Name Used ) ; pstmt . set Int ( NUM_ , client . get AD Client ID ( ) ) ; Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { M Product product = new M Product ( client . get Ctx ( ) , rs , trx Name Used ) ; for ( int i = NUM_ ; i < ass . length ; i ++ ) { Big Decimal cost = get Current Cost ( product , NUM_ , ass [ i ] , NUM_ , NUM_ , null , Env . ONE , NUM_ , false , trx Name Used ) ; s log . info ( product . get Name ( ) + STR_ + cost ) ; } } rs . close ( ) ; pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { s log . log ( Level . SEVERE , sql , e ) ; success = false ; } try { if ( pstmt != null ) pstmt . close ( ) ; pstmt = null ; } catch ( Exception e ) { pstmt = null ; } if ( trx != null ) { if ( success ) trx . commit ( ) ; else trx . rollback ( ) ; trx . close ( ) ; } }
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { return invoke ( proxy , new Standard Method ( method ) , args ) ; }
public Generic File Output Operator ( ) { set Tuple Separator ( System . get Property ( STR_ ) ) ; set Expire Stream After Access Millis ( DEFAULT STREAM EXPIRY ACCESS MILL ) ; set Rotation Windows ( DEFAULT ROTATION WINDOWS ) ; }
public void rollback ( int task Id ) { Concurrent Linked Queue < Repl DBMS Event > queue = task Queues . get ( task Id ) ; synchronized ( queue ) { if ( queue . size ( ) > NUM_ ) { queue . clear ( ) ; } } }
protected void generate Document Children ( Element root , Document doc , Tree delphi Node ) { if ( root == null || doc == null ) { return ; } for ( int i = NUM_ ; i < delphi Node . get Child Count ( ) ; ++ i ) { Tree child Node = delphi Node . get Child ( i ) ; String processed Name = process Node Name ( child Node ) ; Element child = null ; try { child = doc . create Element ( processed Name ) ; } catch ( DOM Exception e ) { child = doc . create Element ( STR_ ) ; } child . set Text Content ( child Node . get Text ( ) ) ; child . set Attribute ( STR_ , String . value Of ( child Node . get Line ( ) ) ) ; child . set Attribute ( STR_ , String . value Of ( child Node . get Char Position In Line ( ) ) ) ; child . set Attribute ( STR_ , STR_ ) ; child . set Attribute ( STR_ , STR_ ) ; child . set Attribute ( STR_ , STR_ ) ; child . set Attribute ( STR_ , String . value Of ( child Node . get Type ( ) ) ) ; root . append Child ( child ) ; generate Document Children ( child , doc , child Node ) ; } }
protected Long seed Buckets With Highest Version ( Solr Index Searcher new Searcher , Version Info versions ) { Long highest Version = null ; final R Timer timer = new R Timer ( ) ; try ( Recent Updates recent Updates = get Recent Updates ( ) ) { long max Version From Recent = recent Updates . get Max Recent Version ( ) ; long max Version From Index = versions . get Max Version From Index ( new Searcher ) ; long max Version = Math . max ( max Version From Index , max Version From Recent ) ; if ( max Version == NUM_ ) { max Version = versions . get New Clock ( ) ; log . info ( STR_ , max Version ) ; } versions . seed Buckets With Highest Version ( max Version ) ; highest Version = max Version ; } catch ( IO Exception io Exc ) { log . warn ( STR_ + io Exc , io Exc ) ; } log . debug ( STR_ , timer . get Time ( ) , String . value Of ( highest Version ) ) ; return highest Version ; }
public Bytes Ref ( Char Sequence text ) { this ( new byte [ Unicode Util . MAX UTF 8 BYTES PER CHAR * text . length ( ) ] ) ; length = Unicode Util . UTF 16 to UTF 8 ( text , NUM_ , text . length ( ) , bytes ) ; }
private String random Hash ( final String folder ) throws Exception { try { Message Digest algorithm = Message Digest . get Instance ( STR_ ) ; algorithm . reset ( ) ; try { algorithm . update ( folder . get Bytes ( STR_ ) ) ; } catch ( Unsupported Encoding Exception e ) { if ( configuration . is Debug Mode ( ) ) { throw e ; } algorithm . update ( folder . get Bytes ( ) ) ; } byte [ ] message Digest = algorithm . digest ( ) ; String Buffer hex String = new String Buffer ( ) ; for ( int i = NUM_ ; i < message Digest . length ; i ++ ) { hex String . append ( Integer . to Hex String ( HASH & message Digest [ i ] ) ) ; } return hex String . to String ( ) ; } catch ( No Such Algorithm Exception e ) { if ( configuration . is Debug Mode ( ) ) { throw e ; } return STR_ ; } }
private String generate Query ( String qry , Table Descriptor tbl ) throws Ignite Checked Exception { assert tbl != null ; final String qry 0 = qry ; String t = tbl . full Table Name ( ) ; String from = STR_ ; qry = qry . trim ( ) ; String upper = qry . to Upper Case ( ) ; if ( upper . starts With ( STR_ ) ) { qry = qry . substring ( NUM_ ) . trim ( ) ; final int star = qry . index Of ( STR_ ) ; if ( star == NUM_ ) qry = qry . substring ( NUM_ ) . trim ( ) ; else if ( star > NUM_ ) { if ( F . eq ( STR_ , qry . char At ( star - NUM_ ) ) ) { t = qry . substring ( NUM_ , star - NUM_ ) ; qry = qry . substring ( star + NUM_ ) . trim ( ) ; } else throw new Ignite Checked Exception ( STR_ + qry 0 ) ; } else throw new Ignite Checked Exception ( STR_ + STR_ + qry 0 ) ; upper = qry . to Upper Case ( ) ; } if ( ! upper . starts With ( STR_ ) ) from = STR_ + t + ( upper . starts With ( STR_ ) || upper . starts With ( STR_ ) || upper . starts With ( STR_ ) ? STR_ : STR_ ) ; qry = STR_ + t + STR_ + KEY FIELD NAME + STR_ + t + STR_ + VAL FIELD NAME + from + qry ; return qry ; }
synchronized public void stop Warrant ( boolean abort ) { if ( next Signal != null ) { next Signal . remove Property Change Listener ( this ) ; next Signal = null ; } super . stop Warrant ( abort ) ; }
public void boot ( ) { if ( Controller . options . LOGGING LEVEL >= NUM_ ) { try { log = new Print Stream ( new File Output Stream ( Controller . options . LOGFILE NAME ) ) ; synchronized ( log ) { log . println ( get Time ( ) + STR_ ) ; log . println ( Controller . options ) ; } } catch ( IO Exception e ) { VM . sys Write ( STR_ ) ; VM . sys Write ( STR_ ) ; } } booted = true ; }
public void add Handler ( Handler handler ) throws Security Exception { handler . get Class ( ) ; check Permission ( ) ; handlers . add ( handler ) ; }
private String print X Format ( int x ) { String sx = null ; if ( x == Integer . MIN VALUE ) sx = STR_ ; else if ( x < NUM_ ) { String t = Integer . to String ( ( ~ ( - x - NUM_ ) ) ^ Integer . MIN VALUE , NUM_ ) ; switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : switch ( t . char At ( NUM_ ) ) { case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; } break ; } } else sx = Integer . to String ( x , NUM_ ) ; return print X Format ( sx ) ; }
public final void add Validation State ( Validation State vs ) { f V Ss . add ( vs ) ; }
public final void populate Properties ( Internal Session old Session , Internal Session new Session , boolean force Auth ) { Enumeration < String > all Properties = old Session . get Property Names ( ) ; while ( all Properties . has More Elements ( ) ) { String key = all Properties . next Element ( ) ; String value = ( String ) old Session . get Property ( key ) ; if ( should Copy ( key ) ) { if ( ! force Auth ) { update Property ( new Session , key , value ) ; } else { update Property ( old Session , key , value ) ; } } } }
public void transform Over Scroll Canvas ( float offset Y , Canvas canvas , View view ) { final int translate Y = Math . round ( offset Y * DEFAULT DRAW TRANSLATE RATE ) ; canvas . translate ( NUM_ , translate Y ) ; }
private List < Permission Rule > access ( String permission Name ) { List < Permission Rule > rules = effective . get ( permission Name ) ; if ( rules != null ) { return rules ; } rules = capabilities . get Permission ( permission Name ) ; Group Membership groups = user . get Effective Groups ( ) ; List < Permission Rule > mine = new Array List < > ( rules . size ( ) ) ; for ( Permission Rule rule : rules ) { if ( match ( groups , rule ) ) { mine . add ( rule ) ; } } if ( mine . is Empty ( ) ) { mine = Collections . empty List ( ) ; } effective . put ( permission Name , mine ) ; return mine ; }
protected String compute ( Date date Date , String pattern String , String locale String ) { if ( date Date == null || pattern String == null || locale String == null ) { return null ; } Locale locale = new Locale ( locale String ) ; Simple Date Format simple Date Formatter ; try { simple Date Formatter = new Simple Date Format ( pattern String , locale ) ; } catch ( Illegal Argument Exception e ) { throw new Function Input Exception ( STR_ , get Function Name ( ) ) ; } String result = simple Date Formatter . format ( date Date ) ; return result ; }
private void populate Ceph Access Profile ( Access Profile access Profile , Storage Provider provider Info ) { access Profile . set System Id ( provider Info . get Id ( ) ) ; access Profile . set System Clazz ( provider Info . get Class ( ) ) ; access Profile . set Ip Address ( provider Info . get IP Address ( ) ) ; access Profile . set User Name ( provider Info . get User Name ( ) ) ; access Profile . set Password ( provider Info . get Password ( ) ) ; access Profile . set System Type ( STR_ ) ; }
private void initialize Randomization Startpoints ( int increment Size ) { this . random Startpoints = new Concurrent Linked Queue < Integer > ( ) ; int increments = lucene Utils . get Num Docs ( ) / increment Size ; boolean remainder = lucene Utils . get Num Docs ( ) % increment Size > NUM_ ; if ( remainder ) increments ++ ; Array List < Integer > to Randomize = new Array List < Integer > ( ) ; for ( int x = NUM_ ; x < increments ; x ++ ) to Randomize . add ( x * increment Size ) ; Collections . shuffle ( to Randomize ) ; random Startpoints . add All ( to Randomize ) ; }
protected void update Replacement Length For String ( I Document document , int offset , String replacement ) { boolean is String = replacement . starts With ( STR_ ) || replacement . starts With ( STR_ ) ; if ( is String ) { int length = document . get Length ( ) ; int pos = offset ; char c ; while ( pos < length ) { try { c = document . get Char ( pos ) ; switch ( c ) { case STR_ : case STR_ : case STR_ : case STR_ : return ; case STR_ : case STR_ : set Replacement Length ( get Replacement Length ( ) + pos - offset + NUM_ ) ; return ; } ++ pos ; } catch ( Bad Location Exception e ) { e . print Stack Trace ( ) ; } } } }
private boolean generate Remove Animation ( View child ) { if ( m Is Expanded && m Animations Enabled ) { if ( ! m Children To Add Animated . contains ( child ) ) { m Children To Remove Animated . add ( child ) ; m Needs Animation = true ; return true ; } else { m Children To Add Animated . remove ( child ) ; m From More Card Additions . remove ( child ) ; return false ; } } return false ; }
private void prepare Volume Data ( ) throws Exception { log . info ( STR_ ) ; for ( int i = NUM_ ; i < INSTANCES TO CREATE ; i ++ ) { Volume clone Vol = new Volume ( ) ; URI clone URI = URI Util . create Id ( Volume . class ) ; URI source URI = URI Util . create Id ( Volume . class ) ; clone Vol . set Id ( clone URI ) ; clone Vol . set Associated Source Volume ( source URI ) ; db Client . create Object ( clone Vol ) ; clone UR Is . add ( clone URI ) ; } }
@ Override public void install ( J Editor Pane editor ) { super . install ( editor ) ; editor . add Key Listener ( this ) ; }
private void write Keystore ( File config Defaults ) throws IO Exception { File keystore XML = new File ( config Defaults , STR_ ) ; Print Stream writer = Server Config Utils . open ( keystore XML ) ; writer . print ( STR_ ) ; writer . print ( gen Password ( ) ) ; writer . println ( STR_ ) ; Server Config Utils . close ( writer ) ; }
protected @ SQ Lite Open Options int determine Open Options ( File database File ) { @ SQ Lite Open Options int flags = NUM_ ; File wal File = new File ( database File . get Parent ( ) , database File . get Name ( ) + STR_ ) ; if ( wal File . exists ( ) ) { flags |= SQ Lite Database Compat . ENABLE WRITE AHEAD LOGGING ; } return flags ; }
private List load Java API Master Data List ( final String class Name , final String method Name , final String parametertype [ ] , final String parametervalue [ ] ) throws Application Runtime Exception { List list = null ; try { if ( parametertype . length != parametervalue . length ) throw new Application Runtime Exception ( STR_ ) ; final Class cls = Class . for Name ( class Name ) ; final Method method = cls . get Method ( method Name , load Method Parameter ( parametertype ) ) ; list = ( List ) method . invoke ( cls . new Instance ( ) , load Method Arguments ( parametertype , parametervalue ) ) ; } catch ( final Exception e ) { LOGGER . error ( STR_ , e ) ; throw new Application Runtime Exception ( STR_ , e ) ; } return list ; }
void Runge Kutta ( double t 2 ) { if ( klast == kmax - NUM_ ) throw new Runtime Exception ( STR_ ) ; if ( klast == - NUM_ ) { set Init ( ) ; T [ NUM_ ] = NUM_ ; ++ klast ; } if ( t 2 == NUM_ ) return ; int i , nstp ; double t 1 = T [ klast ] ; double t = t 1 ; double tsav = t 1 ; for ( i = NUM_ ; i < nvar ; i ++ ) y [ i ] = Y [ i ] [ klast ] ; double h = hinit ; for ( nstp = NUM_ ; nstp < MAXSTP ; nstp ++ ) { double tmp = nstp ; if ( nstp > MAXSTP / NUM_ ) { tmp = tmp + NUM_ ; } derivs ( t , y , dydt ) ; for ( i = NUM_ ; i < nvar ; i ++ ) yscal [ i ] = Math . abs ( y [ i ] ) + Math . abs ( dydt [ i ] * h ) + TINY ; if ( klast < kmax - NUM_ && Math . abs ( t - tsav ) > Math . abs ( dtsav ) ) { ++ klast ; for ( i = NUM_ ; i < nvar ; i ++ ) Y [ i ] [ klast ] = y [ i ] ; T [ klast ] = t ; tsav = t ; } if ( ( t + h - t 2 ) * ( t + h - t 1 ) > NUM_ ) h = t 2 - t ; t = rkqs ( y , dydt , t , h , yscal ) ; if ( hdid == h ) ++ nok ; else ++ nbad ; if ( ( t - t 2 ) * ( t 2 - t 1 ) >= NUM_ ) { if ( klast < kmax - NUM_ ) { ++ klast ; for ( i = NUM_ ; i < nvar ; i ++ ) Y [ i ] [ klast ] = y [ i ] ; T [ klast ] = t ; } return ; } if ( Math . abs ( hnext ) <= hmin ) { throw new Runtime Exception ( STR_ ) ; } h = hnext ; } throw new Runtime Exception ( STR_ ) ; }
private Counting Thread Pool Executor create Executor ( int num Threads ) { return new Counting Thread Pool Executor ( max Thread Num == - NUM_ ? num Threads : Math . min ( max Thread Num , num Threads ) , Integer . MAX VALUE , NUM_ , Time Unit . SECONDS , new Linked Blocking Queue < Runnable > ( ) ) ; }
public void enable Drag ( ) { m Drag Enabled = true ; }
private void remove Id Repo ( String org Name ) { org Name = DN Utils . normalize DN ( org Name ) ; Map idrepos = null ; synchronized ( idrepo Plugins ) { clear Read Only Plugins ( org Name ) ; idrepos = ( Map ) idrepo Plugins . remove ( org Name ) ; } if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + org Name + STR_ + idrepos . key Set ( ) ) ; } Shutdown Id Repo Plugin shutdownrepos = new Shutdown Id Repo Plugin ( idrepos ) ; scheduler . schedule ( shutdownrepos , NUM_ , Time Unit . MILLISECONDS ) ; }
private Button create Push Button ( Composite parent , String key , String key Override ) { Button button = new Button ( parent , SWT . PUSH ) ; button . set Text ( key != null ? J Face Resources . get String ( key ) : key Override ) ; button . set Font ( parent . get Font ( ) ) ; Grid Data data = new Grid Data ( Grid Data . FILL HORIZONTAL ) ; int width Hint = convert Horizontal DL Us To Pixels ( button , I Dialog Constants . BUTTON WIDTH ) ; data . width Hint = Math . max ( width Hint , button . compute Size ( SWT . DEFAULT , SWT . DEFAULT , true ) . x ) ; button . set Layout Data ( data ) ; button . add Selection Listener ( get Selection Listener ( ) ) ; return button ; }
private Block Mirror query Mirror ( URI id ) { Arg Validator . check Uri ( id ) ; Block Mirror mirror = permissions Helper . get Object By Id ( id , Block Mirror . class ) ; Arg Validator . check Entity Not Null ( mirror , id , is Id Embedded In URL ( id ) ) ; return mirror ; }
private void request For Upload ( OC File file ) { Intent i = new Intent ( m Context , File Uploader . class ) ; i . put Extra ( File Uploader . KEY ACCOUNT , m Account ) ; i . put Extra ( File Uploader . KEY FILE , file ) ; i . put Extra ( File Uploader . KEY UPLOAD TYPE , File Uploader . UPLOAD SINGLE FILE ) ; i . put Extra ( File Uploader . KEY FORCE OVERWRITE , true ) ; m Context . start Service ( i ) ; m Transfer Was Requested = true ; }
public boolean equals ( Object obj ) { if ( obj instanceof Activation Group Desc ) { Activation Group Desc desc = ( Activation Group Desc ) obj ; return ( ( class Name == null ? desc . class Name == null : class Name . equals ( desc . class Name ) ) && ( location == null ? desc . location == null : location . equals ( desc . location ) ) && ( data == null ? desc . data == null : data . equals ( desc . data ) ) && ( env == null ? desc . env == null : env . equals ( desc . env ) ) && ( props == null ? desc . props == null : props . equals ( desc . props ) ) ) ; } else { return false ; } }
public void children Removed ( Bean Context Membership Event bcme ) { Iterator it = bcme . iterator ( ) ; while ( it . has Next ( ) ) { find And Undo ( it . next ( ) ) ; } }
public double border Distance ( double lat , double lon ) { double nsdistance ; double ewdistance ; if ( south <= lat && lat <= north ) { nsdistance = NUM_ ; } else { nsdistance = Math . min ( ( Math . abs ( lat - north ) ) , ( Math . abs ( lat - south ) ) ) ; } if ( west <= lon && lon <= east ) { ewdistance = NUM_ ; } else { ewdistance = Math . min ( ( Math . abs ( lon - east ) ) , ( Math . abs ( lon - west ) ) ) ; } return Math . sqrt ( Math . pow ( nsdistance , NUM_ ) + Math . pow ( ewdistance , NUM_ ) ) ; }
@ Override public void register Listener ( Radio Listener m Radio Listener ) { if ( is Service Connected ) m Service . register Listener ( m Radio Listener ) ; else m Radio Listener Queue . add ( m Radio Listener ) ; }
private boolean scan ( ) { if ( bt Adapter . start Le Scan ( m Callback ) ) { m Scanning = true ; Log . i ( TAG , STR_ ) ; if ( m Handler . post Delayed ( scan Timeout Callback , scan Timeout * NUM_ ) ) { Log . i ( TAG , String . format ( STR_ , scan Timeout ) ) ; } else { Log . e ( TAG , STR_ ) ; } return true ; } else { Log . i ( TAG , STR_ ) ; return false ; } }
public void add Change Listener ( Property Change Listener new Listener ) { listener . add ( new Listener ) ; }
protected void save Transformed Data ( Instances ti ) { J File Chooser fc ; int ret Val ; Buffered Writer writer ; Extension File Filter filter ; fc = new J File Chooser ( ) ; filter = new Extension File Filter ( STR_ , STR_ ) ; fc . set File Filter ( filter ) ; ret Val = fc . show Save Dialog ( this ) ; if ( ret Val == J File Chooser . APPROVE OPTION ) { try { writer = new Buffered Writer ( new File Writer ( fc . get Selected File ( ) ) ) ; writer . write ( ti . to String ( ) ) ; writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; m Log . log Message ( STR_ + e . get Message ( ) ) ; J Option Pane . show Message Dialog ( this , STR_ + e . get Message ( ) , STR_ , J Option Pane . ERROR MESSAGE ) ; } } }
public synchronized Set < K > key Set ( ) { Hash Set < K > set = new Hash Set < K > ( ) ; for ( Segment < K , V > s : segments ) { set . add All ( s . key Set ( ) ) ; } return set ; }
public void fill Default Values ( ) { tf Activation Probability . set Text ( Double . to String ( PROTOTYPE RESPONDER . get Activation Probability ( ) ) ) ; tf Response Value . set Text ( Double . to String ( PROTOTYPE RESPONDER . get Activation Probability ( ) ) ) ; }
public static double [ ] quantiles ( int n , double [ ] values ) { values = ( double [ ] ) values . clone ( ) ; Arrays . sort ( values ) ; double [ ] qtls = new double [ n + NUM_ ] ; for ( int i = NUM_ ; i <= n ; ++ i ) { qtls [ i ] = values [ ( ( values . length - NUM_ ) * i ) / n ] ; } return qtls ; }
public static boolean create Shipment ( M Acct Schema as , int AD Org ID , int M Product ID , int M Attribute Set Instance ID , int M In Out Line ID , int M Cost Element ID , Big Decimal Amt , Big Decimal Qty , String Description , boolean Is SO Trx , String trx Name ) { String sql = STR_ + STR_ + STR_ + M In Out Line ID + STR_ + as . get C Acct Schema ID ( ) + STR_ + M Attribute Set Instance ID ; int no = DB . execute Update ( sql , trx Name ) ; if ( no != NUM_ ) s log . config ( STR_ + no ) ; M Cost Detail cd = get ( as . get Ctx ( ) , STR_ , M In Out Line ID , M Attribute Set Instance ID , as . get C Acct Schema ID ( ) , trx Name ) ; if ( cd == null ) { cd = new M Cost Detail ( as , AD Org ID , M Product ID , M Attribute Set Instance ID , M Cost Element ID , Amt , Qty , Description , trx Name ) ; cd . set M In Out Line ID ( M In Out Line ID ) ; cd . set Is SO Trx ( Is SO Trx ) ; } else { cd . set Delta Amt ( Amt . subtract ( cd . get Amt ( ) ) ) ; cd . set Delta Qty ( Qty . subtract ( cd . get Qty ( ) ) ) ; if ( cd . is Delta ( ) ) { cd . set Processed ( false ) ; cd . set Amt ( Amt ) ; cd . set Qty ( Qty ) ; } else return true ; } boolean ok = cd . save ( ) ; if ( ok && ! cd . is Processed ( ) ) { M Client client = M Client . get ( as . get Ctx ( ) , as . get AD Client ID ( ) ) ; if ( client . is Cost Immediate ( ) ) cd . process ( ) ; } s log . config ( STR_ + ok + STR_ + cd ) ; return ok ; }
public static boolean is Colocation Complete ( Partitioned Region region ) { Region pr Root = Partitioned Region Helper . get PR Root ( region . get Cache ( ) ) ; Partition Region Config config = ( Partition Region Config ) pr Root . get ( region . get Region Identifier ( ) ) ; if ( config == null ) { Assert . assert True ( region . is Destroyed ( ) || region . is Closed , STR_ + region ) ; return false ; } return config . is Colocation Complete ( ) ; }
private void compute Replacement String ( List < Symbol Display Part > parameters , String Builder replacement , Arguments arguments , String indentation , int nb Indentations , boolean initial Function ) { int count = parameters . size ( ) ; Symbol Display Part part = null ; String param Name = null ; boolean has Param = false ; for ( int i = NUM_ ; i != count ; i ++ ) { part = parameters . get ( i ) ; if ( ! part . is Parameter Name ( ) ) { continue ; } if ( has Param ) { replacement . append ( COMMA ) ; replacement . append ( SPACE ) ; } int offset = replacement . length ( ) ; param Name = part . get Text ( ) ; replacement . append ( param Name ) ; arguments . add Arg ( offset , param Name . length ( ) ) ; has Param = true ; } }
private void expect Alarm At ( long millis ) { m Mock Alarm Manager . expect Alarm Time ( Alarm Manager . RTC WAKEUP , millis + Alarm Scheduler . ALARM DELAY MS ) ; }
public void register Network For Cleanup ( String network Name ) { registered Networks . add ( network Name ) ; }
public void keep ( Object obj ) { if ( children == null ) children = new Linked List ( ) ; children . add ( obj ) ; }
private Action action ( String name ) { if ( managed . contains ( name ) ) { return Action . MANAGE ; } else if ( suppressed . contains ( name ) ) { return Action . SUPPRESS ; } else if ( relayed . contains ( name ) ) { return Action . RELAY ; } else { return default Action ; } }
public void prepare ( ) { try { Properties props = System . get Properties ( ) ; props . put ( STR_ , p Protocol ) ; props . put ( STR_ , p Tls ) ; if ( mailhost != null ) { props . put ( STR_ , mailhost ) ; } props . put ( STR_ , p Auth ) ; Authenticator auth = new SMTP Authenticator ( ) ; session = Session . get Instance ( props , auth ) ; if ( log . is Debug Enabled ( ) ) { session . set Debug ( true ) ; } msg = new Mime Message ( session ) ; msg . set From ( new Internet Address ( from ) ) ; msg . set Recipients ( Message . Recipient Type . TO , Internet Address . parse ( to , false ) ) ; if ( cc != null ) { msg . set Recipients ( Message . Recipient Type . CC , Internet Address . parse ( cc , false ) ) ; } if ( bcc != null ) { msg . set Recipients ( Message . Recipient Type . BCC , Internet Address . parse ( bcc , false ) ) ; } msg . set Subject ( subject ) ; mp = new Mime Multipart ( ) ; } catch ( Messaging Exception e ) { log . warn ( STR_ , e ) ; } }
protected Transferable create Transferable ( J Component c ) { if ( c instanceof J List ) { J List list = ( J List ) c ; Object [ ] values = list . get Selected Values ( ) ; if ( values == null || values . length == NUM_ ) { return null ; } String Buffer plain Buf = new String Buffer ( ) ; String Buffer html Buf = new String Buffer ( ) ; html Buf . append ( STR_ ) ; for ( int i = NUM_ ; i < values . length ; i ++ ) { Object obj = values [ i ] ; String val = ( ( obj == null ) ? STR_ : obj . to String ( ) ) ; plain Buf . append ( val + STR_ ) ; html Buf . append ( STR_ + val + STR_ ) ; } plain Buf . delete Char At ( plain Buf . length ( ) - NUM_ ) ; html Buf . append ( STR_ ) ; return new Basic Transferable ( plain Buf . to String ( ) , html Buf . to String ( ) ) ; } return null ; }
public static void capture Movie Result ( String r ) { drop Events = false ; capture Picture Result ( r ) ; }
@ Suppress Warnings ( STR_ ) public Composite File Comparator ( Comparator < File > ... delegates ) { if ( delegates == null ) { this . delegates = ( Comparator < File > [ ] ) NO COMPARATORS ; } else { this . delegates = ( Comparator < File > [ ] ) new Comparator < ? > [ delegates . length ] ; System . arraycopy ( delegates , NUM_ , this . delegates , NUM_ , delegates . length ) ; } }
public static void sleep ( long millis ) { try { Thread . sleep ( NUM_ ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } }
public double matthews Correlation Coefficient ( int class Index ) { double num TP = num True Positives ( class Index ) ; double num TN = num True Negatives ( class Index ) ; double num FP = num False Positives ( class Index ) ; double num FN = num False Negatives ( class Index ) ; double n = ( num TP * num TN ) - ( num FP * num FN ) ; double d = ( num TP + num FP ) * ( num TP + num FN ) * ( num TN + num FP ) * ( num TN + num FN ) ; d = Math . sqrt ( d ) ; if ( d == NUM_ ) { d = NUM_ ; } return n / d ; }
private void append Default Value ( String Builder sb , Field Type field Type , Object default Value ) { if ( field Type . is Escaped Default Value ( ) ) { append Escaped Word ( sb , default Value . to String ( ) ) ; } else { sb . append ( default Value ) ; } }
private void calc Inner Bounds ( ) { final Insets INSETS = get Insets ( ) ; final int SIZE = ( get Width ( ) - INSETS . left - INSETS . right ) <= ( get Height ( ) - INSETS . top - INSETS . bottom ) ? ( get Width ( ) - INSETS . left - INSETS . right ) : ( get Height ( ) - INSETS . top - INSETS . bottom ) ; INNER BOUNDS . set Bounds ( INSETS . left , INSETS . top , SIZE , SIZE ) ; }
@ Override public int hash Code ( ) { int retval = permission . hash Code ( ) ; if ( name != null ) retval ^= name . hash Code ( ) ; if ( action != null ) retval ^= action . hash Code ( ) ; return retval ; }
public void paint Border ( Component c , Graphics g , int x , int y , int width , int height ) { if ( ( this . thickness > NUM_ ) && ( g instanceof Graphics 2 D ) ) { Graphics 2 D g 2 d = ( Graphics 2 D ) g ; Color old Color = g 2 d . get Color ( ) ; g 2 d . set Color ( this . line Color ) ; Shape outer ; Shape inner ; int offs = this . thickness ; int size = offs + offs ; if ( this . rounded Corners ) { float arc = NUM_ * offs ; outer = new Round Rectangle 2 D . Float ( x , y , width , height , offs , offs ) ; inner = new Round Rectangle 2 D . Float ( x + offs , y + offs , width - size , height - size , arc , arc ) ; } else { outer = new Rectangle 2 D . Float ( x , y , width , height ) ; inner = new Rectangle 2 D . Float ( x + offs , y + offs , width - size , height - size ) ; } Path 2 D path = new Path 2 D . Float ( Path 2 D . WIND EVEN ODD ) ; path . append ( outer , false ) ; path . append ( inner , false ) ; g 2 d . fill ( path ) ; g 2 d . set Color ( old Color ) ; } }
public static double angle Sparse Dense ( Sparse Number Vector v 1 , Number Vector v 2 ) { final int dim 2 = v 2 . get Dimensionality ( ) ; double l 1 = NUM_ , l 2 = NUM_ , cross = NUM_ ; int i 1 = v 1 . iter ( ) , d 2 = NUM_ ; while ( v 1 . iter Valid ( i 1 ) ) { final int d 1 = v 1 . iter Dim ( i 1 ) ; while ( d 2 < d 1 && d 2 < dim 2 ) { final double val = v 2 . double Value ( d 2 ) ; l 2 += val ; } if ( d 2 < dim 2 ) { final double val 1 = v 1 . iter Double Value ( i 1 ) ; final double val 2 = v 2 . double Value ( d 2 ) ; l 1 += val 1 * val 1 ; l 2 += val 2 * val 2 ; cross += val 1 * val 2 ; i 1 = v 1 . iter Advance ( i 1 ) ; ++ d 2 ; } } while ( v 1 . iter Valid ( i 1 ) ) { final double val = v 1 . iter Double Value ( i 1 ) ; l 1 += val * val ; i 1 = v 1 . iter Advance ( i 1 ) ; } while ( d 2 < dim 2 ) { final double val = v 2 . double Value ( d 2 ) ; l 2 += val * val ; ++ d 2 ; } final double a = ( cross == NUM_ ) ? NUM_ : ( l 1 == NUM_ || l 2 == NUM_ ) ? NUM_ : Math . sqrt ( ( cross / l 1 ) * ( cross / l 2 ) ) ; return ( a < NUM_ ) ? a : NUM_ ; }
@ Suppress Warnings ( STR_ ) private void init Time ( ) { Time time = new Time ( System . current Time Millis ( ) ) ; int hours = time . get Hours ( ) ; m Hour Single Digits = hours % NUM_ ; m Hour Ten Digits = hours / NUM_ ; int minutes = time . get Minutes ( ) ; m Min Single Digits = minutes % NUM_ ; m Min Ten Digits = minutes / NUM_ ; int seconds = time . get Seconds ( ) ; m Sec Single Digits = seconds % NUM_ ; m Sec Ten Digits = seconds / NUM_ ; }
static List < Structural Property Descriptor > reap Property List ( List < Structural Property Descriptor > property List ) { property List . remove ( NUM_ ) ; Array List < Structural Property Descriptor > a = new Array List < Structural Property Descriptor > ( property List . size ( ) ) ; a . add All ( property List ) ; return Collections . unmodifiable List ( a ) ; }
private void add Interest ( Selectable Channel channel , int operation , I Select Handler callback ) throws Closed Channel Exception { Selection Key key = channel . key For ( selector ) ; if ( key == null ) { channel . register ( selector , operation , callback ) ; } else if ( ! key . is Valid ( ) ) { throw new Runtime Exception ( String . format ( STR_ , operation , channel ) ) ; } else { if ( ( key . interest Ops ( ) & operation ) != NUM_ ) { throw new Runtime Exception ( String . format ( STR_ , operation , channel ) ) ; } if ( key . attachment ( ) == null ) { key . attach ( callback ) ; } else { if ( callback != key . attachment ( ) ) { throw new Runtime Exception ( STR_ + STR_ ) ; } } key . interest Ops ( key . interest Ops ( ) | operation ) ; } }
public void add Command Listener ( String form Name , Action Listener l ) { if ( local Command Listeners == null ) { local Command Listeners = new Hashtable ( ) ; } Event Dispatcher d = ( Event Dispatcher ) local Command Listeners . get ( form Name ) ; if ( d == null ) { d = new Event Dispatcher ( ) ; local Command Listeners . put ( form Name , d ) ; } d . add Listener ( l ) ; }
public Cassandra Versioner ( final Session session ) { this . session = session ; create Schema Version ( ) ; }
public Slider Bridge ( Connection Request source ) { if ( source != null ) { sources = new Connection Request [ ] { source } ; } bind Progress ( sources , this ) ; }
Cache Key ( String field , Object custom ) { this . field = field ; this . custom = custom ; }
public boolean is Diseased ( final String genome ) { final Properties p = get Properties ( genome ) ; if ( p == null ) { return false ; } return Boolean . value Of ( p . get Property ( DISEASE PROPERTY , STR_ ) ) ; }
protected void update Row Count ( ) { int maxrow = m rows . get Maximum Row ( ) + NUM_ ; Iterator cols = get Columns ( ) ; while ( cols . has Next ( ) ) { Column c = ( Column ) cols . next ( ) ; c . set Maximum Row ( maxrow ) ; } }
private boolean coord Is Calendar Cell ( float y ) { return y > cell Height ; }
public void stop Clock ( ) { if ( timer . is Running ( ) ) { fire Property Change ( TIMER STATUS , ( get Clock Direction ( ) > NUM_ ? Timer Status . FORWARD : Timer Status . BACKWARD ) , Timer Status . STOPPED ) ; fire Clock Update ( Timer Status . STOPPED ) ; timer . stop ( ) ; } }
public void find And Init ( Object obj ) { if ( obj instanceof OM Drawing Tool ) { Debug . message ( STR_ , STR_ ) ; set Drawing Tool ( ( OM Drawing Tool ) obj ) ; } }
private boolean verify Log Record ( String [ ] record , int mac Pos ) throws Exception { String Builder data = new String Builder ( ) ; for ( int m = NUM_ ; m < record . length - NUM_ ; m ++ ) { data . append ( record [ m ] ) ; } cur MAC = record [ mac Pos ] ; verified = helper . verify MAC ( data . to String ( ) , helper . to Byte Array ( cur MAC ) ) ; return verified ; }
private Protection Set query Protection Set Resource ( URI id ) { if ( id == null ) { return null ; } Protection Set ret = permissions Helper . get Object By Id ( id , Protection Set . class ) ; Arg Validator . check Entity Not Null ( ret , id , is Id Embedded In URL ( id ) ) ; return ret ; }
protected void generate Resources ( Source Printer printer ) { for ( String resource Class : resources ) { printer . println ( resource Class + STR_ ) ; } }
public boolean is Cell Editable ( Event Object e ) { if ( e instanceof Mouse Event ) { Mouse Event me = ( Mouse Event ) e ; if ( me . get Click Count ( ) >= NUM_ ) { return true ; } return false ; } if ( e == null ) { return true ; } return false ; }
@ Suppress Warnings ( STR_ ) public boolean add Telegram Listener ( Telegram Listener new Listener ) { return ( Telegram Listeners . add ( new Listener ) ) ; }
public static < T > T [ ] to Multi Element Array ( int count , T value ) { T [ ] array = ( T [ ] ) Array . new Instance ( value . get Class ( ) , count ) ; for ( int i = NUM_ ; i < count ; i ++ ) { array [ i ] = value ; } return array ; }
public static Input Stream to UTF 8 Input Stream ( String str ) { Input Stream is = null ; try { is = new Byte Array Input Stream ( str . get Bytes ( STR_ ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Assertion Error ( ) ; } return is ; }
static Compilation Watch Dog watch ( Resolved Java Method method ) { if ( ENABLED ) { Compilation Watch Dog watch Dog = WATCH DOGS . get ( ) ; if ( watch Dog == null ) { Thread current Thread = current Thread ( ) ; watch Dog = new Compilation Watch Dog ( current Thread ) ; WATCH DOGS . set ( watch Dog ) ; watch Dog . start ( ) ; } watch Dog . start Compilation ( method ) ; return watch Dog ; } return null ; }
public static double read Double ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Object . get Double ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } double value = NUM_ ; if ( ! json Object . is Null ( key ) ) { value = json Object . get Double ( key ) ; } return value ; }
private static String escape String ( String str ) { int str Len = str . length ( ) ; String Builder b = new String Builder ( str Len ) ; for ( int i = NUM_ ; i < str Len ; i ++ ) { char original = str . char At ( i ) ; if ( original >= STR_ && original <= STR_ && original != STR_ && original != STR_ ) { b . append ( original ) ; } else { b . append ( String . format ( STR_ , ( int ) original ) ) ; } } return b . to String ( ) ; }
public boolean has Page Data ( final Object key ) { Check . not Null ( key , STR_ ) ; return page Data . contains Key ( key ) ; }
public static void send SLO Requests To Other Participants ( String tenant , Logout State logout State ) throws IO Exception { log . info ( STR_ ) ; Locale locale = logout State . get Locale ( ) ; Http Servlet Response response = logout State . get Response ( ) ; Validate . not Null ( response ) ; Collection < String > saml Request Urls = logout State . generate Request Urls For Tenant ( tenant , logout State . get Message Source ( ) , locale ) ; if ( saml Request Urls == null ) return ; for ( String request Url : saml Request Urls ) { log . info ( STR_ + request Url ) ; if ( request Url != null ) { Throwable exception = null ; try { send SLO Request To Other Participant ( request Url ) ; } catch ( URI Syntax Exception e ) { exception = e ; } catch ( IO Exception e ) { exception = e ; } catch ( Key Management Exception e ) { exception = e ; } catch ( No Such Algorithm Exception e ) { exception = e ; } catch ( Key Store Exception e ) { exception = e ; } if ( exception != null ) { log . error ( STR_ + request Url , exception ) ; } } else { Saml Service Impl . send Logout Error ( locale , response , logout State , logout State . get Message Source ( ) ) ; } } }
@ Override synchronized public final Selection Key key For ( Selector selector ) { for ( Selection Key key : key List ) { if ( key != null && key . selector ( ) == selector ) { return key ; } } return null ; }
public static Token token For Url ( String url , String text ) { if ( url == null ) { return null ; } Video video = Video . match URL ( url , text ) ; if ( video != null ) { return video ; } You Tube Video yt Video = You Tube Video . match URL ( url , text ) ; if ( yt Video != null ) { return yt Video ; } Photo photo = Photo . match URL ( url , text ) ; if ( photo != null ) { return photo ; } Flickr Photo flickr Photo = Flickr Photo . match URL ( url , text ) ; if ( flickr Photo != null ) { return flickr Photo ; } return new Link ( url , text ) ; }
private static File create Temp Directory ( ) { if ( tmp != null ) { return tmp ; } try { tmp = File . create Temp File ( STR_ , null ) ; if ( ! tmp . delete ( ) ) { throw new IO Exception ( STR_ + tmp ) ; } if ( ! tmp . mkdirs ( ) ) { throw new IO Exception ( STR_ + tmp ) ; } tmp . delete On Exit ( ) ; return tmp ; } catch ( final IO Exception e ) { throw new Loader Exception ( STR_ + STR_ + e , e ) ; } }
public TCP Socket Helper ( String address , int port ) { this . address = address ; this . port = port ; create Socket ( ) ; }
public static void preinstall ( ) throws Install Failed Exception { Properties meta Configuration = Common Utils . load Meta Configuration ( ) ; File portable Settings Dir = null ; if ( ! meta Configuration . is Empty ( ) ) { portable Settings Dir = Common Utils . get Portable Settings Dir ( meta Configuration ) ; } File user Settings Dir = ( portable Settings Dir == null ) ? Common Utils . get User Settings Dir ( ) : portable Settings Dir ; preinstall ( user Settings Dir ) ; }
static private String generate Token ID ( String resource ) { if ( String Utils . is Blank ( resource ) ) { return null ; } return Hash . hash ( resource + Random String Utils . random Alphanumeric ( NUM_ ) ) ; }
public void property Change ( Property Change Event evt ) { if ( evt . get Property Name ( ) == Map Bean . Layers Property ) { listen To Layers ( ( Layer [ ] ) evt . get New Value ( ) ) ; } }
public void receive ( boolean bit ) { m Bits = Long . rotate Left ( m Bits , NUM_ ) ; m Bits &= m Mask ; if ( bit ) { m Bits += NUM_ ; } for ( I Sync Processor processor : m Sync Processors ) { processor . check Sync ( m Bits ) ; } }
public synchronized void promote ( Tile tile ) { if ( tile Queue . contains ( tile ) ) { try { tile Queue . remove ( tile ) ; tile . set Priority ( Tile . Priority . High ) ; tile Queue . put ( tile ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } } }
public void remove From Class Introspection Cache ( Class clazz ) { class Introspector . remove ( clazz ) ; }
public boolean handle Error ( DOM Error error ) { errors . add ( new DOM Error Impl ( error ) ) ; return true ; }
private void add Dummy Boundary Patch ( boolean is Shadow , int x To , Input View input View , View Point input Layout Origin ) { final Nine Patch Drawable input Drawable = get Colored Patch Drawable ( is Shadow ? R . drawable . dummy input shadow : R . drawable . dummy input ) ; final Nine Patch Drawable input Border Drawable = m Patch Manager . get Patch Drawable ( R . drawable . dummy input border ) ; int width = input Drawable . get Intrinsic Width ( ) ; if ( m Has Value Input ) { width += m Patch Manager . m Value Input Width ; } boolean in Top Row = ( input Layout Origin . y == NUM_ ) ; m Helper . set Rtl Aware Bounds ( temp Rect , m Block View Size . x , x To - width , input Layout Origin . y + ( in Top Row ? m Block Top Padding : NUM_ ) , x To , input Layout Origin . y + input View . get Row Height ( ) ) ; input Drawable . set Bounds ( temp Rect ) ; input Border Drawable . set Bounds ( temp Rect ) ; m Block Patches . add ( input Drawable ) ; m Block Border Patches . add ( input Border Drawable ) ; }
public static String escape Characters ( String s ) { if ( s == null ) { throw new Null Pointer Exception ( ) ; } s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; return s ; }
boolean is In Private Mode ( ) { return in Private Mode ; }
private I Preference Store create Combined Preference Store ( I Editor Input input ) { List stores = new Array List ( ) ; add Preference Stores ( stores , input ) ; return new Chained Preference Store ( ( I Preference Store [ ] ) stores . to Array ( new I Preference Store [ stores . size ( ) ] ) ) ; }
public Editing Graph Mouse Plugin ( int modifiers , Supplier < V > vertex Factory , Supplier < E > edge Factory ) { super ( modifiers ) ; this . cursor = Cursor . get Predefined Cursor ( Cursor . CROSSHAIR CURSOR ) ; this . vertex Support = new Simple Vertex Support < V , E > ( vertex Factory ) ; this . edge Support = new Simple Edge Support < V , E > ( edge Factory ) ; }
private void copy Plugins ( final List < Plugin Info > plugins 2 ) { for ( Plugin Info plugin Info : this . plugins ) { plugins 2 . add ( new Plugin Info ( plugin Info ) ) ; } }
public Modbus UDP Master ( String addr , int port , int timeout ) { super ( ) ; try { Inet Address slave Address = Inet Address . get By Name ( addr ) ; connection = new UDP Master Connection ( slave Address ) ; connection . set Port ( port ) ; connection . set Timeout ( timeout ) ; } catch ( Unknown Host Exception e ) { throw new Runtime Exception ( STR_ , e ) ; } }
public void action Performed ( Action Event e ) { if ( m setting ) return ; set Time ( ) ; if ( e . get Source ( ) == b OK ) { m abort = false ; dispose ( ) ; return ; } else if ( e . get Source ( ) == b Back ) { if ( -- m current Month < NUM_ ) { m current Month = NUM_ ; m current Year -- ; } m last Day = - NUM_ ; } else if ( e . get Source ( ) == b Next ) { if ( ++ m current Month > NUM_ ) { m current Month = NUM_ ; m current Year ++ ; } m last Day = - NUM_ ; } else if ( e . get Source ( ) instanceof J Button ) { J Button b = ( J Button ) e . get Source ( ) ; String text = b . get Text ( ) ; if ( text . equals ( STR_ ) ) { m calendar . set Time ( new Timestamp ( System . current Time Millis ( ) ) ) ; m current Day = m calendar . get ( java . util . Calendar . DATE ) ; m current Month = m calendar . get ( java . util . Calendar . MONTH ) + NUM_ ; m current Year = m calendar . get ( java . util . Calendar . YEAR ) ; m current 24 Hour = m calendar . get ( java . util . Calendar . HOUR OF DAY ) ; m current Minute = m calendar . get ( java . util . Calendar . MINUTE ) ; } else if ( text . equals ( STR_ ) ) { m cancel = true ; dispose ( ) ; return ; } else if ( text . equals ( Msg . get Msg ( Env . get Ctx ( ) , STR_ ) ) ) { m clear = true ; dispose ( ) ; return ; } else if ( text . length ( ) > NUM_ ) { m current Day = Integer . parse Int ( text ) ; long current Click = System . current Time Millis ( ) ; if ( m current Day == m last Day && current Click - m last Click < NUM_ ) { m abort = false ; dispose ( ) ; return ; } m last Click = current Click ; m last Day = m current Day ; } } else if ( e . get Source ( ) == cb PM ) { set Time ( ) ; m last Day = - NUM_ ; } else { m current Month = c Month . get Selected Index ( ) + NUM_ ; m last Day = - NUM_ ; } set Calendar ( ) ; }
private Url Resolver create Url Resolver ( String protocol ) { return new Default Url Resolver ( ) ; }
public void add Detector Factory ( Detector Factory factory ) { detector Factory List . add ( factory ) ; }
public boolean has Colors ( String account Name , String account Type ) { return m Cache . contains ( generate Key ( account Name , account Type ) ) ; }
public void internal Frame Activated ( Internal Frame Event e ) { if ( e . get Source ( ) == control Panel ) { active Frame = CONTROL PANEL INDEX ; } else if ( e . get Source ( ) == address Panel ) { active Frame = ADDRESS PANEL INDEX ; } else if ( e . get Source ( ) == function Panel ) { active Frame = FUNCTION PANEL INDEX ; } }
public void add Rule ( final Rule rule ) { rules . add ( rule ) ; }
public boolean is Errors ( ) { return errors ; }
protected void wait For File To Grow ( File file ) throws Exception { int current Wait Time = NUM_ ; while ( ! file . exists ( ) ) { Log . i ( LOG TAG , STR_ ) ; current Wait Time = timeout Wait ( current Wait Time , WAIT FOR DOWNLOAD POLL TIME , MAX WAIT FOR DOWNLOAD TIME , STR_ ) ; } long original Size = file . length ( ) ; while ( file . length ( ) <= original Size ) { Log . i ( LOG TAG , STR_ ) ; current Wait Time = timeout Wait ( current Wait Time , WAIT FOR DOWNLOAD POLL TIME , MAX WAIT FOR DOWNLOAD TIME , STR_ ) ; } }
public void add Or Update Extension Value ( Extension Field Value Entity extension Value ) { if ( extension Value == null ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( extension Field Values . contains ( extension Value ) ) { extension Field Values . remove ( extension Value ) ; } extension Field Values . add ( extension Value ) ; }
public Proper Big Fraction Format ( final Number Format format ) { this ( format , ( Number Format ) format . clone ( ) , ( Number Format ) format . clone ( ) ) ; }
public int calculate Partition ( int splitno , int num Partitions ) { final int partition Size = ( int ) ( Math . ceil ( ( double ) num Splits / ( double ) num Partitions ) ) ; return splitno / partition Size ; }
public List < GT Scan Range > plan Scan Ranges ( ) { Tuple Filter flat Filter = flatten To Or And Filter ( gt Filter ) ; List < Collection < Column Range > > or And Dim Ranges = translate To Or And Dim Ranges ( flat Filter ) ; List < GT Scan Range > scan Ranges = Lists . new Array List With Capacity ( or And Dim Ranges . size ( ) ) ; for ( Collection < Column Range > and Dim Ranges : or And Dim Ranges ) { GT Scan Range scan Range = new Scan Range ( and Dim Ranges ) ; if ( scan Range != null ) scan Ranges . add ( scan Range ) ; } List < GT Scan Range > merged Ranges = merge Overlap Ranges ( scan Ranges ) ; merged Ranges = merge Too Many Ranges ( merged Ranges , max Scan Ranges ) ; return merged Ranges ; }
static private String LONG Max ( ) { long temp Value = Long . MAX VALUE ; return String . value Of ( temp Value ) ; }
public Bitmap decode Sampled Bitmap From File ( File input File , int req Width , int req Height ) { Input Stream is = null ; try { try { is = new File Input Stream ( input File ) ; } catch ( Exception e ) { return null ; } final Bitmap Factory . Options options = new Bitmap Factory . Options ( ) ; options . in Just Decode Bounds = true ; Bitmap Factory . decode Stream ( is , null , options ) ; options . in Sample Size = calculate In Sample Size ( options , req Width , req Height ) ; options . in Just Decode Bounds = false ; options . in Purgeable = true ; try { is = new File Input Stream ( input File ) ; } catch ( File Not Found Exception e ) { return null ; } return Bitmap Factory . decode Stream ( is , null , options ) ; } finally { try { if ( is != null ) { is . close ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } } }
private String print O Format ( String sx ) { int n Leading Zeros = NUM_ ; int n Blanks = NUM_ ; if ( sx . equals ( STR_ ) && precision Set && precision == NUM_ ) { sx = STR_ ; } if ( precision Set ) { n Leading Zeros = precision - sx . length ( ) ; } if ( alternate Form ) { n Leading Zeros ++ ; } if ( n Leading Zeros < NUM_ ) { n Leading Zeros = NUM_ ; } if ( field Width Set ) { n Blanks = field Width - n Leading Zeros - sx . length ( ) ; } if ( n Blanks < NUM_ ) { n Blanks = NUM_ ; } final int n = n Leading Zeros + sx . length ( ) + n Blanks ; final char [ ] ca = new char [ n ] ; int i ; if ( left Justify ) { for ( i = NUM_ ; i < n Leading Zeros ; i ++ ) { ca [ i ] = STR_ ; } final char [ ] csx = sx . to Char Array ( ) ; for ( int j = NUM_ ; j < csx . length ; j ++ , i ++ ) { ca [ i ] = csx [ j ] ; } for ( int j = NUM_ ; j < n Blanks ; j ++ , i ++ ) { ca [ i ] = STR_ ; } } else { if ( leading Zeros ) { for ( i = NUM_ ; i < n Blanks ; i ++ ) { ca [ i ] = STR_ ; } } else { for ( i = NUM_ ; i < n Blanks ; i ++ ) { ca [ i ] = STR_ ; } } for ( int j = NUM_ ; j < n Leading Zeros ; j ++ , i ++ ) { ca [ i ] = STR_ ; } final char [ ] csx = sx . to Char Array ( ) ; for ( int j = NUM_ ; j < csx . length ; j ++ , i ++ ) { ca [ i ] = csx [ j ] ; } } return new String ( ca ) ; }
private void rebuild ( ) { List < BT Download Data Line > existing = new Array List < BT Download Data Line > ( list ) ; List < BT Download Data Line > hidden = new Array List < BT Download Data Line > ( HIDDEN ) ; clear ( ) ; for ( int i = NUM_ ; i < existing . size ( ) ; i ++ ) { add Sorted ( existing . get ( i ) ) ; } for ( int i = NUM_ ; i < hidden . size ( ) ; i ++ ) { BT Download Data Line tl = hidden . get ( i ) ; add Sorted ( tl ) ; } }
public static List < I Java Completion Proposal > create Proposals For Problems On Sync Type ( AST Node node , String method Binding Key ) { Rpc Pair rpc Pair = resolve Rpc Pair ( node , method Binding Key , Peer Type Resolver . ASYNC RESOLVER ) ; if ( Util . get Callback Parameter ( rpc Pair . src Method ) == null ) { return Collections . empty List ( ) ; } return create Proposal ( rpc Pair , BUILDER ) ; }
private Coordinate [ ] reduce ( Coordinate [ ] input Pts ) { Coordinate [ ] poly Pts = compute Oct Ring ( input Pts ) ; if ( poly Pts == null ) return input Pts ; Tree Set reduced Set = new Tree Set ( ) ; for ( int i = NUM_ ; i < poly Pts . length ; i ++ ) { reduced Set . add ( poly Pts [ i ] ) ; } for ( int i = NUM_ ; i < input Pts . length ; i ++ ) { if ( ! CG Algorithms . is Point In Ring ( input Pts [ i ] , poly Pts ) ) { reduced Set . add ( input Pts [ i ] ) ; } } Coordinate [ ] reduced Pts = Coordinate Arrays . to Coordinate Array ( reduced Set ) ; if ( reduced Pts . length < NUM_ ) return pad Array 3 ( reduced Pts ) ; return reduced Pts ; }
public void load Catalog Trees ( Element catalog Trees ) { List < Element > cat List = catalog Trees . get Children ( STR_ ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + cat List . size ( ) + STR_ ) ; } Catalog Tree Manager mgr = Instance Manager . get Default ( jmri . Catalog Tree Manager . class ) ; for ( int i = NUM_ ; i < cat List . size ( ) ; i ++ ) { Element elem = cat List . get ( i ) ; Attribute attr = elem . get Attribute ( STR_ ) ; if ( attr == null ) { log . warn ( STR_ + elem + STR_ + elem . get Attributes ( ) ) ; continue ; } String sys Name = attr . get Value ( ) ; String user Name = null ; attr = elem . get Attribute ( STR_ ) ; if ( attr == null ) { log . warn ( STR_ + elem . get Attributes ( ) ) ; continue ; } else { user Name = attr . get Value ( ) ; } Default Tree Model ct = ( Default Tree Model ) mgr . get By System Name ( sys Name ) ; if ( ct != null ) { continue ; } ct = ( Default Tree Model ) mgr . new Catalog Tree ( sys Name , user Name ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + sys Name + STR_ + user Name ) ; } Catalog Tree Node root = ( Catalog Tree Node ) ct . get Root ( ) ; elem = elem . get Child ( STR_ ) ; load Node ( elem , root , ct ) ; } }
public byte read Byte LE ( ) throws IO Exception { return input Stream . read Byte ( ) ; }
void compose Templates ( Elem Template Element templ ) throws Transformer Exception { templ . compose ( this ) ; for ( Elem Template Element child = templ . get First Child Elem ( ) ; child != null ; child = child . get Next Sibling Elem ( ) ) { compose Templates ( child ) ; } templ . end Compose ( this ) ; }
private boolean may Access ( Player player , Entity entity , RP Action action ) { if ( entity == null ) { return false ; } RP Object object = entity . get Container ( ) ; if ( object == null ) { return false ; } RP Slot slot = entity . get Container Slot ( ) ; if ( ! reorderable Slots . contains ( slot . get Name ( ) ) ) { return false ; } if ( slot instanceof Entity Slot ) { if ( ! is Reachable Slot ( player , slot ) ) { return false ; } } else if ( object != player ) { return false ; } do { if ( object instanceof Player ) { if ( object != player ) { logger . error ( STR_ + player . get Name ( ) + STR_ + action ) ; return false ; } } slot = object . get Container Slot ( ) ; if ( ( slot != null ) && is Reachable Slot ( player , slot ) ) { return false ; } if ( object instanceof Corpse ) { return false ; } object = object . get Container ( ) ; } while ( object != null ) ; return true ; }
@ Override public String Builder string Builder ( ) { string Builder . set Length ( NUM_ ) ; return this . string Builder ; }
public synchronized void add ( File file ) { if ( file == null ) return ; File [ ] new Value = new File [ value . length + NUM_ ] ; System . arraycopy ( value , NUM_ , new Value , NUM_ , value . length ) ; new Value [ value . length ] = file ; set Value ( new Value ) ; }
@ Override public void paint Border ( Component c , Graphics g , int x , int y , int width , int height ) { final J Component popup = ( J Component ) c ; final Image h Shadow Bg = ( Image ) popup . get Client Property ( Shadow Popup Factory . PROP HORIZONTAL BACKGROUND ) ; if ( h Shadow Bg != null ) { g . draw Image ( h Shadow Bg , x , y + height - NUM_ , c ) ; } final Image v Shadow Bg = ( Image ) popup . get Client Property ( Shadow Popup Factory . PROP VERTICAL BACKGROUND ) ; if ( v Shadow Bg != null ) { g . draw Image ( v Shadow Bg , x + width - NUM_ , y , c ) ; } g . draw Image ( SHADOW , x + NUM_ , y + height - NUM_ , x + NUM_ , y + height , NUM_ , NUM_ , NUM_ , NUM_ , null , c ) ; g . draw Image ( SHADOW , x + NUM_ , y + height - NUM_ , x + width - NUM_ , y + height , NUM_ , NUM_ , NUM_ , NUM_ , null , c ) ; g . draw Image ( SHADOW , x + width - NUM_ , y + NUM_ , x + width , y + NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , null , c ) ; g . draw Image ( SHADOW , x + width - NUM_ , y + NUM_ , x + width , y + height - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , null , c ) ; g . draw Image ( SHADOW , x + width - NUM_ , y + height - NUM_ , x + width , y + height , NUM_ , NUM_ , NUM_ , NUM_ , null , c ) ; }
public void update Button Action Performed ( ) { if ( ! check Consistency ( ) ) { return ; } set Node Parameters ( ) ; changed Node = true ; edit Mode = false ; cur Node = null ; add Button . set Visible ( true ) ; edit Button . set Visible ( true ) ; delete Button . set Visible ( true ) ; done Button . set Visible ( true ) ; update Button . set Visible ( false ) ; cancel Button . set Visible ( false ) ; status Text 2 . set Text ( std Status 2 ) ; status Text 3 . set Text ( std Status 3 ) ; status Text 1 . set Text ( Bundle . get Message ( STR_ ) + STR_ + read Node Address ( ) ) ; error In Status 1 = true ; }
private void define Text Controls ( UI Defaults d ) { String c = PAINTER PREFIX + STR_ ; String cs = PAINTER PREFIX + STR_ ; String ci = PAINTER PREFIX + STR_ ; String p = STR_ ; d . put ( p + STR_ , STR_ ) ; d . put ( p + STR_ , new Search Field Has Popup State ( ) ) ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , new Lazy Painter ( ci , Search Field Icon Painter . Which . FIND ICON DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( ci , Search Field Icon Painter . Which . FIND ICON ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( ci , Search Field Icon Painter . Which . FIND ICON ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( ci , Search Field Icon Painter . Which . FIND ICON ENABLED POPUP ) ) ; d . put ( p + STR_ , new Lazy Painter ( ci , Search Field Icon Painter . Which . FIND ICON ENABLED POPUP ) ) ; p = STR_ ; d . put ( p + STR_ , STR_ ) ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , new Lazy Painter ( ci , Search Field Icon Painter . Which . CANCEL ICON DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( ci , Search Field Icon Painter . Which . CANCEL ICON ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( ci , Search Field Icon Painter . Which . CANCEL ICON PRESSED ) ) ; p = STR_ ; d . put ( p + STR_ , STR_ ) ; d . put ( p + STR_ , new Text Field Is Search State ( ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , d . get ( STR_ ) ) ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , Color . WHITE ) ; d . put ( p + STR_ , d . get ( STR_ ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SELECTED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER FOCUSED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BACKGROUND SELECTED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BORDER DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BORDER FOCUSED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BORDER ENABLED ) ) ; p = STR_ ; d . put ( p + STR_ , STR_ ) ; d . put ( p + STR_ , new Text Field Is Search State ( ) ) ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , d . get ( STR_ ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SELECTED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER FOCUSED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER ENABLED ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BACKGROUND SELECTED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BORDER DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BORDER FOCUSED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BORDER ENABLED ) ) ; p = STR_ ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , Character . value Of ( ( char ) NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , new Integer ( NUM_ ) ) ; d . put ( p + STR_ , d . get ( STR_ ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; d . put ( p + STR_ , Color . WHITE ) ; d . put ( p + STR_ , d . get ( STR_ ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SELECTED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER FOCUSED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BACKGROUND SELECTED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BORDER DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BORDER FOCUSED ) ) ; d . put ( p + STR_ , new Lazy Painter ( cs , Search Field Painter . Which . BORDER ENABLED ) ) ; p = STR_ ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , STR_ ) ; d . put ( p + STR_ , new Text Area Not In Scroll Pane State ( ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SOLID DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SOLID ENABLED ) ) ; d . put ( p + STR_ , Color . WHITE ) ; d . put ( p + STR_ , d . get ( STR_ ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SELECTED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER FOCUSED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BORDER ENABLED ) ) ; p = STR_ ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , Boolean . TRUE ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SOLID DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SOLID ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SELECTED ) ) ; d . put ( p + STR_ , Color . WHITE ) ; d . put ( p + STR_ , d . get ( STR_ ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; p = STR_ ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , Boolean . TRUE ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SOLID DISABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SOLID ENABLED ) ) ; d . put ( p + STR_ , new Lazy Painter ( c , Text Component Painter . Which . BACKGROUND SELECTED ) ) ; d . put ( p + STR_ , Color . WHITE ) ; d . put ( p + STR_ , d . get ( STR_ ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; p = STR_ ; d . put ( p + STR_ , new Insets UI Resource ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; d . put ( p + STR_ , get Derived Color ( STR_ , NUM_ , NUM_ , NUM_ , NUM_ , true ) ) ; }
private final void compute Pawn Hash Data ( Position pos , Pawn Hash Data ph ) { int score = NUM_ ; long w Pawns = pos . piece Type BB [ Piece . WPAWN ] ; long w Pawn Files = Bit Board . south Fill ( w Pawns ) & NUM_ ; int w Double = Long . bit Count ( w Pawns ) - Long . bit Count ( w Pawn Files ) ; int w Islands = Long . bit Count ( ( ( ~ w Pawn Files ) > > > NUM_ ) & w Pawn Files ) ; int w Isolated = Long . bit Count ( ~ ( w Pawn Files << NUM_ ) & w Pawn Files & ~ ( w Pawn Files > > > NUM_ ) ) ; long b Pawns = pos . piece Type BB [ Piece . BPAWN ] ; long b Pawn Files = Bit Board . south Fill ( b Pawns ) & NUM_ ; int b Double = Long . bit Count ( b Pawns ) - Long . bit Count ( b Pawn Files ) ; int b Islands = Long . bit Count ( ( ( ~ b Pawn Files ) > > > NUM_ ) & b Pawn Files ) ; int b Isolated = Long . bit Count ( ~ ( b Pawn Files << NUM_ ) & b Pawn Files & ~ ( b Pawn Files > > > NUM_ ) ) ; score -= ( w Double - b Double ) * NUM_ ; score -= ( w Islands - b Islands ) * NUM_ ; score -= ( w Isolated - b Isolated ) * NUM_ ; long w Pawn Attacks = ( ( ( w Pawns & Bit Board . mask B To H Files ) << NUM_ ) | ( ( w Pawns & Bit Board . mask A To G Files ) << NUM_ ) ) ; long b Pawn Attacks = ( ( ( b Pawns & Bit Board . mask B To H Files ) > > > NUM_ ) | ( ( b Pawns & Bit Board . mask A To G Files ) > > > NUM_ ) ) ; long w Backward = w Pawns & ~ ( ( w Pawns | b Pawns ) > > > NUM_ ) & ( b Pawn Attacks > > > NUM_ ) & ~ Bit Board . north Fill ( w Pawn Attacks ) ; w Backward &= ( ( ( w Pawns & Bit Board . mask B To H Files ) > > > NUM_ ) | ( ( w Pawns & Bit Board . mask A To G Files ) > > > NUM_ ) ) ; w Backward &= ~ Bit Board . north Fill ( b Pawn Files ) ; long b Backward = b Pawns & ~ ( ( w Pawns | b Pawns ) << NUM_ ) & ( w Pawn Attacks << NUM_ ) & ~ Bit Board . south Fill ( b Pawn Attacks ) ; b Backward &= ( ( ( b Pawns & Bit Board . mask B To H Files ) << NUM_ ) | ( ( b Pawns & Bit Board . mask A To G Files ) << NUM_ ) ) ; b Backward &= ~ Bit Board . north Fill ( w Pawn Files ) ; score -= ( Long . bit Count ( w Backward ) - Long . bit Count ( b Backward ) ) * NUM_ ; long passed Pawns W = w Pawns & ~ Bit Board . south Fill ( b Pawns | b Pawn Attacks | ( w Pawns > > > NUM_ ) ) ; final int [ ] pp Bonus = { - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ } ; int passed Bonus W = NUM_ ; if ( passed Pawns W != NUM_ ) { long guarded Passed W = passed Pawns W & ( ( ( w Pawns & Bit Board . mask B To H Files ) << NUM_ ) | ( ( w Pawns & Bit Board . mask A To G Files ) << NUM_ ) ) ; passed Bonus W += NUM_ * Long . bit Count ( guarded Passed W ) ; long m = passed Pawns W ; while ( m != NUM_ ) { int sq = Long . number Of Trailing Zeros ( m ) ; int y = Position . get Y ( sq ) ; passed Bonus W += pp Bonus [ y ] ; m &= m - NUM_ ; } } long passed Pawns B = b Pawns & ~ Bit Board . north Fill ( w Pawns | w Pawn Attacks | ( b Pawns << NUM_ ) ) ; int passed Bonus B = NUM_ ; if ( passed Pawns B != NUM_ ) { long guarded Passed B = passed Pawns B & ( ( ( b Pawns & Bit Board . mask B To H Files ) > > > NUM_ ) | ( ( b Pawns & Bit Board . mask A To G Files ) > > > NUM_ ) ) ; passed Bonus B += NUM_ * Long . bit Count ( guarded Passed B ) ; long m = passed Pawns B ; while ( m != NUM_ ) { int sq = Long . number Of Trailing Zeros ( m ) ; int y = Position . get Y ( sq ) ; passed Bonus B += pp Bonus [ NUM_ - y ] ; m &= m - NUM_ ; } } ph . key = pos . pawn Zobrist Hash ( ) ; ph . score = score ; ph . passed Bonus W = ( short ) passed Bonus W ; ph . passed Bonus B = ( short ) passed Bonus B ; ph . passed Pawns W = passed Pawns W ; ph . passed Pawns B = passed Pawns B ; }
public void write Task Container Mapping ( String task Name , Integer container Id ) { Integer existing Container Id = task Name To Container Id . get ( task Name ) ; if ( existing Container Id != null && ! existing Container Id . equals ( container Id ) ) { log . info ( STR_ , new Object [ ] { task Name , existing Container Id , container Id } ) ; } else { log . debug ( STR_ , task Name , container Id ) ; } if ( container Id == null ) { send ( new Delete ( get Source ( ) , task Name , Set Task Container Mapping . TYPE ) ) ; task Name To Container Id . remove ( task Name ) ; } else { send ( new Set Task Container Mapping ( get Source ( ) , task Name , String . value Of ( container Id ) ) ) ; task Name To Container Id . put ( task Name , container Id ) ; } }
private Object sanitize Gauge ( Object value ) { final Object final Value ; if ( value instanceof Double && ( Double . is Infinite ( ( Double ) value ) || Double . is Na N ( ( Double ) value ) ) ) { final Value = null ; } else if ( value instanceof Float && ( Float . is Infinite ( ( Float ) value ) || Float . is Na N ( ( Float ) value ) ) ) { final Value = null ; } else { final Value = value ; } return final Value ; }
@ Worker Thread public synchronized boolean prepare Record ( int audio Source , int output Format , int audio Encoder , int sample Rate , int bit Rate , File output File ) { stop Record ( ) ; m Recorder = new Media Recorder ( ) ; m Recorder . set Audio Source ( audio Source ) ; m Recorder . set Output Format ( output Format ) ; m Recorder . set Audio Sampling Rate ( sample Rate ) ; m Recorder . set Audio Encoding Bit Rate ( bit Rate ) ; m Recorder . set Audio Encoder ( audio Encoder ) ; m Recorder . set Output File ( output File . get Absolute Path ( ) ) ; try { m Recorder . prepare ( ) ; } catch ( IO Exception exception ) { Log . w ( TAG , STR_ + exception . get Message ( ) ) ; set Error ( ERROR INTERNAL ) ; m Recorder . reset ( ) ; m Recorder . release ( ) ; m Recorder = null ; return false ; } m State = STATE PREPARED ; return true ; }
public static String approx Source Location ( Node node ) { Stack Trace Element [ ] stack Trace Elements = approx Source Stack Trace Element ( node ) ; if ( stack Trace Elements != null && stack Trace Elements . length > NUM_ ) { Stack Trace Element top = stack Trace Elements [ NUM_ ] ; if ( top . get File Name ( ) != null && top . get Line Number ( ) >= NUM_ ) { return top . get File Name ( ) + STR_ + top . get Line Number ( ) ; } } return null ; }
@ Override public Element Locator create Locator ( Field field ) { return field . is Annotation Present ( Global . class ) ? new Default Element Locator ( search Context , field ) : new Selector Scoped Element Locator ( search Context , selector , field ) ; }
protected byte [ ] generate Random Bytes ( int length ) { byte [ ] data = new byte [ length ] ; while ( length -- != NUM_ ) { data [ length ] = ( byte ) ( Math . random ( ) * ( NUM_ - NUM_ ) + NUM_ ) ; } return data ; }
public void fill Default Values ( ) { tf Learning Rate . set Text ( Double . to String ( Subtractive Normalization Rule . DEFAULT LEARNING RATE ) ) ; }
public void stop ( ) throws JMS Exception { synchronized ( this ) { ensure Open ( ) ; set Modified ( ) ; if ( ! stopped ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + to String ( ) ) ; } for ( int i = NUM_ ; i < sessions . size ( ) ; i ++ ) { GS Session Impl session = ( GS Session Impl ) sessions . get ( i ) ; session . stop ( ) ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + get Cnx Key ( ) ) ; } stopped = true ; } } }
static private void add Timestamp Format ( String Builder sb , boolean avoid Colons ) { if ( avoid Colons ) sb . append ( STR_ ) ; else sb . append ( STR_ ) ; }
public static synchronized Controller Plan find Latest Plan ( RVM Method method ) { Linked List < Controller Plan > plan List = find Plan ( method ) ; if ( plan List == null ) { return null ; } else { return plan List . get Last ( ) ; } }
@ Override public Instances define Data Format ( ) throws Exception { Random random = new Random ( get Seed ( ) ) ; set Random ( random ) ; Instances dataset ; Array List < Attribute > attributes = new Array List < Attribute > ( NUM_ ) ; Attribute attribute ; boolean class Flag = get Class Flag ( ) ; Array List < String > class Values = null ; if ( class Flag ) { class Values = new Array List < String > ( m Num Clusters ) ; } for ( int i = NUM_ ; i < get Num Attributes ( ) ; i ++ ) { attribute = new Attribute ( STR_ + i ) ; attributes . add ( attribute ) ; } if ( class Flag ) { for ( int i = NUM_ ; i < m Num Clusters ; i ++ ) { class Values . add ( STR_ + i ) ; } attribute = new Attribute ( STR_ , class Values ) ; attributes . add ( attribute ) ; } dataset = new Instances ( get Relation Name To Use ( ) , attributes , NUM_ ) ; if ( class Flag ) { dataset . set Class Index ( get Num Attributes ( ) ) ; } Instances format = new Instances ( dataset , NUM_ ) ; set Dataset Format ( format ) ; m Cluster List = define Clusters ( random ) ; return dataset ; }
void Calc Bins 4 Map ( double Range ) { int ad = NUM_ ; if ( Range % this . Lag Size == NUM_ ) { ad = NUM_ ; } bin [ ] [ ] bins 1 = new bin [ ( int ) Math . ceil ( Range / this . Lag Size ) + ad ] [ ( int ) Math . ceil ( Range / this . Lag Size + ad ) ] ; bin [ ] [ ] bins 4 = new bin [ ( int ) Math . ceil ( Range / this . Lag Size ) + ad ] [ ( int ) Math . ceil ( Range / this . Lag Size + ad ) ] ; bin [ ] [ ] bins 1 c = new bin [ ( int ) Math . ceil ( Range / this . Lag Size ) + ad ] [ ( int ) Math . ceil ( Range / this . Lag Size + ad ) ] ; bin [ ] [ ] bins 4 c = new bin [ ( int ) Math . ceil ( Range / this . Lag Size ) + ad ] [ ( int ) Math . ceil ( Range / this . Lag Size + ad ) ] ; Bin Surface = new bin [ NUM_ * ( ( int ) Math . ceil ( Range / this . Lag Size ) + ad ) ] [ NUM_ * ( ( int ) Math . ceil ( Range / this . Lag Size + ad ) ) ] ; double radious = this . Lag Size * NUM_ / Math . sqrt ( NUM_ ) ; double half Lag Size = this . Lag Size ; List < pair > prs = new Array List ( ) ; double w = NUM_ ; for ( int r = NUM_ ; r < bins 1 . length ; r ++ ) { for ( int c = NUM_ ; c < bins 1 [ r ] . length ; c ++ ) { if ( bins 1 [ r ] [ c ] == null ) { bin bb = new bin ( ) ; bin bbc = new bin ( ) ; bins 1 [ r ] [ c ] = bb ; bins 1 c [ r ] [ c ] = bbc ; } bins 1 [ r ] [ c ] . Grid Hor Distance = NUM_ * this . Lag Size + c * this . Lag Size ; bins 1 [ r ] [ c ] . Grid Ver Distance = NUM_ * this . Lag Size + r * this . Lag Size ; bins 1 c [ r ] [ c ] . Grid Hor Distance = - NUM_ * this . Lag Size - c * this . Lag Size ; bins 1 c [ r ] [ c ] . Grid Ver Distance = - NUM_ * this . Lag Size - r * this . Lag Size ; double [ ] center = new double [ ] { bins 1 [ r ] [ c ] . Grid Ver Distance , bins 1 [ r ] [ c ] . Grid Hor Distance } ; prs = get Bin NN Pairs 4 Map ( Pairs Tree , center , half Lag Size , radious ) ; for ( int n = NUM_ ; n < prs . size ( ) ; n ++ ) { bins 1 [ r ] [ c ] . Hor Distance += prs . get ( n ) . Hor Distance ; bins 1 [ r ] [ c ] . Ver Distance += prs . get ( n ) . Ver Distance ; w = ( NUM_ - ( Math . abs ( bins 1 [ r ] [ c ] . Grid Hor Distance - prs . get ( n ) . Hor Distance ) / this . Lag Size ) ) * ( NUM_ - ( Math . abs ( bins 1 [ r ] [ c ] . Grid Ver Distance - prs . get ( n ) . Ver Distance ) / this . Lag Size ) ) ; bins 1 [ r ] [ c ] . Weight += w ; bins 1 [ r ] [ c ] . Value += prs . get ( n ) . Moment I * w ; bins 1 [ r ] [ c ] . Size += NUM_ ; bins 1 c [ r ] [ c ] . Hor Distance += prs . get ( n ) . Hor Distance ; bins 1 c [ r ] [ c ] . Ver Distance += prs . get ( n ) . Ver Distance ; bins 1 c [ r ] [ c ] . Weight += w ; bins 1 c [ r ] [ c ] . Value += prs . get ( n ) . Moment I * w ; bins 1 c [ r ] [ c ] . Size += NUM_ ; } } } for ( int i = NUM_ ; i < bins 1 . length ; i ++ ) { for ( int j = NUM_ ; j < bins 1 [ i ] . length ; j ++ ) { if ( bins 1 [ i ] [ j ] == null ) { bin bb = new bin ( ) ; bins 1 [ i ] [ j ] = bb ; bins 1 [ i ] [ j ] . Hor Distance = i * this . Lag Size ; bins 1 [ i ] [ j ] . Ver Distance = j * this . Lag Size ; bins 1 [ i ] [ j ] . Value = - NUM_ ; bin bbc = new bin ( ) ; bins 1 c [ i ] [ j ] = bbc ; bins 1 c [ i ] [ j ] . Hor Distance = - i * this . Lag Size ; bins 1 c [ i ] [ j ] . Ver Distance = - j * this . Lag Size ; bins 1 c [ i ] [ j ] . Value = - NUM_ ; } else { bins 1 [ i ] [ j ] . Hor Distance = bins 1 [ i ] [ j ] . Hor Distance / bins 1 [ i ] [ j ] . Size ; bins 1 [ i ] [ j ] . Ver Distance = bins 1 [ i ] [ j ] . Ver Distance / bins 1 [ i ] [ j ] . Size ; bins 1 [ i ] [ j ] . Value = bins 1 [ i ] [ j ] . Value / bins 1 [ i ] [ j ] . Weight ; bins 1 c [ i ] [ j ] . Hor Distance = bins 1 c [ i ] [ j ] . Hor Distance / bins 1 c [ i ] [ j ] . Size ; bins 1 c [ i ] [ j ] . Ver Distance = bins 1 c [ i ] [ j ] . Ver Distance / bins 1 c [ i ] [ j ] . Size ; bins 1 c [ i ] [ j ] . Value = bins 1 c [ i ] [ j ] . Value / bins 1 c [ i ] [ j ] . Weight ; } } } for ( int r = NUM_ ; r < bins 4 . length ; r ++ ) { for ( int c = NUM_ ; c < bins 4 [ r ] . length ; c ++ ) { if ( bins 4 [ r ] [ c ] == null ) { bin bb = new bin ( ) ; bin bbc = new bin ( ) ; bins 4 [ r ] [ c ] = bb ; bins 4 c [ r ] [ c ] = bbc ; } bins 4 [ r ] [ c ] . Grid Hor Distance = NUM_ * this . Lag Size + c * this . Lag Size ; bins 4 [ r ] [ c ] . Grid Ver Distance = - NUM_ * this . Lag Size - r * this . Lag Size ; bins 4 c [ r ] [ c ] . Grid Hor Distance = - NUM_ * this . Lag Size - c * this . Lag Size ; bins 4 c [ r ] [ c ] . Grid Ver Distance = NUM_ * this . Lag Size + r * this . Lag Size ; double [ ] center = new double [ ] { bins 4 [ r ] [ c ] . Grid Ver Distance , bins 4 [ r ] [ c ] . Grid Hor Distance } ; prs = get Bin NN Pairs 4 Map ( Pairs Tree , center , half Lag Size , radious ) ; for ( int n = NUM_ ; n < prs . size ( ) ; n ++ ) { bins 4 [ r ] [ c ] . Hor Distance += prs . get ( n ) . Hor Distance ; bins 4 [ r ] [ c ] . Ver Distance += prs . get ( n ) . Ver Distance ; w = ( NUM_ - ( Math . abs ( bins 4 [ r ] [ c ] . Grid Hor Distance - prs . get ( n ) . Hor Distance ) / this . Lag Size ) ) * ( NUM_ - ( Math . abs ( bins 4 [ r ] [ c ] . Grid Ver Distance - prs . get ( n ) . Ver Distance ) / this . Lag Size ) ) ; bins 4 [ r ] [ c ] . Weight += w ; bins 4 [ r ] [ c ] . Value += prs . get ( n ) . Moment I * w ; bins 4 [ r ] [ c ] . Size += NUM_ ; bins 4 c [ r ] [ c ] . Hor Distance += prs . get ( n ) . Hor Distance ; bins 4 c [ r ] [ c ] . Ver Distance += prs . get ( n ) . Ver Distance ; bins 4 c [ r ] [ c ] . Weight += w ; bins 4 c [ r ] [ c ] . Value += prs . get ( n ) . Moment I * w ; bins 4 c [ r ] [ c ] . Size += NUM_ ; } } } for ( int i = NUM_ ; i < bins 4 . length ; i ++ ) { for ( int j = NUM_ ; j < bins 4 [ i ] . length ; j ++ ) { if ( bins 4 [ i ] [ j ] == null ) { bin bb = new bin ( ) ; bins 4 [ i ] [ j ] = bb ; bins 4 [ i ] [ j ] . Hor Distance = i * this . Lag Size ; bins 4 [ i ] [ j ] . Ver Distance = j * this . Lag Size ; bins 4 [ i ] [ j ] . Value = - NUM_ ; bin bbc = new bin ( ) ; bins 4 c [ i ] [ j ] = bbc ; bins 4 c [ i ] [ j ] . Hor Distance = - i * this . Lag Size ; bins 4 c [ i ] [ j ] . Ver Distance = - j * this . Lag Size ; bins 4 c [ i ] [ j ] . Value = - NUM_ ; } else { bins 4 [ i ] [ j ] . Hor Distance = bins 4 [ i ] [ j ] . Hor Distance / bins 4 [ i ] [ j ] . Size ; bins 4 [ i ] [ j ] . Ver Distance = bins 4 [ i ] [ j ] . Ver Distance / bins 4 [ i ] [ j ] . Size ; bins 4 [ i ] [ j ] . Value = bins 4 [ i ] [ j ] . Value / bins 4 [ i ] [ j ] . Weight ; bins 4 c [ i ] [ j ] . Hor Distance = bins 4 c [ i ] [ j ] . Hor Distance / bins 4 c [ i ] [ j ] . Size ; bins 4 c [ i ] [ j ] . Ver Distance = bins 4 c [ i ] [ j ] . Ver Distance / bins 4 c [ i ] [ j ] . Size ; bins 4 c [ i ] [ j ] . Value = bins 4 c [ i ] [ j ] . Value / bins 4 c [ i ] [ j ] . Weight ; } } } int st I = Bin Surface . length / NUM_ ; int st J = Bin Surface [ NUM_ ] . length / NUM_ ; for ( int i = NUM_ ; i < bins 1 . length ; i ++ ) { for ( int j = NUM_ ; j < bins 1 [ i ] . length ; j ++ ) { Bin Surface [ st I + i ] [ st J + j ] = bins 1 [ i ] [ j ] ; Bin Surface [ st I - NUM_ - i ] [ st J - NUM_ - j ] = bins 1 c [ i ] [ j ] ; } } st I = Bin Surface . length / NUM_ ; st J = Bin Surface [ NUM_ ] . length / NUM_ ; for ( int i = NUM_ ; i < bins 4 . length ; i ++ ) { for ( int j = NUM_ ; j < bins 4 [ i ] . length ; j ++ ) { Bin Surface [ st I - NUM_ - i ] [ st J + j ] = bins 4 [ i ] [ j ] ; Bin Surface [ st I + i ] [ st J - NUM_ - j ] = bins 4 c [ i ] [ j ] ; } } int resd = NUM_ ; }
private String email To String ( String subject , String msg , String ... to ) { return STR_ + msg + STR_ + Arrays . as List ( to ) + STR_ + subject + STR_ ; }
public static Executor Service create Background Executor ( ) { final Executor Service executor = Executors . new Single Thread Executor ( new Daemon Thread Factory ( DEFAULT BACKGROUND EXECUTOR NAME ) ) ; BACKGROUND EXECUTORS . add ( executor ) ; return executor ; }
public Sparse Array ( int initial Capacity ) { initial Capacity = ideal Int Array Size ( initial Capacity ) ; m Keys = new int [ initial Capacity ] ; Arrays . fill ( m Keys , - NUM_ ) ; m Values = new Double [ initial Capacity ] ; m Size = NUM_ ; }
protected void fire Property Change ( String property Name , boolean old Value , boolean new Value ) { Property Change Support change Support = this . change Support ; if ( change Support == null || old Value == new Value ) { return ; } change Support . fire Property Change ( property Name , old Value , new Value ) ; }
protected void print Attribute Summary ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance ) { String str = STR_ ; if ( numeric Predictor ) { str += STR_ ; } if ( nominal Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( string Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( date Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( relational Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } str = STR_ + str + STR_ ; print ( str ) ; }
private void format ( Number Format nf , String Builder buffer , double value , int max Integer Digits ) { if ( value >= NUM_ ) { buffer . append ( STR_ ) ; } else { buffer . append ( STR_ ) ; } int digits = max Integer Digits - integer Digits ( value ) ; for ( int d = NUM_ ; d < digits ; d ++ ) { buffer . append ( STR_ ) ; } buffer . append ( nf . format ( Math . abs ( value ) ) ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Compass Plot ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } Compass Plot that = ( Compass Plot ) obj ; if ( this . label Type != that . label Type ) { return false ; } if ( ! Object Utilities . equal ( this . label Font , that . label Font ) ) { return false ; } if ( this . draw Border != that . draw Border ) { return false ; } if ( ! Paint Utilities . equal ( this . rose Highlight Paint , that . rose Highlight Paint ) ) { return false ; } if ( ! Paint Utilities . equal ( this . rose Paint , that . rose Paint ) ) { return false ; } if ( ! Paint Utilities . equal ( this . rose Center Paint , that . rose Center Paint ) ) { return false ; } if ( ! Object Utilities . equal ( this . compass Font , that . compass Font ) ) { return false ; } if ( ! Arrays . equals ( this . series Needle , that . series Needle ) ) { return false ; } if ( get Revolution Distance ( ) != that . get Revolution Distance ( ) ) { return false ; } return true ; }
protected void check For Tokens ( String content , int start Offset , int end Offset ) { while ( start Offset <= end Offset ) { while ( is Delimiter ( content . substring ( start Offset , start Offset + NUM_ ) ) ) { if ( start Offset < end Offset ) { start Offset ++ ; } else { return ; } } if ( is Quote Delimiter ( content . substring ( start Offset , start Offset + NUM_ ) ) ) { start Offset = get Quote Token ( content , start Offset , end Offset ) ; } else { start Offset = get Other Token ( content , start Offset , end Offset ) ; } } }
private void calculate Colors ( int point Count , Float Buffer point Cloud Buffer ) { float [ ] points = new float [ point Count * NUM_ ] ; point Cloud Buffer . rewind ( ) ; point Cloud Buffer . get ( points ) ; point Cloud Buffer . rewind ( ) ; int color ; int color Index ; float z ; for ( int i = NUM_ ; i < point Count ; i ++ ) { z = points [ i * NUM_ + NUM_ ] ; color Index = ( int ) Math . min ( z / CLOUD MAX Z * m Palette . length , m Palette . length - NUM_ ) ; color Index = Math . max ( color Index , NUM_ ) ; color = m Palette [ color Index ] ; m Color Array [ i * NUM_ ] = Color . red ( color ) / NUM_ ; m Color Array [ i * NUM_ + NUM_ ] = Color . green ( color ) / NUM_ ; m Color Array [ i * NUM_ + NUM_ ] = Color . blue ( color ) / NUM_ ; m Color Array [ i * NUM_ + NUM_ ] = Color . alpha ( color ) / NUM_ ; } }
public static int binary Search ( double [ ] array , int start Index , int end Index , double value ) { check Index For Binary Search ( array . length , start Index , end Index ) ; long long Bits = Double . double To Long Bits ( value ) ; int low = start Index , mid = - NUM_ , high = end Index - NUM_ ; while ( low <= high ) { mid = ( low + high ) > > > NUM_ ; if ( less Than ( array [ mid ] , value ) ) { low = mid + NUM_ ; } else if ( long Bits == Double . double To Long Bits ( array [ mid ] ) ) { return mid ; } else { high = mid - NUM_ ; } } if ( mid < NUM_ ) { int insert Point = end Index ; for ( int index = start Index ; index < end Index ; index ++ ) { if ( value < array [ index ] ) { insert Point = index ; } } return - insert Point - NUM_ ; } return - mid - ( less Than ( value , array [ mid ] ) ? NUM_ : NUM_ ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Interval XY Delegate ) ) { return false ; } Interval XY Delegate that = ( Interval XY Delegate ) obj ; if ( this . auto Width != that . auto Width ) { return false ; } if ( this . interval Position Factor != that . interval Position Factor ) { return false ; } if ( this . fixed Interval Width != that . fixed Interval Width ) { return false ; } return true ; }
private void read Data Block Header ( String token To Look For , Nexus Block block ) throws Import Exception , IO Exception { boolean dim = false , ttl = false , fmt = false ; String token ; do { token = read Token ( ) ; if ( token . equals Ignore Case ( STR_ ) ) { if ( ttl ) { throw new Duplicate Field Exception ( STR_ ) ; } ttl = true ; } else if ( token . equals Ignore Case ( STR_ ) ) { if ( dim ) { throw new Duplicate Field Exception ( STR_ ) ; } boolean nchar = ( block == TAXA BLOCK ) ; boolean ntax = ( block == CHARACTERS BLOCK ) ; do { String token 2 = read Token ( STR_ ) ; if ( get Last Delimiter ( ) != STR_ ) { throw new Bad Format Exception ( STR_ + token 2 + STR_ ) ; } if ( token 2 . equals Ignore Case ( STR_ ) ) { if ( block == CHARACTERS BLOCK ) { throw new Bad Format Exception ( STR_ ) ; } taxon Count = read Integer ( STR_ ) ; ntax = true ; } else if ( token 2 . equals Ignore Case ( STR_ ) ) { if ( block == TAXA BLOCK ) { throw new Bad Format Exception ( STR_ ) ; } site Count = read Integer ( STR_ ) ; nchar = true ; } else { throw new Bad Format Exception ( STR_ + token 2 + STR_ ) ; } } while ( get Last Delimiter ( ) != STR_ ) ; if ( ! ntax ) { throw new Bad Format Exception ( STR_ ) ; } if ( ! nchar ) { throw new Bad Format Exception ( STR_ ) ; } dim = true ; } else if ( token . equals Ignore Case ( STR_ ) ) { if ( fmt ) { throw new Duplicate Field Exception ( STR_ ) ; } data Type = null ; do { String token 2 = read Token ( STR_ ) ; if ( token 2 . equals Ignore Case ( STR_ ) ) { if ( get Last Delimiter ( ) != STR_ ) { throw new Bad Format Exception ( STR_ ) ; } gap Characters = read Token ( STR_ ) ; } else if ( token 2 . equals Ignore Case ( STR_ ) ) { if ( get Last Delimiter ( ) != STR_ ) { throw new Bad Format Exception ( STR_ ) ; } missing Characters = read Token ( STR_ ) ; } else if ( token 2 . equals Ignore Case ( STR_ ) ) { if ( get Last Delimiter ( ) != STR_ ) { throw new Bad Format Exception ( STR_ ) ; } match Characters = read Token ( STR_ ) ; } else if ( token 2 . equals Ignore Case ( STR_ ) ) { if ( get Last Delimiter ( ) != STR_ ) { throw new Bad Format Exception ( STR_ ) ; } String token 3 = read Token ( STR_ ) ; if ( token 3 . equals Ignore Case ( STR_ ) || token 3 . equals Ignore Case ( STR_ ) || token 3 . equals Ignore Case ( STR_ ) ) { data Type = Nucleotides . INSTANCE ; } else if ( token 3 . equals Ignore Case ( STR_ ) || token 3 . equals Ignore Case ( STR_ ) ) { data Type = Two States . INSTANCE ; } else if ( token 3 . equals Ignore Case ( STR_ ) ) { data Type = Amino Acids . INSTANCE ; } else if ( token 3 . equals Ignore Case ( STR_ ) ) { throw new Unparsable Data Exception ( STR_ ) ; } } else if ( token 2 . equals Ignore Case ( STR_ ) ) { is Interleaved = true ; } } while ( get Last Delimiter ( ) != STR_ ) ; fmt = true ; } } while ( ! token . equals Ignore Case ( token To Look For ) ) ; if ( ! dim ) { throw new Missing Field Exception ( STR_ ) ; } if ( block != TAXA BLOCK && data Type == null ) { throw new Missing Field Exception ( STR_ ) ; } }
private boolean Load UNK ( Byte Buffer f , Sce Module module , int base Address , boolean analyze Only ) throws IO Exception { byte m 0 = f . get ( ) ; byte m 1 = f . get ( ) ; byte m 2 = f . get ( ) ; byte m 3 = f . get ( ) ; if ( m 0 == NUM_ && m 1 == NUM_ && m 2 == NUM_ && m 3 == NUM_ ) { log . info ( STR_ ) ; log . info ( STR_ ) ; } else if ( ( m 0 == NUM_ && m 1 == NUM_ && m 2 == NUM_ && m 3 == NUM_ ) ) { log . info ( STR_ ) ; } else { boolean handled = false ; if ( f . limit ( ) >= NUM_ * NUM_ + NUM_ ) { f . position ( NUM_ * NUM_ ) ; byte [ ] id = new byte [ NUM_ ] ; f . get ( id ) ; if ( ( ( ( char ) id [ NUM_ ] ) == STR_ ) && ( ( ( char ) id [ NUM_ ] ) == STR_ ) && ( ( ( char ) id [ NUM_ ] ) == STR_ ) && ( ( ( char ) id [ NUM_ ] ) == STR_ ) && ( ( ( char ) id [ NUM_ ] ) == STR_ ) ) { log . info ( STR_ ) ; log . info ( STR_ ) ; handled = true ; } } if ( ! handled ) { log . info ( STR_ ) ; log . info ( String . format ( STR_ , m 0 , m 1 , m 2 , m 3 ) ) ; if ( log . is Debug Enabled ( ) ) { byte [ ] buffer = new byte [ NUM_ ] ; buffer [ NUM_ ] = m 0 ; buffer [ NUM_ ] = m 1 ; buffer [ NUM_ ] = m 2 ; buffer [ NUM_ ] = m 3 ; f . get ( buffer , NUM_ , buffer . length - NUM_ ) ; log . debug ( String . format ( STR_ , Utilities . get Memory Dump ( buffer , NUM_ , buffer . length ) ) ) ; } } } return false ; }
private static synchronized void put Converter ( Type type , Open Type Converter conv ) { Weak Reference < Open Type Converter > wr = new Weak Reference < Open Type Converter > ( conv ) ; converter Map . put ( type , wr ) ; }
protected short rlshort ( Data Input Stream dis ) throws IO Exception { short s = NUM_ ; short high , low ; s = dis . read Short ( ) ; high = ( short ) ( ( s & NUM_ ) << NUM_ ) ; low = ( short ) ( ( s & NUM_ ) > > > NUM_ ) ; s = ( short ) ( high | low ) ; return s ; }
private void write Meta Table ( Table Entry entry ) { Temp Buffer t Buf = Temp Buffer . create ( ) ; byte [ ] buffer = t Buf . buffer ( ) ; int offset = NUM_ ; buffer [ offset ++ ] = CODE TABLE ; offset += Bits Util . write ( buffer , offset , entry . table Key ( ) ) ; offset += Bits Util . write Int 16 ( buffer , offset , entry . row Length ( ) ) ; offset += Bits Util . write Int 16 ( buffer , offset , entry . key Offset ( ) ) ; offset += Bits Util . write Int 16 ( buffer , offset , entry . key Length ( ) ) ; byte [ ] data = entry . data ( ) ; offset += Bits Util . write Int 16 ( buffer , offset , data . length ) ; System . arraycopy ( data , NUM_ , buffer , offset , data . length ) ; offset += data . length ; int crc = nonce ; crc = Crc 32 Caucho . generate ( crc , buffer , NUM_ , offset ) ; offset += Bits Util . write Int ( buffer , offset , crc ) ; try ( Out Store s Out = open Write ( meta Offset , offset ) ) { s Out . write ( meta Offset , buffer , NUM_ , offset ) ; meta Offset += offset ; } t Buf . free ( ) ; if ( meta Tail - meta Offset < NUM_ ) { write Meta Continuation ( ) ; } }
private void assign Node Location ( FXG Node node ) { if ( node != null ) { node . set Start Line ( start Line ) ; node . set Start Column ( start Column ) ; node . set End Line ( locator . get Line Number ( ) ) ; node . set End Column ( locator . get Column Number ( ) ) ; } }
protected void layout Major Axis ( int target Span , int axis , int [ ] offsets , int [ ] spans ) { if ( children == null ) { init ( ) ; } Size Requirements . calculate Tiled Positions ( target Span , null , get Child Requests ( target Span , axis ) , offsets , spans ) ; }
private static void s ua Col Sum Gt Le ( Matrix Block in , Matrix Block out , double [ ] bv , Binary Operator b Op ) throws DML Runtime Exception { int agg 0 = sum Row Sum Lt Ge Col Sum Gt Le ( NUM_ , bv , b Op ) ; out . allocate Dense Block ( true ) ; Arrays . fill ( out . get Dense Block ( ) , NUM_ , out . get Num Columns ( ) , agg 0 ) ; if ( agg 0 != NUM_ ) out . set Non Zeros ( out . get Num Columns ( ) ) ; if ( in . is Empty Block ( false ) ) return ; Sparse Block sblock = in . get Sparse Block ( ) ; for ( int j = NUM_ ; j < sblock . num Rows ( ) ; j ++ ) if ( ! sblock . is Empty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i ++ ) { int cnt = sum Row Sum Lt Ge Col Sum Gt Le ( avals [ i ] , bv , b Op ) ; out . quick Set Value ( NUM_ , aix [ i ] , cnt ) ; } } }
protected J Menu create Menu ( String key ) { J Menu menu = new J Menu ( get Resource String ( key + label Suffix ) ) ; for ( String item Key : get Item Keys ( key ) ) { if ( item Key . equals ( STR_ ) ) { menu . add Separator ( ) ; } else { J Menu Item mi = create Menu Item ( item Key ) ; menu . add ( mi ) ; } } return menu ; }
public synchronized void add Pv Change Listener ( Pv Change Listener l , int event Mask ) { ensure Pv Change Listeners ( ) ; Pv Change Listeners . put ( l , new Integer ( event Mask ) ) ; allow Events = true ; log . trace ( STR_ + to String ( ) + STR_ + String . value Of ( l ) ) ; }
public static Job Definition manually Triggerable Job Definition ( final String job Type , final String job Name , final String description , final int restarts , final Optional < Duration > max Age ) { return new Default Job Definition ( job Type , job Name , description , max Age , Optional . empty ( ) , Optional . empty ( ) , restarts , NUM_ , Optional . empty ( ) ) ; }
public Object Graph build Graph With Aditional Modules ( List < Object > modules ) { if ( modules == null ) { throw new Illegal Argument Exception ( STR_ ) ; } return object Graph . plus ( modules . to Array ( ) ) ; }
private void write Chunks ( Socket Channel channel , byte [ ] bytes , int length ) { synchronized ( channel ) { byte [ ] buff = new byte [ length ] ; System . arraycopy ( bytes , NUM_ , buff , NUM_ , length ) ; message Processor . send ( channel , bytes ) ; } }
boolean use Write Cache ( String name , IO Context context ) { if ( ! block Cache Write Enabled || name . starts With ( Index File Names . PENDING SEGMENTS ) ) { return false ; } if ( block Cache File Types != null && ! is Cachable File ( name ) ) { return false ; } switch ( context . context ) { case MERGE : { return false ; } default : { return true ; } } }
public void include ( final Path Matcher matcher ) { include Matchers . add ( matcher ) ; }
private static Igfs Path path ( String p ) { return new Igfs Path ( p ) ; }
@ Override public void reset References ( ) { refs . clear ( ) ; }
@ Override protected int eviction Extra Space ( Builder < K , V > builder ) { double factor = EVICTION SPACE PERCENT / NUM_ ; user Data Elements = builder . get Expected Map Size ( ) ; final int parallelity Eviction Space ; if ( FEATURE Extra Par Eviction Space ) { int eviction Space Per Writer = builder . get Concurrency Level ( ) * EVICTION SPACE PER WRITER ; parallelity Eviction Space = Math . min ( eviction Space Per Writer , MAXIMUM EVICTION SPACE FOR WRITERS ) ; } else { parallelity Eviction Space = NUM_ ; } long normal Eviction Space = ( long ) ( user Data Elements * factor ) ; long extra Eviction Space = Math . max ( normal Eviction Space , parallelity Eviction Space ) ; long planned Size Long = user Data Elements + extra Eviction Space ; block Start At = ( int ) Math . min ( planned Size Long , Integer . MAX VALUE ) ; evict Normally Elements = ( int ) ( ( double ) user Data Elements * FREE PERCENTAGE / NUM_ ) ; evict Normally Elements = Math . max ( NUM_ , evict Normally Elements ) ; evict Until At Least = user Data Elements - evict Normally Elements ; if ( LOG INTERNAL DATA ) { logger . info ( STR_ + id ( ) + STR_ + user Data Elements + STR_ + block Start At + STR_ + evict Until At Least + STR_ + evict Normally Elements ) ; } return block Start At - user Data Elements ; }
static String do Target Resource Normalization ( String original Target Resource ) { String target Resource = original Target Resource ; while ( target Resource . ends With ( PARAM WILDCARD ) ) { int len = target Resource . length ( ) ; target Resource = target Resource . substring ( NUM_ , len - NUM_ ) ; } return target Resource ; }
private void notify No Activity ( ) { logger . debug ( STR_ ) ; enquire Link Sender . enquire Link ( ) ; }
public static void merge Tabix Files ( File output , List < File > files , List < Long > data File Sizes ) throws IO Exception { long pointer Adjust = NUM_ ; final Sequence Index [ ] [ ] indexes Squared = new Sequence Index [ files . size ( ) ] [ ] ; final String [ ] [ ] sequence Names = new String [ files . size ( ) ] [ ] ; Tabix Header merged Header = null ; for ( int i = NUM_ ; i < files . size ( ) ; i ++ ) { final File tbi File = files . get ( i ) ; try ( Block Compressed Input Stream bcis = new Block Compressed Input Stream ( tbi File ) ) { final Tabix Header th = Tabix Header . read Header ( bcis ) ; sequence Names [ i ] = th . get Sequence Names Unpacked ( ) ; if ( merged Header != null ) { merged Header = Tabix Header . merge Headers ( merged Header , th ) ; } else { merged Header = th ; } indexes Squared [ i ] = load File Indexes ( bcis , th . get Num Sequences ( ) , pointer Adjust ) ; } pointer Adjust += data File Sizes . get ( i ) ; } final List < Sequence Index > indexes = collapse Indexes ( indexes Squared , sequence Names ) ; Tabix Indexer . merge Chunks ( indexes ) ; try ( Block Compressed Output Stream fos = new Block Compressed Output Stream ( output ) ) { Tabix Indexer . write Index ( indexes , merged Header . get Options ( ) , Arrays . as List ( merged Header . get Sequence Names Unpacked ( ) ) , fos ) ; } }
protected List < Job Definition > add Dependencies For Seeding ( List < Job Definition > jobs ) { List < Job Definition > list = new Array List < Job Definition > ( jobs . size ( ) ) ; for ( int i = NUM_ ; i < jobs . size ( ) ; i ++ ) { Job Definition job = jobs . get ( i ) ; Set < String > inputs = calculate Input Classes ( job ) ; Set < String > parents = calculate Ancestors ( job ) ; list . add ( job . get By Adding Dependencies ( inputs , parents ) ) ; } return list ; }
public static boolean equals ( final Object [ ] a , final Object [ ] b ) { if ( a == b ) { return true ; } else if ( a . length != b . length ) { return false ; } for ( int i = NUM_ ; i < a . length ; i ++ ) { final Object x = a [ i ] ; final Object y = b [ i ] ; if ( x == null ) { if ( y != null ) { return false ; } } else { if ( ! x . equals ( y ) ) { return false ; } } } return true ; }
public void load Tag Fragment ( ) { final Intent tag User Activity Intent = new Intent ( get Activity ( ) , Tag User Activity . class ) ; tag User Activity Intent . put Extra ( App Constants . Keys . WALL ID , m Wall Id ) ; tag User Activity Intent . put Extra ( App Constants . Keys . USER ID , m User Id ) ; tag User Activity Intent . put Extra ( App Constants . Keys . TAG USER COUNT , Integer . parse Int ( m Connection ) ) ; tag User Activity Intent . put Extra ( App Constants . Keys . FROM WALL , true ) ; start Activity ( tag User Activity Intent ) ; }
@ Override public List < Source Record > poll ( ) throws Interrupted Exception { List < Source Record > records = new Array List < > ( ) ; Mqtt Message Processor message = m Queue . take ( ) ; log . debug ( STR_ , m Mqtt Client Id , m Kafka Topic ) ; Collections . add All ( records , message . get Records ( m Kafka Topic ) ) ; return records ; }
public void add Charge ( Attack Action ea ) { pending Charges . add Element ( ea ) ; process Game Event ( new Game New Action Event ( this , ea ) ) ; }
protected boolean looks Like ISO 8601 ( String date Str ) { if ( date Str . length ( ) >= NUM_ && Character . is Digit ( date Str . char At ( NUM_ ) ) && Character . is Digit ( date Str . char At ( NUM_ ) ) && date Str . char At ( NUM_ ) == STR_ ) { return true ; } return false ; }
public static Summary Tree Node create Node ( Android Version version , Set < Updater Tree Node > children ) { Set < Updater Tree Node > included Children = Sets . new Hash Set ( ) ; Updater Tree Node primary Child = null ; for ( Updater Tree Node child : children ) { if ( child . include In Summary ( ) ) { included Children . add ( child ) ; } if ( child . is Primary ( ) ) { primary Child = child ; } } if ( ! included Children . is Empty ( ) ) { return new Summary Tree Node ( version , children , included Children , primary Child ) ; } return null ; }
private void methods ( Class type ) { Method [ ] list = type . get Declared Methods ( ) ; for ( Method method : list ) { Method Detail detail = new Method Detail ( method ) ; methods . add ( detail ) ; } }
public String generate Label String ( XY Dataset dataset , int series , int item ) { String result ; Object [ ] items = create Item Array ( dataset , series , item ) ; result = Message Format . format ( this . format String , items ) ; return result ; }
public static Buffered Input Stream new Input Stream ( File file ) throws File Not Found Exception { return new Buffered Input Stream ( new File Input Stream ( file ) ) ; }
public int remote Hash Code ( ) { return ref . hash Code ( ) ; }
public void select Object ( Img img , Point Info touch Point ) { curr Touch Point . set ( touch Point ) ; if ( img != null ) { m Images . remove ( img ) ; m Images . add ( img ) ; } else { } invalidate ( ) ; }
void fire Init Handlers ( Registered Project project ) throws Forbidden Exception , Conflict Exception , Not Found Exception , Server Exception { fire Init ( project , project . get Type ( ) ) ; for ( String mixin : project . get Mixins ( ) ) { fire Init ( project , mixin ) ; } }
public J Slider create Slider ( ) { J Slider slider = new J Slider ( m model ) ; slider . add Focus Listener ( get Slider Adjuster ( ) ) ; return slider ; }
boolean scan And Transfer To Waiter ( E e , int start ) { for ( int i = NUM_ ; i < ARENA LENGTH ; i ++ ) { int index = ( start + i ) & ARENA MASK ; Atomic Reference < Object > slot = arena [ index ] ; if ( ( slot . get ( ) == WAITER ) && slot . compare And Set ( WAITER , e ) ) { return true ; } } return false ; }
static < T > void subscribe ( Subscriber < ? super T > s , Iterator < ? extends T > it ) { if ( it == null ) { Subscription Helper . error ( s , new Null Pointer Exception ( STR_ ) ) ; return ; } boolean b ; try { b = it . has Next ( ) ; } catch ( Throwable e ) { Subscription Helper . error ( s , e ) ; return ; } if ( ! b ) { Subscription Helper . complete ( s ) ; return ; } if ( s instanceof Conditional Subscriber ) { s . on Subscribe ( new Iterable Subscription Conditional < > ( ( Conditional Subscriber < ? super T > ) s , it ) ) ; } else { s . on Subscribe ( new Iterable Subscription < > ( s , it ) ) ; } }
public static String shift Flags Into Value ( final I Translation Environment environment , final long offset , final Operand Size size , final List < Reil Instruction > instructions ) throws Illegal Argument Exception { Preconditions . check Not Null ( environment , STR_ ) ; Preconditions . check Not Null ( size , STR_ ) ; Preconditions . check Not Null ( instructions , STR_ ) ; final String start Value = environment . get Next Variable String ( ) ; final String after Cf = environment . get Next Variable String ( ) ; final String shifted Pf = environment . get Next Variable String ( ) ; final String after Pf = environment . get Next Variable String ( ) ; final String shifted Af = environment . get Next Variable String ( ) ; final String after Af = environment . get Next Variable String ( ) ; final String shifted Zf = environment . get Next Variable String ( ) ; final String after Zf = environment . get Next Variable String ( ) ; final String shifted Sf = environment . get Next Variable String ( ) ; final String after Sf = environment . get Next Variable String ( ) ; final String shifted Of = environment . get Next Variable String ( ) ; final String after Of = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create Str ( offset , size , STR_ , size , start Value ) ) ; instructions . add ( Reil Helpers . create Or ( offset + NUM_ , size , start Value , Operand Size . BYTE , Helpers . CARRY FLAG , size , after Cf ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset + NUM_ , Operand Size . BYTE , Helpers . PARITY FLAG , Operand Size . BYTE , STR_ , size , shifted Pf ) ) ; instructions . add ( Reil Helpers . create Or ( offset + NUM_ , size , after Cf , size , shifted Pf , size , after Pf ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset + NUM_ , Operand Size . BYTE , Helpers . AUXILIARY FLAG , Operand Size . BYTE , STR_ , size , shifted Af ) ) ; instructions . add ( Reil Helpers . create Or ( offset + NUM_ , size , after Pf , size , shifted Af , size , after Af ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset + NUM_ , Operand Size . BYTE , Helpers . ZERO FLAG , Operand Size . BYTE , STR_ , size , shifted Zf ) ) ; instructions . add ( Reil Helpers . create Or ( offset + NUM_ , size , after Af , size , shifted Zf , size , after Zf ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset + NUM_ , Operand Size . BYTE , Helpers . SIGN FLAG , Operand Size . BYTE , STR_ , size , shifted Sf ) ) ; instructions . add ( Reil Helpers . create Or ( offset + NUM_ , size , after Zf , size , shifted Sf , size , after Sf ) ) ; instructions . add ( Reil Helpers . create Bsh ( offset + NUM_ , Operand Size . BYTE , Helpers . OVERFLOW FLAG , Operand Size . BYTE , STR_ , size , shifted Of ) ) ; instructions . add ( Reil Helpers . create Or ( offset + NUM_ , size , after Sf , size , shifted Of , size , after Of ) ) ; return after Of ; }
Integer Key ( int val ) { this . val = val ; this . affinity = val ; }
private int convert Surrogate ( int second Part ) throws IO Exception { int first Part = m Surrogate ; m Surrogate = NUM_ ; if ( second Part < SURR 2 FIRST || second Part > SURR 2 LAST ) { throw new IO Exception ( STR_ + Integer . to Hex String ( first Part ) + STR_ + Integer . to Hex String ( second Part ) + STR_ ) ; } return NUM_ + ( ( first Part - SURR 1 FIRST ) << NUM_ ) + ( second Part - SURR 2 FIRST ) ; }
private void check Searchables ( Array List < Searchable Info > searchables List ) { assert Not Null ( searchables List ) ; int count = searchables List . size ( ) ; for ( int ii = NUM_ ; ii < count ; ii ++ ) { Searchable Info si = searchables List . get ( ii ) ; check Searchable ( si ) ; } }
@ Override public int compare To ( Spatial Object Pair other ) { return Double . compare ( this . distance , other . distance ) ; }
public Builder ( DTED Directory Handler dir Handler ) { dir Handlers = new Array List < DTED Directory Handler > ( ) ; dir Handlers . add ( dir Handler ) ; }
private Stream Tokenizer make Arff Tokenizer ( Buffered Reader br ) { Stream Tokenizer tokenizer = new Stream Tokenizer ( br ) ; { tokenizer . reset Syntax ( ) ; tokenizer . whitespace Chars ( NUM_ , STR_ ) ; tokenizer . ordinary Chars ( STR_ , STR_ ) ; tokenizer . ordinary Char ( STR_ ) ; tokenizer . ordinary Char ( STR_ ) ; tokenizer . word Chars ( STR_ + NUM_ , STR_ ) ; tokenizer . whitespace Chars ( STR_ , STR_ ) ; tokenizer . comment Char ( STR_ ) ; tokenizer . quote Char ( STR_ ) ; tokenizer . quote Char ( STR_ ) ; tokenizer . ordinary Char ( STR_ ) ; tokenizer . ordinary Char ( STR_ ) ; tokenizer . eol Is Significant ( true ) ; } return tokenizer ; }
public static boolean is Empty Or Whitespace ( String s ) { s = make Safe ( s ) ; for ( int i = NUM_ , n = s . length ( ) ; i < n ; i ++ ) { if ( ! Character . is Whitespace ( s . char At ( i ) ) ) { return false ; } } return true ; }
private void write Header String ( Buffered Writer output ) throws IO Exception { output . write ( STR_ ) ; output . write ( delimiter ) ; output . write ( STR_ ) ; output . write ( delimiter ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { output . write ( STR_ ) ; output . write ( String . value Of ( i ) ) ; output . write ( delimiter ) ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { output . write ( STR_ ) ; output . write ( String . value Of ( i ) ) ; output . write ( delimiter ) ; } output . write ( STR_ ) ; output . new Line ( ) ; }
private < T > Binding Amp < T > find Binding ( Key < T > key ) { Binding Set < T > set = ( Binding Set ) binding Set Map . get ( key . raw Class ( ) ) ; if ( set != null ) { Binding Amp < T > binding = set . find ( key ) ; if ( binding != null ) { return binding ; } } return null ; }
private void update Base Matrix ( Drawable d ) { Image View image View = get Image View ( ) ; if ( null == image View || null == d ) { return ; } final float view Width = get Image View Width ( image View ) ; final float view Height = get Image View Height ( image View ) ; final int drawable Width = d . get Intrinsic Width ( ) ; final int drawable Height = d . get Intrinsic Height ( ) ; m Base Matrix . reset ( ) ; final float width Scale = view Width / drawable Width ; final float height Scale = view Height / drawable Height ; if ( m Scale Type == Scale Type . CENTER ) { m Base Matrix . post Translate ( ( view Width - drawable Width ) / NUM_ , ( view Height - drawable Height ) / NUM_ ) ; } else if ( m Scale Type == Scale Type . CENTER CROP ) { float scale = Math . max ( width Scale , height Scale ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM_ , ( view Height - drawable Height * scale ) / NUM_ ) ; } else if ( m Scale Type == Scale Type . CENTER INSIDE ) { float scale = Math . min ( NUM_ , Math . min ( width Scale , height Scale ) ) ; m Base Matrix . post Scale ( scale , scale ) ; m Base Matrix . post Translate ( ( view Width - drawable Width * scale ) / NUM_ , ( view Height - drawable Height * scale ) / NUM_ ) ; } else { Rect F m Temp Src = new Rect F ( NUM_ , NUM_ , drawable Width , drawable Height ) ; Rect F m Temp Dst = new Rect F ( NUM_ , NUM_ , view Width , view Height ) ; if ( ( int ) m Base Rotation % NUM_ != NUM_ ) { m Temp Src = new Rect F ( NUM_ , NUM_ , drawable Height , drawable Width ) ; } switch ( m Scale Type ) { case FIT CENTER : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . CENTER ) ; break ; case FIT START : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . START ) ; break ; case FIT END : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . END ) ; break ; case FIT XY : m Base Matrix . set Rect To Rect ( m Temp Src , m Temp Dst , Scale To Fit . FILL ) ; break ; default : break ; } } reset Matrix ( ) ; }
@ Override public void finish ( ) { for ( Entry < String , File Channel > entry : file Name And Stream Cache . entry Set ( ) ) { try { File Channel channel = entry . get Value ( ) ; if ( null != channel ) { channel . close ( ) ; } } catch ( IO Exception exception ) { LOGGER . error ( exception , exception . get Message ( ) ) ; } } }
public void ensure Capacity ( int min Capacity ) { min Capacity = Math . max ( NUM_ , min Capacity ) ; if ( min Capacity >= data . length ) { int [ ] d = new int [ min Capacity ] ; System . arraycopy ( data , NUM_ , d , NUM_ , data . length ) ; data = d ; } }
public void close Doc Viewer ( Doc Viewer Panel doc Panel ) { if ( open Docs . size ( ) == NUM_ ) { return ; } if ( doc Panel . has Been Modfied Since Save ( ) ) { Object [ ] options = { STR_ , STR_ } ; int n = J Option Pane . show Option Dialog ( null , STR_ + STR_ , STR_ , J Option Pane . YES NO CANCEL OPTION , J Option Pane . WARNING MESSAGE , null , options , options [ NUM_ ] ) ; if ( n == NUM_ ) { return ; } } open Docs . remove ( doc Panel ) ; doc Panel . destroy All Undo States ( ) ; destroy Doc ( doc Panel . get Doc ( ) ) ; just Closed Tab = true ; doc Tabs . remove ( doc Panel ) ; just Closed Tab = false ; }
static File create Snapshot File ( String name , File directory , long index , long timestamp ) { return new File ( directory , String . format ( STR_ , Assert . not Null ( name , STR_ ) , index , TIMESTAMP FORMAT . format ( new Date ( timestamp ) ) ) ) ; }
private static Content Impl parse Content ( Ole Blob Impl blob ) throws IO Exception { Byte Buffer bb = Page Channel . wrap ( blob . get Bytes ( ) ) ; if ( ( bb . remaining ( ) < NUM_ ) || ( bb . get Short ( ) != PACKAGE SIGNATURE ) ) { return new Unknown Content Impl ( blob ) ; } int header Size = bb . get Short ( ) ; bb . get Int ( ) ; int pretty Name Len = bb . get Short ( ) ; int class Name Len = bb . get Short ( ) ; int pretty Name Off = bb . get Short ( ) ; int class Name Off = bb . get Short ( ) ; bb . get Int ( ) ; String pretty Name = read Str ( bb , pretty Name Off , pretty Name Len ) ; String class Name = read Str ( bb , class Name Off , class Name Len ) ; bb . position ( header Size ) ; int ole Ver = bb . get Int ( ) ; bb . get Int ( ) ; if ( ole Ver != OLE VERSION ) { return new Unknown Content Impl ( blob ) ; } int type Name Len = bb . get Int ( ) ; String type Name = read Str ( bb , bb . position ( ) , type Name Len ) ; bb . get Long ( ) ; int data Block Len = bb . get Int ( ) ; int data Block Pos = bb . position ( ) ; if ( SIMPLE PACKAGE TYPE . equals Ignore Case ( type Name ) ) { return create Simple Package Content ( blob , pretty Name , class Name , type Name , bb , data Block Len ) ; } if ( ( COMPOUND FACTORY != null ) && ( bb . remaining ( ) >= COMPOUND STORAGE SIGNATURE . length ) && Byte Util . matches Range ( bb , bb . position ( ) , COMPOUND STORAGE SIGNATURE ) ) { return COMPOUND FACTORY . create Compound Package Content ( blob , pretty Name , class Name , type Name , bb , data Block Len ) ; } return new Other Content Impl ( blob , pretty Name , class Name , type Name , data Block Pos , data Block Len ) ; }
@ Override public T compare ( String request Resource , String target Resource , boolean wildcard Compare ) { if ( ! wildcard Compare ) { return super . compare ( request Resource , target Resource , wildcard Compare ) ; } String schemeless Target = target Resource ; String schemeless Request = request Resource ; if ( schemeless Target . contains ( SCHEME DELIMITER ) && schemeless Request . contains ( SCHEME DELIMITER ) ) { schemeless Target = remove Scheme Ensure Slash ( schemeless Target ) ; schemeless Request = remove Scheme Ensure Slash ( schemeless Request ) ; } else { return super . compare ( request Resource , target Resource , wildcard Compare ) ; } final int first Colon = schemeless Target . index Of ( COLON ) ; final int first Slash = schemeless Target . index Of ( SLASH ) ; if ( first Colon == - NUM_ ) { return super . compare ( request Resource , target Resource , wildcard Compare ) ; } else { T scheme Match = compare Before Breakpoint ( request Resource , target Resource , SCHEME DELIMITER ) ; if ( ! is Successful Match ( scheme Match ) ) { return no Match ; } if ( first Slash >= NUM_ && first Slash < first Colon ) { return super . compare ( schemeless Request , schemeless Target , wildcard Compare ) ; } if ( first Slash >= NUM_ && first Slash > first Colon ) { T host Match = compare Before Breakpoint ( schemeless Request , schemeless Target , COLON ) ; if ( ! is Successful Match ( host Match ) ) { return no Match ; } final String post Colon Request = schemeless Request . substring ( schemeless Request . index Of ( COLON ) ) ; final String post Colon Target = schemeless Target . substring ( schemeless Target . index Of ( COLON ) ) ; T port Match = compare Before Breakpoint ( post Colon Request , post Colon Target , SLASH ) ; if ( ! is Successful Match ( port Match ) ) { return no Match ; } final String post Slash Request = post Colon Request . substring ( post Colon Request . index Of ( SLASH ) ) ; final String post Slash Target = post Colon Target . substring ( post Colon Target . index Of ( SLASH ) ) ; final int request Query String Index = post Slash Request . index Of ( QUERY DELIMITER ) ; final int target Query String Index = post Slash Target . index Of ( QUERY DELIMITER ) ; if ( request Query String Index != - NUM_ ) { if ( target Query String Index == - NUM_ ) { final String pre Query String Request = post Slash Request . substring ( NUM_ , request Query String Index ) ; T path Match = super . compare ( pre Query String Request , post Slash Target , wildcard Compare ) ; if ( no Match . equals ( path Match ) || sub Resource Match . equals ( path Match ) ) { return no Match ; } return super Resource Match ; } T path Match = compare Before Breakpoint ( post Slash Request , post Slash Target , QUERY DELIMITER ) ; if ( ! is Successful Match ( path Match ) ) { return no Match ; } T query Match = super . compare ( post Slash Request . substring ( request Query String Index ) , post Slash Target . substring ( target Query String Index ) , wildcard Compare ) ; return wildcard Response Combiner ( host Match , port Match , path Match , query Match ) ; } else { T path Match = super . compare ( post Slash Request , post Slash Target , wildcard Compare ) ; return wildcard Response Combiner ( host Match , port Match , path Match ) ; } } else { return compare Split ( schemeless Request , schemeless Target , COLON ) ; } } }
private void stretch View Horizontally ( View view , int cross Size ) { Layout Params lp = ( Layout Params ) view . get Layout Params ( ) ; int new Width = cross Size - lp . left Margin - lp . right Margin ; new Width = Math . max ( new Width , NUM_ ) ; view . measure ( Measure Spec . make Measure Spec ( new Width , Measure Spec . EXACTLY ) , Measure Spec . make Measure Spec ( view . get Measured Height ( ) , Measure Spec . EXACTLY ) ) ; }
public LRU Statistics stats ( ) { return this . stats ; }
private int find ( E [ ] array , E element ) { int min = NUM_ ; int max = array . length - NUM_ ; while ( max >= min ) { int mid = midpoint ( min , max ) ; int compare = comparator . compare ( array [ mid ] , element ) ; if ( NUM_ == compare ) { return mid ; } min = ( compare < NUM_ ) ? mid + NUM_ : min ; max = ( compare > NUM_ ) ? mid - NUM_ : max ; } return - NUM_ ; }
public static void update Beginning Balance ( Properties ctx , int terminal Id , String trx Name ) throws Operation Exception { int cash Book Id = POS Terminal Manager . get Cash Book Id ( ctx , terminal Id ) ; update Cash Book Beginning Balance ( ctx , cash Book Id , trx Name ) ; }
public void parent Implotion ( int PP Product BOM Line ID ) throws Exception { int PP Product BOM ID = NUM_ ; int M Product ID = NUM_ ; X T BOM Line tboml = new X T BOM Line ( ctx , NUM_ , null ) ; PP Product BOM ID = DB . get SQL Value ( null , STR_ , PP Product BOM Line ID ) ; if ( PP Product BOM ID < NUM_ ) throw new Exception ( C Logger . retrieve Error String ( STR_ ) ) ; M Product ID = DB . get SQL Value ( null , STR_ , PP Product BOM ID ) ; if ( M Product ID < NUM_ ) throw new Exception ( C Logger . retrieve Error String ( STR_ ) ) ; tboml . set PP Product BOM ID ( PP Product BOM ID ) ; tboml . set PP Product BOM Line ID ( PP Product BOM Line ID ) ; tboml . set M Product ID ( M Product ID ) ; tboml . set Level No ( Level No ) ; tboml . set Sel Product ID ( p M Product ID ) ; tboml . set Implosion ( p implosion ) ; if ( Level No >= NUM_ ) tboml . set Levels ( levels + STR_ + Level No ) ; else if ( Level No >= NUM_ ) tboml . set Levels ( levels . substring ( NUM_ , Level No ) + Level No ) ; tboml . set Seq No ( Seq No ) ; tboml . set AD P Instance ID ( AD P Instance ID ) ; tboml . save ( ) ; Prepared Statement stmt = null ; Result Set rs = null ; String sql = STR_ + STR_ ; try { stmt = DB . prepare Statement ( sql , get Trx Name ( ) ) ; stmt . set Int ( NUM_ , M Product ID ) ; rs = stmt . execute Query ( ) ; while ( rs . next ( ) ) { Seq No += NUM_ ; component ( rs . get Int ( NUM_ ) ) ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , e . get Localized Message ( ) + sql , e ) ; throw new Exception ( STR_ + e . get Localized Message ( ) ) ; } finally { DB . close ( rs , stmt ) ; rs = null ; stmt = null ; } }
protected void request Result ( Request Type type , String url , String result , int response Code , String error , String encoding , String token ) { int length = - NUM_ ; if ( result != null ) { length = result . length ( ) ; } String encoding Text = encoding == null ? STR_ : STR_ + encoding ; LOGGER . info ( STR_ + response Code + STR_ + length + encoding Text + STR_ + url + STR_ + ( error != null ? STR_ + error + STR_ : STR_ ) ) ; if ( type == Request Type . VERIFY TOKEN ) { Token Info token Info = parse Verify Token ( result ) ; result Listener . token Verified ( token , token Info ) ; } else if ( type == Request Type . CHANNEL PUT ) { request Result ( type , url , result , response Code , error , encoding ) ; } else if ( type == Request Type . COMMERCIAL ) { String stream = remove Request ( url ) ; String result Text = STR_ + response Code + STR_ ; Request Result result Code = Request Result . UNKNOWN ; if ( response Code == NUM_ ) { result Text = STR_ ; result Code = Request Result . RUNNING COMMERCIAL ; } else if ( response Code == NUM_ ) { result Text = STR_ ; result Code = Request Result . FAILED ; } else if ( response Code == NUM_ || response Code == NUM_ ) { result Text = STR_ ; result Code = Request Result . ACCESS DENIED ; access Denied ( ) ; } else if ( response Code == NUM_ ) { result Text = STR_ + stream + STR_ ; result Code = Request Result . INVALID CHANNEL ; } if ( result Listener != null ) { result Listener . run Commercial Result ( stream , result Text , result Code ) ; } } else if ( type == Request Type . FOLLOWED STREAMS ) { stream Info Manager . request Result Follows ( result , response Code ) ; } else if ( type == Request Type . SUBSCRIBERS ) { String stream = remove Request ( url ) ; subscriber Manager . received ( response Code , stream , result ) ; } else if ( type == Request Type . FOLLOW ) { String target = remove Request ( url ) ; if ( response Code == NUM_ ) { long follow Time = follow Get Time ( result ) ; if ( follow Time != - NUM_ && System . current Time Millis ( ) - follow Time > NUM_ ) { result Listener . follow Result ( String . format ( STR_ , target , Date Time . ago ( follow Time , NUM_ , NUM_ , NUM_ , Date Time . Formatting . VERBOSE ) ) ) ; } else { result Listener . follow Result ( STR_ + target + STR_ ) ; } } else if ( response Code == NUM_ ) { result Listener . follow Result ( STR_ + target + STR_ ) ; } else if ( response Code == NUM_ ) { result Listener . follow Result ( STR_ + target + STR_ ) ; } else { result Listener . follow Result ( STR_ + target + STR_ ) ; } } else if ( type == Request Type . UNFOLLOW ) { String target = remove Request ( url ) ; if ( response Code == NUM_ ) { result Listener . follow Result ( STR_ + target + STR_ ) ; } else if ( response Code == NUM_ ) { result Listener . follow Result ( STR_ + target + STR_ ) ; } else if ( response Code == NUM_ ) { result Listener . follow Result ( STR_ + target + STR_ ) ; } else { result Listener . follow Result ( STR_ + target + STR_ ) ; } } }
@ Override public byte [ ] from Byte Array ( Slice fragment ) { if ( fragment == null || fragment . buffer == null ) { return null ; } else if ( fragment . offset == NUM_ && fragment . length == fragment . buffer . length ) { return fragment . buffer ; } else { byte [ ] buffer = new byte [ fragment . buffer . length ] ; System . arraycopy ( fragment . buffer , fragment . offset , buffer , NUM_ , fragment . length ) ; return buffer ; } }
final int external Help Complete ( Counted Completer < ? > task , int max Tasks ) { Work Queue [ ] ws ; int n ; int r = Thread Local Random . get Probe ( ) ; return ( ( ws = work Queues ) == null || ( n = ws . length ) == NUM_ ) ? NUM_ : help Complete ( ws [ ( n - NUM_ ) & r & SQMASK ] , task , max Tasks ) ; }
public void deactivate ( ) { stop ( ) ; destroy ( ) ; if ( ! run Managed ) { System . exit ( NUM_ ) ; } }
public static int calc RW Count ( int lvl ) { return ( int ) Math . ceil ( Math . log 10 ( NUM_ + rand . next Int ( lvl * lvl + NUM_ ) ) ) + rand . next Int ( NUM_ ) ; }
public static synchronized void do Deferred Specializations ( ) { if ( specialization In Progress ) { return ; } specialization In Progress = true ; Iterator < Specialized Method > methods = deferred Methods . iterator ( ) ; while ( methods . has Next ( ) ) { Specialized Method m = methods . next ( ) ; if ( m . get Compiled Method ( ) == null ) { m . compile ( ) ; register Compiled Method ( m ) ; } deferred Methods . remove ( m ) ; methods = deferred Methods . iterator ( ) ; } specialization In Progress = false ; }
protected void index Nulls ( Input Stream is , long ptr , Output Stream os ) { boolean more Records = true ; byte r Hdr [ ] = new byte [ SHAPE RECORD HEADER LENGTH ] ; byte out Buf [ ] = new byte [ SPATIAL INDEX RECORD LENGTH ] ; int result ; int n Records = NUM_ ; int rec Length Words , rec Length Bytes ; long rec Offset ; int rec Buf Size = NUM_ ; byte rec Buf [ ] = new byte [ rec Buf Size ] ; double x ; double y ; try { while ( more Records ) { result = is . read ( r Hdr , NUM_ , SHAPE RECORD HEADER LENGTH ) ; if ( result < NUM_ ) { more Records = false ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + n Records + STR_ ) ; logger . fine ( STR_ + rec Buf Size ) ; } } else { n Records ++ ; rec Offset = ptr ; read BE Int ( r Hdr , NUM_ ) ; rec Length Words = read BE Int ( r Hdr , NUM_ ) ; rec Length Bytes = rec Length Words * NUM_ ; if ( rec Length Bytes > rec Buf Size ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + rec Length Bytes ) ; } rec Buf Size = rec Length Bytes ; rec Buf = new byte [ rec Buf Size ] ; } result = is . read ( rec Buf , NUM_ , rec Length Bytes ) ; x = NUM_ ; y = NUM_ ; ptr += rec Length Bytes + NUM_ ; write BE Int ( out Buf , NUM_ , ( int ) ( rec Offset / NUM_ ) ) ; write BE Int ( out Buf , NUM_ , rec Length Words ) ; write LE Double ( out Buf , NUM_ , x ) ; write LE Double ( out Buf , NUM_ , y ) ; write LE Double ( out Buf , NUM_ , x ) ; write LE Double ( out Buf , NUM_ , y ) ; os . write ( out Buf , NUM_ , SPATIAL INDEX RECORD LENGTH ) ; } } } catch ( java . io . IO Exception e ) { e . print Stack Trace ( ) ; } finally { try { is . close ( ) ; } catch ( java . io . IO Exception e ) { } } }
protected void assert Standard Equals ( Object o ) { assert True ( o . equals ( o ) ) ; assert False ( o . equals ( null ) ) ; assert False ( o . equals ( SINGLETON OBJECT ) ) ; o . hash Code ( ) ; }
public static boolean is Subclass Or Implements Interface ( Class extendor Or Implementor , Class extended Or Implemented ) { if ( extendor Or Implementor . equals ( extended Or Implemented ) ) { return true ; } if ( extended Or Implemented . is Interface ( ) ) { return recursive Is Implements Interface ( extendor Or Implementor , extended Or Implemented ) || recursive Superclass Implements Interface ( extendor Or Implementor , extended Or Implemented ) ; } return recursive Is Super Class ( extendor Or Implementor , extended Or Implemented ) ; }
private void generate Fixed Partition Attributes ( String kind , List < Fixed Partition Attributes > all Static Attrs ) throws SAX Exception { for ( Fixed Partition Attributes attr : all Static Attrs ) { Attributes Impl s Atts = new Attributes Impl ( ) ; s Atts . add Attribute ( STR_ , STR_ , PARTITION NAME , STR_ , attr . get Partition Name ( ) ) ; s Atts . add Attribute ( STR_ , STR_ , IS PRIMARY , STR_ , String . value Of ( attr . is Primary ( ) ) ) ; s Atts . add Attribute ( STR_ , STR_ , NUM BUCKETS , STR_ , String . value Of ( attr . get Num Buckets ( ) ) ) ; handler . start Element ( STR_ , kind , kind , s Atts ) ; handler . end Element ( STR_ , kind , kind ) ; } }
protected void print Attribute Summary ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type ) { String str = STR_ ; if ( numeric Predictor ) { str += STR_ ; } if ( nominal Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( string Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( date Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } if ( relational Predictor ) { if ( str . length ( ) > NUM_ ) { str += STR_ ; } str += STR_ ; } str += STR_ ; switch ( class Type ) { case Attribute . NUMERIC : str = STR_ + str ; break ; case Attribute . NOMINAL : str = STR_ + str ; break ; case Attribute . STRING : str = STR_ + str ; break ; case Attribute . DATE : str = STR_ + str ; break ; case Attribute . RELATIONAL : str = STR_ + str ; break ; case NO CLASS : str = STR_ + str ; break ; } print ( str ) ; }
public boolean is Send Was Called ( ) { return this . send Was Called ; }
private void generate Tag Handler Init ( ) { if ( ! is Pooling Enabled || tag Handler Pool Names . is Empty ( ) ) { return ; } if ( ctxt . is Tag File ( ) ) { out . printil ( STR_ ) ; } else { out . printil ( STR_ ) ; } out . push Indent ( ) ; for ( String tag Handler Pool Name : tag Handler Pool Names ) { out . printin ( tag Handler Pool Name ) ; out . print ( STR_ ) ; if ( ctxt . is Tag File ( ) ) { out . print ( STR_ ) ; } else { out . print ( STR_ ) ; } out . println ( STR_ ) ; } out . pop Indent ( ) ; out . printil ( STR_ ) ; out . println ( ) ; }
private void layout Chunk ( Recycler View . Recycler recycler , Recycler View . State state , boolean is Fill Bottom ) { layout Chunk ( recycler , state , is Fill Bottom , false ) ; }
public void refresh Column Index ( final int index ) { final int last Index = table . get Item Count ( ) ; for ( int i = index ; i < last Index ; i ++ ) { final Table Item item = table . get Item ( i ) ; item . set Text ( NUM_ , String . value Of ( i ) ) ; } }
public static synchronized Bean Info find Bean Info ( String bean Class Name ) { String [ ] bean Info Paths = Introspector . get Bean Info Search Path ( ) ; String info Class Name = bean Class Name + STR_ ; Class info Class = null ; try { info Class = Class . for Name ( info Class Name ) ; return ( Bean Info ) info Class . new Instance ( ) ; } catch ( Exception ex ) { } for ( int i = NUM_ ; i < bean Info Paths . length ; i ++ ) { int index = bean Class Name . last Index Of ( STR_ ) ; String class Name With Dot = bean Class Name . substring ( index ) ; info Class Name = bean Info Paths [ i ] + class Name With Dot + STR_ ; try { info Class = Class . for Name ( info Class Name ) ; break ; } catch ( Class Not Found Exception ex ) { } } Object retval = null ; if ( info Class != null ) { try { retval = info Class . new Instance ( ) ; } catch ( Exception ex ) { } } return ( Bean Info ) retval ; }
static Name Constraints Extension merge Name Constraints ( X 509 Certificate curr Cert , Name Constraints Extension prev NC ) throws Cert Path Validator Exception { X 509 Cert Impl curr Cert Impl ; try { curr Cert Impl = X 509 Cert Impl . to Impl ( curr Cert ) ; } catch ( Certificate Exception ce ) { throw new Cert Path Validator Exception ( ce ) ; } Name Constraints Extension new Constraints = curr Cert Impl . get Name Constraints Extension ( ) ; if ( debug != null ) { debug . println ( STR_ + prev NC + STR_ + String . value Of ( new Constraints ) ) ; } if ( prev NC == null ) { if ( debug != null ) { debug . println ( STR_ + String . value Of ( new Constraints ) ) ; } if ( new Constraints == null ) { return new Constraints ; } else { return ( Name Constraints Extension ) new Constraints . clone ( ) ; } } else { try { prev NC . merge ( new Constraints ) ; } catch ( IO Exception ioe ) { throw new Cert Path Validator Exception ( ioe ) ; } if ( debug != null ) { debug . println ( STR_ + prev NC ) ; } return prev NC ; } }
protected final void add All Doc Vectors ( Fields vectors , Merge State merge State ) throws IO Exception { if ( vectors == null ) { start Document ( NUM_ ) ; finish Document ( ) ; return ; } int num Fields = vectors . size ( ) ; if ( num Fields == - NUM_ ) { num Fields = NUM_ ; for ( final Iterator < String > it = vectors . iterator ( ) ; it . has Next ( ) ; ) { it . next ( ) ; num Fields ++ ; } } start Document ( num Fields ) ; String last Field Name = null ; Terms Enum terms Enum = null ; Postings Enum docs And Positions Enum = null ; int field Count = NUM_ ; for ( String field Name : vectors ) { field Count ++ ; final Field Info field Info = merge State . merge Field Infos . field Info ( field Name ) ; assert last Field Name == null || field Name . compare To ( last Field Name ) > NUM_ : STR_ + last Field Name + STR_ + field Name ; last Field Name = field Name ; final Terms terms = vectors . terms ( field Name ) ; if ( terms == null ) { continue ; } final boolean has Positions = terms . has Positions ( ) ; final boolean has Offsets = terms . has Offsets ( ) ; final boolean has Payloads = terms . has Payloads ( ) ; assert ! has Payloads || has Positions ; int num Terms = ( int ) terms . size ( ) ; if ( num Terms == - NUM_ ) { num Terms = NUM_ ; terms Enum = terms . iterator ( ) ; while ( terms Enum . next ( ) != null ) { num Terms ++ ; } } start Field ( field Info , num Terms , has Positions , has Offsets , has Payloads ) ; terms Enum = terms . iterator ( ) ; int term Count = NUM_ ; while ( terms Enum . next ( ) != null ) { term Count ++ ; final int freq = ( int ) terms Enum . total Term Freq ( ) ; start Term ( terms Enum . term ( ) , freq ) ; if ( has Positions || has Offsets ) { docs And Positions Enum = terms Enum . postings ( docs And Positions Enum , Postings Enum . OFFSETS | Postings Enum . PAYLOADS ) ; assert docs And Positions Enum != null ; final int doc ID = docs And Positions Enum . next Doc ( ) ; assert doc ID != Doc Id Set Iterator . NO MORE DOCS ; assert docs And Positions Enum . freq ( ) == freq ; for ( int pos Upto = NUM_ ; pos Upto < freq ; pos Upto ++ ) { final int pos = docs And Positions Enum . next Position ( ) ; final int start Offset = docs And Positions Enum . start Offset ( ) ; final int end Offset = docs And Positions Enum . end Offset ( ) ; final Bytes Ref payload = docs And Positions Enum . get Payload ( ) ; assert ! has Positions || pos >= NUM_ ; add Position ( pos , start Offset , end Offset , payload ) ; } } finish Term ( ) ; } assert term Count == num Terms ; finish Field ( ) ; } assert field Count == num Fields ; finish Document ( ) ; }
private void draw Overlay Graphic ( Graphics 2 D g , int width , int height ) { Shape s = shape Generator . create Tab Close Icon ( NUM_ , NUM_ , width - NUM_ , height - NUM_ ) ; g . set Paint ( graphic Base ) ; g . fill ( s ) ; s = shape Generator . create Tab Close Icon ( NUM_ , NUM_ , width - NUM_ , height - NUM_ ) ; g . set Paint ( create Graphic Drop Shadow Gradient ( s ) ) ; Shape old Clip = g . get Clip ( ) ; g . set Clip ( NUM_ , NUM_ , width - NUM_ , height - NUM_ ) ; g . fill ( s ) ; g . set Clip ( old Clip ) ; }
public boolean has Permissions By Internal Id ( String internal Id , Permission ... permissions ) { return has Permissions By Internal Id ( internal Id , Arrays . as List ( permissions ) ) ; }
public static Console create ( boolean interactive ) throws IO Exception { console Instance . set ( new Console ( interactive ) ) ; return console Instance . get ( ) ; }
@ Override public List < Work Order > search WO To View ( final Map < String , Object > criteria Map ) { logger . debug ( STR_ ) ; return search WO ( criteria Map ) ; }
public Pool add Pool ( String name ) { Pool pool = get Pool By Name ( name ) ; if ( pool == null ) { id Pool Number ++ ; String id = id + STR_ + Integer . to String ( id Pool Number ) ; log . debug ( STR_ , name , id ) ; pool = new Pool ( id , name ) ; register ( pool ) ; } return pool ; }
public Reliable Log ( String dir Path , Log Handler handler ) throws IO Exception { this ( dir Path , handler , false ) ; }
@ Override public double conf ( double total Weight , double total Positive Weight , Hypothesis hypo , double delta ) { double g = hypo . get Covered Weight ( ) / total Weight ; double p = hypo . get Positive Weight ( ) / hypo . get Covered Weight ( ) ; double sg = variance ( g , total Weight ) ; double sp = variance ( p , hypo . get Covered Weight ( ) ) ; double inverse Normal = inverse Normal ( NUM_ - delta / NUM_ ) ; return Math . sqrt ( sg * inverse Normal ) + sp * inverse Normal + Math . sqrt ( sg * inverse Normal ) * sp * inverse Normal ; }
public void remove Item ( int position ) { m Datas . remove ( position ) ; notify Item Removed ( position ) ; }
public Builder with White List ( final List < Pattern > white List ) { Reject . if Null ( white List ) ; this . white List = white List ; return this ; }
private void validate Dns Name ( String dns Name ) throws Policy Exception { int star Index = dns Name . index Of ( STR_ ) ; if ( ( star Index >= NUM_ ) && ! dns Name . equals ( STR_ ) ) { if ( ( star Index > NUM_ ) || ( ( star Index == NUM_ ) && ( ( dns Name . index Of ( STR_ , NUM_ ) != - NUM_ ) || ( dns Name . char At ( NUM_ ) != STR_ ) ) ) ) { String args [ ] = { DNS NAME , dns Name } ; throw new Policy Exception ( Res Bundle Utils . rb Name , STR_ , args , null ) ; } } }
protected boolean [ ] can Predict ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type ) { print ( STR_ ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STR_ ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; int num Train = get Num Instances ( ) , num Classes = NUM_ , missing Level = NUM_ ; boolean predictor Missing = false , class Missing = false ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Classes , accepts ) ; }
static private void log Detail Rows ( final I Running Query q , final Map < Integer , Queue Stats > queue Stats , final String Builder sb ) { final Integer [ ] order = B Op Utility . get Evaluation Order ( q . get Query ( ) ) ; int order Index = NUM_ ; for ( Integer bop Id : order ) { sb . append ( get Table Row ( q , order Index , bop Id , false , queue Stats ) ) ; order Index ++ ; } }
public void end Phase ( int phase ) { if ( compile Times != null && phase >= PREPROCESS && phase <= POSTPROCESS ) { compile Times [ phase ] . invocation Count ++ ; compile Times [ phase ] . total Time += System . current Time Millis ( ) - start Time ; } }
private boolean dyn Init ( ) { Vector < String > column Names = new Vector < String > ( ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , m C B Partner ID == NUM_ ? STR_ : STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; column Names . add ( Msg . translate ( Env . get Ctx ( ) , STR_ ) ) ; Vector < Vector < Object > > data = null ; if ( m C B Partner ID == NUM_ ) data = query B Partner ( ) ; else data = query Product ( ) ; m model Price = new List Model Table ( data ) ; m table Price . set Data ( m model Price , column Names ) ; m table Price . set Column Class ( NUM_ , String . class , true ) ; m table Price . set Column Class ( NUM_ , Double . class , true ) ; m table Price . set Column Class ( NUM_ , Double . class , true ) ; m table Price . set Column Class ( NUM_ , Big Decimal . class , true ) ; m table Price . set Column Class ( NUM_ , String . class , true ) ; m table Price . set Column Class ( NUM_ , Timestamp . class , true ) ; m table Price . set Column Class ( NUM_ , String . class , true ) ; m table Price . auto Size ( ) ; return data . size ( ) != NUM_ ; }
public void initialize ( ) throws Interrupted Exception { check ( NUM_ , NUM_ , NUM_ ) ; for ( Thread t : threads ) { t . start ( ) ; } ready . await ( ) ; check ( numthreads , NUM_ , NUM_ ) ; }
public static boolean does Data Frame Look Like Matrix ( Data Frame df ) { Struct Type schema = df . schema ( ) ; Struct Field [ ] fields = schema . fields ( ) ; if ( fields == null ) { return true ; } for ( Struct Field field : fields ) { Data Type data Type = field . data Type ( ) ; if ( ( data Type != Data Types . Double Type ) && ( data Type != Data Types . Integer Type ) && ( data Type != Data Types . Long Type ) && ( ! ( data Type instanceof Vector UDT ) ) ) { return false ; } } return true ; }
public static void send Mail ( Context m Context , String mail ID ) { Uri uri = Uri . parse ( STR_ + mail ID ) ; Intent intent = new Intent ( Intent . ACTION SENDTO , uri ) ; m Context . start Activity ( intent ) ; }
public void run Now ( ) { gc Executor Loop . set Dependency Tracker ( data Object Scanner . get Dependency Tracker ( ) ) ; Future f = executor . submit ( gc Executor Loop , NUM_ ) ; log . info ( STR_ ) ; try { f . get ( ) ; } catch ( Execution Exception | Interrupted Exception ex ) { } log . info ( STR_ ) ; }
protected void create Renderers ( Combined Chart chart , Chart Animator animator , View Port Handler view Port Handler ) { m Renderers = new Array List < Data Renderer > ( ) ; Draw Order [ ] orders = chart . get Draw Order ( ) ; for ( Draw Order order : orders ) { switch ( order ) { case BAR : if ( chart . get Bar Data ( ) != null ) m Renderers . add ( new Bar Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case LINE : if ( chart . get Line Data ( ) != null ) m Renderers . add ( new Line Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case CANDLE : if ( chart . get Candle Data ( ) != null ) m Renderers . add ( new Candle Stick Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case SCATTER : if ( chart . get Scatter Data ( ) != null ) m Renderers . add ( new Scatter Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; } } }
private void adjust Day Of Week ( Calendar start Time ) { int days Diff = get Day Of Week ( ) - get Day Of Week ( start Time ) ; start Time . add ( Calendar . DAY OF WEEK , days Diff ) ; }
private static < T > void read Table Field ( Database Table Config < T > config , String field , String value ) { if ( field . equals ( FIELD NAME DATA CLASS ) ) { try { @ Suppress Warnings ( STR_ ) Class < T > clazz = ( Class < T > ) Class . for Name ( value ) ; config . set Data Class ( clazz ) ; } catch ( Class Not Found Exception e ) { throw new Illegal Argument Exception ( STR_ + value ) ; } } else if ( field . equals ( FIELD NAME TABLE NAME ) ) { config . set Table Name ( value ) ; } }
protected void check Assignability ( Annotated Type Mirror var Type , Tree var Tree ) { if ( Tree Utils . is Expression Tree ( var Tree ) ) { Annotated Type Mirror rcv Type = atype Factory . get Receiver Type ( ( Expression Tree ) var Tree ) ; if ( ! is Assignable ( var Type , rcv Type , var Tree ) ) { checker . report ( Result . failure ( STR_ , Internal Utils . symbol ( var Tree ) , rcv Type ) , var Tree ) ; } } }
public void append Local Variable Label ( I Local Variable local Variable , long flags ) { if ( get Flag ( flags , F PRE TYPE SIGNATURE ) ) { append Type Signature Label ( local Variable , local Variable . get Type Signature ( ) , flags ) ; f Buffer . append ( STR_ ) ; } if ( get Flag ( flags , F FULLY QUALIFIED ) ) { append Element Label ( local Variable . get Declaring Member ( ) , M PARAMETER TYPES | M FULLY QUALIFIED | T FULLY QUALIFIED | ( flags & QUALIFIER FLAGS ) ) ; f Buffer . append ( STR_ ) ; } f Buffer . append ( get Element Name ( local Variable ) ) ; if ( get Flag ( flags , F APP TYPE SIGNATURE ) ) { int offset = f Buffer . length ( ) ; f Buffer . append ( DECL STRING ) ; append Type Signature Label ( local Variable , local Variable . get Type Signature ( ) , flags ) ; } if ( get Flag ( flags , F POST QUALIFIED ) ) { f Buffer . append ( CONCAT STRING ) ; append Element Label ( local Variable . get Declaring Member ( ) , M PARAMETER TYPES | M FULLY QUALIFIED | T FULLY QUALIFIED | ( flags & QUALIFIER FLAGS ) ) ; } }
public String sanitize String ( String string ) { String Builder retval = new String Builder ( ) ; String Character Iterator iterator = new String Character Iterator ( string ) ; char character = iterator . current ( ) ; while ( character != java . text . Character Iterator . DONE ) { if ( character == STR_ ) { retval . append ( STR_ ) ; } else if ( character == STR_ ) { retval . append ( STR_ ) ; } else if ( character == STR_ ) { retval . append ( STR_ ) ; } else if ( character == STR_ ) { retval . append ( STR_ ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else if ( character == STR_ ) { add Char Entity ( NUM_ , retval ) ; } else { retval . append ( character ) ; } character = iterator . next ( ) ; } return retval . to String ( ) ; }
static public J Check Box create J Check Box For Table ( boolean selected ) { J Check Box check Box = new J Check Box ( ) ; check Box . set Opaque ( true ) ; check Box . set Horizontal Alignment ( Swing Constants . CENTER ) ; check Box . set Foreground ( TABLE COMPONENT FG COLOR ) ; check Box . set Background ( TABLE COMPONENT BG COLOR ) ; check Box . set Selected ( selected ) ; return check Box ; }
public Scanner Exception ( File file , Error Messages message , int line ) { this ( file , Error Messages . get ( message ) , message , line , - NUM_ ) ; }
public void output Node Push ( ) { push ( ) ; }
void calculate Next Frame ( ) { if ( m Prev Frame When Nsec == NUM_ ) { m Prev Frame When Nsec = System . nano Time ( ) ; m Recent Time Delta Next = - NUM_ ; return ; } long now Nsec = System . nano Time ( ) ; double cur Delta Sec = ( now Nsec - m Prev Frame When Nsec ) / NANOS PER SECOND ; if ( cur Delta Sec > MAX FRAME DELTA SEC ) { Log . d ( TAG , STR_ + cur Delta Sec + STR_ + MAX FRAME DELTA SEC ) ; cur Delta Sec = MAX FRAME DELTA SEC ; } double delta Sec ; if ( FRAME RATE SMOOTHING ) { if ( m Recent Time Delta Next < NUM_ ) { for ( int i = NUM_ ; i < RECENT TIME DELTA COUNT ; i ++ ) { m Recent Time Delta [ i ] = cur Delta Sec ; } m Recent Time Delta Next = NUM_ ; } m Recent Time Delta [ m Recent Time Delta Next ] = cur Delta Sec ; m Recent Time Delta Next = ( m Recent Time Delta Next + NUM_ ) % RECENT TIME DELTA COUNT ; delta Sec = NUM_ ; for ( int i = NUM_ ; i < RECENT TIME DELTA COUNT ; i ++ ) { delta Sec += m Recent Time Delta [ i ] ; } delta Sec /= RECENT TIME DELTA COUNT ; } else { delta Sec = cur Delta Sec ; } boolean advance Frame = true ; if ( m Pause Duration > NUM_ ) { advance Frame = false ; if ( m Pause Duration > delta Sec ) { m Pause Duration -= delta Sec ; if ( m Game Play State == GAME PLAYING ) { float [ ] colors = m Paddle . get Color ( ) ; if ( colors [ NUM_ ] == NUM_ ) { m Paddle . set Color ( NUM_ , NUM_ , NUM_ ) ; } else if ( colors [ NUM_ ] == NUM_ ) { m Paddle . set Color ( NUM_ , NUM_ , NUM_ ) ; } else { m Paddle . set Color ( NUM_ , NUM_ , NUM_ ) ; } } } else { m Pause Duration = NUM_ ; m Paddle . set Color ( NUM_ , NUM_ , NUM_ ) ; } } switch ( m Game Play State ) { case GAME INITIALIZING : m Game Play State = GAME READY ; break ; case GAME READY : m Game Status Message Num = Text Resources . READY ; if ( advance Frame ) { m Game Play State = GAME PLAYING ; m Game Status Message Num = Text Resources . NO MESSAGE ; set Pause Time ( NUM_ ) ; advance Frame = false ; } break ; case GAME WON : m Game Status Message Num = Text Resources . WINNER ; m Is Animating = false ; advance Frame = false ; break ; case GAME LOST : m Game Status Message Num = Text Resources . GAME OVER ; m Is Animating = false ; advance Frame = false ; break ; case GAME PLAYING : break ; default : Log . e ( TAG , STR_ + m Game Play State ) ; break ; } if ( advance Frame ) { int event = move Ball ( delta Sec ) ; switch ( event ) { case EVENT LAST BRICK : m Game Play State = GAME WON ; Sound Resources . play ( Sound Resources . PADDLE HIT ) ; Sound Resources . play ( Sound Resources . WALL HIT ) ; Sound Resources . play ( Sound Resources . BALL LOST ) ; break ; case EVENT BALL LOST : if ( -- m Lives Remaining == NUM_ ) { m Game Play State = GAME LOST ; } else { m Game Play State = GAME READY ; m Game Status Message Num = Text Resources . READY ; set Pause Time ( NUM_ ) ; reset Ball ( ) ; } break ; case EVENT NONE : break ; default : throw new Runtime Exception ( STR_ + event ) ; } } m Prev Frame When Nsec = now Nsec ; }
public static Tab State restore Tab State ( File state Folder , int id ) { boolean encrypted = false ; File file = get Tab State File ( state Folder , id , encrypted ) ; if ( ! file . exists ( ) ) { encrypted = true ; file = get Tab State File ( state Folder , id , encrypted ) ; } if ( ! file . exists ( ) ) return null ; return restore Tab State ( file , encrypted ) ; }
public static void add Combo Box ( final J Panel panel , final J Combo Box < String > combo Box , final String description , final String hint , final String [ ] values , final int selected Option ) { Preconditions . check Not Null ( panel , STR_ ) ; Preconditions . check Not Null ( combo Box , STR_ ) ; Preconditions . check Not Null ( description , STR_ ) ; Preconditions . check Not Null ( values , STR_ ) ; for ( final String string : values ) { combo Box . add Item ( string ) ; } combo Box . set Selected Index ( selected Option ) ; combo Box . set Preferred Size ( new Dimension ( PREFERRED WIDTH , PREFERRED HEIGHT ) ) ; add Component ( panel , combo Box , description , hint ) ; }
public void update Edge Parents ( Object cell , Object root ) { int child Count = get Child Count ( cell ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { Object child = get Child At ( cell , i ) ; update Edge Parents ( child , root ) ; } int edge Count = get Edge Count ( cell ) ; List < Object > edges = new Array List < Object > ( edge Count ) ; for ( int i = NUM_ ; i < edge Count ; i ++ ) { edges . add ( get Edge At ( cell , i ) ) ; } Iterator < Object > it = edges . iterator ( ) ; while ( it . has Next ( ) ) { Object edge = it . next ( ) ; if ( is Ancestor ( root , edge ) ) { update Edge Parent ( edge , root ) ; } } }
protected void reset ( ) { init Time Nanos = System . nano Time ( ) ; last Recording Nanos = init Time Nanos ; clock Start Time = new Date ( ) ; }
public Point 2 D transform ( Point 2 D graph Point ) { if ( graph Point == null ) return null ; Point 2 D view Center = get View Center ( ) ; double view Radius = get View Radius ( ) ; double ratio = get Ratio ( ) ; Point 2 D view Point = delegate . transform ( graph Point ) ; double dx = view Point . get X ( ) - view Center . get X ( ) ; double dy = view Point . get Y ( ) - view Center . get Y ( ) ; dx *= ratio ; Point 2 D point From Center = new Point 2 D . Double ( dx , dy ) ; Polar Point polar = Polar Point . cartesian To Polar ( point From Center ) ; double theta = polar . get Theta ( ) ; double radius = polar . get Radius ( ) ; if ( radius > view Radius ) return view Point ; double mag = Math . tan ( Math . PI / NUM_ * magnification ) ; radius *= mag ; radius = Math . min ( radius , view Radius ) ; radius /= view Radius ; radius *= Math . PI / NUM_ ; radius = Math . abs ( Math . atan ( radius ) ) ; radius *= view Radius ; Point 2 D projected Point = Polar Point . polar To Cartesian ( theta , radius ) ; projected Point . set Location ( projected Point . get X ( ) / ratio , projected Point . get Y ( ) ) ; Point 2 D translated Back = new Point 2 D . Double ( projected Point . get X ( ) + view Center . get X ( ) , projected Point . get Y ( ) + view Center . get Y ( ) ) ; return translated Back ; }
public Json Response < T > add Cookie ( New Cookie new Cookie ) { if ( cookies == null ) { cookies = new Array List < New Cookie > ( ) ; } cookies . add ( new Cookie ) ; return this ; }
private void emit Getter ( Method getter , String field Name , String return Type , String Builder builder ) { if ( getter . is Annotation Present ( javax . validation . constraints . Not Null . class ) ) { builder . append ( STR_ ) ; } else if ( getter . is Annotation Present ( org . eclipse . che . commons . annotation . Nullable . class ) ) { builder . append ( STR_ ) ; } builder . append ( STR_ ) ; builder . append ( return Type ) ; builder . append ( STR_ ) ; builder . append ( getter . get Name ( ) ) ; builder . append ( STR_ ) ; Class < ? > return Type Class = getter . get Return Type ( ) ; if ( is List ( return Type Class ) || is Map ( return Type Class ) ) { builder . append ( STR_ ) ; builder . append ( get Ensure Name ( field Name ) ) ; builder . append ( STR_ ) ; } builder . append ( STR_ ) ; emit Return ( getter , field Name , builder ) ; builder . append ( STR_ ) ; }
protected static void append Byte Array Type ( String Builder sb ) { sb . append ( STR_ ) ; }
public static void register Toolbar Action ( Selection Dependent Action action ) { toolbar Actions . add ( action ) ; }
public static Mode Scope change Mode ( Mode mode ) { Mode previous Mode = tl . get ( ) ; tl . set ( mode ) ; return new Mode Scope ( previous Mode ) ; }
protected void request Pass Code Confirmation ( ) { clear Boxes ( ) ; m Pass Code Hdr . set Text ( R . string . pass code reenter your pass code ) ; m Pass Code Hdr Explanation . set Visibility ( View . INVISIBLE ) ; m Confirming Pass Code = true ; }
public void finish Span ( ) { Trace State ts = trace State . get ( ) ; if ( ts != null ) { Span span = ts . pop Span ( ) ; if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( STR_ + span + STR_ + ts ) ; } span . finish ( ) ; if ( ts . is Finished ( ) ) { if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( STR_ + ts ) ; } trace State . remove ( ) ; } } else if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( STR_ ) ; } }
void add Markers ( Token tok ) { Syntax Document s Doc = ( Syntax Document ) pane . get Document ( ) ; s Doc . read Lock ( ) ; String text = tok . get Text ( s Doc ) ; Iterator < Token > it = s Doc . get Tokens ( NUM_ , s Doc . get Length ( ) ) ; while ( it . has Next ( ) ) { Token next Token = it . next ( ) ; if ( next Token . length == tok . length && text . equals ( next Token . get Text ( s Doc ) ) ) { Markers . mark Token ( pane , next Token , marker ) ; } } s Doc . read Unlock ( ) ; }
@ Override public void debug Print ( Print Stream out ) throws Ade Exception { super . debug Print ( out ) ; out . println ( STR_ ) ; }
@ Override public void layout Completed ( Layout Complete Event le ) { set Appropriate Size ( ) ; m gp . invalidate ( ) ; m js . revalidate ( ) ; m gp . repaint ( ) ; j Bt Layout . set Enabled ( true ) ; }
public static void init Urban Sim Zone Writer ( ) { try { log . info ( STR_ ) ; parcel Writer = IO Utils . get Buffered Writer ( Internal Constants . MATSIM 4 OPUS TEMP + FILE NAME ) ; log . info ( STR_ + Internal Constants . MATSIM 4 OPUS TEMP + FILE NAME + STR_ ) ; parcel Writer . write ( Internal Constants . PARCEL ID + STR_ + Internal Constants . ACCESSIBILITY BY FREESPEED + STR_ + Internal Constants . ACCESSIBILITY BY CAR + STR_ + Internal Constants . ACCESSIBILITY BY BIKE + STR_ + Internal Constants . ACCESSIBILITY BY WALK ) ; parcel Writer . new Line ( ) ; log . info ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public Key Store History ( Key Store key Store , String name , Password password , Provider explicit Provider ) { this . name = name ; this . explicit Provider = explicit Provider ; Key Store Type type = Key Store Type . resolve Jce ( key Store . get Type ( ) ) ; if ( type . is File Based ( ) ) { initial State = new Key Store State ( this , key Store , password ) ; } else { initial State = new Always Identical Key Store State ( this , key Store , password ) ; } current State = initial State ; }
protected void check And Send Notation ( Notation not ) { if ( is Root Document ( ) ) { int index = f Notations . index Of ( not ) ; if ( index == - NUM_ ) { XML Resource Identifier id = new XML Resource Identifier Impl ( not . public Id , not . system Id , not . base URI , not . expanded System Id ) ; add Notation ( not . name , id , not . augmentations ) ; if ( f Send UE And Notation Events && f DTD Handler != null ) { f DTD Handler . notation Decl ( not . name , id , not . augmentations ) ; } } else { Notation local Notation = ( Notation ) f Notations . get ( index ) ; if ( ! not . is Duplicate ( local Notation ) ) { report Fatal Error ( STR_ , new Object [ ] { not . name } ) ; } } } else { f Parent X Include Handler . check And Send Notation ( not ) ; } }
void sanitize Menu Position ( Rect F menu Rect ) { Point app Usable Screen Size = get App Usable Screen Size ( ) ; float margin = flyout Menu View . menu Margin ; float right = app Usable Screen Size . x - margin ; float bottom = app Usable Screen Size . y - margin ; if ( menu Rect . left < margin ) { float dx = margin - menu Rect . left ; menu Rect . offset ( dx , NUM_ ) ; } if ( menu Rect . top < margin ) { float dy = margin - menu Rect . top ; menu Rect . offset ( NUM_ , dy ) ; } if ( menu Rect . right > right ) { float dx = right - menu Rect . right ; menu Rect . offset ( dx , NUM_ ) ; } if ( menu Rect . bottom > bottom ) { float dy = bottom - menu Rect . bottom ; menu Rect . offset ( NUM_ , dy ) ; } }
public static final Timeout Token add Timeout Handler ( long run Time , Runnable handler ) { Timeout Token token = new Timeout Token ( run Time , handler ) ; synchronized ( todolist ) { todolist . add ( token ) ; Collections . sort ( todolist ) ; if ( timeout Thread != null ) timeout Thread . interrupt ( ) ; else { timeout Thread = new Timeout Thread ( ) ; timeout Thread . set Daemon ( true ) ; timeout Thread . start ( ) ; } } return token ; }
private static List < Category List Item > flatten Root Category ( Category List Item category ) { Category List Item [ ] sub Categories = category . sub Items ; List < Category List Item > sibling Categories = new Array List < Category List Item > ( ) ; for ( int i = NUM_ ; i < sub Categories . length ; i ++ ) { Category List Item sub Category = sub Categories [ i ] ; Category List Item [ ] sub Sub Categories = sub Category . sub Items ; if ( sub Sub Categories . length != NUM_ ) { Category List Item [ ] new Sub Categories = new Category List Item [ sub Categories . length - NUM_ ] ; System . arraycopy ( sub Categories , NUM_ , new Sub Categories , NUM_ , i ) ; System . arraycopy ( sub Categories , i + NUM_ , new Sub Categories , i , sub Categories . length - i - NUM_ ) ; category = new Category List Item ( category . name , category . full Name , category . key , new Sub Categories ) ; Category List Item sibling Category = new Category List Item ( category . name + STR_ + sub Category . name , null , sub Category . key , sub Sub Categories ) ; List < Category List Item > flattened Sibling Category = flatten Root Category ( sibling Category ) ; sibling Categories . add All ( flattened Sibling Category ) ; } } if ( ! sibling Categories . is Empty ( ) ) { Log . v ( STR_ , category . full Name + STR_ + sibling Categories . size ( ) + STR_ + STR_ ) ; } sibling Categories . add ( NUM_ , category ) ; return sibling Categories ; }
public String list Quests States ( final Player player ) { final String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; for ( final I Quest quest : quests ) { if ( quest . is Started ( player ) && ! quest . is Completed ( player ) ) { sb . append ( STR_ + quest . get Name ( ) + STR_ + quest . get Slot Name ( ) + STR_ + player . get Quest ( quest . get Slot Name ( ) ) ) ; } } sb . append ( STR_ ) ; for ( final I Quest quest : quests ) { if ( quest . is Completed ( player ) ) { sb . append ( STR_ + quest . get Name ( ) + STR_ + quest . get Slot Name ( ) + STR_ + player . get Quest ( quest . get Slot Name ( ) ) ) ; } } return sb . to String ( ) ; }
@ Override public Default Ascii Array with Title ( String ... columns Title ) { this . titles = Arrays . as List ( columns Title ) ; return this ; }
public Composer transform ( float x , float y , int alpha , float scale X , float scale Y , float rotation ) { if ( m Tween Parameter List . size ( ) > NUM_ ) { to ( NUM_ , x , y , alpha , scale X , scale Y , rotation , Ease . NONE ) ; } else { m Initial Param = new Anim Parameter ( x , y , alpha , scale X , scale Y , rotation ) ; } return this ; }
public static int calc Hash ( char [ ] buffer , int start , int len ) { int hash = ( int ) buffer [ NUM_ ] ; for ( int i = NUM_ ; i < len ; ++ i ) { hash = ( hash * NUM_ ) + ( int ) buffer [ i ] ; } return hash ; }
private int reverse Index ( int k ) { if ( reverse Index Map == null ) { reverse Index Map = new int [ attributes . get Length ( ) ] ; for ( int i = NUM_ , len = index Set . size ( ) ; i < len ; i ++ ) reverse Index Map [ index Set . get ( i ) ] = i + NUM_ ; } return reverse Index Map [ k ] - NUM_ ; }
protected void execute Tasks ( final Access Path Task [ ] tasks ) throws Exception { if ( executor == null ) { for ( Access Path Task task : tasks ) { task . call ( ) ; } return ; } final List < Future Task < Void > > future Tasks = new Linked List < Future Task < Void > > ( ) ; for ( Access Path Task task : tasks ) { final Future Task < Void > ft = new Future Task < Void > ( task ) ; future Tasks . add ( ft ) ; } try { for ( Future Task < Void > ft : future Tasks ) { if ( halt ) throw new Runtime Exception ( first Cause . get ( ) ) ; executor . execute ( ft ) ; } for ( Future Task < Void > ft : future Tasks ) { if ( ! halt ) ft . get ( ) ; } } finally { for ( Future Task < Void > ft : future Tasks ) { ft . cancel ( true ) ; } } }
private void trim Database ( ) { L Log . i ( STR_ ) ; Cursor cursor = null ; try { cursor = content Resolver . query ( downloads Uri Provider . get All Downloads Uri ( ) , new String [ ] { Download Contract . Downloads . ID } , Download Contract . Downloads . COLUMN STATUS + STR_ , null , Download Contract . Downloads . COLUMN LAST MODIFICATION ) ; if ( cursor == null ) { L Log . e ( STR_ ) ; return ; } if ( cursor . move To First ( ) ) { int num Delete = cursor . get Count ( ) - Constants . MAX DOWNLOADS ; int column Id = cursor . get Column Index Or Throw ( Download Contract . Downloads . ID ) ; while ( num Delete > NUM_ ) { Uri download Uri = Content Uris . with Appended Id ( downloads Uri Provider . get All Downloads Uri ( ) , cursor . get Long ( column Id ) ) ; content Resolver . delete ( download Uri , null , null ) ; if ( ! cursor . move To Next ( ) ) { break ; } num Delete -- ; } } } catch ( SQ Lite Exception e ) { L Log . w ( STR_ + e . get Message ( ) ) ; return ; } finally { if ( cursor != null ) { cursor . close ( ) ; } } }
private void start Intermediate Merging ( File [ ] intermediate Files ) { File file = new File ( parameters . get Temp File Location ( ) + File . separator + parameters . get Table Name ( ) + System . nano Time ( ) + Carbon Common Constants . MERGERD EXTENSION ) ; Intermediate File Merger merger = new Intermediate File Merger ( parameters , intermediate Files , file ) ; executor Service . submit ( merger ) ; }
private int add Expansion ( int an Order , String expand Chars ) { if ( expand Table == null ) { expand Table = new Vector < > ( INITIALTABLESIZE ) ; } int offset = ( an Order == RB Collation Tables . UNMAPPED ) ? NUM_ : NUM_ ; int [ ] value List = new int [ expand Chars . length ( ) + offset ] ; if ( offset == NUM_ ) { value List [ NUM_ ] = an Order ; } int j = offset ; for ( int i = NUM_ ; i < expand Chars . length ( ) ; i ++ ) { char ch 0 = expand Chars . char At ( i ) ; char ch 1 ; int ch ; if ( Character . is High Surrogate ( ch 0 ) ) { if ( ++ i == expand Chars . length ( ) || ! Character . is Low Surrogate ( ch 1 = expand Chars . char At ( i ) ) ) { break ; } ch = Character . to Code Point ( ch 0 , ch 1 ) ; } else { ch = ch 0 ; } int map Value = get Char Order ( ch ) ; if ( map Value != RB Collation Tables . UNMAPPED ) { value List [ j ++ ] = map Value ; } else { value List [ j ++ ] = CHARINDEX + ch ; } } if ( j < value List . length ) { int [ ] tmp Buf = new int [ j ] ; while ( -- j >= NUM_ ) { tmp Buf [ j ] = value List [ j ] ; } value List = tmp Buf ; } int table Index = RB Collation Tables . EXPANDCHARINDEX + expand Table . size ( ) ; expand Table . add Element ( value List ) ; return table Index ; }
public void register Prefix For URI ( String prefix , String uri ) { if ( ( uri != null ) && ( prefix != null ) ) { if ( no Namespace Mappings ) { ns Stack . push ( ) ; no Namespace Mappings = false ; } String active Prefix = ns Stack . get Prefix ( uri , true ) ; if ( active Prefix == null || ! active Prefix . equals ( prefix ) ) { ns Stack . add ( uri , prefix ) ; } } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } if ( ! ( obj instanceof XY Polygon Annotation ) ) { return false ; } XY Polygon Annotation that = ( XY Polygon Annotation ) obj ; if ( ! Arrays . equals ( this . polygon , that . polygon ) ) { return false ; } if ( ! Object Utilities . equal ( this . stroke , that . stroke ) ) { return false ; } if ( ! Paint Utilities . equal ( this . outline Paint , that . outline Paint ) ) { return false ; } if ( ! Paint Utilities . equal ( this . fill Paint , that . fill Paint ) ) { return false ; } return true ; }
static public double log 10 ( double in Value ) { return Math . log ( in Value ) / Math . log ( NUM_ ) ; }
void free Soft References ( ) { try { eat Memory ( NUM_ ) ; } catch ( Out Of Memory Error e ) { } System . gc ( ) ; System . gc ( ) ; free Memory ( ) ; }
public void remove Action Fire Listener ( On Action Fired Listener listener ) { if ( listener != null ) m Action Fired Listeners . remove ( listener ) ; }
private void add Self Intersection Node ( int arg Index , Coordinate coord , int loc ) { if ( is Boundary Node ( arg Index , coord ) ) return ; if ( loc == Location . BOUNDARY && use Boundary Determination Rule ) insert Boundary Point ( arg Index , coord ) ; else insert Point ( arg Index , coord , loc ) ; }
private String format String ( String content ) { if ( content != null ) return String Utils . format String ( content ) ; return content ; }
public void extend ( String variable , Collection < Value > vals ) { Set < Assignment > new Groundings = new Hash Set < Assignment > ( ) ; for ( Assignment g : groundings ) { for ( Value v : vals ) { new Groundings . add ( new Assignment ( g , variable , v ) ) ; } } groundings = new Groundings ; }
public static boolean is Valid SQL Text ( Textbox f ) { if ( f != null && f . get Text ( ) != null ) return is Valid SQL Text ( f . get Text ( ) ) ; return false ; }
public void add Property ( String key , String value ) { carbon Properties . set Property ( key , value ) ; }
public Collection < Cluster Node > nodes ( @ Nullable Collection < UUID > ids , Ignite Predicate < UUID > ... p ) { return F . is Empty ( ids ) ? Collections . < Cluster Node > empty List ( ) : F . view ( F . view Read Only ( ids , U . id 2 Node ( ctx ) , p ) , F . not Null ( ) ) ; }
private static String pretty Print Object ( Lz Persistent Base Impl < ? extends Generic PK > object , Pretty Print Options options ) { if ( options != null && options . get Style ( ) == Reference Style . NAME ) { if ( options . is Explicit Type ( ) ) { return Pretty Print Constant . IDENTIFIER TAG + Analysis Scope . AXIS + STR_ + Pretty Print Constant . OPEN IDENT + object . get Name ( ) + Pretty Print Constant . CLOSE IDENT ; } else { return Pretty Print Constant . OPEN IDENT + object . get Name ( ) + Pretty Print Constant . CLOSE IDENT ; } } else { return Pretty Print Constant . IDENTIFIER TAG + Pretty Print Constant . OPEN IDENT + object . get Oid ( ) + Pretty Print Constant . CLOSE IDENT ; } }
public Builder with Session Timeout ( Duration session Timeout ) { Assert . arg Not ( session Timeout . is Negative ( ) || session Timeout . is Zero ( ) , STR_ ) ; Assert . arg Not ( session Timeout . to Millis ( ) <= election Timeout . to Millis ( ) , STR_ ) ; this . session Timeout = Assert . not Null ( session Timeout , STR_ ) ; return this ; }
public void initialize Iterations ( ) { if ( df == null ) df = new Function Derivative ( f ) ; if ( Double . is Na N ( result ) ) result = NUM_ ; int n = NUM_ ; while ( Dr Math . equal ( df . value ( result ) , NUM_ ) ) { if ( ++ n > get Maximum Iterations ( ) ) break ; result += Math . random ( ) ; } }
private boolean verify Signature ( String [ ] record , int sign Pos , int rec Pos ) throws Exception { String cur Sign = record [ sign Pos ] ; if ( cur MAC == null ) { return false ; } byte [ ] prev MAC = helper . to Byte Array ( cur MAC ) ; byte [ ] new MAC ; if ( ( prev Signature == null ) || prev Signature . equals ( STR_ ) ) { new MAC = new byte [ prev MAC . length ] ; System . arraycopy ( prev MAC , NUM_ , new MAC , NUM_ , prev MAC . length ) ; } else { new MAC = new byte [ prev MAC . length + helper . to Byte Array ( prev Signature ) . length ] ; System . arraycopy ( prev MAC , NUM_ , new MAC , NUM_ , prev MAC . length ) ; System . arraycopy ( helper . to Byte Array ( prev Signature ) , NUM_ , new MAC , prev MAC . length , helper . to Byte Array ( prev Signature ) . length ) ; } if ( rec Pos != NUM_ ) { prev Signature = cur Sign ; } verified = helper . verify Signature ( helper . to Byte Array ( cur Sign ) , new MAC ) ; return verified ; }
protected void append Date Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
public static Lazy Query Container create Lazy Query Container ( final Bean Query Factory < ? extends Abstract Bean Query < ? > > query Factory ) { query Factory . set Query Configuration ( Collections . empty Map ( ) ) ; return new Lazy Query Container ( new Lazy Query Definition ( true , NUM_ , SPUI Label Definitions . VAR NAME ) , query Factory ) ; }
public Intervalle Date previous Year ( ) { Calendar lower = null ; if ( lower bound != null ) { lower = Calendar . get Instance ( ) ; lower . set Time ( lower bound ) ; lower . add ( Calendar . YEAR , - NUM_ ) ; } Calendar upper = null ; if ( upper bound != null ) { upper = Calendar . get Instance ( ) ; upper . set Time ( upper bound ) ; upper . add ( Calendar . YEAR , - NUM_ ) ; } return new Intervalle Date ( lower . get Time ( ) , upper . get Time ( ) ) ; }
public static String create Library File Name ( String library Name ) { String lib Prefix = create Library Prefix ( ) ; String lib Extension = create Library Extension ( ) ; String full Name = lib Prefix + library Name + STR_ + lib Extension ; return full Name ; }
protected void reward Player ( final Player player ) { player . add Karma ( NUM_ ) ; player . set Atk XP ( player . get Atk XP ( ) + ( int ) ( player . get XP ( ) * ATK REWARD RATE ) ) ; player . inc Atk XP ( ) ; player . send Private Text ( Notification Type . POSITIVE , STR_ + Integer . to String ( ( int ) ( player . get XP ( ) * ATK REWARD RATE ) ) + STR_ ) ; }
public static Tailer create ( File file , Tailer Listener listener , long delay Millis , boolean end , boolean re Open , int buf Size ) { Tailer tailer = new Tailer ( file , listener , delay Millis , end , re Open , buf Size ) ; Thread thread = new Thread ( tailer ) ; thread . set Daemon ( true ) ; thread . start ( ) ; return tailer ; }
protected final Json Token finish Token ( ) throws IO Exception { if ( input Ptr >= input End ) { return Json Token . NOT AVAILABLE ; } byte b = input Buffer [ input Ptr ++ ] ; if ( state == STATE INITIAL ) { if ( b == Smile Constants . HEADER BYTE 1 ) { if ( ! handle Header ( NUM_ ) ) { return Json Token . NOT AVAILABLE ; } if ( input Ptr >= input End ) { return Json Token . NOT AVAILABLE ; } b = input Buffer [ input Ptr ++ ] ; } else { if ( cfg Require Header ) { String msg ; if ( b == STR_ || b == STR_ ) { msg = STR_ + Integer . to Hex String ( b & NUM_ ) + STR_ + ( ( char ) b ) + STR_ ; } else { msg = STR_ + Integer . to Hex String ( b & NUM_ ) + STR_ ; } throw new Json Parse Exception ( this , msg ) ; } } } else if ( state == STATE HEADER ) { if ( ! handle Header ( substate ) ) { return Json Token . NOT AVAILABLE ; } if ( input Ptr >= input End ) { return Json Token . NOT AVAILABLE ; } b = input Buffer [ input Ptr ++ ] ; } switch ( state ) { case STATE NUMBER INT : return next Int ( substate , pending Int ) ; case STATE NUMBER LONG : return next Long ( substate , pending Long ) ; case STATE NUMBER BIGINT : return next Big Int ( substate ) ; case STATE NUMBER FLOAT : return next Float ( substate , pending Int ) ; case STATE NUMBER DOUBLE : return next Double ( substate , pending Long ) ; case STATE NUMBER BIGDEC : return next Big Decimal ( substate ) ; } throw Invalid State ( STR_ ) ; return null ; }
@ Override public int hash Code ( ) { final int prime = NUM_ ; int result = NUM_ ; result = prime * result + ( ( database Name == null ) ? NUM_ : database Name . hash Code ( ) ) ; result = prime * result + ( ( table Unique Name == null ) ? NUM_ : table Unique Name . hash Code ( ) ) ; return result ; }
protected void on Get Image Error ( String cache Key , Volley Error error ) { Batched Image Request request = m In Flight Requests . remove ( cache Key ) ; if ( request != null ) { request . set Error ( error ) ; batch Response ( cache Key , request ) ; } }
public boolean can Go Hull Down ( ) { return false ; }
protected final void read Base ( final Element element ) { set Id ( Lw Xml Reader . get Required String ( element , UI Form Xml Constants . ATTRIBUTE ID ) ) ; set Binding ( element . get Attribute Value ( UI Form Xml Constants . ATTRIBUTE BINDING ) ) ; my Custom Create = Lw Xml Reader . get Optional Boolean ( element , UI Form Xml Constants . ATTRIBUTE CUSTOM CREATE , false ) ; my Default Binding = Lw Xml Reader . get Optional Boolean ( element , UI Form Xml Constants . ATTRIBUTE DEFAULT BINDING , false ) ; }
@ Override public void populate Frame ( Audio a ) { if ( ! ( a instanceof Audio Source ) ) { throw new Illegal Argument Exception ( a . get System Name ( ) + STR_ ) ; } super . populate Frame ( a ) ; Audio Source s = ( Audio Source ) a ; Audio Manager am = Instance Manager . get Default ( jmri . Audio Manager . class ) ; String ab = s . get Assigned Buffer Name ( ) ; Audio b = am . get Audio ( ab ) ; if ( b != null ) { assigned Buffer . set Selected Item ( b . get User Name ( ) == null ? ab : b . get User Name ( ) ) ; } loop Infinite . set Selected ( ( s . get Min Loops ( ) == Audio Source . LOOP CONTINUOUS ) ) ; loop Min . set Value ( loop Infinite . is Selected ( ) ? NUM_ : s . get Min Loops ( ) ) ; loop Max . set Value ( loop Infinite . is Selected ( ) ? NUM_ : s . get Max Loops ( ) ) ; position . set Value ( s . get Position ( ) ) ; position Relative . set Selected ( s . is Position Relative ( ) ) ; velocity . set Value ( s . get Velocity ( ) ) ; gain . set Value ( s . get Gain ( ) ) ; pitch . set Value ( s . get Pitch ( ) ) ; ref Distance . set Value ( s . get Reference Distance ( ) ) ; max Distance . set Value ( s . get Maximum Distance ( ) ) ; roll Off Factor . set Value ( s . get Roll Off Factor ( ) ) ; fade In Time . set Value ( s . get Fade In ( ) ) ; fade Out Time . set Value ( s . get Fade Out ( ) ) ; this . new Source = false ; }
private float calculate Linear Out Faster In Y 2 ( float velocity ) { float t = ( velocity - m Min Velocity Px Per Second ) / ( m High Velocity Px Per Second - m Min Velocity Px Per Second ) ; t = Math . max ( NUM_ , Math . min ( NUM_ , t ) ) ; return ( NUM_ - t ) * LINEAR OUT FASTER IN Y 2 MIN + t * LINEAR OUT FASTER IN Y 2 MAX ; }
public static void drop Index ( Connection conn , String schema , String table ) throws SQL Exception { init ( conn ) ; Prepared Statement prep = conn . prepare Statement ( STR_ + SCHEMA + STR_ ) ; prep . set String ( NUM_ , schema ) ; prep . set String ( NUM_ , table ) ; int row Count = prep . execute Update ( ) ; if ( row Count == NUM_ ) { return ; } reindex ( conn ) ; }
public void dump ( String context ) throws Key Store Exception , No Such Algorithm Exception { dump ( context , key Store , key Password ) ; }
public static Object Input Stream new Object Input Stream ( Path self ) throws IO Exception { return new Object Input Stream ( Files . new Input Stream ( self ) ) ; }
public Builder For Gossip Seed Discoverer max Discover Attempts ( int max Discover Attempts ) { super . max Discover Attempts = max Discover Attempts ; return this ; }
public static void update Port Associations ( Network Lite network , List < Storage Port > ports , Db Client db Client ) { Set < String > varray Set = new Hash Set < String > ( network . get Assigned Virtual Arrays ( ) ) ; for ( Storage Port port : ports ) { port . set Network ( network . get Id ( ) ) ; port . replace Connected Virtual Array ( varray Set ) ; log . info ( STR_ , port . get Port Network Id ( ) , varray Set ) ; } db Client . update And Reindex Object ( ports ) ; }
private static void append Integer Type ( String Builder sb ) { sb . append ( STR_ ) ; }
private void create Element ( Document doc , Element parent Element , String element Name , int value ) { Element element = doc . create Element ( element Name ) ; element . append Child ( doc . create Text Node ( Integer . to String ( value ) ) ) ; parent Element . append Child ( element ) ; }
public All Access Exporter ( String input , byte [ ] cp Data ) throws No Such Algorithm Exception , No Such Padding Exception , IO Exception { m Cipher = Cipher . get Instance ( STR_ ) ; m Key Spec = new Secret Key Spec ( cp Data , STR_ ) ; m Input = new File Input Stream ( input ) ; m Magic Number = new byte [ NUM_ ] ; if ( m Input . read ( m Magic Number ) != NUM_ ) m Magic Number = null ; }
public void add Sub Action ( Sub Action sub ) { list . add ( sub ) ; }
public Atomic File ( File base Name ) { m Base Name = base Name ; m Backup Name = new File ( base Name . get Path ( ) + STR_ ) ; }
public static boolean is Gzip File ( Input Stream in ) throws IO Exception { if ( ! in . mark Supported ( ) ) { throw new Illegal Argument Exception ( STR_ ) ; } in . mark ( NUM_ ) ; try { final byte [ ] b = new byte [ NUM_ ] ; IO Utils . read Fully ( in , b , NUM_ , NUM_ ) ; final int magic = ( ( ( int ) b [ NUM_ ] & NUM_ ) << NUM_ ) | ( ( int ) b [ NUM_ ] & NUM_ ) ; return magic == GZIP Input Stream . GZIP MAGIC ; } finally { in . reset ( ) ; } }
public static Intent create Get Content Intent ( ) { final Intent intent = new Intent ( Intent . ACTION GET CONTENT ) ; intent . set Type ( STR_ ) ; intent . add Category ( Intent . CATEGORY OPENABLE ) ; return intent ; }
protected File create Temp Dir ( ) throws IO Exception { File tmp = create Temp File ( STR_ ) ; if ( ! tmp . delete ( ) ) { throw new IO Exception ( STR_ + tmp . get Path ( ) + STR_ ) ; } tmp . mkdir ( ) ; return tmp ; }
protected void generate Adapter ( ) { String holder Class Name = Utils . get View Holder Class Name ( ) ; String Builder holder Builder = new String Builder ( ) ; String Builder generator = new String Builder ( ) ; generator . append ( STR_ + holder Class Name + STR_ ) ; String root View Name = STR_ ; holder Builder . append ( STR_ + STR_ + root View Name + STR_ ) ; generator . append ( STR_ + root View Name + STR_ + root View Name + STR_ ) ; for ( Element element : m Elements ) { if ( ! element . used ) { continue ; } holder Builder . append ( STR_ + element . name + STR_ + element . get Field Name ( ) + STR_ ) ; generator . append ( STR_ + element . get Field Name ( ) + STR_ + element . name + STR_ + root View Name + STR_ + element . get Full ID ( ) + STR_ ) ; } generator . append ( STR_ ) ; holder Builder . append ( generator . to String ( ) ) ; Psi Class view Holder = m Factory . create Class From Text ( holder Builder . to String ( ) , m Class ) ; view Holder . set Name ( holder Class Name ) ; m Class . add ( view Holder ) ; m Class . add Before ( m Factory . create Keyword ( STR_ , m Class ) , m Class . find Inner Class By Name ( holder Class Name , true ) ) ; m Class . add Before ( m Factory . create Keyword ( STR_ , m Class ) , m Class . find Inner Class By Name ( holder Class Name , true ) ) ; }
public synchronized void shutdown ( ) { shutdown = true ; notify All ( ) ; }
@ Override public final void close Shape ( ) { elements . add ( new Close Path ( ) ) ; }
private static Api Field copy Field ( Api Field api Field ) { Api Field field Copy = new Api Field ( ) ; field Copy . name = api Field . name ; field Copy . required = api Field . required ; field Copy . primitive Type = api Field . primitive Type ; field Copy . wrapper Name = api Field . wrapper Name ; field Copy . description = api Field . description ; field Copy . valid Values = Lists . new Array List ( api Field . valid Values ) ; field Copy . collection = api Field . collection ; field Copy . min = api Field . min ; field Copy . max = api Field . max ; return field Copy ; }
public static final String insert Image ( Context contex , Bitmap source , String title , String description , Callback cb ) { final Simple Date Format df = new Simple Date Format ( STR_ ) ; final String time = df . format ( new Date ( ) ) ; return insert Image ( contex . get Content Resolver ( ) , source , title , description , cb ) ; }
public static byte [ ] pad Array ( byte [ ] array , byte value , int new Length ) { int length = array . length ; int padding Length = new Length - length ; if ( padding Length < NUM_ ) { return array ; } else { byte [ ] padding = new byte [ padding Length ] ; Arrays . fill ( padding , value ) ; return concatenate ( array , padding ) ; } }
public Garbage Collector Metric Set ( ) { this ( Management Factory . get Garbage Collector MX Beans ( ) ) ; }
private static String prepare Instruction ( String inst ) { String tmp = inst ; tmp = tmp . replace All ( Lop . OPERAND DELIMITOR , STR_ ) ; tmp = tmp . replace All ( Lop . DATATYPE PREFIX , STR_ ) ; tmp = tmp . replace All ( Lop . INSTRUCTION DELIMITOR , STR_ ) ; return tmp ; }
public void run Warrant ( int Run Mode ) { set Route ( NUM_ , null ) ; set Run Mode ( Run Mode , null , null , null , false ) ; }
public static Vector Clock increment ( Vector Clock clock , int ... nodes ) { for ( int n : nodes ) clock = clock . incremented ( ( short ) n , System . current Time Millis ( ) ) ; return clock ; }
protected void handle Pending Call Result ( RTMP Connection conn , Notify invoke ) { final I Service Call call = invoke . get Call ( ) ; final I Pending Service Call pending Call = conn . retrieve Pending Call ( invoke . get Invoke Id ( ) ) ; if ( pending Call != null ) { Object [ ] args = call . get Arguments ( ) ; if ( ( args != null ) && ( args . length > NUM_ ) ) { pending Call . set Result ( args [ NUM_ ] ) ; } Set < I Pending Service Callback > callbacks = pending Call . get Callbacks ( ) ; if ( ! callbacks . is Empty ( ) ) { Hash Set < I Pending Service Callback > tmp = new Hash Set < I Pending Service Callback > ( ) ; tmp . add All ( callbacks ) ; for ( I Pending Service Callback callback : tmp ) { try { callback . result Received ( pending Call ) ; } catch ( Exception e ) { log . error ( STR_ , callback , e ) ; } } } } }
public void modify Leaf Block ( Block Id blk ) { lock Tbl . x Lock ( blk , tx Num ) ; writen Index Blks . add ( blk ) ; }
@ Override public void do Get ( Base Solr Resource endpoint , String child Id ) { Solr Query Response response = endpoint . get Solr Response ( ) ; if ( child Id != null ) { String key = get Ignore Case ( ) ? child Id . to Lower Case ( Locale . ROOT ) : child Id ; if ( ! managed Words . contains ( key ) ) throw new Solr Exception ( Error Code . NOT FOUND , String . format ( Locale . ROOT , STR_ , child Id , get Resource Id ( ) ) ) ; response . add ( child Id , key ) ; } else { response . add ( WORD SET JSON FIELD , build Map To Store ( managed Words ) ) ; } }
private boolean apply Volumes To Masks Using Rules ( Storage System storage , Export Group export Group , Map < URI , Map < URI , Integer > > existing Masks To Update With New Volumes , Map < URI , Map < URI , Integer > > volumes With No Mask , Map < Export Mask , Export Mask Policy > masks Map , Map < URI , Set < Initiator > > mask To Initiators Map , Set < URI > partial Masks , String token ) { boolean is VMAX 3 = storage . check If Vmax 3 ( ) ; if ( export Group . check Internal Flags ( Flag . RECOVERPOINT ) || ( export Group . check Internal Flags ( Flag . RECOVERPOINT JOURNAL ) ) ) { masks Map = apply Volumes To Masks Using RPVMAX Rules ( storage , export Group , masks Map ) ; if ( masks Map . is Empty ( ) ) { log . info ( STR_ ) ; return true ; } } if ( ! apply Volumes To Masks Using Rule ( export Group , token , existing Masks To Update With New Volumes , volumes With No Mask , masks Map , mask To Initiators Map , partial Masks , NUM_ , is VMAX 3 ) ) { return false ; } if ( ! apply Volumes To Masks Using Rule ( export Group , token , existing Masks To Update With New Volumes , volumes With No Mask , masks Map , mask To Initiators Map , partial Masks , NUM_ , is VMAX 3 ) ) { return false ; } if ( ! apply Volumes To Masks Using Rule ( export Group , token , existing Masks To Update With New Volumes , volumes With No Mask , masks Map , mask To Initiators Map , partial Masks , NUM_ , is VMAX 3 ) ) { return false ; } return true ; }
public static void create Alias ( String host , String alias , String collection ) throws IO Exception { String create Alias Template = STR_ ; String create Alias Command = String . format ( create Alias Template , host , DEFAULT SOLR PORT , alias , collection ) ; String result = execute Solr Command ( create Alias Command ) ; logger . info ( result ) ; }
protected void adjust Min Max ( Local Tile tile ) { if ( this . extreme Elevations == null && tile != null ) { this . extreme Elevations = new double [ ] { tile . min Elevation , tile . max Elevation } ; } else if ( tile != null ) { if ( tile . min Elevation < this . extreme Elevations [ NUM_ ] ) this . extreme Elevations [ NUM_ ] = tile . min Elevation ; if ( tile . max Elevation > this . extreme Elevations [ NUM_ ] ) this . extreme Elevations [ NUM_ ] = tile . max Elevation ; } else { double min = Double . MAX VALUE ; double max = - min ; for ( Local Tile t : this . tiles ) { if ( t . min Elevation < min ) min = t . min Elevation ; if ( t . max Elevation > max ) max = t . max Elevation ; } this . extreme Elevations = new double [ ] { min != Double . MAX VALUE ? min : NUM_ , max != - Double . MAX VALUE ? max : NUM_ } ; } }
protected void close Resources ( Connection connection , Statement statement ) { if ( cache Statements ) return ; if ( statement != null ) { try { statement . close ( ) ; } catch ( SQL Exception e ) { LOG . finest ( STR_ + e . get Message ( ) + STR_ ) ; } } close Resources ( connection ) ; }
private void listener Dropped ( Array List drops , Array List notifies ) { Service Registrar [ ] proxys = new Service Registrar [ drops . size ( ) ] ; drops . to Array ( proxys ) ; listener Dropped ( proxys , notifies ) ; }
private Map < String , Big Decimal > init Reasons Map ( final Map < String , Big Decimal > tax Sum ) { tax Sum . put ( DEMANDRSN CODE GENERAL TAX , Big Decimal . ZERO ) ; tax Sum . put ( DEMANDRSN CODE LIBRARY CESS , Big Decimal . ZERO ) ; tax Sum . put ( DEMANDRSN CODE EDUCATIONAL CESS , Big Decimal . ZERO ) ; tax Sum . put ( DEMANDRSN CODE UNAUTHORIZED PENALTY , Big Decimal . ZERO ) ; tax Sum . put ( DEMANDRSN CODE PENALTY FINES , Big Decimal . ZERO ) ; tax Sum . put ( DEMANDRSN CODE CHQ BOUNCE PENALTY , Big Decimal . ZERO ) ; return tax Sum ; }
public int checksum ts ( ) { return calculate Checksum ( compile checksum . to String ( ) + compile checksum ts . to String ( ) ) ; }
@ Override public void print General User Data ( I Structured Output Writer out ) throws Exception { out . simple Child ( STR_ , m percentiles With Empty Intervals ) ; out . simple Child ( STR_ , m interval Count ) ; final I Structured Output Writer child = out . child ( STR_ ) ; for ( int i = NUM_ ; i < NUM BUCKETS ; ++ i ) { child . simple Child ( STR_ + i , m percentiles [ i ] ) ; } child . close ( ) ; }
private static Object new Proxy Instance ( List < Class Loader > class Loaders To Try , Class < ? > [ ] interfaces , Invocation Handler delegate ) throws Illegal Argument Exception { Object ret = null ; Class Loader cl = class Loaders To Try . get ( NUM_ ) ; List < Class Loader > remaining Class Loaders = class Loaders To Try . sub List ( NUM_ , class Loaders To Try . size ( ) ) ; try { return Proxy . new Proxy Instance ( cl , interfaces , delegate ) ; } catch ( Illegal Argument Exception some Class Not Found ) { if ( remaining Class Loaders . size ( ) > NUM_ ) { ret = new Proxy Instance ( remaining Class Loaders , interfaces , delegate ) ; } else { throw some Class Not Found ; } } return ret ; }
public void paint Children ( Graphics g , Rectangle clip ) { Buffered Image local Drawing Buffer = drawing Buffer ; if ( buffer Dirty ) { local Drawing Buffer = reset Drawing Buffer ( local Drawing Buffer , get Projection ( ) ) ; draw Projection Background ( local Drawing Buffer . get Graphics ( ) ) ; render Data For Projection ( get Projection ( ) , local Drawing Buffer . get Graphics ( ) ) ; drawing Buffer = local Drawing Buffer ; } if ( local Drawing Buffer != null ) { g . draw Image ( local Drawing Buffer , NUM_ , NUM_ , null ) ; } }
public void load XML ( Node stepnode , List < Database Meta > databases , Map < String , Counter > counters ) throws Kettle XML Exception { try { this . tabel Name = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . output Row Size = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . fact Dim Lens String = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . cube Name = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . schema Name = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . dimension Count = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . no Dictionary Dims = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . no Dictionary Dims Mapping = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . complex Dimension Count = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . measure Count = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . update Member Request = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . measure Data Type = XML Handler . get Tag Value ( stepnode , STR_ ) ; current Restruct Number = Integer . parse Int ( XML Handler . get Tag Value ( stepnode , STR_ ) ) ; this . partition ID = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . segment Id = XML Handler . get Tag Value ( stepnode , STR_ ) ; this . task No = XML Handler . get Tag Value ( stepnode , STR_ ) ; } catch ( Exception e ) { throw new Kettle XML Exception ( STR_ , e ) ; } }
@ Suppress Warnings ( STR_ ) public final int compare To ( E o ) { Enum < ? > other = ( Enum < ? > ) o ; Enum < E > self = this ; if ( self . get Class ( ) != other . get Class ( ) && self . get Declaring Class ( ) != other . get Declaring Class ( ) ) throw new Class Cast Exception ( ) ; return self . ordinal - other . ordinal ; }
private static Node locate Attr Parent ( Element elem , Node attr ) { Node parent = null ; Attr check = elem . get Attribute Node ( attr . get Node Name ( ) ) ; if ( check == attr ) parent = elem ; if ( null == parent ) { for ( Node node = elem . get First Child ( ) ; null != node ; node = node . get Next Sibling ( ) ) { if ( Node . ELEMENT NODE == node . get Node Type ( ) ) { parent = locate Attr Parent ( ( Element ) node , attr ) ; if ( null != parent ) break ; } } } return parent ; }
public int check Action Access ( int client Id , int doc Type Id , String [ ] options , int max Index ) { if ( max Index <= NUM_ ) return max Index ; final Vector < String > valid Options = new Vector < String > ( ) ; final List < Object > params = new Array List < Object > ( ) ; params . add ( client Id ) ; params . add ( doc Type Id ) ; final String Buffer sql values = new String Buffer ( ) ; for ( int i = NUM_ ; i < max Index ; i ++ ) { if ( sql values . length ( ) > NUM_ ) sql values . append ( STR_ ) ; sql values . append ( STR_ ) ; params . add ( options [ i ] ) ; } final String sql = STR_ + STR_ + STR_ + STR_ + sql values + STR_ + STR_ + get Included Roles Where Clause ( STR_ , params ) ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; DB . set Parameters ( pstmt , params ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { String op = rs . get String ( NUM_ ) ; valid Options . add ( op ) ; } valid Options . to Array ( options ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } int new Max Index = valid Options . size ( ) ; return new Max Index ; }
@ Non Null public static Animator create Circular Reveal ( @ Non Null View root View , @ Id Res int start View Id , @ Non Null Interpolator interpolator ) { final View start View = root View . find View By Id ( start View Id ) ; return create Circular Reveal ( start View , root View , interpolator ) ; }
public void load Latest Entries In Category ( ) { load Categories ( ) ; if ( categories . contains ( category ) ) { entries For Page = ( search String != null ? retrieve Search Results In Category ( ) : retrieve Latest Entries In Category ( ) ) ; } else { category = null ; } }
@ Override public int hash Code ( ) { int hash = NUM_ ; hash = NUM_ * hash + Objects . hash Code ( this . name ) ; hash = NUM_ * hash + Objects . hash Code ( this . description ) ; return hash ; }
protected Secret Key generate Secret Key ( String algorithm , int key Strength ) throws Encryption Exception { try { Key Generator keygen = Key Generator . get Instance ( algorithm ) ; if ( key Strength != NUM_ ) { keygen . init ( key Strength ) ; } return keygen . generate Key ( ) ; } catch ( No Such Algorithm Exception ne ) { throw new Encryption Exception ( ne ) ; } }
public void write Data ( Object entity , Entity Type entity Type ) throws XML Stream Exception , O Data Render Exception { xml Writer . write Start Element ( ODATA CONTENT ) ; xml Writer . write Attribute ( TYPE , XML . to String ( ) ) ; xml Writer . write Start Element ( METADATA , ODATA PROPERTIES , STR_ ) ; marshall ( entity , entity Type ) ; xml Writer . write End Element ( ) ; xml Writer . write End Element ( ) ; }
private void create Element ( Document doc , Element parent Element , String element Name , Font value ) { Element element = doc . create Element ( element Name ) ; element . set Attribute ( FONT SIZE , Integer . to String ( value . get Size ( ) ) ) ; element . set Attribute ( FONT STYLE , Integer . to String ( value . get Style ( ) ) ) ; element . append Child ( doc . create Text Node ( value . get Name ( ) ) ) ; parent Element . append Child ( element ) ; }
@ Override public void draw ( final Count Down Latch latch ) { if ( ! initialized ) { return ; } if ( is Showing ( ) ) { canvas Renderer . draw ( ) ; } if ( latch != null ) { latch . count Down ( ) ; } }
public static String pad Or Trim ( String str , int num ) { if ( str == null ) str = STR_ ; int leng = str . length ( ) ; if ( leng < num ) { String Builder sb = new String Builder ( str ) ; for ( int i = NUM_ ; i < num - leng ; i ++ ) { sb . append ( STR_ ) ; } return sb . to String ( ) ; } else if ( leng > num ) { return str . substring ( NUM_ , num ) ; } else { return str ; } }
protected void decrypt Final ( ) throws IO Exception { in Buffer . flip ( ) ; out Buffer . clear ( ) ; try { cipher . do Final ( in Buffer , out Buffer ) ; final Done = true ; } catch ( Short Buffer Exception e ) { throw new IO Exception ( e ) ; } catch ( Illegal Block Size Exception e ) { throw new IO Exception ( e ) ; } catch ( Bad Padding Exception e ) { throw new IO Exception ( e ) ; } in Buffer . clear ( ) ; out Buffer . flip ( ) ; }
public static double calc Projected Euclidean Distance ( Coord coord , Coord other ) { double x Diff = other . get X ( ) - coord . get X ( ) ; double y Diff = other . get Y ( ) - coord . get Y ( ) ; return Math . sqrt ( ( x Diff * x Diff ) + ( y Diff * y Diff ) ) ; }
public I Multimedia Streaming Session initiate Streaming Session ( String service Id , Contact Id contact ) throws Remote Exception { return initiate Streaming Session 2 ( service Id , contact , Data Format . ENCODING ) ; }
public String consume Boolean Attribute ( String name , boolean default Value ) throws Unable To Complete Exception { return consume Attribute With Default ( name , Boolean . to String ( default Value ) , get Boolean Type ( ) ) ; }
public Fb Exception Builder message Parameter ( int parameter ) { return message Parameter ( Integer . to String ( parameter ) ) ; }
public void array Length ( ) { mv . visit Insn ( Opcodes . ARRAYLENGTH ) ; }
protected void draw Domain Markers ( Graphics 2 D g 2 , Rectangle 2 D data Area , int index , Layer layer ) { Category Item Renderer r = get Renderer ( index ) ; if ( r == null ) { return ; } Collection markers = get Domain Markers ( index , layer ) ; Category Axis axis = get Domain Axis For Dataset ( index ) ; if ( markers != null && axis != null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . has Next ( ) ) { Category Marker marker = ( Category Marker ) iterator . next ( ) ; r . draw Domain Marker ( g 2 , this , axis , marker , data Area ) ; } } }
boolean is Valid Jimple Name ( String prospective Name ) { if ( prospective Name == null ) return false ; for ( int i = NUM_ ; i < prospective Name . length ( ) ; i ++ ) { char c = prospective Name . char At ( i ) ; if ( i == NUM_ && c >= STR_ && c <= STR_ ) return false ; if ( ! ( ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || ( c == STR_ || c == STR_ ) ) ) return false ; } return true ; }
public void generate ( ) { preprocess Classes ( ) ; process Classes ( ) ; process Excludes ( ) ; process Fields ( ) ; process Methods ( ) ; process Metadata ( ) ; process Class Inheritance ( ) ; assemble Class XML ( ) ; assemble Class Package Hierarchy ( ) ; }
protected void fire Vetoable Change ( Property Change Event e ) throws java . beans . Property Veto Exception { m vetoable Change Support . fire Vetoable Change ( e ) ; }
@ Override public void print Message User Data ( I Structured Output Writer out , String msg Id ) throws Exception { final Msg Data data = m msg Data . get ( msg Id ) ; if ( data == null ) { out . simple Child ( STR_ , NUM_ ) ; return ; } out . simple Child ( STR_ , data . m interval All Count ) ; out . simple Child ( STR_ , data . m all Count ) ; out . simple Child ( STR_ , data . m interval Count ) ; out . simple Child ( STR_ , data . m total Log Counts ) ; if ( data . m total Log Counts > NUM_ ) { out . simple Child ( STR_ , data . m lambda ) ; out . simple Child ( STR_ , calc Threshold ( NUM_ , data . m lambda ) ) ; out . simple Child ( STR_ , calc Threshold ( NUM_ , data . m lambda ) ) ; } }
public static void remove Analysis Cache For Current Thread ( ) { analysis Cache Thread Local . remove ( ) ; }
Node < V > find ( int h , int k ) { Node < V > e = this ; do { if ( ( e . key == k ) ) { return e ; } } while ( ( e = e . next ) != null ) ; return null ; }
public double linear Azimuth ( Location location ) { if ( location == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STR_ , STR_ , STR_ ) ) ; } double lat 1 = Math . to Radians ( this . latitude ) ; double lon 1 = Math . to Radians ( this . longitude ) ; double lat 2 = Math . to Radians ( location . latitude ) ; double lon 2 = Math . to Radians ( location . longitude ) ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) { return NUM_ ; } double d Lon = lon 2 - lon 1 ; double d Phi = lat 2 - lat 1 ; if ( Math . abs ( d Lon ) > Math . PI ) { d Lon = d Lon > NUM_ ? - ( NUM_ * Math . PI - d Lon ) : ( NUM_ * Math . PI + d Lon ) ; } double azimuth Radians = Math . atan 2 ( d Lon , d Phi ) ; return Double . is Na N ( azimuth Radians ) ? NUM_ : Math . to Degrees ( azimuth Radians ) ; }
final boolean try Read Lock ( ) { Thread current = Thread . current Thread ( ) ; for ( ; ; ) { int c = get State ( ) ; if ( exclusive Count ( c ) != NUM_ && get Exclusive Owner Thread ( ) != current ) return false ; int r = shared Count ( c ) ; if ( r == MAX COUNT ) throw new Error ( STR_ ) ; if ( compare And Set State ( c , c + SHARED UNIT ) ) { if ( r == NUM_ ) { first Reader = current ; first Reader Hold Count = NUM_ ; } else if ( first Reader == current ) { first Reader Hold Count ++ ; } else { Hold Counter rh = cached Hold Counter ; if ( rh == null || rh . tid != get Thread Id ( current ) ) cached Hold Counter = rh = read Holds . get ( ) ; else if ( rh . count == NUM_ ) read Holds . set ( rh ) ; rh . count ++ ; } return true ; } } }
default < T > T new Instance ( Class < T > concrete Class ) { try { return concrete Class . new Instance ( ) ; } catch ( Exception ex ) { throw new Unchecked Exception ( ex ) ; } }
private static Image create Blank Thumbnail ( final int w , final int h ) { final Canvas canvas = new Canvas ( w , h ) ; final Graphics Context gc = canvas . get Graphics Context 2 D ( ) ; gc . set Fill ( Color . WHITE ) ; gc . fill Rect ( NUM_ , NUM_ , w - NUM_ , h - NUM_ ) ; gc . set Fill ( Color . BLACK ) ; gc . stroke Rect ( NUM_ , NUM_ , w - NUM_ , h - NUM_ ) ; gc . stroke Line ( NUM_ , NUM_ , w , h ) ; gc . stroke Line ( NUM_ , h , w , NUM_ ) ; return canvas . snapshot ( null , null ) ; }
protected J Button make Ok Button ( ) { return make Ok Button ( STR_ ) ; }
public boolean close Note ( Note bug ) { if ( ! bug . is New ( ) ) { Log . d ( DEBUG TAG , STR_ + bug . get Id ( ) ) ; Http URL Connection connection = null ; try { try { URL close Note Url = get Close Note Url ( Long . to String ( bug . get Id ( ) ) ) ; connection = open Connection For Write Access ( close Note Url , STR_ , STR_ ) ; if ( connection . get Response Code ( ) != Http URL Connection . HTTP OK ) { throw Unexpected Request Exception ( connection ) ; } parse Bug ( bug , connection . get Input Stream ( ) ) ; return true ; } catch ( Xml Pull Parser Exception e ) { Log . e ( DEBUG TAG , STR_ , e ) ; } catch ( IO Exception e ) { Log . e ( DEBUG TAG , STR_ , e ) ; } } finally { disconnect ( connection ) ; } } return false ; }
@ Override public void post Invalidate On Animation ( ) { if ( m Pending Invalidation ) return ; long next Draw Time = m Last Draw Time Ms + MIN MS PER FRAME ; long delay = Math . max ( NUM_ , next Draw Time - System . current Time Millis ( ) ) ; m Pending Invalidation = true ; post On Animation Delayed ( m Invalidation Runnable , delay ) ; }
protected void shuffle Messages ( List < Message > messages ) { if ( messages . size ( ) <= NUM_ ) { return ; } Random rng = new Random ( Sim Clock . get Int Time ( ) ) ; Collections . shuffle ( messages , rng ) ; }
private static final char [ ] grow Buffer ( char [ ] dest , int index , int size ) { char [ ] copy = new char [ size ] ; if ( index > NUM_ ) { System . arraycopy ( dest , NUM_ , copy , NUM_ , index ) ; } return copy ; }
public static boolean is W Reply URL Valid ( Http Servlet Request request , String relay State ) { String meta Alias = WS Federation Meta Utils . get Meta Alias By Uri ( request . get Request URI ( ) ) ; try { WS Federation Meta Manager meta Manager = new WS Federation Meta Manager ( ) ; return is W Reply URL Valid ( meta Alias , relay State , meta Manager . get Role By Meta Alias ( meta Alias ) ) ; } catch ( WS Federation Meta Exception e ) { debug . warning ( STR_ , e ) ; return false ; } }
public void check Messages ( XML File messages Doc ) throws Document Exception { for ( Iterator < Node > i = messages Doc . xpath Iterator ( STR_ ) ; i . has Next ( ) ; ) { Node node = i . next ( ) ; messages Doc . check Attribute ( node , STR_ ) ; messages Doc . check Element ( node , STR_ ) ; } for ( Iterator < Node > i = messages Doc . xpath Iterator ( STR_ ) ; i . has Next ( ) ; ) { Node node = i . next ( ) ; messages Doc . check Attribute ( node , STR_ ) ; messages Doc . check Element ( node , STR_ ) ; messages Doc . check Element ( node , STR_ ) ; messages Doc . check Element ( node , STR_ ) ; } for ( Iterator < Node > i = messages Doc . xpath Iterator ( STR_ ) ; i . has Next ( ) ; ) { Node node = i . next ( ) ; messages Doc . check Attribute ( node , STR_ ) ; messages Doc . check Non Empty Text ( node ) ; } Set < String > described Detectors Set = messages Doc . collect Attributes ( STR_ , STR_ ) ; check Described ( STR_ , messages Doc , declared Detectors Set , described Detectors Set ) ; Set < String > described Abbrevs Set = messages Doc . collect Attributes ( STR_ , STR_ ) ; check Described ( STR_ , messages Doc , declared Abbrevs Set , described Abbrevs Set ) ; }
public Object internal Put ( String key , Object value ) { return context . put ( key , value ) ; }
@ React Method public void r Delete All ( Callback error Callback , Callback success Callback ) { try { Array List < Integer > ids = m Notification Manager . get I Ds ( ) ; for ( Integer id : ids ) { try { m Notification Manager . delete ( id ) ; } catch ( Exception e ) { Log . e ( STR_ , STR_ + Log . get Stack Trace String ( e ) ) ; } } success Callback . invoke ( ) ; } catch ( Exception e ) { error Callback . invoke ( e . get Message ( ) ) ; Log . e ( STR_ , STR_ + Log . get Stack Trace String ( e ) ) ; } }
public static double poisson ( double k , double x , boolean cum ) { if ( ( x < NUM_ ) || ( k < NUM_ ) ) { throw new Arithmetic Exception ( STR_ ) ; } k = k + NUM_ ; if ( cum ) { return ( NUM_ - igamma ( k , x ) ) ; } else { return ( ( Math . exp ( - x ) * Math . pow ( x , k ) ) / gamma ( k ) ) ; } }
private int encrypt Block ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STR_ ) ; } if ( ( out Off + block Size ) > out . length ) { throw new Data Length Exception ( STR_ ) ; } if ( count > block Size ) { FR [ block Size - NUM_ ] = out [ out Off ] = encrypt Byte ( in [ in Off ] , block Size - NUM_ ) ; FR [ block Size - NUM_ ] = out [ out Off + NUM_ ] = encrypt Byte ( in [ in Off + NUM_ ] , block Size - NUM_ ) ; cipher . process Block ( FR , NUM_ , FRE , NUM_ ) ; for ( int n = NUM_ ; n < block Size ; n ++ ) { FR [ n - NUM_ ] = out [ out Off + n ] = encrypt Byte ( in [ in Off + n ] , n - NUM_ ) ; } } else if ( count == NUM_ ) { cipher . process Block ( FR , NUM_ , FRE , NUM_ ) ; for ( int n = NUM_ ; n < block Size ; n ++ ) { FR [ n ] = out [ out Off + n ] = encrypt Byte ( in [ in Off + n ] , n ) ; } count += block Size ; } else if ( count == block Size ) { cipher . process Block ( FR , NUM_ , FRE , NUM_ ) ; out [ out Off ] = encrypt Byte ( in [ in Off ] , NUM_ ) ; out [ out Off + NUM_ ] = encrypt Byte ( in [ in Off + NUM_ ] , NUM_ ) ; System . arraycopy ( FR , NUM_ , FR , NUM_ , block Size - NUM_ ) ; System . arraycopy ( out , out Off , FR , block Size - NUM_ , NUM_ ) ; cipher . process Block ( FR , NUM_ , FRE , NUM_ ) ; for ( int n = NUM_ ; n < block Size ; n ++ ) { FR [ n - NUM_ ] = out [ out Off + n ] = encrypt Byte ( in [ in Off + n ] , n - NUM_ ) ; } count += block Size ; } return block Size ; }
private void initialize Font Metrics ( Font font ) { final Buffered Image temporary Image = new Buffered Image ( NUM_ , NUM_ , Buffered Image . TYPE INT RGB ) ; Graphics 2 D temporary Graphics 2 D = ( Graphics 2 D ) temporary Image . get Graphics ( ) ; temporary Graphics 2 D . set Font ( font ) ; font Metrics = temporary Graphics 2 D . get Font Metrics ( ) ; font Char Width = font Metrics . get Max Advance ( ) ; font Line Height = font Metrics . get Height ( ) ; }
static public String normalize WWN ( String wwn ) { String result = wwn ; if ( wwn != null && ! wwn . is Empty ( ) ) { result = wwn . replace All ( STR_ , STR_ ) ; result = result . to Upper Case ( ) ; } return result ; }
private Properties remove Redundant Properties ( Properties props ) { if ( props == null ) { return null ; } Properties cloned Props = ( Properties ) props . clone ( ) ; cloned Props . remove ( X Path Properties . CONTAINER JNDI URL ) ; return cloned Props ; }
public Runnable increment As Runnable ( ) { return m Increment Runnable ; }
void update Cache ( String org ) throws Config Manager Exception { Set e Names = new Hash Set ( ) ; Set s Names = new Hash Set ( ) ; Set c Names = new Hash Set ( ) ; if ( org . equals ( root DN ) ) { Set o Set = new Hash Set ( ) ; o Set . add ( OBJECTRESOLVERPATH ) ; load Cache ( org , o Set , OBJECTRESOLVER ) ; } try { e Names = get Service Components ( org , ENTITYPATH , true ) ; } catch ( SMS Exception smse ) { if ( debug . warning Enabled ( ) ) debug . warning ( STR_ + smse . to String ( ) ) ; } catch ( SSO Exception ssoe ) { if ( debug . warning Enabled ( ) ) debug . warning ( STR_ + ssoe . to String ( ) ) ; } try { s Names = get Service Components ( org , SEARCHPATH , true ) ; } catch ( SMS Exception smse ) { if ( debug . warning Enabled ( ) ) debug . warning ( STR_ + smse . to String ( ) ) ; } catch ( SSO Exception ssoe ) { if ( debug . warning Enabled ( ) ) debug . warning ( STR_ + ssoe . to String ( ) ) ; } try { c Names = get Service Components ( org , CREATIONPATH , true ) ; } catch ( SMS Exception smse ) { if ( debug . warning Enabled ( ) ) debug . warning ( STR_ + smse . to String ( ) ) ; } catch ( SSO Exception ssoe ) { if ( debug . warning Enabled ( ) ) debug . warning ( STR_ + ssoe . to String ( ) ) ; } if ( c Names . is Empty ( ) && e Names . is Empty ( ) && s Names . is Empty ( ) ) { check List Cache . put ( org . to Lower Case ( ) , STR_ ) ; return ; } if ( ! s Names . is Empty ( ) ) { Iterator it = s Names . iterator ( ) ; Set set = new Hash Set ( ) ; while ( it . has Next ( ) ) { String s = new String ( ) ; String t ; t = ( String ) it . next ( ) ; int count = t . last Index Of ( STR_ ) ; s = t . substring ( count + NUM_ ) ; set . add ( s ) ; } cch . put ( org + STR_ + SEARCH + STR_ , set ) ; if ( debug . message Enabled ( ) ) debug . message ( STR_ + org + STR_ + SEARCH + STR_ + set ) ; } if ( ! c Names . is Empty ( ) ) { Iterator it = c Names . iterator ( ) ; Set set = new Hash Set ( ) ; while ( it . has Next ( ) ) { String s = new String ( ) ; String t ; t = ( String ) it . next ( ) ; int count = t . last Index Of ( STR_ ) ; s = t . substring ( count + NUM_ ) ; set . add ( s ) ; } cch . put ( org + STR_ + CREATION + STR_ , set ) ; if ( debug . message Enabled ( ) ) debug . message ( STR_ + org + STR_ + CREATION + STR_ + set ) ; } load Cache ( org , e Names , ENTITY ) ; load Cache ( org , c Names , CREATION ) ; load Cache ( org , s Names , SEARCH ) ; check List Cache . put ( org . to Lower Case ( ) , STR_ ) ; }
@ Not Null static String format Message ( @ Not Null String format , @ Not Null String msg ) { if ( format . is Empty ( ) ) { return msg ; } Log Cat Message message = parse Message ( msg ) ; return format Message ( format , message . get Header ( ) , message . get Message ( ) ) ; }
public String html popup ( String short txt , String popup txt , String popup title ) { String popup = String . format ( STR_ , popup Id , popup title , popup txt ) ; String txt = String . format ( STR_ , popup Id ++ , short txt ) ; return txt + STR_ + popup ; }
public void add Data Set Colors ( Array List < Integer > colors ) { m Data Set Colors . add ( colors ) ; m Color Count += colors . size ( ) ; }
private String crawl Code ( String content ) { String result = STR_ ; String result Span = STR_ ; String result Paragraph = STR_ ; String result Div = STR_ ; result Span = get Tag Content ( STR_ , content ) ; result Paragraph = get Tag Content ( STR_ , content ) ; result Div = get Tag Content ( STR_ , content ) ; result = result Span ; if ( result Paragraph . length ( ) > result Span . length ( ) && result Paragraph . length ( ) >= result Div . length ( ) ) result = result Paragraph ; else if ( result Paragraph . length ( ) > result Span . length ( ) && result Paragraph . length ( ) < result Div . length ( ) ) result = result Div ; else result = result Paragraph ; return html Decode ( result ) ; }
@ Override protected void prepare Block ( ) { double [ ] frame = get Next Frame ( ) ; if ( frame == null ) return ; int frame Length = frame Provider . get Frame Length Samples ( ) ; if ( processor != null ) processor . apply Inline ( frame , NUM_ , frame Length ) ; if ( output Window != null ) output Window . apply Inline ( frame , NUM_ , frame Length ) ; if ( memory . length < frame Length ) { double [ ] old Memory = memory ; memory = new double [ frame Length ] ; System . arraycopy ( old Memory , NUM_ , memory , NUM_ , old Memory . length ) ; } for ( int i = NUM_ ; i < frame Length ; i ++ ) { memory [ i ] += frame [ i ] ; } }
public void handle Notification ( Notification notification , Object handback ) { Map event = ( Map ) handback ; if ( event != null ) { Object del = event . get ( STR_ ) ; Object callback = event . get ( STR_ ) ; if ( callback != null && callback instanceof Closure ) { Closure closure = ( Closure ) callback ; closure . set Delegate ( del ) ; if ( closure . get Maximum Number Of Parameters ( ) == NUM_ ) closure . call ( build Operation Notification Packet ( notification ) ) ; else closure . call ( ) ; } } }
public static final boolean is Logging Behavior Enabled ( Logging Behavior behavior ) { synchronized ( logging Behaviors ) { return Build Config . DEBUG && logging Behaviors . contains ( behavior ) ; } }
public void append To Nal Unit ( byte [ ] data , int offset , int limit ) { if ( ! is Filling ) { return ; } int read Length = limit - offset ; if ( ifr Data . length < ifr Length + read Length ) { ifr Data = Arrays . copy Of ( ifr Data , ( ifr Length + read Length ) * NUM_ ) ; } System . arraycopy ( data , offset , ifr Data , ifr Length , read Length ) ; ifr Length += read Length ; scratch Slice Type . reset ( ifr Data , ifr Length ) ; scratch Slice Type . skip Bits ( NUM_ ) ; int len = scratch Slice Type . peek Exp Golomb Coded Num Length ( ) ; if ( ( len == - NUM_ ) || ( len > scratch Slice Type . bits Left ( ) ) ) { return ; } scratch Slice Type . skip Bits ( len ) ; len = scratch Slice Type . peek Exp Golomb Coded Num Length ( ) ; if ( ( len == - NUM_ ) || ( len > scratch Slice Type . bits Left ( ) ) ) { return ; } slice Type = scratch Slice Type . read Unsigned Exp Golomb Coded Int ( ) ; is Filling = false ; }
private Class read Primitive ( String target ) throws Exception { if ( target . equals ( BYTE ) ) { return byte . class ; } if ( target . equals ( SHORT ) ) { return short . class ; } if ( target . equals ( INTEGER ) ) { return int . class ; } if ( target . equals ( LONG ) ) { return long . class ; } if ( target . equals ( CHARACTER ) ) { return char . class ; } if ( target . equals ( FLOAT ) ) { return float . class ; } if ( target . equals ( DOUBLE ) ) { return double . class ; } if ( target . equals ( BOOLEAN ) ) { return boolean . class ; } if ( target . equals ( VOID ) ) { return void . class ; } return null ; }
public void processed ( String source Id , String target Id , boolean link Existed , String link Id , boolean link Created , Situation situation , Recon Action action ) { String id ; if ( phase == Phase . SOURCE ) { id = source Id ; } else { id = target Id ; } parent Stat . processed ( source Id , target Id , link Existed , link Id , link Created , situation , action ) ; if ( id != null ) { processed Entries . increment And Get ( ) ; if ( situation != null ) { List < String > situation Ids = ids . get ( situation ) ; if ( situation Ids != null ) { situation Ids . add ( id ) ; } } } }
public static void add ( final Runnable task ) { if ( ! cb . add ( task ) ) { task . run ( ) ; } }
public Object read ( String value ) throws Exception { char [ ] list = value . to Char Array ( ) ; int length = list . length ; if ( entry == char . class ) { return list ; } return read ( list , length ) ; }
protected void populate Client ( String client Name , Properties props ) throws Invalid Properties Format Exception { String name = props . get Property ( client Name + NAME SUFFIX ) ; String attr List = props . get Property ( client Name + ATTRIBUTE SUFFIX ) ; String Tokenizer st = new String Tokenizer ( attr List , COMMA ) ; Map attributes = new Hash Map ( ) ; Set attribute Values = null ; while ( st . has More Tokens ( ) ) { attribute Values = new Hash Set ( ) ; String entry = st . next Token ( ) ; String attr Name = entry . substring ( NUM_ , entry . index Of ( EQUALS ) ) ; String attr Value = entry . substring ( entry . index Of ( EQUALS ) + NUM_ ) ; attribute Values . add ( attr Value ) ; attributes . put ( attr Name , attribute Values ) ; } clients . put ( name , new Client ( name , attributes ) ) ; clients Data . put ( name , attributes ) ; }
public void update PDP Descriptor ( String realm , String entity Name , Map attr Values ) throws AM Console Exception { String [ ] params = { realm , entity Name , STR_ , STR_ } ; log Event ( STR_ , params ) ; try { SAML 2 Meta Manager saml 2 Manager = get SAML 2 Meta Manager ( ) ; Entity Descriptor Element entity Descriptor = saml 2 Manager . get Entity Descriptor ( realm , entity Name ) ; XACMLPDP Descriptor Element pdp Descriptor = saml 2 Manager . get Policy Decision Point Descriptor ( realm , entity Name ) ; if ( pdp Descriptor != null ) { List authz Service List = pdp Descriptor . get XACML Authz Service ( ) ; if ( authz Service List . size ( ) != NUM_ ) { XACML Authz Service Element authz Service = ( XACML Authz Service Element ) authz Service List . get ( NUM_ ) ; authz Service . set Location ( ( String ) AM Admin Utils . get Value ( ( Set ) attr Values . get ( ATTR XACML AUTHZ SERVICE LOCATION ) ) ) ; } } saml 2 Manager . set Entity Descriptor ( realm , entity Descriptor ) ; log Event ( STR_ , params ) ; } catch ( SAML 2 Meta Exception e ) { String str Error = get Error String ( e ) ; String [ ] params Ex = { realm , entity Name , STR_ , STR_ , str Error } ; log Event ( STR_ , params Ex ) ; throw new AM Console Exception ( str Error ) ; } }
protected void initialize Property Change Listener ( Property Change Listener pcl ) { Timer Status running Status = timer . is Running ( ) ? ( get Clock Direction ( ) > NUM_ ? Timer Status . FORWARD : Timer Status . BACKWARD ) : Timer Status . STOPPED ; fire Property Change ( TIMER STATUS , null , running Status ) ; fire Clock Update ( running Status ) ; }
public static int rebuild SMS Index ( ) throws Exception { return rebuild Index ( AM Setup Servlet . get Base Dir ( ) , SMS Entry . get Root Suffix ( ) ) ; }
public List < Modifier > new Modifiers ( int flags ) { if ( this . api Level == AST . JLS 2 ) { unsupported In 2 ( ) ; } List < Modifier > result = new Array List < Modifier > ( NUM_ ) ; if ( Modifier . is Public ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . PUBLIC KEYWORD ) ) ; } if ( Modifier . is Protected ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . PROTECTED KEYWORD ) ) ; } if ( Modifier . is Private ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . PRIVATE KEYWORD ) ) ; } if ( Modifier . is Abstract ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . ABSTRACT KEYWORD ) ) ; } if ( Modifier . is Static ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . STATIC KEYWORD ) ) ; } if ( Modifier . is Final ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . FINAL KEYWORD ) ) ; } if ( Modifier . is Synchronized ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . SYNCHRONIZED KEYWORD ) ) ; } if ( Modifier . is Native ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . NATIVE KEYWORD ) ) ; } if ( Modifier . is Strictfp ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . STRICTFP KEYWORD ) ) ; } if ( Modifier . is Transient ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . TRANSIENT KEYWORD ) ) ; } if ( Modifier . is Volatile ( flags ) ) { result . add ( new Modifier ( Modifier . Modifier Keyword . VOLATILE KEYWORD ) ) ; } return result ; }
public void calculate scores ( ) { score = NUM_ ; if ( contents . length == NUM_ ) { API api = API . v ( ) ; Set < Info Kind > source = api . get Source Info Kinds ( method ) ; Set < Info Kind > sink = api . get Sink Info Kinds ( method ) ; if ( is system ( method ) ) { if ( api . is Safe Method ( method ) ) score = NUM_ ; else if ( api . is Spec Method ( method ) ) score = NUM_ ; else if ( api . is Banned Method ( method ) ) score = NUM_ ; if ( ! source . is Empty ( ) ) score += NUM_ ; else if ( ! sink . is Empty ( ) ) score += NUM_ ; } return ; } for ( Source Call Chain Info cci : contents ) { cci . calculate scores ( ) ; calls += cci . calls ; syscalls += cci . syscalls ; if ( cci . score > score ) score = cci . score ; } }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; if ( resource Bundle Name != null ) { try { rb = Resource Bundle . get Bundle ( resource Bundle Name ) ; } catch ( Missing Resource Exception e ) { rb = null ; } } }
public String extract Password ( Authenticator a , String secret ) throws IO Exception { final int val Len = ( ( super . get Octets ( ) [ NUM_ ] ) & NUM_ ) - NUM_ ; final byte [ ] cipher Text = new byte [ val Len ] ; System . arraycopy ( super . get Octets ( ) , NUM_ , cipher Text , NUM_ , val Len ) ; final byte [ ] clear Text = User Password Attribute . convert ( cipher Text , Direction . DECRYPT , secret , a ) ; int i = NUM_ ; for ( ; i < clear Text . length ; i ++ ) { if ( clear Text [ i ] == NUM_ ) { break ; } } return new String ( clear Text , NUM_ , i , Standard Charsets . UTF 8 ) ; }
public boolean check For Dangerous Props ( ) { final Map < String , String > dangerous Props = new Hash Map < String , String > ( ) ; dangerous Props . put ( STR_ , STR_ ) ; dangerous Props . put ( STR_ , STR_ ) ; boolean result = false ; String [ ] lines = props Reader ( ) ; for ( String line : lines ) { for ( String key : dangerous Props . key Set ( ) ) { if ( line . contains ( key ) ) { String bad Value = dangerous Props . get ( key ) ; bad Value = STR_ + bad Value + STR_ ; if ( line . contains ( bad Value ) ) { Q Log . v ( key + STR_ + bad Value + STR_ ) ; result = true ; } } } } return result ; }
public String create Message ( Sso Exception e ) { return create Message ( e . get Message Key ( ) , e . get Message Details ( ) , e . get Message ( ) ) ; }
synchronized Set < Long > key Set ( ) { Hash Set < Long > set = new Hash Set < Long > ( ) ; for ( Entry < V > e = stack . stack Next ; e != stack ; e = e . stack Next ) { set . add ( e . key ) ; } for ( Entry < V > e = queue . queue Next ; e != queue ; e = e . queue Next ) { set . add ( e . key ) ; } return set ; }
public Network Interface ( Settings s ) { this . interfacetype = s . get Name Space ( ) ; this . connections = new Array List < Connection > ( ) ; this . transmit Range = s . get Double ( TRANSMIT RANGE S ) ; this . transmit Speed = s . get Int ( TRANSMIT SPEED S ) ; ensure Positive Value ( transmit Range , TRANSMIT RANGE S ) ; ensure Positive Value ( transmit Speed , TRANSMIT SPEED S ) ; }
public void save Position ( ) { Record Id rid 1 = s 1 . get Record Id ( ) ; Record Id rid 2 = ( s 2 == null ) ? null : s 2 . get Record Id ( ) ; saved Position = Arrays . as List ( rid 1 , rid 2 ) ; }
protected boolean identity Equals ( Identity identity ) { if ( ! name . equals Ignore Case ( identity . name ) ) return false ; if ( ( public Key == null ) ^ ( identity . public Key == null ) ) return false ; if ( public Key != null && identity . public Key != null ) if ( ! public Key . equals ( identity . public Key ) ) return false ; return true ; }
public void add Listener ( Tap Listener listener ) { if ( ! m Listeners . contains ( listener ) ) { m Listeners . add ( listener ) ; } }
public double empirical HSIC ( Tetrad Matrix Ky , Tetrad Matrix Kx , int m ) { Tetrad Matrix Kyx = Ky . times ( Kx ) ; double emp HSIC = NUM_ ; for ( int i = NUM_ ; i < m ; i ++ ) { emp HSIC += Kyx . get ( i , i ) ; } emp HSIC /= Math . pow ( m - NUM_ , NUM_ ) ; return emp HSIC ; }
public void shut Down ( ) throws Interrupted Exception { wexec . await Termination ( timeout , Time Unit . MILLISECONDS ) ; }
private String next Thread Name ( ) { Class < ? > cls = get Class ( ) ; int new Thread Id ; Atomic Integer thread Id = thread Ids . put If Absent ( cls , new Atomic Integer ( NUM_ ) ) ; if ( thread Id == null ) { new Thread Id = NUM_ ; } else { new Thread Id = thread Id . increment And Get ( ) ; } return cls . get Simple Name ( ) + STR_ + new Thread Id ; }
@ Override protected void delete Last ( final byte [ ] key ) { final Lock lock = write Lock ( ) ; lock . lock ( ) ; try { super . delete Last ( key ) ; } finally { unlock ( lock ) ; } }
public static Cert Chain Key Pair generate Signed For Client ( String fqdn , X 509 Certificate issuer Certificate , Private Key issuer Private Key ) { try { return generate Certificate And Sign ( fqdn , issuer Certificate , issuer Private Key , get Client Extensions ( ) ) ; } catch ( Cert IO Exception | Certificate Exception | Operator Creation Exception e ) { throw new Runtime Exception ( String . format ( STR_ , e . get Message ( ) ) , e ) ; } }
public static boolean can Access System Clipboard ( ) { boolean can Access = false ; if ( ! Graphics Environment . is Headless ( ) ) { Security Manager sm = System . get Security Manager ( ) ; if ( sm == null ) { can Access = true ; } else { try { sm . check Permission ( Security Constants . AWT . ACCESS CLIPBOARD PERMISSION ) ; can Access = true ; } catch ( Security Exception e ) { } if ( can Access && ! is Trusted Context ( ) ) { can Access = can Current Event Access System Clipboard ( true ) ; } } } return can Access ; }
public void start ( long doc Id ) { reader = new Reader ( server UUID , event Bus , doc Id ) ; reader Thread = new Thread ( reader ) ; reader Thread . start ( ) ; }
private static double log ( final double x , final double [ ] hi Prec ) { if ( x == NUM_ ) { return Double . NEGATIVE INFINITY ; } long bits = Double . double To Raw Long Bits ( x ) ; if ( ( ( bits & NUM_ ) != NUM_ || Double . is Na N ( x ) ) && x != NUM_ ) { if ( hi Prec != null ) { hi Prec [ NUM_ ] = Double . Na N ; } return Double . Na N ; } if ( x == Double . POSITIVE INFINITY ) { if ( hi Prec != null ) { hi Prec [ NUM_ ] = Double . POSITIVE INFINITY ; } return Double . POSITIVE INFINITY ; } int exp = ( int ) ( bits > > NUM_ ) - NUM_ ; if ( ( bits & NUM_ ) == NUM_ ) { if ( x == NUM_ ) { if ( hi Prec != null ) { hi Prec [ NUM_ ] = Double . NEGATIVE INFINITY ; } return Double . NEGATIVE INFINITY ; } bits <<= NUM_ ; while ( ( bits & NUM_ ) == NUM_ ) { -- exp ; bits <<= NUM_ ; } } if ( ( exp == - NUM_ || exp == NUM_ ) && x < NUM_ && x > NUM_ && hi Prec == null ) { double xa = x - NUM_ ; double xb = xa - x + NUM_ ; double tmp = xa * HEX 40000000 ; double aa = xa + tmp - tmp ; double ab = xa - aa ; xa = aa ; xb = ab ; final double [ ] ln Coef last = LN QUICK COEF [ LN QUICK COEF . length - NUM_ ] ; double ya = ln Coef last [ NUM_ ] ; double yb = ln Coef last [ NUM_ ] ; for ( int i = LN QUICK COEF . length - NUM_ ; i >= NUM_ ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX 40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; final double [ ] ln Coef i = LN QUICK COEF [ i ] ; aa = ya + ln Coef i [ NUM_ ] ; ab = yb + ln Coef i [ NUM_ ] ; tmp = aa * HEX 40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX 40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; return ya + yb ; } final double [ ] lnm = ln Mant . LN MANT [ ( int ) ( ( bits & NUM_ ) > > NUM_ ) ] ; final double epsilon = ( bits & NUM_ ) / ( TWO POWER 52 + ( bits & NUM_ ) ) ; double lnza = NUM_ ; double lnzb = NUM_ ; if ( hi Prec != null ) { double tmp = epsilon * HEX 40000000 ; double aa = epsilon + tmp - tmp ; double ab = epsilon - aa ; double xa = aa ; double xb = ab ; final double numer = bits & NUM_ ; final double denom = TWO POWER 52 + ( bits & NUM_ ) ; aa = numer - xa * denom - xb * denom ; xb += aa / denom ; final double [ ] ln Coef last = LN HI PREC COEF [ LN HI PREC COEF . length - NUM_ ] ; double ya = ln Coef last [ NUM_ ] ; double yb = ln Coef last [ NUM_ ] ; for ( int i = LN HI PREC COEF . length - NUM_ ; i >= NUM_ ; i -- ) { aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; tmp = aa * HEX 40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; final double [ ] ln Coef i = LN HI PREC COEF [ i ] ; aa = ya + ln Coef i [ NUM_ ] ; ab = yb + ln Coef i [ NUM_ ] ; tmp = aa * HEX 40000000 ; ya = aa + tmp - tmp ; yb = aa - ya + ab ; } aa = ya * xa ; ab = ya * xb + yb * xa + yb * xb ; lnza = aa + ab ; lnzb = - ( lnza - aa - ab ) ; } else { lnza = - NUM_ ; lnza = lnza * epsilon + NUM_ ; lnza = lnza * epsilon + - NUM_ ; lnza = lnza * epsilon + NUM_ ; lnza = lnza * epsilon + - NUM_ ; lnza = lnza * epsilon + NUM_ ; lnza *= epsilon ; } double a = LN 2 A * exp ; double b = NUM_ ; double c = a + lnm [ NUM_ ] ; double d = - ( c - a - lnm [ NUM_ ] ) ; a = c ; b += d ; c = a + lnza ; d = - ( c - a - lnza ) ; a = c ; b += d ; c = a + LN 2 B * exp ; d = - ( c - a - LN 2 B * exp ) ; a = c ; b += d ; c = a + lnm [ NUM_ ] ; d = - ( c - a - lnm [ NUM_ ] ) ; a = c ; b += d ; c = a + lnzb ; d = - ( c - a - lnzb ) ; a = c ; b += d ; if ( hi Prec != null ) { hi Prec [ NUM_ ] = a ; hi Prec [ NUM_ ] = b ; } return a + b ; }
public long kstkesp ( ) { return Long . parse Long ( fields [ NUM_ ] ) ; }
private void commit Discard ( long time , boolean allow Discard ) { if ( m Discarding Tab == null ) return ; assert m Stack Tabs != null ; Stack Tab discarded = m Discarding Tab ; if ( Math . abs ( discarded . get Discard Amount ( ) ) / get Discard Range ( ) > DISCARD COMMIT THRESHOLD && allow Discard ) { m Layout . ui Requesting Close Tab ( time , discarded . get Id ( ) ) ; Record User Action . record ( STR_ ) ; Record User Action . record ( STR_ ) ; } else { start Animation ( time , Overview Animation Type . UNDISCARD ) ; } m Discarding Tab = null ; request Update ( ) ; }
public static void close Quietly ( Connection con ) { if ( con == null ) { return ; } try { con . close ( ) ; } catch ( SQL Exception ex ) { } }
@ React Method public void r Get I Ds ( Callback error Callback , Callback success Callback ) { try { Array List < Integer > ids = m Notification Manager . get I Ds ( ) ; Writable Array rids = new Writable Native Array ( ) ; for ( Integer id : ids ) { rids . push Int ( id ) ; } success Callback . invoke ( ( Readable Array ) rids ) ; } catch ( Exception e ) { error Callback . invoke ( e . get Message ( ) ) ; Log . e ( STR_ , STR_ + Log . get Stack Trace String ( e ) ) ; } }
private static int parse File For Value ( String text To Match , File Input Stream stream ) { byte [ ] buffer = new byte [ NUM_ ] ; try { int length = stream . read ( buffer ) ; for ( int i = NUM_ ; i < length ; i ++ ) { if ( buffer [ i ] == STR_ || i == NUM_ ) { if ( buffer [ i ] == STR_ ) i ++ ; for ( int j = i ; j < length ; j ++ ) { int text Index = j - i ; if ( buffer [ j ] != text To Match . char At ( text Index ) ) { break ; } if ( text Index == text To Match . length ( ) - NUM_ ) { return extract Value ( buffer , j ) ; } } } } } catch ( IO Exception e ) { } catch ( Number Format Exception e ) { } return DEVICEINFO UNKNOWN ; }
boolean clear Addr Map ( final long addr , final int latched Addr ) throws Illegal State Exception , Interrupted Exception { final Byte Buffer tmp = acquire ( ) ; try { if ( m closed For Writes ) { return false ; } final Record Metadata removed = record Map . remove ( addr ) ; if ( removed == null ) { throw new Assertion Error ( ) ; } removed . deleted = true ; if ( ! prefix Writes ) { m removed += removed . record Length ; return true ; } final int addr offset = removed . buffer Offset - SIZEOF PREFIX WRITE METADATA ; tmp . put Long ( addr offset , - removed . file Offset ) ; if ( m written && record Map . is Empty ( ) ) { m written = false ; } m removed += removed . record Length ; return true ; } finally { release ( ) ; } }
private int [ ] [ ] mm Chain DP ( double [ ] dim Array , int size ) { double [ ] [ ] dp Matrix = new double [ size ] [ size ] ; int [ ] [ ] split = new int [ size ] [ size ] ; for ( int i = NUM_ ; i < size ; i ++ ) { Arrays . fill ( dp Matrix [ i ] , NUM_ ) ; Arrays . fill ( split [ i ] , - NUM_ ) ; } for ( int l = NUM_ ; l <= size ; l ++ ) { for ( int i = NUM_ ; i < size - l + NUM_ ; i ++ ) { int j = i + l - NUM_ ; dp Matrix [ i ] [ j ] = Double . MAX VALUE ; for ( int k = i ; k <= j - NUM_ ; k ++ ) { double cost = dp Matrix [ i ] [ k ] + dp Matrix [ k + NUM_ ] [ j ] + ( dim Array [ i ] * dim Array [ k + NUM_ ] * dim Array [ j + NUM_ ] ) ; if ( cost < dp Matrix [ i ] [ j ] ) { dp Matrix [ i ] [ j ] = cost ; split [ i ] [ j ] = k ; } } if ( LOG . is Trace Enabled ( ) ) { LOG . trace ( STR_ + ( i + NUM_ ) + STR_ + ( j + NUM_ ) + STR_ + dp Matrix [ i ] [ j ] + STR_ + ( split [ i ] [ j ] + NUM_ ) ) ; } } } return split ; }
public static Transaction round Trip Transaction ( Network Parameters params , Transaction tx ) { try { Message Serializer bs = params . get Default Serializer ( ) ; Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; bs . serialize ( tx , bos ) ; return ( Transaction ) bs . deserialize ( Byte Buffer . wrap ( bos . to Byte Array ( ) ) ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } }
private void append Integer Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
private void validate Min Paths ( Storage System system , Export Path Params path Params , Map < Initiator , List < Storage Port > > existing Assignments , Map < Initiator , List < Storage Port > > assignments , List < Initiator > new Initiators ) { Map < URI , Set < Initiator > > existing Initiators Map = generate Network To Initiators Map ( existing Assignments , db Client ) ; Map < Initiator , List < Storage Port > > all Assignments = new Hash Map < Initiator , List < Storage Port > > ( ) ; all Assignments . put All ( existing Assignments ) ; all Assignments . put All ( assignments ) ; Collection < Initiator > all Initiators = new Hash Set < Initiator > ( new Initiators ) ; for ( Set < Initiator > existing Initiators : existing Initiators Map . values ( ) ) { all Initiators . add All ( existing Initiators ) ; } Map < URI , List < Initiator > > host Initiators Map = Default Storage Ports Assigner . make Host Initiators Map ( all Initiators ) ; validate Min Paths ( path Params , host Initiators Map , all Assignments ) ; if ( need To Validate HA ( system ) ) { validate HA Capabilities ( path Params , all Assignments ) ; } }
public boolean equals ( Object obj ) { if ( obj == null || ( ! ( obj instanceof Timestamp ) ) ) { return false ; } Timestamp that = ( Timestamp ) obj ; if ( this == that ) { return true ; } return ( timestamp . equals ( that . get Timestamp ( ) ) && signer Cert Path . equals ( that . get Signer Cert Path ( ) ) ) ; }
public static void reinitiate ( ) { CLIENT INSTANCE = new Frequency Grid ( ) ; SERVER INSTANCE = new Frequency Grid ( ) ; }
public static String format Big Decimal ( Big Decimal v , Locale locale ) { Number Format number Format = Number Format . get Instance ( locale ) ; int scale = NUM_ ; if ( v . int Value ( ) >= NUM_ ) { scale = NUM_ ; } return number Format . format ( v . set Scale ( scale , Rounding Mode . UP ) ) ; }
char [ ] trim Aspect Bits ( ) { try { return Arrays . copy Of ( aspect Bits , bit Num ) ; } catch ( Exception ex ) { log . error ( STR_ ) ; return null ; } }
@ Override public Iterator < Instruction > iterator ( ) { return m instructions . iterator ( ) ; }
public static boolean check AL Error ( String msg ) { msg = msg . trim ( ) ; if ( msg . length ( ) > NUM_ ) { msg = msg + STR_ ; } switch ( al . al Get Error ( ) ) { case AL . AL NO ERROR : return false ; case AL . AL INVALID NAME : log . warn ( msg + STR_ ) ; return true ; case AL . AL INVALID ENUM : log . warn ( msg + STR_ ) ; return true ; case AL . AL INVALID VALUE : log . warn ( msg + STR_ ) ; return true ; case AL . AL INVALID OPERATION : log . warn ( msg + STR_ ) ; return true ; case AL . AL OUT OF MEMORY : log . warn ( msg + STR_ ) ; return true ; default : log . warn ( msg + STR_ ) ; return true ; } }
@ Override public boolean accepts ( Field field ) { return field . is Annotation Present ( Current Frame . class ) ; }
private byte [ ] create Entry Bytes ( Object [ ] values ) throws IO Exception { if ( values == null ) { return null ; } if ( entry Buffer == null ) { entry Buffer = new Byte Stream ( ) ; } entry Buffer . reset ( ) ; for ( Column Descriptor col : columns ) { Object value = values [ col . get Column Index ( ) ] ; if ( Column Impl . is Raw Data ( value ) ) { continue ; } if ( value == MIN VALUE ) { entry Buffer . write ( get Null Entry Flag ( col . is Ascending ( ) ) ) ; continue ; } if ( value == MAX VALUE ) { entry Buffer . write ( get Null Entry Flag ( ! col . is Ascending ( ) ) ) ; continue ; } col . write Value ( value , entry Buffer ) ; } return entry Buffer . to Byte Array ( ) ; }
public void fwd Dct Nx M ( int [ ] [ ] pixels , double [ ] [ ] dcts ) { int x = NUM_ ; int y = NUM_ ; int i = NUM_ ; int j = NUM_ ; double t = NUM_ ; double cx 0 = Math . sqrt ( NUM_ / this . N ) ; double cy 0 = Math . sqrt ( NUM_ / this . M ) ; for ( x = NUM_ ; x < this . N ; x ++ ) { for ( y = NUM_ ; y < this . M ; y ++ ) { t += ( pixels [ x ] [ y ] - NUM_ ) ; } } dcts [ NUM_ ] [ NUM_ ] = cx 0 * cy 0 * t ; for ( i = NUM_ ; i < this . N ; i ++ ) { t = NUM_ ; for ( x = NUM_ ; x < this . N ; x ++ ) { for ( y = NUM_ ; y < this . M ; y ++ ) { t += ( pixels [ x ] [ y ] - NUM_ ) * this . nxm Cos Table X [ x ] [ i ] ; } } dcts [ i ] [ NUM_ ] = cy 0 * t ; } for ( j = NUM_ ; j < this . M ; j ++ ) { t = NUM_ ; for ( x = NUM_ ; x < this . N ; x ++ ) { for ( y = NUM_ ; y < this . M ; y ++ ) { t += ( pixels [ x ] [ y ] - NUM_ ) * this . nxm Cos Table Y [ y ] [ j ] ; } } dcts [ NUM_ ] [ j ] = cx 0 * t ; } for ( i = NUM_ ; i < this . N ; i ++ ) { for ( j = NUM_ ; j < this . M ; j ++ ) { t = NUM_ ; for ( x = NUM_ ; x < this . N ; x ++ ) { for ( y = NUM_ ; y < this . M ; y ++ ) { t += ( pixels [ x ] [ y ] - NUM_ ) * this . nxm Cos Table X [ x ] [ i ] * this . nxm Cos Table Y [ y ] [ j ] ; } } dcts [ i ] [ j ] = t ; } } }
private String create Workflow Step For Detach Native Full Copy ( Workflow workflow , Storage System native System , List < URI > native Full Copy UR Is , String wait For , Workflow . Method rollback Method ) { URI native System URI = native System . get Id ( ) ; Workflow . Method detach Full Copy Method = new Workflow . Method ( DETACH FC METHOD NAME , native System URI , native Full Copy UR Is ) ; workflow . create Step ( DETACH FULL COPY STEP , String . format ( STR_ , native Full Copy UR Is ) , wait For , native System URI , native System . get System Type ( ) , Block Device Controller . class , detach Full Copy Method , rollback Method , null ) ; log . info ( STR_ , native Full Copy UR Is ) ; return DETACH FULL COPY STEP ; }
public void handle Exception ( Parse Exception ex , SIP Message sip Message , Class hdr Class , String header , String message ) throws Parse Exception { if ( logger . is Logging Enabled ( ) ) logger . log Exception ( ex ) ; if ( ( hdr Class != null ) && ( hdr Class . equals ( From . class ) || hdr Class . equals ( To . class ) || hdr Class . equals ( C Seq . class ) || hdr Class . equals ( Via . class ) || hdr Class . equals ( Call ID . class ) || hdr Class . equals ( Content Length . class ) || hdr Class . equals ( Request Line . class ) || hdr Class . equals ( Status Line . class ) ) ) { if ( logger . is Logging Enabled ( Log Writer . TRACE DEBUG ) ) { logger . log Debug ( STR_ + sip Message . to String ( ) ) ; } String msg String = sip Message . to String ( ) ; if ( ! msg String . starts With ( STR_ ) && ! msg String . starts With ( STR_ ) ) { if ( socket Channel != null ) { if ( logger . is Logging Enabled ( Log Writer . TRACE ERROR ) ) { logger . log Error ( STR_ + socket Channel . to String ( ) ) ; } try { socket Channel . close ( ) ; } catch ( IO Exception ie ) { if ( logger . is Logging Enabled ( Log Writer . TRACE ERROR ) ) { logger . log Error ( STR_ + socket Channel . to String ( ) + STR_ + ie . to String ( ) ) ; } } } } throw ex ; } else { sip Message . add Unparsed ( header ) ; } }
public static Intent Filter make Get Intent Filter ( ) { return new Intent Filter ( ACTION GET ) ; }
private void initialize Scheme ( String p uri Spec ) throws Malformed URI Exception { int uri Spec Len = p uri Spec . length ( ) ; int index = NUM_ ; String scheme = null ; char test Char = STR_ ; while ( index < uri Spec Len ) { test Char = p uri Spec . char At ( index ) ; if ( test Char == STR_ || test Char == STR_ || test Char == STR_ || test Char == STR_ ) { break ; } index ++ ; } scheme = p uri Spec . substring ( NUM_ , index ) ; if ( scheme . length ( ) == NUM_ ) { throw new Malformed URI Exception ( STR_ ) ; } else { set Scheme ( scheme ) ; } }
@ Suppress Warnings ( STR_ ) public static < T extends Packet > void register Out Listener ( final Class < T > type , Player player , Predicate < T > listener ) { Network Manager Wrapper wrapper = wrap Network Manager ( player ) ; wrapper . register Outgoing Listener ( type , listener ) ; }
void close ( Client Socket stream ) { if ( log . is Loggable ( Level . FINER ) ) log . finer ( STR_ + stream ) ; active Count . decrement And Get ( ) ; }
public Closure Stats assert All ( final Temp Triple Store temp Store ) { return assert All ( temp Store , null ) ; }
public void update Button Action Performed ( ) { node Type = node Type Box . get Selected Index ( ) ; log . debug ( STR_ + cur Node . get Node Type ( ) + STR_ + node Type ) ; if ( cur Node . get Node Type ( ) != node Type ) { cur Node . set Node Type ( node Type ) ; } set Node Parameters ( ) ; changed Node = true ; edit Mode = false ; cur Node = null ; add Button . set Visible ( true ) ; edit Button . set Visible ( true ) ; delete Button . set Visible ( true ) ; done Button . set Visible ( true ) ; update Button . set Visible ( false ) ; cancel Button . set Visible ( false ) ; node Addr Field . set Visible ( true ) ; node Addr Static . set Visible ( false ) ; status Text 2 . set Text ( std Status 2 ) ; status Text 3 . set Text ( std Status 3 ) ; status Text 1 . set Text ( rb . get String ( STR_ ) + STR_ + Integer . to String ( node Address ) ) ; error In Status 1 = true ; }
private double [ ] prepare Extended Batch ( Example Set extended Batch ) { int [ ] class Count = new int [ NUM_ ] ; Iterator < Example > reader = extended Batch . iterator ( ) ; while ( reader . has Next ( ) ) { Example example = reader . next ( ) ; example . set Weight ( NUM_ ) ; class Count [ ( int ) example . get Label ( ) ] ++ ; } double [ ] class Priors = new double [ NUM_ ] ; int sum = class Count [ NUM_ ] + class Count [ NUM_ ] ; class Priors [ NUM_ ] = ( double ) class Count [ NUM_ ] / sum ; class Priors [ NUM_ ] = ( double ) class Count [ NUM_ ] / sum ; return class Priors ; }
private int position ( boolean inject ) { int pos Inc = accum Pos Inc ; if ( has Output Token ) { accum Pos Inc = NUM_ ; return inject ? NUM_ : Math . max ( NUM_ , pos Inc ) ; } has Output Token = true ; if ( ! has Output Following Original ) { has Output Following Original = true ; return NUM_ ; } accum Pos Inc = NUM_ ; return Math . max ( NUM_ , pos Inc ) ; }
private float limit Min ( float color Component ) { return Math . max ( NUM_ , color Component ) ; }
@ Override public void populate Frame ( Audio a ) { if ( ! ( a instanceof Audio Buffer ) ) { throw new Illegal Argument Exception ( a . get System Name ( ) + STR_ ) ; } super . populate Frame ( a ) ; Audio Buffer b = ( Audio Buffer ) a ; url . set Text ( b . get URL ( ) ) ; stream . set Selected ( b . is Streamed ( ) ) ; stream . set Enabled ( false ) ; loop Start . set Value ( b . get Start Loop Point ( ) ) ; loop End . set Value ( b . get End Loop Point ( ) ) ; loop Start . set Enabled ( true ) ; loop Start Label . set Enabled ( true ) ; loop End . set Enabled ( true ) ; loop End Label . set Enabled ( true ) ; this . new Buffer = false ; }
public void init Dct 8 x 8 ( ) { int i = NUM_ ; int j = NUM_ ; double sq Jpeg = Math . sqrt ( NJPEG ) ; double sq Jpeg 2 = Math . sqrt ( NUM_ / NJPEG ) ; for ( j = NUM_ ; j < NJPEG ; j ++ ) { this . C [ NUM_ ] [ j ] = NUM_ / sq Jpeg ; this . Ct [ j ] [ NUM_ ] = this . C [ NUM_ ] [ j ] ; } for ( i = NUM_ ; i < NJPEG ; i ++ ) { for ( j = NUM_ ; j < NJPEG ; j ++ ) { this . C [ i ] [ j ] = sq Jpeg 2 * Math . cos ( Math . PI * ( NUM_ * j + NUM_ ) * i / ( NUM_ * NJPEG ) ) ; this . Ct [ j ] [ i ] = this . C [ i ] [ j ] ; } } }
@ Override protected synchronized Class < ? > load Class ( String name , boolean resolve ) throws Class Not Found Exception { Class c = find Loaded Class ( name ) ; if ( ( c == null ) && ( my Loader != null ) && ( my Loader != target Loader ) ) { try { c = my Loader . load Class ( name ) ; } catch ( Class Not Found Exception ignored ) { if ( LOGGER . is Loggable ( Level . FINEST ) ) { LOGGER . log ( Level . FINEST , STR_ , ignored ) ; } } } if ( c == null ) { c = super . load Class ( name , false ) ; } if ( resolve ) { resolve Class ( c ) ; } return c ; }
public Object put ( String key , Object value ) { final int len = key . length ( ) ; if ( len > m char Buffer . length ) { m char Buffer = new char [ len ] ; } Node node = m Root ; for ( int i = NUM_ ; i < len ; i ++ ) { Node next Node = node . m next Char [ Character . to Lower Case ( key . char At ( i ) ) ] ; if ( next Node != null ) { node = next Node ; } else { for ( ; i < len ; i ++ ) { Node new Node = new Node ( ) ; if ( m lower Case Only ) { node . m next Char [ Character . to Lower Case ( key . char At ( i ) ) ] = new Node ; } else { node . m next Char [ Character . to Upper Case ( key . char At ( i ) ) ] = new Node ; node . m next Char [ Character . to Lower Case ( key . char At ( i ) ) ] = new Node ; } node = new Node ; } break ; } } Object ret = node . m Value ; node . m Value = value ; return ret ; }
@ Visible For Testing Minidump Upload Callable create Minidump Upload Callable ( File minidump File , File logfile ) { return new Minidump Upload Callable ( minidump File , logfile , get Application Context ( ) ) ; }
@ Override @ Transactional public void logout ( Http Servlet Request request , Http Servlet Response response , Authentication authentication ) { String remember Me Cookie = extract Remember Me Cookie ( request ) ; if ( remember Me Cookie != null && remember Me Cookie . length ( ) != NUM_ ) { try { String [ ] cookie Tokens = decode Cookie ( remember Me Cookie ) ; Persistent Token token = get Persistent Token ( cookie Tokens ) ; persistent Token Repository . delete ( token ) ; } catch ( Invalid Cookie Exception ice ) { log . info ( STR_ ) ; } catch ( Remember Me Authentication Exception rmae ) { log . debug ( STR_ ) ; } } super . logout ( request , response , authentication ) ; }
static void remove Global Metadata For Failed Node ( Node failed Node , String region Identifier , Gem Fire Cache Impl cache ) { remove Global Metadata For Failed Node ( failed Node , region Identifier , cache , true ) ; }
void ref Count Changed ( Long address , boolean dec Ref Count , int rc ) { if ( ! track Reference Counts ( ) ) return ; final Object owner = ref Count Owner . get ( ) ; if ( owner == SKIP REF COUNT TRACKING ) { return ; } List < Ref Count Change Info > list = stacktraces . get ( address ) ; if ( list == null ) { List < Ref Count Change Info > new List = new Array List < Ref Count Change Info > ( ) ; ref Count Changed Test Hook ( address , dec Ref Count , rc ) ; List < Ref Count Change Info > old = stacktraces . put If Absent ( address , new List ) ; if ( old == null ) { list = new List ; } else { list = old ; } } if ( dec Ref Count ) { if ( owner != null ) { synchronized ( list ) { for ( int i = NUM_ ; i < list . size ( ) ; i ++ ) { Ref Count Change Info info = list . get ( i ) ; if ( owner instanceof Region Entry ) { if ( owner == info . get Owner ( ) ) { if ( info . get Use Count ( ) > NUM_ ) { info . dec Use Count ( ) ; } else { list . remove ( i ) ; } return ; } } else if ( owner . equals ( info . get Owner ( ) ) ) { if ( info . get Use Count ( ) > NUM_ ) { info . dec Use Count ( ) ; } else { list . remove ( i ) ; } return ; } } } } } if ( list == LOCKED ) { Memory Allocator Impl . debug Log ( STR_ + ( dec Ref Count ? STR_ : STR_ ) + STR_ + Long . to Hex String ( address ) , true ) ; return ; } Ref Count Change Info info = new Ref Count Change Info ( dec Ref Count , rc , owner ) ; synchronized ( list ) { for ( Ref Count Change Info e : list ) { if ( e . is Same Caller ( info ) ) { e . inc Use Count ( ) ; return ; } } list . add ( info ) ; } }
private void snap ( ) { m Translate Rect . set ( m Temp Src ) ; m Matrix . map Rect ( m Translate Rect ) ; float max Left = m Allow Crop ? m Crop Rect . left : NUM_ ; float max Right = m Allow Crop ? m Crop Rect . right : get Width ( ) ; float l = m Translate Rect . left ; float r = m Translate Rect . right ; final float translate X ; if ( r - l < max Right - max Left ) { translate X = max Left + ( ( max Right - max Left ) - ( r + l ) ) / NUM_ ; } else if ( l > max Left ) { translate X = max Left - l ; } else if ( r < max Right ) { translate X = max Right - r ; } else { translate X = NUM_ ; } float max Top = m Allow Crop ? m Crop Rect . top : NUM_ ; float max Bottom = m Allow Crop ? m Crop Rect . bottom : get Height ( ) ; float t = m Translate Rect . top ; float b = m Translate Rect . bottom ; final float translate Y ; if ( b - t < max Bottom - max Top ) { translate Y = max Top + ( ( max Bottom - max Top ) - ( b + t ) ) / NUM_ ; } else if ( t > max Top ) { translate Y = max Top - t ; } else if ( b < max Bottom ) { translate Y = max Bottom - b ; } else { translate Y = NUM_ ; } if ( Math . abs ( translate X ) > SNAP THRESHOLD || Math . abs ( translate Y ) > SNAP THRESHOLD ) { m Snap Runnable . start ( translate X , translate Y ) ; } else { m Matrix . post Translate ( translate X , translate Y ) ; invalidate ( ) ; } }
public synchronized long recovered Bytes ( ) { long recovered = NUM_ ; for ( File file : file Details . values ( ) ) { recovered += file . recovered ( ) ; } return recovered ; }
private void update Action Status ( final Message message ) { final Action Update Status action Update Status = convert Message ( message , Action Update Status . class ) ; final Action action = check Action Exist ( message , action Update Status ) ; final Action Status action Status = create Action Status ( message , action Update Status , action ) ; update Last Poll Time ( action . get Target ( ) ) ; switch ( action Update Status . get Action Status ( ) ) { case DOWNLOAD : action Status . set Status ( Status . DOWNLOAD ) ; break ; case RETRIEVED : action Status . set Status ( Status . RETRIEVED ) ; break ; case RUNNING : action Status . set Status ( Status . RUNNING ) ; break ; case CANCELED : action Status . set Status ( Status . CANCELED ) ; break ; case FINISHED : action Status . set Status ( Status . FINISHED ) ; break ; case ERROR : action Status . set Status ( Status . ERROR ) ; break ; case WARNING : action Status . set Status ( Status . WARNING ) ; break ; case CANCEL REJECTED : handle Cancel Rejected ( message , action , action Status ) ; break ; default : log And Throw Message Error ( message , STR_ ) ; } final Action add Update Action Status = get Update Action Status ( action Status ) ; if ( ! add Update Action Status . is Active ( ) ) { look If Update Available ( action . get Target ( ) ) ; } }
private int find Word Limit ( int index , Break Iterator words , boolean direction , String s ) { int last = ( direction == NEXT ) ? words . following ( index ) : words . preceding ( index ) ; int current = ( direction == NEXT ) ? words . next ( ) : words . previous ( ) ; while ( current != Break Iterator . DONE ) { for ( int p = Math . min ( last , current ) ; p < Math . max ( last , current ) ; p ++ ) { if ( Character . is Letter ( s . char At ( p ) ) ) { return last ; } } last = current ; current = ( direction == NEXT ) ? words . next ( ) : words . previous ( ) ; } return Break Iterator . DONE ; }
private void dump Complex Type Attribute ( XS Complex Type type ) { Iterator itr ; itr = type . iterate Att Groups ( ) ; while ( itr . has Next ( ) ) { dump Ref ( ( XS Att Group Decl ) itr . next ( ) ) ; } itr = type . iterate Declared Attribute Uses ( ) ; while ( itr . has Next ( ) ) { attribute Use ( ( XS Attribute Use ) itr . next ( ) ) ; } }
public Storage Unit Entity create Database Entities For Business Object Data Ddl Testing ( String partition Value ) { if ( partition Value != null ) { String s 3 Key Prefix = Abstract Service Test . get Expected S 3 Key Prefix ( Abstract Service Test . NAMESPACE , Abstract Service Test . DATA PROVIDER NAME , Abstract Service Test . BDEF NAME , Abstract Service Test . FORMAT USAGE CODE , File Type Entity . TXT FILE TYPE , Abstract Service Test . FORMAT VERSION , Abstract Service Test . FIRST PARTITION COLUMN NAME , partition Value , null , null , Abstract Service Test . DATA VERSION ) ; return create Database Entities For Business Object Data Ddl Testing ( partition Value , s 3 Key Prefix ) ; } else { return create Database Entities For Business Object Data Ddl Testing ( null , null ) ; } }
@ Override public File Visit Result visit File Failed ( T file , IO Exception exc ) throws IO Exception { Objects . require Non Null ( file ) ; throw exc ; }
public boolean check Authentication ( final Http Servlet Request request ) { return DEFAULT CHECKAUTHENTICATION ; }
private static boolean compare Strings ( final String s 1 , final String s 2 ) { if ( s 1 == s 2 ) { return true ; } if ( s 1 == null ) { return false ; } return s 1 . equals ( s 2 ) ; }
public static boolean for Each Child ( Node parent , Node Visitor visitor ) { Compiler Asserts . never Part Of Compilation ( STR_ ) ; Objects . require Non Null ( visitor ) ; Node Class node Class = parent . get Node Class ( ) ; for ( Object field : node Class . get Node Fields ( ) ) { if ( node Class . is Child Field ( field ) ) { Object child = node Class . get Field Object ( field , parent ) ; if ( child != null ) { if ( ! visitor . visit ( ( Node ) child ) ) { return false ; } } } else if ( node Class . is Children Field ( field ) ) { Object array Object = node Class . get Field Object ( field , parent ) ; if ( array Object != null ) { Object [ ] array = ( Object [ ] ) array Object ; for ( int i = NUM_ ; i < array . length ; i ++ ) { Object child = array [ i ] ; if ( child != null ) { if ( ! visitor . visit ( ( Node ) child ) ) { return false ; } } } } } else if ( node Class . node Fields Ordered By Kind ( ) ) { break ; } } return true ; }
private void initialize Partitioned Region ( ) { this . pr Root = Partitioned Region Helper . get PR Root ( get Cache ( ) ) ; }
public void hide Keyboard ( Runnable post Hide Task ) { if ( m Url Bar != null ) m Url Bar . clear Focus ( ) ; boolean was Visible = false ; if ( has Focus ( ) ) { was Visible = Ui Utils . hide Keyboard ( this ) ; } if ( was Visible ) { m Post Hide Keyboard Task = post Hide Task ; } else { post Hide Task . run ( ) ; } }
protected double d Calc ( Continuous Distribution cd ) { double max = NUM_ ; for ( int i = NUM_ ; i < v . length ( ) ; i ++ ) { if ( v . get ( i ) >= cd . min ( ) && v . get ( i ) <= cd . max ( ) ) { double tmp = ( i + NUM_ ) / v . length ( ) - cd . cdf ( v . get ( i ) ) ; max = Math . max ( max , Math . abs ( tmp ) ) ; } else { max = Math . max ( max , Math . abs ( ( i + NUM_ ) / v . length ( ) ) ) ; } } return max ; }
@ Override public Index Input open Input ( String name , IO Context context ) throws IO Exception { ensure Open ( ) ; ensure Can Read ( name ) ; Path path = directory . resolve ( name ) ; try ( File Channel c = File Channel . open ( path , Standard Open Option . READ ) ) { final String resource Description = STR_ + path . to String ( ) + STR_ ; final boolean use Unmap = get Use Unmap ( ) ; return Byte Buffer Index Input . new Instance ( resource Description , map ( resource Description , c , NUM_ , c . size ( ) ) , c . size ( ) , chunk Size Power , new Byte Buffer Guard ( resource Description , use Unmap ? CLEANER : null ) ) ; } }
public static boolean is Add To Home Intent Supported ( Context context ) { Package Manager pm = context . get Package Manager ( ) ; Intent i = new Intent ( INSTALL SHORTCUT ) ; List < Resolve Info > receivers = pm . query Broadcast Receivers ( i , Package Manager . GET INTENT FILTERS ) ; return ! receivers . is Empty ( ) ; }
public void add Property Change Listener ( Scene Property Change Listener listener ) { if ( listener != null ) { logger . log ( Level . FINE , STR_ , listener ) ; listeners . add ( listener ) ; } }
public static < ET extends Enum < ET > > Enum Resolver < ET > construct Using To String ( Class < ET > enum Cls ) { ET [ ] enum Values = enum Cls . get Enum Constants ( ) ; Hash Map < String , ET > map = new Hash Map < String , ET > ( ) ; for ( int i = enum Values . length ; -- i >= NUM_ ; ) { ET e = enum Values [ i ] ; map . put ( e . to String ( ) , e ) ; } return new Enum Resolver < ET > ( enum Cls , enum Values , map ) ; }
public String write ( Class target ) throws Exception { return target . get Name ( ) ; }
public void add Listener ( @ Not Null Cloud Breakpoint Listener listener ) { breakpoint List Changed Listeners . add ( listener ) ; }
protected void parse DOM Attributes ( Element element ) throws SAML 2 Exception { super . parse DOM Attributes ( element ) ; session Index = element . get Attribute ( SAML 2 Constants . SESSION INDEX ) ; }
public Shell Minimum Size Enforcer ( final Shell shell , final int minimum Width , final int minimum Height ) { this . shell = shell ; this . minimum Width = minimum Width ; this . minimum Height = minimum Height ; current Location = shell . get Location ( ) ; if ( ( FORCE LEGACY BEHAVIOR || ! attempt Set Minimum Size ( ) ) && ! Window System . is Current Window System ( Window System . X WINDOW SYSTEM ) ) { final Min Size Listener listener = new Min Size Listener ( ) ; shell . add Control Listener ( listener ) ; } }
public Query Results Printer ( String ... queries To Print ) { for ( String s : queries To Print ) { output Ids . add ( Byte String . copy From Utf 8 ( s ) ) ; } }
public static void register Converter ( Java Type Converter the Converter ) { Class < ? > target Type = the Converter . get Target Type ( ) ; Class < ? > source Type = the Converter . get Source Type ( ) ; Hashtable < Class < ? > , Java Type Converter > inner Table = m converters . get ( target Type ) ; if ( inner Table != null ) { inner Table . put ( source Type , the Converter ) ; } else { inner Table = new Hashtable < Class < ? > , Java Type Converter > ( NUM_ ) ; inner Table . put ( source Type , the Converter ) ; m converters . put ( target Type , inner Table ) ; } }
private static Data Set load G ( Reader reader , double sparse Ratio , int vector Length , boolean classification ) throws IO Exception { String Builder process Buffer = new String Builder ( NUM_ ) ; String Builder char Buffer = new String Builder ( NUM_ ) ; char [ ] buffer = new char [ NUM_ ] ; List < Sparse Vector > sparce Vecs = new Array List < Sparse Vector > ( ) ; List < Double > label Vals = new Double List ( ) ; Map < Double , Integer > possible Cats = new Hash Map < Double , Integer > ( ) ; int max Len = NUM_ ; STATE state = STATE . INITIAL ; int position = NUM_ ; Sparse Vector temp Vec = new Sparse Vector ( NUM_ , NUM_ ) ; int index Processing = - NUM_ ; while ( true ) { while ( char Buffer . length ( ) - position <= NUM_ ) { char Buffer . delete ( NUM_ , position ) ; position = NUM_ ; int read = reader . read ( buffer ) ; if ( read < NUM_ ) break ; char Buffer . append ( buffer , NUM_ , read ) ; } if ( char Buffer . length ( ) - position == NUM_ ) { if ( state == STATE . LABEL ) { double label = Double . parse Double ( process Buffer . to String ( ) ) ; if ( ! possible Cats . contains Key ( label ) && classification ) possible Cats . put ( label , possible Cats . size ( ) ) ; label Vals . add ( label ) ; sparce Vecs . add ( new Sparse Vector ( max Len , NUM_ ) ) ; } else if ( state == STATE . WHITESPACE AFTER LABEL ) { sparce Vecs . add ( new Sparse Vector ( max Len , NUM_ ) ) ; } else if ( state == STATE . FEATURE VALUE || state == STATE . WHITESPACE AFTER FEATURE ) { double value = String Utils . parse Double ( process Buffer , NUM_ , process Buffer . length ( ) ) ; process Buffer . delete ( NUM_ , process Buffer . length ( ) ) ; max Len = Math . max ( max Len , index Processing + NUM_ ) ; temp Vec . set Length ( max Len ) ; if ( value != NUM_ ) temp Vec . set ( index Processing , value ) ; sparce Vecs . add ( temp Vec . clone ( ) ) ; } else if ( state == STATE . NEWLINE ) { break ; } else throw new Runtime Exception ( ) ; break ; } char ch = char Buffer . char At ( position ) ; switch ( state ) { case INITIAL : state = STATE . LABEL ; break ; case LABEL : if ( Character . is Digit ( ch ) || ch == STR_ || ch == STR_ || ch == STR_ || ch == STR_ || ch == STR_ ) { process Buffer . append ( ch ) ; position ++ ; } else if ( Character . is Whitespace ( ch ) ) { double label = Double . parse Double ( process Buffer . to String ( ) ) ; if ( ! possible Cats . contains Key ( label ) && classification ) possible Cats . put ( label , possible Cats . size ( ) ) ; label Vals . add ( label ) ; process Buffer . delete ( NUM_ , process Buffer . length ( ) ) ; if ( ch == STR_ || ch == STR_ ) { temp Vec . zero Out ( ) ; sparce Vecs . add ( new Sparse Vector ( max Len , NUM_ ) ) ; state = STATE . NEWLINE ; } else { temp Vec . zero Out ( ) ; state = STATE . WHITESPACE AFTER LABEL ; } } else throw new Runtime Exception ( STR_ ) ; break ; case WHITESPACE AFTER LABEL : if ( Character . is Digit ( ch ) ) { state = STATE . FEATURE INDEX ; } else if ( Character . is Whitespace ( ch ) ) { if ( ch == STR_ || ch == STR_ ) { temp Vec . zero Out ( ) ; sparce Vecs . add ( new Sparse Vector ( max Len , NUM_ ) ) ; state = STATE . NEWLINE ; } else position ++ ; } else throw new Runtime Exception ( ) ; break ; case FEATURE INDEX : if ( Character . is Digit ( ch ) ) { process Buffer . append ( ch ) ; position ++ ; } else if ( ch == STR_ ) { index Processing = String Utils . parse Int ( process Buffer , NUM_ , process Buffer . length ( ) ) - NUM_ ; process Buffer . delete ( NUM_ , process Buffer . length ( ) ) ; state = STATE . FEATURE VALUE ; position ++ ; } else throw new Runtime Exception ( ) ; break ; case FEATURE VALUE : if ( Character . is Digit ( ch ) || ch == STR_ || ch == STR_ || ch == STR_ || ch == STR_ || ch == STR_ ) { process Buffer . append ( ch ) ; position ++ ; } else { double value = String Utils . parse Double ( process Buffer , NUM_ , process Buffer . length ( ) ) ; process Buffer . delete ( NUM_ , process Buffer . length ( ) ) ; max Len = Math . max ( max Len , index Processing + NUM_ ) ; temp Vec . set Length ( max Len ) ; if ( value != NUM_ ) temp Vec . set ( index Processing , value ) ; if ( Character . is Whitespace ( ch ) ) state = STATE . WHITESPACE AFTER FEATURE ; else throw new Runtime Exception ( ) ; } break ; case WHITESPACE AFTER FEATURE : if ( Character . is Digit ( ch ) ) state = STATE . FEATURE INDEX ; else if ( Character . is Whitespace ( ch ) ) { if ( ch == STR_ || ch == STR_ ) { sparce Vecs . add ( temp Vec . clone ( ) ) ; temp Vec . zero Out ( ) ; state = STATE . NEWLINE ; } else position ++ ; } break ; case NEWLINE : if ( ch == STR_ || ch == STR_ ) position ++ ; else { state = STATE . LABEL ; } break ; } } if ( vector Length > NUM_ ) if ( max Len > vector Length ) throw new Runtime Exception ( STR_ + vector Length + STR_ + max Len ) ; else max Len = vector Length ; if ( classification ) { Categorical Data predicting = new Categorical Data ( possible Cats . size ( ) ) ; List < Double > all Cat Keys = new Double List ( possible Cats . key Set ( ) ) ; Collections . sort ( all Cat Keys ) ; for ( int i = NUM_ ; i < all Cat Keys . size ( ) ; i ++ ) possible Cats . put ( all Cat Keys . get ( i ) , i ) ; Classification Data Set cds = new Classification Data Set ( max Len , new Categorical Data [ NUM_ ] , predicting ) ; for ( int i = NUM_ ; i < label Vals . size ( ) ; i ++ ) { Sparse Vector vec = sparce Vecs . get ( i ) ; vec . set Length ( max Len ) ; cds . add Data Point ( vec , new int [ NUM_ ] , possible Cats . get ( label Vals . get ( i ) ) ) ; } cds . apply Transform ( new Dense Sparce Transform ( sparse Ratio ) ) ; return cds ; } else { Regression Data Set rds = new Regression Data Set ( max Len , new Categorical Data [ NUM_ ] ) ; for ( int i = NUM_ ; i < sparce Vecs . size ( ) ; i ++ ) { Sparse Vector sv = sparce Vecs . get ( i ) ; sv . set Length ( max Len ) ; rds . add Data Point ( sv , new int [ NUM_ ] , label Vals . get ( i ) ) ; } rds . apply Transform ( new Dense Sparce Transform ( sparse Ratio ) ) ; return rds ; } }
public Dimension preferred Layout Size ( Container parent ) { return calculate Layout Size ( parent , STR_ ) ; }
public Parse Query < T > where Matches ( String key , String regex , String modifiers ) { check If Running ( ) ; builder . add Condition ( key , STR_ , regex ) ; if ( modifiers . length ( ) != NUM_ ) { builder . add Condition ( key , STR_ , modifiers ) ; } return this ; }
private void build First Line ( Line Path path , Rect r ) { int [ ] range = new int [ ] { - r . left , - r . top , r . right , r . bottom } ; int max = - NUM_ ; int max Id = NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( range [ i ] > max ) { max = range [ i ] ; max Id = i ; } } switch ( max Id ) { case NUM_ : path . set End Point ( r . left , Utils . next Int ( r . height ( ) ) + r . top ) ; break ; case NUM_ : path . set End Point ( Utils . next Int ( r . width ( ) ) + r . left , r . top ) ; break ; case NUM_ : path . set End Point ( r . right , Utils . next Int ( r . height ( ) ) + r . top ) ; break ; case NUM_ : path . set End Point ( Utils . next Int ( r . width ( ) ) + r . left , r . bottom ) ; break ; } path . line To End ( ) ; }
private Map < String , Set < String > > resolve Search Routing All Indices ( Meta Data meta Data , String routing ) { if ( routing != null ) { Set < String > r = Strings . split String By Comma To Set ( routing ) ; Map < String , Set < String > > routings = new Hash Map ( ) ; String [ ] concrete Indices = meta Data . concrete All Indices ( ) ; for ( String index : concrete Indices ) { routings . put ( index , r ) ; } return routings ; } return null ; }
private int scroll Horizontally Internal ( int dx ) { int child Count = get Child Count ( ) ; if ( child Count == NUM_ ) { return NUM_ ; } int item Count = get Item Count ( ) ; View left View = get Child At ( NUM_ ) ; View right View = get Child At ( child Count - NUM_ ) ; for ( int i = NUM_ ; i < get Child Count ( ) ; i ++ ) { View view = get Child At ( i ) ; if ( get Decorated Left ( left View ) > get Decorated Left ( view ) ) { left View = view ; } if ( get Decorated Right ( right View ) < get Decorated Right ( view ) ) { right View = view ; } } int view Span = get Decorated Right ( right View ) > get Width ( ) ? get Decorated Right ( right View ) : get Width ( ) - ( get Decorated Left ( left View ) < NUM_ ? get Decorated Left ( left View ) : NUM_ ) ; if ( view Span < get Width ( ) ) { return NUM_ ; } int delta = NUM_ ; if ( dx < NUM_ ) { int first View Adapter Pos = get Position ( left View ) ; if ( first View Adapter Pos > NUM_ ) { delta = dx ; } else { int view Left = get Decorated Left ( left View ) - get Width ( ) / NUM_ + get Decorated Measured Width ( left View ) / NUM_ ; delta = Math . max ( view Left , dx ) ; } } else if ( dx > NUM_ ) { int last View Adapter Pos = get Position ( right View ) ; if ( last View Adapter Pos < item Count - NUM_ ) { delta = dx ; } else { int view Right = get Decorated Right ( right View ) + get Width ( ) / NUM_ - get Decorated Measured Width ( right View ) / NUM_ ; int parent Right = get Width ( ) ; delta = Math . min ( view Right - parent Right , dx ) ; } } return delta ; }
public void ignore Unknown Elements ( final String pattern ) { ignore Unknown Elements ( Pattern . compile ( pattern ) ) ; }
public static String pad Or Trim ( String str , int num ) { if ( str == null ) str = STR_ ; int leng = str . length ( ) ; if ( leng < num ) { String Buffer sb = new String Buffer ( str ) ; for ( int i = NUM_ ; i < num - leng ; i ++ ) { sb . append ( STR_ ) ; } return sb . to String ( ) ; } else if ( leng > num ) { return str . substring ( NUM_ , num ) ; } else { return str ; } }
protected void add Component To Side Menu ( Container menu , Component cmp ) { add Component To Side Menu Impl ( menu , cmp ) ; }
public void push Elem Attribute Set ( Elem Attribute Set attr Set ) { m attr Set Stack . push ( attr Set ) ; }
public Process Builder prepare Main Module Resolve Process Builder ( File package Root ) { final Builder < String > builder = Immutable List . < String > builder ( ) ; Node Js Binary node Binary = node Binary Provider . get ( ) ; if ( is Windows ( ) ) { builder . add ( WIN SHELL COMAMNDS ) ; builder . add ( escape Binary Path ( node Binary . get Binary Absolute Path ( ) ) ) ; builder . add ( STR_ ) ; builder . add ( STR_ + package Root . get Name ( ) + STR_ ) ; } else { builder . add ( NIX SHELL COMAMNDS ) ; builder . add ( escape Binary Path ( node Binary . get Binary Absolute Path ( ) ) + STR_ + package Root . get Name ( ) + STR_ ) ; } return create ( builder . build ( ) , node Binary , package Root , false ) ; }
private String handle Zoning Update ( URI export , List < URI > initiators , Map < URI , Integer > block Object Map , Workflow workflow , String wait For , List < Export Mask > export Masks To Create On Device , List < Export Mask > export Masks To Update On Device ) { String zoning Step Id = workflow . create Step Id ( ) ; List < URI > export Mask UR Is = new Array List < URI > ( ) ; for ( Export Mask mask : export Masks To Create On Device ) { export Mask UR Is . add ( mask . get Id ( ) ) ; } for ( Export Mask mask : export Masks To Update On Device ) { export Mask UR Is . add ( mask . get Id ( ) ) ; } List < URI > volume UR Is = new Array List < URI > ( ) ; volume UR Is . add All ( block Object Map . key Set ( ) ) ; Workflow . Method zoning Execute Method = network Device Controller . zone Export Masks Create Method ( export , export Mask UR Is , volume UR Is ) ; Workflow . Method zoning Rollback Method = network Device Controller . zone Rollback Method ( export , zoning Step Id ) ; zoning Step Id = workflow . create Step ( ZONING STEP , String . format ( STR_ , export , initiators . to String ( ) ) , wait For , null URI , STR_ , network Device Controller . get Class ( ) , zoning Execute Method , zoning Rollback Method , zoning Step Id ) ; return zoning Step Id ; }
public Response Entity < List < Review > > default Reviews ( int product Id ) { LOG . warn ( STR_ ) ; return util . create Response ( Arrays . as List ( new Review ( product Id , NUM_ , STR_ , STR_ , STR_ ) ) , Http Status . OK ) ; }
private void init Create Game DB Schema ( ) throws SQL Exception { Result Set rs ; rs = stmt . execute Query ( STR_ ) ; if ( false == rs . next ( ) ) { String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; stmt . execute Update ( sql ) ; } rs = stmt . execute Query ( STR_ ) ; if ( false == rs . next ( ) ) { String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; stmt . execute Update ( sql ) ; } rs = stmt . execute Query ( STR_ ) ; if ( false == rs . next ( ) ) { String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; stmt . execute Update ( sql ) ; } rs = stmt . execute Query ( STR_ ) ; if ( false == rs . next ( ) ) { String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; stmt . execute Update ( sql ) ; } }
private void append Double Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
public void add Map Events Listener ( Map Events Listener listener ) { if ( map Events Listeners == null ) { map Events Listeners = new Array List < Map Events Listener > ( ) ; } map Events Listeners . add ( listener ) ; }
public synchronized boolean contains ( Session Owner owner ) { check Not Null ( owner ) ; return sessions . contains Key ( get Key ( owner ) ) || soft Sessions . contains Key ( owner ) ; }
static public String cdata ( final String s ) { if ( s == null ) throw new Illegal Argument Exception ( ) ; return HTML Utility . escape For XHTML ( s ) ; }
@ HLE Unimplemented @ HLE Function ( nid = NUM_ , version = NUM_ ) public int sce Usb Cam Setup Video ( psp Usb Cam Setup Video Param usb Cam Setup Video Param , T Pointer work Area , int work Area Size ) { this . work Area = work Area . get Address ( ) ; this . work Area Size = work Area Size ; resolution = usb Cam Setup Video Param . resolution ; frame Rate = usb Cam Setup Video Param . framerate ; white Balance = usb Cam Setup Video Param . wb ; saturation = usb Cam Setup Video Param . saturation ; brightness = usb Cam Setup Video Param . brightness ; contrast = usb Cam Setup Video Param . contrast ; sharpness = usb Cam Setup Video Param . sharpness ; image Effect Mode = usb Cam Setup Video Param . effectmode ; frame Size = usb Cam Setup Video Param . framesize ; ev Level = usb Cam Setup Video Param . evlevel ; if ( ! setup Video ( ) ) { log . warn ( String . format ( STR_ ) ) ; return Sce Kernel Errors . ERROR USBCAM NOT READY ; } return NUM_ ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; if ( shared Group Log == null ) { throw new Invalid Object Exception ( STR_ ) ; } if ( host == null ) { throw new Invalid Object Exception ( STR_ ) ; } if ( port <= NUM_ ) { throw new Invalid Object Exception ( STR_ + port ) ; } inner Proxy Preparer = null ; }
public void abort Current Data Transfer ( boolean send Abor Command ) throws IO Exception , FTP Illegal Reply Exception { synchronized ( abort Lock ) { if ( ongoing Data Transfer && ! aborted ) { if ( send Abor Command ) { communication . send FTP Command ( STR_ ) ; touch Auto Noop Timer ( ) ; consume Abor Command Reply = true ; } if ( data Transfer Input Stream != null ) { try { data Transfer Input Stream . close ( ) ; } catch ( Throwable t ) { ; } } if ( data Transfer Output Stream != null ) { try { data Transfer Output Stream . close ( ) ; } catch ( Throwable t ) { ; } } aborted = true ; } } }
public int count Num Elements ( ) { return reg Spill List . size ( ) ; }
private void save Log File ( License license , Properties props ) { File log File = get Log File ( license ) ; logger . fine ( STR_ + props ) ; try { final Output Stream out = new File Output Stream ( log File ) ; try { props . store ( out , String . format ( LOG HEADER , new Date ( ) ) ) ; } finally { out . close ( ) ; } } catch ( IO Exception ex ) { logger . log ( Level . SEVERE , STR_ + log File . get Absolute Path ( ) , ex ) ; } }
private void cut Changes If Necessary ( Document Event event , String Builder old Text ) { if ( my Changes . is Empty ( ) ) { return ; } int start = event . get Offset ( ) ; int end = event . get Offset ( ) + event . get Old Length ( ) ; int diff = event . get New Length ( ) - event . get Old Length ( ) ; int forward Index = find Index ( start ) ; int backward Index Start = forward Index - NUM_ ; if ( forward Index < NUM_ ) { backward Index Start = my Changes . size ( ) - NUM_ ; } else { T Int Array List indices = new T Int Array List ( ) ; for ( ; forward Index < my Changes . size ( ) ; forward Index ++ ) { Text Change Impl change = my Changes . get ( forward Index ) ; if ( change . get Start ( ) >= end ) { change . advance ( diff ) ; } else if ( change . get End ( ) <= end ) { indices . add ( forward Index ) ; int delete Start = start - change . get Start ( ) ; delete Start = Math . max ( NUM_ , delete Start ) ; int delete End = change . get End ( ) - change . get Start ( ) ; delete End = Math . min ( old Text . length ( ) , Math . max ( NUM_ , delete End ) ) ; old Text . delete ( delete Start , delete End ) ; old Text . insert ( NUM_ , change . get Text ( ) ) ; } else { int delete Start = change . get Start ( ) - start ; delete Start = Math . min ( old Text . length ( ) , Math . max ( NUM_ , delete Start ) ) ; int delete End = old Text . length ( ) ; delete End = Math . min ( old Text . length ( ) , Math . max ( NUM_ , delete End ) ) ; old Text . delete ( delete Start , delete End ) ; my Changes . set ( forward Index , new Text Change Impl ( change . get Text ( ) , end + diff , change . get End ( ) + diff ) ) ; } } if ( ! indices . is Empty ( ) ) { for ( int i = indices . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { my Changes . remove ( indices . get ( i ) ) ; } } } for ( int i = Math . min ( backward Index Start , my Changes . size ( ) - NUM_ ) ; i >= NUM_ ; i -- ) { Text Change Impl change = my Changes . get ( i ) ; if ( change . get End ( ) <= start ) { break ; } Char Sequence text To Use = change . get Text ( ) ; int symbols To Cut = Math . min ( change . get End ( ) , end ) - start ; if ( text To Use . length ( ) >= symbols To Cut ) { old Text . insert ( symbols To Cut , text To Use . sub Sequence ( text To Use . length ( ) - symbols To Cut , text To Use . length ( ) ) ) ; text To Use = text To Use . sub Sequence ( NUM_ , text To Use . length ( ) - symbols To Cut ) ; } old Text . delete ( NUM_ , symbols To Cut ) ; my Changes . set ( i , new Text Change Impl ( text To Use , change . get Start ( ) , start ) ) ; if ( change . get End ( ) > end ) { int shift = event . get Offset ( ) + event . get New Length ( ) - end ; Text Change Impl change Tail = new Text Change Impl ( STR_ , end + shift , change . get End ( ) + shift ) ; if ( i >= my Changes . size ( ) - NUM_ ) { my Changes . add ( change Tail ) ; } else { my Changes . add ( i + NUM_ , change Tail ) ; } } } }
public void execute ( Runnable runnable ) { synchronized ( lock ) { pending = runnable ; lock . notify All ( ) ; } }
public void validate Password ( String user Password ) throws User Name Password Validation Exception { AM User Password Validation plugin = get UP Validation Instance ( ) ; try { if ( plugin != null ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ ) ; } plugin . validate Password ( user Password ) ; } else { if ( debug . message Enabled ( ) ) { debug . message ( STR_ ) ; } } } catch ( AM Exception ame ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + ame . get Message ( ) ) ; } throw new User Name Password Validation Exception ( ame ) ; } catch ( Exception ex ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ ) ; } throw new User Name Password Validation Exception ( ex ) ; } }
public Lazy Value < Form > create Back Lazy Value ( final Form f ) { Vector form Navigation Stack = base Form Navigation Stack ; Hashtable p = null ; Command cmd = null ; if ( form Navigation Stack . size ( ) > NUM_ ) { p = ( Hashtable ) form Navigation Stack . element At ( form Navigation Stack . size ( ) - NUM_ ) ; String back Title = get Back Command Text ( ( String ) p . get ( FORM STATE KEY TITLE ) ) ; String command Action = ( String ) p . get ( FORM STATE KEY NAME ) ; cmd = create Command Impl ( back Title , null , BACK COMMAND ID , command Action , true , STR_ ) ; cmd . put Client Property ( COMMAND ARGUMENTS , STR_ ) ; cmd . put Client Property ( COMMAND ACTION , command Action ) ; } return new Lazy Value C ( f , p , cmd , this ) ; }
private Igfs Path igfs Path ( File f ) throws Igfs Exception { String path = f . get Absolute Path ( ) ; if ( work Dir != null ) { if ( ! path . starts With ( work Dir ) ) throw new Igfs Exception ( STR_ + work Dir + STR_ + path + STR_ ) ; path = path . substring ( work Dir . length ( ) , path . length ( ) ) ; } return new Igfs Path ( path ) ; }
public static < C extends Configuration Client , S extends Configuration > Create Sub Command Handler < C , S > create ( Sub Command Argument Parser parser , Managed Object Path < ? , ? > p , Set Relation Definition < C , S > r ) throws Argument Exception { return new Create Sub Command Handler < > ( parser , p , r , null , p . child ( r ) ) ; }
private void process Export Data ( Block Storage Driver driver , com . emc . storageos . db . client . model . Storage System storage System , Map < String , URI > un Managed Volume Native Id To Uri Map , Map < String , URI > managed Volume Native Id To Uri Map , Map < String , List < Host Export Info > > host To Volume Export Info Map , Set < String > invalid Export Hosts , Db Client db Client , Partition Manager partition Manager ) { List < Un Managed Export Mask > un Managed Export Masks To Create = new Array List < > ( ) ; List < Un Managed Export Mask > un Managed Export Masks To Update = new Array List < > ( ) ; Map < URI , Host Export Info > export Infos For Existing Masks = new Hash Map < > ( ) ; List < Host Export Info > export Infos For New Masks = new Array List < > ( ) ; determine Un Managed Export Masks For Export Info ( storage System , host To Volume Export Info Map , invalid Export Hosts , db Client , export Infos For Existing Masks , export Infos For New Masks ) ; log . info ( STR_ , export Infos For New Masks ) ; log . info ( STR_ , export Infos For Existing Masks ) ; if ( ! ( export Infos For New Masks . is Empty ( ) && export Infos For Existing Masks . is Empty ( ) ) ) { process Un Managed Masks For Volumes ( storage System , export Infos For Existing Masks , export Infos For New Masks , un Managed Volume Native Id To Uri Map , managed Volume Native Id To Uri Map , un Managed Export Masks To Update , un Managed Export Masks To Create , db Client ) ; } log . info ( STR_ , un Managed Export Masks To Create ) ; log . info ( STR_ , un Managed Export Masks To Update ) ; if ( ! un Managed Export Masks To Create . is Empty ( ) ) { partition Manager . insert In Batches ( un Managed Export Masks To Create , Constants . DEFAULT PARTITION SIZE , db Client , UNMANAGED EXPORT MASK ) ; } if ( ! un Managed Export Masks To Update . is Empty ( ) ) { partition Manager . update In Batches ( un Managed Export Masks To Update , Constants . DEFAULT PARTITION SIZE , db Client , UNMANAGED EXPORT MASK ) ; } update Un Managed Volumes With Export Data ( un Managed Volume Native Id To Uri Map , un Managed Export Masks To Create , un Managed Export Masks To Update , db Client , partition Manager ) ; un Managed Export Masks To Create . clear ( ) ; un Managed Export Masks To Update . clear ( ) ; }
public void end Element ( String uri , String local Name , String q Name ) throws SAX Exception { try { if ( q Name . equals ( STR_ ) ) { if ( packages . size ( ) > NUM_ ) { writer . new Line ( ) ; writer . write ( STR_ ) ; for ( Iterator iterator = packages . iterator ( ) ; iterator . has Next ( ) ; ) { Package Info info = ( Package Info ) iterator . next ( ) ; writer . new Line ( ) ; writer . write ( STR_ + info . name + STR_ ) ; writer . new Line ( ) ; writer . write ( STR_ + info . description + STR_ ) ; writer . write ( STR_ + info . description + STR_ ) ; writer . new Line ( ) ; writer . write ( STR_ ) ; } writer . new Line ( ) ; writer . write ( STR_ ) ; } } writer . write ( STR_ + q Name + STR_ ) ; } catch ( IO Exception ioe ) { throw new SAX Exception ( ioe ) ; } }
@ Visible For Testing static int calculate Size Shown Next ( List < Double > y Axis Points , double y Min Shown , double y Max Shown ) { if ( y Axis Points . size ( ) < NUM_ ) { return NUM_ ; } double increment = ( y Axis Points . get ( NUM_ ) - y Axis Points . get ( NUM_ ) ) ; int start Index = ( int ) Math . floor ( ( y Min Shown - y Axis Points . get ( NUM_ ) ) / increment + NUM_ ) ; int end Index = ( int ) Math . ceil ( ( y Max Shown - y Axis Points . get ( y Axis Points . size ( ) - NUM_ ) ) / increment ) + y Axis Points . size ( ) - NUM_ ; return end Index - start Index ; }
@ Override public Template Druid Query update Outer Query ( Template Druid Query outer Query , Map < String , String > old Field Name To New Field Name Map ) { Map < String , Aggregation > old Name To New Aggregation Mapping = new Hash Map < > ( ) ; Set < Aggregation > updated Outer Aggs = update Query Aggs ( outer Query . get Aggregations ( ) , old Field Name To New Field Name Map , old Name To New Aggregation Mapping ) ; Set < Post Aggregation > update Outer Post Aggs = new Hash Set < > ( ) ; for ( Post Aggregation post Aggregation : outer Query . get Post Aggregations ( ) ) { update Outer Post Aggs . add ( replace Post Agg With Post Agg From Map ( post Aggregation , old Name To New Aggregation Mapping ) ) ; } return new Template Druid Query ( updated Outer Aggs , update Outer Post Aggs , outer Query . get Inner Query ( ) , outer Query . get Time Grain ( ) ) ; }
public boolean delete Mailbox Dump Request ( String user , String id ) throws Apps For Your Domain Exception , Malformed URL Exception , IO Exception , Service Exception { try { delete ( new URL ( BASE URL + STR_ + domain + STR_ + user + STR_ + id ) ) ; return true ; } catch ( Apps For Your Domain Exception ex ) { if ( ex . get Error Code ( ) == Apps For Your Domain Error Code . Invalid Value ) { LOGGER . log ( Level . INFO , STR_ + STR_ ) ; } } return false ; }
private void update Core Border Objects ( int clusterid ) { int i = cores . length ; cores = Arrays . copy Of ( cores , clusterid ) ; borders = Arrays . copy Of ( borders , clusterid ) ; while ( i < clusterid ) { cores [ i ] = new Core ( i ) ; borders [ i ] = new Border ( cores [ i ] ) ; ++ i ; } }
private File write To File ( final Input Stream uploaded Input Stream , final String file Name ) { final File file = new File ( file Name ) ; try { final Output Stream out = new File Output Stream ( new File ( file Name ) ) ; int read = NUM_ ; final byte [ ] bytes = new byte [ NUM_ ] ; while ( ( read = uploaded Input Stream . read ( bytes ) ) != - NUM_ ) out . write ( bytes , NUM_ , read ) ; out . flush ( ) ; out . close ( ) ; } catch ( final IO Exception e ) { } return file ; }
private void emit Getter ( Method method , String method Name , String field Name , String return Type , String Builder builder ) { builder . append ( STR_ ) ; builder . append ( return Type ) ; builder . append ( STR_ ) ; builder . append ( method Name ) ; builder . append ( STR_ ) ; Class < ? > return Type Class = method . get Return Type ( ) ; if ( is List ( return Type Class ) || is Map ( return Type Class ) ) { builder . append ( STR_ ) ; builder . append ( get Ensure Name ( field Name ) ) ; builder . append ( STR_ ) ; } builder . append ( STR_ ) ; builder . append ( field Name ) ; builder . append ( STR_ ) ; }
protected String recover Quoted Strings ( String ret Value , Vector < String > ret Vars ) { String Buffer sb = new String Buffer ( ) ; for ( int i = NUM_ ; i < ret Vars . size ( ) ; i ++ ) { String replacement = ( String ) ret Vars . get ( i ) ; replacement = escape Quoted String ( replacement ) ; ret Value = ret Value . replace ( STR_ + i + STR_ , replacement ) ; } return ret Value ; }
public void notify Service Destroy ( ) { if ( timer != null ) timer . cancel ( ) ; timer = null ; notify Hardware State Changed ( ) ; service Weak Reference = null ; }
public void append Path List ( String pathlist ) throws Not Found Exception { char sep = File . path Separator Char ; int i = NUM_ ; for ( ; ; ) { int j = pathlist . index Of ( sep , i ) ; if ( j < NUM_ ) { append Class Path ( pathlist . substring ( i ) ) ; break ; } else { append Class Path ( pathlist . substring ( i , j ) ) ; i = j + NUM_ ; } } }
void terminated Request ( Integer index ) { servers Counters . decrement And Get ( index ) ; }
public void use Fuel ( int fuel Used ) { set Fuel ( Math . max ( NUM_ , get Fuel ( ) - fuel Used ) ) ; }
public static Buffered Image create Buffered Image ( int w , int h , Color background ) throws Out Of Memory Error { Buffered Image result = null ; if ( w > NUM_ && h > NUM_ ) { Runtime runtime = Runtime . get Runtime ( ) ; long max Memory = runtime . max Memory ( ) ; long allocated Memory = runtime . total Memory ( ) ; long free Memory = runtime . free Memory ( ) ; long total Free Memory = ( free Memory + ( max Memory - allocated Memory ) ) / NUM_ ; int bytes = NUM_ ; long memory Required = w * h * bytes / NUM_ ; if ( memory Required <= total Free Memory ) { int type = ( background != null ) ? Buffered Image . TYPE INT RGB : Buffered Image . TYPE INT ARGB ; result = new Buffered Image ( w , h , type ) ; if ( background != null ) { Graphics 2 D g 2 = ( Graphics 2 D ) result . create Graphics ( ) ; clear Rect ( g 2 , new Rectangle ( w , h ) , background ) ; g 2 . dispose ( ) ; } } else { throw new Out Of Memory Error ( STR_ + w + STR_ + h + STR_ ) ; } } return result ; }
protected void scan Dir ( File src Dir , File dest Dir , String [ ] files ) { Glob Pattern Mapper m = new Glob Pattern Mapper ( ) ; m . set From ( STR_ ) ; m . set To ( STR_ ) ; Source File Scanner sfs = new Source File Scanner ( this ) ; File [ ] new Files = sfs . restrict As Files ( files , src Dir , dest Dir , m ) ; if ( new Files . length > NUM_ ) { File [ ] new Compile List = new File [ compile List . length + new Files . length ] ; System . arraycopy ( compile List , NUM_ , new Compile List , NUM_ , compile List . length ) ; System . arraycopy ( new Files , NUM_ , new Compile List , compile List . length , new Files . length ) ; compile List = new Compile List ; } }
public boolean validate Mutation Fee ( String assessment No , Big Decimal payment Amount ) { boolean valid Fee = true ; Property Mutation property Mutation = get Latest Property Mutation By Assesment No ( assessment No ) ; if ( property Mutation != null ) { if ( payment Amount . compare To ( property Mutation . get Mutation Fee ( ) ) > NUM_ ) { valid Fee = false ; } } else { valid Fee = false ; } return valid Fee ; }
public Object internal Get ( String key ) { return context . get ( key ) ; }
public Router Activity Logger ( Connection Factory connection Factory , boolean suspend Exception ) { this . connection Factory = connection Factory ; this . suspend Exception = suspend Exception ; Identity Server identity Server = Identity Server . get Instance ( ) ; this . log Full Objects = Boolean . value Of ( identity Server . get Property ( OPENIDM AUDIT LOG FULL OBJECTS , STR_ ) ) ; }
public final int exec ( String command ) throws Exception { final Runtime r = Runtime . get Runtime ( ) ; final Process process = r . exec ( command ) ; return process Output ( process ) ; }
synchronized protected void timeout ( ) { Sprog Version v ; switch ( state ) { case CRSENT : log . debug ( STR_ ) ; state = Query State . IDLE ; v = new Sprog Version ( new Sprog Type ( Sprog Type . TIMEOUT ) ) ; notify Version ( v ) ; break ; case QUERYSENT : log . debug ( STR_ ) ; state = Query State . IDLE ; v = new Sprog Version ( new Sprog Type ( Sprog Type . NOT A SPROG ) ) ; notify Version ( v ) ; break ; case DONE : case IDLE : log . error ( STR_ + state ) ; break ; } }
private State build Patch ( final Task State . Task Stage stage , final Task State . Sub Stage sub Satge , final Throwable e ) { State s = new State ( ) ; s . task Info = new Task State ( ) ; s . task Info . stage = stage ; s . task Info . sub Stage = sub Satge ; if ( e != null ) { s . task Info . failure = Utils . to Service Error Response ( e ) ; } return s ; }
private static Set < Annotation Mirror > find All Supers ( Annotation Mirror anno , Map < Annotation Mirror , Set < Annotation Mirror > > supertypes , Map < Annotation Mirror , Set < Annotation Mirror > > all Supers So Far ) { Set < Annotation Mirror > supers = Annotation Utils . create Annotation Set ( ) ; for ( Annotation Mirror super Anno : supertypes . get ( anno ) ) { supers . add ( super Anno ) ; supers . add All ( find All Supers ( super Anno , supertypes , all Supers So Far ) ) ; } all Supers So Far . put ( anno , Collections . unmodifiable Set ( supers ) ) ; return supers ; }
protected void synch With Target ( Map < String , Monitor > map ) throws Monitor Exception { long time Limit = System . current Time Millis ( ) + sync Wait Ms ; String name = STR_ ; Long Monitor ticks = ( Long Monitor ) poll For ( map , name , time Limit ) ; log ( STR_ + lvmid + STR_ ) ; while ( ticks . long Value ( ) == NUM_ ) { log ( STR_ ) ; try { Thread . sleep ( NUM_ ) ; } catch ( Interrupted Exception e ) { } if ( System . current Time Millis ( ) > time Limit ) { lognl ( STR_ + lvmid ) ; throw new Monitor Exception ( STR_ ) ; } } lognl ( STR_ + lvmid ) ; }
public Array List < Data Holder > read Gallery ( final Gallery Activity activity ) { Array List < Data Holder > list Of All Images = new Array List < > ( ) ; prepare Data For Reading ( ) ; if ( activity . get Type ( ) == Const . Gallery Type . IMAGE || activity . get Type ( ) == Const . Gallery Type . IMAGE VIDEO ) { list Of All Images . add All ( get Images ( ) ) ; } if ( activity . get Type ( ) == Const . Gallery Type . VIDEO || activity . get Type ( ) == Const . Gallery Type . IMAGE VIDEO ) { list Of All Images . add All ( get Videos ( ) ) ; } Collections . sort ( list Of All Images , new Data Holder Comparator ( ) ) ; return list Of All Images ; }
public boolean add Cockpit ( ) { if ( get Empty Criticals ( LOC HEAD ) < NUM_ ) { return false ; } add Critical ( LOC HEAD , NUM_ , new Critical Slot ( Critical Slot . TYPE SYSTEM , SYSTEM LIFE SUPPORT ) ) ; add Critical ( LOC HEAD , NUM_ , new Critical Slot ( Critical Slot . TYPE SYSTEM , SYSTEM SENSORS ) ) ; add Critical ( LOC HEAD , NUM_ , new Critical Slot ( Critical Slot . TYPE SYSTEM , SYSTEM COCKPIT ) ) ; add Critical ( LOC HEAD , NUM_ , new Critical Slot ( Critical Slot . TYPE SYSTEM , SYSTEM SENSORS ) ) ; add Critical ( LOC HEAD , NUM_ , new Critical Slot ( Critical Slot . TYPE SYSTEM , SYSTEM LIFE SUPPORT ) ) ; if ( is Super Heavy ( ) ) { if ( this instanceof Tripod Mech ) { set Cockpit Type ( COCKPIT SUPERHEAVY TRIPOD ) ; } else if ( is Industrial ( ) ) { set Cockpit Type ( COCKPIT SUPERHEAVY INDUSTRIAL ) ; } else { set Cockpit Type ( COCKPIT SUPERHEAVY ) ; } } else if ( this instanceof Tripod Mech ) { set Cockpit Type ( COCKPIT TRIPOD ) ; } else { set Cockpit Type ( COCKPIT STANDARD ) ; } return true ; }
public void blocking Wait ( int duration ) throws Interrupted Exception { Thread . sleep ( duration ) ; }
void generate ( Xml Writer w ) throws IO Exception { List < Xml Writer . Attribute > attrs = null ; if ( count > NUM_ ) { attrs = Collections . singleton List ( new Xml Writer . Attribute ( STR_ , Integer . to String ( count ) ) ) ; } w . simple Element ( Google Base Namespaces . GM , STR_ , attrs , value ) ; }
public String add Step For Remove V Plex CG ( Workflow workflow , String step Id , String wait For , Storage System vplex System , URI cg URI , String cg Name , String cluster Name , Boolean set Inactive , Workflow . Method rollback Method ) { URI vplex System URI = vplex System . get Id ( ) ; Workflow . Method vplex Execute Method = new Workflow . Method ( DELETE CG METHOD NAME , vplex System URI , cg URI , cg Name , cluster Name , set Inactive ) ; String step = workflow . create Step ( DELETE CG STEP , String . format ( STR_ , cg Name , vplex System URI . to String ( ) ) , wait For , vplex System URI , vplex System . get System Type ( ) , get Class ( ) , vplex Execute Method , rollback Method , step Id ) ; log . info ( STR_ , cluster Name + STR_ + cg Name , vplex System URI ) ; return step ; }
private String trim And Parenthesise ( String str ) { String parenthesised String = str ; if ( str != null ) { str = str . trim ( ) ; if ( ! str . starts With ( OPEN PARENTHESIS ) ) { parenthesised String = OPEN PARENTHESIS + str + CLOSE PARENTHESIS ; } } else { parenthesised String = OPEN PARENTHESIS + CLOSE PARENTHESIS ; } return parenthesised String ; }
public Char Stream Consumer ( Reader stream ) { in = new Buffered Reader ( stream ) ; thread . start ( ) ; }
@ Override public List < Proxy > select ( URI uri ) { Array List < Proxy > proxies = new Array List < Proxy > ( ) ; if ( pac Script == null ) { try { pac Script = compile Pac Script ( load Pac Script ( pac Url ) ) ; } catch ( Pac Proxy Exception ex ) { ex . print Stack Trace ( ) ; proxies . add ( Proxy . NO PROXY ) ; return proxies ; } } String pac Function Return = null ; try { pac Function Return = ( String ) pac Script . invoke Function ( STR_ , uri . to String ( ) , uri . get Host ( ) ) ; } catch ( No Such Method Exception ex ) { ex . print Stack Trace ( ) ; proxies . add ( Proxy . NO PROXY ) ; return proxies ; } catch ( Script Exception ex ) { ex . print Stack Trace ( ) ; proxies . add ( Proxy . NO PROXY ) ; return proxies ; } if ( pac Function Return == null ) { proxies . add ( Proxy . NO PROXY ) ; return proxies ; } proxies . add All ( parse Pac Proxies ( pac Function Return ) ) ; if ( proxies . size ( ) == NUM_ ) { proxies . add ( Proxy . NO PROXY ) ; } return proxies ; }
public void release Resources For Address ( String address ) { synchronized ( async Close Executors ) { Thread Pool Executor pool = async Close Executors . get ( address ) ; if ( pool != null ) { pool . shutdown ( ) ; async Close Executors . remove ( address ) ; } } }
private String type To Package Name ( String content Type ) { content Type = content Type . to Lower Case ( ) ; int len = content Type . length ( ) ; char nm [ ] = new char [ len ] ; content Type . get Chars ( NUM_ , len , nm , NUM_ ) ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = nm [ i ] ; if ( c == STR_ ) { nm [ i ] = STR_ ; } else if ( ! ( STR_ <= c && c <= STR_ || STR_ <= c && c <= STR_ || STR_ <= c && c <= STR_ ) ) { nm [ i ] = STR_ ; } } return new String ( nm ) ; }
public void display Components Onscreen ( final int start Page , int end Page ) { if ( comp Data != null ) { end Page ++ ; comp Data . display Components ( start Page , end Page ) ; org . jpedal . Dev Flags . forms Loaded = true ; } }
public static void main ( String ... args ) { System . set Err ( System . out ) ; Process Logger . log ( STR_ + Arrays . as List ( args ) ) ; try { Java Process jp = new Java Process ( args ) ; jp . run ( ) ; } catch ( Throwable t ) { Process Logger . log ( STR_ , t ) ; System . exit ( NUM_ ) ; } }
public CLIQUE Unit ( CLIQUE Interval interval ) { intervals = new Array List < > ( ) ; intervals . add ( interval ) ; ids = DBID Util . new Hash Set ( ) ; assigned = false ; }
public Set < Resource > some Values From ( ) { Set < Resource > targets = new Hash Set < > ( ) ; for ( Owl Class c : svf Classes ) { targets . add ( c . get URI ( ) ) ; } return targets ; }
private void process File Action ( ) throws IO Exception { switch ( file Action . to Lower Case ( ) ) { case STR_ : fs . delete ( file , true ) ; break ; case STR_ : Path target File Move Path = new Path ( target Folder , file . get Name ( ) ) ; fs . rename ( file , target File Move Path ) ; break ; case STR_ : try ( FS Data Output Stream archived Stream = fs . create ( new Path ( target Folder , file . get Name ( ) + STR_ ) ) ; Zip Output Stream zip Archived Stream = new Zip Output Stream ( archived Stream ) ; FS Data Input Stream fd Data Input Stream = fs . open ( file ) ) { zip Archived Stream . put Next Entry ( new Zip Entry ( file . get Name ( ) ) ) ; int length ; byte [ ] buffer = new byte [ NUM_ ] ; while ( ( length = fd Data Input Stream . read ( buffer ) ) > NUM_ ) { zip Archived Stream . write ( buffer , NUM_ , length ) ; } zip Archived Stream . close Entry ( ) ; } fs . delete ( file , true ) ; break ; default : break ; } }
public static byte [ ] encrypt Key ( @ Not Null byte [ ] password , byte [ ] raw Key ) { try { Cipher c = Cipher . get Instance ( ENCRYPT KEY ALGORITHM ) ; c . init ( Cipher . ENCRYPT MODE , new Secret Key Spec ( password , SECRET KEY ALGORITHM ) , CBC SALT KEY ) ; return c . do Final ( raw Key ) ; } catch ( General Security Exception e ) { throw new Illegal State Exception ( e . get Message ( ) , e ) ; } }
public void capture Photo ( ) throws Exception { m Camera . take Picture ( shutter Callback , raw Callback , jpeg Callback ) ; Thread . sleep ( WAIT GENERIC ) ; m Camera . stop Preview ( ) ; m Camera . release ( ) ; }
@ Override public void add Bridge Idle Debug Listener ( Not Thread Safe Bridge Idle Debug Listener listener ) { m Bridge Idle Listeners . add ( listener ) ; }
public String emit Pattern ( ) { return emit Pattern ( true ) ; }
@ Target Api ( Build . VERSION CODES . M ) public boolean ensure Storage Permission Granted ( ) { if ( Build . VERSION . SDK INT >= Build . VERSION CODES . M ) { if ( check Self Permission ( Manifest . permission . WRITE EXTERNAL STORAGE ) == Package Manager . PERMISSION GRANTED ) { return true ; } else { request Permissions ( new String [ ] { Manifest . permission . WRITE EXTERNAL STORAGE } , REQUESTCODE PERMISSION STORAGE ) ; return false ; } } else { return true ; } }
public XML Parser ( final String namespace , final String [ ] schemas ) throws XML Exception { try { JAXB Context jc = JAXB Context . new Instance ( namespace ) ; marshaller = jc . create Marshaller ( ) ; marshaller . set Schema ( XML Schema Utils . create Schema ( schemas ) ) ; unmarshaller = jc . create Unmarshaller ( ) ; unmarshaller . set Schema ( XML Schema Utils . create Schema ( schemas ) ) ; } catch ( JAXB Exception e ) { throw new XML Exception ( STR_ + namespace , e ) ; } }
public static int scan ( int v ) { return NUM_ - Integer . number Of Leading Zeros ( v ) ; }
private J Panel create Histogram Panel ( Node selected ) { Data Set data Set = ( Data Set ) data Editor . get Selected Data Model ( ) ; Histogram histogram = new Histogram ( data Set ) ; histogram . set Target ( selected == null ? null : selected . get Name ( ) ) ; Histogram View view = new Histogram View ( histogram ) ; Box box = Box . create Horizontal Box ( ) ; box . add ( view ) ; box . add ( Box . create Horizontal Strut ( NUM_ ) ) ; box . add ( Box . create Horizontal Glue ( ) ) ; Box v Box = Box . create Vertical Box ( ) ; v Box . add ( Box . create Vertical Strut ( NUM_ ) ) ; v Box . add ( box ) ; v Box . add ( Box . create Vertical Strut ( NUM_ ) ) ; J Panel panel = new J Panel ( ) ; panel . set Layout ( new Border Layout ( ) ) ; panel . add ( v Box , Border Layout . CENTER ) ; return panel ; }
private static void analyze String Sets ( String Set a , String Set b , String name , Hash Map < String , Change > changes ) { if ( a != null ) { Iterator < String > iter = a . iterator ( ) ; while ( iter . has Next ( ) ) { String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; } String key = name + STR_ + val ; Change change = new Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } if ( b != null ) { Iterator < String > iter = b . iterator ( ) ; while ( iter . has Next ( ) ) { String val = iter . next ( ) ; if ( a != null && a . contains ( val ) ) { continue ; } String key = name + STR_ + val ; Change change = new Change ( key , null , val , name ) ; changes . put ( key , change ) ; } } }
public void register Listener ( Namespace Listener listener ) { if ( listeners . add ( listener ) ) { watch Namespace Changes ( ) ; } }
@ Override public void load Tx Mtd ( Job Conf job , File System fs , Path tf Mtd Dir , Tf Utils agents ) throws IO Exception { if ( fs . is Directory ( tf Mtd Dir ) ) { if ( col List != null ) for ( int i = NUM_ ; i < col List . length ; i ++ ) { int col ID = col List [ i ] ; if ( mv Method List [ i ] == MV Method . GLOBAL MEAN || mv Method List [ i ] == MV Method . GLOBAL MODE ) replacement List [ i ] = read Replacement ( col ID , fs , tf Mtd Dir , agents ) ; else if ( mv Method List [ i ] == MV Method . CONSTANT ) { } else throw new Runtime Exception ( STR_ + mv Method List [ i ] ) ; } if ( col List != null ) for ( int i = NUM_ ; i < col List . length ; i ++ ) if ( is MV Scaled . get ( i ) ) process Scaling File ( i , col List , mean List , var List , fs , tf Mtd Dir , agents ) ; if ( scnomv List != null ) for ( int i = NUM_ ; i < scnomv List . length ; i ++ ) process Scaling File ( i , scnomv List , scnomv Mean List , scnomv Var List , fs , tf Mtd Dir , agents ) ; } else { fs . close ( ) ; throw new Runtime Exception ( STR_ + tf Mtd Dir ) ; } }
static protected Hash Set < String > scan Content For Hosts ( Char Sequence content ) { Hash Set < String > set = new Hash Set < String > ( ) ; Matcher mat = uri Pattern . matcher ( content ) ; while ( mat . find ( ) ) { String found = mat . group ( ) ; Matcher clean Mat = uri Cleanup . matcher ( found ) ; if ( clean Mat . find ( ) ) { found = clean Mat . group ( NUM_ ) ; } clean Mat = uri Cleanup 2 . matcher ( found ) ; if ( clean Mat . find ( ) ) { found = clean Mat . replace All ( STR_ ) ; } clean Mat = uri Cleanup 3 . matcher ( found ) ; if ( clean Mat . find ( ) ) { found = STR_ + clean Mat . group ( NUM_ ) + clean Mat . group ( NUM_ ) ; } clean Mat = scheme Pattern . matcher ( found ) ; if ( ! clean Mat . find ( ) ) { if ( found . matches ( STR_ ) ) { found = STR_ + found ; } else if ( found . matches ( STR_ ) ) { found = STR_ + found ; } } String host = host From Uri Str ( found ) ; if ( null != host ) { host = host . to Lower Case ( ) ; if ( ! set . contains ( host ) ) { set . add ( host ) ; } } } mat = email Addr Pattern . matcher ( content ) ; while ( mat . find ( ) ) { String found = mat . group ( ) ; debug Out ( STR_ + found + STR_ ) ; found = STR_ + found ; debug Out ( STR_ + found + STR_ ) ; String host = host From Uri Str ( found ) ; if ( null != host ) { host = host . to Lower Case ( ) ; if ( ! set . contains ( host ) ) { set . add ( host ) ; } } } return set ; }
protected List < Individual < A > > next Generation ( List < Individual < A > > population , Fitness Function < A > fitness Fn ) { List < Individual < A > > new Population = new Array List < Individual < A > > ( population . size ( ) ) ; for ( int i = NUM_ ; i < population . size ( ) ; i ++ ) { Individual < A > x = random Selection ( population , fitness Fn ) ; Individual < A > y = random Selection ( population , fitness Fn ) ; Individual < A > child = reproduce ( x , y ) ; if ( random . next Double ( ) <= mutation Probability ) { child = mutate ( child ) ; } new Population . add ( child ) ; } notify Progress Tracers ( get Iterations ( ) , population ) ; return new Population ; }
private void verify Buffer Size ( int sz ) { if ( sz > buf . length ) { byte [ ] old = buf ; buf = new byte [ Math . max ( sz , NUM_ * buf . length ) ] ; System . arraycopy ( old , NUM_ , buf , NUM_ , old . length ) ; old = null ; } }
private void grow ( int min Capacity ) { int old Capacity = buf . length ; int new Capacity = old Capacity << NUM_ ; if ( new Capacity - min Capacity < NUM_ ) new Capacity = min Capacity ; if ( new Capacity - MAX ARRAY SIZE > NUM_ ) new Capacity = huge Capacity ( min Capacity ) ; buf = Arrays . copy Of ( buf , new Capacity ) ; }
public double [ ] distribution For Instance ( Instance instance ) throws Exception { double [ ] prob Of Class Given Doc = new double [ m num Classes ] ; double [ ] log Doc Given Class = new double [ m num Classes ] ; for ( int h = NUM_ ; h < m num Classes ; h ++ ) log Doc Given Class [ h ] = prob Of Doc Given Class ( instance , h ) ; double max = log Doc Given Class [ Utils . max Index ( log Doc Given Class ) ] ; double prob Of Doc = NUM_ ; for ( int i = NUM_ ; i < m num Classes ; i ++ ) { prob Of Class Given Doc [ i ] = Math . exp ( log Doc Given Class [ i ] - max ) * m prob Of Class [ i ] ; prob Of Doc += prob Of Class Given Doc [ i ] ; } Utils . normalize ( prob Of Class Given Doc , prob Of Doc ) ; return prob Of Class Given Doc ; }
public Multilabel Result ( int [ ] [ ] goldstandard , double [ ] [ ] predictions , String bipartition Threshold ) throws Text Classification Exception { this . actuals = goldstandard ; this . predictions = predictions ; try { this . bipartition Threshold = Double . parse Double ( bipartition Threshold ) ; } catch ( Number Format Exception e ) { throw new Text Classification Exception ( STR_ ) ; } }
public Compactor snapshot Index ( long index ) { this . snapshot Index = Math . max ( this . snapshot Index , index ) ; return this ; }
public static void register Container M Bean ( String container Name , IJ Space Container container ) { M Bean Server m Bean Server = get M Bean Server ( container Name ) ; if ( m Bean Server == null ) return ; if ( m M Beans Repository . contains Key ( container Name ) ) return ; try { JMX Space Container mbean = new JMX Space Container ( container , CONTAINER MBEAN DESCR URL ) ; Object Name obj Name = Object Name Factory . build Object Name ( DEFAULT DOMAIN , mbean . get Type ( ) , container Name ) ; m M Beans Repository . put ( container Name , m Bean Server . register M Bean ( mbean , obj Name ) ) ; } catch ( Instance Already Exists Exception e ) { if ( logger . is Loggable ( Level . CONFIG ) ) { logger . config ( STR_ + container Name + STR_ ) ; } } catch ( Exception ex ) { if ( logger . is Loggable ( Level . WARNING ) ) { logger . log ( Level . WARNING , STR_ + container Name + STR_ , ex ) ; } } if ( logger . is Loggable ( Level . CONFIG ) ) { logger . config ( STR_ + container Name + STR_ ) ; } }
private boolean read Meta Data ( ) throws IO Exception { Segment Extent 10 segment = meta Segment ; try ( Read Stream is = open Read ( segment . address ( ) , segment . length ( ) ) ) { is . position ( META OFFSET ) ; while ( read Meta Entry ( is ) ) { } } return true ; }
protected void parse DOM Attributes ( Element element ) throws SAML 2 Exception { super . parse DOM Attributes ( element ) ; }
public org . smpte ra . schemas . st 2067 2 2013 . Digest Method Type build Default Digest Method Type ( ) { org . smpte ra . schemas . st 2067 2 2013 . Digest Method Type digest Method Type = new org . smpte ra . schemas . st 2067 2 2013 . Digest Method Type ( ) ; digest Method Type . set Algorithm ( Composition Playlist Builder 2013 . default Hash Algorithm ) ; return digest Method Type ; }
void update Mnemonic Binding ( Abstract Button b ) { int m = b . get Mnemonic ( ) ; if ( m != NUM_ ) { Input Map map = Swing Utilities . get UI Input Map ( b , J Component . WHEN IN FOCUSED WINDOW ) ; if ( map == null ) { map = new Component Input Map UI Resource ( b ) ; Swing Utilities . replace UI Input Map ( b , J Component . WHEN IN FOCUSED WINDOW , map ) ; } map . clear ( ) ; map . put ( Key Stroke . get Key Stroke ( m , Basic Look And Feel . get Focus Accelerator Key Mask ( ) , false ) , STR_ ) ; map . put ( Key Stroke . get Key Stroke ( m , Basic Look And Feel . get Focus Accelerator Key Mask ( ) , true ) , STR_ ) ; map . put ( Key Stroke . get Key Stroke ( m , NUM_ , true ) , STR_ ) ; } else { Input Map map = Swing Utilities . get UI Input Map ( b , J Component . WHEN IN FOCUSED WINDOW ) ; if ( map != null ) { map . clear ( ) ; } } }
protected Intersection find Closest Intersection ( Lat Lon Point lat Lon ) { Intersection inter = ( Intersection ) inter Quad Tree . get ( lat Lon . get Y ( ) , lat Lon . get X ( ) ) ; if ( inter == null ) logger . warning ( STR_ + lat Lon ) ; return inter ; }
public static < T > T with Reader ( Reader reader , @ Closure Params ( First Param . class ) Closure < T > closure ) throws IO Exception { try { T result = closure . call ( reader ) ; Reader temp = reader ; reader = null ; temp . close ( ) ; return result ; } finally { close With Warning ( reader ) ; } }
public void connection Open ( ) { lock . lock ( ) ; try { log . info ( STR_ ) ; connection Open = true ; } finally { lock . unlock ( ) ; } }
public static Version serializable Instance ( ) { return new Version ( STR_ ) ; }
public Compactor minor Index ( long index ) { this . minor Index = Math . max ( this . minor Index , index ) ; Segment segment = segments . segment ( minor Index ) ; if ( segment != null ) { compact Index = segment . first Index ( ) ; } return this ; }
private void generate ( Region . Entry entry ) throws SAX Exception { if ( ( entry == null ) ) { return ; } handler . start Element ( STR_ , ENTRY , ENTRY , EMPTY ) ; handler . start Element ( STR_ , KEY , KEY , EMPTY ) ; generate ( entry . get Key ( ) ) ; handler . end Element ( STR_ , KEY , KEY ) ; handler . start Element ( STR_ , VALUE , VALUE , EMPTY ) ; generate ( entry . get Value ( ) ) ; handler . end Element ( STR_ , VALUE , VALUE ) ; handler . end Element ( STR_ , ENTRY , ENTRY ) ; }
private void init ( Matrix matrix ) { for ( int i = NUM_ ; i < NUM_ ; i ++ ) { for ( int j = NUM_ ; j < NUM_ ; j ++ ) { matrix . create Entry ( Integer . to String ( i ) , Integer . to String ( j ) , NUM_ ) ; } } }
@ Override public boolean on Touch ( final View v , final Motion Event event ) { if ( ! lollipop And Above ( ) ) switch ( event . get Action ( ) ) { case Motion Event . ACTION DOWN : gradient Drawable = new Gradient Drawable ( ) ; gradient Drawable . set Shape ( Gradient Drawable . OVAL ) ; gradient Drawable . set Size ( m Original Thumb Height / NUM_ , m Original Thumb Height / NUM_ ) ; gradient Drawable . set Color ( m Is Enabled ? m Thumb Color : Color . LTGRAY ) ; gradient Drawable . set Dither ( true ) ; gradient Drawable . set Alpha ( m Thumb Alpha ) ; set Thumb ( gradient Drawable ) ; break ; case Motion Event . ACTION UP : gradient Drawable = new Gradient Drawable ( ) ; gradient Drawable . set Shape ( Gradient Drawable . OVAL ) ; gradient Drawable . set Size ( m Original Thumb Height / NUM_ , m Original Thumb Height / NUM_ ) ; gradient Drawable . set Color ( m Is Enabled ? m Thumb Color : Color . LTGRAY ) ; gradient Drawable . set Dither ( true ) ; gradient Drawable . set Alpha ( m Thumb Alpha ) ; set Thumb ( gradient Drawable ) ; break ; } return false ; }
public void add Numeric Value Changed Listener ( Numeric Value Watcher watcher ) { m Numeric Listeners . add ( watcher ) ; }
public Point 2 D transform ( Point 2 D graph Point ) { if ( graph Point == null ) return null ; Point 2 D view Center = get View Center ( ) ; double view Radius = get View Radius ( ) ; double ratio = get Ratio ( ) ; Point 2 D view Point = delegate . transform ( graph Point ) ; double dx = view Point . get X ( ) - view Center . get X ( ) ; double dy = view Point . get Y ( ) - view Center . get Y ( ) ; dx *= ratio ; Point 2 D point From Center = new Point 2 D . Double ( dx , dy ) ; Polar Point polar = Polar Point . cartesian To Polar ( point From Center ) ; double theta = polar . get Theta ( ) ; double radius = polar . get Radius ( ) ; if ( radius > view Radius ) return view Point ; double mag = magnification ; radius *= mag ; radius = Math . min ( radius , view Radius ) ; Point 2 D projected Point = Polar Point . polar To Cartesian ( theta , radius ) ; projected Point . set Location ( projected Point . get X ( ) / ratio , projected Point . get Y ( ) ) ; Point 2 D translated Back = new Point 2 D . Double ( projected Point . get X ( ) + view Center . get X ( ) , projected Point . get Y ( ) + view Center . get Y ( ) ) ; return translated Back ; }
private static String decode Header ( String authorization Header ) { final String BASIC AUTH CHARSET = STR_ ; if ( null == authorization Header ) throw new Null Pointer Exception ( STR_ ) ; if ( authorization Header . is Empty ( ) ) throw new Illegal Argument Exception ( STR_ ) ; Base 64 . Decoder decoder = Base 64 . get Mime Decoder ( ) ; byte [ ] decoded Bytes = decoder . decode ( authorization Header ) ; try { return new String ( decoded Bytes , BASIC AUTH CHARSET ) ; } catch ( Unsupported Encoding Exception e ) { throw new Illegal State Exception ( STR_ + BASIC AUTH CHARSET , e ) ; } }
void rollover With Lock ( final boolean force ) throws IO Exception { write Lock . lock ( ) ; try { rollover ( force ) ; } finally { write Lock . unlock ( ) ; } }
protected boolean is Attach API Not Found ( final Throwable t ) { boolean missing = false ; if ( t instanceof Class Not Found Exception || t instanceof No Class Def Found Error ) { if ( ! is Attach API On Classpath ( ) ) { final String Writer stack Trace Writer = new String Writer ( ) ; t . print Stack Trace ( new Print Writer ( stack Trace Writer ) ) ; final String stack Trace = stack Trace Writer . to String ( ) ; for ( String attach Api Package : ATTACH API PACKAGES ) { missing |= stack Trace . contains ( attach Api Package ) ; } } } return missing ; }
public void resolve ( Class type , String value ) throws Exception { String name = type . get Name ( ) ; read . put ( value , name ) ; write . put ( name , value ) ; }
public void start ( ) { if ( paired Devices . size ( ) > NUM_ ) { current Paired Device Index = - NUM_ ; check Next Paired Device ( ) ; } else { start Discovery ( ) ; } }
public void add Listener ( @ Not Null Configuration Listener listener ) { if ( my Listeners == null ) { my Listeners = new Array List < > ( ) ; } my Listeners . add ( listener ) ; }
public static void show Reil Code ( final Window parent , final I Navi Code Node code Node ) { try { C Reil Instruction Dialog . show ( parent , code Node ) ; } catch ( final Internal Translation Exception exception ) { C Utility Functions . log Exception ( exception ) ; final String message = STR_ + STR_ ; final String description = C Utility Functions . create Description ( String . format ( STR_ , code Node . get Address ( ) ) , new String [ ] { STR_ } , new String [ ] { STR_ + STR_ } ) ; Navi Error Dialog . show ( parent , message , description , exception ) ; } }
protected void generate Attributes ( ) { for ( Tag t : sc . get Tags ( ) ) { if ( t instanceof Attribute ) { cv . visit Attribute ( create ASM Attribute ( ( Attribute ) t ) ) ; } } }
public static final G Code Flavor taste Flavor ( File file ) throws IO Exception , G Code Parse Exception { if ( file . exists ( ) ) throw new G Code Parse Exception ( STR_ ) ; if ( ! file . is File ( ) ) throw new G Code Parse Exception ( STR_ ) ; final Buffered Input Stream buffer = new Buffered Input Stream ( new File Input Stream ( file ) ) ; G Code Flavor ret = taste Flavor ( buffer ) ; buffer . close ( ) ; return ret ; }
public static < T > Iterator < T > array As Iterator ( T [ ] array ) { return new Array Iterator < T > ( array ) ; }
private boolean process Key Up ( int key Code ) { if ( key Code == Key Event . KEYCODE DEL ) { if ( m In Kb Mode ) { if ( ! m Typed Times . is Empty ( ) ) { int deleted = delete Last Typed Key ( ) ; String deleted Key Str ; if ( deleted == get Am Or Pm Key Code ( AM ) ) { deleted Key Str = m Am Text ; } else if ( deleted == get Am Or Pm Key Code ( PM ) ) { deleted Key Str = m Pm Text ; } else { deleted Key Str = String . format ( STR_ , get Val From Key Code ( deleted ) ) ; } Accessibility Utils . make Announcement ( this , String . format ( m Deleted Key Format , deleted Key Str ) ) ; update Display ( true ) ; } } } else if ( key Code == Key Event . KEYCODE 0 || key Code == Key Event . KEYCODE 1 || key Code == Key Event . KEYCODE 2 || key Code == Key Event . KEYCODE 3 || key Code == Key Event . KEYCODE 4 || key Code == Key Event . KEYCODE 5 || key Code == Key Event . KEYCODE 6 || key Code == Key Event . KEYCODE 7 || key Code == Key Event . KEYCODE 8 || key Code == Key Event . KEYCODE 9 || ( ! m Is 24 Hour View && ( key Code == get Am Or Pm Key Code ( AM ) || key Code == get Am Or Pm Key Code ( PM ) ) ) ) { if ( ! m In Kb Mode ) { if ( m Radial Time Picker View == null ) { Log . e ( TAG , STR_ ) ; return true ; } m Typed Times . clear ( ) ; try Starting Kb Mode ( key Code ) ; return true ; } if ( add Key If Legal ( key Code ) ) { update Display ( false ) ; } return true ; } return false ; }
public void unbind Property ( Component cmp , String property Name ) { Bind Target t = ( Bind Target ) cmp . get Client Property ( STR_ + property Name ) ; cmp . unbind Property ( property Name , t ) ; ; }
public synchronized void remove Pv Change Listener ( Pv Change Listener l ) { ensure Pv Change Listeners ( ) ; Pv Change Listeners . remove ( l ) ; allow Events = ! Pv Change Listeners . is Empty ( ) ; log . trace ( STR_ + to String ( ) + STR_ + String . value Of ( l ) ) ; }
private void disconnect D Server ( ) { if ( ld != null ) { ld . close ( ) ; ld = null ; ds Config Instance = null ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Text Title ) ) { return false ; } Text Title that = ( Text Title ) obj ; if ( ! Object Utilities . equal ( this . text , that . text ) ) { return false ; } if ( ! Object Utilities . equal ( this . font , that . font ) ) { return false ; } if ( ! Paint Utilities . equal ( this . paint , that . paint ) ) { return false ; } if ( this . text Alignment != that . text Alignment ) { return false ; } if ( ! Paint Utilities . equal ( this . background Paint , that . background Paint ) ) { return false ; } if ( this . maximum Lines To Display != that . maximum Lines To Display ) { return false ; } if ( this . expand To Fit Space != that . expand To Fit Space ) { return false ; } if ( ! Object Utilities . equal ( this . tool Tip Text , that . tool Tip Text ) ) { return false ; } if ( ! Object Utilities . equal ( this . url Text , that . url Text ) ) { return false ; } return super . equals ( obj ) ; }
public boolean read Descriptor ( String service UUID , String characteristic UUID , String descriptor UUID ) { if ( m Bluetooth Gatt == null ) { Log . w ( TAG , STR_ ) ; return false ; } Bluetooth Gatt Service service = m Bluetooth Gatt . get Service ( UUID . from String ( service UUID ) ) ; Bluetooth Gatt Characteristic characteristic = service . get Characteristic ( UUID . from String ( characteristic UUID ) ) ; Bluetooth Gatt Descriptor descriptor = characteristic . get Descriptor ( UUID . from String ( descriptor UUID ) ) ; return m Bluetooth Gatt . read Descriptor ( descriptor ) ; }
private String drop Index DDL ( String index Name ) { sb . set Length ( NUM_ ) ; sb . append ( STR_ ) ; sb . append ( index Name ) ; sb . append ( STR_ ) ; return ( sb . to String ( ) ) ; }
public void notify Target Activity Changed ( Target Activity target Activity ) { int in = target Activities . index Of ( target Activity ) ; if ( in != - NUM_ ) { notify Item Changed ( in + NUM_ ) ; } }
public void after Properties Set ( ) throws Exception { String platform = System . get Property ( STR_ ) ; if ( platform Prefix Mappings != null ) { platform Prefix = ( String ) platform Prefix Mappings . get ( platform ) ; } if ( platform Prefix == null ) { platform Prefix = ( String ) DEFAULT PLATFORM PREFIX MAPPINGS . get ( platform ) ; } }
public Atomic Integer read ( String value ) { Integer number = Integer . value Of ( value ) ; return new Atomic Integer ( number ) ; }
protected final void send Add Loader Event ( ) { if ( has New Loader && is Scanning . compare And Set ( false , true ) ) { try { while ( has New Loader ) { has New Loader = false ; scan ( ) ; configure Enhancer Event ( ) ; configure Post Enhancer Event ( ) ; } } finally { is Scanning . set ( false ) ; } } }
protected String build URL ( String action , Node remote , Node local , String security Token , String registration Url ) throws IO Exception { String url = add Security Token ( ( resolve URL ( remote . get Sync Url ( ) , registration Url ) + STR_ + action ) , STR_ , local . get Node Id ( ) , security Token ) ; log . debug ( STR_ , url ) ; return url ; }
private static boolean is Appropriate Property Name For Setter ( @ Not Null String imported Name , @ Not Null String property Name ) { property Name = Groovy Property Utils . decapitalize ( property Name ) ; return property Name . equals ( Groovy Property Utils . get Property Name By Setter Name ( imported Name ) ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof XY Step Area Renderer ) ) { return false ; } XY Step Area Renderer that = ( XY Step Area Renderer ) obj ; if ( this . show Outline != that . show Outline ) { return false ; } if ( this . shapes Visible != that . shapes Visible ) { return false ; } if ( this . shapes Filled != that . shapes Filled ) { return false ; } if ( this . plot Area != that . plot Area ) { return false ; } if ( this . range Base != that . range Base ) { return false ; } if ( this . step Point != that . step Point ) { return false ; } return super . equals ( obj ) ; }
public void on Register Click ( View view ) { if ( view != null ) { Intent register = new Intent ( Intent . ACTION VIEW , Uri . parse ( get String ( R . string . welcome link url ) ) ) ; set Result ( RESULT CANCELED ) ; start Activity ( register ) ; } }
public String reference ( Object obj ) { return null ; }
protected Boolean parse Boolean Value ( String boolean Value ) throws Parse Exception { if ( boolean Value == null ) { return null ; } if ( boolean Value . equals Ignore Case ( STR_ ) || boolean Value . equals ( STR_ ) ) { return Boolean . FALSE ; } if ( boolean Value . equals Ignore Case ( STR_ ) || boolean Value . equals ( STR_ ) ) { return Boolean . TRUE ; } Parse Exception pe = new Parse Exception ( Core Error Domain . ERR . invalid Boolean Attribute ) ; pe . set Internal Reason ( STR_ + boolean Value ) ; throw pe ; }
@ Override public void suite Start ( ) { throw new Unsupported Operation Exception ( ) ; }
private void map Possible Type ( I Drawer Item drawer Item ) { if ( ! m Type Instances . contains Key ( drawer Item . get Type ( ) ) ) { m Type Ids . add ( drawer Item . get Type ( ) ) ; m Type Instances . put ( drawer Item . get Type ( ) , drawer Item ) ; } }
@ Override public Instances define Data Format ( ) throws Exception { Array List < Attribute > atts ; atts = new Array List < Attribute > ( ) ; atts . add ( new Attribute ( STR_ ) ) ; m Raw Data = new Instances ( get Relation Name To Use ( ) , atts , NUM_ ) ; m Filter = new Add Expression ( ) ; m Filter . set Name ( STR_ ) ; m Filter . set Expression ( get Expression ( ) ) ; m Filter . set Input Format ( m Raw Data ) ; return super . define Data Format ( ) ; }
@ Override public int hash Code ( ) { return region Path . hash Code ( ) ; }
private void retain Valid Entity I Ds ( Map map , String protocol , String realm ) throws COT Exception { Set p Set = ( Set ) map . get ( protocol ) ; if ( ( p Set != null ) && ! p Set . is Empty ( ) ) { Set entity Ids = get All Entities ( realm , protocol ) ; if ( ( entity Ids == null ) || entity Ids . is Empty ( ) ) { map . remove ( protocol ) ; } else { if ( ! entity Ids . contains All ( p Set ) ) { if ( entity Ids . retain All ( p Set ) ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + entity Ids + STR_ + STR_ ) ; } map . put ( protocol , entity Ids ) ; } } } } }
public boolean remove Handler ( String column Name ) { if ( m overrides == null ) return false ; else return m overrides . remove ( column Name ) != null ; }
public static void register New Column Width ( Class < ? > controller Class , String column Name , int width ) { if ( width > NUM_ ) { int hash = get Column Hash ( controller Class , column Name ) ; column Size Cache . put ( hash , width ) ; } }
protected void commit From Within Callback ( boolean heuristic , boolean one Phase ) throws Heur Rollback Exception , Heur Mixed Exception , Heur Hazard Exception , java . lang . Illegal State Exception , Rollback Exception , Sys Exception { Coordinator State Handler next State Handler = null ; try { Vector < Participant > participants = coordinator . get Participants ( ) ; int count = ( participants . size ( ) - read Only Table . size ( ) ) ; Termination Result commitresult = new Termination Result ( count ) ; committed = Boolean . TRUE ; try { coordinator . set State ( Tx State . COMMITTING ) ; } catch ( Runtime Exception error ) { String msg = STR_ + error . get Message ( ) + STR_ ; LOGGER . log Warning ( msg , error ) ; throw new Rollback Exception ( msg , error ) ; } Enumeration < Participant > enumm = participants . elements ( ) ; while ( enumm . has More Elements ( ) ) { Participant p = enumm . next Element ( ) ; if ( ! read Only Table . contains ( p ) ) { Commit Message cm = new Commit Message ( p , commitresult , one Phase ) ; if ( one Phase && cascade List != null ) { Integer sibnum = cascade List . get ( p ) ; if ( sibnum != null ) p . set Global Sibling Count ( sibnum . int Value ( ) ) ; p . set Cascade List ( cascade List ) ; } propagator . submit Propagation Message ( cm ) ; } } commitresult . wait For Replies ( ) ; int res = commitresult . get Result ( ) ; if ( res != Termination Result . ALL OK ) { if ( res == Termination Result . HEUR MIXED ) { Set < Participant > hazards = commitresult . get Possibly Indoubts ( ) ; next State Handler = new Heur Mixed State Handler ( this , hazards ) ; coordinator . set State Handler ( next State Handler ) ; throw new Heur Mixed Exception ( ) ; } else if ( res == Termination Result . ROLLBACK ) { next State Handler = new Terminated State Handler ( this ) ; coordinator . set State Handler ( next State Handler ) ; throw new Rollback Exception ( STR_ ) ; } else if ( res == Termination Result . HEUR ROLLBACK ) { next State Handler = new Heur Aborted State Handler ( this ) ; coordinator . set State Handler ( next State Handler ) ; throw new Heur Rollback Exception ( ) ; } else if ( res == Termination Result . HEUR HAZARD ) { Set < Participant > hazards = commitresult . get Possibly Indoubts ( ) ; next State Handler = new Heur Hazard State Handler ( this , hazards ) ; coordinator . set State Handler ( next State Handler ) ; throw new Heur Hazard Exception ( ) ; } } else { if ( heuristic ) { next State Handler = new Heur Committed State Handler ( this ) ; } else next State Handler = new Terminated State Handler ( this ) ; coordinator . set State Handler ( next State Handler ) ; } } catch ( Runtime Exception runerr ) { throw new Sys Exception ( STR_ + runerr . get Message ( ) , runerr ) ; } catch ( Interrupted Exception intr ) { Interrupted Exception Helper . handle Interrupted Exception ( intr ) ; throw new Sys Exception ( STR_ + intr . get Message ( ) , intr ) ; } }
public static void spooky 4 ( final long [ ] triple , final long seed , final long [ ] tuple ) { long h 0 , h 1 , h 2 , h 3 ; h 0 = seed ; h 1 = ARBITRARY BITS + triple [ NUM_ ] ; h 2 = ARBITRARY BITS + triple [ NUM_ ] ; h 3 = ARBITRARY BITS + triple [ NUM_ ] ; h 2 = Long . rotate Left ( h 2 , NUM_ ) ; h 2 += h 3 ; h 0 ^= h 2 ; h 3 = Long . rotate Left ( h 3 , NUM_ ) ; h 3 += h 0 ; h 1 ^= h 3 ; h 0 = Long . rotate Left ( h 0 , NUM_ ) ; h 0 += h 1 ; h 2 ^= h 0 ; h 1 = Long . rotate Left ( h 1 , NUM_ ) ; h 1 += h 2 ; h 3 ^= h 1 ; h 2 = Long . rotate Left ( h 2 , NUM_ ) ; h 2 += h 3 ; h 0 ^= h 2 ; h 3 = Long . rotate Left ( h 3 , NUM_ ) ; h 3 += h 0 ; h 1 ^= h 3 ; h 0 = Long . rotate Left ( h 0 , NUM_ ) ; h 0 += h 1 ; h 2 ^= h 0 ; h 1 = Long . rotate Left ( h 1 , NUM_ ) ; h 1 += h 2 ; h 3 ^= h 1 ; h 2 = Long . rotate Left ( h 2 , NUM_ ) ; h 2 += h 3 ; h 0 ^= h 2 ; h 3 = Long . rotate Left ( h 3 , NUM_ ) ; h 3 += h 0 ; h 1 ^= h 3 ; h 0 = Long . rotate Left ( h 0 , NUM_ ) ; h 0 += h 1 ; h 2 ^= h 0 ; h 1 = Long . rotate Left ( h 1 , NUM_ ) ; h 1 += h 2 ; h 3 ^= h 1 ; switch ( tuple . length ) { case NUM_ : tuple [ NUM_ ] = h 3 ; case NUM_ : tuple [ NUM_ ] = h 2 ; case NUM_ : tuple [ NUM_ ] = h 1 ; case NUM_ : tuple [ NUM_ ] = h 0 ; } }
public static void do Deactivate Vcenter Data Center ( Db Client db Client , Vcenter Data Center data Center ) { List < Named Element Query Result List . Named Element > host Uris = list Children ( db Client , data Center . get Id ( ) , Host . class , STR_ , STR_ ) ; Set < URI > do Not Deleteclusters = new Hash Set < URI > ( ) ; for ( Named Element Query Result List . Named Element host Uri : host Uris ) { Host host = db Client . query Object ( Host . class , host Uri . get Id ( ) ) ; if ( host != null && ! host . get Inactive ( ) ) { if ( Null Column Value Getter . is Null URI ( host . get Compute Element ( ) ) ) { do Deactivate Host ( db Client , host ) ; } else { host . set Vcenter Data Center ( Null Column Value Getter . get Null URI ( ) ) ; db Client . persist Object ( host ) ; if ( ! Null Column Value Getter . is Null URI ( host . get Cluster ( ) ) ) { do Not Deleteclusters . add ( host . get Cluster ( ) ) ; } } } } List < Named Element Query Result List . Named Element > clusters Uris = list Children ( db Client , data Center . get Id ( ) , Cluster . class , STR_ , STR_ ) ; for ( Named Element Query Result List . Named Element cluster Uri : clusters Uris ) { Cluster cluster = db Client . query Object ( Cluster . class , cluster Uri . get Id ( ) ) ; if ( cluster != null && ! cluster . get Inactive ( ) ) { if ( do Not Deleteclusters . contains ( cluster . get Id ( ) ) ) { cluster . set Vcenter Data Center ( Null Column Value Getter . get Null URI ( ) ) ; cluster . set External Id ( Null Column Value Getter . get Null Str ( ) ) ; db Client . persist Object ( cluster ) ; } else { db Client . mark For Deletion ( cluster ) ; Event Utils . delete Resource Events ( db Client , cluster . get Id ( ) ) ; } } } log . info ( STR_ , data Center . get Label ( ) , data Center . get Id ( ) ) ; db Client . mark For Deletion ( data Center ) ; Event Utils . delete Resource Events ( db Client , data Center . get Id ( ) ) ; }
public Business Object Data Entity create Database Entities For Initiate Restore Testing ( Business Object Data Key business Object Data Key ) { return create Database Entities For Initiate Restore Testing ( business Object Data Key , Abstract Service Test . STORAGE NAME ORIGIN , Abstract Service Test . S 3 BUCKET NAME ORIGIN , Storage Unit Status Entity . DISABLED , Abstract Service Test . STORAGE NAME GLACIER , Abstract Service Test . S 3 BUCKET NAME GLACIER , Storage Unit Status Entity . ENABLED , Abstract Service Test . S 3 BUCKET NAME ORIGIN + STR_ + Abstract Service Test . TEST S 3 KEY PREFIX ) ; }
private float calc Angle ( float value ) { return calc Angle ( value , m Data . get Y Value Sum ( ) ) ; }
public Media Config create Channel File Attachment ( String file , Media Config config ) { config . add Credentials ( this ) ; String xml = POSTFILE ( this . url + STR_ , file , config . name , config . to XML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { Media Config media = new Media Config ( ) ; media . parse XML ( root ) ; return media ; } catch ( Exception exception ) { this . exception = SDK Exception . parse Failure ( exception ) ; throw this . exception ; } }
private static double Internalgamma ( double z ) { double sum = NUM_ ; double [ ] c = { NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ } ; for ( int i = NUM_ ; i < c . length ; i ++ ) { sum += c [ i ] * Math . pow ( z , ( double ) ( i + NUM_ ) ) ; } return ( NUM_ / sum ) ; }
private static boolean is Assignable From ( Type from , Parameterized Type to , Map < String , Type > type Var Map ) { if ( from == null ) { return false ; } if ( to . equals ( from ) ) { return true ; } Class < ? > clazz = get Raw Type ( from ) ; Parameterized Type ptype = null ; if ( from instanceof Parameterized Type ) { ptype = ( Parameterized Type ) from ; } if ( ptype != null ) { Type [ ] t Args = ptype . get Actual Type Arguments ( ) ; Type Variable < ? > [ ] t Params = clazz . get Type Parameters ( ) ; for ( int i = NUM_ ; i < t Args . length ; i ++ ) { Type arg = t Args [ i ] ; Type Variable < ? > var = t Params [ i ] ; while ( arg instanceof Type Variable ) { Type Variable < ? > v = ( Type Variable < ? > ) arg ; arg = type Var Map . get ( v . get Name ( ) ) ; } type Var Map . put ( var . get Name ( ) , arg ) ; } if ( type Equals ( ptype , to , type Var Map ) ) { return true ; } } for ( Type itype : clazz . get Generic Interfaces ( ) ) { if ( is Assignable From ( itype , to , new Hash Map < String , Type > ( type Var Map ) ) ) { return true ; } } Type s Type = clazz . get Generic Superclass ( ) ; if ( is Assignable From ( s Type , to , new Hash Map < String , Type > ( type Var Map ) ) ) { return true ; } return false ; }
@ Not Null public Message Builder type ( @ Not Null Message Type type ) { types . add ( type ) ; return this ; }
private void update Min Max ( Instance instance ) { for ( int j = NUM_ ; j < instance . num Attributes ( ) ; j ++ ) { if ( Double . is Na N ( m Min [ j ] ) ) { m Min [ j ] = instance . value ( j ) ; m Max [ j ] = instance . value ( j ) ; } else { if ( instance . value ( j ) < m Min [ j ] ) { m Min [ j ] = instance . value ( j ) ; } else { if ( instance . value ( j ) > m Max [ j ] ) { m Max [ j ] = instance . value ( j ) ; } } } } }
All Instruction Enumeration ( Basic Block bb , SSA Dictionary dict ) { explicit Instructions = bb . forward Instr Enumerator ( ) ; implicit Instructions = dict . get Heap Phi Instructions ( bb ) ; label Instruction = explicit Instructions . next Element ( ) ; }
public String statistics ( ) { Decimal Format formatter = new Decimal Format ( STR_ ) ; Decimal Format float Formatter = new Decimal Format ( STR_ ) ; return String . format ( STR_ , formatter . format ( min Rate ( ) ) , formatter . format ( avg Rate ( ) ) , formatter . format ( max Rate ( ) ) , float Formatter . format ( std Dev ( ) ) ) ; }
public long cmajflt ( ) { return Long . parse Long ( fields [ NUM_ ] ) ; }
@ Suppress Warnings ( STR_ ) public static Store Context from Serialized Bytes ( byte bytes [ ] ) { Store Context ctx ; if ( bytes != null && bytes . length > NUM_ ) { Byte Buffer bb = Byte Buffer Support . fill Buffer ( bytes ) ; Byte Buffer framework Id = Byte Buffer Support . create Buffer ( bb ) ; List < Byte Buffer > task Ids = Byte Buffer Support . create Buffer List ( bb , bb . get Int ( ) ) ; List < Byte Buffer > task Nodes = Byte Buffer Support . create Buffer List ( bb , bb . get Int ( ) ) ; List < Byte Buffer > pending Tasks = Byte Buffer Support . create Buffer List ( bb , bb . get Int ( ) ) ; List < Byte Buffer > staging Tasks = Byte Buffer Support . create Buffer List ( bb , bb . get Int ( ) ) ; List < Byte Buffer > active Tasks = Byte Buffer Support . create Buffer List ( bb , bb . get Int ( ) ) ; List < Byte Buffer > lost Tasks = Byte Buffer Support . create Buffer List ( bb , bb . get Int ( ) ) ; List < Byte Buffer > killable Tasks = Byte Buffer Support . create Buffer List ( bb , bb . get Int ( ) ) ; ctx = new Store Context ( framework Id , task Ids , task Nodes , pending Tasks , staging Tasks , active Tasks , lost Tasks , killable Tasks ) ; } else { ctx = new Store Context ( ) ; } return ctx ; }
protected static int create Serial Number ( ) { return serial Number Sequencer . increment And Get ( ) ; }
public double calculate Clone Usable Capacity ( int vmfullclonesize , int vmdeltasize , int vmdisposabledisksize , int vmlogsize , int vmswapsize , int vmvideoswapsize , int vmcount , int storageoverhead , int blockdeduplicationratio , String clonetype ) { Double d = ( double ) ( ( vmfullclonesize + vmdeltasize + vmdisposabledisksize + vmlogsize + vmswapsize + vmvideoswapsize ) * vmcount ) / NUM_ ; d += disposableusablecapacity ; d += localswapsizetotal ; d *= ( NUM_ + ( storageoverhead / NUM_ ) ) ; if ( clonetype . equals Ignore Case ( STR_ ) || clonetype . equals Ignore Case ( STR_ ) ) { d *= ( NUM_ - ( blockdeduplicationratio / NUM_ ) ) ; } d = ( double ) Math . round ( d * NUM_ ) / NUM_ ; return d ; }
protected void fire Property Change ( String property Name , Object old Value , Object new Value ) { Property Change Support change Support ; synchronized ( get Object Lock ( ) ) { change Support = this . change Support ; } if ( change Support == null || ( old Value != null && new Value != null && old Value . equals ( new Value ) ) ) { return ; } change Support . fire Property Change ( property Name , old Value , new Value ) ; }
private final Result Set Row unpack Binary Result Set Row ( Field [ ] fields , Buffer binary Data , int result Set Concurrency ) throws SQL Exception { int num Fields = fields . length ; byte [ ] [ ] unpacked Row Data = new byte [ num Fields ] [ ] ; int null Count = ( num Fields + NUM_ ) / NUM_ ; int null Mask Pos = binary Data . get Position ( ) ; binary Data . set Position ( null Mask Pos + null Count ) ; int bit = NUM_ ; for ( int i = NUM_ ; i < num Fields ; i ++ ) { if ( ( binary Data . read Byte ( null Mask Pos ) & bit ) != NUM_ ) { unpacked Row Data [ i ] = null ; } else { if ( result Set Concurrency != Result Set . CONCUR UPDATABLE ) { extract Native Encoded Column ( binary Data , fields , i , unpacked Row Data ) ; } else { unpack Native Encoded Column ( binary Data , fields , i , unpacked Row Data ) ; } } if ( ( ( bit <<= NUM_ ) & NUM_ ) == NUM_ ) { bit = NUM_ ; null Mask Pos ++ ; } } return new Byte Array Row ( unpacked Row Data , get Exception Interceptor ( ) ) ; }
public Output Distribution ( String var ) { this . base Var = var . replace ( STR_ , STR_ ) ; this . primes = var . replace ( base Var , STR_ ) ; input Rules = new Array List < Anchored Rule > ( ) ; }
private void update Header Separator ( ) { String time Pattern ; if ( S Utils . is Api 18 Or Higher ( ) ) { time Pattern = Date Format . get Best Date Time Pattern ( m Current Locale , ( m Is 24 Hour View ) ? STR_ : STR_ ) ; } else { time Pattern = Date Time Pattern Helper . get Best Date Time Pattern ( m Current Locale , ( m Is 24 Hour View ) ? Date Time Pattern Helper . PATTERN Hm : Date Time Pattern Helper . PATTERN hm ) ; } final String separator Text ; final char [ ] hour Formats = { STR_ , STR_ , STR_ , STR_ } ; int h Index = last Index Of Any ( time Pattern , hour Formats ) ; if ( h Index == - NUM_ ) { separator Text = STR_ ; } else { separator Text = Character . to String ( time Pattern . char At ( h Index + NUM_ ) ) ; } m Separator View . set Text ( separator Text ) ; }
public boolean reopen Note ( Note bug ) { if ( ! bug . is New ( ) ) { Log . d ( DEBUG TAG , STR_ + bug . get Id ( ) ) ; Http URL Connection connection = null ; try { try { URL reopen Note Url = get Reopen Note Url ( Long . to String ( bug . get Id ( ) ) ) ; connection = open Connection For Write Access ( reopen Note Url , STR_ , STR_ ) ; if ( connection . get Response Code ( ) != Http URL Connection . HTTP OK ) { throw Unexpected Request Exception ( connection ) ; } parse Bug ( bug , connection . get Input Stream ( ) ) ; return true ; } catch ( Xml Pull Parser Exception e ) { Log . e ( DEBUG TAG , STR_ , e ) ; } catch ( IO Exception e ) { Log . e ( DEBUG TAG , STR_ , e ) ; } } finally { disconnect ( connection ) ; } } return false ; }
private void reset Arrays For Testing ( boolean [ ] fired , Distributed Member [ ] member , String [ ] member Id , boolean [ ] is Client ) { for ( int i = NUM_ ; i < fired . length ; i ++ ) { fired [ i ] = false ; member [ i ] = null ; member Id [ i ] = null ; is Client [ i ] = false ; } }
protected void request ( Request Context context , String key , String message ) { try { Http Servlet Request request = context . get Request ( ) ; String filename = request . get Remote Addr ( ) ; start ( filename , key , STR_ + request . get Method ( ) + STR_ + request . get Request URI ( ) + STR_ + message ) ; } catch ( Exception e ) { } }
public void close ( ) { if ( m Prepared Statement != null ) { try { m Prepared Statement . close ( ) ; m Prepared Statement = null ; } catch ( Exception e ) { } } }
protected Http Host determine Proxy ( Http Host target , Http Request request , Http Context context ) throws Http Exception { Proxy Selector psel = this . proxy Selector ; if ( psel == null ) psel = Proxy Selector . get Default ( ) ; if ( psel == null ) return null ; URI target URI = null ; try { target URI = new URI ( target . to URI ( ) ) ; } catch ( URI Syntax Exception usx ) { throw new Http Exception ( STR_ + target , usx ) ; } List < Proxy > proxies = psel . select ( target URI ) ; Proxy p = choose Proxy ( proxies , target , request , context ) ; Http Host result = null ; if ( p . type ( ) == Proxy . Type . HTTP ) { if ( ! ( p . address ( ) instanceof Inet Socket Address ) ) { throw new Http Exception ( STR_ + p . address ( ) ) ; } final Inet Socket Address isa = ( Inet Socket Address ) p . address ( ) ; result = new Http Host ( get Host ( isa ) , isa . get Port ( ) ) ; } return result ; }
protected String generate Label String ( Category Dataset dataset , int row , int column ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; String result ; Object [ ] items = create Item Array ( dataset , row , column ) ; result = Message Format . format ( this . label Format , items ) ; return result ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( ! ( obj instanceof Column Schema ) ) { return false ; } Column Schema other = ( Column Schema ) obj ; if ( column Name == null ) { if ( other . column Name != null ) { return false ; } } else if ( ! column Name . equals ( other . column Name ) ) { return false ; } return true ; }
public Gson Builder register Type Adapter Factory ( Type Adapter Factory factory ) { factories . add ( factory ) ; return this ; }
private void code Class For Name ( Class < ? > cl , Data Output Stream out ) throws IO Exception { code ldc ( cp . get String ( cl . get Name ( ) ) , out ) ; out . write Byte ( opc invokestatic ) ; out . write Short ( cp . get Method Ref ( STR_ , STR_ , STR_ ) ) ; }
private Message Digest clone Message Digest ( ) { try { return ( Message Digest ) message Digest . clone ( ) ; } catch ( Clone Not Supported Exception e ) { return get Message Digest ( ) ; } }
protected final void fire Vetoable Change ( String property Name , float old Value , float new Value ) throws Property Veto Exception { fire Vetoable Change ( property Name , Float . value Of ( old Value ) , Float . value Of ( new Value ) ) ; }
public static boolean is Empty ( @ Nullable String str ) { return str == null || str . is Empty ( ) ; }
public int read ( ) throws IO Exception { int temp ; byte tempbyte ; if ( frame Size == NUM_ ) { if ( conversion Type == PCM SWITCH SIGNED 8 BIT ) { temp = super . read ( ) ; if ( temp < NUM_ ) return temp ; tempbyte = ( byte ) ( temp & NUM_ ) ; tempbyte = ( tempbyte >= NUM_ ) ? ( byte ) ( NUM_ | tempbyte ) : ( byte ) ( NUM_ & tempbyte ) ; temp = ( int ) tempbyte & NUM_ ; return temp ; } else { throw new IO Exception ( STR_ ) ; } } else { throw new IO Exception ( STR_ ) ; } }
public static Delete Sub Command Handler create ( Sub Command Argument Parser parser , Managed Object Path < ? , ? > p , Optional Relation Definition < ? , ? > r ) throws Argument Exception { return new Delete Sub Command Handler ( parser , p , r , p . child ( r ) ) ; }
public static void sleep ( int t ) { try { Thread . sleep ( t ) ; } catch ( Interrupted Exception e ) { } }
private void report Exception Throw ( Element element , Throwable t ) { if ( element != null ) { log Message ( STR_ , element ) ; } log Exception ( t ) ; error Message ( element , STR_ , t , Arrays . to String ( Arrays . copy Of ( t . get Stack Trace ( ) , NUM_ ) ) ) ; }
int write ( int block index ) { on Disk Order . add ( block index ) ; return on Disk Order . size ( ) - NUM_ ; }
private void fill Packages ( Array List < Package > packages ) { if ( parent Class Loader != null ) { parent Class Loader . fill Packages ( packages ) ; } synchronized ( defined Packages ) { packages . add All ( defined Packages . values ( ) ) ; } }
public void unlock Flushing ( ) { flush Lock . unlock ( ) ; }
public boolean is Persistent ( ) { return m persist ; }
@ Visible For Testing protected static void add Attribute ( Class < ? extends Context > context Class , Attribute < ? > attribute ) { Set < String > attribute Names = CONTEXT CLASS TO ATTRIBUTES . get ( context Class ) ; if ( attribute Names == null ) { attribute Names = Sets . new Hash Set ( ) ; CONTEXT CLASS TO ATTRIBUTES . put ( context Class , attribute Names ) ; } attribute Names . add ( attribute . get Simple Name ( ) ) ; CONTEXT CLASSES . add ( context Class ) ; Map < String , Attribute < ? > > attribute Map = CONTEXT TO ATTRIBUTE NAME TO ATTRIBUTE . get ( context Class ) ; if ( attribute Map == null ) { attribute Map = Maps . new Hash Map ( ) ; CONTEXT TO ATTRIBUTE NAME TO ATTRIBUTE . put ( context Class , attribute Map ) ; } attribute Map . put ( attribute . get Simple Name ( ) , attribute ) ; }
protected void init Lookup ( ) { m lookup = new Hash Map ( ) ; for ( int i = NUM_ ; i < m names . length ; ++ i ) { m lookup . put ( m names [ i ] , new Integer ( i ) ) ; } }
public void run ( ) { final String method Name = STR_ ; Mqtt Token token = null ; while ( running && ( in != null ) ) { try { log . fine ( CLASS NAME , method Name , STR_ ) ; receiving = in . available ( ) > NUM_ ; Mqtt Wire Message message = in . read Mqtt Wire Message ( ) ; receiving = false ; if ( message instanceof Mqtt Ack ) { token = token Store . get Token ( message ) ; if ( token != null ) { synchronized ( token ) { client State . notify Received Ack ( ( Mqtt Ack ) message ) ; } } else { throw new Mqtt Exception ( Mqtt Exception . REASON CODE UNEXPECTED ERROR ) ; } } else { client State . notify Received Msg ( message ) ; } } catch ( Mqtt Exception ex ) { log . fine ( CLASS NAME , method Name , STR_ , null , ex ) ; running = false ; client Comms . shutdown Connection ( token , ex ) ; } catch ( IO Exception ioe ) { log . fine ( CLASS NAME , method Name , STR_ ) ; running = false ; if ( ! client Comms . is Disconnecting ( ) ) { client Comms . shutdown Connection ( token , new Mqtt Exception ( Mqtt Exception . REASON CODE CONNECTION LOST , ioe ) ) ; } } finally { receiving = false ; } } log . fine ( CLASS NAME , method Name , STR_ ) ; }
public Http Mon start ( ) { time Mon Index = NUM_ ; Iterator iter = iter ( ) ; while ( iter . has Next ( ) ) { Http Mon Item mon Item = ( Http Mon Item ) iter . next ( ) ; mon Item . start ( this ) ; } return this ; }
public Query Entry ( final String query , final int timezone Offset , final long message period , final Source Type source type , final boolean by User Query ) { this . query = query ; this . query length = query . length ( ) ; this . timezone Offset = timezone Offset ; this . source type = source type ; this . retrieval count = NUM_ ; this . message period = NUM_ ; this . messages per day = NUM_ ; this . score retrieval = NUM_ ; this . score suggest = NUM_ ; update ( message period , by User Query ) ; this . query first = retrieval last ; }
@ Override public boolean accepts ( Field field ) { return field . is Annotation Present ( Dialog Field . class ) ; }
public void add Data ( Data Set d ) { data Set . add ( d ) ; }
public static String print Collection ( Collection c ) { if ( c != null ) { String Buffer sb = new String Buffer ( STR_ ) ; Iterator itr = c . iterator ( ) ; while ( itr . has Next ( ) ) { sb . append ( itr . next ( ) ) ; if ( itr . has Next ( ) ) { sb . append ( STR_ ) ; } } sb . append ( STR_ ) ; return sb . to String ( ) ; } else { return STR_ ; } }
@ Override public int index Of ( Object object ) { return index Of ( object , NUM_ ) ; }
public static String [ ] split ( Char Sequence self ) { String Tokenizer st = new String Tokenizer ( self . to String ( ) ) ; String [ ] strings = new String [ st . count Tokens ( ) ] ; for ( int i = NUM_ ; i < strings . length ; i ++ ) { strings [ i ] = st . next Token ( ) ; } return strings ; }
private void replace With Language Model ( Constant Value constant Value ) { assert ( constant Value . get Value ( ) instanceof String ) ; String old String = ( String ) constant Value . get Value ( ) ; String LM Optimizer slmo = new String LM Optimizer ( constant Value , objective ) ; String new String = slmo . optimize ( ) ; constant Value . set Value ( new String ) ; if ( ! objective . is Not Worse ( ) ) { constant Value . set Value ( old String ) ; } }
protected void entering ( String method Name , Object [ ] params ) { if ( params != null ) { logger . entering ( class Name , method Name , params ) ; } else { logger . entering ( class Name , method Name ) ; } }
private void start Authentication Activity ( ) { Intent intent = new Intent ( Server Details . this , Authentication Activity . class ) ; intent . set Flags ( Intent . FLAG ACTIVITY CLEAR TOP ) ; start Activity ( intent ) ; }
public Node text No Encode ( final String text ) throws IO Exception { close Head ( ) ; m writer . write ( text ) ; m text ++ ; return this ; }
public static void close Quietly ( Statement stmt ) { if ( stmt == null ) { return ; } try { stmt . close ( ) ; } catch ( SQL Exception ex ) { } }
private void move Hosts ( double time Increment ) { for ( int i = NUM_ , n = hosts . size ( ) ; i < n ; i ++ ) { DTN Host host = hosts . get ( i ) ; host . move ( time Increment ) ; } }
public Proposition ( Proposition proposition ) { this . variable Source = proposition . variable Source ; this . allowed Categories = new boolean [ proposition . allowed Categories . length ] [ ] ; for ( int i = NUM_ ; i < allowed Categories . length ; i ++ ) { this . allowed Categories [ i ] = new boolean [ proposition . allowed Categories [ i ] . length ] ; System . arraycopy ( proposition . allowed Categories [ i ] , NUM_ , allowed Categories [ i ] , NUM_ , allowed Categories [ i ] . length ) ; } }
@ Override public OS Process Handler create Process Handler ( String working Directory , Map < String , String > env Variables ) throws Execution Exception { startup Process Handler . destroy Process ( ) ; Process Builder dummy Process = new Process Builder ( STR_ ) ; try { return new OS Process Handler ( dummy Process . start ( ) , Gct Bundle . get String ( STR_ ) ) ; } catch ( IO Exception ioe ) { throw new Execution Exception ( ioe ) ; } }
private byte [ ] concat ( byte [ ] ... arrays ) { int last Pos = NUM_ ; byte [ ] combined = new byte [ combined Length ( arrays ) ] ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , NUM_ , combined , last Pos , array . length ) ; last Pos += array . length ; } return combined ; }
synchronized Session create Session ( User user ) { if ( closing ) { return null ; } if ( exclusive Session != null ) { throw Db Exception . get ( Error Code . DATABASE IS IN EXCLUSIVE MODE ) ; } Session session = new Session ( this , user , ++ next Session Id ) ; user Sessions . add ( session ) ; trace . info ( STR_ , session . get Id ( ) , database Name ) ; if ( delayed Closer != null ) { delayed Closer . reset ( ) ; delayed Closer = null ; } return session ; }
private void finish String Section ( List < String Section > sections , String Section current Section , String Builder template Expressions , Position last Source Position , Position target Position ) { if ( current Section . last Source Position != null ) { return ; } current Section . last Source Position = new Position ( last Source Position ) ; sections . add ( current Section ) ; append ( template Expressions , target Position , STR_ + index ++ + STR_ ) ; current Section . last Target Position = new Position ( target Position . row , target Position . column ) ; }
private static Escape [ ] hex 2 Escapes ( char min , char max ) { Escape [ ] out = new Escape [ max - min + NUM_ ] ; for ( int i = NUM_ ; i < out . length ; ++ i ) { String Builder sb = new String Builder ( NUM_ ) ; char ch = ( char ) ( min + i ) ; try { hex 2 Escape ( ch , sb ) ; } catch ( IO Exception ex ) { throw new Something Widgy Happened Error ( STR_ , ex ) ; } out [ i ] = new Escape ( ch , sb . to String ( ) ) ; } return out ; }
private void walk ( File directory , int depth , Collection < T > results ) throws IO Exception { check If Cancelled ( directory , depth , results ) ; if ( handle Directory ( directory , depth , results ) ) { handle Directory Start ( directory , depth , results ) ; int child Depth = depth + NUM_ ; if ( depth Limit < NUM_ || child Depth <= depth Limit ) { check If Cancelled ( directory , depth , results ) ; File [ ] child Files = filter == null ? directory . list Files ( ) : directory . list Files ( filter ) ; child Files = filter Directory Contents ( directory , depth , child Files ) ; if ( child Files == null ) { handle Restricted ( directory , child Depth , results ) ; } else { for ( File child File : child Files ) { if ( child File . is Directory ( ) ) { walk ( child File , child Depth , results ) ; } else { check If Cancelled ( child File , child Depth , results ) ; handle File ( child File , child Depth , results ) ; check If Cancelled ( child File , child Depth , results ) ; } } } } handle Directory End ( directory , depth , results ) ; } check If Cancelled ( directory , depth , results ) ; }
private Startup Commands Holder unmarshal Startup Commands ( String file ) throws JAXB Exception , File Not Found Exception , XML Stream Exception { JAXB Context context = JAXB Context . new Instance ( Startup Commands Holder . class ) ; Unmarshaller um = context . create Unmarshaller ( ) ; XML Input Factory xif = XML Input Factory . new Factory ( ) ; xif . set Property ( XML Input Factory . IS SUPPORTING EXTERNAL ENTITIES , false ) ; xif . set Property ( XML Input Factory . SUPPORT DTD , false ) ; XML Stream Reader xsr = xif . create XML Stream Reader ( new File Input Stream ( file ) ) ; return ( Startup Commands Holder ) um . unmarshal ( xsr ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof XY Area Renderer 2 ) ) { return false ; } XY Area Renderer 2 that = ( XY Area Renderer 2 ) obj ; if ( this . show Outline != that . show Outline ) { return false ; } if ( ! Shape Utilities . equal ( this . legend Area , that . legend Area ) ) { return false ; } return super . equals ( obj ) ; }
public String shorten Pfeat ( String fea ) { String s = fea ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; s = s . replace ( STR_ , STR_ ) ; return s ; }
void add Fill ( int row , int col ) { Row View rv = get Row ( row ) ; if ( rv != null ) { rv . fill Column ( col ) ; } }
private void dump Routed Networks ( String prefix , Network network ) { String Buffer sb = new String Buffer ( ) ; sb . append ( prefix + STR_ ) ; sb . append ( STR_ + network . get Label ( ) + STR_ ) ; if ( network . get Routed Networks ( ) != null ) { for ( String str : network . get Routed Networks ( ) ) { sb . append ( STR_ + str ) ; } } else { sb . append ( STR_ ) ; } log . info ( sb . to String ( ) ) ; }
protected void print Predictions Header ( String Buffer out Buff , Abstract Output classification Output , String title ) { if ( classification Output . generates Output ( ) ) { out Buff . append ( STR_ + title + STR_ ) ; } classification Output . print Header ( ) ; }
public static String calculate MD 5 Request Digest ( String uri , String username , String password , String realm , String nonce , String nc , String cnonce , String qop ) { String req A 1 = username + STR_ + realm + STR_ + password ; String req A 2 = STR_ + uri ; String hash A 1 = checksum MD 5 ( req A 1 ) ; String hash A 2 = checksum MD 5 ( req A 2 ) ; String request Digest = digest MD 5 ( hash A 1 , nonce + STR_ + nc + STR_ + cnonce + STR_ + qop + STR_ + hash A 2 ) ; return request Digest ; }
private Element Key < ? , ? > calculate Key ( Element Key < ? , ? > key , Element Key < ? , ? > source Key ) { Class < ? > key Type = key . get Element Type ( ) ; Class < ? extends Element > source Type = source Key . get Element Type ( ) ; if ( key Type != source Type && key Type . is Assignable From ( source Type ) ) { key = Element Key . of ( key . get Id ( ) , key . get Datatype ( ) , source Type ) ; } return key ; }
public static double power Series ( double a , double b , double x ) { double s , t , u , v , n , t 1 , z , ai ; ai = NUM_ / a ; u = ( NUM_ - b ) * x ; v = u / ( a + NUM_ ) ; t 1 = v ; t = u ; n = NUM_ ; s = NUM_ ; z = MACHEP * ai ; while ( Math . abs ( v ) > z ) { u = ( n - b ) * x / n ; t *= u ; v = t / ( a + n ) ; s += v ; n += NUM_ ; } s += t 1 ; s += ai ; u = a * Math . log ( x ) ; if ( ( a + b ) < MAXGAM && Math . abs ( u ) < MAXLOG ) { t = gamma ( a + b ) / ( gamma ( a ) * gamma ( b ) ) ; s = s * t * Math . pow ( x , a ) ; } else { t = ln Gamma ( a + b ) - ln Gamma ( a ) - ln Gamma ( b ) + u + Math . log ( s ) ; if ( t < MINLOG ) { s = NUM_ ; } else { s = Math . exp ( t ) ; } } return s ; }
private Referer Lookup lookup Referer ( String referer Host , String referer Path , Boolean include Path ) { Referer Lookup referer = ( include Path ) ? referers . get ( referer Host + referer Path ) : referers . get ( referer Host ) ; if ( include Path && referer == null ) { final String [ ] path Elements = referer Path . split ( STR_ ) ; if ( path Elements . length > NUM_ ) { referer = referers . get ( referer Host + STR_ + path Elements [ NUM_ ] ) ; } } if ( referer == null ) { final int idx = referer Host . index Of ( STR_ ) ; if ( idx == - NUM_ ) { return null ; } else { return lookup Referer ( referer Host . substring ( idx + NUM_ ) , referer Path , include Path ) ; } } else { return referer ; } }
public void clean Up ( ) { Utils . LOGD ( TAG , STR_ ) ; m Context . stop Service ( new Intent ( m Context , Wcl Wearable Listener Service . class ) ) ; if ( ! m Watched Capabilities . is Empty ( ) ) { String [ ] capabilities = m Watched Capabilities . to Array ( new String [ m Watched Capabilities . size ( ) ] ) ; remove Capabilities ( capabilities ) ; } m Wear Consumers . clear ( ) ; }
public static boolean above Or Equal ( long a , long b ) { return Long . compare Unsigned ( a , b ) >= NUM_ ; }
@ After public void clear Source And Target Folder ( ) { delete Files ( source Folder ) ; delete Files ( target Folder ) ; }
public void add Listener ( Connectable Device Listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
@ Override public void visit Map Way ( Map Way way ) { Default Entity View Info p Info = ( Default Entity View Info ) way . get View Info ( ) ; List < Map Node > nodes = get Way Nodes ( way ) ; if ( ! nodes . is Empty ( ) && p Info . way Color != null ) { if ( p Info . way Fill Color != null && nodes . get ( NUM_ ) == nodes . get ( nodes . size ( ) - NUM_ ) && ( way . is Area ( ) || ! p Info . fill Areas Only ) ) area Buffer . add ( way ) ; else way Buffer . add ( way ) ; } if ( p Info . is Way Icon && p Info . icon != null ) node Buffer . add ( way ) ; }
private void calc Content Rect ( ) { Insets content Insets = get Content Border Insets ( tab Placement ) ; Rectangle bounds = tab Pane . get Bounds ( ) ; Insets insets = tab Pane . get Insets ( ) ; int cx ; int cy ; int cw ; int ch ; switch ( tab Placement ) { case LEFT : cx = tab Area Rect . x + tab Area Rect . width + content Insets . left ; cy = tab Area Rect . y + content Insets . top ; cw = bounds . width - insets . left - insets . right - tab Area Rect . width - content Insets . left - content Insets . right ; ch = bounds . height - insets . top - insets . bottom - content Insets . top - content Insets . bottom ; break ; case RIGHT : cx = insets . left + content Insets . left ; cy = insets . top + content Insets . top ; cw = bounds . width - insets . left - insets . right - tab Area Rect . width - content Insets . left - content Insets . right ; ch = bounds . height - insets . top - insets . bottom - content Insets . top - content Insets . bottom ; break ; case BOTTOM : cx = insets . left + content Insets . left ; cy = insets . top + content Insets . top ; cw = bounds . width - insets . left - insets . right - content Insets . left - content Insets . right ; ch = bounds . height - insets . top - insets . bottom - tab Area Rect . height - content Insets . top - content Insets . bottom ; break ; case TOP : default : cx = tab Area Rect . x + content Insets . left ; cy = tab Area Rect . y + tab Area Rect . height + content Insets . top ; cw = bounds . width - insets . left - insets . right - content Insets . left - content Insets . right ; ch = bounds . height - insets . top - insets . bottom - tab Area Rect . height - content Insets . top - content Insets . bottom ; } content Rect . set Bounds ( cx , cy , cw , ch ) ; }
public Rect update Fast Scroller Bounds ( Fast Scroll Recycler View recycler View , int thumb Offset Y ) { m Invalidate Rect . set ( m Bg Bounds ) ; if ( is Visible ( ) ) { int edge Padding = recycler View . get Scroll Bar Width ( ) ; int bg Padding = ( m Background Size - m Text Bounds . height ( ) ) / NUM_ ; int bg Height = m Background Size ; int bg Width = Math . max ( m Background Size , m Text Bounds . width ( ) + ( NUM_ * bg Padding ) ) ; if ( Utils . is Rtl ( m Res ) ) { m Bg Bounds . left = ( NUM_ * recycler View . get Scroll Bar Width ( ) ) ; m Bg Bounds . right = m Bg Bounds . left + bg Width ; } else { m Bg Bounds . right = recycler View . get Width ( ) - ( NUM_ * recycler View . get Scroll Bar Width ( ) ) ; m Bg Bounds . left = m Bg Bounds . right - bg Width ; } m Bg Bounds . top = thumb Offset Y - bg Height + recycler View . get Scroll Bar Thumb Height ( ) / NUM_ ; m Bg Bounds . top = Math . max ( edge Padding , Math . min ( m Bg Bounds . top , recycler View . get Height ( ) - edge Padding - bg Height ) ) ; m Bg Bounds . bottom = m Bg Bounds . top + bg Height ; } else { m Bg Bounds . set Empty ( ) ; } m Invalidate Rect . union ( m Bg Bounds ) ; return m Invalidate Rect ; }
public D View Csr ( J Frame parent , String title , PKCS 10 Certification Request pkcs 10 Csr ) throws Crypto Exception { super ( parent , title , Dialog . Modality Type . DOCUMENT MODAL ) ; this . pkcs 10 Csr = pkcs 10 Csr ; init Components ( ) ; }
public V peek ( K key ) { Entry < K , V > e = find ( key ) ; return e == null ? null : e . value ; }
public Eg Demand Details insert Advance Collection ( final String demand Reason , final Big Decimal advance Collection Amount , final Installment installment ) { Eg Demand Details demand Detail = null ; if ( advance Collection Amount != null && advance Collection Amount . compare To ( Big Decimal . ZERO ) > NUM_ ) { final Eg Demand Reason Master eg Demand Reason Master = demand Generic DAO . get Demand Reason Master By Code ( Water Tax Constants . DEMANDRSN CODE ADVANCE , module ( ) ) ; if ( eg Demand Reason Master == null ) throw new Application Runtime Exception ( STR_ ) ; final Eg Demand Reason eg Demand Reason = demand Generic DAO . get Dmd Reason By Dmd Reason Mster Install And Mod ( eg Demand Reason Master , installment , module ( ) ) ; if ( eg Demand Reason == null ) throw new Application Runtime Exception ( STR_ ) ; demand Detail = create Demand Details ( eg Demand Reason , advance Collection Amount , Big Decimal . ZERO ) ; } return demand Detail ; }
public static Jpa Module new Client Module ( String resource Search Package ) { return new Jpa Module ( resource Search Package ) ; }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { s . write Object ( my Syntax ) ; s . write Int ( size ( ) ) ; Enumeration < String > comps = get All ( ) ; while ( comps . has More Elements ( ) ) { s . write Object ( comps . next Element ( ) ) ; } }
protected void pop Navigation Stack ( ) { if ( base Form Navigation Stack != null && base Form Navigation Stack . size ( ) > NUM_ ) { base Form Navigation Stack . remove Element At ( base Form Navigation Stack . size ( ) - NUM_ ) ; } }
private static void create Notif Timer Thread ( ) { set Last Notif Time ( NUM_ ) ; notif Timeout Thread = new Thread ( new Notif Timeout Handler ( ) ) ; try { notif Timeout Thread . set Name ( STR_ ) ; } catch ( Security Exception e ) { Logger . Error ( STR_ ) ; } notif Timeout Thread . set Daemon ( true ) ; notif Timeout Thread . start ( ) ; }
public void load Tree ( Input Stream tree Stream ) throws IO Exception , Mary Configuration Exception { Mary CART Reader cart Reader = new Mary CART Reader ( ) ; this . tree = cart Reader . load From Stream ( tree Stream ) ; this . feature Definition = tree . get Feature Definition ( ) ; this . index Predicted Feature = feature Definition . get Feature Index ( PREDICTED STRING FEATURENAME ) ; this . convert To Lowercase = false ; Properties props = tree . get Properties ( ) ; if ( props == null ) throw new Illegal Argument Exception ( STR_ ) ; convert To Lowercase = Boolean . parse Boolean ( props . get Property ( STR_ ) ) ; context = Integer . parse Int ( props . get Property ( STR_ ) ) ; }
protected final void deserialize ( Object Input Stream ois , Collection coll ) throws IO Exception , Class Not Found Exception { int count = NUM_ ; count = ois . read Int ( ) ; while ( count -- > NUM_ ) { coll . add ( ois . read Object ( ) ) ; } }
public static double coefficient ( Number Vector x , Number Vector y ) { final int xdim = x . get Dimensionality ( ) ; final int ydim = y . get Dimensionality ( ) ; if ( xdim != ydim ) { throw new Illegal Argument Exception ( STR_ ) ; } double sum XX = NUM_ , sum YY = NUM_ , sum XY = NUM_ ; double mean X = x . double Value ( NUM_ ) , mean Y = y . double Value ( NUM_ ) ; int i = NUM_ ; while ( i < xdim ) { final double xv = x . double Value ( i ) , yv = y . double Value ( i ) ; final double delta X = xv - mean X ; final double delta Y = yv - mean Y ; ++ i ; mean X += delta X / i ; mean Y += delta Y / i ; final double nelta X = xv - mean X ; final double nelta Y = yv - mean Y ; sum XX += delta X * nelta X ; sum YY += delta Y * nelta Y ; sum XY += delta X * nelta Y ; } if ( ! ( sum XX > NUM_ && sum YY > NUM_ ) ) { return ( sum XX == sum YY ) ? NUM_ : NUM_ ; } return sum XY / Math . sqrt ( sum XX * sum YY ) ; }
public void enqueue ( ) { long current time = System . nano Time ( ) ; long previous = Math . max ( next , current time - history Size ) ; next = previous + delay ; avail = Math . max ( next , current time ) ; throttlers . add ( this ) ; }
public void fwd Dct Nx N ( int [ ] [ ] pixels , double [ ] [ ] dcts ) { int u = NUM_ ; int v = NUM_ ; double two over sqrtncolsnrows = NUM_ / Math . sqrt ( ( double ) this . N * this . M ) ; for ( u = NUM_ ; u < this . N ; u ++ ) { for ( v = NUM_ ; v < this . M ; v ++ ) { dcts [ u ] [ v ] = ( pixels [ u ] [ v ] - NUM_ ) ; } } for ( u = NUM_ ; u <= this . M - NUM_ ; u ++ ) { fct No Scale ( dcts [ u ] ) ; } for ( v = NUM_ ; v <= this . N - NUM_ ; v ++ ) { for ( u = NUM_ ; u <= this . M - NUM_ ; u ++ ) { this . nxn Tmp [ u ] = dcts [ u ] [ v ] ; } fct No Scale ( this . nxn Tmp ) ; for ( u = NUM_ ; u <= this . M - NUM_ ; u ++ ) { dcts [ u ] [ v ] = this . nxn Tmp [ u ] * two over sqrtncolsnrows ; } } }
public static Command new Instance ( Control Thread parent ) throws Security Exception , No Such Method Exception , Illegal Argument Exception , Instantiation Exception , Illegal Access Exception , Invocation Target Exception { final Constructor < ? extends Command > c = cmdclazz . get Constructor ( new Class [ ] { Control Thread . class } ) ; Command cmd = c . new Instance ( new Object [ ] { parent } ) ; cmd . set Daemon ( true ) ; return cmd ; }
public static void close Zip Entry ( Zip Output Stream out ) { try { out . close Entry ( ) ; } catch ( Exception ex ) { throw new Runtime Exception ( STR_ , ex ) ; } }
@ Override public void on Shared Preference Changed ( Shared Preferences a Shared Preferences , String a Key ) { if ( m Is Ui Update Skipped ) { Log . d ( LOG TAG , STR_ ) ; return ; } if ( a Key . equals ( PREF KEY ROOM PHOTO AVATAR ) ) { on Room Avatar Preference Changed ( ) ; } else if ( a Key . equals ( PREF KEY ROOM NAME ) ) { on Room Name Preference Changed ( ) ; } else if ( a Key . equals ( PREF KEY ROOM TOPIC ) ) { on Room Topic Preference Changed ( ) ; } else if ( a Key . equals ( PREF KEY ROOM MUTE NOTIFICATIONS SWITCH ) ) { on Room Mute Notifications Preference Changed ( ) ; } else if ( a Key . equals ( PREF KEY ROOM DIRECTORY VISIBILITY SWITCH ) ) { on Room Directory Visibility Preference Changed ( ) ; } else if ( a Key . equals ( PREF KEY ROOM TAG LIST ) ) { on Room Tag Preference Changed ( ) ; } else if ( a Key . equals ( PREF KEY ROOM ACCESS RULES LIST ) ) { on Room Access Preference Changed ( ) ; } else if ( a Key . equals ( PREF KEY ROOM HISTORY READABILITY LIST ) ) { on Room History Readability Preference Changed ( ) ; } else { Log . w ( LOG TAG , STR_ + a Key ) ; } }
private void remove Cookies For Redirects ( final Http Servlet Request request , final Http Servlet Response response ) { final Set < String > domains = Auth Client Utils . get Cookie Domains For Request ( request ) ; for ( String domain : domains ) { Cookie Utils . add Cookie To Response ( response , Cookie Utils . new Cookie ( Constants . AM LOCATION COOKIE , STR_ , NUM_ , STR_ , domain ) ) ; } }
public static void main ( String [ ] args ) { Apm Mock Server main = new Apm Mock Server ( ) ; main . run ( ) ; }
private void sort Child Drawing Order ( ) { if ( drawing Ordered Children == null ) { drawing Ordered Children = new Array List < > ( ) ; } else { drawing Ordered Children . clear ( ) ; } final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; drawing Ordered Children . add ( child ) ; } Collections . sort ( drawing Ordered Children , VIEW COMPARATOR ) ; }
public static Cipher Parameters make PBE Parameters ( PBE Key Spec key Spec , int type , int hash , int key Size , int iv Size ) { PBE Parameters Generator generator = make PBE Generator ( type , hash ) ; byte [ ] key ; Cipher Parameters param ; key = convert Password ( type , key Spec ) ; generator . init ( key , key Spec . get Salt ( ) , key Spec . get Iteration Count ( ) ) ; if ( iv Size != NUM_ ) { param = generator . generate Derived Parameters ( key Size , iv Size ) ; } else { param = generator . generate Derived Parameters ( key Size ) ; } for ( int i = NUM_ ; i != key . length ; i ++ ) { key [ i ] = NUM_ ; } return param ; }
protected void update All Nodes ( ) { updated Node List = update All List ; likelihood Known = false ; }
private void calculate Panning Speed ( ) { final int dux = dvx / PAN INERTIA ; final int duy = dvy / PAN INERTIA ; final int tspeed = ( ( dux * dux ) + ( duy * duy ) ) * PAN SCALE ; if ( speed > tspeed ) { speed = ( NUM_ * speed + tspeed ) / NUM_ ; if ( ( dvx != NUM_ ) || ( dvy != NUM_ ) ) { speed = Math . max ( speed , NUM_ ) ; } } else if ( speed < tspeed ) { speed += NUM_ ; } }
protected void sprint ( long long Field ) { sprint ( String . value Of ( long Field ) ) ; }
public void delete Host ( final String host Name ) { if ( host Name == null ) throw new Illegal Argument Exception ( ) ; known Hosts . remove ( host Name ) ; }
public void emit Replayed Tuples ( Prepared Statement ps ) { Result Set rs = null ; try ( Prepared Statement p Stat = ps ) { p Stat . set Fetch Size ( get Fetch Size ( ) ) ; rs = p Stat . execute Query ( ) ; if ( rs == null || rs . is Closed ( ) ) { return ; } while ( rs . next ( ) ) { emit Tuple ( get Tuple ( rs ) ) ; last Emitted Row ++ ; } } catch ( SQL Exception ex ) { throw new Runtime Exception ( ex ) ; } }
protected static Map attr Set To Map ( Attr Set attr Set , boolean fetch Byte Values ) { Map attributes Map = new AM Hash Map ( fetch Byte Values ) ; if ( attr Set == null ) { return attributes Map ; } int attr Set Size = attr Set . size ( ) ; if ( ! fetch Byte Values ) { for ( int i = NUM_ ; i < attr Set Size ; i ++ ) { Attr attr = attr Set . element At ( i ) ; String values [ ] = attr . get String Values ( ) ; attributes Map . put ( attr . get Name ( ) , string Array To Set ( values ) ) ; } } else { for ( int i = NUM_ ; i < attr Set Size ; i ++ ) { Attr attr = attr Set . element At ( i ) ; attributes Map . put ( attr . get Name ( ) , attr . get Byte Values ( ) ) ; } } return attributes Map ; }
public void add On Change Listener ( On Change Listener on Change Listener ) { m On Change Listeners . add ( on Change Listener ) ; }
@ Override public Throwable fill In Stack Trace ( ) { return this ; }
private void update Child Clipping And Background ( Stack Scroll State . View State state , float real Height , float clip Height , float background Height ) { if ( real Height > clip Height ) { state . top Over Lap = ( int ) Math . floor ( ( real Height - clip Height ) / state . scale ) ; } else { state . top Over Lap = NUM_ ; } if ( real Height > background Height ) { state . clip Top Amount = ( int ) Math . floor ( ( real Height - background Height ) / state . scale ) ; } else { state . clip Top Amount = NUM_ ; } }
protected void index Points ( Input Stream is , long ptr , List < Entry > entries ) { boolean more Records = true ; byte r Hdr [ ] = new byte [ SHAPE RECORD HEADER LENGTH ] ; int result ; int n Records = NUM_ ; int rec Length Words , rec Length Bytes ; long rec Offset ; int shape Type ; int rec Buf Size = NUM_ ; byte rec Buf [ ] = new byte [ rec Buf Size ] ; double x = NUM_ ; double y = NUM_ ; try { while ( more Records ) { result = is . read ( r Hdr , NUM_ , SHAPE RECORD HEADER LENGTH ) ; if ( result < NUM_ ) { more Records = false ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + n Records + STR_ ) ; logger . fine ( STR_ + rec Buf Size ) ; } } else { n Records ++ ; rec Offset = ptr ; read BE Int ( r Hdr , NUM_ ) ; rec Length Words = read BE Int ( r Hdr , NUM_ ) ; rec Length Bytes = rec Length Words * NUM_ ; if ( rec Length Bytes > rec Buf Size ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + rec Length Bytes ) ; } rec Buf Size = rec Length Bytes ; rec Buf = new byte [ rec Buf Size ] ; } result = is . read ( rec Buf , NUM_ , rec Length Bytes ) ; shape Type = read LE Int ( rec Buf , NUM_ ) ; if ( shape Type != SHAPE TYPE NULL ) { x = read LE Double ( rec Buf , NUM_ ) ; y = read LE Double ( rec Buf , NUM_ ) ; } ptr += rec Length Bytes + NUM_ ; Entry entry = new Entry ( x , y , x , y , ( int ) rec Offset ) ; entries . add ( entry ) ; } } } catch ( java . io . IO Exception e ) { e . print Stack Trace ( ) ; } finally { try { is . close ( ) ; } catch ( java . io . IO Exception e ) { } } }
public static void close Quietly ( Result Set rs ) { if ( rs == null ) { return ; } try { rs . close ( ) ; } catch ( SQL Exception ex ) { } }
private boolean has Loop ( int parent Category Id , Vector < Simple Tree Node > categories , int loop Indicator Id ) { final Iterator < Simple Tree Node > iter = categories . iterator ( ) ; boolean ret = false ; while ( iter . has Next ( ) ) { Simple Tree Node node = ( Simple Tree Node ) iter . next ( ) ; if ( node . get Node Id ( ) == parent Category Id ) { if ( node . get Parent Id ( ) == NUM_ ) { return false ; } if ( node . get Node Id ( ) == loop Indicator Id ) { return true ; } ret = has Loop ( node . get Parent Id ( ) , categories , loop Indicator Id ) ; } } return ret ; }
@ Override public long create Back Buffer ( X 11 Component Peer peer , int num Buffers , Buffer Capabilities caps ) throws AWT Exception { if ( num Buffers > NUM_ ) { throw new AWT Exception ( STR_ ) ; } Buffer Capabilities config Caps = get Buffer Capabilities ( ) ; if ( ! config Caps . is Page Flipping ( ) ) { throw new AWT Exception ( STR_ ) ; } if ( caps . get Flip Contents ( ) == Buffer Capabilities . Flip Contents . PRIOR ) { throw new AWT Exception ( STR_ ) ; } return NUM_ ; }
@ Nullable private Eml read Metadata ( String shortname , Archive archive , Action Logger alog ) { Eml eml ; File eml File = archive . get Metadata Location File ( ) ; try { if ( eml File == null || ! eml File . exists ( ) ) { eml File = new File ( archive . get Location ( ) , Data Dir . EML XML FILENAME ) ; } if ( eml File . exists ( ) ) { eml = copy Metadata ( shortname , eml File ) ; alog . info ( STR_ ) ; return eml ; } else { log . warn ( STR_ ) ; } } catch ( Import Exception e ) { String msg = STR_ + e . get Message ( ) ; log . warn ( msg ) ; alog . warn ( msg ) ; return null ; } catch ( Exception e ) { log . warn ( STR_ , e ) ; } try { eml = convert Metadata To Eml ( archive . get Metadata ( ) ) ; alog . info ( STR_ ) ; return eml ; } catch ( Exception e ) { log . warn ( STR_ + e . get Message ( ) ) ; } alog . warn ( STR_ ) ; return null ; }
public Decision Support ( Map h Category Estimations , String s Suggested Category , String s Correct Category ) { Category Estimations = new Tree Map ( ) ; Category Estimations . put All ( h Category Estimations ) ; Suggested Category = new String ( s Suggested Category ) ; Correct Category = new String ( s Correct Category ) ; }
public static boolean is Self Issued ( X 509 Certificate cert ) { X 500 Principal subject = cert . get Subject X 500 Principal ( ) ; X 500 Principal issuer = cert . get Issuer X 500 Principal ( ) ; return subject . equals ( issuer ) ; }
public Wildcard Filter ( String [ ] wildcards ) { if ( wildcards == null ) { throw new Illegal Argument Exception ( STR_ ) ; } this . wildcards = new String [ wildcards . length ] ; System . arraycopy ( wildcards , NUM_ , this . wildcards , NUM_ , wildcards . length ) ; }
protected Json Deserializer < Object > find Subclass Deserializer ( Deserialization Context ctxt , Object bean , Token Buffer unknown Tokens ) throws IO Exception , Json Processing Exception { Json Deserializer < Object > sub Deser ; synchronized ( this ) { sub Deser = ( sub Deserializers == null ) ? null : sub Deserializers . get ( new Class Key ( bean . get Class ( ) ) ) ; } if ( sub Deser != null ) { return sub Deser ; } Deserializer Provider deser Prov = ctxt . get Deserializer Provider ( ) ; if ( deser Prov != null ) { Java Type type = ctxt . construct Type ( bean . get Class ( ) ) ; sub Deser = deser Prov . find Value Deserializer ( ctxt . get Config ( ) , type , property ) ; if ( sub Deser != null ) { synchronized ( this ) { if ( sub Deserializers == null ) { sub Deserializers = new Hash Map < Class Key , Json Deserializer < Object > > ( ) ; ; } sub Deserializers . put ( new Class Key ( bean . get Class ( ) ) , sub Deser ) ; } } } return sub Deser ; }
private void emit List Add ( Method method , String field Name , String Builder builder ) { builder . append ( STR_ ) ; builder . append ( get List Adder Name ( field Name ) ) ; builder . append ( STR_ ) ; builder . append ( get Type Argument Impl Name ( ( Parameterized Type ) method . get Generic Return Type ( ) , NUM_ ) ) ; builder . append ( STR_ ) ; builder . append ( get Ensure Name ( field Name ) ) ; builder . append ( STR_ ) ; builder . append ( field Name ) ; builder . append ( STR_ ) ; builder . append ( STR_ ) ; }
@ Override public void compute Scroll ( ) { if ( ! is In Edit Mode ( ) && m View Drag Helper . continue Settling ( true ) ) { View Compat . post Invalidate On Animation ( this ) ; } }
public void start Trace ( ) throws Mqtt Exception { trace Enabled = true ; }
@ Deprecated @ Override public void recycle ( ) { LOG . trace ( STR_ ) ; clear Request Body ( ) ; request Content Length = Input Stream Request Entity . CONTENT LENGTH AUTO ; repeat Count = NUM_ ; chunked = false ; super . recycle ( ) ; }
protected static void mid Point Step ( double fracdim , int size , int delta , int elevation Map [ ] [ ] , int step , boolean new Border ) { int d 1 , d 2 ; int delta 5 ; int x , y ; d 1 = size > > ( step - NUM_ ) ; d 2 = d 1 / NUM_ ; fracdim = ( NUM_ - fracdim ) / NUM_ ; delta = ( int ) ( delta * Math . exp ( - NUM_ * fracdim * ( NUM_ * step - NUM_ ) ) ) ; delta 5 = delta << NUM_ ; x = d 2 ; do { y = d 2 ; do { elevation Map [ x ] [ y ] = middle Value ( elevation Map [ x + d 2 ] [ y + d 2 ] , elevation Map [ x + d 2 ] [ y - d 2 ] , elevation Map [ x - d 2 ] [ y + d 2 ] , elevation Map [ x - d 2 ] [ y - d 2 ] , delta 5 ) ; y += d 1 ; } while ( y < size - d 2 ) ; x += d 1 ; } while ( x < size - d 2 ) ; delta = ( int ) ( delta * Math . exp ( - NUM_ * fracdim ) ) ; delta 5 = delta << NUM_ ; if ( new Border ) { x = d 2 ; do { y = x ; elevation Map [ NUM_ ] [ x ] = middle Value ( elevation Map [ NUM_ ] [ x + d 2 ] , elevation Map [ NUM_ ] [ x - d 2 ] , elevation Map [ d 2 ] [ x ] , delta 5 ) ; elevation Map [ size ] [ x ] = middle Value ( elevation Map [ size - NUM_ ] [ x + d 2 ] , elevation Map [ size - NUM_ ] [ x - d 2 ] , elevation Map [ size - d 2 - NUM_ ] [ x ] , delta 5 ) ; y = NUM_ ; elevation Map [ x ] [ NUM_ ] = middle Value ( elevation Map [ x + d 2 ] [ NUM_ ] , elevation Map [ x - d 2 ] [ NUM_ ] , elevation Map [ x ] [ d 2 ] , delta 5 ) ; elevation Map [ x ] [ size ] = middle Value ( elevation Map [ x + d 2 ] [ size - NUM_ ] , elevation Map [ x - d 2 ] [ size - NUM_ ] , elevation Map [ x ] [ size - d 2 - NUM_ ] , delta 5 ) ; x += d 1 ; } while ( x < size - d 2 ) ; } diag Mid ( new Point ( d 2 , d 1 ) , d 1 , d 2 , delta 5 , size , elevation Map ) ; diag Mid ( new Point ( d 1 , d 2 ) , d 1 , d 2 , delta 5 , size , elevation Map ) ; }
static File create Segment File ( String name , File directory , long id , long version ) { return new File ( directory , String . format ( STR_ , Assert . not Null ( name , STR_ ) , id , version ) ) ; }
public static void load Window Properties ( Window window ) { on Load Position ( window ) ; }
@ Override public void init Params ( Http Servlet Request request , I Configuration configuration , Object ... params ) throws Connector Exception { super . init Params ( request , configuration ) ; this . files = new Array List < > ( ) ; get Files List From Request ( request ) ; }
synchronized int allocate ( Glow Entity entity ) { if ( entity . id != NUM_ ) { throw new Illegal State Exception ( STR_ ) ; } int started At = last Id ; for ( int id = last Id + NUM_ ; id != started At ; ++ id ) { if ( id == - NUM_ || id == NUM_ ) continue ; if ( used Ids . add ( id ) ) { entity . id = id ; last Id = id ; return id ; } } throw new Illegal State Exception ( STR_ ) ; }
public boolean cg Create Rollback Step ( URI rp System Id , List < Volume Descriptor > volume Descriptors , String token ) throws Workflow Exception { log . info ( STR_ ) ; Workflow Step Completer . step Executing ( token ) ; List < Volume Descriptor > source Volume Descriptors = Volume Descriptor . filter By Type ( volume Descriptors , new Volume Descriptor . Type [ ] { Volume Descriptor . Type . RP SOURCE , Volume Descriptor . Type . RP EXISTING SOURCE , Volume Descriptor . Type . RP VPLEX VIRT SOURCE } , new Volume Descriptor . Type [ ] { } ) ; List < Volume Descriptor > journal Volume Descriptors = Volume Descriptor . filter By Type ( volume Descriptors , new Volume Descriptor . Type [ ] { Volume Descriptor . Type . RP JOURNAL , Volume Descriptor . Type . RP VPLEX VIRT JOURNAL } , new Volume Descriptor . Type [ ] { } ) ; if ( source Volume Descriptors == null || source Volume Descriptors . is Empty ( ) ) { Workflow Step Completer . step Succeded ( token ) ; return true ; } List < URI > volume I Ds = new Array List < URI > ( ) ; for ( Volume Descriptor descriptor : source Volume Descriptors ) { volume I Ds . add ( descriptor . get Volume URI ( ) ) ; } List < URI > journal Volume I Ds = new Array List < URI > ( ) ; for ( Volume Descriptor journal Descriptor : journal Volume Descriptors ) { journal Volume I Ds . add ( journal Descriptor . get Volume URI ( ) ) ; } return cg Delete Step ( rp System Id , volume I Ds , journal Volume I Ds , token ) ; }
public static String clean Leading And Trailing New Line And Chars ( String input ) { if ( ! String Utils . has Text ( input ) ) { return input ; } String output = input ; output = output . replace All ( STR_ , STR_ ) ; while ( output . starts With ( STR_ ) || output . starts With ( STR_ ) || output . starts With ( STR_ ) || output . starts With ( STR_ ) || output . starts With ( STR_ ) || output . starts With ( STR_ ) || output . starts With ( STR_ ) ) { output = output . substring ( NUM_ ) ; } while ( output . ends With ( STR_ ) || output . ends With ( STR_ ) || output . ends With ( STR_ ) || output . ends With ( STR_ ) || output . ends With ( STR_ ) || output . ends With ( STR_ ) || output . ends With ( STR_ ) ) { output = output . substring ( NUM_ , output . length ( ) - NUM_ ) ; } return output ; }
public void print ( Dict Node root ) { print ( root , System . out ) ; }
public void check Jvm Classes Verbose Level ( Enum Jvm Classes Verbose Level x ) throws Snmp Status Exception { if ( Jvm Classes Verbose Level Verbose . equals ( x ) ) return ; if ( Jvm Classes Verbose Level Silent . equals ( x ) ) return ; throw new Snmp Status Exception ( Snmp Status Exception . snmp Rsp Wrong Value ) ; }
private boolean types Match ( Class < V > value Type , Class getter Type ) { if ( getter Type != value Type ) { if ( getter Type . is Primitive ( ) ) { return ( getter Type == float . class && value Type == Float . class ) || ( getter Type == int . class && value Type == Integer . class ) || ( getter Type == boolean . class && value Type == Boolean . class ) || ( getter Type == long . class && value Type == Long . class ) || ( getter Type == double . class && value Type == Double . class ) || ( getter Type == short . class && value Type == Short . class ) || ( getter Type == byte . class && value Type == Byte . class ) || ( getter Type == char . class && value Type == Character . class ) ; } return false ; } return true ; }
private void save Window State ( Window window ) { if ( ! location Set . contains ( window ) && window != primary Window ) { return ; } State Item item = windows . get ( window ) ; Point location = window . get Location ( ) ; String state = location . x + STR_ + location . y ; Dimension size = window . get Size ( ) ; state += STR_ + size . width + STR_ + size . height ; state += STR_ + ( window . is Visible ( ) ? STR_ : STR_ ) ; settings . map Put ( SETTING , item . id , state ) ; }
public boolean remove Update ( final Password password ) throws IO Exception , Servlet Exception { if ( ! singelton . can ( CFML Engine . CAN UPDATE , password ) ) throw new IO Exception ( STR_ ) ; return remove Update ( ) ; }
public static File index File Name ( File data ) { return new File ( data . get Parent File ( ) , data . get Name ( ) + TABIX EXTENSION ) ; }
synchronized void redo ( RT Edit Text editor ) { Stack < Operation > redo Stack = get Redo Stack ( editor ) ; if ( ! redo Stack . empty ( ) ) { Stack < Operation > undo Stack = get Undo Stack ( editor ) ; Operation op = redo Stack . pop ( ) ; push ( op , undo Stack ) ; op . redo ( editor ) ; while ( ! redo Stack . empty ( ) && op . can Merge ( redo Stack . peek ( ) ) ) { op = redo Stack . pop ( ) ; push ( op , undo Stack ) ; op . redo ( editor ) ; } } }
public void load Chats ( ) { log . fine ( STR_ + m vo . Tab No ) ; if ( ! can Have Attachment ( ) ) return ; String sql = STR_ + STR_ ; try { if ( m Chats == null ) m Chats = new Hash Map < Integer , Integer > ( ) ; else m Chats . clear ( ) ; Prepared Statement pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM_ , m vo . AD Table ID ) ; Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { Integer key = new Integer ( rs . get Int ( NUM_ ) ) ; Integer value = new Integer ( rs . get Int ( NUM_ ) ) ; m Chats . put ( key , value ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } log . config ( STR_ + m Chats . size ( ) ) ; }
public void paint Border ( Component c , Graphics g , int x , int y , int width , int height ) { int w = width ; int h = height ; g . translate ( x , y ) ; g . set Color ( etch Type == LOWERED ? get Shadow Color ( c ) : get Highlight Color ( c ) ) ; g . draw Rect ( NUM_ , NUM_ , w - NUM_ , h - NUM_ ) ; g . set Color ( etch Type == LOWERED ? get Highlight Color ( c ) : get Shadow Color ( c ) ) ; g . draw Line ( NUM_ , h - NUM_ , NUM_ , NUM_ ) ; g . draw Line ( NUM_ , NUM_ , w - NUM_ , NUM_ ) ; g . draw Line ( NUM_ , h - NUM_ , w - NUM_ , h - NUM_ ) ; g . draw Line ( w - NUM_ , h - NUM_ , w - NUM_ , NUM_ ) ; g . translate ( - x , - y ) ; }
public void next Entry ( Zip Entry ze ) throws IO Exception { LOG . fine ( STR_ + current Pos ) ; byte [ ] int Buffer = new byte [ NUM_ ] ; int bytes Read = fis . read ( int Buffer ) ; LOG . fine ( STR_ + bytes Read ) ; if ( bytes Read == - NUM_ ) { throw new IO Exception ( STR_ + fis . available ( ) ) ; } int data Descriptor Length = NUM_ ; if ( Arrays . equals ( int Buffer , new byte [ ] { NUM_ , NUM_ , NUM_ , NUM_ } ) ) { data Descriptor Length = NUM_ + NUM_ + NUM_ ; fis . skip ( data Descriptor Length ) ; fis . read ( int Buffer ) ; } if ( ! Arrays . equals ( int Buffer , new byte [ ] { NUM_ , NUM_ , NUM_ , NUM_ } ) ) { throw new IO Exception ( STR_ + Byte Array Helper . to String ( int Buffer ) ) ; } boolean has Data Descriptor = ( ze . get Method ( ) & NUM_ ) > NUM_ ; LOG . fine ( STR_ + has Data Descriptor ) ; this . compressed Size = ze . get Compressed Size ( ) ; fis . skip ( NUM_ + NUM_ + NUM_ ) ; byte [ ] short Buffer = new byte [ NUM_ ] ; fis . read ( short Buffer ) ; int file Name Length = Byte Array Helper . to Int ( short Buffer ) ; fis . read ( short Buffer ) ; int extra Field Length = Byte Array Helper . to Int ( short Buffer ) ; start Pos = NUM_ + NUM_ + file Name Length + extra Field Length + data Descriptor Length ; current Pos = start Pos ; end Pos = start Pos + this . compressed Size ; fis . skip ( file Name Length + extra Field Length ) ; }
private String print D Format ( int x ) { return print D Format ( Integer . to String ( x ) ) ; }
public static boolean reschedule Expiration ( Cache cache , Object key , int new Exp Time ) { Scheduled Future f = expiry Futures . get ( key ) ; if ( f != null ) { if ( f . cancel ( false ) ) { Scheduled Future f 2 = expiry Executor . schedule ( new Expiry Task ( cache , key ) , new Exp Time , Time Unit . SECONDS ) ; expiry Futures . put ( key , f 2 ) ; return true ; } } return false ; }
private boolean ensure Scroll Wheel Adjusted ( ) { int delta Y = m Initial Scroll Offset - m Current Scroll Offset ; if ( delta Y != NUM_ ) { m Previous Scroller Y = NUM_ ; if ( Math . abs ( delta Y ) > m Selector Element Height / NUM_ ) { delta Y += ( delta Y > NUM_ ) ? - m Selector Element Height : m Selector Element Height ; } m Adjust Scroller . start Scroll ( NUM_ , NUM_ , NUM_ , delta Y , SELECTOR ADJUSTMENT DURATION MILLIS ) ; invalidate ( ) ; return true ; } return false ; }
public Object before Encode ( mx Codec enc , Object obj , Node node ) { return obj ; }
@ Deprecated public boolean allow Thread Suspension ( boolean b ) { this . vm Allow Suspension = b ; if ( ! b ) { VM . unsuspend Some Threads ( ) ; } return true ; }
protected void remove Next Protocol Messages ( List < Protocol Message > protocol Messages , int from Index ) { for ( int i = protocol Messages . size ( ) - NUM_ ; i >= from Index ; i -- ) { protocol Messages . remove ( i ) ; } }
public void combine ( Stats o ) { max = Math . max ( max , o . max ) ; min = Math . min ( min , o . min ) ; m = m * ( n / ( double ) ( n + o . n ) ) + o . m * ( o . n / ( double ) ( n + o . n ) ) ; s = Double . Na N ; n += o . n ; }
protected void init Key Holder Class ( ) throws Messaging Exception { String key Holder Class Name = get Init Parameter ( STR_ ) ; if ( key Holder Class Name == null ) { throw new Messaging Exception ( STR_ ) ; } try { set Key Holder Class ( Class . for Name ( key Holder Class Name ) ) ; } catch ( Class Not Found Exception cnfe ) { throw new Messaging Exception ( STR_ + key Holder Class Name ) ; } if ( is Debug ( ) ) { log ( STR_ + get Key Holder Class ( ) ) ; } }
public static Injector create Injector ( Module ... modules ) { return create Injector ( Arrays . as List ( modules ) ) ; }
public Default File Filter ( String extension , String description ) { ext = extension . to Lower Case ( ) ; desc = description ; }
@ Override public Request < List < Runner Status > > processes ( Project Reference project Reference ) { List < Dummy Runner Status > current = current Runner Statuses . get ( project Reference . name ( ) ) ; List < Runner Status > update = new Array List < > ( ) ; if ( current != null ) { for ( Dummy Runner Status dummy Runner Status : current ) { update . add ( dummy Runner Status ) ; } } return new Dummy Request < > ( update ) ; }
public void verify ( int max Doc ) throws IO Exception { byte [ ] root Min Packed = new byte [ packed Bytes Length ] ; byte [ ] root Max Packed = new byte [ packed Bytes Length ] ; Arrays . fill ( root Max Packed , ( byte ) NUM_ ) ; verify ( get Intersect State ( new Verify Visitor ( num Dims , bytes Per Dim , max Doc ) ) , NUM_ , root Min Packed , root Max Packed ) ; }
private static List < Object > array To List ( final Object array ) { if ( array instanceof Object [ ] ) return Arrays . as List ( ( Object [ ] ) array ) ; List < Object > result = new Array List < Object > ( ) ; if ( array instanceof int [ ] ) for ( int value : ( int [ ] ) array ) result . add ( value ) ; else if ( array instanceof boolean [ ] ) for ( boolean value : ( boolean [ ] ) array ) result . add ( value ) ; else if ( array instanceof long [ ] ) for ( long value : ( long [ ] ) array ) result . add ( value ) ; else if ( array instanceof float [ ] ) for ( float value : ( float [ ] ) array ) result . add ( value ) ; else if ( array instanceof double [ ] ) for ( double value : ( double [ ] ) array ) result . add ( value ) ; else if ( array instanceof short [ ] ) for ( short value : ( short [ ] ) array ) result . add ( value ) ; else if ( array instanceof byte [ ] ) for ( byte value : ( byte [ ] ) array ) result . add ( value ) ; else if ( array instanceof char [ ] ) for ( char value : ( char [ ] ) array ) result . add ( value ) ; return result ; }
protected void draw Projection Background ( Graphics g ) { if ( g instanceof Graphics 2 D ) { projection . draw Background ( ( Graphics 2 D ) g , get Bckgrnd ( ) ) ; } else { g . set Color ( get Background ( ) ) ; projection . draw Background ( g ) ; } }
final Node < K , V > find Near ( K key , int rel , Comparator < ? super K > cmp ) { if ( key == null ) throw new Null Pointer Exception ( ) ; for ( ; ; ) { for ( Node < K , V > b = find Predecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; if ( n == null ) return ( ( rel & LT ) == NUM_ || b . is Base Header ( ) ) ? null : b ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; int c = cpr ( cmp , key , n . key ) ; if ( ( c == NUM_ && ( rel & EQ ) != NUM_ ) || ( c < NUM_ && ( rel & LT ) == NUM_ ) ) return n ; if ( c <= NUM_ && ( rel & LT ) != NUM_ ) return b . is Base Header ( ) ? null : b ; b = n ; n = f ; } } }
private void add Observed File ( String local Path , Account account ) { File file = new File ( local Path ) ; String parent Path = file . get Parent ( ) ; Folder Observer observer = m Folder Observers Map . get ( parent Path ) ; if ( observer == null ) { observer = new Folder Observer ( parent Path , account , get Application Context ( ) ) ; m Folder Observers Map . put ( parent Path , observer ) ; Log OC . d ( TAG , STR_ + parent Path + STR_ ) ; } observer . start Watching ( file . get Name ( ) ) ; Log OC . d ( TAG , STR_ + local Path + STR_ ) ; }
private void add Solution Users To Group ( String group Name , Collection < Principal Id > users ) throws Exception { throw new Not Implemented Error ( STR_ ) ; }
public void add Callback Pull ( I Callback callback ) { callbacks Pull . add ( callback ) ; }
public void add State ( int [ ] specs , Animator animation , Animator . Animator Listener listener ) { Tuple tuple = new Tuple ( specs , animation , listener ) ; animation . add Listener ( m Animation Listener ) ; m Tuples . add ( tuple ) ; }
public Explanation idf Explain ( Collection Statistics collection Stats , Term Statistics term Stats [ ] ) { final long doc Count = collection Stats . doc Count ( ) == - NUM_ ? collection Stats . max Doc ( ) : collection Stats . doc Count ( ) ; float idf = NUM_ ; List < Explanation > subs = new Array List < > ( ) ; for ( final Term Statistics stat : term Stats ) { final long df = stat . doc Freq ( ) ; final float term Idf = idf ( df , doc Count ) ; subs . add ( Explanation . match ( term Idf , STR_ + df + STR_ + doc Count + STR_ ) ) ; idf += term Idf ; } return Explanation . match ( idf , STR_ , subs ) ; }
final boolean try Read Lock ( ) { Thread current = Thread . current Thread ( ) ; for ( ; ; ) { int c = get State ( ) ; if ( exclusive Count ( c ) != NUM_ && get Exclusive Owner Thread ( ) != current ) return false ; int r = shared Count ( c ) ; if ( r == MAX COUNT ) throw new Error ( STR_ ) ; if ( compare And Set State ( c , c + SHARED UNIT ) ) { if ( r == NUM_ ) { first Reader = current ; first Reader Hold Count = NUM_ ; } else if ( first Reader == current ) { first Reader Hold Count ++ ; } else { Hold Counter rh = cached Hold Counter ; if ( rh == null || rh . tid != current . get Id ( ) ) cached Hold Counter = rh = read Holds . get ( ) ; else if ( rh . count == NUM_ ) read Holds . set ( rh ) ; rh . count ++ ; } return true ; } } }
protected SIP Transaction Stack ( Stack Message Factory message Factory ) { this ( ) ; this . sip Message Factory = message Factory ; }
public static Transaction round Trip Transaction ( Network Parameters params , Transaction tx ) throws IO Exception , Protocol Exception { Bitcoin Serializer bs = new Bitcoin Serializer ( params ) ; Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; bs . serialize ( tx , bos ) ; return ( Transaction ) bs . deserialize ( Byte Buffer . wrap ( bos . to Byte Array ( ) ) ) ; }
private void notify Listeners ( Object object , Json Object config ) { for ( Property Change Listener config Update : listener ) { config Update . property Change ( new Property Change Event ( this , STR_ , config , config ) ) ; } }
public static void front End Initialize ( Spec Obj spec , Print Stream syserr ) throws Init Exception { String file Name = spec . get File Name ( ) ; Errors init Errors = spec . init Errors ; try { Configuration . Re Init ( ) ; Context . re Init ( ) ; Configuration . load ( init Errors ) ; Built In Level . load ( ) ; if ( ! init Errors . is Success ( ) ) { syserr . println ( STR_ ) ; syserr . print ( init Errors ) ; spec . error Level = NUM_ ; throw new Init Exception ( ) ; } } catch ( Exception e ) { syserr . println ( STR_ + file Name + STR_ + e ) ; syserr . println ( STR_ + STR_ ) ; syserr . print ( init Errors ) ; spec . error Level = NUM_ ; throw new Init Exception ( ) ; } return ; }
private Frequency Distribution < String > create Freq Dist For Misc File ( File misc ) throws IO Exception { Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( new File Input Stream ( misc ) , output Encoding ) ) ; Frequency Distribution < String > letter FD = new Frequency Distribution < String > ( ) ; String read Line = null ; while ( ( read Line = reader . read Line ( ) ) != null ) { int index Of Tab = read Line . index Of ( TAB ) ; String key = get Starting Letters ( read Line , index Of Tab ) ; letter FD . add Sample ( key , NUM_ ) ; } reader . close ( ) ; return letter FD ; }
@ Override public synchronized void destroy ( ) { destroyed = true ; for ( Thread t : workers Threads ) { t . interrupt ( ) ; } notify All ( ) ; }
public static final void message ( String message , Throwable e ) { if ( message == null && e != null ) { message = e . get Message ( ) ; } log Expensive ( Level . INFO , message , e ) ; }
@ Before public void load Data ( ) { feature Data = Simple Feature Data . load ( Stream . of ( tuple ( NUM_ , NUM_ , NUM_ ) , tuple ( NUM_ , NUM_ , NUM_ ) , tuple ( NUM_ , NUM_ , NUM_ ) ) ) ; preferences = Simple Preference Data . load ( Stream . of ( tuple ( NUM_ , NUM_ , NUM_ ) , tuple ( NUM_ , NUM_ , NUM_ ) , tuple ( NUM_ , NUM_ , NUM_ ) , tuple ( NUM_ , NUM_ , NUM_ ) , tuple ( NUM_ , NUM_ , NUM_ ) ) ) ; }
private Json Value correlate Target ( ) throws Synchronization Exception { return correlate Target ( null ) ; }
private Set < String > build Item List ( List < Offer > offers ) { Set < String > items = new Tree Set < String > ( ) ; for ( Offer offer : offers ) { items . add ( offer . get Item Name ( ) ) ; } return items ; }
protected void newline ( ) { if ( page != null && pagenum >= pr First ) { page . draw String ( line , x 0 , y 0 + ( linenum * lineheight ) + lineascent ) ; } line = STR_ ; charnum = NUM_ ; charoffset = NUM_ ; linenum ++ ; if ( linenum >= lines per page ) { if ( is Preview ) { page Images . add Element ( preview Image ) ; } if ( page != null ) { page . dispose ( ) ; } page = null ; newpage ( ) ; } }
@ Override public int hash Code ( ) { return NUM_ + ( is Zero ( ) ? NUM_ : ( sign << NUM_ ) ) + ( nans << NUM_ ) + exp + Arrays . hash Code ( mant ) ; }
public void execute ( Job Execution Context context ) throws Job Execution Exception { executions . increment And Get ( ) ; try { if ( status == STATE . RUNNING ) return ; status = STATE . RUNNING ; execute ( ) ; } catch ( Exception e ) { status = STATE . ERROR ; logger . error ( STR_ + e . get Message ( ) , e ) ; errors . increment And Get ( ) ; } catch ( Throwable e ) { status = STATE . ERROR ; logger . error ( STR_ + e . get Message ( ) , e ) ; errors . increment And Get ( ) ; } if ( status != STATE . ERROR ) status = STATE . DONE ; }
public static String replace Misused Apostrophe Symbol ( String orig Text ) { return orig Text . replace All ( STR_ , STR_ ) ; }
private void start Partition Properties ( Attributes atts , String local Or Global ) { stack . push ( local Or Global ) ; }
public Word Iterator ( Locale locale ) { m Iterator = Break Iterator . get Word Instance ( locale ) ; }
public boolean equals ( Object other ) { if ( ! ( other instanceof Policy Information ) ) return false ; Policy Information pi Other = ( Policy Information ) other ; if ( ! policy Identifier . equals ( pi Other . get Policy Identifier ( ) ) ) return false ; return policy Qualifiers . equals ( pi Other . get Policy Qualifiers ( ) ) ; }
boolean is Keepalive Allowed ( long connection Start Time ) { if ( ! lifecycle . is Active ( ) ) { return false ; } else if ( connection Start Time + keepalive Time Max < Current Time . current Time ( ) ) { return false ; } else if ( keepalive Max <= keepalive Allocate Count . get ( ) ) { return false ; } else { return true ; } }
private synchronized void read Object ( java . io . Object Input Stream s ) throws IO Exception , Class Not Found Exception { s . default Read Object ( ) ; init ( get Mask ( actions ) ) ; }
public static Buffered Input Stream new Input Stream ( Path self ) throws IO Exception { return new Buffered Input Stream ( Files . new Input Stream ( self ) ) ; }
public static int add Data Page Row ( Byte Buffer data Page , int row Size , Jet Format format , int row Flags ) { int row Space Usage = get Row Space Usage ( row Size , format ) ; short free Space In Page = data Page . get Short ( format . OFFSET FREE SPACE ) ; data Page . put Short ( format . OFFSET FREE SPACE , ( short ) ( free Space In Page - row Space Usage ) ) ; short row Count = data Page . get Short ( format . OFFSET NUM ROWS ON DATA PAGE ) ; data Page . put Short ( format . OFFSET NUM ROWS ON DATA PAGE , ( short ) ( row Count + NUM_ ) ) ; short row Location = find Row End ( data Page , row Count , format ) ; row Location -= row Size ; data Page . put Short ( get Row Start Offset ( row Count , format ) , ( short ) ( row Location | row Flags ) ) ; data Page . position ( row Location ) ; return row Count ; }
protected Array List < Integer > calculate Heights For Animation Parts ( int title View Height , int content View Height , int additional Flips Count ) { Array List < Integer > part Heights = new Array List < > ( ) ; int additional Parts Total Height = content View Height - title View Height * NUM_ ; if ( additional Parts Total Height < NUM_ ) throw new Illegal State Exception ( STR_ ) ; part Heights . add ( title View Height ) ; part Heights . add ( title View Height ) ; if ( additional Parts Total Height == NUM_ ) return part Heights ; if ( additional Flips Count != NUM_ ) { int additional Part Height = additional Parts Total Height / additional Flips Count ; int remaining Height = additional Parts Total Height % additional Flips Count ; if ( additional Part Height + remaining Height > title View Height ) throw new Illegal State Exception ( STR_ ) ; for ( int i = NUM_ ; i < additional Flips Count ; i ++ ) part Heights . add ( additional Part Height + ( i == NUM_ ? remaining Height : NUM_ ) ) ; } else { int parts Count = additional Parts Total Height / title View Height ; int rest Part Height = additional Parts Total Height % title View Height ; for ( int i = NUM_ ; i < parts Count ; i ++ ) part Heights . add ( title View Height ) ; if ( rest Part Height > NUM_ ) part Heights . add ( rest Part Height ) ; } return part Heights ; }
public void register Single Biome ( Biome Gen Base biome ) { registered Single Biome . add ( biome ) ; }
@ Override public boolean connect ( String user Name , String password ) { File file = new File ( dir Name ) ; try { file = file . get Canonical File ( ) ; return ( file . exists ( ) ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return ( false ) ; } }
@ Override public Instances define Data Format ( ) throws Exception { Array List < Attribute > atts ; Array List < String > att Values ; int i ; int n ; m Random = new Random ( get Seed ( ) ) ; set Num Examples Act ( get Num Examples ( ) ) ; atts = new Array List < Attribute > ( ) ; for ( n = NUM_ ; n <= NUM_ ; n ++ ) { att Values = new Array List < String > ( ) ; for ( i = NUM_ ; i < NUM_ ; i ++ ) { att Values . add ( STR_ + i ) ; } atts . add ( new Attribute ( STR_ + n , att Values ) ) ; } att Values = new Array List < String > ( ) ; for ( i = NUM_ ; i < NUM_ ; i ++ ) { att Values . add ( STR_ + i ) ; } atts . add ( new Attribute ( STR_ , att Values ) ) ; m Dataset Format = new Instances ( get Relation Name To Use ( ) , atts , NUM_ ) ; return m Dataset Format ; }
public void remove Client ( Connector Handler client ) { dead Clients . offer ( client ) ; }
public void write ( String text ) throws SAX Exception { if ( text != null ) { char [ ] chars = text . to Char Array ( ) ; content Handler . characters ( chars , NUM_ , chars . length ) ; } }
public void add Listener ( Bot Name Listener listener ) { if ( listener != null ) { listeners . add ( listener ) ; } }
public void add Connecting Socket ( Socket socket , Inet Address addr ) { synchronized ( connecting Sockets ) { connecting Sockets . put ( socket , new Connecting Socket Info ( addr ) ) ; } }
public void parse URL ( URL u , String spec , int start , int limit ) { String protocol = u . get Protocol ( ) ; String host = STR_ ; int port = u . get Port ( ) ; String file = STR_ ; if ( start < limit ) { file = spec . substring ( start , limit ) ; } boolean nogood = false ; if ( file == null || file . equals ( STR_ ) ) nogood = true ; else { boolean allwhites = true ; for ( int i = NUM_ ; i < file . length ( ) ; i ++ ) if ( ! Character . is Whitespace ( file . char At ( i ) ) ) allwhites = false ; if ( allwhites ) nogood = true ; } if ( nogood ) throw new Runtime Exception ( STR_ ) ; set URL Handler ( u , protocol , host , port , file , null ) ; }
public static void register Info Listener ( Info Listener l ) { info Listeners . add ( l ) ; }
private void scan Attribute For Annotation ( Input Stream is ) throws IO Exception { int name Index = read Short ( is ) ; int length = read Int ( is ) ; if ( ! is Name Annotation ( name Index ) ) { is . skip ( length ) ; return ; } int count = read Short ( is ) ; for ( int i = NUM_ ; i < count ; i ++ ) { int ann Type Index = scan Annotation ( is ) ; if ( ann Type Index > NUM_ && cp Lengths [ ann Type Index ] > NUM_ ) { matcher . add Class Annotation ( char Buffer , cp Data [ ann Type Index ] + NUM_ , cp Lengths [ ann Type Index ] - NUM_ ) ; } } }
private boolean convert ( View convert View ) { if ( cards . size ( ) != NUM_ ) { Log . d ( STR_ , STR_ + cards . size ( ) ) ; return false ; } Relative Layout container = ( Relative Layout ) convert View . find View By Id ( R . id . stack Container ) ; if ( container == null ) { Log . d ( STR_ , STR_ ) ; return false ; } if ( container . get Child Count ( ) != NUM_ ) { Log . d ( STR_ , STR_ + container . get Child Count ( ) ) ; return false ; } Card card = cards . get ( NUM_ ) ; View convert Card View = container . get Child At ( NUM_ ) ; if ( convert Card View == null || convert Card View . get Id ( ) != card . get Id ( ) ) { Log . d ( STR_ , String . format ( STR_ , convert Card View . get Id ( ) , card . get Id ( ) ) ) ; return false ; } if ( card . convert ( convert Card View ) ) return true ; return false ; }
private void init Class Path ( ) { String Builder cpath = new String Builder ( ) ; String sep = System . get Property ( STR_ ) ; cpath . append ( options . get Scratch Dir ( ) + sep ) ; String cp = ( String ) context . get Attribute ( Constants . SERVLET CLASSPATH ) ; if ( cp == null || cp . equals ( STR_ ) ) { cp = options . get Class Path ( ) ; } if ( cp != null ) { classpath = cpath . to String ( ) + cp ; } if ( classpath != null ) { try { classpath = URL Decoder . decode ( classpath , STR_ ) ; } catch ( Unsupported Encoding Exception e ) { if ( log . is Loggable ( Level . FINE ) ) log . log ( Level . FINE , STR_ + classpath , e ) ; } } }
public void clear Selected Item List ( ) { m Data List . clear ( ) ; }
public List < Lookup Result > lookup ( Char Sequence key , Boolean Query context Query , int num , boolean all Terms Required , boolean do Highlight ) throws IO Exception { if ( searcher Mgr == null ) { throw new Illegal State Exception ( STR_ ) ; } final Boolean Clause . Occur occur ; if ( all Terms Required ) { occur = Boolean Clause . Occur . MUST ; } else { occur = Boolean Clause . Occur . SHOULD ; } Boolean Query . Builder query ; Set < String > matched Tokens ; String prefix Token = null ; try ( Token Stream ts = query Analyzer . token Stream ( STR_ , new String Reader ( key . to String ( ) ) ) ) { ts . reset ( ) ; final Char Term Attribute term Att = ts . add Attribute ( Char Term Attribute . class ) ; final Offset Attribute offset Att = ts . add Attribute ( Offset Attribute . class ) ; String last Token = null ; query = new Boolean Query . Builder ( ) ; int max End Offset = - NUM_ ; matched Tokens = new Hash Set < > ( ) ; while ( ts . increment Token ( ) ) { if ( last Token != null ) { matched Tokens . add ( last Token ) ; query . add ( new Term Query ( new Term ( TEXT FIELD NAME , last Token ) ) , occur ) ; } last Token = term Att . to String ( ) ; if ( last Token != null ) { max End Offset = Math . max ( max End Offset , offset Att . end Offset ( ) ) ; } } ts . end ( ) ; if ( last Token != null ) { Query last Query ; if ( max End Offset == offset Att . end Offset ( ) ) { last Query = get Last Token Query ( last Token ) ; prefix Token = last Token ; } else { matched Tokens . add ( last Token ) ; last Query = new Term Query ( new Term ( TEXT FIELD NAME , last Token ) ) ; } if ( last Query != null ) { query . add ( last Query , occur ) ; } } if ( context Query != null ) { boolean all Must Not = true ; for ( Boolean Clause clause : context Query . clauses ( ) ) { if ( clause . get Occur ( ) != Boolean Clause . Occur . MUST NOT ) { all Must Not = false ; break ; } } if ( all Must Not ) { for ( Boolean Clause clause : context Query . clauses ( ) ) { query . add ( clause ) ; } } else if ( all Terms Required == false ) { Boolean Query . Builder new Query = new Boolean Query . Builder ( ) ; new Query . add ( query . build ( ) , Boolean Clause . Occur . MUST ) ; new Query . add ( context Query , Boolean Clause . Occur . MUST ) ; query = new Query ; } else { query . add ( context Query , Boolean Clause . Occur . MUST ) ; } } } Query final Query = finish Query ( query , all Terms Required ) ; Top Field Collector c = Top Field Collector . create ( SORT , num , true , false , false ) ; Collector c 2 = new Early Terminating Sorting Collector ( c , SORT , num ) ; List < Lookup Result > results = null ; Index Searcher searcher = searcher Mgr . acquire ( ) ; try { searcher . search ( final Query , c 2 ) ; Top Field Docs hits = c . top Docs ( ) ; results = create Results ( searcher , hits , num , key , do Highlight , matched Tokens , prefix Token ) ; } finally { searcher Mgr . release ( searcher ) ; } return results ; }
public Building ( Coords coords , I Board board , int structure Type , Basement Type basement Type ) { id = coords . hash Code ( ) ; coordinates . add Element ( coords ) ; original Hexes ++ ; burning . put ( coords , false ) ; I Hex start Hex = board . get Hex ( coords ) ; if ( ! start Hex . contains Terrain ( structure Type ) ) { throw new Illegal Argument Exception ( STR_ + coords . get Board Num ( ) + STR_ ) ; } type = start Hex . terrain Level ( structure Type ) ; bldg Class = start Hex . terrain Level ( Terrains . BLDG CLASS ) ; current CF . put ( coords , get Default CF ( type ) ) ; if ( current CF . get ( coords ) == Building . UNKNOWN ) { throw new Illegal Argument Exception ( STR_ + type + STR_ ) ; } if ( ( structure Type == Terrains . BUILDING ) && start Hex . contains Terrain ( Terrains . BLDG CF ) ) { current CF . put ( coords , start Hex . terrain Level ( Terrains . BLDG CF ) ) ; } if ( ( structure Type == Terrains . BRIDGE ) && start Hex . contains Terrain ( Terrains . BRIDGE CF ) ) { current CF . put ( coords , start Hex . terrain Level ( Terrains . BRIDGE CF ) ) ; } if ( ( structure Type == Terrains . FUEL TANK ) && start Hex . contains Terrain ( Terrains . FUEL TANK CF ) ) { current CF . put ( coords , start Hex . terrain Level ( Terrains . FUEL TANK CF ) ) ; } if ( start Hex . contains Terrain ( Terrains . BLDG ARMOR ) ) { armor . put ( coords , start Hex . terrain Level ( Terrains . BLDG ARMOR ) ) ; } else { armor . put ( coords , NUM_ ) ; } phase CF . put All ( current CF ) ; basement . put ( coords , basement Type ) ; basement Collapsed . put ( coords , start Hex . terrain Level ( Terrains . BLDG BASE COLLAPSED ) == NUM_ ) ; for ( int dir = NUM_ ; dir < NUM_ ; dir ++ ) { if ( start Hex . contains Terrain Exit ( structure Type , dir ) ) { include ( coords . translated ( dir ) , board , structure Type ) ; } } String Buffer buffer = new String Buffer ( ) ; if ( structure Type == Terrains . FUEL TANK ) { buffer . append ( STR_ ) ; } else if ( get Type ( ) == Building . WALL ) { buffer . append ( STR_ ) ; } else if ( structure Type == Terrains . BUILDING ) { buffer . append ( STR_ ) ; } else if ( structure Type == Terrains . BRIDGE ) { buffer . append ( STR_ ) ; } else { buffer . append ( STR_ ) ; } buffer . append ( id ) ; name = buffer . to String ( ) ; }
static public List < Key Parts > key Parts For Query ( final Temporal Instant query Instant , final Statement Constraints contraints ) { final List < Key Parts > keys = new Linked List < Key Parts > ( ) ; final URI url Null = new URI Impl ( STR_ ) ; final Resource current Context = contraints . get Context ( ) ; final boolean has Subj = contraints . has Subject ( ) ; if ( contraints . has Predicates ( ) ) { for ( final URI next Predicate : contraints . get Predicates ( ) ) { final Text contraint Prefix = new Text ( ) ; final Statement statement = new Context Statement Impl ( has Subj ? contraints . get Subject ( ) : url Null , next Predicate , url Null , contraints . get Context ( ) ) ; if ( has Subj ) { append Subject Predicate ( statement , contraint Prefix ) ; } else { append Predicate ( statement , contraint Prefix ) ; } keys . add ( new Key Parts ( contraint Prefix , query Instant , ( current Context == null ) ? STR_ : current Context . to String ( ) , has Subj ? CQ S P AT : CQ P AT ) ) ; } } else if ( contraints . has Subject ( ) ) { final Text contraint Prefix = new Text ( ) ; final Statement statement = new Statement Impl ( contraints . get Subject ( ) , url Null , url Null ) ; append Subject ( statement , contraint Prefix ) ; keys . add ( new Key Parts ( contraint Prefix , query Instant , ( current Context == null ) ? STR_ : current Context . to String ( ) , CQ S AT ) ) ; } else { keys . add ( new Key Parts ( null , query Instant , ( current Context == null ) ? STR_ : current Context . to String ( ) , CQ O AT ) ) ; } return keys ; }
private void call Drop PLSQL ( String collection Name ) throws Oracle Exception { Oracle Callable Statement stmt = null ; String sqltext = STR_ + STR_ + STR_ ; try { metrics . start Timing ( ) ; stmt = ( Oracle Callable Statement ) conn . prepare Call ( sqltext ) ; stmt . set N String ( NUM_ , collection Name ) ; stmt . execute ( ) ; if ( Oracle Log . is Logging Enabled ( ) ) log . info ( STR_ + collection Name ) ; stmt . close ( ) ; stmt = null ; metrics . record DDL ( ) ; } catch ( SQL Exception e ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( e . to String ( ) ) ; boolean commit Needed = false ; try { if ( sql Syntax Level == SODA Utils . SQL Syntax Level . SQL SYNTAX UNKNOWN ) sql Syntax Level = SODA Utils . get Database Version ( conn ) ; } catch ( SQL Exception se ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( se . get Message ( ) ) ; throw new Oracle Exception ( se ) ; } if ( ! SODA Utils . sql Syntax Below 12 2 ( sql Syntax Level ) ) { if ( e . get Error Code ( ) == NUM_ ) { commit Needed = true ; } } else if ( e . get Error Code ( ) == NUM_ ) { commit Needed = true ; } if ( commit Needed ) throw SODA Utils . make Exception With SQL Text ( SODA Message . EX COMMIT MIGHT BE NEEDED , e , sqltext ) ; throw SODA Utils . make Exception With SQL Text ( e , sqltext ) ; } finally { for ( String message : SODA Utils . close Cursor ( stmt , null ) ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( message ) ; } } }
public boolean is Secondary Index ( ) { return cf Name . contains ( STR_ ) ; }
private void write Object ( java . io . Object Output Stream s ) throws java . io . IO Exception { s . write Int ( size ( ) ) ; Enumeration < String > comps = get All ( ) ; while ( comps . has More Elements ( ) ) { s . write Object ( comps . next Element ( ) ) ; } }
public synchronized T read ( String text ) throws Exception { Date date = Date Type . get Date ( text ) ; Long time = date . get Time ( ) ; return factory . get Instance ( time ) ; }
public static String extract CSV Output Line Freq ( String csv Out ) { String tokens [ ] = csv Out . split ( STR_ , - NUM_ ) ; return tokens [ NUM_ ] ; }
protected void add Profile Event ( Mouse Event event ) { Lat Lon Point llp = proj . inverse ( event . get X ( ) , event . get Y ( ) , new Lat Lon Point . Double ( ) ) ; if ( last Mouse != null ) { if ( ( Math . abs ( last Mouse . get X ( ) - event . get X ( ) ) > MAX SPACE BETWEEN PIXELS ) || ( Math . abs ( last Mouse . get Y ( ) - event . get Y ( ) ) > MAX SPACE BETWEEN PIXELS ) ) { add Great Circle Points ( last Mouse , event ) ; coords . add Element ( llp ) ; xypoints . add Element ( event . get Point ( ) ) ; } } else { coords . add Element ( llp ) ; xypoints . add Element ( event . get Point ( ) ) ; } last Mouse = event ; profile Line . set Location ( set LL Points ( ) , OM Graphic . RADIANS ) ; profile Line . generate ( proj ) ; }
public org . smpte ra . schemas . st 2067 2 2013 . Content Maturity Rating Type build Content Maturity Rating Type ( String agency , String rating , org . smpte ra . schemas . st 2067 2 2013 . Content Maturity Rating Type . Audience audience ) throws URI Syntax Exception { org . smpte ra . schemas . st 2067 2 2013 . Content Maturity Rating Type content Maturity Rating Type = new org . smpte ra . schemas . st 2067 2 2013 . Content Maturity Rating Type ( ) ; if ( ! agency . matches ( STR_ ) == true ) { throw new URI Syntax Exception ( STR_ , STR_ ) ; } content Maturity Rating Type . set Agency ( agency ) ; content Maturity Rating Type . set Rating ( rating ) ; content Maturity Rating Type . set Audience ( audience ) ; return content Maturity Rating Type ; }
boolean is Socket Scheme ( String scheme ) { for ( String p : URI Helper . SOCKET SCHEMES ) { if ( p . equals ( scheme ) ) { return true ; } } return false ; }
protected Async Http Request new Async Http Request ( Default Http Client client , Http Context http Context , Http Uri Request uri Request , String content Type , Response Handler Interface response Handler , Context context ) { return new Async Http Request ( client , http Context , uri Request , response Handler ) ; }
public void initialize Writer ( ) throws Carbon Data Writer Exception { init File Count ( ) ; String carbon Data File Name = carbon Table Path . get Carbon Data File Name ( file Count , carbon Data File Attributes . get Task Id ( ) , carbon Data File Attributes . get Fact Time Stamp ( ) ) ; String actual File Name Val = carbon Data File Name + Carbon Common Constants . FILE INPROGRESS STATUS ; File Data file Data = new File Data ( actual File Name Val , this . store Location ) ; file Manager . add ( file Data ) ; this . file Name = store Location + File . separator + carbon Data File Name + Carbon Common Constants . FILE INPROGRESS STATUS ; this . file Count ++ ; try { file Output Stream = new File Output Stream ( this . file Name , true ) ; this . file Channel = file Output Stream . get Channel ( ) ; } catch ( File Not Found Exception file Not Found Exception ) { throw new Carbon Data Writer Exception ( STR_ , file Not Found Exception ) ; } }
public void fetch And Parse Data Files ( Log log ) throws IO Exception { for ( Enum Map . Entry < Data File Type , URL > entry : data Files . entry Set ( ) ) { Data File Type file Type = entry . get Key ( ) ; URL url = entry . get Value ( ) ; log . info ( STR_ + url . get Path ( ) ) ; file Type . scan ( url , this ) ; log . info ( STR_ + url . get Path ( ) ) ; } }
public void init Raw Swap ( Array List < S 2 Cell Id > cell Ids ) { this . cell Ids = new Array List < S 2 Cell Id > ( cell Ids ) ; cell Ids . clear ( ) ; }
protected void check ( ) { double tsum ; int i , j ; double s = NUM_ ; for ( i = NUM_ ; i < examples total ; i ++ ) { s += alphas [ i ] ; tsum = NUM_ ; for ( j = NUM_ ; j < the examples . count examples ( ) ; j ++ ) { tsum += alphas [ j ] * the kernel . calculate K ( i , j ) ; } ; if ( Math . abs ( tsum - sum [ i ] ) > is zero ) { logln ( NUM_ , STR_ + i + STR_ + ( tsum - sum [ i ] ) ) ; } ; } ; if ( Math . abs ( s + sum alpha ) > is zero ) { logln ( NUM_ , STR_ + ( s + sum alpha ) ) ; } ; }
public void add Listener ( @ Not Null Selection Change Listener listener ) { listeners . add ( listener ) ; }
private char [ ] f Format Digits ( double x ) { String sx , sx Out ; int i , j , k ; int n 1 In , n 2 In ; int expon = NUM_ ; boolean minus Sign = false ; if ( x > NUM_ ) sx = Double . to String ( x ) ; else if ( x < NUM_ ) { sx = Double . to String ( - x ) ; minus Sign = true ; } else { sx = Double . to String ( x ) ; if ( sx . char At ( NUM_ ) == STR_ ) { minus Sign = true ; sx = sx . substring ( NUM_ ) ; } } int e Pos = sx . index Of ( STR_ ) ; int r Pos = sx . index Of ( STR_ ) ; if ( r Pos != - NUM_ ) n 1 In = r Pos ; else if ( e Pos != - NUM_ ) n 1 In = e Pos ; else n 1 In = sx . length ( ) ; if ( r Pos != - NUM_ ) { if ( e Pos != - NUM_ ) n 2 In = e Pos - r Pos - NUM_ ; else n 2 In = sx . length ( ) - r Pos - NUM_ ; } else n 2 In = NUM_ ; if ( e Pos != - NUM_ ) { int ie = e Pos + NUM_ ; expon = NUM_ ; if ( sx . char At ( ie ) == STR_ ) { for ( ++ ie ; ie < sx . length ( ) ; ie ++ ) if ( sx . char At ( ie ) != STR_ ) break ; if ( ie < sx . length ( ) ) expon = - Integer . parse Int ( sx . substring ( ie ) ) ; } else { if ( sx . char At ( ie ) == STR_ ) ++ ie ; for ( ; ie < sx . length ( ) ; ie ++ ) if ( sx . char At ( ie ) != STR_ ) break ; if ( ie < sx . length ( ) ) expon = Integer . parse Int ( sx . substring ( ie ) ) ; } } int p ; if ( precision Set ) p = precision ; else p = default Digits - NUM_ ; char [ ] ca 1 = sx . to Char Array ( ) ; char [ ] ca 2 = new char [ n 1 In + n 2 In ] ; char [ ] ca 3 , ca 4 , ca 5 ; for ( j = NUM_ ; j < n 1 In ; j ++ ) ca 2 [ j ] = ca 1 [ j ] ; i = j + NUM_ ; for ( k = NUM_ ; k < n 2 In ; j ++ , i ++ , k ++ ) ca 2 [ j ] = ca 1 [ i ] ; if ( n 1 In + expon <= NUM_ ) { ca 3 = new char [ - expon + n 2 In ] ; for ( j = NUM_ , k = NUM_ ; k < ( - n 1 In - expon ) ; k ++ , j ++ ) ca 3 [ j ] = STR_ ; for ( i = NUM_ ; i < ( n 1 In + n 2 In ) ; i ++ , j ++ ) ca 3 [ j ] = ca 2 [ i ] ; } else ca 3 = ca 2 ; boolean carry = false ; if ( p < - expon + n 2 In ) { if ( expon < NUM_ ) i = p ; else i = p + n 1 In ; carry = check For Carry ( ca 3 , i ) ; if ( carry ) carry = start Symbolic Carry ( ca 3 , i - NUM_ , NUM_ ) ; } if ( n 1 In + expon <= NUM_ ) { ca 4 = new char [ NUM_ + p ] ; if ( ! carry ) ca 4 [ NUM_ ] = STR_ ; else ca 4 [ NUM_ ] = STR_ ; if ( alternate Form || ! precision Set || precision != NUM_ ) { ca 4 [ NUM_ ] = STR_ ; for ( i = NUM_ , j = NUM_ ; i < Math . min ( p , ca 3 . length ) ; i ++ , j ++ ) ca 4 [ j ] = ca 3 [ i ] ; for ( ; j < ca 4 . length ; j ++ ) ca 4 [ j ] = STR_ ; } } else { if ( ! carry ) { if ( alternate Form || ! precision Set || precision != NUM_ ) ca 4 = new char [ n 1 In + expon + p + NUM_ ] ; else ca 4 = new char [ n 1 In + expon ] ; j = NUM_ ; } else { if ( alternate Form || ! precision Set || precision != NUM_ ) ca 4 = new char [ n 1 In + expon + p + NUM_ ] ; else ca 4 = new char [ n 1 In + expon + NUM_ ] ; ca 4 [ NUM_ ] = STR_ ; j = NUM_ ; } for ( i = NUM_ ; i < Math . min ( n 1 In + expon , ca 3 . length ) ; i ++ , j ++ ) ca 4 [ j ] = ca 3 [ i ] ; for ( ; i < n 1 In + expon ; i ++ , j ++ ) ca 4 [ j ] = STR_ ; if ( alternate Form || ! precision Set || precision != NUM_ ) { ca 4 [ j ] = STR_ ; j ++ ; for ( k = NUM_ ; i < ca 3 . length && k < p ; i ++ , j ++ , k ++ ) ca 4 [ j ] = ca 3 [ i ] ; for ( ; j < ca 4 . length ; j ++ ) ca 4 [ j ] = STR_ ; } } int n Zeros = NUM_ ; if ( ! left Justify && leading Zeros ) { int x Thousands = NUM_ ; if ( thousands ) { int xlead = NUM_ ; if ( ca 4 [ NUM_ ] == STR_ || ca 4 [ NUM_ ] == STR_ || ca 4 [ NUM_ ] == STR_ ) xlead = NUM_ ; int xdp = xlead ; for ( ; xdp < ca 4 . length ; xdp ++ ) if ( ca 4 [ xdp ] == STR_ ) break ; x Thousands = ( xdp - xlead ) / NUM_ ; } if ( field Width Set ) n Zeros = field Width - ca 4 . length ; if ( ( ! minus Sign && ( leading Sign || leading Space ) ) || minus Sign ) n Zeros -- ; n Zeros -= x Thousands ; if ( n Zeros < NUM_ ) n Zeros = NUM_ ; } j = NUM_ ; if ( ( ! minus Sign && ( leading Sign || leading Space ) ) || minus Sign ) { ca 5 = new char [ ca 4 . length + n Zeros + NUM_ ] ; j ++ ; } else ca 5 = new char [ ca 4 . length + n Zeros ] ; if ( ! minus Sign ) { if ( leading Sign ) ca 5 [ NUM_ ] = STR_ ; if ( leading Space ) ca 5 [ NUM_ ] = STR_ ; } else ca 5 [ NUM_ ] = STR_ ; for ( i = NUM_ ; i < n Zeros ; i ++ , j ++ ) ca 5 [ j ] = STR_ ; for ( i = NUM_ ; i < ca 4 . length ; i ++ , j ++ ) ca 5 [ j ] = ca 4 [ i ] ; int lead = NUM_ ; if ( ca 5 [ NUM_ ] == STR_ || ca 5 [ NUM_ ] == STR_ || ca 5 [ NUM_ ] == STR_ ) lead = NUM_ ; int dp = lead ; for ( ; dp < ca 5 . length ; dp ++ ) if ( ca 5 [ dp ] == STR_ ) break ; int n Thousands = ( dp - lead ) / NUM_ ; if ( dp < ca 5 . length ) ca 5 [ dp ] = dfs . get Decimal Separator ( ) ; char [ ] ca 6 = ca 5 ; if ( thousands && n Thousands > NUM_ ) { ca 6 = new char [ ca 5 . length + n Thousands + lead ] ; ca 6 [ NUM_ ] = ca 5 [ NUM_ ] ; for ( i = lead , k = lead ; i < dp ; i ++ ) { if ( i > NUM_ && ( dp - i ) % NUM_ == NUM_ ) { ca 6 [ k ] = dfs . get Grouping Separator ( ) ; ca 6 [ k + NUM_ ] = ca 5 [ i ] ; k += NUM_ ; } else { ca 6 [ k ] = ca 5 [ i ] ; k ++ ; } } for ( ; i < ca 5 . length ; i ++ , k ++ ) { ca 6 [ k ] = ca 5 [ i ] ; } } return ca 6 ; }
private static boolean equal ( Number [ ] [ ] array 1 , Number [ ] [ ] array 2 ) { if ( array 1 == null ) { return ( array 2 == null ) ; } if ( array 2 == null ) { return false ; } if ( array 1 . length != array 2 . length ) { return false ; } for ( int i = NUM_ ; i < array 1 . length ; i ++ ) { if ( ! Arrays . equals ( array 1 [ i ] , array 2 [ i ] ) ) { return false ; } } return true ; }
public void reset ( ) { m Object Count = NUM_ ; m Object Data Used = NUM_ ; Arrays . fill ( m Objects , null ) ; }
@ Rpc Method public void reserve ( Resource resource , Integer generation , Async Method Callback < Host . Async Client . reserve call > handler ) throws Rpc Exception { ensure Client ( ) ; Reserve Request reserve Request = new Reserve Request ( ) ; reserve Request . set Resource ( resource ) ; if ( null != generation ) { reserve Request . set Generation ( generation ) ; } client Proxy . set Timeout ( RESERVE TIMEOUT MS ) ; logger . info ( STR_ , resource , generation , get Host Ip ( ) , reserve Request ) ; try { client Proxy . reserve ( reserve Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
private void queue Events ( ) { if ( ! new Notifies . is Empty ( ) ) { tasker . add All ( new Notifies ) ; new Notifies . clear ( ) ; } }
protected String normalize Value ( String value ) { Comparable < T > comparable Value = null ; try { comparable Value = convert To Comparable ( value ) ; } catch ( Number Format Exception e ) { return DEFAULT VALUE ; } if ( MAX VALUE != null && comparable Value . compare To ( MAX VALUE ) > NUM_ ) { return MAX VALUE . to String ( ) ; } else if ( MIN VALUE != null && comparable Value . compare To ( MIN VALUE ) < NUM_ ) { return MIN VALUE . to String ( ) ; } return value ; }
protected void read Stream Header ( ) throws IO Exception , Stream Corrupted Exception { short s 0 = bin . read Short ( ) ; short s 1 = bin . read Short ( ) ; if ( s 0 != STREAM MAGIC || s 1 != STREAM VERSION ) { throw new Stream Corrupted Exception ( String . format ( STR_ , s 0 , s 1 ) ) ; } }
public static T Stream < Json Object > water Detector ( Topology topology , int well Id ) { Random r Num = new Random ( ) ; T Stream < Integer > temp = topology . poll ( null , NUM_ , Time Unit . SECONDS ) ; T Stream < Integer > acidity = topology . poll ( null , NUM_ , Time Unit . SECONDS ) ; T Stream < Integer > ecoli = topology . poll ( null , NUM_ , Time Unit . SECONDS ) ; T Stream < Integer > lead = topology . poll ( null , NUM_ , Time Unit . SECONDS ) ; T Stream < Integer > id = topology . poll ( null , NUM_ , Time Unit . SECONDS ) ; temp . tag ( STR_ , STR_ + well Id ) ; acidity . tag ( STR_ , STR_ + well Id ) ; ecoli . tag ( STR_ , STR_ + well Id ) ; lead . tag ( STR_ , STR_ + well Id ) ; id . tag ( STR_ + well Id ) ; T Stream < Json Object > temp Obj = temp . map ( null ) ; T Stream < Json Object > acidity Obj = acidity . map ( null ) ; T Stream < Json Object > ecoli Obj = ecoli . map ( null ) ; T Stream < Json Object > lead Obj = lead . map ( null ) ; T Stream < Json Object > id Obj = id . map ( null ) ; Hash Set < T Stream < Json Object > > set = new Hash Set < T Stream < Json Object > > ( ) ; set . add ( acidity Obj ) ; set . add ( acidity Obj ) ; set . add ( ecoli Obj ) ; set . add ( lead Obj ) ; set . add ( id Obj ) ; T Stream < Json Object > all Readings = temp Obj . union ( set ) ; return all Readings ; }
public void add Datatransfer Progress Listener ( On Datatransfer Progress Listener listener , Account account , OC File file ) { if ( account == null || file == null || listener == null ) return ; String target Key = build Remote Name ( account . name , file . get Remote Path ( ) ) ; m Bound Listeners . put ( target Key , listener ) ; }
private void update Min Max ( Instance instance ) { for ( int j = NUM_ ; j < m instances . num Attributes ( ) ; j ++ ) { if ( ! instance . is Missing ( j ) ) { if ( Double . is Na N ( m Min [ j ] ) ) { m Min [ j ] = instance . value ( j ) ; m Max [ j ] = instance . value ( j ) ; } else if ( instance . value ( j ) < m Min [ j ] ) { m Min [ j ] = instance . value ( j ) ; } else if ( instance . value ( j ) > m Max [ j ] ) { m Max [ j ] = instance . value ( j ) ; } } } }
protected void pad ( String Builder sb , int length ) { while ( sb . length ( ) < length ) { sb . append ( STR_ ) ; } }
private final boolean check String ( String s , Condition condition ) { String value = condition . get Value ( ) ; assert ( value != null ) ; Filter Op op = condition . get Condition Type ( ) ; switch ( op ) { case NULL : { return ( s == null ) ; } case NOT NULL : { return ( s != null ) ; } } if ( s == null ) { return false ; } final int comp = s . compare To ( value ) ; switch ( op ) { case EQUALS : { return ( comp == NUM_ ) ; } case NOT EQUALS : { return ( comp != NUM_ ) ; } case GREATER : { return ( comp > NUM_ ) ; } case GREATER EQ : { return ( comp >= NUM_ ) ; } case LESS : { return ( comp < NUM_ ) ; } case LESS EQ : { return ( comp <= NUM_ ) ; } default : { return false ; } } }
public long length ( byte [ ] id ) { Byte Buffer id Buffer = Byte Buffer . wrap ( id ) ; long length = NUM_ ; while ( id Buffer . has Remaining ( ) ) { switch ( id Buffer . get ( ) ) { case NUM_ : int len = Data Utils . read Var Int ( id Buffer ) ; id Buffer . position ( id Buffer . position ( ) + len ) ; length += len ; break ; case NUM_ : length += Data Utils . read Var Int ( id Buffer ) ; Data Utils . read Var Long ( id Buffer ) ; break ; case NUM_ : length += Data Utils . read Var Long ( id Buffer ) ; Data Utils . read Var Long ( id Buffer ) ; break ; default : throw Data Utils . new Illegal Argument Exception ( STR_ , Arrays . to String ( id ) ) ; } } return length ; }
public static boolean equal ( double [ ] [ ] a , double [ ] [ ] b ) { if ( a == null ) { return ( b == null ) ; } if ( b == null ) { return false ; } if ( a . length != b . length ) { return false ; } for ( int i = NUM_ ; i < a . length ; i ++ ) { if ( ! Arrays . equals ( a [ i ] , b [ i ] ) ) { return false ; } } return true ; }
void append Particle ( String Buffer buffer ) { switch ( f Type ) { case PARTICLE EMPTY : buffer . append ( STR_ ) ; break ; case PARTICLE ELEMENT : buffer . append ( f Value . to String ( ) ) ; break ; case PARTICLE WILDCARD : buffer . append ( STR_ ) ; buffer . append ( f Value . to String ( ) ) ; buffer . append ( STR_ ) ; break ; case PARTICLE MODELGROUP : buffer . append ( f Value . to String ( ) ) ; break ; } }
static String db Name For User ( final int user Id ) { if ( user Id == User Handle . USER OWNER ) { return DATABASE NAME ; } else { File database File = new File ( Environment . get User System Directory ( user Id ) , DATABASE NAME ) ; return database File . get Path ( ) ; } }
protected void write Primary Key Stmt ( Table table , Column [ ] primary Key Columns , String Builder ddl ) { ddl . append ( STR_ ) ; for ( int idx = NUM_ ; idx < primary Key Columns . length ; idx ++ ) { print Identifier ( get Column Name ( primary Key Columns [ idx ] ) , ddl ) ; if ( idx < primary Key Columns . length - NUM_ ) { ddl . append ( STR_ ) ; } } ddl . append ( STR_ ) ; }
public boolean evaluate Is Zero ( final Vector v ) { return Math . abs ( evaluate ( v ) ) < MINIMUM RESOLUTION ; }
public void register Service ( SSO Token token , String org DN , String service Name ) throws AM Exception , SSO Exception { try { Set attr Names = get Service Attributes With Qualifier ( token , service Name ) ; if ( ( attr Names != null ) && ! attr Names . is Empty ( ) ) { Persistent Object po = UMS Object . get Object Handle ( token , new Guid ( org DN ) ) ; Direct COS Definition dcos = create COS Definition ( service Name , attr Names ) ; COS Manager cm = COS Manager . get COS Manager ( token , po . get Guid ( ) ) ; cm . add Definition ( dcos ) ; } } catch ( Access Rights Exception e ) { debug . error ( STR_ + STR_ + service Name , e ) ; throw new AM Exception ( token , STR_ ) ; } catch ( Entry Already Exists Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STR_ + STR_ + service Name + STR_ , e ) ; } Object args [ ] = { service Name } ; String locale = Common Utils . get User Locale ( token ) ; throw new AM Exception ( AMSDK Bundle . get String ( STR_ , args , locale ) , STR_ , args ) ; } catch ( SMS Exception e ) { debug . error ( STR_ + STR_ + service Name , e ) ; throw new AM Exception ( token , STR_ ) ; } catch ( UMS Exception e ) { debug . error ( STR_ + STR_ + service Name , e ) ; throw new AM Exception ( token , STR_ , e ) ; } }
Color next Color ( ) { int red = Math . min ( NUM_ , ( ( measurement Color > > NUM_ ) & NUM_ ) * NUM_ / NUM_ ) ; int green = Math . min ( NUM_ , ( ( measurement Color > > NUM_ ) & NUM_ ) * NUM_ / NUM_ ) ; int blue = Math . min ( NUM_ , ( ( measurement Color > > NUM_ ) & NUM_ ) * NUM_ / NUM_ ) ; measurement Color ++ ; return new Color ( red , green , blue ) ; }
private Node variables ( int context ) throws IO Exception , Parser Exception { Node pn ; boolean first = true ; if ( context == Token . CONST ) { pn = nf . create Variables ( Token . CONST , ts . get Lineno ( ) ) ; decompiler . add Token ( Token . CONST ) ; } else { pn = nf . create Variables ( Token . VAR , ts . get Lineno ( ) ) ; decompiler . add Token ( Token . VAR ) ; } for ( ; ; ) { Node name ; Node init ; must Match Token ( Token . NAME , STR_ ) ; String s = ts . get String ( ) ; if ( ! first ) decompiler . add Token ( Token . COMMA ) ; first = false ; decompiler . add Name ( s ) ; if ( context == Token . CONST ) { if ( ! current Script Or Fn . add Const ( s ) ) { if ( current Script Or Fn . add Var ( s ) != Script Or Fn Node . DUPLICATE CONST ) add Error ( STR_ , s ) ; else add Error ( STR_ , s ) ; } } else { int dup State = current Script Or Fn . add Var ( s ) ; if ( dup State == Script Or Fn Node . DUPLICATE CONST ) add Error ( STR_ , s ) ; else if ( dup State == Script Or Fn Node . DUPLICATE PARAMETER ) add Strict Warning ( STR_ , s ) ; else if ( dup State == Script Or Fn Node . DUPLICATE VAR ) add Strict Warning ( STR_ , s ) ; } name = nf . create Name ( s ) ; if ( match Token ( Token . ASSIGN ) ) { decompiler . add Token ( Token . ASSIGN ) ; init = assign Expr ( context == Token . FOR ) ; nf . add Child To Back ( name , init ) ; } nf . add Child To Back ( pn , name ) ; if ( ! match Token ( Token . COMMA ) ) break ; } return pn ; }
void clear Errors ( ) { synchronized ( cached Workspace Lock ) { empty Cached Workspace Failures = false ; cached Workspace Failures . clear ( ) ; } }
private static Path 2 D create Left Tab Shape ( int x , int y , int w , int h , double r Left , boolean add Side ) { Path 2 D path = new Path 2 D . Double ( ) ; path . append ( new Line 2 D . Double ( x + w , y + h , x + r Left , y + h ) , true ) ; Quad Curve 2 D curve = new Quad Curve 2 D . Double ( x + r Left , y + h , x , y + h , x , y + h - r Left ) ; path . append ( curve , true ) ; path . append ( new Line 2 D . Double ( x , y + h - r Left , x , y + r Left ) , true ) ; curve = new Quad Curve 2 D . Double ( x , y + r Left , x , y , x + r Left , y ) ; path . append ( curve , true ) ; path . append ( new Line 2 D . Double ( x + r Left , y , x + w , y ) , true ) ; if ( add Side ) { path . append ( new Line 2 D . Double ( x + w , y , x + w , y + h - NUM_ ) , true ) ; } return path ; }
public Object remove Property ( final URI uri , final String prop ) { return remove Property ( uri , factory . to Property URI ( prop ) ) ; }
private void init Create Userinfo Schma ( ) throws SQL Exception { Result Set rs ; rs = stmt . execute Query ( STR_ ) ; if ( false == rs . next ( ) ) { String sql = STR_ + STR_ + STR_ + STR_ ; stmt . execute Update ( sql ) ; } rs = stmt . execute Query ( STR_ ) ; if ( false == rs . next ( ) ) { String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; stmt . execute Update ( sql ) ; } }
public JB Zip File ( File f , String encoding ) throws IO Exception { this . encoding = encoding ; archive = new Random Access File ( f , STR_ ) ; try { if ( archive . length ( ) > NUM_ ) { populate From Central Directory ( ) ; } else { get Output Stream ( ) ; } } catch ( IO Exception e ) { try { archive . close ( ) ; } catch ( IO Exception e 2 ) { } throw e ; } }
private static boolean eq ( Object o 1 , Object o 2 ) { return ( o 1 == null ) ? o 2 == null : o 1 . equals ( o 2 ) ; }
public static Simple Checkout Starter create With Command Line Args ( final List < String > args ) throws Runtime Exception { if ( args . size ( ) < NUM_ ) { throw new Runtime Exception ( Tf Plugin Bundle . message ( Tf Plugin Bundle . STARTER ERRORS SIMPLECHECKOUT INVALID COMMAND LINE ARGS ) ) ; } return create With Git Url ( args . get ( NUM_ ) , args . size ( ) < NUM_ ? String Utils . EMPTY : args . get ( NUM_ ) ) ; }
public static boolean global Lights Off ( ) { return instance . global Lights Off ; }
private static String normalize Jar Entry Path ( String jar Entry Dir Path , boolean directory ) { if ( ! jar Entry Dir Path . starts With ( STR_ ) ) { jar Entry Dir Path = STR_ + jar Entry Dir Path ; } if ( directory && ! jar Entry Dir Path . ends With ( STR_ ) ) { jar Entry Dir Path = jar Entry Dir Path + STR_ ; } return jar Entry Dir Path ; }
public Dynamic Time Series Collection ( int n Series , int n Moments ) { this ( n Series , n Moments , new Millisecond ( ) , Time Zone . get Default ( ) ) ; this . newest At = n Moments - NUM_ ; }
private String print X Format ( final short x ) { String sx = null ; if ( x == Short . MIN VALUE ) { sx = STR_ ; } else if ( x < NUM_ ) { String t ; if ( x == Short . MIN VALUE ) { t = STR_ ; } else { t = Integer . to String ( ( ~ ( - x - NUM_ ) ) ^ Short . MIN VALUE , NUM_ ) ; if ( t . char At ( NUM_ ) == STR_ || t . char At ( NUM_ ) == STR_ ) { t = t . substring ( NUM_ , NUM_ ) ; } } switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : switch ( t . char At ( NUM_ ) ) { case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; } break ; } } else { sx = Integer . to String ( x , NUM_ ) ; } return print X Format ( sx ) ; }
public static void color Snackbar ( Context context , Snackbar snackbar ) { snackbar . set Action Text Color ( Context Compat . get Color ( context , R . color . white ) ) ; }
public void handle Server Name Href Request ( Request Invocation Event event ) { forward To ( ) ; }
private String prep Operand ( String label ) { String Builder sb = new String Builder ( STR_ ) ; sb . append ( label ) ; sb . append ( Lop . DATATYPE PREFIX ) ; sb . append ( get Data Type ( ) ) ; sb . append ( Lop . VALUETYPE PREFIX ) ; sb . append ( get Value Type ( ) ) ; return sb . to String ( ) ; }
private static Set < String > remove Redundant Privileges ( Session session , String [ ] privileges , String [ ] actions ) throws Repository Exception { final Cq Actions cq Actions = new Cq Actions ( session ) ; final Set < String > cleaned Privileges = new Hash Set < String > ( ) ; if ( privileges == null ) { return cleaned Privileges ; } cleaned Privileges . add All ( Arrays . as List ( privileges ) ) ; if ( actions == null ) { return cleaned Privileges ; } for ( final String action : actions ) { @ Suppress Warnings ( STR_ ) final Set < Privilege > covered Privileges = cq Actions . get Privileges ( action ) ; for ( final Privilege covered Privilege : covered Privileges ) { cleaned Privileges . remove ( covered Privilege . get Name ( ) ) ; } } return cleaned Privileges ; }
public void clear Info Text ( int state ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + state ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STR_ , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM_ ) { throw new Auth Login Exception ( bundle Name , STR_ , null ) ; } Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM_ ) ) [ NUM_ ] ; List < String > info Texts = pc . get Info Text ( ) ; for ( int i = NUM_ ; i < info Texts . size ( ) ; i ++ ) { info Texts . set ( i , EMPTY STRING ) ; } pc . set Info Text ( info Texts ) ; }
public static Map < String , Object > create Order Note ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Delegator delegator = dctx . get Delegator ( ) ; Local Dispatcher dispatcher = dctx . get Dispatcher ( ) ; Generic Value user Login = ( Generic Value ) context . get ( STR_ ) ; String note String = ( String ) context . get ( STR_ ) ; String note Name = ( String ) context . get ( STR_ ) ; String order Id = ( String ) context . get ( STR_ ) ; String internal Note = ( String ) context . get ( STR_ ) ; Map < String , Object > note Ctx = Util Misc . < String , Object > to Map ( STR_ , note String , STR_ , user Login , STR_ , note Name ) ; Locale locale = ( Locale ) context . get ( STR_ ) ; try { Map < String , Object > note Res = dispatcher . run Sync ( STR_ , note Ctx ) ; if ( Service Util . is Error ( note Res ) ) return note Res ; String note Id = ( String ) note Res . get ( STR_ ) ; if ( Util Validate . is Empty ( note Id ) ) { return Service Util . return Error ( Util Properties . get Message ( resource error , STR_ , locale ) ) ; } Map < String , String > fields = Util Misc . < String , String > to Map ( STR_ , order Id , STR_ , note Id , STR_ , internal Note ) ; Generic Value v = delegator . make Value ( STR_ , fields ) ; delegator . create ( v ) ; } catch ( Generic Entity Exception ee ) { Debug . log Error ( ee , module ) ; return Service Util . return Error ( Util Properties . get Message ( resource , STR_ , Util Misc . to Map ( STR_ , ee . get Message ( ) ) , locale ) ) ; } catch ( Generic Service Exception se ) { Debug . log Error ( se , module ) ; return Service Util . return Error ( Util Properties . get Message ( resource , STR_ , Util Misc . to Map ( STR_ , se . get Message ( ) ) , locale ) ) ; } return Service Util . return Success ( ) ; }
@ Override public boolean input ( Instance instance ) { return m attribute Filter . input ( instance ) ; }
public static void delete Collection Level Snapshot ( Solr Zk Client zk Client , String collection Name , String commit Name ) throws Interrupted Exception , Keeper Exception { String zk Path = get Snapshot Meta Data Zk Path ( collection Name , Optional . of ( commit Name ) ) ; zk Client . delete ( zk Path , - NUM_ , true ) ; }
private static Map . Entry < String , String > maybe Truncate Tag Entry ( Map . Entry < String , String > tag entry ) { String k = tag entry . get Key ( ) ; String v = tag entry . get Value ( ) ; if ( k . length ( ) + v . length ( ) <= MAX TAG KEY VAL CHARS - NUM_ ) return tag entry ; if ( k . length ( ) > TRUNCATE TAG NAME ) k = k . substring ( NUM_ , TRUNCATE TAG NAME ) ; if ( k . length ( ) + v . length ( ) > MAX TAG KEY VAL CHARS - NUM_ ) v = v . substring ( NUM_ , MAX TAG KEY VAL CHARS - NUM_ - k . length ( ) ) ; return Simple Map Entry . create ( k , v ) ; }
public URL generate URL ( ) throws Malformed URL Exception { return compute Composite Update Site URL ( Gdt Ext Plugin . FEATURE UPDATE SITE URL , null , null , null , null , null ) ; }
public void message ( Loco Net Message m ) { log . debug ( STR_ ) ; if ( ! m Run Button . is Selected ( ) ) { return ; } if ( ! ( m Next Echo . equals ( m ) ) ) { return ; } start Sequence Delay ( ) ; }
public static String clean Path Segment ( final String to Clean ) { final String cleaned = to Clean . replace All ( STR_ , STR_ ) ; if ( cleaned . length ( ) == NUM_ ) throw new Illegal State Exception ( STR_ + to Clean + STR_ ) ; return cleaned ; }
public static JAXB Context create Ttml Jaxb Context ( ) throws JAXB Exception { return JAXB Context . new Instance ( TTML PACKAGES ) ; }
public static Decimal Style of ( Locale locale ) { Objects . require Non Null ( locale , STR_ ) ; Decimal Style info = CACHE . get ( locale ) ; if ( info == null ) { info = create ( locale ) ; CACHE . put If Absent ( locale , info ) ; info = CACHE . get ( locale ) ; } return info ; }
@ Override protected List < String > create New Export Mask Workflow For Initiators ( List < URI > initiator UR Is , Export Group export Group , Workflow workflow , Map < URI , Integer > volume Map , Storage System storage , String token , String previous Step ) throws Exception { List < String > new Steps = new Array List < > ( ) ; if ( ! initiator UR Is . is Empty ( ) ) { Map < String , List < URI > > compute Resource To Initiators = map Initiators To Compute Resource ( export Group , initiator UR Is ) ; for ( Map . Entry < String , List < URI > > resource Entry : compute Resource To Initiators . entry Set ( ) ) { String compute Key = resource Entry . get Key ( ) ; List < URI > compute Initiator UR Is = resource Entry . get Value ( ) ; log . info ( String . format ( STR_ , compute Key ) ) ; Gen Export Mask Create Workflow Result result = generate Device Specific Export Mask Create Work Flow ( workflow , previous Step , storage , export Group , compute Initiator UR Is , volume Map , token ) ; previous Step = result . get Step Id ( ) ; } } new Steps . add ( previous Step ) ; return new Steps ; }
public static Indexed Connectivity serializable Instance ( ) { return new Indexed Connectivity ( Basic Lag Graph . serializable Instance ( ) ) ; }
public Commitment commit ( byte [ ] message ) { if ( message . length > byte Length / NUM_ ) { throw new Data Length Exception ( STR_ ) ; } byte [ ] w = new byte [ byte Length - message . length ] ; random . next Bytes ( w ) ; return new Commitment ( w , calculate Commitment ( w , message ) ) ; }
public void remove Listener ( Connectable Device Listener listener ) { listeners . remove ( listener ) ; }
public static int make List Item Survey Resp ( Delegator delegator , Generic Value item , List < String > survey Resps ) throws Generic Entity Exception { if ( Util Validate . is Not Empty ( survey Resps ) ) { int count = NUM_ ; for ( String response Id : survey Resps ) { Generic Value list Resp = delegator . make Value ( STR_ ) ; list Resp . set ( STR_ , item . get String ( STR_ ) ) ; list Resp . set ( STR_ , item . get String ( STR_ ) ) ; list Resp . set ( STR_ , response Id ) ; delegator . create ( list Resp ) ; count ++ ; } return count ; } return - NUM_ ; }
protected String compute Extension ( String packaging ) { String extension ; if ( packaging . equals Ignore Case ( Deployable . EJB ) || packaging . equals Ignore Case ( Deployable . BUNDLE ) ) { extension = STR_ ; } else if ( packaging . equals Ignore Case ( Deployable . UBERWAR ) ) { extension = STR_ ; } else if ( packaging . starts With ( Deployable . JBOSS ) ) { extension = packaging . substring ( Deployable . JBOSS STRIP ) ; } else { extension = packaging ; } return extension ; }
public Trigger Is NPC Name For Unstarted Quest Condition ( final String region ) { this . regions = Arrays . as List ( region ) ; }
static String escape String For ASCII ( String s ) { String out = STR_ ; char [ ] c Array = s . to Char Array ( ) ; for ( int i = NUM_ ; i < c Array . length ; i ++ ) { char c = c Array [ i ] ; if ( c > NUM_ ) { out += STR_ ; String hex = Integer . to Hex String ( c ) ; while ( hex . length ( ) < NUM_ ) hex = STR_ + hex ; out += hex ; } else if ( c == STR_ ) { out += STR_ ; } else if ( c == STR_ ) { out += STR_ ; } else if ( c == STR_ ) { out += STR_ ; } else if ( c == STR_ ) { out += STR_ ; } else if ( c == STR_ ) { out += STR_ ; } else if ( c == STR_ ) { out += STR_ ; } else { out += c ; } } return out ; }
public void crab Down Dir Block For Read ( Block Id blk ) { lock Tbl . s Lock ( blk , tx Num ) ; read Index Blks . add ( blk ) ; }
private void schedule Cache Cleanup ( Context context ) { if ( ! is Alarm Active ( context ) ) { m Alarm Manager . set Inexact Repeating ( Alarm Manager . ELAPSED REALTIME WAKEUP , System Clock . elapsed Realtime ( ) + CLEANUP SCHEDULER TIME INTERVAL , CLEANUP SCHEDULER TIME INTERVAL , Cache Cleanup Receiver . make Receiver Pending Intent ( context ) ) ; } }
public void add Rendering Hints ( Map < ? , ? > hints ) { m Graphics . add Rendering Hints ( hints ) ; }
public Run Stats delegate Get Bucket For Fourthousand Year Dates ( int buckets ) throws Exception { long start Time = System . current Time Millis ( ) ; Primary Index Bucket Generator Impl ibg = new Primary Index Bucket Generator Impl ( Field Data Type . DATE TIME , buckets ) ; Primary Index Bucket Locator Impl locator = new Primary Index Bucket Locator Impl ( null , ibg . generate Buckets ( ) , null , null , null , null , null , null , null ) ; logger . debug ( STR_ ) ; Simple Date Format simple Dt Format = new Simple Date Format ( STR_ ) ; String start Date = STR_ ; Hash Map < Long , List < Object > > hm = new Hash Map < > ( ) ; Summary Statistics stats = new Summary Statistics ( ) ; Date date = null ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { date = simple Dt Format . parse ( start Date ) ; final Date TIME = new Date ( ( long ) ( Math . random ( ) * NUM_ ) ) ; date . set Time ( date . get Time ( ) + TIME . get Time ( ) ) ; Long bucket Id = locator . get Bucket ( start Date , Field Data Type . DATE TIME ) ; calculate ( hm , stats , bucket Id , start Date ) ; date . set Time ( date . get Time ( ) + NUM_ - TIME . get Time ( ) ) ; start Date = simple Dt Format . format ( date . get Time ( ) ) ; } long run Time = System . current Time Millis ( ) - start Time ; Run Stats run Stats = new Run Stats ( STR_ , Field Data Type . DATE TIME , run Time , stats , hm ) ; logger . debug ( run Stats . to String ( ) ) ; return run Stats ; }
@ Override public Thread schedule Collector Context ( Collector Context context ) { Trace . trace ( Item . SCHEDULER , STR_ ) ; Collector Thread t = new Collector Thread ( this , context , false ) ; collector Threads . add ( t ) ; context . init Collector ( collector Threads . size ( ) ) ; return t ; }
public void append Element Label ( I Java Element element , long flags ) { int type = element . get Element Type ( ) ; I Package Fragment Root root = null ; if ( type != I Java Element . JAVA MODEL && type != I Java Element . JAVA PROJECT && type != I Java Element . PACKAGE FRAGMENT ROOT ) root = Java Model Util . get Package Fragment Root ( element ) ; if ( root != null && get Flag ( flags , Java Element Labels . PREPEND ROOT PATH ) ) { append Package Fragment Root Label ( root , Java Element Labels . ROOT QUALIFIED ) ; f Buffer . append ( Java Element Labels . CONCAT STRING ) ; } switch ( type ) { case I Java Element . METHOD : append Method Label ( ( I Method ) element , flags ) ; break ; case I Java Element . FIELD : append Field Label ( ( I Field ) element , flags ) ; break ; case I Java Element . LOCAL VARIABLE : append Local Variable Label ( ( I Local Variable ) element , flags ) ; break ; case I Java Element . TYPE PARAMETER : append Type Parameter Label ( ( I Type Parameter ) element , flags ) ; break ; case I Java Element . INITIALIZER : append Initializer Label ( ( I Initializer ) element , flags ) ; break ; case I Java Element . TYPE : append Type Label ( ( I Type ) element , flags ) ; break ; case I Java Element . CLASS FILE : append Class File Label ( ( I Class File ) element , flags ) ; break ; case I Java Element . COMPILATION UNIT : append Compilation Unit Label ( ( I Compilation Unit ) element , flags ) ; break ; case I Java Element . PACKAGE FRAGMENT : append Package Fragment Label ( ( I Package Fragment ) element , flags ) ; break ; case I Java Element . PACKAGE FRAGMENT ROOT : append Package Fragment Root Label ( ( I Package Fragment Root ) element , flags ) ; break ; case I Java Element . IMPORT CONTAINER : case I Java Element . IMPORT DECLARATION : case I Java Element . PACKAGE DECLARATION : append Declaration Label ( element , flags ) ; break ; case I Java Element . JAVA PROJECT : case I Java Element . JAVA MODEL : f Buffer . append ( element . get Element Name ( ) ) ; break ; default : f Buffer . append ( element . get Element Name ( ) ) ; } if ( root != null && get Flag ( flags , Java Element Labels . APPEND ROOT PATH ) ) { int offset = f Buffer . length ( ) ; f Buffer . append ( Java Element Labels . CONCAT STRING ) ; append Package Fragment Root Label ( root , Java Element Labels . ROOT QUALIFIED ) ; } }
public void finish ( ) { if ( ! is Finished ( ) ) { start Time = System . current Time Millis ( ) - duration ; current Motion Time = - NUM_ ; } }
public void closed ( final Socket Channel channel ) { remove All ( channel ) ; }
public static double raw Probability ( double x , double lambda ) { if ( lambda == NUM_ ) { return ( ( x == NUM_ ) ? NUM_ : NUM_ ) ; } if ( Double . is Infinite ( lambda ) || x < NUM_ ) { return NUM_ ; } if ( x <= lambda * Double . MIN NORMAL ) { return Math . exp ( - lambda ) ; } if ( lambda < x * Double . MIN NORMAL ) { double r = - lambda + x * Math . log ( lambda ) - Gamma Distribution . log Gamma ( x + NUM_ ) ; return Math . exp ( r ) ; } final double f = Math Util . TWOPI * x ; final double y = - stirling Error ( x ) - deviance Term ( x , lambda ) ; return Math . exp ( y ) / Math . sqrt ( f ) ; }
@ Transactional public void update ( ) throws SQL Exception , Task Failed Exception { try { final Simple Date Format sdf = new Simple Date Format ( STR_ ) ; final Simple Date Format formatter = new Simple Date Format ( STR_ ) ; created = formatter . format ( sdf . parse ( created ) ) ; new Update ( ) ; } catch ( final Exception e ) { LOGGER . error ( e . get Message ( ) , e ) ; throw task Exc ; } }
public void start ( ) { thd = new Thread ( this , STR_ ) ; thd . start ( ) ; }
public void flush ( ) { flush ( false ) ; }
private List < Substitution < Reference Type > > collect Substitutions ( List < Type Variable > type Parameters , Substitution < Reference Type > substitution ) { List < Type Variable > generic Parameters = new Array List < > ( ) ; List < Type Variable > nongeneric Parameters = new Array List < > ( ) ; List < Type Variable > capture Parameters = new Array List < > ( ) ; for ( Type Variable variable : type Parameters ) { if ( variable . has Generic Bound ( ) ) { generic Parameters . add ( variable ) ; } else { if ( variable . is Capture Variable ( ) ) { capture Parameters . add ( variable ) ; } else { nongeneric Parameters . add ( variable ) ; } } } List < Substitution < Reference Type > > substitution List = new Array List < > ( ) ; if ( ! generic Parameters . is Empty ( ) ) { Type Check type Check = Type Check . for Parameters ( generic Parameters ) ; if ( ! nongeneric Parameters . is Empty ( ) ) { List < List < Reference Type > > non Gen Candidates = get Candidate Type Lists ( nongeneric Parameters ) ; if ( non Gen Candidates . is Empty ( ) ) { return new Array List < > ( ) ; } List Enumerator < Reference Type > enumerator = new List Enumerator < > ( non Gen Candidates ) ; while ( enumerator . has Next ( ) ) { Substitution < Reference Type > initial Substitution = substitution . extend ( Substitution . for Args ( nongeneric Parameters , enumerator . next ( ) ) ) ; List < Type Variable > parameters = new Array List < > ( ) ; for ( Type Variable variable : generic Parameters ) { Type Variable param = ( Type Variable ) variable . apply ( initial Substitution ) ; parameters . add ( param ) ; } substitution List . add All ( collect Substitutions ( parameters , initial Substitution ) ) ; } } else { substitution List = get Instantiations ( generic Parameters , substitution , type Check ) ; } if ( substitution List . is Empty ( ) ) { return substitution List ; } } else if ( ! nongeneric Parameters . is Empty ( ) ) { substitution = select And Extend ( nongeneric Parameters , substitution ) ; if ( substitution == null ) { return new Array List < > ( ) ; } substitution List . add ( substitution ) ; } if ( ! capture Parameters . is Empty ( ) ) { List < Substitution < Reference Type > > subst List = new Array List < > ( ) ; if ( substitution List . is Empty ( ) ) { subst List . add ( select And Extend ( capture Parameters , substitution ) ) ; } else { for ( Substitution < Reference Type > s : substitution List ) { subst List . add ( select And Extend ( capture Parameters , s ) ) ; } } substitution List = subst List ; } return substitution List ; }
public void visit All ( Traversal Visitor visitor ) { while ( ! tri Queue . is Empty ( ) ) { Quad Edge Triangle tri = ( Quad Edge Triangle ) tri Queue . remove First ( ) ; process ( tri , visitor ) ; } }
public void finish Term ( ) throws IO Exception { int num Arcs = NUM_ ; int num Dedup Bytes = NUM_ ; analyzed . grow ( analyzed . length ( ) + NUM_ ) ; analyzed . set Length ( analyzed . length ( ) + NUM_ ) ; for ( Entry entry : entries ) { if ( num Arcs == max Num Arcs For Dedup Byte ( num Dedup Bytes ) ) { analyzed . set Byte At ( analyzed . length ( ) - NUM_ , ( byte ) ( num Arcs ) ) ; analyzed . grow ( analyzed . length ( ) + NUM_ ) ; analyzed . set Length ( analyzed . length ( ) + NUM_ ) ; num Arcs = NUM_ ; num Dedup Bytes ++ ; } analyzed . set Byte At ( analyzed . length ( ) - NUM_ , ( byte ) num Arcs ++ ) ; Util . to Ints Ref ( analyzed . get ( ) , scratch Ints ) ; builder . add ( scratch Ints . get ( ) , outputs . new Pair ( entry . weight , entry . payload ) ) ; } max Analyzed Paths Per Output = Math . max ( max Analyzed Paths Per Output , entries . size ( ) ) ; entries . clear ( ) ; }
private void generate Reference Doc ( final String Builder builder , Collection < Sub Command > sub Commands ) { to Ref Entry ( builder , sub Commands ) ; }
private void tst Unknown Job Counters ( ) throws Exception { Ignite Hadoop Client Protocol Provider provider = provider ( ) ; Client Protocol proto = provider . create ( config ( Hadoop Abstract Self Test . REST PORT ) ) ; try { proto . get Job Counters ( new Job ID ( UUID . random UUID ( ) . to String ( ) , - NUM_ ) ) ; fail ( STR_ ) ; } catch ( Exception e ) { assert e instanceof IO Exception : STR_ ; } }
public void fill Default Values ( ) { tf Normalize . set Text ( Double . to String ( Oja Rule . DEFAULT NORMALIZATION FACTOR ) ) ; tf Learning Rate . set Text ( Double . to String ( Oja Rule . DEFAULT LEARNING RATE ) ) ; }
public SRN Creation Dialog ( final Network Panel panel ) { this . panel = panel ; Grid Bag Constraints gbc = new Grid Bag Constraints ( ) ; set Title ( STR_ ) ; gbc . anchor = Grid Bag Constraints . NORTHWEST ; gbc . fill = Grid Bag Constraints . HORIZONTAL ; srn Panel . set My Next Item Row ( NUM_ ) ; gbc . gridy = srn Panel . get My Next Item Row ( ) ; gbc . gridx = NUM_ ; section Separator ( STR_ , gbc , NUM_ ) ; tf Num Inputs . set Columns ( NUM_ ) ; srn Panel . add Item ( STR_ , tf Num Inputs ) ; srn Panel . add Item ( STR_ , hidden Neuron Types , NUM_ ) ; srn Panel . add Item ( STR_ , tf Num Hidden ) ; srn Panel . add Item ( STR_ , output Neuron Types , NUM_ ) ; srn Panel . add Item ( STR_ , tf Num Outputs ) ; fill Field Values ( ) ; Action help Action = new Show Help Action ( STR_ ) ; add Button ( new J Button ( help Action ) ) ; set Content Pane ( srn Panel ) ; }
public void remove Attribute ( String name ) { attributes . remove ( name . to Lower Case ( Locale . ENGLISH ) ) ; }
public void register Data Sent ( long platform Ident ) { Agent Status Data agent Status Data = agent Status Data Map . get ( platform Ident ) ; if ( null != agent Status Data ) { agent Status Data . set Last Data Send Timestamp ( System . current Time Millis ( ) ) ; } }
private boolean is Converted ( ) { return view Graph != null ; }
public void ignore Invoke For Output Events ( Stmt stmt ) { ignore Set . add ( stmt ) ; }
public void execute ( ) { final long start Time = System . current Time Millis ( ) ; if ( DATA MODE FILES . equals ( mode ) && args . length > NUM_ ) { do Files Mode ( ) ; } else if ( DATA MODE ARGS . equals ( mode ) && args . length > NUM_ ) { do Args Mode ( ) ; } else if ( DATA MODE WEB . equals ( mode ) && args . length > NUM_ ) { do Web Mode ( ) ; } else if ( DATA MODE STDIN . equals ( mode ) ) { do Stdin Mode ( ) ; } else { usage Short ( ) ; return ; } if ( commit ) commit ( ) ; if ( optimize ) optimize ( ) ; final long end Time = System . current Time Millis ( ) ; display Timing ( end Time - start Time ) ; }
public void create Chart Print Job ( ) { Printer Job job = Printer Job . get Printer Job ( ) ; Page Format pf = job . default Page ( ) ; Page Format pf 2 = job . page Dialog ( pf ) ; if ( pf 2 != pf ) { job . set Printable ( this , pf 2 ) ; if ( job . print Dialog ( ) ) { try { job . print ( ) ; } catch ( Printer Exception e ) { J Option Pane . show Message Dialog ( this , e ) ; } } } }
private int decode Quant Wordlen ( ) { for ( int ch Num = NUM_ ; ch Num < num Channels ; ch Num ++ ) { Arrays . fill ( ctx . channels [ ch Num ] . qu Wordlen , NUM_ ) ; int ret = decode Channel Wordlen ( ch Num ) ; if ( ret < NUM_ ) { return ret ; } } int i ; for ( i = ctx . num Quant Units - NUM_ ; i >= NUM_ ; i -- ) { if ( ctx . channels [ NUM_ ] . qu Wordlen [ i ] != NUM_ || ( num Channels == NUM_ && ctx . channels [ NUM_ ] . qu Wordlen [ i ] != NUM_ ) ) { break ; } } ctx . used Quant Units = i + NUM_ ; return NUM_ ; }
public static String escape Csv Data ( String data ) { Byte Array Output Stream out = new Byte Array Output Stream ( ) ; Csv Writer writer = new Csv Writer ( new Output Stream Writer ( out ) , STR_ ) ; writer . set Escape Mode ( Csv Writer . ESCAPE MODE BACKSLASH ) ; try { writer . write ( data ) ; writer . close ( ) ; out . close ( ) ; } catch ( IO Exception e ) { } return out . to String ( ) ; }
public void save Current Background ( ) { if ( background . is Present ( ) ) { saved Background = Optional . of ( background . get ( ) ) ; } }
protected void prepare Data Set ( ) { data Set 1 = Arrays . as List ( new String [ ] { STR_ , STR_ , STR_ } ) ; data Set 2 = Arrays . as List ( new String [ ] { STR_ , STR_ , STR_ } ) ; data Set 3 = Arrays . as List ( new String [ ] { STR_ , STR_ , STR_ , STR_ } ) ; }
@ Called By Native private void add Permission Section ( String name , int type , int current Setting Value ) { set Visibility Of Permissions List ( true ) ; m Displayed Permissions . add ( new Page Info Permission Entry ( name , type , Content Setting . from Int ( current Setting Value ) ) ) ; }
public void add Missing Columns ( String trx Name ) { int total = NUM_ ; String sql = STR_ + STR_ ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , trx Name ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) total += add Missing Columns ( new M Print Format ( m ctx , rs , trx Name ) ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } log . info ( STR_ + total ) ; }
public final int exec ( String [ ] args ) throws Exception { final Runtime r = Runtime . get Runtime ( ) ; final Process process = r . exec ( args ) ; return process Output ( process ) ; }
@ Override public List < Period > generate Periods ( Date Time Unit date Time Unit ) { Calendar cal = get Calendar ( ) ; Period period = create Period ( date Time Unit , cal ) ; date Time Unit = create Local Date Unit Instance ( period . get Start Date ( ) , cal ) ; List < Period > periods = Lists . new Array List ( ) ; if ( date Time Unit . get Month ( ) == get Base Month ( ) ) { periods . add ( period ) ; periods . add ( get Next Period ( period ) ) ; } else { periods . add ( get Previous Period ( period ) ) ; periods . add ( period ) ; } return periods ; }
@ Override public void use Default Visual ( ) { m visual . load Icons ( Bean Visual . ICON PATH + STR_ , Bean Visual . ICON PATH + STR_ ) ; }
protected void Create Charset ( Offset Item charset Ref , int nglyphs ) { Output List . add Last ( new Marker Item ( charset Ref ) ) ; Output List . add Last ( new U Int 8 Item ( ( char ) NUM_ ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) NUM_ ) ) ; Output List . add Last ( new U Int 16 Item ( ( char ) ( nglyphs - NUM_ ) ) ) ; }
@ Override public synchronized Object put ( Object key , Object value ) { int action = contains Key ( key ) ? default Action : Pv Change Event . PV ADDED ; return ( put ( key , value , action ) ) ; }
private void migrate CM Settings For User ( int user Id ) { synchronized ( this ) { if ( LOCAL LOGV ) Log . d ( TAG , STR_ + user Id ) ; int rows Migrated = migrate CM Settings For Table ( user Id , CM Database Helper . CM Table Names . TABLE SYSTEM , CM Settings . System . LEGACY SYSTEM SETTINGS ) ; if ( LOCAL LOGV ) Log . d ( TAG , STR_ + rows Migrated + STR_ ) ; rows Migrated = migrate CM Settings For Table ( user Id , CM Database Helper . CM Table Names . TABLE SECURE , CM Settings . Secure . LEGACY SECURE SETTINGS ) ; if ( LOCAL LOGV ) Log . d ( TAG , STR_ + rows Migrated + STR_ ) ; rows Migrated = migrate CM Settings For Table ( user Id , CM Database Helper . CM Table Names . TABLE GLOBAL , CM Settings . Global . LEGACY GLOBAL SETTINGS ) ; if ( LOCAL LOGV ) Log . d ( TAG , STR_ + rows Migrated + STR_ ) ; } }
private static void create And Check Is Directory ( Path dir , File Attribute < ? > ... attrs ) throws IO Exception { try { create Directory ( dir , attrs ) ; } catch ( File Already Exists Exception x ) { if ( ! is Directory ( dir , Link Option . NOFOLLOW LINKS ) ) throw x ; } }
private boolean process Key Up ( int key Code ) { if ( key Code == Key Event . KEYCODE ESCAPE || key Code == Key Event . KEYCODE BACK ) { if ( is Cancelable ( ) ) dismiss ( ) ; return true ; } else if ( key Code == Key Event . KEYCODE TAB ) { if ( m In Kb Mode ) { if ( is Typed Time Fully Legal ( ) ) { finish Kb Mode ( true ) ; } return true ; } } else if ( key Code == Key Event . KEYCODE ENTER ) { if ( m In Kb Mode ) { if ( ! is Typed Time Fully Legal ( ) ) { return true ; } finish Kb Mode ( false ) ; } if ( m Callback != null ) { m Callback . on Time Set ( m Time Picker , m Time Picker . get Hours ( ) , m Time Picker . get Minutes ( ) , m Time Picker . get Seconds ( ) ) ; } dismiss ( ) ; return true ; } else if ( key Code == Key Event . KEYCODE DEL ) { if ( m In Kb Mode ) { if ( ! m Typed Times . is Empty ( ) ) { int deleted = delete Last Typed Key ( ) ; String deleted Key Str ; if ( deleted == get Am Or Pm Key Code ( AM ) ) { deleted Key Str = m Am Text ; } else if ( deleted == get Am Or Pm Key Code ( PM ) ) { deleted Key Str = m Pm Text ; } else { deleted Key Str = String . format ( STR_ , get Val From Key Code ( deleted ) ) ; } Utils . try Accessibility Announce ( m Time Picker , String . format ( m Deleted Key Format , deleted Key Str ) ) ; update Display ( true ) ; } } } else if ( key Code == Key Event . KEYCODE 0 || key Code == Key Event . KEYCODE 1 || key Code == Key Event . KEYCODE 2 || key Code == Key Event . KEYCODE 3 || key Code == Key Event . KEYCODE 4 || key Code == Key Event . KEYCODE 5 || key Code == Key Event . KEYCODE 6 || key Code == Key Event . KEYCODE 7 || key Code == Key Event . KEYCODE 8 || key Code == Key Event . KEYCODE 9 || ( ! m Is 24 Hour Mode && ( key Code == get Am Or Pm Key Code ( AM ) || key Code == get Am Or Pm Key Code ( PM ) ) ) ) { if ( ! m In Kb Mode ) { if ( m Time Picker == null ) { Log . e ( TAG , STR_ ) ; return true ; } m Typed Times . clear ( ) ; try Starting Kb Mode ( key Code ) ; return true ; } if ( add Key If Legal ( key Code ) ) { update Display ( false ) ; } return true ; } return false ; }
public List < Expected Partition Value Entity > create Expected Partition Value Process Dates For April 2014 ( String partition Key Group Name ) { return create Expected Partition Value Process Dates ( partition Key Group Name , new Gregorian Calendar ( NUM_ , NUM_ , NUM_ ) , new Gregorian Calendar ( NUM_ , NUM_ , NUM_ ) ) ; }
public static String make Length ( String s , int n , boolean b Right Justify ) { int l = s . length ( ) ; if ( l == n ) { return s ; } else if ( l < n ) { if ( b Right Justify ) { return SPACES . substring ( NUM_ , n - l ) + s ; } return s + SPACES . substring ( NUM_ , n - l ) ; } else { return s . substring ( NUM_ , n - NUM_ ) + STR_ ; } }
public void install Defaults ( Sea Glass Context context , Seaglass UI ui ) { if ( ! context . is Subregion ( ) ) { J Component c = context . get Component ( ) ; Border border = c . get Border ( ) ; if ( border == null || border instanceof UI Resource ) { c . set Border ( new Sea Glass Border ( ui , get Insets ( context , null ) ) ) ; } } install Defaults ( context ) ; }
public Object visit ( Property Is Null filter , Object extra Data ) { LOGGER . finer ( STR_ ) ; Expression expr = filter . get Expression ( ) ; expr . accept ( this , extra Data ) ; return extra Data ; }
public Connection put Connection ( Connection connection ) { return connections . put ( connection . get Identifier ( ) , connection ) ; }
private String concat ( List < I Line Segment > list ) { String Builder res = new String Builder ( ) ; Node < I Line Segment > n = list . head ( ) ; while ( n != null ) { res . append ( n . value ( ) ) ; n = n . next ( ) ; if ( n != null ) { res . append ( STR_ ) ; } } return res . to String ( ) ; }
public void edit Text ( Visual Item item , String attribute , Rectangle r ) { if ( m editing ) { stop Editing ( ) ; } String txt = item . get String ( attribute ) ; m edit Item = item ; m edit Attribute = attribute ; Color tc = Color Lib . get Color ( item . get Text Color ( ) ) ; Color fc = Color Lib . get Color ( item . get Fill Color ( ) ) ; m editor . set Foreground ( tc ) ; m editor . set Background ( fc ) ; edit Text ( txt , r ) ; }
public void append To Content Buffer ( String append ) { if ( content Buffer == null ) { content Buffer = new String Buffer ( append ) ; } else { content Buffer . append ( STR_ ) ; content Buffer . append ( append ) ; } }
private String generate Storage Port Key ( Storage HA Domain vplex Director , String object Name ) { return String . format ( STR_ , vplex Director . get Native Guid ( ) , object Name ) ; }
@ Override public void run ( ) { am I Active = true ; String input Header = null ; String output Header = null ; String histo File = null ; double range = NUM_ ; int num Iterations = NUM_ ; double z = NUM_ ; int row , col ; float progress = NUM_ ; double [ ] data 1 ; double [ ] data 2 ; if ( args . length <= NUM_ ) { show Feedback ( STR_ ) ; return ; } for ( int i = NUM_ ; i < args . length ; i ++ ) { if ( i == NUM_ ) { input Header = args [ i ] ; } else if ( i == NUM_ ) { output Header = args [ i ] ; } else if ( i == NUM_ ) { histo File = args [ i ] ; } else if ( i == NUM_ ) { range = Double . parse Double ( args [ i ] ) ; } else if ( i == NUM_ ) { num Iterations = Integer . parse Int ( args [ i ] ) ; } else if ( i == NUM_ ) { num Bands = Integer . parse Int ( args [ i ] ) ; } } if ( ( input Header == null ) || ( output Header == null ) ) { show Feedback ( STR_ ) ; return ; } try { DEM = new Whitebox Raster ( input Header , STR_ ) ; rows = DEM . get Number Rows ( ) ; cols = DEM . get Number Columns ( ) ; no Data = DEM . get No Data Value ( ) ; double [ ] [ ] output = new double [ rows ] [ cols ] ; for ( int iteration Num = NUM_ ; iteration Num < num Iterations ; iteration Num ++ ) { if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * NUM_ / NUM_ ) ; update Progress ( STR_ + ( iteration Num + NUM_ ) + STR_ + num Iterations + STR_ , ( int ) progress ) ; temp Grid 1 = new double [ rows ] [ cols ] ; temp Grid 2 = new double [ rows ] [ cols ] ; for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { temp Grid 2 [ row ] [ col ] = no Data ; } } Turning Band Simulation ( range ) ; if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * NUM_ / NUM_ ) ; update Progress ( STR_ + ( iteration Num + NUM_ ) + STR_ + num Iterations + STR_ , ( int ) progress ) ; Histogram Matching ( histo File ) ; if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * NUM_ / NUM_ ) ; update Progress ( STR_ + ( iteration Num + NUM_ ) + STR_ + num Iterations + STR_ , ( int ) progress ) ; for ( row = NUM_ ; row < rows ; row ++ ) { data 1 = DEM . get Row Values ( row ) ; for ( col = NUM_ ; col < cols ; col ++ ) { if ( data 1 [ col ] != no Data ) { temp Grid 1 [ row ] [ col ] = data 1 [ col ] + temp Grid 2 [ row ] [ col ] ; } else { temp Grid 1 [ row ] [ col ] = no Data ; } } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * NUM_ / NUM_ ) ; update Progress ( STR_ + ( iteration Num + NUM_ ) + STR_ + num Iterations + STR_ , ( int ) progress ) ; Fill Depressions ( ) ; if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * NUM_ / NUM_ ) ; update Progress ( STR_ + ( iteration Num + NUM_ ) + STR_ + num Iterations + STR_ , ( int ) progress ) ; for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { if ( temp Grid 2 [ row ] [ col ] > temp Grid 1 [ row ] [ col ] ) { output [ row ] [ col ] += NUM_ ; } } } progress = ( float ) ( NUM_ * NUM_ / NUM_ ) ; update Progress ( STR_ + ( iteration Num + NUM_ ) + STR_ + num Iterations + STR_ , ( int ) progress ) ; if ( cancel Op ) { cancel Operation ( ) ; return ; } } output File = new Whitebox Raster ( output Header , STR_ , input Header , Whitebox Raster . Data Type . FLOAT , NUM_ ) ; output File . set Preferred Palette ( STR_ ) ; for ( row = NUM_ ; row < rows ; row ++ ) { data 1 = DEM . get Row Values ( row ) ; for ( col = NUM_ ; col < cols ; col ++ ) { if ( data 1 [ col ] != no Data ) { output File . set Value ( row , col , output [ row ] [ col ] ) ; } else { output File . set Value ( row , col , no Data ) ; } } } output File . add Metadata Entry ( STR_ + get Descriptive Name ( ) + STR_ ) ; output File . add Metadata Entry ( STR_ + new Date ( ) ) ; DEM . close ( ) ; output File . close ( ) ; return Data ( output Header ) ; } catch ( Out Of Memory Error oe ) { my Host . show Feedback ( STR_ ) ; } catch ( Exception e ) { my Host . show Feedback ( STR_ ) ; my Host . log Exception ( STR_ + get Descriptive Name ( ) , e ) ; } finally { update Progress ( STR_ , NUM_ ) ; am I Active = false ; my Host . plugin Complete ( ) ; } }
@ Override public String generate Label ( XY Dataset dataset , int series , int category ) { return null ; }
public Dava Flow Set process Abrupt Statements ( Stmt s , Dava Flow Set input ) { if ( s instanceof Return Stmt || s instanceof Ret Stmt || s instanceof Return Void Stmt ) { return NOPATH ; } else if ( s instanceof D Abrupt Stmt ) { D Abrupt Stmt ab Stmt = ( D Abrupt Stmt ) s ; if ( ! ( ab Stmt . is Continue ( ) || ab Stmt . is Break ( ) ) ) { throw new Runtime Exception ( STR_ ) ; } Dava Flow Set temp = NOPATH ; SET Node Label node Label = ab Stmt . get Label ( ) ; if ( node Label != null && node Label . to String ( ) != null ) { if ( ab Stmt . is Continue ( ) ) temp . add To Continue List ( node Label . to String ( ) , input ) ; else if ( ab Stmt . is Break ( ) ) temp . add To Break List ( node Label . to String ( ) , input ) ; else throw new Runtime Exception ( STR_ ) ; } else { if ( ab Stmt . is Continue ( ) ) temp . add To Implicit Continues ( ab Stmt , input ) ; else if ( ab Stmt . is Break ( ) ) temp . add To Implicit Breaks ( ab Stmt , input ) ; else throw new Runtime Exception ( STR_ ) ; } return temp ; } else { return process Statement ( s , input ) ; } }
public J Frame construct Application Frame ( ) { J Frame frame = new J Frame ( ) ; J Panel panel = new Connect Four Panel ( ) ; frame . add ( panel , Border Layout . CENTER ) ; frame . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; return frame ; }
public boolean is Available Scope ( @ Not Null State scope ) { return scopes . contains ( scope ) ; }
private Method Type ( Class < ? > rtype , Class < ? > [ ] ptypes , boolean trusted ) { check Rtype ( rtype ) ; check Ptypes ( ptypes ) ; this . rtype = rtype ; this . ptypes = trusted ? ptypes : Arrays . copy Of ( ptypes , ptypes . length ) ; }
public boolean equals ( Object o ) { if ( o instanceof Name ) { Comparator < String > c = ASCII Case Insensitive Comparator . CASE INSENSITIVE ORDER ; return c . compare ( name , ( ( Name ) o ) . name ) == NUM_ ; } else { return false ; } }
private void initialize Clustering ( ) { assert data Point Set != null ; assert cluster List != null ; Iterator < String > it = data Point Set . iterator ( ) ; while ( it . has Next ( ) ) { Array List < String > data Set = new Array List < String > ( ) ; data Set . add ( it . next ( ) ) ; Cluster a Cluster = new Cluster ( data Set ) ; cluster List . add ( a Cluster ) ; } }
private Validator create Validator ( Schema schema ) { Stack stack = ( Stack ) validator Handler Cache . get ( schema ) ; if ( stack == null ) { stack = new Stack ( ) ; validator Handler Cache . put ( schema , stack ) ; } if ( stack . empty ( ) ) return schema . create Validator ( properties ) ; return ( Validator ) stack . pop ( ) ; }
public void fill Default Values ( ) { STDP Rule template = new STDP Rule ( ) ; tf Tau Plus . set Text ( STR_ + template . get Tau plus ( ) ) ; tf Tau Minus . set Text ( STR_ + template . get Tau minus ( ) ) ; tf W Plus . set Text ( STR_ + template . get W plus ( ) ) ; tf W Minus . set Text ( STR_ + template . get W minus ( ) ) ; tf Learning Rate . set Text ( STR_ + template . get Learning Rate ( ) ) ; }
@ Override public final boolean is Non Paired Magic Word ( String missing ) { return ( missing == null || missing . equals Ignore Case ( STR_ ) ) ; }
public synchronized void remove Vetoable Change Listener ( Vetoable Change Listener l ) { m vetoable Change Support . remove Vetoable Change Listener ( l ) ; }
public static long nano Time ( ) { was Time Accessed = true ; return current Time * NUM_ ; }
public void destroy ( ) { if ( m Native Bookmarks Bridge != NUM_ ) { native Destroy ( m Native Bookmarks Bridge ) ; m Native Bookmarks Bridge = NUM_ ; m Is Native Bookmark Model Loaded = false ; m Delayed Bookmark Callbacks . clear ( ) ; } m Observers . clear ( ) ; }
public void cut ( ) { build ( ) ; is Cut = true ; for ( Task t : get Tasks ( ) ) { my Assignments . add All ( Arrays . as List ( t . get Assignments ( ) ) ) ; my Task Manager . delete Task ( t ) ; t . delete ( ) ; } }
private void label Isolated Nodes ( ) { for ( Iterator ni = nodes . iterator ( ) ; ni . has Next ( ) ; ) { Node n = ( Node ) ni . next ( ) ; Label label = n . get Label ( ) ; Assert . is True ( label . get Geometry Count ( ) > NUM_ , STR_ ) ; if ( n . is Isolated ( ) ) { if ( label . is Null ( NUM_ ) ) label Isolated Node ( n , NUM_ ) ; else label Isolated Node ( n , NUM_ ) ; } } }
public int hash Code ( ) { int result = NUM_ ; int increment = Math . min ( NUM_ , values . length / NUM_ ) ; for ( int i = NUM_ ; i < values . length ; i += increment ) { result = result * NUM_ + values [ i ] ; } return result ; }
static void add To Timestamp ( String operation , String Builder sb ) { if ( operation != null ) sb . append ( operation ) ; sb . append ( STR_ ) ; }
protected void add Form ( Element e , Xhtml Form f ) { if ( forms == null ) { forms = new Linked Hash Map ( ) ; } forms . put ( e , f ) ; }
public boolean equals ( Object obj ) { if ( obj instanceof Activation ID ) { Activation ID id = ( Activation ID ) obj ; return ( uid . equals ( id . uid ) && activator . equals ( id . activator ) ) ; } else { return false ; } }
@ Override public List refresh Ticks ( Graphics 2 D g 2 , Axis State state , Rectangle 2 D data Area , Rectangle Edge edge ) { return Collections . EMPTY LIST ; }
public void clean Up ( ) { top Snapshot . set ( null ) ; single Msgs . clear ( ) ; full Msgs . clear ( ) ; crd = null ; part Release Fut = null ; }
private void internal Coord Copy ( int [ ] coords ) { if ( ( this . coord Copy == null ) || ( this . coord Copy . length != coords . length ) ) { this . coord Copy = new int [ coords . length ] ; } System . arraycopy ( coords , NUM_ , coord Copy , NUM_ , coords . length ) ; }
public File Processor add Input Suffix ( String ... suffixes ) { for ( String suffix : suffixes ) add Input Regex ( STR_ + Pattern . quote ( suffix ) ) ; return this ; }
public void sleep ( long millis ) { try { Thread . sleep ( millis ) ; } catch ( Interrupted Exception e ) { } }
protected void stop Message Loop If No Instances ( ) { synchronized ( web View UI Lock ) { if ( instances . get ( ) <= NUM_ ) { Windows Web View JNI . release Message Loop ( web View Message Loop ) ; web View Message Loop = NUM_ ; web View UI = null ; } } }
public static Redeem Data of ( EC Key key , Script program ) { check Argument ( program . is Sent To Address ( ) || program . is Sent To Raw Pub Key ( ) ) ; return key != null ? new Redeem Data ( Collections . singleton List ( key ) , program ) : null ; }
public void remove Datatransfer Progress Listener ( On Datatransfer Progress Listener listener , Account account , OC File file ) { if ( account == null || file == null || listener == null ) return ; String target Key = build Remote Name ( account . name , file . get Remote Path ( ) ) ; if ( m Bound Listeners . get ( target Key ) == listener ) { m Bound Listeners . remove ( target Key ) ; } }
private int indexed Binary Search ( List < S 2 Cell Id > l , S 2 Cell Id key , int low ) { int high = l . size ( ) - NUM_ ; while ( low <= high ) { int mid = ( low + high ) > > NUM_ ; S 2 Cell Id mid Val = l . get ( mid ) ; int cmp = mid Val . compare To ( key ) ; if ( cmp < NUM_ ) { low = mid + NUM_ ; } else if ( cmp > NUM_ ) { high = mid - NUM_ ; } else { return mid ; } } return low ; }
@ Override public List < Period > generate Periods ( Date Time Unit date Time Unit ) { Calendar calendar = get Calendar ( ) ; date Time Unit = calendar . minus Years ( date Time Unit , NUM_ ) ; date Time Unit . set Day ( NUM_ ) ; date Time Unit . set Month ( NUM_ ) ; List < Period > periods = Lists . new Array List ( ) ; for ( int i = NUM_ ; i < NUM_ ; ++ i ) { periods . add ( create Period ( date Time Unit , calendar ) ) ; date Time Unit = calendar . plus Years ( date Time Unit , NUM_ ) ; } return periods ; }
private byte [ ] fetch Guid ( ) { Prepared Statement stmt = null ; Result Set rows = null ; String sqltext = SELECT GUID ; byte [ ] data = null ; try { metrics . start Timing ( ) ; stmt = conn . prepare Statement ( sqltext ) ; rows = stmt . execute Query ( ) ; if ( rows . next ( ) ) { data = rows . get Bytes ( NUM_ ) ; } rows . close ( ) ; rows = null ; stmt . close ( ) ; stmt = null ; metrics . record GUIDS ( ) ; } catch ( SQL Exception e ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( e . to String ( ) ) ; } finally { for ( String message : SODA Utils . close Cursor ( stmt , rows ) ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( message ) ; } } return ( data ) ; }
protected void init View ( ) { m Month Title Paint = new Paint ( ) ; m Month Title Paint . set Fake Bold Text ( true ) ; m Month Title Paint . set Anti Alias ( true ) ; m Month Title Paint . set Text Size ( MONTH LABEL TEXT SIZE ) ; m Month Title Paint . set Typeface ( Typeface . create ( m Month Title Typeface , Typeface . BOLD ) ) ; m Month Title Paint . set Color ( m Day Text Color ) ; m Month Title Paint . set Text Align ( Align . CENTER ) ; m Month Title Paint . set Style ( Style . FILL ) ; m Month Title BG Paint = new Paint ( ) ; m Month Title BG Paint . set Fake Bold Text ( true ) ; m Month Title BG Paint . set Anti Alias ( true ) ; m Month Title BG Paint . set Color ( m Month Title BG Color ) ; m Month Title BG Paint . set Text Align ( Align . CENTER ) ; m Month Title BG Paint . set Style ( Style . FILL ) ; m Selected Circle Paint = new Paint ( ) ; m Selected Circle Paint . set Fake Bold Text ( true ) ; m Selected Circle Paint . set Anti Alias ( true ) ; m Selected Circle Paint . set Color ( m Today Number Color ) ; m Selected Circle Paint . set Text Align ( Align . CENTER ) ; m Selected Circle Paint . set Style ( Style . FILL ) ; m Selected Circle Paint . set Alpha ( SELECTED CIRCLE ALPHA ) ; m Month Day Label Paint = new Paint ( ) ; m Month Day Label Paint . set Anti Alias ( true ) ; m Month Day Label Paint . set Text Size ( MONTH DAY LABEL TEXT SIZE ) ; m Month Day Label Paint . set Color ( m Month Day Label Text Color ) ; m Month Day Label Paint . set Typeface ( Typeface . create ( m Day Of Week Typeface , Typeface . NORMAL ) ) ; m Month Day Label Paint . set Style ( Style . FILL ) ; m Month Day Label Paint . set Text Align ( Align . CENTER ) ; m Month Day Label Paint . set Fake Bold Text ( true ) ; m Month Num Paint = new Paint ( ) ; m Month Num Paint . set Anti Alias ( true ) ; m Month Num Paint . set Text Size ( MINI DAY NUMBER TEXT SIZE ) ; m Month Num Paint . set Style ( Style . FILL ) ; m Month Num Paint . set Text Align ( Align . CENTER ) ; m Month Num Paint . set Fake Bold Text ( false ) ; }
public boolean check Connectionliveness ( Cim Connection connection ) { boolean is Live = false ; if ( null == connection ) { return is Live ; } WBEM Client wbem Client = connection . get Cim Client ( ) ; log . debug ( STR_ , cop ) ; try { wbem Client . enumerate Instance Names ( cop ) ; is Live = true ; } catch ( WBEM Exception wbem Ex ) { log . error ( STR_ , connection . get Host ( ) ) ; } return is Live ; }
public static void silent Close Input Stream ( Input Stream is ) { try { if ( is != null ) { is . close ( ) ; } } catch ( IO Exception e ) { Log . w ( LOG TAG , STR_ , e ) ; } }
private void fire Object Removed ( Binding old Bd , long change ID ) { if ( naming Listeners == null || naming Listeners . size ( ) == NUM_ ) return ; Naming Event e = new Naming Event ( event Src , Naming Event . OBJECT REMOVED , null , old Bd , new Long ( change ID ) ) ; support . queue Event ( e , naming Listeners ) ; }
public Format Real ( final int in , final int iff ) { if ( in < NUM_ ) { throw new Illegal Argument Exception ( STR_ + in ) ; } if ( iff < NUM_ ) { throw new Illegal Argument Exception ( STR_ + iff ) ; } m Length = NUM_ + in + iff ; m Padding = new char [ m Length ] ; for ( int i = NUM_ ; i < m Length ; i ++ ) { m Padding [ i ] = STR_ ; } final String Builder formatpos = new String Builder ( ) ; final String Builder formatneg = new String Builder ( ) ; formatpos . append ( STR_ ) ; formatneg . append ( STR_ ) ; for ( int i = NUM_ ; i < in ; i ++ ) { formatpos . append ( STR_ ) ; formatneg . append ( STR_ ) ; } formatpos . append ( STR_ ) ; formatneg . append ( STR_ ) ; for ( int i = NUM_ ; i < iff ; i ++ ) { formatpos . append ( STR_ ) ; formatneg . append ( STR_ ) ; } final String format = formatpos . to String ( ) + STR_ + formatneg . to String ( ) ; m Local Format = new Decimal Format ( format ) ; }
public static String read String ( final JSON Array json Array , final int index , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Array . get String ( index ) ; } if ( not Null && json Array . is Null ( index ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT ARRAY , index ) ) ; } String value = null ; if ( ! json Array . is Null ( index ) ) { value = json Array . get String ( index ) ; } return value ; }
public String format Un Mount Cmd ( String data Mover , String path , String protocol ) { String Builder cmd = new String Builder ( ) ; cmd . append ( STR_ ) ; cmd . append ( data Mover ) ; cmd . append ( STR_ ) ; cmd . append ( STR_ ) ; cmd . append ( STR_ ) ; cmd . append ( path ) ; return cmd . to String ( ) ; }
void complete Template Initialization ( final Map < String , Template > templates ) throws Decode Exception { sub Templates = new Array List < > ( ) ; for ( final String subordinate Name : sub Template Names ) { final Template template = templates . get ( subordinate Name . to Lower Case ( ) ) ; if ( template == null ) { throw Decode Exception . fatal Error ( ERR ENTRY GENERATOR UNDEFINED TEMPLATE SUBORDINATE . get ( this . name , subordinate Name ) ) ; } sub Templates . add ( template ) ; } ensure All RDN Attributes Are Defined ( ) ; }
public void add Endpoints ( ) { int max Seg Index = edge . pts . length - NUM_ ; add ( edge . pts [ NUM_ ] , NUM_ , NUM_ ) ; add ( edge . pts [ max Seg Index ] , max Seg Index , NUM_ ) ; }
private void add Finally ( Array List return List , Stmnt finally Block ) throws Compile Error { Bytecode bc = bytecode ; int n = return List . size ( ) ; for ( int i = NUM_ ; i < n ; ++ i ) { final int [ ] ret = ( int [ ] ) return List . get ( i ) ; int pc = ret [ NUM_ ] ; bc . write 16 bit ( pc , bc . current Pc ( ) - pc + NUM_ ) ; Return Hook hook = new Jsr Hook 2 ( this , ret ) ; finally Block . accept ( this ) ; hook . remove ( this ) ; if ( ! has Returned ) { bc . add Opcode ( Opcode . GOTO ) ; bc . add Index ( pc + NUM_ - bc . current Pc ( ) ) ; } } }
public void add Rate Limit ( Rate Limit Type type , Server server , long retry After ) { if ( server == null ) { rate Limits . put ( type , System . current Time Millis ( ) + retry After ) ; } else { Hash Map < Rate Limit Type , Long > rate Limits = server Rate Limits . get ( server ) ; if ( rate Limits == null ) { rate Limits = new Hash Map < > ( ) ; server Rate Limits . put ( server , rate Limits ) ; } rate Limits . put ( type , System . current Time Millis ( ) + retry After ) ; } }
private int create Lines ( String text , int insert Position , int offset ) { int count = NUM_ ; int start = NUM_ ; Delimiter Info delimiter Info = next Delimiter Info ( text , NUM_ ) ; while ( delimiter Info != null && delimiter Info . delimiter Index > - NUM_ ) { int index = delimiter Info . delimiter Index + ( delimiter Info . delimiter Length - NUM_ ) ; if ( insert Position + count >= f Lines . size ( ) ) f Lines . add ( new Line ( offset + start , offset + index , delimiter Info . delimiter ) ) ; else f Lines . add ( insert Position + count , new Line ( offset + start , offset + index , delimiter Info . delimiter ) ) ; ++ count ; start = index + NUM_ ; delimiter Info = next Delimiter Info ( text , start ) ; } if ( start < text . length ( ) ) { if ( insert Position + count < f Lines . size ( ) ) { Line l = ( Line ) f Lines . get ( insert Position + count ) ; int delta = text . length ( ) - start ; l . offset -= delta ; l . length += delta ; } else { f Lines . add ( new Line ( offset + start , offset + text . length ( ) - NUM_ , null ) ) ; ++ count ; } } return count ; }
public static Rect make Rect For Cross Hairs ( int x , int y , int cross Hair Length ) { return new Rect ( x - cross Hair Length , y - cross Hair Length , x + cross Hair Length + NUM_ , y + cross Hair Length + NUM_ ) ; }
public Ignite Thread ( Thread Group grp , String grid Name , String thread Name , Runnable r , int grp Idx ) { super ( grp , r , create Name ( cntr . increment And Get ( ) , thread Name , grid Name ) ) ; this . grid Name = grid Name ; this . grp Idx = grp Idx ; }
public void register Fix ( @ Not Null Intention Action fix , @ Nullable Text Range range , @ Nullable final Highlight Display Key key ) { if ( range == null ) { range = new Text Range ( my Start Offset , my End Offset ) ; } if ( my Quick Fixes == null ) { my Quick Fixes = new Array List < Quick Fix Info > ( ) ; } my Quick Fixes . add ( new Quick Fix Info ( fix , range , key ) ) ; }
public static void print Stats ( Taxonomy Reader r , Print Stream out , boolean print Tree ) throws IO Exception { out . println ( r . get Size ( ) + STR_ ) ; Children Iterator it = r . get Children ( Taxonomy Reader . ROOT ORDINAL ) ; int child ; while ( ( child = it . next ( ) ) != Taxonomy Reader . INVALID ORDINAL ) { Children Iterator chilren It = r . get Children ( child ) ; int num Immediate Children = NUM_ ; while ( chilren It . next ( ) != Taxonomy Reader . INVALID ORDINAL ) { num Immediate Children ++ ; } Facet Label cp = r . get Path ( child ) ; out . println ( STR_ + cp . components [ NUM_ ] + STR_ + num Immediate Children + STR_ + ( NUM_ + count All Children ( r , child ) ) + STR_ ) ; if ( print Tree ) { print All Children ( out , r , child , STR_ , NUM_ ) ; } } }
public Usage Server ( int port , File usage Dir , int threads ) throws IO Exception { if ( ! Charset . is Supported ( UTF 8 ) ) { throw new IO Exception ( STR_ ) ; } System . set Property ( STR_ , STR_ ) ; System . set Property ( STR_ , STR_ ) ; m Usage Dir = usage Dir ; m Port = port ; m Thread Pool Executor = new Thread Pool Executor ( threads , threads , NUM_ , Time Unit . SECONDS , new Linked Blocking Queue < Runnable > ( ) , new Usage Server Thread Factory ( ) ) ; }
public static double erf ( double x ) { return ( igamma ( NUM_ , Math . pow ( x , NUM_ ) ) ) ; }
protected void select Horizontal Auto Tick Unit ( Graphics 2 D g 2 , Rectangle 2 D data Area , Rectangle Edge edge ) { Range range = get Range ( ) ; double log Axis Min = calculate Log ( Math . max ( this . smallest Value , range . get Lower Bound ( ) ) ) ; double log Axis Max = calculate Log ( range . get Upper Bound ( ) ) ; double size = ( log Axis Max - log Axis Min ) / NUM_ ; Tick Unit Source tick Units = get Standard Tick Units ( ) ; Tick Unit candidate = tick Units . get Ceiling Tick Unit ( size ) ; Tick Unit prev Candidate = candidate ; boolean found = false ; while ( ! found ) { this . tick Unit = ( Number Tick Unit ) candidate ; double tick Label Width = estimate Maximum Tick Label Width ( g 2 , candidate ) ; double candidate Width = exponent Length To Java 2 D ( candidate . get Size ( ) , data Area , edge ) ; if ( tick Label Width < candidate Width ) { found = true ; } else if ( Double . is Na N ( candidate Width ) ) { candidate = prev Candidate ; found = true ; } else { prev Candidate = candidate ; candidate = tick Units . get Larger Tick Unit ( prev Candidate ) ; if ( candidate . equals ( prev Candidate ) ) { found = true ; } } } set Tick Unit ( ( Number Tick Unit ) candidate , false , false ) ; }
@ Override protected byte [ ] encrypt ( byte type , byte [ ] fragment , int offset , int len ) { try { int content mac length = len + hash size ; int padding length = ( block size == NUM_ ) ? NUM_ : get Padding Size ( ++ content mac length ) ; byte [ ] res = new byte [ content mac length + padding length ] ; System . arraycopy ( fragment , offset , res , NUM_ , len ) ; mac material header [ NUM_ ] = type ; mac material header [ NUM_ ] = ( byte ) ( ( NUM_ & len ) > > NUM_ ) ; mac material header [ NUM_ ] = ( byte ) ( NUM_ & len ) ; enc Mac . update ( write seq num ) ; enc Mac . update ( mac material header ) ; enc Mac . update ( fragment , offset , len ) ; enc Mac . do Final ( res , len ) ; if ( block size != NUM_ ) { Arrays . fill ( res , content mac length - NUM_ , res . length , ( byte ) ( padding length ) ) ; } if ( logger != null ) { logger . println ( STR_ + ( block size != NUM_ ? STR_ + padding length + STR_ : STR_ ) ) ; logger . print ( res ) ; } byte [ ] rez = new byte [ enc Cipher . get Output Size ( res . length ) ] ; enc Cipher . update ( res , NUM_ , res . length , rez ) ; inc Sequence Number ( write seq num ) ; return rez ; } catch ( General Security Exception e ) { e . print Stack Trace ( ) ; throw new Alert Exception ( Alert Protocol . INTERNAL ERROR , new SSL Protocol Exception ( STR_ ) ) ; } }
public static void put At ( String Buffer self , Int Range range , Object value ) { Range Info info = sub List Borders ( self . length ( ) , range ) ; self . replace ( info . from , info . to , value . to String ( ) ) ; }
public Effect Layer ( int duration ) { this . duration = duration ; timestamp = System . current Time Millis ( ) ; }
public void add Output ( Lop op ) { outputs . add ( op ) ; }
private void stop Drag ( Motion Event ev ) { m Touch Mode = TOUCH MODE IDLE ; boolean commit Change = ev . get Action ( ) == Motion Event . ACTION UP && is Enabled ( ) ; cancel Super Touch ( ev ) ; if ( commit Change ) { boolean new State ; m Velocity Tracker . compute Current Velocity ( NUM_ ) ; float xvel = m Velocity Tracker . get X Velocity ( ) ; if ( Math . abs ( xvel ) > m Min Fling Velocity ) { new State = xvel > NUM_ ; } else { new State = get Target Checked State ( ) ; } animate Thumb To Checked State ( new State ) ; } else { animate Thumb To Checked State ( is Checked ( ) ) ; } }
public void add Notifier ( final DSS Notifier dss Notifier ) { if ( ! notifiers . contains ( dss Notifier ) ) { LOG . trace ( STR_ + dss Notifier ) ; notifiers . add ( dss Notifier ) ; } }
private Identity Generator ( Identity Builder builder ) { time Bits = builder . time Bits ( ) ; is Random = builder . is Random ( ) ; int node Bits = builder . node Bits ( ) ; time Offset = NUM_ - time Bits ; node = Long . reverse ( builder . node ( ) ) > > > time Bits ; sequence Bits = time Offset ; sequence Mask = ( NUM_ << sequence Bits ) - NUM_ ; sequence Random Mask = ( NUM_ << ( sequence Bits - node Bits - NUM_ ) ) - NUM_ ; sequence Increment = NUM_ ; }
protected < N , T extends N > Extension Point Impl < T > register Extension Point ( @ Not Null Extension Point Name < N > name , @ Not Null Class < T > type ) { extensions Area . register Extension Point ( name . get Name ( ) , type . get Name ( ) , new Default Plugin Descriptor ( Plugin Id . get Id ( type . get Name ( ) ) , type . get Class Loader ( ) ) ) ; return extensions Area . get Extension Point ( name . get Name ( ) ) ; }
public void add Builder Set ( Builder builer ) { relations . add All ( builer . relations ) ; }
public static Query create ( Query Parse Context context , Geo Point Field Mapper . Geo Point Field Type field Type , String geohash , @ Nullable List < Char Sequence > geohashes ) { Mapped Field Type geo Hash Mapper = field Type . geohash Field Type ( ) ; if ( geo Hash Mapper == null ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( geohashes == null || geohashes . size ( ) == NUM_ ) { return geo Hash Mapper . term Query ( geohash , context ) ; } else { geohashes . add ( geohash ) ; return geo Hash Mapper . terms Query ( geohashes , context ) ; } }
static String gravity To String ( @ Edge Gravity int gravity ) { if ( ( gravity & Gravity . LEFT ) == Gravity . LEFT ) { return STR_ ; } if ( ( gravity & Gravity . RIGHT ) == Gravity . RIGHT ) { return STR_ ; } return Integer . to Hex String ( gravity ) ; }
public static < T extends I Identifyable > List < T > check Ids ( @ Non Null List < T > items ) { for ( int i = NUM_ , size = items . size ( ) ; i < size ; i ++ ) { check Id ( items . get ( i ) ) ; } return items ; }
public Wave Writer ( Audio Format format , Path file , long max Size ) throws IO Exception { assert ( format != null ) ; assert ( file != null ) ; m Audio Format = format ; m File = file ; if ( NUM_ < max Size && max Size <= MAX WAVE SIZE ) { m Max Size = max Size ; } else { m Max Size = MAX WAVE SIZE ; } open ( ) ; }
private String create Length Minutes Xml ( double length Minutes ) { return STR_ + Double . to String ( length Minutes ) + STR_ ; }
public FXG Node parse ( Input Stream stream , String document Name ) throws FXG Exception , IO Exception { try { scanner . set Document Name ( document Name ) ; SAX Parser Factory sax Factory = SAX Parser Factory . new Instance ( ) ; sax Factory . set Validating ( false ) ; sax Factory . set Namespace Aware ( true ) ; SAX Parser parser = sax Factory . new SAX Parser ( ) ; parser . parse ( stream , scanner ) ; FXG Node node = scanner . get Root Node ( ) ; return node ; } catch ( Parser Configuration Exception ex ) { throw new FXG Exception ( scanner . get Start Line ( ) , scanner . get Start Column ( ) , STR_ , ex . get Localized Message ( ) , ex ) ; } catch ( SAX Exception ex ) { throw new FXG Exception ( scanner . get Start Line ( ) , scanner . get Start Column ( ) , STR_ , ex . get Localized Message ( ) , ex ) ; } finally { stream . close ( ) ; } }
private void show Tag User Fragment ( String wall Id , String wall User Id , String tag Count ) { if ( is Attached ( ) ) { final Intent tag User Activity Intent = new Intent ( get Activity ( ) , Tag User Activity . class ) ; tag User Activity Intent . put Extra ( App Constants . Keys . WALL ID , wall Id ) ; tag User Activity Intent . put Extra ( App Constants . Keys . USER ID , wall User Id ) ; tag User Activity Intent . put Extra ( App Constants . Keys . TAG USER COUNT , Integer . parse Int ( tag Count ) ) ; start Activity ( tag User Activity Intent ) ; } }
public static void process Layout Attributes ( @ Not Null Android Facet facet , @ Not Null Xml Tag tag , @ Not Null Layout Element element , @ Not Null Set < Xml Name > skip Attr Names , @ Not Null Attribute Processor callback ) { Map < String , Psi Class > map = get View Class Map ( facet ) ; if ( ! ( element instanceof Data Binding Element ) ) { register Tools Attribute ( ATTR TARGET API , callback ) ; if ( tag . get Parent Tag ( ) == null ) { register Tools Attribute ( ATTR CONTEXT , callback ) ; register Tools Attribute ( ATTR MENU , callback ) ; register Tools Attribute ( ATTR ACTION BAR NAV MODE , callback ) ; register Tools Attribute ( ATTR SHOW IN , callback ) ; } final Psi Class adapter View = map . get ( ADAPTER VIEW ) ; final Psi Class psi Class = map . get ( tag . get Name ( ) ) ; if ( adapter View != null && psi Class != null && psi Class . is Inheritor ( adapter View , true ) ) { register Tools Attribute ( ATTR LISTITEM , callback ) ; register Tools Attribute ( ATTR LISTHEADER , callback ) ; register Tools Attribute ( ATTR LISTFOOTER , callback ) ; } final Psi Class drawer Layout = map . get ( CLASS DRAWER LAYOUT ) ; if ( drawer Layout != null && psi Class != null && ( psi Class . is Equivalent To ( drawer Layout ) || psi Class . is Inheritor ( drawer Layout , true ) ) ) { register Tools Attribute ( ATTR OPEN DRAWER , callback ) ; } } if ( element instanceof Tag || element instanceof Include || element instanceof Data ) { return ; } String tag Name = tag . get Name ( ) ; switch ( tag Name ) { case VIEW TAG : for ( Psi Class a Class : map . values ( ) ) { final String name = a Class . get Name ( ) ; if ( name == null ) { continue ; } register Attributes ( facet , element , name , callback , skip Attr Names ) ; } break ; case VIEW MERGE : if ( tag . get Parent Tag ( ) == null ) { register Tools Attribute ( ATTR PARENT TAG , callback ) ; } register Attributes For Class And Superclasses ( facet , element , map . get ( VIEW MERGE ) , callback , skip Attr Names ) ; String parent Tag Name = tag . get Attribute Value ( ATTR PARENT TAG , TOOLS URI ) ; if ( parent Tag Name != null ) { register Attributes For Class And Superclasses ( facet , element , map . get ( parent Tag Name ) , callback , skip Attr Names ) ; } break ; default : Psi Class c = map . get ( tag Name ) ; register Attributes For Class And Superclasses ( facet , element , c , callback , skip Attr Names ) ; break ; } if ( tag Name . equals ( VIEW MERGE ) ) { return ; } Xml Tag parent Tag = tag . get Parent Tag ( ) ; if ( parent Tag != null ) { String parent Tag Name = parent Tag . get Name ( ) ; if ( VIEW MERGE . equals ( parent Tag Name ) ) { parent Tag Name = parent Tag . get Attribute Value ( ATTR PARENT TAG , TOOLS URI ) ; } if ( TAG LAYOUT . equals ( parent Tag Name ) ) { parent Tag Name = VIEW GROUP ; } if ( parent Tag Name != null ) { Psi Class c = map . get ( parent Tag Name ) ; while ( c != null ) { register Attributes From Suffixed Styleables ( facet , element , c , callback , skip Attr Names ) ; c = get Superclass ( c ) ; } return ; } } for ( Psi Class c : map . values ( ) ) { register Attributes From Suffixed Styleables ( facet , element , c , callback , skip Attr Names ) ; } }
protected void add Context ( Server Context server Context ) { append Contexts ( Collections . singleton List ( server Context ) ) ; }
private double fix To Range ( double x , double min X , double max X ) { if ( min X > max X ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( x < min X ) { return min X ; } else if ( x > max X ) { return max X ; } else { return x ; } }
GL create GL ( ) { return m Egl Context . get GL ( ) ; }
public static void register M Bean ( Object mbean , Class < ? > mbean Class ) { M Bean Server mbs = Management Factory . get Platform M Bean Server ( ) ; try { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + mbean . get Class ( ) ) ; Object Name name = generate M Bean Object Name ( mbean Class ) ; if ( mbs . is Registered ( name ) ) mbs . unregister M Bean ( name ) ; mbs . register M Bean ( mbean , name ) ; } catch ( Exception e ) { throw new Server Runtime Exception ( String . format ( STR_ , mbean Class . get Name ( ) , e ) , e ) ; } }
public void initialize ( ) { load Helpers = new Linked List < Class Load Helper > ( ) ; load Helpers . add ( new Loading Loader Class Load Helper ( ) ) ; load Helpers . add ( new Simple Class Load Helper ( ) ) ; load Helpers . add ( new Thread Context Class Load Helper ( ) ) ; load Helpers . add ( new Init Thread Context Class Load Helper ( ) ) ; for ( Class Load Helper load Helper : load Helpers ) { load Helper . initialize ( ) ; } }
protected T create Projection ( @ Nullable Collection < Grid Client Node > nodes , @ Nullable Grid Client Predicate < ? super Grid Client Node > filter , @ Nullable Grid Client Load Balancer balancer , Projection Factory < T > factory ) throws Grid Client Exception { if ( nodes != null && nodes . is Empty ( ) ) throw new Grid Client Exception ( STR_ ) ; if ( filter != null && this . filter != null ) filter = new Grid Client And Predicate < > ( this . filter , filter ) ; else if ( filter == null ) filter = this . filter ; Collection < Grid Client Node > subset = intersection ( this . nodes , nodes ) ; if ( subset != null && subset . is Empty ( ) ) throw new Grid Client Exception ( STR_ + STR_ + this . nodes + STR_ + nodes ) ; if ( filter != null && subset != null ) { subset = apply Filter ( subset , filter ) ; if ( subset != null && subset . is Empty ( ) ) throw new Grid Client Exception ( STR_ + STR_ + subset + STR_ + filter + STR_ ) ; } if ( balancer == null ) balancer = this . balancer ; return factory . create ( nodes , filter , balancer ) ; }
public Format Integer ( final int in , final boolean group ) { if ( in < NUM_ ) { throw new Illegal Argument Exception ( STR_ + in ) ; } m Length = in ; m Padding = new char [ m Length ] ; final String Builder sb = new String Builder ( ) ; for ( int i = NUM_ ; i < m Length ; i ++ ) { m Padding [ i ] = STR_ ; sb . append ( STR_ ) ; } m Blanks = sb . to String ( ) ; m Local Format . set Grouping Used ( group ) ; }
static void add Manifest Reference ( Manifest manifest , String uri ) throws Exception { manifest . add Document ( null , STR_ + uri , null , DEFAULT DIGEST ALGORITHM URI , null , null ) ; }
static boolean is Launch Name Matched ( Launch launch , Email Sender Case one Case ) { List < String > configured Names = one Case . get Launch Names ( ) ; return ( null == configured Names ) || ( configured Names . is Empty ( ) ) || configured Names . contains ( launch . get Name ( ) ) ; }
public void add Item ( int position , M model ) { m Datas . add ( position , model ) ; notify Data Set Changed ( ) ; }
private Design File open dialog ( Stat stat , String p design dir name ) { J File Chooser file chooser = new J File Chooser ( p design dir name ) ; File Filter file filter = new File Filter ( Design File . all file extensions ) ; file chooser . set File Filter ( file filter ) ; file chooser . show Open Dialog ( null ) ; File curr design file = file chooser . get Selected File ( ) ; if ( curr design file == null ) return null ; return new Design File ( stat , curr design file , file chooser ) ; }
@ Override public boolean is Inside ( Point point ) { return entity Rect . contains ( point . x , point . y ) ; }
public void read Data ( Data Input din ) throws IO Exception { reference = din . read Unsigned Short ( ) ; bit Count = din . read Unsigned Short ( ) ; }
@ Override public void on Bind View Holder ( Statistic View Holder holder , int position ) { switch ( get Item View Type ( position ) ) { case Statistic View Holder . TYPE SMALL : switch ( m Statistic Items . get ( position ) ) { case TYPE DUE : holder . apply Due Chart ( ) ; break ; case TYPE STAGE : holder . apply Stage Chart ( ) ; break ; } break ; case Statistic View Holder . TYPE LARGE : holder . apply Most Played Chart ( m Statistic Items . get ( position ) ) ; break ; } }
public void search ( String object Type , String query , Default List Model results , Action Listener callback ) throws IO Exception { Hashtable params = new Hashtable ( ) ; params . put ( STR_ , query ) ; params . put ( STR_ , object Type ) ; get Face Book Object Items ( STR_ , STR_ , results , params , callback ) ; }
public Volatile Image create Volatile Image ( int width , int height ) { Component Peer peer = this . peer ; if ( peer instanceof Lightweight Peer ) { if ( parent != null ) { return parent . create Volatile Image ( width , height ) ; } else { return null ; } } else { return ( peer != null ) ? peer . create Volatile Image ( width , height ) : null ; } }
public static String convert To Java Class Name ( String name ) { int dot Index = name . index Of ( STR_ ) ; if ( dot Index >= NUM_ ) { name = name . substring ( NUM_ , dot Index ) ; } String [ ] split = name . split ( STR_ ) ; String Builder out = new String Builder ( ) ; for ( String section : split ) { out . append ( String Util . capitalize ( section ) ) ; } return out . to String ( ) ; }
public static Bloom Filter create Optimal Filter ( int n , double false Positive Probability , int tweak , Update Mode update ) { double ln 2 = Math . log ( NUM_ ) ; int mod = Math . max ( NUM_ , ( int ) Math . min ( ( - n * Math . log ( false Positive Probability ) / ( ln 2 * ln 2 ) ) / NUM_ , MAX FILTER SIZE ) ) ; int hash Functions = Math . max ( NUM_ , Math . min ( ( int ) ( mod * NUM_ / n * ln 2 ) , MAX HASH FUNCS ) ) ; return new Bloom Filter ( new byte [ mod ] , hash Functions , tweak , update ) ; }
private String build Music Folders Selection ( Cursor music Folders Cursor ) { String media Store Selection = Media Store . Audio . Media . IS MUSIC + STR_ ; int folder Path Col Index = music Folders Cursor . get Column Index ( DB Access Helper . FOLDER PATH ) ; int include Col Index = music Folders Cursor . get Column Index ( DB Access Helper . INCLUDE ) ; for ( int i = NUM_ ; i < music Folders Cursor . get Count ( ) ; i ++ ) { music Folders Cursor . move To Position ( i ) ; boolean include = music Folders Cursor . get Int ( include Col Index ) > NUM_ ; String like Clause ; if ( include ) like Clause = STR_ ; else like Clause = STR_ ; if ( i != NUM_ && ! include ) media Store Selection += STR_ ; else if ( i != NUM_ && include ) media Store Selection += STR_ ; media Store Selection += Media Store . Audio . Media . DATA + like Clause + STR_ + music Folders Cursor . get String ( folder Path Col Index ) + STR_ ; } media Store Selection += STR_ ; return media Store Selection ; }
public static int parse Digit Value ( String s ) throws Number Format Exception { int value = - NUM_ ; if ( s . length ( ) > NUM_ ) { value = Integer . parse Int ( s , NUM_ ) ; } return value ; }
public I Pv 6 Address Validator ( @ Non Null final Char Sequence error Message ) { super ( error Message , REGEX ) ; }
public Date Range modify ( long start , long end ) { return new Date Range ( Math . max ( this . start , start ) , Math . min ( this . end , end - NUM_ ) ) ; }
public static void main ( String [ ] args ) throws Exception { try { Samza Rest Config config = parse Config ( args ) ; Samza Rest Service rest Service = new Samza Rest Service ( config ) ; Samza Rest Application samza Rest Application = new Samza Rest Application ( config ) ; Servlet Container container = new Servlet Container ( samza Rest Application ) ; rest Service . add Servlet ( container , STR_ ) ; Scheduled Executor Service scheduling Service = Executors . new Scheduled Thread Pool ( NUM_ ) ; Scheduled Executor Scheduling Provider scheduling Provider = new Scheduled Executor Scheduling Provider ( scheduling Service ) ; Samza Monitor Service monitor Service = new Samza Monitor Service ( config , new No Op Metrics Registry ( ) , scheduling Provider ) ; monitor Service . start ( ) ; rest Service . run Blocking ( ) ; monitor Service . stop ( ) ; } catch ( Throwable t ) { log . error ( STR_ , t ) ; } }
private int calculate Resistance ( ) { double mean = Math . sqrt ( get Width ( ) * get Height ( ) ) ; double normalized = NUM_ - NUM_ / Math . max ( NUM_ , mean ) ; return Math . max ( MIN RESISTANCE , ( int ) ( MAX RESISTANCE * normalized ) ) ; }
public boolean remove Extent ( Geo Extent region ) { boolean ret = false ; Bounding Circle bc = region . get Bounding Circle ( ) ; if ( bc == null ) { return discarded . remove ( region ) ; } Geo center = bc . get Center ( ) ; double clon = center . get Longitude ( ) ; double clat = center . get Latitude ( ) ; double rnm = Geo . nm ( bc . get Radius ( ) ) ; if ( ( clat == NUM_ && clon == - NUM_ ) || rnm >= NUM_ * NUM_ ) { discarded . remove ( region ) ; } else { all . remove ( region ) ; double latfactor = Geo . npd At Lat ( clat ) ; if ( latfactor == NUM_ ) { ret = ret || polar . remove ( region ) ; } else { double xd = ( rnm + margin ) / latfactor ; if ( xd >= NUM_ ) { ret = ret || polar . remove ( region ) ; } else { double [ ] lons = normalize Lons ( new double [ ] { clon - xd , clon + xd } ) ; int lb = bucket For ( lons [ NUM_ ] ) ; int rb = bucket For ( lons [ NUM_ ] ) ; if ( rb < lb ) rb += nbuckets ; for ( int i = lb ; i <= rb ; i ++ ) { int x = i % nbuckets ; Collection b = buckets [ x ] ; if ( b != null ) { ret = ret || b . remove ( region ) ; if ( b . is Empty ( ) ) { buckets [ x ] = null ; } } } } } } return ret ; }
protected int hash ( Object key 1 , Object key 2 ) { int h = NUM_ ; if ( key 1 != null ) { h ^= key 1 . hash Code ( ) ; } if ( key 2 != null ) { h ^= key 2 . hash Code ( ) ; } h += ~ ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; h += ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; return h ; }
public static int option Length ( String option ) { if ( option . equals ( OUTPUT OPTION ) ) { return NUM_ ; } if ( option . equals ( CONTENT OPTION ) ) { return NUM_ ; } if ( option . equals ( BUILD OPTION ) ) { return NUM_ ; } if ( option . equals ( PORTAL SRC OPTION ) ) { return NUM_ ; } if ( option . equals ( ROOT DIRECTORY ) ) { return NUM_ ; } return NUM_ ; }
static public void add Query Params ( final String Builder url String , final Map < String , String [ ] > request Params ) throws Unsupported Encoding Exception { if ( request Params == null ) return ; boolean first = true ; for ( Map . Entry < String , String [ ] > e : request Params . entry Set ( ) ) { final String name = e . get Key ( ) ; final String [ ] vals = e . get Value ( ) ; if ( vals == null ) { url String . append ( first ? STR_ : STR_ ) ; first = false ; url String . append ( URL Encoder . encode ( name , Remote Repository . UTF 8 ) ) ; } else { for ( String val : vals ) { url String . append ( first ? STR_ : STR_ ) ; first = false ; url String . append ( URL Encoder . encode ( name , Remote Repository . UTF 8 ) ) ; url String . append ( STR_ ) ; if ( val != null ) url String . append ( URL Encoder . encode ( val , Remote Repository . UTF 8 ) ) ; } } } }
protected Boolean parse Boolean Value ( String value ) throws Parse Exception { if ( value == null ) { return null ; } if ( value . equals Ignore Case ( STR_ ) || value . equals ( STR_ ) ) { return Boolean . FALSE ; } if ( value . equals Ignore Case ( STR_ ) || value . equals ( STR_ ) ) { return Boolean . TRUE ; } Parse Exception pe = new Parse Exception ( Core Error Domain . ERR . invalid Boolean Attribute ) ; pe . set Internal Reason ( STR_ + value ) ; throw pe ; }
public static < U extends Object , S extends Service < U > > boolean launch Service By Class ( Class < ? extends S > c , U user , Frame owner ) { boolean success = false ; S ret = null ; for ( Service < ? > s : SERVICE TO USER MAP . key Set ( ) ) { if ( c . is Instance ( s ) ) { s . pull To Front ( ) ; return true ; } } try { ret = c . new Instance ( ) ; SERVICE TO USER MAP . put ( ret , user ) ; ret . setup GUI ( owner ) ; ret . launch ( ) ; success = true ; } catch ( Instantiation Exception | Illegal Access Exception e ) { LOG . severe ( STR_ + e . get Message ( ) ) ; } return success ; }
private Point 2 D compute Center ( Array List < Point 2 D > points ) { final Point center = new Point ( NUM_ , NUM_ ) ; if ( points . size ( ) > NUM_ ) { for ( Point 2 D a Pt : points ) { center . x += ( int ) a Pt . get X ( ) ; center . y += ( int ) a Pt . get Y ( ) ; } center . x /= points . size ( ) ; center . y /= points . size ( ) ; } return center ; }
private void write Chunks ( Output Stream output Stream , byte [ ] bytes , int length , boolean small Chunks ) throws IO Exception { synchronized ( output Stream ) { int chunksize = NUM_ * NUM_ ; if ( small Chunks ) { chunksize = NUM_ ; } for ( int p = NUM_ ; p < length ; p += chunksize ) { int chunk = p + chunksize < length ? chunksize : length - p ; output Stream . write ( bytes , p , chunk ) ; } } output Stream . flush ( ) ; }
private void change position ( Pla Point Float p new position ) { current position = p new position . round ( ) ; if ( ! current position . equals ( previous position ) ) { Pla Vector Int translate vector = current position . difference by ( previous position ) ; Iterator < board . items . Brd Item > it = item list . iterator ( ) ; while ( it . has Next ( ) ) { board . items . Brd Item curr item = it . next ( ) ; curr item . translate by ( translate vector ) ; } previous position = current position ; i brd . repaint ( ) ; } }
private void values Tester ( final int tree Size , final Collection < String > values ) { int counter = NUM_ ; for ( String value : values ) { counter ++ ; } assert Equals ( tree Size , counter ) ; assert Equals ( tree Size , values . size ( ) ) ; }
public void add ( T item ) { queue . add ( item ) ; if ( idle . get ( ) ) proceed ( ) ; }
private void compute Word Proposals ( String word , int offset , List proposition List ) { int qualifier Length = word . length ( ) ; for ( int i = NUM_ ; i < proposals . length ; i ++ ) { String proposal Text = proposals [ i ] ; if ( proposal Text . starts With ( word ) ) { String text = proposal Text + STR_ ; int cursor = proposal Text . length ( ) ; Completion Proposal proposal = new Completion Proposal ( text , offset - qualifier Length , qualifier Length , cursor ) ; proposition List . add ( proposal ) ; } } }
private I Running Query init Query With Conditional Routing Op ( I Constraint condition , int start Id , int join Id 1 , int join Id 2 ) throws Exception { final int pred Id 1 = NUM_ ; final int pred Id 2 = NUM_ ; final int cond Id = NUM_ ; final int slice Id = NUM_ ; final Pipeline Op start Op = new Start Op ( new B Op [ ] { } , NV . as Map ( new NV [ ] { new NV ( Predicate . Annotations . BOP ID , start Id ) , new NV ( Slice Op . Annotations . EVALUATION CONTEXT , B Op Evaluation Context . CONTROLLER ) } ) ) ; final Predicate < ? > pred 1 Op = new Predicate < E > ( new I Variable Or Constant [ ] { Var . var ( STR_ ) , Var . var ( STR_ ) } , NV . as Map ( new NV [ ] { new NV ( Predicate . Annotations . RELATION NAME , new String [ ] { namespace } ) , new NV ( Predicate . Annotations . BOP ID , pred Id 1 ) , new NV ( Annotations . TIMESTAMP , I Tx . READ COMMITTED ) } ) ) ; final Predicate < ? > pred 2 Op = new Predicate < E > ( new I Variable Or Constant [ ] { Var . var ( STR_ ) , Var . var ( STR_ ) } , NV . as Map ( new NV [ ] { new NV ( Predicate . Annotations . RELATION NAME , new String [ ] { namespace } ) , new NV ( Predicate . Annotations . BOP ID , pred Id 2 ) , new NV ( Annotations . TIMESTAMP , I Tx . READ COMMITTED ) } ) ) ; final Conditional Routing Op cond = new Conditional Routing Op ( new B Op [ ] { start Op } , NV . as Map ( new NV [ ] { new NV ( B Op . Annotations . BOP ID , cond Id ) , new NV ( Pipeline Op . Annotations . SINK REF , join Id 1 ) , new NV ( Pipeline Op . Annotations . ALT SINK REF , slice Id ) , new NV ( Conditional Routing Op . Annotations . CONDITION , condition ) } ) ) ; final Pipeline Op join 1 Op = new Pipeline Join < E > ( new B Op [ ] { cond } , new NV ( Predicate . Annotations . BOP ID , join Id 1 ) , new NV ( Pipeline Join . Annotations . PREDICATE , pred 1 Op ) ) ; final Pipeline Op join 2 Op = new Pipeline Join < E > ( new B Op [ ] { join 1 Op } , new NV ( Predicate . Annotations . BOP ID , join Id 2 ) , new NV ( Pipeline Join . Annotations . PREDICATE , pred 2 Op ) ) ; final Pipeline Op slice Op = new Slice Op ( new B Op [ ] { join 2 Op } , NV . as Map ( new NV [ ] { new NV ( B Op . Annotations . BOP ID , slice Id ) , new NV ( B Op . Annotations . EVALUATION CONTEXT , B Op Evaluation Context . CONTROLLER ) , new NV ( Pipeline Op . Annotations . SHARED STATE , true ) , new NV ( Pipeline Op . Annotations . REORDER SOLUTIONS , false ) , new NV ( Query Engine . Annotations . CHUNK HANDLER , Standalone Chunk Handler . TEST INSTANCE ) } ) ) ; final Pipeline Op query = slice Op ; final UUID query Id = UUID . random UUID ( ) ; final I Binding Set initial Bindings = new List Binding Set ( ) ; { initial Bindings . set ( Var . var ( STR_ ) , new Constant < String > ( STR_ ) ) ; } final I Running Query running Query = query Engine . eval ( query Id , query , initial Bindings ) ; return running Query ; }
public int remaining Kills ( Player player , String creature ) { final List < String > tokens = Arrays . as List ( quest State . split ( STR_ ) ) ; if ( ( tokens . size ( ) % NUM_ ) != NUM_ ) { LOGGER . error ( STR_ + player . get Name ( ) + STR_ + quest State + STR_ ) ; return - NUM_ ; } for ( int i = NUM_ ; i < tokens . size ( ) / NUM_ ; i ++ ) { final String creature Name = tokens . get ( i * NUM_ ) ; if ( creature . equals ( creature Name ) ) { List < String > tokens For Creature = tokens . sub List ( i * NUM_ , i * NUM_ + NUM_ ) ; return remaining Kills ( player , tokens For Creature ) ; } } LOGGER . warn ( STR_ + player . get Name ( ) + STR_ + creature ) ; return - NUM_ ; }
private static int uarimax Ge ( double value , double [ ] bv , int [ ] bvi , Binary Operator b Op ) throws DML Runtime Exception { int ix Max = bv . length ; if ( value < bv [ NUM_ ] || value >= bv [ bv . length - NUM_ ] ) return ix Max ; int ix = Arrays . binary Search ( bv , value ) ; if ( ix < NUM_ ) ix = Math . abs ( ix ) - NUM_ ; ix Max = bvi [ ix ] + NUM_ ; return ix Max ; }
public void load Logical Categories ( ) { logical OF Message Categories = Immutable Set . copy Of ( logical OF Message Categories ) ; num Required Connections = calc Num Required Connections ( ) ; }
public static String build Selector From Element And Attribute ( String element Name , String attribute Name , boolean not Empty Attribute ) { String Builder selector = new String Builder ( ) ; selector . append ( element Name ) ; if ( attribute Name != null && ! attribute Name . is Empty ( ) ) { selector . append ( OPEN BRACKET ) ; selector . append ( attribute Name ) ; selector . append ( CLOSE BRACKET ) ; if ( not Empty Attribute ) { selector . append ( NOT PREFIX ) ; selector . append ( OPEN BRACKET ) ; selector . append ( attribute Name ) ; selector . append ( NOT EMPTY REGEXP ) ; selector . append ( CLOSE BRACKET ) ; selector . append ( CLOSE PARENTHESE ) ; } } return selector . to String ( ) ; }
public static void disable Channel Warnings ( ) { ignore Channel Warnings . set ( true ) ; }
public void add Coupling Listener ( final Coupling Listener listener ) { coupling Listeners . add ( listener ) ; }
@ Contract ( pure = true ) public static int difference ( @ Not Null String s 1 , @ Not Null String s 2 ) { int [ ] [ ] a = new int [ s 1 . length ( ) ] [ s 2 . length ( ) ] ; for ( int i = NUM_ ; i < s 1 . length ( ) ; i ++ ) { a [ i ] [ NUM_ ] = i ; } for ( int j = NUM_ ; j < s 2 . length ( ) ; j ++ ) { a [ NUM_ ] [ j ] = j ; } for ( int i = NUM_ ; i < s 1 . length ( ) ; i ++ ) { for ( int j = NUM_ ; j < s 2 . length ( ) ; j ++ ) { a [ i ] [ j ] = Math . min ( Math . min ( a [ i - NUM_ ] [ j - NUM_ ] + ( s 1 . char At ( i ) == s 2 . char At ( j ) ? NUM_ : NUM_ ) , a [ i - NUM_ ] [ j ] + NUM_ ) , a [ i ] [ j - NUM_ ] + NUM_ ) ; } } return a [ s 1 . length ( ) - NUM_ ] [ s 2 . length ( ) - NUM_ ] ; }
@ Override public String word ( ) { return get String ( WORD KEY ) ; }
public static Map < String , Object > create Image ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = create Image Method ( dctx , context ) ; return result ; }
private static Map < String , Object > create Billing Account From Return ( Generic Value return Header , List < Generic Value > return Items , Dispatch Context dctx , Map < String , ? extends Object > context ) { Local Dispatcher dispatcher = dctx . get Dispatcher ( ) ; Generic Value user Login = ( Generic Value ) context . get ( STR_ ) ; Locale locale = ( Locale ) context . get ( STR_ ) ; try { List < Generic Value > orders = Entity Util . get Related ( STR_ , null , return Items , false ) ; List < Generic Value > product Stores = Entity Util . get Related ( STR_ , null , orders , false ) ; Long store Credit Valid Days = null ; for ( Generic Value product Store : product Stores ) { Long this Store Valid Days = product Store . get Long ( STR_ ) ; if ( this Store Valid Days == null ) continue ; if ( store Credit Valid Days == null ) { store Credit Valid Days = this Store Valid Days ; } else if ( this Store Valid Days . compare To ( store Credit Valid Days ) < NUM_ ) { store Credit Valid Days = this Store Valid Days ; } } Timestamp thru Date = null ; if ( store Credit Valid Days != null ) thru Date = Util Date Time . get Day End ( Util Date Time . now Timestamp ( ) , store Credit Valid Days ) ; Map < String , Object > input = Util Misc . < String , Object > to Map ( STR_ , Big Decimal . ZERO , STR_ , STR_ + return Header . get ( STR_ ) , STR_ , user Login ) ; input . put ( STR_ , return Header . get ( STR_ ) ) ; input . put ( STR_ , thru Date ) ; Map < String , Object > results = dispatcher . run Sync ( STR_ , input ) ; if ( Service Util . is Error ( results ) ) return results ; String billing Account Id = ( String ) results . get ( STR_ ) ; input = Util Misc . to Map ( STR_ , billing Account Id , STR_ , return Header . get ( STR_ ) , STR_ , STR_ , STR_ , user Login ) ; Map < String , Object > role Results = dispatcher . run Sync ( STR_ , input ) ; if ( Service Util . is Error ( role Results ) ) { Debug . log Error ( STR_ + role Results . get ( Model Service . ERROR MESSAGE ) , module ) ; return Service Util . return Error ( Util Properties . get Message ( resource error , STR_ , locale ) + role Results . get ( Model Service . ERROR MESSAGE ) ) ; } return results ; } catch ( Generic Entity Exception e ) { Debug . log Error ( e , STR_ + e . get Message ( ) , module ) ; return Service Util . return Error ( Util Properties . get Message ( resource error , STR_ , locale ) ) ; } catch ( Generic Service Exception e ) { Debug . log Error ( e , STR_ + e . get Message ( ) , module ) ; return Service Util . return Error ( Util Properties . get Message ( resource error , STR_ , locale ) ) ; } }
@ Transactional public long create Pre Approved Voucher From Bill ( final int bill Id , final String voucher Number , final Date voucher Date ) throws Application Runtime Exception , Validation Exception { String voucher Status = null ; long vh = - NUM_ ; try { final List v Status List = app Config Values Service . get Config Values By Module And Key ( STR_ , STR_ ) ; if ( ! v Status List . is Empty ( ) && v Status List . size ( ) == NUM_ ) { final App Config Values app Val = ( App Config Values ) v Status List . get ( NUM_ ) ; voucher Status = app Val . get Value ( ) ; } else throw new Application Runtime Exception ( STR_ + MISSINGMSG ) ; vh = create Voucher . create Voucher From Bill ( bill Id , voucher Status , voucher Number , voucher Date ) ; } catch ( final Validation Exception e ) { LOGGER . error ( e . get Errors ( ) ) ; throw new Validation Exception ( e . get Errors ( ) ) ; } catch ( final Exception e ) { LOGGER . error ( e . get Message ( ) ) ; throw new Application Runtime Exception ( e . get Message ( ) ) ; } return vh ; }
private float draw Y Axis Markers ( Chart Value Series chart Value Series , Canvas canvas , int x Position ) { int interval = chart Value Series . get Interval ( ) ; float max Marker Width = NUM_ ; for ( int i = NUM_ ; i <= Y AXIS INTERVALS ; i ++ ) { max Marker Width = Math . max ( max Marker Width , draw Y Axis Marker ( chart Value Series , canvas , x Position , i * interval + chart Value Series . get Min Marker Value ( ) ) ) ; } return max Marker Width ; }
public static Password Validator build Update Validator ( Map < String , String > properties , Password Utils password Utils ) { List < Rule > rule List = build Base Rule List ( properties ) ; rule List . add ( new History Rule ( Number Utils . to Int ( properties . get ( PASSWORD REUSE NUMBER ) , NUM_ ) , password Utils ) ) ; rule List . add ( new Changed Number Rule ( Number Utils . to Int ( properties . get ( PASSWORD CHANGED NUMBER ) , NUM_ ) ) ) ; rule List . add ( new Change Interval Rule ( Number Utils . to Int ( properties . get ( PASSWORD CHANGE INTERVAL ) , NUM_ ) ) ) ; Password Validator validator = new Password Validator ( rule List ) ; return validator ; }
public static void main ( String [ ] args ) { Log . print Line ( STR_ ) ; try { int num user = NUM_ ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = false ; Cloud Sim . init ( num user , calendar , trace flag ) ; @ Suppress Warnings ( STR_ ) Datacenter datacenter 0 = create Datacenter ( STR_ ) ; @ Suppress Warnings ( STR_ ) Datacenter datacenter 1 = create Datacenter ( STR_ ) ; Datacenter Broker broker = create Broker ( ) ; int broker Id = broker . get Id ( ) ; vmlist = new Array List < Vm > ( ) ; int vmid = NUM_ ; int mips = NUM_ ; long size = NUM_ ; int ram = NUM_ ; long bw = NUM_ ; int pes Number = NUM_ ; String vmm = STR_ ; Vm vm 1 = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmid ++ ; Vm vm 2 = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmlist . add ( vm 1 ) ; vmlist . add ( vm 2 ) ; broker . submit Vm List ( vmlist ) ; cloudlet List = new Array List < Cloudlet > ( ) ; int id = NUM_ ; long length = NUM_ ; long file Size = NUM_ ; long output Size = NUM_ ; Utilization Model utilization Model = new Utilization Model Full ( ) ; Cloudlet cloudlet 1 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 1 . set User Id ( broker Id ) ; id ++ ; Cloudlet cloudlet 2 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 2 . set User Id ( broker Id ) ; cloudlet List . add ( cloudlet 1 ) ; cloudlet List . add ( cloudlet 2 ) ; broker . submit Cloudlet List ( cloudlet List ) ; broker . bind Cloudlet To Vm ( cloudlet 1 . get Cloudlet Id ( ) , vm 1 . get Id ( ) ) ; broker . bind Cloudlet To Vm ( cloudlet 2 . get Cloudlet Id ( ) , vm 2 . get Id ( ) ) ; Cloud Sim . start Simulation ( ) ; List < Cloudlet > new List = broker . get Cloudlet Received List ( ) ; Cloud Sim . stop Simulation ( ) ; print Cloudlet List ( new List ) ; Log . print Line ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STR_ ) ; } }
private boolean ensure Target Is Valid ( ) { String target Dir = get Target Directory ( ) ; if ( ! ensure Target Directory Is Valid ( target Dir ) ) { return false ; } String file Name = get Target File Name ( ) ; if ( ! ensure Target File Is Valid ( new File ( target Dir , file Name ) ) ) { return false ; } return true ; }
public static String hash Password ( String password ) { byte [ ] random Bytes = new byte [ NUM_ ] ; rand . set Seed ( System . current Time Millis ( ) ) ; rand . next Bytes ( random Bytes ) ; return my Crypt ( password , gen Salt ( random Bytes ) ) ; }
public void add Listener ( @ Not Null State Change Listener listener ) { listeners . add ( listener ) ; }
protected void compute Thresholds ( Instances instances ) { int i ; double [ ] values ; int [ ] sorted Indices ; int half ; int quarter ; double q 1 ; double q 2 ; double q 3 ; m Upper Extreme Value = new double [ m Attribute Indices . length ] ; m Upper Outlier = new double [ m Attribute Indices . length ] ; m Lower Outlier = new double [ m Attribute Indices . length ] ; m Lower Extreme Value = new double [ m Attribute Indices . length ] ; m Median = new double [ m Attribute Indices . length ] ; m IQR = new double [ m Attribute Indices . length ] ; for ( i = NUM_ ; i < m Attribute Indices . length ; i ++ ) { if ( m Attribute Indices [ i ] == NON NUMERIC ) { continue ; } values = instances . attribute To Double Array ( m Attribute Indices [ i ] ) ; sorted Indices = Utils . sort ( values ) ; half = sorted Indices . length / NUM_ ; quarter = half / NUM_ ; if ( sorted Indices . length % NUM_ == NUM_ ) { q 2 = values [ sorted Indices [ half ] ] ; } else { q 2 = ( values [ sorted Indices [ half ] ] + values [ sorted Indices [ half + NUM_ ] ] ) / NUM_ ; } if ( half % NUM_ == NUM_ ) { q 1 = values [ sorted Indices [ quarter ] ] ; q 3 = values [ sorted Indices [ sorted Indices . length - quarter - NUM_ ] ] ; } else { q 1 = ( values [ sorted Indices [ quarter ] ] + values [ sorted Indices [ quarter + NUM_ ] ] ) / NUM_ ; q 3 = ( values [ sorted Indices [ sorted Indices . length - quarter - NUM_ ] ] + values [ sorted Indices [ sorted Indices . length - quarter ] ] ) / NUM_ ; } m Median [ i ] = q 2 ; m IQR [ i ] = q 3 - q 1 ; m Upper Extreme Value [ i ] = q 3 + get Extreme Values Factor ( ) * m IQR [ i ] ; m Upper Outlier [ i ] = q 3 + get Outlier Factor ( ) * m IQR [ i ] ; m Lower Outlier [ i ] = q 1 - get Outlier Factor ( ) * m IQR [ i ] ; m Lower Extreme Value [ i ] = q 1 - get Extreme Values Factor ( ) * m IQR [ i ] ; } }
@ Override public boolean implies ( Protection Domain pd , Permission p ) { Policy Info pi = policy Info . get ( ) ; Protection Domain Cache pd Map = pi . get Pd Mapping ( ) ; Permission Collection pc = pd Map . get ( pd ) ; if ( pc != null ) { return pc . implies ( p ) ; } pc = get Permissions ( pd ) ; if ( pc == null ) { return false ; } pd Map . put ( pd , pc ) ; return pc . implies ( p ) ; }
protected int hash ( Object key 1 , Object key 2 , Object key 3 , Object key 4 ) { int h = NUM_ ; if ( key 1 != null ) { h ^= key 1 . hash Code ( ) ; } if ( key 2 != null ) { h ^= key 2 . hash Code ( ) ; } if ( key 3 != null ) { h ^= key 3 . hash Code ( ) ; } if ( key 4 != null ) { h ^= key 4 . hash Code ( ) ; } h += ~ ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; h += ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; return h ; }
private void write Domain Pair ( Dom Pair pair , Document document , Element parent Element ) { Element dom Pair = document . create Element ( STR_ ) ; parent Element . append Child ( dom Pair ) ; write Domain Spec ( pair . get First Domain ( ) , document , dom Pair ) ; write Domain Spec ( pair . get Second Domain ( ) , document , dom Pair ) ; }
public void create Cluster Config Root Dirs ( ) throws Configuration Exception { cluster Config Dir = new File ( Cluster Configuration . get Cluster Config Root Dir Name ( cluster Home Name ) ) ; cluster Config Root Dir = new File ( get Cluster Config Root Dir Name ( cluster Home Name ) ) ; if ( ! cluster Config Dir . exists ( ) ) { logger . debug ( STR_ + cluster Config Dir . get Absolute Path ( ) ) ; cluster Config Dir . mkdirs ( ) ; } if ( ! cluster Config Dir . is Directory ( ) || ! cluster Config Dir . can Write ( ) ) { throw new Configuration Exception ( STR_ + cluster Config Dir . get Absolute Path ( ) ) ; } if ( ! cluster Config Root Dir . exists ( ) ) { logger . debug ( STR_ + cluster Config Root Dir . get Absolute Path ( ) ) ; cluster Config Root Dir . mkdirs ( ) ; } if ( ! cluster Config Root Dir . is Directory ( ) || ! cluster Config Root Dir . can Write ( ) ) { throw new Configuration Exception ( STR_ + cluster Config Root Dir . get Absolute Path ( ) ) ; } }
private void add Category ( Categorized category ) { Iterator < String > names = category . get Category Names ( ) ; while ( names . has Next ( ) ) { categories . put ( names . next ( ) , category ) ; } }
private void skip To Next Variant ( final Path head ) { final int a Next = future Variant Pos ( head . m Called Path , m Called Variants ) ; final int b Next = future Variant Pos ( head . m Baseline Path , m Base Line Variants ) ; final int last Template Pos = m Template . length - NUM_ ; final int next Pos = Math . min ( Math . min ( a Next , b Next ) , last Template Pos ) - NUM_ ; assert head . m Called Path . get Position ( ) == head . m Baseline Path . get Position ( ) ; if ( next Pos > head . m Called Path . get Position ( ) ) { head . move Forward ( next Pos ) ; } }
static void release Context ( Sea Glass Context context ) { synchronized ( context Map ) { List instances = ( List ) context Map . get ( context . get Class ( ) ) ; if ( instances == null ) { instances = new Array List ( NUM_ ) ; context Map . put ( context . get Class ( ) , instances ) ; } instances . add ( context ) ; } }
@ Override public void prompt Loop ( ) { lock . lock ( ) ; try { while ( true ) { try { end Of Shell . await ( ) ; } catch ( Interrupted Exception e ) { } this . exit Shell Request = Exit Shell Request . NORMAL EXIT ; set Shell Status ( Status . SHUTTING DOWN ) ; break ; } } finally { lock . unlock ( ) ; } }
private void prepare Fold ( Orientation orientation , float anchor Factor , int number Of Folds ) { m Src = new float [ NUM OF POLY POINTS ] ; m Dst = new float [ NUM OF POLY POINTS ] ; m Dst Rect = new Rect ( ) ; m Fold Factor = NUM_ ; m Previous Fold Factor = NUM_ ; m Is Fold Prepared = false ; m Solid Shadow = new Paint ( ) ; m Gradient Shadow = new Paint ( ) ; m Orientation = orientation ; m Is Horizontal = ( orientation == Orientation . HORIZONTAL ) ; if ( m Is Horizontal ) { m Shadow Linear Gradient = new Linear Gradient ( NUM_ , NUM_ , SHADING FACTOR , NUM_ , Color . BLACK , Color . TRANSPARENT , Tile Mode . CLAMP ) ; } else { m Shadow Linear Gradient = new Linear Gradient ( NUM_ , NUM_ , NUM_ , SHADING FACTOR , Color . BLACK , Color . TRANSPARENT , Tile Mode . CLAMP ) ; } m Gradient Shadow . set Style ( Style . FILL ) ; m Gradient Shadow . set Shader ( m Shadow Linear Gradient ) ; m Shadow Gradient Matrix = new Matrix ( ) ; m Anchor Factor = anchor Factor ; m Number Of Folds = number Of Folds ; m Original Width = get Measured Width ( ) ; m Original Height = get Measured Height ( ) ; m Fold Rect Array = new Rect [ m Number Of Folds ] ; m Matrix = new Matrix [ m Number Of Folds ] ; for ( int x = NUM_ ; x < m Number Of Folds ; x ++ ) { m Matrix [ x ] = new Matrix ( ) ; } int h = m Original Height ; int w = m Original Width ; int delta = Math . round ( m Is Horizontal ? ( ( float ) w ) / ( ( float ) m Number Of Folds ) : ( ( float ) h ) / ( ( float ) m Number Of Folds ) ) ; for ( int x = NUM_ ; x < m Number Of Folds ; x ++ ) { if ( m Is Horizontal ) { int deltap = ( x + NUM_ ) * delta > w ? w - x * delta : delta ; m Fold Rect Array [ x ] = new Rect ( x * delta , NUM_ , x * delta + deltap , h ) ; } else { int deltap = ( x + NUM_ ) * delta > h ? h - x * delta : delta ; m Fold Rect Array [ x ] = new Rect ( NUM_ , x * delta , w , x * delta + deltap ) ; } } if ( m Is Horizontal ) { m Fold Max Height = h ; m Fold Max Width = delta ; } else { m Fold Max Height = delta ; m Fold Max Width = w ; } m Is Fold Prepared = true ; }
public void clear ( ) { m Event Queue . clear ( ) ; m Qualifying Events . clear ( ) ; }
public static void add Other Feature To Predict Document ( Mira Template a Template , Repository Service a Repository , Annotation Service a Annotation Service , Automation Service a Automation Service , User Dao a User Dao ) throws UIMA Exception , Class Not Found Exception , IO Exception , Brat Annotation Exception , Automation Exception { Annotation Feature layer Feature = a Template . get Train Feature ( ) ; File mira Dir = a Automation Service . get Mira Dir ( layer Feature ) ; for ( Source Document document : a Repository . list Source Documents ( layer Feature . get Project ( ) ) ) { List < List < String > > predictions = new Array List < List < String > > ( ) ; if ( ! document . is Processed ( ) && ! document . is Training Document ( ) ) { File pred Ft File = new File ( mira Dir , document . get Id ( ) + STR_ ) ; Mira mira = new Mira ( ) ; int beam Size = NUM_ ; boolean max Posteriors = false ; File predcited File = new File ( pred Ft File . get Absolute Path ( ) + STR_ ) ; get Feature Other Layer ( a Template , a Repository , a Annotation Service , a Automation Service , a User Dao , beam Size , max Posteriors , predictions , mira , pred Ft File , predcited File , document ) ; get Features Tab Sep ( a Template , a Repository , a Automation Service , beam Size , max Posteriors , layer Feature , predictions , mira , pred Ft File , predcited File ) ; File base Pred File = new File ( mira Dir , document . get Id ( ) + STR_ ) ; if ( predictions . size ( ) == NUM_ ) { create Template ( a Template . get Train Feature ( ) , get Mira Template File ( layer Feature , a Automation Service ) , NUM_ ) ; File Utils . copy File ( pred Ft File , base Pred File ) ; } else { create Template ( a Template . get Train Feature ( ) , get Mira Template File ( layer Feature , a Automation Service ) , predictions . size ( ) ) ; build Predict File ( pred Ft File , base Pred File , predictions , a Template . get Train Feature ( ) ) ; } } } }
public void stop Log Verifier ( ) { if ( verifier != null ) { verifier . cancel ( ) ; verifier = null ; } }
public static String generate Native Guid ( Db Client db Client , Quota Directory quota Dir , String fs Name ) throws IO Exception { File Share fs = db Client . query Object ( File Share . class , quota Dir . get Parent ( ) ) ; Storage System device = db Client . query Object ( Storage System . class , fs . get Storage Device ( ) ) ; return String . format ( STR_ + QUOTADIRECTORY + STR_ , device Type Map . get ( device . get System Type ( ) ) , device . get Serial Number ( ) , fs Name , quota Dir . get Name ( ) ) ; }
public I Object Info insert Entry Indexed Field ( Template Cache Info p Template , K field Value , Type Data p Type , boolean already Cloned ) { I Object Info oi = null ; I Stored List < Template Cache Info > new SL = null ; I Stored List < Template Cache Info > current SL = null ; boolean first = true ; size . increment And Get ( ) ; while ( true ) { if ( first ) { first = false ; current SL = ordered Store . get ( field Value ) ; } if ( current SL == null ) { if ( ! already Cloned && index . consider Value Clone ( ) ) { field Value = ( K ) index . clone Index Value ( field Value , p Template . m Template Holder ) ; already Cloned = true ; } current SL = ordered Store . put If Absent ( field Value , p Template ) ; if ( current SL == null ) { oi = p Template ; break ; } } if ( current SL . is Multi Object Collection ( ) ) { oi = current SL . add ( p Template ) ; if ( oi == null ) { ordered Store . remove ( field Value , current SL ) ; current SL = null ; continue ; } else break ; } if ( new SL == null ) new SL = Stored List Factory . create Concurrent List ( false , true ) ; I Object Info otheroi = new SL . add Unlocked ( current SL . get Object From Head ( ) ) ; I Object Info myoi = new SL . add Unlocked ( p Template ) ; if ( ! ordered Store . replace ( field Value , current SL , new SL ) ) { new SL . remove Unlocked ( otheroi ) ; new SL . remove Unlocked ( myoi ) ; myoi = null ; current SL = null ; } else { oi = myoi ; break ; } } return oi ; }
@ Override public void run ( ) { am I Active = true ; int row , col , x , y ; float progress = NUM_ ; double z ; int i , b , c , ICLCA ; boolean flag = false ; double flow Dir = NUM_ ; double outlet ID = NUM_ ; double SCA Value ; double max SCA , d 1 , d 2 ; if ( args . length <= NUM_ ) { show Feedback ( STR_ ) ; return ; } String pointer Header = args [ NUM_ ] ; String ca Header = args [ NUM_ ] ; String output Header = args [ NUM_ ] ; double SCA Threshold = Double . parse Double ( args [ NUM_ ] ) ; if ( pointer Header . is Empty ( ) || ca Header . is Empty ( ) || output Header . is Empty ( ) ) { show Feedback ( STR_ ) ; return ; } try { pointer = new Whitebox Raster ( pointer Header , STR_ ) ; int rows = pointer . get Number Rows ( ) ; int cols = pointer . get Number Columns ( ) ; double no Data = pointer . get No Data Value ( ) ; String temp File = ca Header . replace ( STR_ , STR_ ) ; File Utilities . copy File ( new File ( ca Header ) , new File ( temp File ) ) ; File Utilities . copy File ( new File ( ca Header . replace ( STR_ , STR_ ) ) , new File ( temp File . replace ( STR_ , STR_ ) ) ) ; cont Area = new Whitebox Raster ( temp File , STR_ ) ; cont Area . is Temporary File = true ; Whitebox Raster output = new Whitebox Raster ( output Header , STR_ , ca Header , Whitebox Raster . Data Type . FLOAT , - NUM_ ) ; output . set Data Scale ( Whitebox Raster Base . Data Scale . CATEGORICAL ) ; output . set Preferred Palette ( STR_ ) ; outlet ID = NUM_ ; for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { if ( pointer . get Value ( row , col ) != no Data ) { flag = false ; for ( i = NUM_ ; i < NUM_ ; i ++ ) { if ( pointer . get Value ( col + d X [ i ] , row + d Y [ i ] ) == inflowing Vals [ i ] ) { flag = true ; } } if ( ! flag ) { flag = false ; x = col ; y = row ; do { flow Dir = pointer . get Value ( y , x ) ; if ( flow Dir > NUM_ ) { i = ( int ) ( Math . log ( flow Dir ) / Ln Of 2 ) ; x += d X [ i ] ; y += d Y [ i ] ; } else { flag = true ; } SCA Value = cont Area . get Value ( y , x ) ; if ( SCA Value >= SCA Threshold ) { max SCA = - NUM_ ; ICLCA = NUM_ ; for ( i = NUM_ ; i < NUM_ ; i ++ ) { b = x + d X [ i ] ; c = y + d Y [ i ] ; if ( pointer . get Value ( c , b ) == inflowing Vals [ i ] ) { z = cont Area . get Value ( c , b ) ; if ( z > max SCA ) { max SCA = z ; ICLCA = i ; } } } b = x + d X [ ICLCA ] ; c = y + d Y [ ICLCA ] ; if ( cont Area . get Value ( c , b ) > SCA Threshold ) { flag = true ; } else { d 1 = Math . abs ( cont Area . get Value ( c , b ) - SCA Threshold ) ; d 2 = Math . abs ( cont Area . get Value ( y , x ) - SCA Threshold ) ; if ( d 1 < d 2 ) { output . set Value ( c , b , outlet ID ) ; decrement Flowpath ( c , b , cont Area . get Value ( c , b ) ) ; } else { output . set Value ( y , x , outlet ID ) ; decrement Flowpath ( y , x , cont Area . get Value ( y , x ) ) ; } outlet ID ++ ; } } } while ( ! flag ) ; } } else { output . set Value ( row , col , no Data ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * row / ( rows - NUM_ ) ) ; update Progress ( STR_ , ( int ) progress ) ; } for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { if ( output . get Value ( row , col ) == - NUM_ && pointer . get Value ( row , col ) != no Data ) { flag = false ; x = col ; y = row ; do { flow Dir = pointer . get Value ( y , x ) ; if ( flow Dir > NUM_ ) { c = ( int ) ( Math . log ( flow Dir ) / Ln Of 2 ) ; x += d X [ c ] ; y += d Y [ c ] ; z = output . get Value ( y , x ) ; if ( z != - NUM_ ) { outlet ID = z ; flag = true ; } } else { outlet ID = no Data ; flag = true ; } } while ( ! flag ) ; flag = false ; x = col ; y = row ; output . set Value ( y , x , outlet ID ) ; do { flow Dir = pointer . get Value ( y , x ) ; if ( flow Dir > NUM_ ) { c = ( int ) ( Math . log ( flow Dir ) / Ln Of 2 ) ; x += d X [ c ] ; y += d Y [ c ] ; z = output . get Value ( y , x ) ; if ( z != - NUM_ ) { flag = true ; } } else { flag = true ; } output . set Value ( y , x , outlet ID ) ; } while ( ! flag ) ; } else if ( pointer . get Value ( row , col ) == no Data ) { output . set Value ( row , col , no Data ) ; } } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( float ) ( NUM_ * row / ( rows - NUM_ ) ) ; update Progress ( STR_ , ( int ) progress ) ; } output . add Metadata Entry ( STR_ + get Descriptive Name ( ) + STR_ ) ; output . add Metadata Entry ( STR_ + new Date ( ) ) ; pointer . close ( ) ; cont Area . close ( ) ; output . close ( ) ; return Data ( output Header ) ; } catch ( Out Of Memory Error oe ) { my Host . show Feedback ( STR_ ) ; } catch ( Exception e ) { my Host . show Feedback ( STR_ ) ; my Host . log Exception ( STR_ + get Descriptive Name ( ) , e ) ; } finally { update Progress ( STR_ , NUM_ ) ; am I Active = false ; my Host . plugin Complete ( ) ; } }
private void count Lines ( String message ) { char [ ] chars = message . to Char Array ( ) ; for ( int i = NUM_ ; i < chars . length ; i ++ ) { if ( chars [ i ] == STR_ ) line Count ++ ; } }
private void check State ( ) throws Illegal State Exception { if ( training Names == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( training Names . size ( ) == NUM_ ) { throw new Illegal State Exception ( STR_ ) ; } }
private Array List < Alias Info > map Private Keys ( Array List < byte [ ] > pkey I Ds , Hash Map < String , Hash Set < Alias Info > > cert Map ) throws PKCS 11 Exception , Certificate Exception { alias Map = new Hash Map < String , Alias Info > ( ) ; Array List < Alias Info > matched Certs = new Array List < Alias Info > ( ) ; for ( byte [ ] pkey ID : pkey I Ds ) { boolean found Match = false ; Set < String > cert Labels = cert Map . key Set ( ) ; for ( String cert Label : cert Labels ) { Hash Set < Alias Info > info Set = cert Map . get ( cert Label ) ; for ( Alias Info alias Info : info Set ) { if ( Arrays . equals ( pkey ID , alias Info . id ) ) { if ( info Set . size ( ) == NUM_ ) { alias Info . matched = true ; alias Map . put ( cert Label , alias Info ) ; } else { alias Info . matched = true ; alias Map . put ( get ID ( cert Label , alias Info . cert ) , alias Info ) ; } matched Certs . add ( alias Info ) ; found Match = true ; break ; } } if ( found Match ) { break ; } } if ( ! found Match ) { if ( debug != null ) { debug . println ( STR_ + get ID ( pkey ID ) + STR_ ) ; } } } return matched Certs ; }
public void clear ( final Neuron neuron ) { neuron . force Set Activation ( NUM_ ) ; }
public static void configure Numeric Formatted Text Field ( @ Not Null J Formatted Text Field text Field ) { Number Format format = Number Format . get Integer Instance ( ) ; format . set Parse Integer Only ( true ) ; format . set Grouping Used ( false ) ; Number Formatter number Formatter = new Number Formatter ( format ) ; number Formatter . set Minimum ( NUM_ ) ; text Field . set Formatter Factory ( new Default Formatter Factory ( number Formatter ) ) ; text Field . set Horizontal Alignment ( Swing Constants . TRAILING ) ; text Field . set Columns ( NUM_ ) ; }
public static int hash 3 ( int hash , Object x , Object y , Object z ) { return NUM_ | ( hash + NUM_ * System . identity Hash Code ( x ) + NUM_ * System . identity Hash Code ( y ) + NUM_ * System . identity Hash Code ( z ) ) ; }
@ Override public Index Input open Input ( String name , IO Context context ) throws IO Exception { ensure Open ( ) ; ensure Can Read ( name ) ; Path path = directory . resolve ( name ) ; Seekable Byte Channel channel = Files . new Byte Channel ( path , Standard Open Option . READ ) ; return new Simple FS Index Input ( STR_ + path + STR_ , channel , context ) ; }
public void trim ( ) { for ( String key : key Names ( ) ) { String value = ( String ) properties . get ( key ) ; if ( value != null ) properties . put ( key , value . trim ( ) ) ; } }
public static void remove Markers ( I Resource res ) throws Core Exception { res . delete Markers ( Find Bugs Marker . NAME , true , I Resource . DEPTH INFINITE ) ; if ( res instanceof I Project ) { I Project project = ( I Project ) res ; Findbugs Plugin . clear Bug Collection ( project ) ; } }
private Map load Java API Master Data Map ( final String class Name , final String method Name , final String parametertype [ ] , final String parametervalue [ ] ) throws Application Runtime Exception { Map data Map = new Hash Map ( ) ; try { if ( parametertype . length != parametervalue . length ) throw new Application Runtime Exception ( STR_ ) ; final Class cls = Class . for Name ( class Name ) ; final Method method = cls . get Method ( method Name , load Method Parameter ( parametertype ) ) ; data Map = ( Hash Map ) method . invoke ( cls . new Instance ( ) , load Method Arguments ( parametertype , parametervalue ) ) ; } catch ( final Exception e ) { LOGGER . error ( STR_ , e ) ; throw new Application Runtime Exception ( STR_ , e ) ; } return data Map ; }
String format Date Time For File Name ( long unix Time ) { final Date date = new Date ( unix Time ) ; final Simple Date Format format = filename Date And Time Format . get ( ) ; return format . format ( date ) ; }
@ Override public boolean is Server Primary ( Server Bartender server ) { for ( int i = NUM_ ; i < Math . min ( NUM_ , owners . length ) ; i ++ ) { Server Bartender server Bar = server ( i ) ; if ( server Bar == null ) { continue ; } else if ( server Bar . is Same Server ( server ) ) { return true ; } } return false ; }
protected void calc Formats ( ) { if ( m Value Digits To Use == - NUM_ ) m Value Format Digits = Utils . get Pie Format Digits ( m Delta Y ) ; else m Value Format Digits = m Value Digits To Use ; String Buffer b = new String Buffer ( ) ; for ( int i = NUM_ ; i < m Value Format Digits ; i ++ ) { if ( i == NUM_ ) b . append ( STR_ ) ; b . append ( STR_ ) ; } m Format Value = new Decimal Format ( STR_ + b . to String ( ) ) ; }
public static UUID uuid For Timestamp ( Date timestamp ) { return uuid For Time Millis ( timestamp . get Time ( ) , NUM_ ) ; }
public Long read ( String value ) { return Long . value Of ( value ) ; }
private void provide Param For Context ( String context , String qualifier , Object param Value ) { if ( context == null || context . equals ( STR_ ) ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( qualifier == null || qualifier . equals ( STR_ ) ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( param Value == null ) { throw new Illegal Argument Exception ( STR_ ) ; } Param Binder Helper . add Provided Param ( context , qualifier , param Value ) ; }
void invoke ( @ Non Null Event Bus bus , @ Non Null Object event ) { try { Object subscriber = m Subscriber . get ( ) ; if ( subscriber != null ) { m Method . invoke ( subscriber , event ) ; } } catch ( Invocation Target Exception e ) { } catch ( Throwable e ) { e . print Stack Trace ( ) ; } }
private void update Device Data Map In Export Mask ( Export Mask export Mask , Host Storage Domain hsd , Storage System storage , String Set Map device Data Map Entries ) { List < String > storage Ports = Arrays . as List ( hsd . get Port ID ( ) ) ; String Set hsd Target Port Values = new String Set ( ) ; List < String > storage Port UR Is = get Storage Port UR Is ( storage Ports , storage ) ; hsd Target Port Values . add All ( storage Port UR Is ) ; device Data Map Entries . put ( hsd . get Object ID ( ) , hsd Target Port Values ) ; }
public String decode Base 64 ( String value ) { return new String ( Base 64 . decode Base 64 ( value ) ) ; }
public static boolean is Region Departure Notification Ok ( ) { return region Departure Notification Disabled . get ( ) != Boolean . TRUE ; }
private String build Row ( long n ) { Array List < Long > times = timings . get ( n ) ; long sum , min , max ; if ( times == null || times . size ( ) == NUM_ ) { return n + STR_ ; } sum = NUM_ ; min = max = sum = times . get ( NUM_ ) ; if ( times . size ( ) == NUM_ ) { return n + STR_ + min + STR_ + min + STR_ + max + STR_ + NUM_ + STR_ + NUM_ ; } int min Idx = NUM_ ; int max Idx = NUM_ ; for ( int i = NUM_ ; i < times . size ( ) ; i ++ ) { long t = times . get ( i ) ; if ( t < min ) { min = t ; min Idx = i ; } if ( t > max ) { max = t ; max Idx = i ; } sum += t ; } if ( times . size ( ) == NUM_ ) { double diff = Math . abs ( max - min ) ; diff = diff / NUM_ ; double avg = max + min ; avg = avg / NUM_ ; return n + STR_ + avg + STR_ + min + STR_ + max + STR_ + diff + STR_ + NUM_ ; } sum = sum - min - max ; int ct = times . size ( ) - NUM_ ; double mean = sum ; mean = mean / ct ; double calc = NUM_ ; for ( int i = NUM_ ; i < times . size ( ) ; i ++ ) { if ( i == min Idx || i == max Idx ) continue ; calc += ( times . get ( i ) - mean ) * ( times . get ( i ) - mean ) ; } if ( ct == NUM_ ) { calc = NUM_ ; } else { calc /= ( ct - NUM_ ) ; calc = Math . sqrt ( calc ) ; } return n + STR_ + mean + STR_ + min + STR_ + max + STR_ + calc + STR_ + ct ; }
private void start Subscription For Monitoring ( Set < String > active Providers Change Set ) { for ( String smis Provider Uri : active Providers Change Set ) { boolean is Success = connection Factory . subscribe SMI Provider Connection ( smis Provider Uri ) ; if ( is Success ) { ACTIVE SMIS PROVIDERS CACHE . add ( smis Provider Uri ) ; logger . info ( STR_ , smis Provider Uri ) ; } else { logger . error ( STR_ + STR_ , smis Provider Uri ) ; } } }
public void create Default Columns From Model ( ) { Data Line Model < ? , ? > dlm = ( Data Line Model < ? , ? > ) data Model ; if ( dlm != null ) { Table Column Model cm = get Column Model ( ) ; while ( cm . get Column Count ( ) > NUM_ ) { cm . remove Column ( cm . get Column ( NUM_ ) ) ; } for ( int i = NUM_ ; i < dlm . get Column Count ( ) ; i ++ ) { Table Column new Column = dlm . get Table Column ( i ) ; if ( new Column != null ) { add Column ( new Column ) ; } } } }
public Event Queue Handler ( ) { Settings settings = new Settings ( SETTINGS NAMESPACE ) ; int nrof = settings . get Int ( NROF SETTING ) ; this . queues = new Array List < Event Queue > ( ) ; for ( int i = NUM_ ; i <= nrof ; i ++ ) { Settings s = new Settings ( SETTINGS NAMESPACE + i ) ; if ( s . contains ( PATH SETTING ) ) { int preload = NUM_ ; String path = STR_ ; if ( s . contains ( PRELOAD SETTING ) ) { preload = s . get Int ( PRELOAD SETTING ) ; } path = s . get Setting ( PATH SETTING ) ; queues . add ( new External Events Queue ( path , preload ) ) ; } else if ( s . contains ( CLASS SETTING ) ) { String class Name = CLASS PACKAGE + STR_ + s . get Setting ( CLASS SETTING ) ; Event Queue eq = ( Event Queue ) s . create Intialized Object ( class Name ) ; queues . add ( eq ) ; } } }
public J Tool Tip create Tool Tip ( ) { return new J Multi Line Tool Tip ( ) ; }
public void notify Data Changed ( ) { init ( ) ; }
public double [ ] predict ( F Vec feat , boolean output margin , int ntree limit ) { double [ ] preds = predict Raw ( feat , ntree limit ) ; if ( ! output margin ) { return obj . pred Transform ( preds ) ; } return preds ; }
private boolean process Key Up ( int key Code ) { if ( key Code == Key Event . KEYCODE DEL ) { if ( m In Kb Mode ) { if ( ! m Typed Times . is Empty ( ) ) { int deleted = delete Last Typed Key ( ) ; String deleted Key Str ; if ( deleted == get Am Or Pm Key Code ( AM ) ) { deleted Key Str = m Am Text ; } else if ( deleted == get Am Or Pm Key Code ( PM ) ) { deleted Key Str = m Pm Text ; } else { deleted Key Str = String . format ( STR_ , get Val From Key Code ( deleted ) ) ; } announce For Accessibility ( String . format ( m Deleted Key Format , deleted Key Str ) ) ; update Display ( true ) ; } } } else if ( key Code == Key Event . KEYCODE 0 || key Code == Key Event . KEYCODE 1 || key Code == Key Event . KEYCODE 2 || key Code == Key Event . KEYCODE 3 || key Code == Key Event . KEYCODE 4 || key Code == Key Event . KEYCODE 5 || key Code == Key Event . KEYCODE 6 || key Code == Key Event . KEYCODE 7 || key Code == Key Event . KEYCODE 8 || key Code == Key Event . KEYCODE 9 || ( ! m Is 24 Hour View && ( key Code == get Am Or Pm Key Code ( AM ) || key Code == get Am Or Pm Key Code ( PM ) ) ) ) { if ( ! m In Kb Mode ) { if ( m Radial Time Picker View == null ) { Log . e ( TAG , STR_ ) ; return true ; } m Typed Times . clear ( ) ; try Starting Kb Mode ( key Code ) ; return true ; } if ( add Key If Legal ( key Code ) ) { update Display ( false ) ; } return true ; } return false ; }
public static < T > Atomic Integer Field Updater < T > new Atomic Integer Field Updater ( Class < T > t Class , String field Name ) { try { return new Unsafe Atomic Integer Field Updater < > ( J Unsafe . get Unsafe ( ) , t Class , field Name ) ; } catch ( Throwable t ) { return Atomic Integer Field Updater . new Updater ( t Class , field Name ) ; } }
private static boolean eq ( Object o 1 , Object o 2 ) { return ( o 1 == null ? o 2 == null : o 1 . equals ( o 2 ) ) ; }
@ Nullable public static Block load One Block From Xml ( Input Stream is , Block Factory block Factory ) throws Blockly Parser Exception { List < Block > temp = load From Xml ( is , block Factory , null ) ; if ( temp . is Empty ( ) ) { return null ; } return temp . get ( NUM_ ) ; }
private table create Tabs ( String sel Tab ) { td tabbar = new td ( STR_ , Align Type . LEFT , Align Type . MIDDLE , false ) ; a tab = new a ( STR_ , new span ( STR_ ) ) ; if ( sel Tab . equals ( STR_ ) ) { tab . set ID ( STR_ ) ; } else { tab . set ID ( STR_ ) ; tab . set Href ( STR_ ) ; } tab . set On Mouse Over ( STR_ ) ; tabbar . add Element ( tab ) ; tab = new a ( STR_ , new span ( STR_ ) ) ; if ( sel Tab . equals ( STR_ ) ) { tab . set ID ( STR_ ) ; } else { tab . set ID ( STR_ ) ; tab . set Href ( STR_ ) ; } tab . set On Mouse Over ( STR_ ) ; tabbar . add Element ( tab ) ; table top Table = new table ( STR_ , STR_ , STR_ , STR_ , null ) ; top Table . set ID ( STR_ ) ; top Table . add Element ( new tr ( tabbar ) ) ; return top Table ; }
private String print D Format ( final int x ) { return print D Format ( Integer . to String ( x ) ) ; }
public Bounding Box unify With ( Bounding Box bb ) { lat Min = Math . min ( lat Min , bb . lat Min ) ; lon Min = Math . min ( lon Min , bb . lon Min ) ; lat Max = Math . max ( lat Max , bb . lat Max ) ; lon Max = Math . max ( lon Max , bb . lon Max ) ; return this ; }
public boolean filter ( Object o , List list ) throws Exception { for ( Protocol protocol : protocol List ) { if ( protocol . is Filtered ( o . get Class ( ) ) ) { protocol . filter Packet ( user Connection , o , list ) ; return true ; } } return false ; }
private void heart Beat ( ) { try { Long new Heart Beat = System . current Time Millis ( ) ; data Manager . put Data ( get Heart Beat Path ( unique Id ) , new Heart Beat ) ; } catch ( Exception e ) { log . error ( STR_ + unique Id + STR_ , e ) ; } }
public static Result sudo ( long timeout , Pattern mask Filter , String ... args ) { String user Name = System . get Property ( STR_ ) ; if ( user Name . equals ( STR_ ) ) { return exec ( timeout , mask Filter , args ) ; } List < String > tmp List = new Array List ( Arrays . as List ( args ) ) ; tmp List . add ( NUM_ , STR_ ) ; String [ ] new Array = tmp List . to Array ( new String [ tmp List . size ( ) ] ) ; return exec ( timeout , mask Filter , new Array ) ; }
public File resource Rtf File ( @ Not Null String resource Name , @ Not Null Big Decimal version ) { String fn = resource Name + STR_ + version . to Plain String ( ) + STR_ ; return data File ( RESOURCES DIR + STR_ + resource Name + STR_ + fn ) ; }
void clear ( ) { m Top Section . clear ( ) ; m Middle Section . clear ( ) ; m Bottom Section . clear ( ) ; }
public void save Views For ( Data Source data Source , Snapshot snapshot ) { Set < Data Source View Provider > compatible Providers = get Compatible Providers ( data Source ) ; for ( Data Source View Provider compatible Provider : compatible Providers ) if ( compatible Provider . supports View For ( data Source ) && compatible Provider . supports Save View For ( data Source , snapshot . get Class ( ) ) ) compatible Provider . view Save View ( data Source , snapshot ) ; }
public static Map < String , Object > create Binary File ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = null ; try { result = create Binary File Method ( dctx , context ) ; } catch ( Generic Service Exception e ) { return Service Util . return Error ( e . get Message ( ) ) ; } return result ; }
protected void register Lang Handler ( Create Simple Lexer handler , List < String > file Extensions ) throws Exception { for ( int i = file Extensions . size ( ) ; -- i >= NUM_ ; ) { String ext = file Extensions . get ( i ) ; if ( lang Handler Registry . get ( ext ) == null ) { lang Handler Registry . put ( ext , handler ) ; } else { throw new Exception ( STR_ + ext ) ; } } }
public void z Lazy Init Objects With Callback ( Mithra Runtime Type mithra Runtime Type , Mithra Configuration Manager . Post Initialize Hook hook ) { config Manager . lazy Init Objects With Callback ( mithra Runtime Type , hook ) ; }
public List < V > values ( ) { Array List < V > list = new Array List < V > ( ) ; for ( long k : key Set ( ) ) { V value = find ( k ) . value ; if ( value != null ) { list . add ( value ) ; } } return list ; }
private int assert Pivot Counts Are Correct ( String pivot Name , Solr Params base Params , Pivot Field constraint ) throws Solr Server Exception { Solr Params p = Solr Params . wrap Appended ( base Params , params ( STR_ , build Filter ( constraint ) ) ) ; List < Pivot Field > sub Pivots = null ; try { assert Num Found ( pivot Name , constraint . get Count ( ) , p ) ; sub Pivots = constraint . get Pivot ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( pivot Name + STR_ + p + STR_ + e . get Message ( ) , e ) ; } int depth = NUM_ ; if ( null != sub Pivots ) { assert Trace Ok ( pivot Name , base Params , sub Pivots ) ; for ( Pivot Field sub Pivot : sub Pivots ) { depth = assert Pivot Counts Are Correct ( pivot Name , p , sub Pivot ) ; } } return depth + NUM_ ; }
public void prepare Filter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new Illegal Argument Exception ( STR_ + property ) ; } }
public void monitor Enter ( ) { mv . visit Insn ( Opcodes . MONITORENTER ) ; }
public static String insert Breaking Whitespace ( int line Len , String original ) { if ( original == null || line Len <= NUM_ ) throw new Illegal Argument Exception ( ) ; int length = original . length ( ) ; if ( length <= line Len ) return original ; int curr Pos = NUM_ ; String Builder retval = new String Builder ( ) ; while ( length - curr Pos > line Len ) { retval . append ( original . substring ( curr Pos , curr Pos + line Len ) ) ; curr Pos += line Len ; retval . append ( STR_ ) ; } retval . append ( original . substring ( curr Pos , length ) ) ; return retval . to String ( ) ; }
void remove Admin Role Aci ( boolean recursive ) throws AM Exception , SSO Exception { String org DN = get Organization DN ( ) ; AM Organization Impl org = new AM Organization Impl ( token , org DN ) ; Set aci Set = org . get Attribute ( STR_ ) ; Set new Aci Set = new Hash Set ( ) ; Iterator iter = aci Set . iterator ( ) ; DN this DN = DN . value Of ( entry DN ) ; while ( iter . has Next ( ) ) { String aci = ( String ) iter . next ( ) ; int index = aci . index Of ( STR_ ) ; if ( index == - NUM_ ) { new Aci Set . add ( aci ) ; continue ; } index = aci . index Of ( STR_ , index ) ; if ( index == - NUM_ ) { new Aci Set . add ( aci ) ; continue ; } index = aci . index Of ( STR_ , index ) ; if ( index == - NUM_ ) { new Aci Set . add ( aci ) ; continue ; } int index 2 = aci . last Index Of ( STR_ ) ; DN role DN = DN . value Of ( aci . substring ( index + NUM_ , index 2 ) ) ; String role Name = LDAP Utils . rdn Value From Dn ( role DN ) ; String tmpdn = role Name . replace ( STR_ , STR_ ) ; DN tmp DN = DN . value Of ( tmpdn ) ; if ( ! tmp DN . is Root DN ( ) ) { if ( ! tmp DN . equals ( this DN ) ) { if ( tmp DN . is In Scope Of ( this DN , Search Scope . SUBORDINATES ) ) { if ( ! recursive ) { new Aci Set . add ( aci ) ; } } else { new Aci Set . add ( aci ) ; } } } else { new Aci Set . add ( aci ) ; } } org . set Attribute ( STR_ , new Aci Set ) ; org . store ( ) ; }
public boolean has Remote Download Lock ( String svc Id ) { return svc Id . equals ( get Remote Download Leader ( ) ) ; }
public Pla Point Int round to the right ( Pla Direction p dir ) { Pla Point Float dir = p dir . to float ( ) ; double rounded x ; if ( dir . v y > NUM_ ) { rounded x = Math . ceil ( v x ) ; } else if ( dir . v y < NUM_ ) { rounded x = Math . floor ( v x ) ; } else { rounded x = Math . round ( v x ) ; } double rounded y ; if ( dir . v x > NUM_ ) { rounded y = Math . floor ( v y ) ; } else if ( dir . v x < NUM_ ) { rounded y = Math . ceil ( v y ) ; } else { rounded y = Math . round ( v y ) ; } return new Pla Point Int ( rounded x , rounded y ) ; }
@ Override public int hash Code ( ) { final int prime = NUM_ ; int result = NUM_ ; result = prime * result + ( ( column Name == null ) ? NUM_ : column Name . hash Code ( ) ) ; return result ; }
private void clear ( boolean remove From Cache ) { subscription . cancel ( ) ; valid = false ; synchronized ( dirty Lock ) { dirty = true ; } if ( remove From Cache ) { sms Entries . remove ( dn RFC Str ) ; } }
public String correct ( String a Word ) { if ( ( a Word . length ( ) < NUM_ ) || is Number ( a Word ) ) { return a Word ; } boolean is Upper = is Upper Case ( a Word . char At ( NUM_ ) ) ; String word = a Word . to Lower Case ( ) ; String correction = cached Corrections . get ( word ) ; if ( correction == null ) { correction = get Best Candidate ( word ) ; cached Corrections . put ( word , correction ) ; } char [ ] buffer = correction . to Char Array ( ) ; if ( is Upper ) { buffer [ NUM_ ] = to Upper Case ( buffer [ NUM_ ] ) ; } return new String ( buffer ) ; }
public Set pre Process Modify Member Ship ( SSO Token token , String entry DN , String org DN , Set members , int operation , int object Type ) throws AM Exception { Set impl Set = get Pre Post Impls ( org DN ) ; if ( impl Set != null && ! impl Set . is Empty ( ) ) { Iterator itr = impl Set . iterator ( ) ; while ( itr . has Next ( ) ) { String class Name = ( String ) itr . next ( ) ; AM Call Back impl = get Call Back Object ( class Name ) ; if ( impl == null ) { continue ; } try { switch ( operation ) { case Directory Services Impl . ADD MEMBER : members = impl . pre Process Add User ( token , entry DN , members , object Type ) ; break ; case Directory Services Impl . REMOVE MEMBER : members = impl . pre Process Remove User ( token , entry DN , members , object Type ) ; break ; } } catch ( AM Exception ae ) { debug . error ( STR_ + STR_ + class Name + STR_ + STR_ , ae ) ; throw ae ; } } } return members ; }
public static String write One Block To Xml ( Block to Serialize ) throws Blockly Serializer Exception { String Writer sw = new String Writer ( ) ; List < Block > temp = new Array List < > ( ) ; temp . add ( to Serialize ) ; write To Xml ( temp , sw ) ; String xml String = sw . to String ( ) ; try { sw . close ( ) ; return xml String ; } catch ( IO Exception e ) { throw new Illegal State Exception ( e ) ; } }
public List < Double > results ( ) { return Collections . unmodifiable List ( lapped ) ; }
protected double d Cald O ( Vec o ) { double max = NUM_ ; for ( int i = NUM_ ; i < v . length ( ) ; i ++ ) { double tmp = ( i + NUM_ ) / v . length ( ) - ECDF ( o , v . get ( i ) ) ; max = Math . max ( max , Math . abs ( tmp ) ) ; } for ( int i = NUM_ ; i < o . length ( ) ; i ++ ) { double tmp = ( i + NUM_ ) / o . length ( ) - ECDF ( v , o . get ( i ) ) ; max = Math . max ( max , Math . abs ( tmp ) ) ; } return max ; }
protected Array List < String > split Uris ( String uri ) { Array List < String > uris = new Array List < String > ( ) ; int start = NUM_ ; while ( true ) { if ( uri . char At ( start ) != STR_ ) { uris = null ; break ; } final int second Slash = uri . index Of ( STR_ , start + NUM_ ) ; if ( second Slash == - NUM_ ) { uris = null ; break ; } boolean is Done = false ; int third Slash = uri . index Of ( STR_ , second Slash + NUM_ ) ; if ( third Slash == - NUM_ ) { third Slash = uri . length ( ) ; is Done = true ; } uris . add ( uri . substring ( start , third Slash ) ) ; if ( is Done ) { break ; } start = third Slash ; } return uris ; }
@ Override public double conf Small M ( double total Example Weight , double delta ) { return NUM_ * Math . sqrt ( Math . log ( NUM_ / delta ) / ( NUM_ * total Example Weight ) ) ; }
private void configure Known Hosts ( Connection c ) throws IO Exception { File known Host File = new File ( known Host Path ) ; if ( known Host File . exists ( ) ) { database . add Hostkeys ( known Host File ) ; } final List < String > algorithms = my Host . get Host Key Algorithms ( ) ; c . set Server Host Key Algorithms ( Array Util Rt . to String Array ( algorithms ) ) ; }
public void add Row ( Object [ ] row ) throws Carbon Sort Key And Group By Exception { int current Size = entry Count ; if ( sort Buffer Size == current Size ) { LOGGER . debug ( STR_ ) ; intermediate File Merger . start Merging If Possible ( ) ; Object [ ] [ ] record Holder List Local = record Holder List ; try { semaphore . acquire ( ) ; data Sorter And Writer Executor Service . submit ( new Data Sorter And Writer ( record Holder List Local ) ) ; } catch ( Interrupted Exception e ) { LOGGER . error ( STR_ + e . get Message ( ) ) ; throw new Carbon Sort Key And Group By Exception ( e . get Message ( ) ) ; } this . record Holder List = new Object [ this . sort Buffer Size ] [ ] ; this . entry Count = NUM_ ; } record Holder List [ entry Count ++ ] = row ; }
protected double B Ffactor ( int c , int r ) { double sum = NUM_ ; double multiplier = NUM_ ; for ( int i = NUM_ ; i < r ; i ++ ) { sum += multiplier * Math . exp ( ( c * Math . log ( r - i ) - ( Special Functions . ln Factorial ( i ) + Special Functions . ln Factorial ( r - i ) ) ) ) ; multiplier *= - NUM_ ; } return sum ; }
public void trigger Notifications For Invalidate Unregistered Business Object Data ( Business Object Data Invalidate Unregistered Response business Object Data Invalidate Unregistered Response ) { for ( Business Object Data business Object Data : business Object Data Invalidate Unregistered Response . get Registered Business Object Data List ( ) ) { trigger Notifications For Create Business Object Data ( business Object Data ) ; } }
public void register Push Services With Token ( final String token ) { String http URI ; String http Method ; JSON Object data = new JSON Object ( ) ; try { data . put ( STR_ , token ) ; data . put ( STR_ , STR_ ) ; Shared Preferences prefs = app Context . get Shared Preferences ( app Context . get Package Name ( ) , Context . MODE PRIVATE ) ; if ( null != prefs ) { String last Known Push Token = prefs . get String ( PROPERTY LAST VALID PUSH TOKEN , STR_ ) ; String last Known Push Token ID = prefs . get String ( PROPERTY LAST VALID PUSH TOKEN ID , STR_ ) ; if ( ( null == last Known Push Token ID ) || ( last Known Push Token ID . equals ( STR_ ) ) ) { http URI = String . format ( STR_ , local Connection ID ) ; http Method = STR_ ; create Or Update Push Service Token ( token , http URI , http Method , data , prefs ) ; } else if ( ! last Known Push Token . equals ( STR_ ) && ! last Known Push Token . equals ( token ) ) { http URI = String . format ( STR_ , local Connection ID , last Known Push Token ID ) ; http Method = STR_ ; create Or Update Push Service Token ( token , http URI , http Method , data , prefs ) ; } } } catch ( JSON Exception e ) { Log . d ( STR_ , STR_ ) ; } }
private void check Numnber Of Engines Needed ( ) throws Build Failed Exception { if ( req Num Engines == NUM_ || ! train . is Build Consist Enabled ( ) || Setup . get Horse Power Per Ton ( ) == NUM_ ) { return ; } add Line ( build Report , ONE , BLANK LINE ) ; add Line ( build Report , ONE , Message Format . format ( Bundle . get Message ( STR_ ) , new Object [ ] { Setup . get Horse Power Per Ton ( ) } ) ) ; Route route = train . get Route ( ) ; int hp Available = NUM_ ; int extra Hp Needed = NUM_ ; Route Location rl Need Hp = null ; Route Location rl Start = train . get Train Departs Route Location ( ) ; Route Location rl End = train . get Train Terminates Route Location ( ) ; if ( route != null ) { boolean helper = false ; for ( Route Location rl : route . get Locations By Sequence List ( ) ) { if ( ( train . get Second Leg Options ( ) == Train . HELPER ENGINES && rl == train . get Second Leg Start Location ( ) ) || ( train . get Third Leg Options ( ) == Train . HELPER ENGINES && rl == train . get Third Leg Start Location ( ) ) ) { add Line ( build Report , FIVE , Message Format . format ( Bundle . get Message ( STR_ ) , new Object [ ] { rl . get Name ( ) } ) ) ; helper = true ; } if ( ( train . get Second Leg Options ( ) == Train . HELPER ENGINES && rl == train . get Second Leg End Location ( ) ) || ( train . get Third Leg Options ( ) == Train . HELPER ENGINES && rl == train . get Third Leg End Location ( ) ) ) { add Line ( build Report , FIVE , Message Format . format ( Bundle . get Message ( STR_ ) , new Object [ ] { rl . get Name ( ) } ) ) ; helper = false ; } if ( helper ) { continue ; } if ( ( ( train . get Second Leg Options ( ) & Train . CHANGE ENGINES ) == Train . CHANGE ENGINES && rl == train . get Second Leg Start Location ( ) ) || ( ( train . get Third Leg Options ( ) & Train . CHANGE ENGINES ) == Train . CHANGE ENGINES && rl == train . get Third Leg Start Location ( ) ) ) { log . debug ( STR_ , rl . get Name ( ) ) ; add Locos ( hp Available , extra Hp Needed , rl Need Hp , rl Start , rl ) ; add Line ( build Report , THREE , BLANK LINE ) ; rl Start = rl ; rl Need Hp = null ; extra Hp Needed = NUM_ ; } int weight = rl . get Train Weight ( ) ; if ( weight > NUM_ ) { double hpt Minimum = Setup . get Horse Power Per Ton ( ) ; double hpt Grade = ( NUM_ * rl . get Grade ( ) / NUM_ ) ; int hp = train . get Train Horse Power ( rl ) ; int hpt = hp / weight ; if ( hpt Grade > hpt Minimum ) { hpt Minimum = hpt Grade ; } if ( hpt Minimum > hpt ) { int add Hp = ( int ) ( hpt Minimum * weight - hp ) ; if ( add Hp > extra Hp Needed ) { hp Available = hp ; extra Hp Needed = add Hp ; rl Need Hp = rl ; } add Line ( build Report , SEVEN , Message Format . format ( Bundle . get Message ( STR_ ) , new Object [ ] { weight , hp , rl . get Grade ( ) , hpt , hpt Minimum , rl . get Name ( ) , rl . get Id ( ) } ) ) ; add Line ( build Report , FIVE , Message Format . format ( Bundle . get Message ( STR_ ) , new Object [ ] { add Hp , rl . get Name ( ) , hpt Minimum } ) ) ; add Line ( build Report , SEVEN , BLANK LINE ) ; } } } } add Locos ( hp Available , extra Hp Needed , rl Need Hp , rl Start , rl End ) ; add Line ( build Report , SEVEN , Message Format . format ( Bundle . get Message ( STR_ ) , new Object [ ] { train . get Name ( ) } ) ) ; add Line ( build Report , THREE , BLANK LINE ) ; }
public Domain Name Validator ( @ Non Null final Char Sequence error Message ) { super ( error Message , REGEX ) ; }
public static Run Stats delegate Get Bucket For Uuids ( int buckets ) throws Exception { Long start Time = System . current Time Millis ( ) ; Primary Index Bucket Generator Impl ibg = new Primary Index Bucket Generator Impl ( Field Data Type . UUID , buckets ) ; Primary Index Bucket Locator Impl locator = new Primary Index Bucket Locator Impl ( null , null , null , null , null , ibg . generate Buckets ( ) , null , null , null ) ; logger . debug ( STR_ ) ; Hash Map < Long , List < Object > > hm = new Hash Map < > ( ) ; Summary Statistics stats = new Summary Statistics ( ) ; UUID [ ] uuid = new UUID [ NUM_ ] ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { uuid [ i ] = UUID . random UUID ( ) ; } for ( int input Uuid = NUM_ ; input Uuid < NUM_ ; input Uuid ++ ) { Long bucket Id = locator . get Bucket ( uuid [ input Uuid ] , Field Data Type . UUID ) ; calculate ( hm , stats , bucket Id , input Uuid ) ; } Long run Time = System . current Time Millis ( ) - start Time ; Run Stats run Stats = new Run Stats ( STR_ , Field Data Type . UUID , run Time , stats , hm ) ; logger . debug ( run Stats . to String ( ) ) ; return run Stats ; }
final public int read ( final byte [ ] a , final int aoff , final int alen ) throws IO Exception { if ( alen == NUM_ ) { return NUM_ ; } final int remaining = limit - off ; if ( remaining == NUM_ ) { return - NUM_ ; } final int n = remaining < alen ? remaining : alen ; System . arraycopy ( buf , this . off , a , aoff , n ) ; this . off += n ; return n ; }
protected int calculate Cycles ( int units Cycle , Big Decimal qty ) { Big Decimal cycles = qty ; Big Decimal units Cycle BD = Big Decimal . value Of ( units Cycle ) ; if ( units Cycle BD . signum ( ) > NUM_ ) { cycles = qty . divide ( units Cycle BD , NUM_ , Rounding Mode . UP ) ; } return cycles . int Value ( ) ; }
protected boolean decl Already Declared ( String prefix ) { int start Decls = m context Indexes . peek ( ) ; java . util . Vector prefix Mappings = m prefix Mappings ; int n Decls = prefix Mappings . size ( ) ; for ( int i = start Decls ; i < n Decls ; i += NUM_ ) { String prefix Decl = ( String ) prefix Mappings . element At ( i ) ; if ( prefix Decl == null ) continue ; if ( prefix Decl . equals ( prefix ) ) return true ; } return false ; }
public final Byte Array Builder append ( String string , Charset charset ) throws Unsupported Encoding Exception { return append ( string . get Bytes ( charset . name ( ) ) ) ; }
protected Workflow . Method create Add Volumes To CG Method ( URI vplex URI , URI cg URI , List < URI > vplex Volume UR Is ) { return new Workflow . Method ( ADD VOLUMES TO CG METHOD NAME , vplex URI , cg URI , vplex Volume UR Is ) ; }
protected Supplier < Map < String , String > > build Druid Web Service Header Supplier ( ) { Supplier < Map < String , String > > supplier = null ; String custom Supplier Class String = SYSTEM CONFIG . get String Property ( DRUID HEADER SUPPLIER CLASS , null ) ; if ( custom Supplier Class String != null && custom Supplier Class String . equals ( STR_ ) ) { try { Class < ? > c = Class . for Name ( custom Supplier Class String ) ; Constructor < ? > constructor = c . get Constructor ( ) ; supplier = ( Supplier < Map < String , String > > ) constructor . new Instance ( ) ; } catch ( Exception e ) { LOG . error ( STR_ , custom Supplier Class String , e ) ; throw new Illegal State Exception ( e ) ; } } return supplier ; }
public static void main ( String argv [ ] ) throws Exception { Ping Launcher launcher = new Ping Launcher ( ) ; try { launcher . process ( argv ) ; } catch ( Throwable e ) { logger . fatal ( STR_ + e . get Message ( ) , e ) ; } exit With Success ( ) ; }
@ Target Api ( Build . VERSION CODES . KITKAT ) public void show ( ) { if ( is Show ) return ; init TN ( ) ; try { show . invoke ( m TN ) ; } catch ( Invocation Target Exception | Illegal Access Exception e ) { e . print Stack Trace ( ) ; } is Show = true ; if ( m Duration > LENGTH ALWAYS ) { handler . post Delayed ( hide Runnable , m Duration * NUM_ ) ; } }
private void compute Y Axis Stops ( float min Y , float max Y ) { int start = ( int ) min Y ; int end = ( int ) Math . ceil ( max Y ) ; float range = end - start ; if ( range < NUM_ ) { return ; } int steps Count = NUM_ ; if ( range == NUM_ ) { start -= steps Count ; end += steps Count ; } int interval = range == NUM_ ? steps Count : ( int ) Math . ceil ( range / steps Count ) ; while ( start + interval * steps Count <= end ) { steps Count ++ ; interval = range == NUM_ ? steps Count : ( int ) Math . ceil ( range / steps Count ) ; } float value = start ; int n = NUM_ ; while ( value <= end ) { value += interval ; n ++ ; } y Stops . num Stops = n ; if ( y Stops . stops . length < n ) { y Stops . stops = new float [ n ] ; } value = start ; for ( int i = NUM_ ; i < n ; i ++ , value += interval ) { y Stops . stops [ i ] = value ; } }
private void enter Linked Mode For Prefix ( I Document document , I Text Viewer viewer , IDOM Element root Element , String prefix ) throws Bad Location Exception { int linked Pos Sequence = NUM_ ; Linked Position pos 1 = new Linked Position ( document , start Position , prefix . length ( ) , linked Pos Sequence ++ ) ; Linked Position pos 2 = new Linked Position ( document , cursor Position + NUM_ , prefix . length ( ) , linked Pos Sequence ++ ) ; IDOM Element root Dom Element = ( IDOM Element ) root Element ; final String xmlns Prefix = STR_ ; String full Prefix Name = xmlns Prefix + prefix ; IDOM Attr dom Attribute = ( IDOM Attr ) root Dom Element . get Attribute Node ( full Prefix Name ) ; Linked Position pos 3 = new Linked Position ( document , dom Attribute . get Start Offset ( ) + xmlns Prefix . length ( ) , prefix . length ( ) , linked Pos Sequence ++ ) ; Linked Position Group group = new Linked Position Group ( ) ; group . add Position ( pos 1 ) ; group . add Position ( pos 2 ) ; group . add Position ( pos 3 ) ; Linked Mode Model model = new Linked Mode Model ( ) ; model . add Group ( group ) ; model . force Install ( ) ; Linked Mode UI ui = new Linked Mode UI ( model , viewer ) ; ui . enter ( ) ; was Linked Mode Entered = true ; }
private void compute IFD Offset ( ) { long bytes Per Row = ( long ) Math . ceil ( ( sample Size [ NUM_ ] / NUM_ ) * tile Width * num Bands ) ; long bytes Per Tile = bytes Per Row * tile Length ; long last Tile = bytes Per Tile ; if ( ! is Tiled ) { long last Strip Rows = length - ( tile Length * ( num Tiles - NUM_ ) ) ; last Tile = last Strip Rows * bytes Per Row ; } long total Bytes Of Data = bytes Per Tile * ( num Tiles - NUM_ ) + last Tile ; first IFD Offset = NUM_ + total Bytes Of Data ; if ( ( first IFD Offset % NUM_ ) != NUM_ ) { first IFD Offset ++ ; } }
private void create Multiple Style Legend ( Styled Layer Descriptor sld , Map < String , Style > style Map , Styled Layer selected Styled Layer ) { List < Styled Layer > styled Layer List = null ; if ( selected Styled Layer == null ) { styled Layer List = sld . layers ( ) ; } else { styled Layer List = new Array List < Styled Layer > ( ) ; styled Layer List . add ( selected Styled Layer ) ; } for ( Styled Layer styled Layer : styled Layer List ) { List < Style > style List = null ; if ( styled Layer instanceof Named Layer Impl ) { Named Layer Impl named Layer = ( Named Layer Impl ) styled Layer ; style List = named Layer . styles ( ) ; } else if ( styled Layer instanceof User Layer Impl ) { User Layer Impl user Layer = ( User Layer Impl ) styled Layer ; style List = user Layer . user Styles ( ) ; } if ( style List != null ) { int count = NUM_ ; for ( Style style : style List ) { String style Name ; if ( style . get Name ( ) != null ) { style Name = style . get Name ( ) ; } else { style Name = String . format ( STR_ , count ) ; } style Map . put ( style Name , style ) ; count ++ ; } } } }
public String generate Create ( String table ) throws Database Exception { String Buffer result = new String Buffer ( ) ; try { String Buffer sql = new String Buffer ( ) ; sql . append ( STR_ ) ; sql . append ( table ) ; Result Set rs = execute Query ( sql . to String ( ) ) ; Result Set Meta Data md = rs . get Meta Data ( ) ; result . append ( STR_ ) ; result . append ( table ) ; result . append ( STR_ ) ; for ( int i = NUM_ ; i <= md . get Column Count ( ) ; i ++ ) { if ( i != NUM_ ) { result . append ( STR_ ) ; } result . append ( md . get Column Name ( i ) ) ; result . append ( STR_ ) ; String type = process Type ( md . get Column Type Name ( i ) , md . get Precision ( i ) ) ; result . append ( type ) ; } result . append ( STR_ ) ; rs . close ( ) ; } catch ( SQL Exception e ) { throw ( new Database Exception ( e ) ) ; } return result . to String ( ) ; }
private Segment Meta find Segment Meta ( int size ) { for ( Segment Meta segment Meta : this . segment Meta ) { if ( segment Meta . size ( ) == size ) { return segment Meta ; } } throw new Illegal State Exception ( L . l ( STR_ , size ) ) ; }
protected synchronized void remember Last Thing ( Undo Event event ) { if ( undo Stack . size ( ) >= stack Size ) { undo Stack . remove Element At ( NUM_ ) ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + event . get Description ( ) + STR_ ) ; } undo Stack . push ( event ) ; }
private void create Scene Vao ( ) { int vao = gl Gen Vertex Arrays ( ) ; int vbo = gl Gen Buffers ( ) ; gl Bind Vertex Array ( vao ) ; gl Bind Buffer ( GL ARRAY BUFFER , vbo ) ; Byte Buffer bb = Buffer Utils . create Byte Buffer ( boxes . length * NUM_ * ( NUM_ + NUM_ ) * NUM_ * NUM_ ) ; Float Buffer fv = bb . as Float Buffer ( ) ; for ( int i = NUM_ ; i < boxes . length ; i += NUM_ ) { Demo Utils . triangulate Box ( boxes [ i ] , boxes [ i + NUM_ ] , fv ) ; } gl Buffer Data ( GL ARRAY BUFFER , bb , GL STATIC DRAW ) ; gl Enable Vertex Attrib Array ( NUM_ ) ; gl Vertex Attrib Pointer ( NUM_ , NUM_ , GL FLOAT , false , NUM_ * ( NUM_ + NUM_ ) , NUM_ ) ; gl Enable Vertex Attrib Array ( NUM_ ) ; gl Vertex Attrib Pointer ( NUM_ , NUM_ , GL FLOAT , false , NUM_ * ( NUM_ + NUM_ ) , NUM_ * NUM_ ) ; gl Bind Buffer ( GL ARRAY BUFFER , NUM_ ) ; gl Bind Vertex Array ( NUM_ ) ; this . vao Scene = vao ; }
public void file Not Found ( File f ) { if ( ! recent Files . contains ( f ) ) { throw new Illegal State Exception ( STR_ ) ; } else { recent Files . remove ( f ) ; } }
public static String clear Last Viewed Categories ( Http Servlet Request request , Http Servlet Response response ) { Http Session session = request . get Session ( ) ; if ( session != null ) { session . set Attribute ( STR_ , Fast List . new Instance ( ) ) ; } return STR_ ; }
public SQ Lite Database Configuration ( String path , int open Flags ) { if ( path == null ) { throw new Illegal Argument Exception ( STR_ ) ; } this . path = path ; label = strip Path For Logs ( path ) ; this . open Flags = open Flags ; max Sql Cache Size = NUM_ ; locale = Locale . get Default ( ) ; }
private void do Restore ( ) { view . set Original Trace Shown ( true ) ; view . update Error View ( ) ; }
@ Api Operation ( value = STR_ ) @ Request Mapping ( value = STR_ , method = Request Method . POST ) @ Response Status ( Http Status . NO CONTENT ) @ Response Body public final void post Request Initial Load ( @ Path Variable ( STR_ ) String engine Name , @ Request Param ( value = STR_ ) String node Id ) { I Symmetric Engine engine = get Symmetric Engine ( engine Name ) ; I Node Service node Service = engine . get Node Service ( ) ; node Service . set Initial Load Enabled ( node Id , true , false , - NUM_ , STR_ ) ; }
public static int hash Word ( String s Word ) { int i Cnt = NUM_ , i Res = NUM_ , i Len = s Word . length ( ) ; for ( i Cnt = NUM_ ; i Cnt < i Len ; i Cnt ++ ) i Res += ( int ) s Word . char At ( i Cnt ) ; return ( s Word . length ( ) * NUM_ + i Res ) ; }
public static final void add Logging Behavior ( Logging Behavior behavior ) { synchronized ( logging Behaviors ) { logging Behaviors . add ( behavior ) ; } }
private static Iterator < Edge Info > parse ( int sup [ ] , int dem [ ] , int sup transship [ ] [ ] , int [ ] warehouse costs , int [ ] warehouse limits , int dem transship [ ] [ ] , int costs [ ] [ ] ) { int m = sup . length ; int n = dem . length ; int w = warehouse costs . length ; if ( m != costs . length ) { throw new Illegal Argument Exception ( STR_ + costs . length + STR_ + m ) ; } for ( int i = NUM_ ; i < m ; i ++ ) { if ( costs [ i ] . length != n ) { throw new Illegal Argument Exception ( STR_ + costs [ i ] . length + STR_ + n ) ; } } if ( w != NUM_ ) { if ( sup transship . length != m ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( dem transship . length != w ) { throw new Illegal Argument Exception ( STR_ ) ; } for ( int i = NUM_ ; i < w ; i ++ ) { if ( dem transship [ i ] . length != n ) { throw new Illegal Argument Exception ( STR_ ) ; } } for ( int i = NUM_ ; i < m ; i ++ ) { if ( sup transship [ i ] . length != w ) { throw new Illegal Argument Exception ( STR_ ) ; } } } Array List < Edge Info > edges = new Array List < Edge Info > ( ) ; int supply offset = NUM_ ; int w offset = NUM_ + m ; int demand offset = NUM_ + m + NUM_ * w ; int target = NUM_ + m + NUM_ * w + n ; for ( int i = NUM_ ; i < m ; i ++ ) { edges . add ( new Edge Info ( NUM_ , supply offset + i , sup [ i ] , NUM_ ) ) ; } for ( int j = NUM_ ; j < n ; j ++ ) { edges . add ( new Edge Info ( demand offset + j , target , dem [ j ] , NUM_ ) ) ; } for ( int k = NUM_ ; k < w ; k ++ ) { edges . add ( new Edge Info ( w offset + NUM_ * k , w offset + ( NUM_ * k + NUM_ ) , warehouse limits [ k ] , warehouse costs [ k ] ) ) ; } for ( int i = NUM_ ; i < m ; i ++ ) { for ( int k = NUM_ ; k < w ; k ++ ) { edges . add ( new Edge Info ( supply offset + i , w offset + NUM_ * k , sup [ i ] , sup transship [ i ] [ k ] ) ) ; } } for ( int i = NUM_ ; i < w ; i ++ ) { for ( int j = NUM_ ; j < n ; j ++ ) { edges . add ( new Edge Info ( w offset + NUM_ * i + NUM_ , demand offset + j , dem [ j ] , dem transship [ i ] [ j ] ) ) ; } } for ( int i = NUM_ ; i < m ; i ++ ) { for ( int j = NUM_ ; j < n ; j ++ ) { edges . add ( new Edge Info ( supply offset + i , demand offset + j , Integer . MAX VALUE , costs [ i ] [ j ] ) ) ; } } return edges . iterator ( ) ; }
public String module Alias ( Module pkg ) { if ( compiler . is Compiling Language Module ( ) && pkg . get Language Module ( ) == pkg ) { return STR_ ; } String Builder sb = new String Builder ( STR_ ) ; sb . append ( Long . to String ( get UID ( pkg ) , NUM_ ) ) ; return sb . to String ( ) ; }
private static void initalise ( ) { if ( current Profile == null ) { current Profile = Configuration Manager . get Current Profile ( ) ; max Before Split = current Profile . get Max Before Split ( ) ; max Split Levels = current Profile . get Max Split Levels ( ) ; max Before Paginate = current Profile . get Max Before Paginate ( ) ; use External Icons = current Profile . get External Icons ( ) ; use External Images = current Profile . get External Images ( ) ; include Covers In Catalog = current Profile . get Include Covers In Catalog ( ) ; books URI = current Profile . get Url Books ( ) ; collator = Collator . get Instance ( Configuration Manager . get Locale ( ) ) ; xsl Catalog Changed = ! Catalog Manager . is Generate File Same As Catalog File ( Constants . CATALOG XSL ) ; xsl Full Entry Changed = ! Catalog Manager . is Generate File Same As Catalog File ( Constants . FULLENTRY XSL ) ; default Cover File = Cached File Manager . add Cached File ( new File ( Catalog Manager . get Generate Folder ( ) , Constants . DEFAULT IMAGE FILENAME ) ) ; default Cover Uri = Constants . PARENT PATH PREFIX + Constants . DEFAULT IMAGE FILENAME ; } }
protected void calc Modulus ( ) { float [ ] values = new float [ NUM_ ] ; m Matrix Touch . get Values ( values ) ; m Legend Grid Modulus = ( int ) Math . ceil ( ( m Data . get X Val Count ( ) * m X Legend Width ) / ( m Content Rect . width ( ) * values [ Matrix . MSCALE X ] ) ) ; }
private Template Druid Query build Outer Query ( String metric Dictionary , Metric Field source Metric , Template Druid Query inner Query ) { Aggregation sum = create Summing Aggregator ( source Metric ) ; Set < Aggregation > outer Aggs = new Linked Hash Set < > ( Arrays . as List ( sum , COUNT OUTER ) ) ; Field Accessor Post Aggregation sum Post = new Field Accessor Post Aggregation ( sum ) ; Post Aggregation average = new Arithmetic Post Aggregation ( metric Dictionary , DIVIDE , Arrays . as List ( sum Post , COUNT FIELD OUTER ) ) ; Set < Post Aggregation > outer Post Aggs = Collections . singleton ( average ) ; return new Template Druid Query ( outer Aggs , outer Post Aggs , inner Query ) ; }
private static boolean is Appropriate Property Name For Getter ( @ Not Null Psi Method getter , @ Not Null String imported Name For Getter , @ Not Null String property Name ) { property Name = Groovy Property Utils . decapitalize ( property Name ) ; return property Name . equals ( get Property Name By Getter ( getter , imported Name For Getter ) ) ; }
public void remove Menu ( final int index ) { menu Bar . remove ( menu Bar . get Menu ( index ) ) ; }
public static Prob CNF Grammar build Example Grammar One ( ) { Prob CNF Grammar g = new Prob CNF Grammar ( ) ; Array List < Rule > rules = new Array List < Rule > ( ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; rules . add ( new Rule ( STR_ , STR_ , ( float ) NUM_ ) ) ; if ( ! g . add Rules ( rules ) ) { return null ; } return g ; }
public synchronized OM Graphic List prepare ( ) { OM Graphic List list = get List ( ) ; if ( list == null ) { list = new OM Graphic List ( ) ; } else { list . clear ( ) ; } Debug . message ( STR_ , get Name ( ) + STR_ ) ; OM Graphic ras = create Image ( get Projection ( ) ) ; if ( timer != null ) timer . restart ( ) ; list . add ( ras ) ; return list ; }
private void refresh Dictionary If Needed ( ) throws Ade Exception { if ( System . current Time Millis ( ) - m dictionary . get Last Refresh Time ( ) > m min Refresh Time ) { m dictionary . refresh ( ) ; m src 2 Analysis Grp Map . clear ( ) ; } }
public void allocate Load Balance ( ) { load Balance Allocate Count . increment And Get ( ) ; }
public static java . sql . Date to Sql Date ( int month , int day , int year ) { java . util . Date new Date = to Date ( month , day , year , NUM_ , NUM_ , NUM_ ) ; if ( new Date != null ) { return new java . sql . Date ( new Date . get Time ( ) ) ; } else { return null ; } }
@ Pure public static < T extends Comparable < ? super T > > I Persistent Vector < T > sort ( I Persistent Vector < T > list ) { I Transient Vector < T > tv = list . as Transient ( ) ; Collections . sort ( tv ) ; return tv . persistent ( ) ; }
public static String gensalt ( int log rounds , Secure Random random ) { String Buffer rs = new String Buffer ( ) ; byte rnd [ ] = new byte [ BCRYPT SALT LEN ] ; random . next Bytes ( rnd ) ; rs . append ( STR_ ) ; if ( log rounds < NUM_ ) rs . append ( STR_ ) ; rs . append ( Integer . to String ( log rounds ) ) ; rs . append ( STR_ ) ; rs . append ( encode base 64 ( rnd , rnd . length ) ) ; return rs . to String ( ) ; }
public List < Named Entity Task 1 Data > generate Task 1 Data ( List < J Cas > documents J Cas , int gold Offset , boolean generate Gold , int limit ) throws Crowd Exception { Log LOG = Log Factory . get Log ( get Class ( ) ) ; List < Named Entity Task 1 Data > data = new Array List < Named Entity Task 1 Data > ( ) ; int i = gold Offset ; String Builder text Builder = new String Builder ( ) ; int doc No = NUM_ ; jcasloop : for ( J Cas document J Cas : documents J Cas ) { int offset = i ; int sentence No = NUM_ ; LOG . info ( STR_ + doc No + STR_ + documents J Cas . size ( ) ) ; for ( Sentence sentence : select ( document J Cas , Sentence . class ) ) { if ( limit != - NUM_ && sentence No >= limit ) { break jcasloop ; } text Builder . set Length ( NUM_ ) ; Map < Integer , Integer > char Offset Start Mapping = new Hash Map < Integer , Integer > ( ) ; Map < Integer , Integer > char Offset End Mapping = new Hash Map < Integer , Integer > ( ) ; for ( Token token : select Covered ( Token . class , sentence ) ) { text Builder . append ( HTML SPAN TOKEN START ) ; text Builder . append ( String . value Of ( i ) ) ; text Builder . append ( HTML SPAN TOKEN CLOSE ) ; text Builder . append ( escape Html ( token . get Covered Text ( ) ) ) ; text Builder . append ( STR_ ) ; text Builder . append ( HTML SPAN CLOSE ) ; char Offset Start Mapping . put ( token . get Begin ( ) , i ) ; char Offset End Mapping . put ( token . get End ( ) , i ) ; i ++ ; } String text = text Builder . to String ( ) ; text Builder . set Length ( NUM_ ) ; Named Entity Task 1 Data task 1 Data = new Named Entity Task 1 Data ( text ) ; task 1 Data . set Offset ( offset ) ; task 1 Data . set Document ( JSON SOURCEDOC SHORTFORM + String . value Of ( doc No ) ) ; if ( generate Gold ) { List < String > gold Elems = new Array List < String > ( ) ; List < String > gold Tokens = new Array List < String > ( ) ; List < String > gold Types = new Array List < String > ( ) ; int last Ne Begin = - NUM_ ; int last Ne End = - NUM_ ; for ( Named Entity named Entity : select Covered ( Named Entity . class , sentence ) ) { List < Token > tokens = select Covered ( document J Cas , Token . class , named Entity . get Begin ( ) , named Entity . get End ( ) ) ; List < String > str Tokens = new Array List < String > ( ) ; for ( Token t : tokens ) { str Tokens . add ( new String ( t . get Covered Text ( ) ) ) ; } String str Token = concat With Separator ( str Tokens , STR_ ) ; String type = named Entity . get Value ( ) ; int ne Begin = named Entity . get Begin ( ) ; int ne End = named Entity . get End ( ) ; String str Elem = build Task 1 Token JSON ( text Builder , named Entity , char Offset Start Mapping , char Offset End Mapping ) ; if ( last Ne End != - NUM_ && ne Begin <= last Ne End ) { if ( ( ne End - ne Begin ) > ( last Ne End - last Ne Begin ) ) { gold Elems . remove ( gold Elems . size ( ) - NUM_ ) ; gold Tokens . remove ( gold Elems . size ( ) - NUM_ ) ; gold Types . remove ( gold Elems . size ( ) - NUM_ ) ; gold Elems . add ( str Elem ) ; gold Tokens . add ( str Token ) ; gold Types . add ( type ) ; last Ne Begin = ne Begin ; last Ne End = ne End ; } } else { gold Elems . add ( str Elem ) ; gold Tokens . add ( str Token ) ; gold Types . add ( type ) ; last Ne Begin = ne Begin ; last Ne End = ne End ; } } String str Types = JSON VALUE EMPTY ARRAY ; String str Gold = JSON VALUE NONE MARKER ; String str Gold Reason = no Gold NER 1 Reason ; int difficulty = NUM_ ; if ( gold Elems . size ( ) > NUM_ ) { str Gold = build Task 1 Gold Elem ( text Builder , gold Elems ) ; difficulty = gold Elems . size ( ) ; str Types = build Task 1 Gold Elem ( text Builder , gold Types ) ; str Gold Reason = build Task 1 Gold Elem Reason ( text Builder , gold Tokens ) ; } task 1 Data . set difficulty ( difficulty ) ; task 1 Data . set Markertext gold ( str Gold ) ; task 1 Data . set Markertext gold reason ( str Gold Reason ) ; task 1 Data . set Types ( str Types ) ; task 1 Data . set Document ( JSON GOLDDOC SHORTFORM + String . value Of ( doc No ) ) ; task 1 Data . set golden ( JSON TRUE ) ; } data . add ( task 1 Data ) ; sentence No ++ ; } doc No ++ ; } if ( generate Gold ) { last Gold Offset = i ; } return data ; }
private String generate Template Id SQL Statement ( boolean table Exists ) { String Buffer output = new String Buffer ( ) ; output . append ( STR_ + Generator Constants . TABLE TPLID TPLNAME + STR_ + STR_ + STR_ + STR_ ) ; if ( ! table Exists ) { output . append ( STR_ + Generator Constants . TABLE TPLID TPLNAME + STR_ ) ; output . append ( STR_ ) ; } return output . to String ( ) ; }
private Workflow . Method create Invalidate Cache Method ( URI vplex URI , URI vplex Volume URI ) { return new Workflow . Method ( INVALIDATE CACHE METHOD NAME , vplex URI , vplex Volume URI ) ; }
public void put Clone ( Map < Attribute Key , Object > a , @ Nullable T value ) { try { put ( a , value == null ? null : clazz . cast ( Methods . invoke ( value , STR_ ) ) ) ; } catch ( No Such Method Exception ex ) { Internal Error e = new Internal Error ( ) ; e . init Cause ( ex ) ; throw e ; } }
public static String make HTML Name Safe ( String name ) { if ( name == null || name . is Empty ( ) ) { return name ; } char [ ] chrs = name . to Char Array ( ) ; if ( name . index Of ( percent Int ) != - NUM_ || name . index Of ( space Int ) != - NUM_ || name . index Of ( full Stop Int ) != - NUM_ || name . index Of ( plus Int ) != - NUM_ || name . index Of ( colon Int ) != - NUM_ || name . index Of ( equals Int ) != - NUM_ || name . index Of ( forward Slash Int ) != - NUM_ || name . index Of ( back Slash Int ) != - NUM_ ) { for ( int i = NUM_ ; i < chrs . length ; i ++ ) { switch ( chrs [ i ] ) { case ampersand : chrs [ i ] = ampersand Int ; break ; case space Int : chrs [ i ] = under Score Int ; break ; case full Stop Int : chrs [ i ] = minus Int ; break ; case percent Int : chrs [ i ] = under Score Int ; break ; case plus Int : chrs [ i ] = p Int ; break ; case colon Int : chrs [ i ] = c Int ; break ; case equals Int : chrs [ i ] = q Int ; break ; case forward Slash Int : chrs [ i ] = under Score Int ; break ; case back Slash Int : chrs [ i ] = under Score Int ; break ; } } } final char [ ] testchrs = { open Square Bracket Int , close Square Bracket Int , hash Int , divide Int , open Curly Bracket , close Curly Bracket } ; int count = NUM_ ; for ( final char chr 1 : chrs ) { for ( final char testchr : testchrs ) { if ( chr 1 == testchr ) { count ++ ; } } } if ( count > NUM_ ) { int c = NUM_ ; final char [ ] tmp = new char [ chrs . length - count ] ; MAINLOOP : for ( final char chr : chrs ) { for ( final char testchr : testchrs ) { if ( chr == testchr ) { continue MAINLOOP ; } } tmp [ c ++ ] = chr ; } chrs = tmp ; } if ( chrs [ NUM_ ] >= zero Int && chrs [ NUM_ ] <= nine Int ) { final char [ ] tmp = new char [ chrs . length + NUM_ ] ; System . arraycopy ( chrs , NUM_ , tmp , NUM_ , chrs . length ) ; tmp [ NUM_ ] = a Int ; chrs = tmp ; } name = new String ( chrs ) ; return name ; }
public static Ignite Uuid trash Id ( int idx ) { assert idx >= NUM_ && idx < TRASH CONCURRENCY ; return TRASH IDS [ idx ] ; }
public void record Bounds ( final Planet Model planet Model , final Lat Lon Bounds bounds Info , final Membership ... bounds ) { final double A = this . x ; final double B = this . y ; final double C = this . z ; if ( ! bounds Info . check No Top Latitude Bound ( ) || ! bounds Info . check No Bottom Latitude Bound ( ) ) { if ( ( Math . abs ( A ) >= MINIMUM RESOLUTION || Math . abs ( B ) >= MINIMUM RESOLUTION ) ) { final Plane vertical Plane = construct Normalized Z Plane ( A , B ) ; final Geo Point [ ] points = find Intersections ( planet Model , vertical Plane , bounds , NO BOUNDS ) ; for ( final Geo Point point : points ) { add Point ( bounds Info , bounds , point ) ; } } else { final Geo Point [ ] points = find Intersections ( planet Model , normal X Plane , NO BOUNDS , NO BOUNDS ) ; bounds Info . add Z Value ( points [ NUM_ ] ) ; } } if ( ! bounds Info . check No Longitude Bound ( ) ) { double a ; double b ; double c ; if ( Math . abs ( C ) < MINIMUM RESOLUTION ) { if ( Math . abs ( D ) >= MINIMUM RESOLUTION ) { if ( Math . abs ( A ) > Math . abs ( B ) ) { a = B * B * planet Model . inverse Ab Squared + A * A * planet Model . inverse Ab Squared ; b = NUM_ * B * D * planet Model . inverse Ab Squared ; c = D * D * planet Model . inverse Ab Squared - A * A ; double sqrt Clause = b * b - NUM_ * a * c ; if ( Math . abs ( sqrt Clause ) < MINIMUM RESOLUTION SQUARED ) { double y 0 = - b / ( NUM_ * a ) ; double x 0 = ( - D - B * y 0 ) / A ; double z 0 = NUM_ ; add Point ( bounds Info , bounds , new Geo Point ( x 0 , y 0 , z 0 ) ) ; } else if ( sqrt Clause > NUM_ ) { double sqrt Result = Math . sqrt ( sqrt Clause ) ; double denom = NUM_ / ( NUM_ * a ) ; double Hdenom = NUM_ / A ; double y 0 a = ( - b + sqrt Result ) * denom ; double y 0 b = ( - b - sqrt Result ) * denom ; double x 0 a = ( - D - B * y 0 a ) * Hdenom ; double x 0 b = ( - D - B * y 0 b ) * Hdenom ; double z 0 a = NUM_ ; double z 0 b = NUM_ ; add Point ( bounds Info , bounds , new Geo Point ( x 0 a , y 0 a , z 0 a ) ) ; add Point ( bounds Info , bounds , new Geo Point ( x 0 b , y 0 b , z 0 b ) ) ; } } else { a = B * B * planet Model . inverse Ab Squared + A * A * planet Model . inverse Ab Squared ; b = NUM_ * A * D * planet Model . inverse Ab Squared ; c = D * D * planet Model . inverse Ab Squared - B * B ; double sqrt Clause = b * b - NUM_ * a * c ; if ( Math . abs ( sqrt Clause ) < MINIMUM RESOLUTION SQUARED ) { double x 0 = - b / ( NUM_ * a ) ; double y 0 = ( - D - A * x 0 ) / B ; double z 0 = NUM_ ; add Point ( bounds Info , bounds , new Geo Point ( x 0 , y 0 , z 0 ) ) ; } else if ( sqrt Clause > NUM_ ) { double sqrt Result = Math . sqrt ( sqrt Clause ) ; double denom = NUM_ / ( NUM_ * a ) ; double Idenom = NUM_ / B ; double x 0 a = ( - b + sqrt Result ) * denom ; double x 0 b = ( - b - sqrt Result ) * denom ; double y 0 a = ( - D - A * x 0 a ) * Idenom ; double y 0 b = ( - D - A * x 0 b ) * Idenom ; double z 0 a = NUM_ ; double z 0 b = NUM_ ; add Point ( bounds Info , bounds , new Geo Point ( x 0 a , y 0 a , z 0 a ) ) ; add Point ( bounds Info , bounds , new Geo Point ( x 0 b , y 0 b , z 0 b ) ) ; } } } } else { double E = A * A * planet Model . inverse C Squared + C * C * planet Model . inverse Ab Squared ; double F = B * B * planet Model . inverse C Squared + C * C * planet Model . inverse Ab Squared ; double G = NUM_ * A * B * planet Model . inverse C Squared ; double H = NUM_ * A * D * planet Model . inverse C Squared ; double I = NUM_ * B * D * planet Model . inverse C Squared ; double J = D * D * planet Model . inverse C Squared - C * C ; if ( Math . abs ( J ) >= MINIMUM RESOLUTION && J > NUM_ ) { if ( Math . abs ( H ) > Math . abs ( I ) ) { a = E * I * I - G * H * I + F * H * H ; b = NUM_ * E * I * J - NUM_ * G * H * J ; c = NUM_ * E * J * J - J * H * H ; double sqrt Clause = b * b - NUM_ * a * c ; if ( Math . abs ( sqrt Clause ) < MINIMUM RESOLUTION CUBED ) { double y 0 = - b / ( NUM_ * a ) ; double x 0 = ( - NUM_ * J - I * y 0 ) / H ; double z 0 = ( - A * x 0 - B * y 0 - D ) / C ; add Point ( bounds Info , bounds , new Geo Point ( x 0 , y 0 , z 0 ) ) ; } else if ( sqrt Clause > NUM_ ) { double sqrt Result = Math . sqrt ( sqrt Clause ) ; double denom = NUM_ / ( NUM_ * a ) ; double Hdenom = NUM_ / H ; double Cdenom = NUM_ / C ; double y 0 a = ( - b + sqrt Result ) * denom ; double y 0 b = ( - b - sqrt Result ) * denom ; double x 0 a = ( - NUM_ * J - I * y 0 a ) * Hdenom ; double x 0 b = ( - NUM_ * J - I * y 0 b ) * Hdenom ; double z 0 a = ( - A * x 0 a - B * y 0 a - D ) * Cdenom ; double z 0 b = ( - A * x 0 b - B * y 0 b - D ) * Cdenom ; add Point ( bounds Info , bounds , new Geo Point ( x 0 a , y 0 a , z 0 a ) ) ; add Point ( bounds Info , bounds , new Geo Point ( x 0 b , y 0 b , z 0 b ) ) ; } } else { a = E * I * I - G * H * I + F * H * H ; b = NUM_ * F * H * J - NUM_ * G * I * J ; c = NUM_ * F * J * J - J * I * I ; double sqrt Clause = b * b - NUM_ * a * c ; if ( Math . abs ( sqrt Clause ) < MINIMUM RESOLUTION CUBED ) { double x 0 = - b / ( NUM_ * a ) ; double y 0 = ( - NUM_ * J - H * x 0 ) / I ; double z 0 = ( - A * x 0 - B * y 0 - D ) / C ; add Point ( bounds Info , bounds , new Geo Point ( x 0 , y 0 , z 0 ) ) ; } else if ( sqrt Clause > NUM_ ) { double sqrt Result = Math . sqrt ( sqrt Clause ) ; double denom = NUM_ / ( NUM_ * a ) ; double Idenom = NUM_ / I ; double Cdenom = NUM_ / C ; double x 0 a = ( - b + sqrt Result ) * denom ; double x 0 b = ( - b - sqrt Result ) * denom ; double y 0 a = ( - NUM_ * J - H * x 0 a ) * Idenom ; double y 0 b = ( - NUM_ * J - H * x 0 b ) * Idenom ; double z 0 a = ( - A * x 0 a - B * y 0 a - D ) * Cdenom ; double z 0 b = ( - A * x 0 b - B * y 0 b - D ) * Cdenom ; add Point ( bounds Info , bounds , new Geo Point ( x 0 a , y 0 a , z 0 a ) ) ; add Point ( bounds Info , bounds , new Geo Point ( x 0 b , y 0 b , z 0 b ) ) ; } } } } } }
public Builder mime Type Is ( String ... mime Types ) { verify Not Null ( mime Types ) ; expressions . add ( new Event Filter Expression . Mime Type Is ( mime Types ) ) ; return this ; }
@ Suppress Warnings ( STR_ ) @ Override protected boolean is Transaction In Advance Of Installment ( final int current Installment Index , final List < Loan Repayment Schedule Installment > installments , final Local Date transaction Date , final Money transaction Amount ) { final Loan Repayment Schedule Installment current Installment = installments . get ( current Installment Index ) ; return transaction Date . is Before ( current Installment . get Due Date ( ) ) ; }
@ Suppress Warnings ( STR_ ) private static Class wrap ( Class c ) { return c . is Primitive ( ) ? PRIMITIVES TO WRAPPERS . get ( c ) : c ; }
public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { String name = method . get Name ( ) ; if ( method . get Declaring Class ( ) == Groovy Object . class ) { if ( name . equals ( STR_ ) ) { return get Meta Class ( ) ; } else if ( name . equals ( STR_ ) ) { return set Meta Class ( ( Meta Class ) args [ NUM_ ] ) ; } } return Invoker Helper . invoke Method ( extension , method . get Name ( ) , args ) ; }
protected void post Notify Uri ( Uri uri ) { synchronized ( m Changed Uris ) { m Changed Uris . add ( uri ) ; } }
public void assert Same Path Counts ( int [ ] [ ] expected , int [ ] [ ] actual ) { int nrows = expected . length ; int ncols = expected [ NUM_ ] . length ; assert Equals ( STR_ , nrows , actual . length ) ; assert Equals ( STR_ , ncols , actual [ NUM_ ] . length ) ; for ( int i = NUM_ ; i < nrows ; i ++ ) { for ( int j = NUM_ ; j < ncols ; j ++ ) { assert Equals ( STR_ + i + STR_ + j + STR_ , expected [ i ] [ j ] , actual [ i ] [ j ] ) ; } } }
public static boolean is Similar ( final String str 1 , final String str 2 , final double delta ) { if ( ( str 1 == null ) || ( str 2 == null ) ) { return ( str 1 == null ) && ( str 2 == null ) ; } final int len 1 = str 1 . length ( ) ; final int len 2 = str 2 . length ( ) ; if ( ( len 1 == NUM_ ) || ( len 2 == NUM_ ) ) { return len 1 == len 2 ; } final int shorter Length = Math . min ( len 1 , len 2 ) ; final int limit = ( int ) ( ( shorter Length * delta * shorter Length + ( shorter Length - NUM_ ) ) / shorter Length ) ; return compare Levenshtein ( str 1 , str 2 , limit ) ; }
private void compute Responses ( double [ ] incoming Inst , double [ ] incoming Param Vector , double [ ] responses ) throws Exception { for ( int i = NUM_ ; i < responses . length ; i ++ ) { for ( int j = NUM_ ; j < m parameter List . size ( ) ; j ++ ) { P Cell p = m param Matrix [ i ] [ j ] ; if ( p == null ) { responses [ i ] += NUM_ * incoming Param Vector [ j ] ; } else { responses [ i ] += incoming Param Vector [ j ] * p . m beta ; } } } switch ( m model Type ) { case MULTINOMIALLOGISTIC : compute Probabilities Multinomial Logistic ( responses ) ; break ; case REGRESSION : break ; case GENERALLINEAR : case GENERALIZEDLINEAR : if ( m link Function != Link Function . NONE ) { compute Response Generalized Linear ( incoming Inst , responses ) ; } else { throw new Exception ( STR_ ) ; } break ; case ORDINALMULTINOMIAL : if ( m cumulative Link Function != Cumulative Link Function . NONE ) { compute Response Ordinal Multinomial ( incoming Inst , responses ) ; } else { throw new Exception ( STR_ ) ; } break ; default : throw new Exception ( STR_ ) ; } }
public void schedule ( Runnable command , long delay , long tolerance , Time Unit unit ) { if ( delay < NUM_ || tolerance < NUM_ ) { throw new Illegal Argument Exception ( ) ; } long trigger Point = clock . now ( ) + unit . to Millis ( delay ) ; scheduled Tasks . add ( new Scheduled Runnable ( command , trigger Point , unit . to Millis ( tolerance ) ) ) ; if ( signal . compare And Set ( false , true ) ) { selector . wakeup ( ) ; } }
public void register Setting Change Listener ( String key , Setting Change Listener listener ) { String real Key = STR_ + key ; List < Setting Change Listener > list = listeners . get ( real Key ) ; if ( list == null ) { list = new Array List < Setting Change Listener > ( ) ; listeners . put ( real Key , list ) ; } list . add ( listener ) ; }
private static Private Key convert To Sun Impl ( Private Key key ) { PKCS 8 Encoded Key Spec spec = new PKCS 8 Encoded Key Spec ( key . get Encoded ( ) ) ; Key Factory kf ; try { kf = Key Factory . get Instance ( Key Util . RSA ALGORITHM ) ; return kf . generate Private ( spec ) ; } catch ( No Such Algorithm Exception | Invalid Key Spec Exception e ) { e . print Stack Trace ( ) ; } return null ; }
public void add Games To Collection ( List < Game > collection To Add ) { game Collection . add All ( collection To Add ) ; }
protected Rect Tile create Tile ( Sector tile Sector ) { Extent extent = Sector . compute Bounding Box ( this . globe , this . vertical Exaggeration , tile Sector ) ; return new Rect Tile ( extent , this . density , tile Sector ) ; }
protected void writeln ( Object ... strs ) { write ( strs ) ; write ( STR_ ) ; }
J Panel make Top Panel ( J Frame frame , String title , int width , int height ) { Container content Pane = frame . get Content Pane ( ) ; content Pane . set Layout ( new Box Layout ( content Pane , Box Layout . X AXIS ) ) ; content Pane . add ( Box . create Rigid Area ( new Dimension ( NUM_ , height ) ) ) ; J Panel top Panel = new J Panel ( ) ; top Panel . set Layout ( new Box Layout ( top Panel , Box Layout . Y AXIS ) ) ; Border panel Border = Border Factory . create Etched Border ( ) ; Border panel Titled = Border Factory . create Titled Border ( panel Border , rbx . get String ( title ) ) ; top Panel . set Border ( panel Titled ) ; top Panel . add ( Box . create Rigid Area ( new Dimension ( width , NUM_ ) ) ) ; top Panel . add ( Box . create Vertical Glue ( ) ) ; return top Panel ; }
private Criterion apply Restriction ( ) { final Object converted Value = convert Value Type ( search Field , search String ) ; if ( search Oper . equals ( STR_ ) ) return Restrictions . eq ( search Field , converted Value ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . ne ( search Field , converted Value ) ; if ( converted Value instanceof String ) { if ( search Oper . equals ( STR_ ) ) return Restrictions . ilike ( search Field , search String + STR_ ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . ilike ( search Field , STR_ + search String + STR_ ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . ilike ( search Field , STR_ + search String ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . not ( Restrictions . ilike ( search Field , search String + STR_ ) ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . not ( Restrictions . ilike ( search Field , STR_ + search String ) ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . not ( Restrictions . ilike ( search Field , STR_ + search String + STR_ ) ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . in ( search Field , search String . split ( STR_ ) ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . not ( Restrictions . in ( search Field , search String . split ( STR_ ) ) ) ; } else if ( search Oper . equals ( STR_ ) ) return Restrictions . lt ( search Field , converted Value ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . le ( search Field , converted Value ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . gt ( search Field , converted Value ) ; else if ( search Oper . equals ( STR_ ) ) return Restrictions . ge ( search Field , converted Value ) ; return null ; }
public static Matrix radial Gradient Matrix ( Scalable Gradient Node gradient , Rect path Bounds ) { Matrix Node mtx Node = gradient . get Matrix Node ( ) ; if ( mtx Node != null ) { double tx = mtx Node . tx ; double ty = mtx Node . ty ; FXG Matrix fxg Mtx = new FXG Matrix ( mtx Node . a , mtx Node . b , mtx Node . c , mtx Node . d , NUM_ , NUM_ ) ; fxg Mtx . scale ( Swf Constants . TWIPS PER PIXEL / ( float ) Swf Constants . GRADIENT SQUARE , Swf Constants . TWIPS PER PIXEL / ( float ) Swf Constants . GRADIENT SQUARE ) ; fxg Mtx . translate ( tx , ty ) ; return fxg Mtx . to SWF Matrix ( ) ; } double w = ! Double . is Na N ( gradient . get Scale X ( ) ) ? gradient . get Scale X ( ) * Swf Constants . TWIPS PER PIXEL : path Bounds . get Width ( ) ; double h = ! Double . is Na N ( gradient . get Scale Y ( ) ) ? gradient . get Scale Y ( ) * Swf Constants . TWIPS PER PIXEL : path Bounds . get Height ( ) ; double tx = ( ! Double . is Na N ( gradient . get X ( ) ) ? gradient . get X ( ) : ( path Bounds . x Max + path Bounds . x Min ) / ( NUM_ * Swf Constants . TWIPS PER PIXEL ) ) ; double ty = ( ! Double . is Na N ( gradient . get Y ( ) ) ? gradient . get Y ( ) : ( path Bounds . y Max + path Bounds . y Min ) / ( NUM_ * Swf Constants . TWIPS PER PIXEL ) ) ; FXG Matrix matrix = new FXG Matrix ( ) ; matrix . scale ( w / Swf Constants . GRADIENT SQUARE , h / Swf Constants . GRADIENT SQUARE ) ; if ( ! Double . is Na N ( gradient . get Rotation ( ) ) && ( gradient . get Rotation ( ) != NUM_ ) ) matrix . rotate ( gradient . get Rotation ( ) ) ; matrix . translate ( tx , ty ) ; return matrix . to SWF Matrix ( ) ; }
public static boolean verify Signature ( Response saml Response ) { if ( ( saml Response != null ) && ( ! saml Response . is Signed ( ) || ( ! saml Response . is Signature Valid ( ) ) ) ) { return false ; } return true ; }
protected void compute Weights For Pts ( ) { int i ; int s , t ; off graph edge p ; I Var Abstraction node ; pre cnt = NUM_ ; for ( i = NUM_ ; i < n var ; ++ i ) { pre [ i ] = - NUM_ ; count [ i ] = NUM_ ; rep [ i ] = i ; repsize [ i ] = NUM_ ; node = int 2 var . get ( i ) ; node . top value = Integer . MIN VALUE ; } for ( i = NUM_ ; i < n var ; ++ i ) if ( pre [ i ] == - NUM_ ) tarjan scc ( i ) ; for ( i = NUM_ ; i < n var ; ++ i ) { p = var Graph . get ( i ) ; s = find parent ( i ) ; while ( p != null ) { t = find parent ( p . t ) ; if ( t != s ) count [ t ] ++ ; p = p . next ; } } for ( i = NUM_ ; i < n var ; ++ i ) { p = var Graph . get ( i ) ; if ( p != null && rep [ i ] != i ) { t = find parent ( i ) ; while ( p . next != null ) p = p . next ; p . next = var Graph . get ( t ) ; var Graph . set ( t , var Graph . get ( i ) ) ; var Graph . set ( i , null ) ; } } queue . clear ( ) ; for ( i = NUM_ ; i < n var ; ++ i ) if ( rep [ i ] == i && count [ i ] == NUM_ ) queue . add Last ( i ) ; i = NUM_ ; while ( ! queue . is Empty ( ) ) { s = queue . get First ( ) ; queue . remove First ( ) ; node = int 2 var . get ( s ) ; node . top value = i ; i += repsize [ s ] ; p = var Graph . get ( s ) ; while ( p != null ) { t = find parent ( p . t ) ; if ( t != s ) { if ( -- count [ t ] == NUM_ ) queue . add Last ( t ) ; } p = p . next ; } } for ( i = n var - NUM_ ; i > - NUM_ ; -- i ) { if ( rep [ i ] != i ) { node = int 2 var . get ( find parent ( i ) ) ; I Var Abstraction me = int 2 var . get ( i ) ; me . top value = node . top value + repsize [ node . id ] - NUM_ ; -- repsize [ node . id ] ; } } }
@ Override public void run ( ) { am I Active = true ; panel = new Coordinate Transform Dialog ( my Host ) ; if ( my Host instanceof J Frame ) { J Dialog dialog = new J Dialog ( ( J Frame ) my Host , STR_ , false ) ; Container content Pane = dialog . get Content Pane ( ) ; content Pane . add ( panel , Border Layout . CENTER ) ; dialog . set Default Close Operation ( J Frame . DISPOSE ON CLOSE ) ; dialog . pack ( ) ; dialog . set Location Relative To ( null ) ; dialog . set Visible ( true ) ; } else { J Frame frame = new J Frame ( STR_ ) ; Container content Pane = frame . get Content Pane ( ) ; content Pane . add ( panel , Border Layout . CENTER ) ; frame . set Default Close Operation ( J Frame . DISPOSE ON CLOSE ) ; frame . pack ( ) ; frame . set Location Relative To ( null ) ; frame . set Visible ( true ) ; } }
public static String new Name ( Mail mail ) throws Messaging Exception { String old Name = mail . get Name ( ) ; if ( old Name . length ( ) > NUM_ ) { int count = NUM_ ; int index = NUM_ ; while ( ( index = old Name . index Of ( STR_ , index + NUM_ ) ) >= NUM_ ) { count ++ ; } if ( count > NUM_ ) { throw new Messaging Exception ( STR_ + STR_ ) ; } else { old Name = old Name . substring ( NUM_ , NUM_ ) ; } } return old Name + STR_ + random . next Int ( NUM_ ) ; }
public void append Text To File ( File file , String text ) throws IO Exception { try ( Print Writer pw = new Print Writer ( new Output Stream Writer ( new File Output Stream ( file , true ) , Standard Charsets . UTF 8 ) ) ) { pw . println ( text ) ; } }
@ Nullable public static File find Platform Sources ( @ Not Null I Android Target target ) { String path = target . get Path ( I Android Target . SOURCES ) ; if ( path != null ) { File platform Source = new File ( path ) ; if ( platform Source . is Directory ( ) ) { return platform Source ; } } return null ; }
public void dump stack ( ) { if ( stack == null ) { debug message ( STR_ ) ; return ; } debug message ( STR_ ) ; for ( int i = NUM_ ; i < stack . size ( ) ; i ++ ) { debug message ( STR_ + ( ( Symbol ) stack . element At ( i ) ) . sym + STR_ + ( ( Symbol ) stack . element At ( i ) ) . parse state ) ; } debug message ( STR_ ) ; }
@ Suppress Warnings ( STR_ ) private Class validate Class ( Client Config cfg ) { Class clazz = null ; try { clazz = Class . for Name ( cfg . get Access Request Handler Classname ( ) ) ; } catch ( final Class Not Found Exception e ) { LOG . error ( STR_ + cfg . get Access Request Handler Classname ( ) + STR_ + cfg . get Name ( ) + STR_ , e ) ; return null ; } Object inst = null ; try { inst = Injector Holder . get Instance ( clazz ) ; } catch ( Configuration Exception | Provision Exception e ) { LOG . error ( STR_ + cfg . get Access Request Handler Classname ( ) + STR_ + cfg . get Name ( ) + STR_ , e ) ; return null ; } Access Request Handler handler = null ; try { handler = ( Access Request Handler ) inst ; } catch ( final Class Cast Exception e ) { LOG . error ( STR_ + cfg . get Access Request Handler Classname ( ) + STR_ + cfg . get Name ( ) + STR_ , e ) ; return null ; } return clazz ; }
void write ( Image Output Stream ios , JPEG Image Writer writer ) throws IO Exception { write ( ios , null , writer ) ; }
private void compute Values ( ) { logger . debug ( STR_ ) ; Map < N , Set < D > > all Seeds = new Hash Map < N , Set < D > > ( initial Seeds ) ; for ( N unbalanced Ret Site : unbalanced Ret Sites ) { Set < D > seeds = all Seeds . get ( unbalanced Ret Site ) ; if ( seeds == null ) { seeds = new Hash Set < D > ( ) ; all Seeds . put ( unbalanced Ret Site , seeds ) ; } seeds . add ( zero Value ) ; } for ( Entry < N , Set < D > > seed : all Seeds . entry Set ( ) ) { N start Point = seed . get Key ( ) ; for ( D val : seed . get Value ( ) ) { set Val ( start Point , val , value Lattice . bottom Element ( ) ) ; Pair < N , D > super Graph Node = new Pair < N , D > ( start Point , val ) ; schedule Value Processing ( new Value Propagation Task ( super Graph Node ) ) ; } } logger . debug ( STR_ ) ; try { executor . await Completion ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } Set < N > all Non Call Start Nodes = icfg . all Non Call Start Nodes ( ) ; @ Suppress Warnings ( STR_ ) N [ ] non Call Start Nodes Array = ( N [ ] ) new Object [ all Non Call Start Nodes . size ( ) ] ; int i = NUM_ ; for ( N n : all Non Call Start Nodes ) { non Call Start Nodes Array [ i ] = n ; i ++ ; } for ( int t = NUM_ ; t < num Threads ; t ++ ) { Value Computation Task task = new Value Computation Task ( non Call Start Nodes Array , t ) ; schedule Value Computation Task ( task ) ; } try { executor . await Completion ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } }
private void generate ( Class < ? extends Message > cls ) throws Exception { assert cls != null ; if ( cls . is Interface ( ) ) return ; if ( cls . is Annotation Present ( Ignite Code Generating Fail . class ) ) throw new Illegal State Exception ( STR_ + cls . get Name ( ) ) ; write . clear ( ) ; read . clear ( ) ; fields = new Array List < > ( ) ; Field [ ] declared Fields = cls . get Declared Fields ( ) ; for ( Field field : declared Fields ) { int mod = field . get Modifiers ( ) ; if ( ! is Static ( mod ) && ! is Transient ( mod ) && ! field . is Annotation Present ( Grid Direct Transient . class ) ) fields . add ( field ) ; } Collections . sort ( fields , FIELD CMP ) ; int state = start State ( cls ) ; total Field Cnt = state + fields . size ( ) ; indent = NUM_ ; boolean has Super = cls . get Superclass ( ) != Object . class ; start ( write , has Super ? STR_ : null , true ) ; start ( read , has Super ? STR_ : null , false ) ; indent ++ ; for ( Field field : fields ) process Field ( field , state ++ ) ; indent -- ; finish ( write , null ) ; finish ( read , cls . get Simple Name ( ) ) ; }
public void add Session Listener ( Session Listener listener , boolean force ) throws Session Exception { if ( ! force && session State != Session State . VALID ) { throw new Session Exception ( Session Bundle . rb Name , STR_ , null ) ; } local Session Event Listeners . add ( listener ) ; }
public static Date fix Encounter Date Time ( Date datetime ) { Date now = new Date ( ) ; if ( datetime . after ( now ) ) { datetime = now ; } return datetime ; }
public void init ( String component Name ) throws Log Exception { access Logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( component Name + STR_ ) ; error Logger = ( com . sun . identity . log . Logger ) Logger . get Logger ( component Name + STR_ ) ; try { msg Provider = Message Provider Factory . get Provider ( component Name ) ; } catch ( IO Exception e ) { debug . error ( STR_ , e ) ; } }
public void read External ( Object Input in ) throws IO Exception , Class Not Found Exception { id = ( Activation ID ) in . read Object ( ) ; ref = null ; String class Name = in . read UTF ( ) ; if ( class Name . equals ( STR_ ) ) return ; try { Class < ? > ref Class = Class . for Name ( Remote Ref . package Prefix + STR_ + class Name ) ; ref = ( Remote Ref ) ref Class . new Instance ( ) ; ref . read External ( in ) ; } catch ( Instantiation Exception e ) { throw new Unmarshal Exception ( STR_ , e ) ; } catch ( Illegal Access Exception e ) { throw new Unmarshal Exception ( STR_ ) ; } }
public void client Changed ( String client Type , int db Type , int op Type ) { if ( debug . message Enabled ( ) ) { debug . message ( CLASS + STR_ + STR_ + client Type + STR_ + db Type + STR_ + op Type ) ; } if ( ( client Type == null ) || ( client Type . length ( ) == NUM_ ) ) { return ; } if ( op Type == AM Client Cap Data . ADDED ) { if ( db Type == AM Client Cap Data . INTERNAL ) { if ( ! internal Client Data . contains Key ( client Type ) ) { Map i Map = int Cap Instance . load Minimal Client ( client Type ) ; Map o Map = ( Map ) merged Client Data . get ( client Type ) ; Map m Map = merge Map ( o Map , i Map ) ; handle Parent Change ( client Type , m Map ) ; unload Client ( client Type ) ; } } else if ( db Type == AM Client Cap Data . EXTERNAL ) { synchronized ( updated Clients ) { if ( ! external Client Data . contains Key ( client Type ) ) { Map e Map = ext Cap Instance . load Minimal Client ( client Type ) ; Map o Map = ( Map ) merged Client Data . get ( client Type ) ; Map m Map = merge Map ( o Map , e Map ) ; handle Parent Change ( client Type , m Map ) ; unload Client ( client Type ) ; } } } } else if ( op Type == AM Client Cap Data . MODIFIED ) { synchronized ( updated Clients ) { if ( updated Clients . contains ( client Type ) ) { updated Clients . remove ( client Type ) ; } else { Map c Map = ext Cap Instance . load Minimal Client ( client Type ) ; Map o Map = ( Map ) merged Client Data . get ( client Type ) ; Map m Map = merge Map ( o Map , c Map ) ; handle Parent Change ( client Type , m Map ) ; unload Client ( client Type ) ; } } } else if ( op Type == AM Client Cap Data . REMOVED ) { if ( external Client Data . contains Key ( client Type ) ) { remove From Maps ( client Type ) ; } } else { debug . warning ( CLASS + STR_ ) ; } }
public void clone ( Vector 3 f source ) { System . arraycopy ( source . points , NUM_ , points , NUM_ , NUM_ ) ; }
< T > T on Find ( Class < T > model Class , long id , boolean is Eager ) { List < T > data List = query ( model Class , null , STR_ , new String [ ] { String . value Of ( id ) } , null , null , null , null , get Foreign Key Associations ( model Class . get Name ( ) , is Eager ) ) ; if ( data List . size ( ) > NUM_ ) { return data List . get ( NUM_ ) ; } return null ; }
protected boolean click If Matches Description ( Intent intent , String action Name , String extra Name ) { String action = intent . get Action ( ) ; if ( action Name . equals ( action ) ) { String description = intent . get String Extra ( extra Name ) ; if ( m Content Description . equals Ignore Case ( description ) ) { Santa Log . d ( TAG , String . format ( STR_ , action Name , description ) ) ; on Click ( m Click Target ) ; return true ; } } return false ; }
public boolean validate ( Set < String > values ) { if ( values . is Empty ( ) ) { return true ; } Set < String > id Set = new Hash Set < > ( ) ; Set < String > url Set = new Hash Set < > ( ) ; boolean server Lookup = get Server Details ( ) ; for ( String value : values ) { String Tokenizer tok = new String Tokenizer ( value , STR_ ) ; if ( tok . count Tokens ( ) != NUM_ ) { return false ; } String url = tok . next Token ( ) ; String id = tok . next Token ( ) ; int byte Length = id . get Bytes ( ) . length ; if ( byte Length != NUM_ || id Set . contains ( id ) ) { return false ; } else { id Set . add ( id ) ; } if ( url Set . contains ( url ) ) { return false ; } else { url Set . add ( url ) ; } if ( server Lookup ) { if ( server Addr Set . contains ( url ) ) { return false ; } if ( server Id Set . contains ( id ) ) { return false ; } } else { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ ) ; } } } return true ; }
public static Resource Loader create Maven Artifact Loader ( final String name ) throws IO Exception { return create Maven Artifact Loader ( Maven Resolver . create Default Resolver ( ) , name ) ; }
boolean matches ( String string ) throws Jasper Exception { Mark mark = mark ( ) ; int ch = NUM_ ; int i = NUM_ ; do { ch = next Char ( ) ; if ( ( ( char ) ch ) != string . char At ( i ++ ) ) { reset ( mark ) ; return false ; } } while ( i < string . length ( ) ) ; return true ; }
public static byte [ ] generate SHA 1 Hash ( Resource Byte Range Provider resource Byte Range Provider ) throws No Such Algorithm Exception , IO Exception { Message Digest md = Message Digest . get Instance ( STR_ ) ; long range Start = NUM_ ; long range End = ( range Start + NUM_ > resource Byte Range Provider . get Resource Size ( ) - NUM_ ) ? resource Byte Range Provider . get Resource Size ( ) - NUM_ : range Start + NUM_ ; int nread = NUM_ ; while ( range Start < resource Byte Range Provider . get Resource Size ( ) && range End < resource Byte Range Provider . get Resource Size ( ) ) { byte [ ] data Bytes = resource Byte Range Provider . get Byte Range As Bytes ( range Start , range End ) ; nread = ( int ) ( range End - range Start + NUM_ ) ; md . update ( data Bytes , NUM_ , nread ) ; range Start = range End + NUM_ ; range End = ( range Start + NUM_ > resource Byte Range Provider . get Resource Size ( ) - NUM_ ) ? resource Byte Range Provider . get Resource Size ( ) - NUM_ : range Start + NUM_ ; } ; byte [ ] mdbytes = md . digest ( ) ; return Arrays . copy Of ( mdbytes , mdbytes . length ) ; }
public void add Property Change Listener ( final String property Name , final Property Change Listener listener ) { property Change Support . add Property Change Listener ( property Name , listener ) ; }
public static void silent Close Output Stream ( Output Stream os ) { try { if ( os != null ) { os . close ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
public void add Fragment ( Feedback Fragment fragment ) { m Fragments . add ( fragment ) ; }
private void clear Cookie ( String cookie Name ) { String cookie Domain = null ; Set < String > cookie Domain Set = Auth Client Utils . get Cookie Domains For Request ( request ) ; if ( cookie Domain Set . is Empty ( ) ) { cookie = Auth Utils . create Cookie ( cookie Name , LOGOUTCOOKIEVALUE , null ) ; cookie . set Max Age ( NUM_ ) ; response . add Cookie ( cookie ) ; } else { Iterator iter = cookie Domain Set . iterator ( ) ; while ( iter . has Next ( ) ) { cookie Domain = ( String ) iter . next ( ) ; cookie = Auth Utils . create Cookie ( cookie Name , LOGOUTCOOKIEVALUE , cookie Domain ) ; cookie . set Max Age ( NUM_ ) ; response . add Cookie ( cookie ) ; } } }
private static synchronized String format Date As Time ( Date d ) { return format Time In . format ( d ) ; }
@ Override public Connection Protocol new Connection ( Connection Tcp conn Tcp ) { return new Connection Http ( this , conn Tcp , sequence . increment And Get ( ) ) ; }
public Index Segment Plan ( final int m , final long nentries ) { if ( m < Options . MIN BRANCHING FACTOR ) throw new Illegal Argument Exception ( ) ; if ( nentries < NUM_ ) throw new Illegal Argument Exception ( ) ; this . m = m ; this . nentries = nentries ; m 2 = ( m + NUM_ ) / NUM_ ; if ( nentries == NUM_ ) { if ( log . is Info Enabled ( ) ) log . info ( STR_ ) ; nleaves = NUM_ ; height = NUM_ ; num In Leaf = new int [ ] { NUM_ } ; num In Node = new int [ ] [ ] { new int [ ] { NUM_ } } ; num In Level = new long [ ] { NUM_ } ; nnodes = NUM_ ; return ; } nleaves = ( int ) Math . ceil ( ( double ) nentries / ( double ) m ) ; height = get Minimum Height ( m , nleaves ) ; if ( log . is Info Enabled ( ) ) log . info ( STR_ + m + STR_ + nentries + STR_ + nleaves + STR_ + height ) ; num In Leaf = distribute Keys ( m , m 2 , nleaves , nentries ) ; num In Node = new int [ height + NUM_ ] [ ] ; num In Level = new long [ height + NUM_ ] ; long nchildren = nleaves ; int nnodes = NUM_ ; for ( int h = height - NUM_ ; h >= NUM_ ; h -- ) { final long num This Level = ( long ) Math . ceil ( ( double ) nchildren / ( double ) m ) ; num In Level [ h ] = num This Level ; num In Node [ h ] = distribute Children ( m , m 2 , num This Level , nchildren ) ; nchildren = num This Level ; nnodes += num This Level ; } num In Node [ height ] = num In Leaf ; num In Level [ height ] = nleaves ; this . nnodes = nnodes ; }
public synchronized boolean verify And Advance State ( Byte new Step ) { logger . debug ( STR_ , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( new Step ) , Z Wave Security Command Class . command To String ( current Step ) ) ; if ( ! INIT COMMAND ORDER LIST . contains ( new Step ) ) { return true ; } if ( INIT COMMAND ORDER LIST . index Of ( new Step ) > NUM_ ) { int current Index = INIT COMMAND ORDER LIST . index Of ( current Step ) ; int new Index = INIT COMMAND ORDER LIST . index Of ( new Step ) ; if ( new Index != current Index && new Index - current Index > NUM_ ) { if ( HALT ON IMPROPER ORDER ) { set Error State ( String . format ( STR_ , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( current Step ) , Z Wave Security Command Class . command To String ( new Step ) ) ) ; return false ; } else { logger . warn ( STR_ , node . get Node Id ( ) , Z Wave Security Command Class . command To String ( current Step ) , Z Wave Security Command Class . command To String ( new Step ) ) ; } } } current Step = new Step ; return true ; }
private static Element info As Element ( Document doc , Library Info info ) { Element library Element = doc . create Element ( STR_ ) ; library Element . set Attribute ( STR_ , info . get Version ( ) ) ; append Path Elements ( doc , STR_ , library Element , info . get Bootpath ( ) ) ; append Path Elements ( doc , STR_ , library Element , info . get Extension Dirs ( ) ) ; append Path Elements ( doc , STR_ , library Element , info . get Endorsed Dirs ( ) ) ; return library Element ; }
protected String do Mount Obb no Throw ( String obb File Path , String key , int expected State ) { Log . i ( LOG TAG , STR_ + obb File Path + STR_ + key ) ; assert True ( STR_ , obb File Path != null ) ; assert True ( STR_ , obb File Path != null ) ; Obb Listener obb Listener = new Obb Listener ( ) ; boolean success = m Sm . mount Obb ( obb File Path , key , obb Listener ) ; success &= obb File Path . equals ( do Wait For Obb State Change ( obb Listener ) ) ; success &= ( expected State == obb Listener . state ( ) ) ; if ( On Obb State Change Listener . MOUNTED == expected State ) { success &= obb File Path . equals ( obb Listener . official Path ( ) ) ; success &= m Sm . is Obb Mounted ( obb Listener . official Path ( ) ) ; } else { success &= ! m Sm . is Obb Mounted ( obb Listener . official Path ( ) ) ; } if ( success ) { return obb Listener . official Path ( ) ; } else { return null ; } }
public void register Preference Change Listener ( Preference Change Listener preference Change Listener ) { if ( ! m Listeners . contains ( preference Change Listener ) ) { m Listeners . add ( preference Change Listener ) ; } }
protected static void append Boolean Type ( String Builder sb ) { sb . append ( STR_ ) ; }
ASCII Bits clear ( String chars ) { for ( int i = NUM_ , n = chars . length ( ) ; i < n ; ++ i ) { char ch = chars . char At ( i ) ; if ( ch < NUM_ ) { lower Mask &= ~ ( NUM_ << ch ) ; } else { upper Mask &= ~ ( NUM_ << ch ) ; } } return this ; }
public Message Saver ( Message Factory message Factory , File save Dir , Type ... types ) throws File Not Found Exception { if ( ! save Dir . exists ( ) ) { throw new File Not Found Exception ( save Dir . get Name ( ) ) ; } this . message Factory = message Factory ; this . save Dir = save Dir ; this . types = new Hash Set < > ( Arrays . as List ( types ) ) ; }
public void add Event Listeners ( M Bean Server server , Map < String , Map < String , Object > > descriptor ) { for ( Map . Entry < String , Map < String , Object > > item : descriptor . entry Set ( ) ) { Map < String , Object > listener = item . get Value ( ) ; Object Name broadcaster = ( Object Name ) listener . get ( STR_ ) ; try { String event Type = ( String ) listener . get ( STR_ ) ; if ( event Type != null ) { Notification Filter Support filter = new Notification Filter Support ( ) ; filter . enable Type ( event Type ) ; server . add Notification Listener ( broadcaster , Jmx Event Listener . get Listener ( ) , filter , listener ) ; } else { server . add Notification Listener ( broadcaster , Jmx Event Listener . get Listener ( ) , null , listener ) ; } } catch ( Instance Not Found Exception e ) { throw new Jmx Builder Exception ( e ) ; } } }
private Icon create Arrow Icon ( boolean etched ) { Buffered Image image = new Buffered Image ( NUM_ , NUM_ , Buffered Image . TYPE INT ARGB ) ; Graphics 2 D g = image . create Graphics ( ) ; Color high Light , shadow ; Style style = Style Util . get Style ( ) ; if ( style != null ) { high Light = style . get High Light Color ( ) ; shadow = style . get Shadow Color ( ) ; } else { high Light = Color . WHITE ; shadow = Color . BLACK ; } Color nw Color , se Color ; if ( etched ) { nw Color = shadow ; se Color = high Light ; } else { nw Color = high Light ; se Color = shadow ; } g . set Color ( nw Color ) ; g . draw Polyline ( new int [ ] { NUM_ , NUM_ , NUM_ } , new int [ ] { NUM_ , NUM_ , NUM_ } , NUM_ ) ; g . set Color ( se Color ) ; g . draw Line ( NUM_ , NUM_ , NUM_ , NUM_ ) ; g . dispose ( ) ; return new Image Icon ( image ) ; }
public Complex [ ] solve All ( Complex coefficients [ ] , Complex initial ) throws Math Illegal Argument Exception , Null Argument Exception , Math Illegal State Exception { if ( coefficients == null ) { throw new Null Argument Exception ( ) ; } final int n = coefficients . length - NUM_ ; if ( n == NUM_ ) { throw new Math Illegal Argument Exception ( Localized Core Formats . POLYNOMIAL ) ; } final Complex c [ ] = new Complex [ n + NUM_ ] ; for ( int i = NUM_ ; i <= n ; i ++ ) { c [ i ] = coefficients [ i ] ; } final Complex root [ ] = new Complex [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { final Complex subarray [ ] = new Complex [ n - i + NUM_ ] ; System . arraycopy ( c , NUM_ , subarray , NUM_ , subarray . length ) ; root [ i ] = solve ( subarray , initial ) ; Complex newc = c [ n - i ] ; Complex oldc = null ; for ( int j = n - i - NUM_ ; j >= NUM_ ; j -- ) { oldc = c [ j ] ; c [ j ] = newc ; newc = oldc . add ( newc . multiply ( root [ i ] ) ) ; } } return root ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Line Needle ) ) { return false ; } return super . equals ( obj ) ; }
public void substitute For All ( Vector exprs , Vector strs ) throws TLA Expr Exception { substitute For All ( exprs , strs , true ) ; }
public Scripts Publisher ( ) { super ( ) ; }
public void init ( ) { if ( init Depth . get ( ) == null ) { init Depth . set ( NUM_ ) ; } else { init Depth . set ( init Depth . get ( ) + NUM_ ) ; } if ( resource Cache . get ( ) == null ) { resource Cache . set ( new Hash Map < String , Object > ( ) ) ; } if ( cache Locked . get ( ) == null ) { cache Locked . set ( Boolean . FALSE ) ; } }
public void add Dom Child ( Ssa Basic Block child ) { dom Children . add ( child ) ; }
protected int lookup Category ( int c ) { if ( c < Character . MIN SUPPLEMENTARY CODE POINT ) { return char Category Table . element At ( ( char ) c ) ; } else { return supplementary Char Category Table . get Value ( c ) ; } }
public static void write Attribute ( final XML Stream Writer writer , final String attribute Name , final String [ ] value ) throws XML Stream Exception { if ( value == null || value . length == NUM_ ) { return ; } for ( int i = NUM_ ; i < value . length ; i ++ ) { writer . write Attribute ( attribute Name , value [ i ] ) ; } }
public Iterator enumerate Literal Result Attributes ( ) { return ( null == m avts ) ? null : m avts . iterator ( ) ; }
private double round ( double value , int places ) { if ( places < NUM_ ) throw new Illegal Argument Exception ( ) ; long factor = ( long ) Math . pow ( NUM_ , places ) ; value = value * factor ; long tmp = Math . round ( value ) ; return ( double ) tmp / factor ; }
public void substitute Info Text ( int state , int callback , String info Text ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + state + STR_ + info Text ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STR_ , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( ext . length <= NUM_ ) { throw new Auth Login Exception ( bundle Name , STR_ , null ) ; } if ( ( info Text != null ) && ( info Text . length ( ) != NUM_ ) ) { Page Properties Callback page Properties Callback = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM_ ) ) [ NUM_ ] ; List < String > info Texts = page Properties Callback . get Info Text ( ) ; info Texts . set ( callback , info Text ) ; page Properties Callback . set Info Text ( info Texts ) ; } }
private void add User Token ( Map < String , Set < String > > user Linkto Token Map , String user Service Link , String token ) { Set < String > token Set = user Linkto Token Map . get ( user Service Link ) ; if ( token Set == null ) { token Set = new Hash Set < String > ( ) ; } token Set . add ( token ) ; user Linkto Token Map . put ( user Service Link , token Set ) ; }
public static void un Register Client App ( Context context , API Result Call Back api Call Back ) throws Android Agent Exception { String server IP = Constants . DEFAULT HOST ; String pref IP = Preference . get String ( context . get Application Context ( ) , Constants . Preference Flag . IP ) ; if ( pref IP != null ) { server IP = pref IP ; } if ( server IP != null && ! server IP . is Empty ( ) ) { String application Name = Preference . get String ( context , Constants . CLIENT NAME ) ; String consumer Key = Preference . get String ( context , Constants . CLIENT ID ) ; String user Id = Preference . get String ( context , Constants . USERNAME ) ; if ( application Name != null && ! application Name . is Empty ( ) && consumer Key != null && ! consumer Key . is Empty ( ) && user Id != null && ! user Id . is Empty ( ) ) { Unregister Profile profile = new Unregister Profile ( ) ; profile . set Application Name ( application Name ) ; profile . set Consumer Key ( consumer Key ) ; profile . set User Id ( user Id ) ; Server Config utils = new Server Config ( ) ; utils . set Server IP ( server IP ) ; Dynamic Client Manager dynamic Client Manager = new Dynamic Client Manager ( ) ; boolean is Unregistered = dynamic Client Manager . unregister Client ( profile , utils , context , api Call Back ) ; if ( ! is Unregistered ) { Log . e ( TAG , STR_ ) ; } } else { Log . e ( TAG , STR_ ) ; } } else { Log . e ( TAG , STR_ ) ; } }
private boolean are Method Modified Compatibile ( J Diff Method api Method , Method reflected Method ) { if ( ( ( api Method . m Modifier & Modifier . SYNCHRONIZED ) == NUM_ ) && ( ( reflected Method . get Modifiers ( ) & Modifier . SYNCHRONIZED ) != NUM_ ) ) { return false ; } int mod 1 = reflected Method . get Modifiers ( ) & ~ ( Modifier . NATIVE | Modifier . SYNCHRONIZED ) ; int mod 2 = api Method . m Modifier & ~ ( Modifier . NATIVE | Modifier . SYNCHRONIZED ) ; if ( ( m Modifier & Modifier . FINAL ) != NUM_ ) { mod 1 &= ~ Modifier . FINAL ; mod 2 &= ~ Modifier . FINAL ; } return mod 1 == mod 2 ; }
protected Shape create Arc Shape ( double x , double y , double fwidth , double fheight ) { return new Arc 2 D . Double ( x , y , fwidth , fheight , start , extent , arc Type ) ; }
private String [ ] read ( String value , String token ) { String [ ] list = pattern . split ( value ) ; for ( int i = NUM_ ; i < list . length ; i ++ ) { String text = list [ i ] ; if ( text != null ) { list [ i ] = text . trim ( ) ; } } return list ; }
public static void register ( Config config ) { c Thread Local . set ( config ) ; }
public static String newick ( Tree tree ) { String Buffer buffer = new String Buffer ( ) ; newick ( tree , tree . get Root ( ) , true , Branch Length Type . LENGTHS AS TIME , null , null , null , null , buffer ) ; buffer . append ( STR_ ) ; return buffer . to String ( ) ; }
public void purge ( boolean recursive , int graceperiod ) throws AM Exception , SSO Exception { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + entry DN + STR_ + recursive + STR_ + graceperiod ) ; } if ( entry DN . equals ( AM Store Connection . default Org ) ) { throw new AM Exception ( AMSDK Bundle . get String ( STR_ , locale ) , STR_ ) ; } if ( ( graceperiod > - NUM_ ) && ( graceperiod > AM Store Connection . days Since Modified ( token , entry DN ) ) ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + entry DN + STR_ + graceperiod + STR_ ) ; } throw new AM Exception ( AMSDK Bundle . get String ( STR_ , locale ) , STR_ ) ; } if ( ( profile Type == GROUP ) || ( profile Type == DYNAMIC GROUP ) || ( profile Type == ASSIGNABLE DYNAMIC GROUP ) || ( profile Type == PEOPLE CONTAINER ) ) { try { remove Admin Role Aci ( recursive ) ; } catch ( Exception e ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + e ) ; } } try { ds Services . remove Admin Role ( token , entry DN , recursive ) ; } catch ( Exception e ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + e . get Message ( ) ) ; } } } Set aci List = null ; Set template D Ns = null ; if ( ( profile Type == ROLE ) || ( profile Type == FILTERED ROLE ) ) { aci List = find Removable Aci List ( get Attribute ( STR_ ) ) ; String filter = STR_ + entry DN + STR_ ; template D Ns = ds Services . search ( token , get Organization DN ( ) , filter , AM Constants . SCOPE SUB ) ; } ds Services . remove Entry ( token , entry DN , profile Type , recursive , false ) ; if ( aci List != null ) { remove Aci ( aci List ) ; } if ( ( template D Ns != null ) && ! template D Ns . is Empty ( ) ) { Iterator iter = template D Ns . iterator ( ) ; while ( iter . has Next ( ) ) { String template DN = ( String ) iter . next ( ) ; ds Services . remove Entry ( token , template DN , AM Object . TEMPLATE , recursive , false ) ; } } string Value Mod Map . clear ( ) ; if ( ! byte Value Mod Map . is Empty ( ) ) { byte Value Mod Map . clear ( ) ; } }
public void reset Stats ( ) { if ( lock . try Lock ( ) ) { try { ensure Initialized ( ) ; update Stats ( ) ; } finally { lock . unlock ( ) ; } } }
public static void require Wrapper ( Writer writer , Module mod ) throws IO Exception { writer . write ( STR_ + Js Compiler . script Path ( mod ) + STR_ ) ; }
@ Override public String generate Tool Tip ( XY Dataset dataset , int series , int item ) { return generate Label String ( dataset , series , item ) ; }
protected void layout Minor Axis ( int target Span , int axis , int [ ] offsets , int [ ] spans ) { super . layout Minor Axis ( target Span , axis , offsets , spans ) ; int col = NUM_ ; int ncells = get View Count ( ) ; for ( int cell = NUM_ ; cell < ncells ; cell ++ , col ++ ) { View cv = get View ( cell ) ; for ( ; is Filled ( col ) ; col ++ ) ; int col Span = get Columns Occupied ( cv ) ; int row Span = get Rows Occupied ( cv ) ; if ( row Span > NUM_ ) { int row 0 = row Index ; int row 1 = Math . min ( row Index + row Span - NUM_ , get Row Count ( ) - NUM_ ) ; spans [ cell ] = get Multi Row Span ( row 0 , row 1 ) ; } if ( col Span > NUM_ ) { col += col Span - NUM_ ; } } }
public int update Note ( Note note ) { SQ Lite Database db = get Writable Database ( ) ; String spannable As Html = Html . to Html ( note . get Spannable ( ) ) ; String date = dt . format ( new Date ( ) ) ; Content Values values = new Content Values ( ) ; values . put ( KEY IMAGE , Bitmap Converter . get Bytes ( note . get Image ( ) ) ) ; values . put ( KEY DATE UPDATED , date ) ; values . put ( KEY SPANNABLE NOTE , spannable As Html ) ; values . put ( KEY NOTE TITLE , note . get Title ( ) ) ; return db . update ( TABLE NOTES , values , KEY ID + STR_ , new String [ ] { String . value Of ( note . get Id ( ) ) } ) ; }
private void log ( Task Id task Id , Notification Level notification Level , String message , boolean completed , Throwable exception ) { notifier . notify ( task Id , notification Level , message , completed ) ; switch ( notification Level ) { case INFO : log . info ( message ) ; break ; case WARN : log . warn ( message , exception ) ; break ; case ERROR : log . error ( message , exception ) ; break ; } }
protected Point 2 D calculate Range Marker Text Anchor Point ( Graphics 2 D g 2 , Plot Orientation orientation , Rectangle 2 D data Area , Rectangle 2 D marker Area , Rectangle Insets marker Offset , Length Adjustment Type label Offset Type , Rectangle Anchor anchor ) { Rectangle 2 D anchor Rect = null ; if ( orientation == Plot Orientation . HORIZONTAL ) { anchor Rect = marker Offset . create Adjusted Rectangle ( marker Area , label Offset Type , Length Adjustment Type . CONTRACT ) ; } else if ( orientation == Plot Orientation . VERTICAL ) { anchor Rect = marker Offset . create Adjusted Rectangle ( marker Area , Length Adjustment Type . CONTRACT , label Offset Type ) ; } return Rectangle Anchor . coordinates ( anchor Rect , anchor ) ; }
public static byte [ ] hmac sha 1 ( byte [ ] key Bytes , byte [ ] text ) throws No Such Algorithm Exception , Invalid Key Exception { Mac hmac Sha 1 ; try { hmac Sha 1 = Mac . get Instance ( STR_ ) ; } catch ( No Such Algorithm Exception nsae ) { hmac Sha 1 = Mac . get Instance ( STR_ ) ; } Secret Key Spec mac Key = new Secret Key Spec ( key Bytes , STR_ ) ; hmac Sha 1 . init ( mac Key ) ; return hmac Sha 1 . do Final ( text ) ; }
public static long jenkins ( final Bit Vector bv , final long prefix Length , final long [ ] aa , final long bb [ ] , final long cc [ ] ) { if ( prefix Length == NUM_ ) return aa [ NUM_ ] ^ NUM_ ; int state Offset = ( int ) ( prefix Length / ( NUM_ * Long . SIZE ) ) ; long from = ( state Offset * NUM_ ) * Long . SIZE ; long a = aa [ state Offset ] ; long b = bb [ state Offset ] ; long c = cc [ state Offset ] ; if ( prefix Length - from > Long . SIZE * NUM_ ) { a += bv . get Long ( from , from + Long . SIZE ) ; b += bv . get Long ( from + Long . SIZE , from + NUM_ * Long . SIZE ) ; c += bv . get Long ( from + NUM_ * Long . SIZE , Math . min ( from + NUM_ * Long . SIZE , prefix Length ) ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; from += NUM_ * Long . SIZE ; } c += prefix Length ; long residual = prefix Length - from ; if ( residual > NUM_ ) { if ( residual > Long . SIZE ) { a += bv . get Long ( from , from + Long . SIZE ) ; residual -= Long . SIZE ; } if ( residual != NUM_ ) b += bv . get Long ( prefix Length - residual , prefix Length ) ; } a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; return c ; }
public String tree To File Position String ( Tree tree , Compilation Unit Tree current Root , Processing Environment processing Env ) { if ( tree == null ) { return null ; } Source Positions source Positions = trees . get Source Positions ( ) ; long start = source Positions . get Start Position ( current Root , tree ) ; long end = source Positions . get End Position ( current Root , tree ) ; return STR_ + start + STR_ + end + STR_ ; }
private void add Collection Item Clause ( Query Task . Query . Builder builder , String field Name , Resource Constraint constraint ) { List < String > values = constraint . get Values ( ) ; boolean is Negative = false ; if ( constraint . is Set Negative ( ) && constraint . is Negative ( ) ) { is Negative = true ; } Query Task . Query . Occurance occurance = is Negative ? Query Task . Query . Occurance . MUST NOT OCCUR : Query Task . Query . Occurance . MUST OCCUR ; if ( values == null || values . size ( ) == NUM_ ) { return ; } if ( values . size ( ) == NUM_ ) { builder . add Collection Item Clause ( field Name , values . get ( NUM_ ) , occurance ) ; return ; } builder . add In Collection Item Clause ( field Name , values , occurance ) ; }
protected long write Data To File ( Node Holder node Holder , File Channel channel ) throws Carbon Data Writer Exception { byte [ ] [ ] compressed Index = node Holder . get Compressed Index ( ) ; byte [ ] [ ] compressed Index Map = node Holder . get Compressed Index Map ( ) ; byte [ ] [ ] compressed Data Index = node Holder . get Compressed Data Index ( ) ; int index Block Size = NUM_ ; int index = NUM_ ; for ( int i = NUM_ ; i < node Holder . get Key Block Index Length ( ) . length ; i ++ ) { index Block Size += node Holder . get Key Block Index Length ( ) [ index ++ ] + Carbon Common Constants . INT SIZE IN BYTE ; } for ( int i = NUM_ ; i < node Holder . get Data Index Map Length ( ) . length ; i ++ ) { index Block Size += node Holder . get Data Index Map Length ( ) [ i ] ; } Byte Buffer byte Buffer = Byte Buffer . allocate ( node Holder . get Key Array ( ) . length + node Holder . get Data Array ( ) . length + index Block Size ) ; long offset = NUM_ ; try { offset = channel . size ( ) ; byte Buffer . put ( node Holder . get Key Array ( ) ) ; byte Buffer . put ( node Holder . get Data Array ( ) ) ; Byte Buffer buffer 1 = null ; for ( int i = NUM_ ; i < compressed Index . length ; i ++ ) { buffer 1 = Byte Buffer . allocate ( node Holder . get Key Block Index Length ( ) [ i ] ) ; buffer 1 . put Int ( compressed Index [ i ] . length ) ; buffer 1 . put ( compressed Index [ i ] ) ; if ( compressed Index Map [ i ] . length > NUM_ ) { buffer 1 . put ( compressed Index Map [ i ] ) ; } buffer 1 . rewind ( ) ; byte Buffer . put ( buffer 1 . array ( ) ) ; } for ( int i = NUM_ ; i < compressed Data Index . length ; i ++ ) { byte Buffer . put ( compressed Data Index [ i ] ) ; } byte Buffer . flip ( ) ; channel . write ( byte Buffer ) ; } catch ( IO Exception exception ) { throw new Carbon Data Writer Exception ( STR_ , exception ) ; } return offset ; }
@ Api Operation ( value = STR_ ) @ Request Mapping ( value = STR_ , method = Request Method . PUT ) @ Response Status ( Http Status . NO CONTENT ) @ Response Body public final void put Heartbeat ( @ Path Variable ( STR_ ) String engine Name , @ Api Param ( value = STR_ ) @ Request Param ( value = Web Constants . SECURITY TOKEN ) String security Token , @ Request Body Heartbeat heartbeat ) { I Symmetric Engine engine = get Symmetric Engine ( engine Name ) ; if ( security Verified ( heartbeat . get Node Id ( ) , engine , security Token ) ) { heartbeat Impl ( engine , heartbeat ) ; } else { throw new Not Allowed Exception ( ) ; } }
public static void zip Directory ( File dir , File zipfile ) throws IO Exception , Illegal Argument Exception { String [ ] entries = dir . list ( ) ; byte [ ] buffer = new byte [ NUM_ ] ; int bytes Read ; Zip Output Stream out = new Zip Output Stream ( new File Output Stream ( zipfile ) ) ; for ( int i = NUM_ ; i < entries . length ; i ++ ) { File f = new File ( dir , entries [ i ] ) ; if ( f . is Directory ( ) ) continue ; File Input Stream in = new File Input Stream ( f ) ; Zip Entry entry = new Zip Entry ( f . get Path ( ) ) ; out . put Next Entry ( entry ) ; while ( ( bytes Read = in . read ( buffer ) ) != - NUM_ ) out . write ( buffer , NUM_ , bytes Read ) ; in . close ( ) ; } out . close ( ) ; }
public Incomplete Annotation Exception ( Class < ? extends Annotation > annotation Type , String element Name ) { super ( annotation Type . get Name ( ) + STR_ + element Name . to String ( ) ) ; this . annotation Type = annotation Type ; this . element Name = element Name ; }
public static boolean check File Name ( String name ) { if ( name . contains ( STR_ ) || name . contains ( STR_ ) || name . contains ( STR_ ) || name . contains ( STR_ ) || name . contains ( STR_ ) || name . contains ( STR_ ) || name . contains ( STR_ ) || name . contains ( STR_ ) || name . contains ( STR_ ) || name . contains ( STR_ ) ) { return false ; } return true ; }
static void create Property List ( Class node Class , List property List ) { property List . add ( node Class ) ; }
private static int lower Case Hash Code ( String str ) { int len = str . length ( ) ; int h = NUM_ ; for ( int i = NUM_ ; i < len ; i ++ ) { int c = str . char At ( i ) ; c = c <= MAX LOWER CASE CHAR ? LOWER CASE CHARS [ c ] : Character . to Lower Case ( c ) ; h = NUM_ * h + c ; } return h ; }
public void save Model ( String file Name ) throws IO Exception { logger . info ( STR_ , file Name ) ; num Featuer Bit = SL Parameters . HASHING MASK ; Object Output Stream oos = new Object Output Stream ( new Buffered Output Stream ( new File Output Stream ( file Name ) ) ) ; oos . write Object ( this ) ; oos . close ( ) ; logger . info ( STR_ ) ; }
private Workflow . Method create Set CG Properties Method ( URI vplex URI , URI cg URI , List < URI > vplex Volume UR Is ) { return new Workflow . Method ( SET CG PROPERTIES METHOD NAME , vplex URI , cg URI , vplex Volume UR Is ) ; }
public boolean add Edge ( Edge e ) { if ( ! edges . add ( e ) ) return false ; stream . add ( e ) ; Edge position = null ; position = src Unit To Edge . get ( e . src Unit ( ) ) ; if ( position == null ) { src Unit To Edge . put ( e . src Unit ( ) , e ) ; position = dummy ; } e . insert After By Unit ( position ) ; position = src Method To Edge . get ( e . get Src ( ) ) ; if ( position == null ) { src Method To Edge . put ( e . get Src ( ) , e ) ; position = dummy ; } e . insert After By Src ( position ) ; position = tgt To Edge . get ( e . get Tgt ( ) ) ; if ( position == null ) { tgt To Edge . put ( e . get Tgt ( ) , e ) ; position = dummy ; } e . insert After By Tgt ( position ) ; return true ; }
public Resuming Client Handshaker ( DTLS Session session , Record Layer record Layer , Session Listener session Listener , Dtls Connector Config config , int max Transmission Unit ) { super ( session , record Layer , session Listener , config , max Transmission Unit ) ; if ( session . get Session Identifier ( ) == null ) { throw new Illegal Argument Exception ( STR_ ) ; } }
public static Object [ ] assert Thread Id To Sequence Id Map Has Entry Ids ( ) { Event ID [ ] evids = new Event ID [ NUM_ ] ; Map map = pool . get Thread Id To Sequence Id Map ( ) ; assert Not Null ( map ) ; evids [ NUM_ ] = put Allevent Id 1 ; evids [ NUM_ ] = put Allevent Id 2 ; evids [ NUM_ ] = put Allevent Id 3 ; evids [ NUM_ ] = put Allevent Id 4 ; evids [ NUM_ ] = put Allevent Id 5 ; assert Not Null ( evids [ NUM_ ] ) ; assert Not Null ( evids [ NUM_ ] ) ; assert Not Null ( evids [ NUM_ ] ) ; assert Not Null ( evids [ NUM_ ] ) ; assert Not Null ( evids [ NUM_ ] ) ; return evids ; }
public Driver Task create Consistency Group Clone ( Volume Consistency Group consistency Group , List < Volume Clone > clones , List < Capability Instance > capabilities , Driver Task task , Registry driver Registry ) { log . info ( STR_ , consistency Group . get Storage System Id ( ) , consistency Group . get Display Name ( ) , consistency Group . get Native Id ( ) ) ; String V Vset Name For Clone = consistency Group . get Display Name ( ) ; Volume Details Command Result vol Result = null ; Hash Map < String , Volume Clone > clones Map = new Hash Map < String , Volume Clone > ( ) ; try { Boolean save Snapshot = true ; HP 3 PAR Api hp 3 par Api = hp 3 par Util . get HP 3 PAR Device From Native Id ( consistency Group . get Storage System Id ( ) , driver Registry ) ; for ( Volume Clone clone : clones ) { log . info ( STR_ , clone . get Parent Id ( ) , clone . get Display Name ( ) ) ; String generated Clone Name = clone . get Display Name ( ) ; V Vset Name For Clone = generated Clone Name . substring ( NUM_ , generated Clone Name . last Index Of ( STR_ ) ) ; log . info ( STR_ , V Vset Name For Clone ) ; clones Map . put ( clone . get Parent Id ( ) , clone ) ; } log . info ( STR_ , clones Map . to String ( ) ) ; VV Set Volume Clone [ ] result = hp 3 par Api . create V Vset Physical Copy ( consistency Group . get Native Id ( ) , V Vset Name For Clone , clones , save Snapshot ) ; log . info ( STR_ , result . to String ( ) ) ; for ( VV Set Volume Clone clone Created : result ) { Volume Clone clone = clones Map . get ( clone Created . get Parent ( ) ) ; log . info ( STR_ , clone Created . get Values ( ) , clone . get Native Id ( ) , clone . get Parent Id ( ) ) ; vol Result = hp 3 par Api . get Volume Details ( clone Created . get Child ( ) ) ; log . info ( STR_ , vol Result . get All Values ( ) ) ; clone . set Wwn ( vol Result . get Wwn ( ) ) ; clone . set Native Id ( vol Result . get Id ( ) ) ; clone . set Device Label ( vol Result . get Name ( ) ) ; clone . set Display Name ( vol Result . get Name ( ) ) ; clone . set Replication State ( Volume Clone . Replication State . SYNCHRONIZED ) ; clone . set Provisioned Capacity ( clone . get Requested Capacity ( ) ) ; clone . set Allocated Capacity ( clone . get Requested Capacity ( ) ) ; } task . set Status ( Driver Task . Task Status . READY ) ; log . info ( STR_ , consistency Group . get Storage System Id ( ) , consistency Group . get Display Name ( ) , consistency Group . get Native Id ( ) ) ; } catch ( Exception e ) { String msg = String . format ( STR_ , V Vset Name For Clone , consistency Group . get Native Id ( ) , consistency Group . get Storage System Id ( ) , e . get Message ( ) ) ; log . error ( msg ) ; task . set Message ( msg ) ; task . set Status ( Driver Task . Task Status . PARTIALLY FAILED ) ; e . print Stack Trace ( ) ; } return task ; }
public static Document create Document ( boolean is Secure Processing ) { try { Document Builder Factory dfactory = Document Builder Factory . new Instance ( ) ; dfactory . set Namespace Aware ( true ) ; Document Builder doc Builder = dfactory . new Document Builder ( ) ; Document out Node = doc Builder . new Document ( ) ; return out Node ; } catch ( Parser Configuration Exception pce ) { throw new Runtime Exception ( XML Messages . create XML Message ( XML Error Resources . ER CREATEDOCUMENT NOT SUPPORTED , null ) ) ; } }
public void current Task Session ( Compute Task Session ses ) { curr Sess . set ( ses ) ; }
public void update Geometry ( int row , Geometry geometry ) { set Value At ( geometry , row , get Geometry Field Index ( ) ) ; }
public boolean exists ( final String follower Id , final String following Id ) throws Repository Exception { return null != get By Follower Id And Following Id ( follower Id , following Id ) ; }
public void add Membership Listener ( Membership Listener listener ) { membership Listeners . put If Absent ( listener , Boolean . TRUE ) ; }
static boolean is Latin Letter ( char letter ) { if ( ! Character . is Letter ( letter ) && Character . get Type ( letter ) != Character . NON SPACING MARK ) { return false ; } Unicode Block block = Unicode Block . of ( letter ) ; return block . equals ( Unicode Block . BASIC LATIN ) || block . equals ( Unicode Block . LATIN 1 SUPPLEMENT ) || block . equals ( Unicode Block . LATIN EXTENDED A ) || block . equals ( Unicode Block . LATIN EXTENDED ADDITIONAL ) || block . equals ( Unicode Block . LATIN EXTENDED B ) || block . equals ( Unicode Block . COMBINING DIACRITICAL MARKS ) ; }
public static float screen To Scroll ( float x , float warp Size ) { if ( x <= NUM_ ) return NUM_ ; if ( x >= warp Size ) return x + warp Size ; return ( float ) Math . sqrt ( x * warp Size ) * NUM_ ; }
public boolean must Refresh ( ) { try { if ( current Snapshot == null || source File . count Files ( ) != current Snapshot . size ( ) ) return true ; if ( current Open File != null ) { if ( ! Files . exists ( current Open File . get Path ( ) ) ) { LOGGER . debug ( STR_ , current Open File . get Path ( ) ) ; return true ; } Basic File Attributes new Attr = Files . read Attributes ( current Open File . get Path ( ) , Basic File Attributes . class ) ; File Id new Id = File Id . get ( new Attr ) ; if ( ! new Id . equals ( current Open File . get Id ( ) ) ) { LOGGER . debug ( STR_ , current Open File . get Path ( ) , current Open File . get Id ( ) , new Id ) ; return true ; } if ( new Attr . size ( ) < current Open File . get Size ( ) ) { LOGGER . debug ( STR_ , current Open File . get Path ( ) , current Open File . get Size ( ) , new Attr . size ( ) ) ; return true ; } } } catch ( IO Exception e ) { LOGGER . error ( STR_ , e ) ; return true ; } return false ; }
private boolean update Ui For Key ( String config Key , Data Map config ) { if ( config Key . equals ( B Reel Watch Face Util . KEY HOUR FORMAT TYPE ) ) { String twenty Four Switch String = config . get String ( B Reel Watch Face Util . KEY HOUR FORMAT TYPE ) ; Log . d ( TAG , STR_ + twenty Four Switch String ) ; set Is 24 hours ( Boolean . parse Boolean ( twenty Four Switch String ) ) ; return true ; } else { return false ; } }
public static Optional < String > validate Canal ( final Territory territory , final Route route , final Collection < Unit > units , final Player ID player , final Game Data data ) { Optional < String > failure Message = Optional . empty ( ) ; final Set < Canal Attachment > canal Attachments = Canal Attachment . get ( territory ) ; for ( final Canal Attachment canal Attachment : canal Attachments ) { if ( ! is Canal On Route ( canal Attachment , route , data ) ) { continue ; } failure Message = can Pass Through Canal ( canal Attachment , units , player , data ) ; final boolean can Pass = ! failure Message . is Present ( ) ; if ( ( ! Properties . get Control All Canals Between Territories To Pass ( data ) && can Pass ) || ( Properties . get Control All Canals Between Territories To Pass ( data ) && ! can Pass ) ) { break ; } } return failure Message ; }
public void add ( OM Grid grid ) { add ( OM Graphic Util . create Shape 3 D ( grid , NUM_ , proj ) ) ; }
public static void show No Print Service ( Graphics Configuration gc ) { Frame dlg Frame = new Frame ( gc ) ; J Option Pane . show Message Dialog ( dlg Frame , get Msg ( STR_ ) ) ; dlg Frame . dispose ( ) ; }
protected static void init ( ) { root Suffix = AM Store Connection . get AM Sdk Base DN ( ) ; if ( root Suffix == null || root Suffix . equals ( STR_ ) ) { debug . error ( STR_ + STR_ ) ; return ; } }
@ Override public boolean undo ( ) { LOG . info ( STR_ ) ; File file = new File ( dest Topology File ) ; return file . delete ( ) ; }
public FB Escaped Parser ( Escape Parser Mode mode ) { this . mode = mode ; }
private void handle Collection Resource ( final String target Uri , final Http Server Request req , final int recursion Level , final Atomic Integer sub Request Counter , final Recursive Handler Factory . Recursive Handler Types recursion Handler Type , final Delta Handler < Resource Node > handler , final Buffer data , final String e Tag ) throws Resource Collection Exception { Collection Resource Container collection Resource Container = Expansion Delta Util . verify Collection Response ( target Uri , data , null ) ; Logger log = Request Logger Factory . get Logger ( Expansion Handler . class , req ) ; if ( log . is Trace Enabled ( ) ) { log . trace ( STR_ + collection Resource Container . get Collection Name ( ) ) ; log . trace ( STR_ + recursion Level ) ; } List < String > sub Resource Names = collection Resource Container . get Resource Names ( ) ; if ( sub Resource Names . size ( ) == NUM_ ) { if ( log . is Trace Enabled ( ) ) { log . trace ( STR_ + collection Resource Container . get Collection Name ( ) ) ; } Resource Node node = new Resource Node ( collection Resource Container . get Collection Name ( ) , new Json Array ( ) , e Tag ) ; handler . handle ( node ) ; } else { boolean max Recursion Level Reached = recursion Level == MAX RECURSION LEVEL ; if ( ! max Recursion Level Reached ) { if ( log . is Trace Enabled ( ) ) { log . trace ( STR_ + collection Resource Container . get Collection Name ( ) ) ; } final Delta Handler < Resource Node > parent Handler = Recursive Handler Factory . create Handler ( recursion Handler Type , sub Resource Names , collection Resource Container . get Collection Name ( ) , e Tag , handler ) ; if ( is Storage Expand ( target Uri ) ) { make Storage Expand Request ( target Uri , sub Resource Names , req , handler ) ; } else { for ( String child Resource Name : sub Resource Names ) { if ( log . is Trace Enabled ( ) ) { log . trace ( STR_ + child Resource Name ) ; } boolean collection = is Collection ( child Resource Name ) ; final String collection URI = Expansion Delta Util . construct Request Uri ( target Uri , req . params ( ) , parameter to remove after initial request , child Resource Name , Slash Handling . END WITHOUT SLASH ) ; make Resource Sub Request ( ( collection ? collection URI : remove Parameters ( collection URI ) ) , req , recursion Level - DECREMENT BY ONE , sub Request Counter , recursion Handler Type , parent Handler , collection ) ; } } } else { Json Array json Array = new Json Array ( ) ; for ( String child Resource Name : sub Resource Names ) { if ( log . is Trace Enabled ( ) ) { log . trace ( STR_ + child Resource Name ) ; } json Array . add ( child Resource Name ) ; } handler . handle ( new Resource Node ( collection Resource Container . get Collection Name ( ) , json Array , e Tag ) ) ; } } }
private void prepare Params ( Node parent ) throws Jasper Exception { if ( parent == null ) return ; Node . Nodes subelements = parent . get Body ( ) ; if ( subelements != null ) { for ( int i = NUM_ ; i < subelements . size ( ) ; i ++ ) { Node n = subelements . get Node ( i ) ; if ( n instanceof Node . Param Action ) { Node . Nodes param Sub Elements = n . get Body ( ) ; for ( int j = NUM_ ; ( param Sub Elements != null ) && ( j < param Sub Elements . size ( ) ) ; j ++ ) { Node m = param Sub Elements . get Node ( j ) ; if ( m instanceof Node . Named Attribute ) { generate Named Attribute Value ( ( Node . Named Attribute ) m ) ; } } } } } }
private void block RMI ( String method Name , Object ... args ) throws Internal Exception { queue Task ( db Client , Storage System . class , dispatcher , method Name , args ) ; }
public final void scheduled For Flush ( ) { scheduled For Flush . set ( true ) ; }
public byte [ ] write Byte Array ( ) { logger . finer ( STR_ ) ; int local Size = NUM_ ; Byte Array Output Stream buffer = new Byte Array Output Stream ( ) ; try { for ( Pair pair : ( ( Value Pairs ) value ) . mapping ) { { Text Encoded String Null Terminated next = new Text Encoded String Null Terminated ( identifier , frame Body , pair . get Key ( ) ) ; buffer . write ( next . write Byte Array ( ) ) ; local Size += next . get Size ( ) ; } { Text Encoded String Null Terminated next = new Text Encoded String Null Terminated ( identifier , frame Body , pair . get Value ( ) ) ; buffer . write ( next . write Byte Array ( ) ) ; local Size += next . get Size ( ) ; } } } catch ( IO Exception ioe ) { logger . log ( Level . SEVERE , STR_ , ioe ) ; throw new Runtime Exception ( ioe ) ; } size = local Size ; logger . finer ( STR_ ) ; return buffer . to Byte Array ( ) ; }
private List < Ldap Mod > create Atts ( I Ldap Entry entry ) { String [ ] attrs = entry . get Attribute Names ( ) ; List < Ldap Mod > obj Attributes = new Array List < > ( ) ; for ( String attr : attrs ) { if ( ! attr . equals Ignore Case ( STR_ ) && ! attr . equals Ignore Case ( STR_ ) ) { Ldap Value [ ] values = entry . get Attribute Values ( attr ) ; Ldap Mod mod = new Ldap Mod ( Ldap Mod Operation . ADD , attr , values ) ; obj Attributes . add ( mod ) ; } } return obj Attributes ; }
static void validate ( ) { String sql = STR_ ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { validate ( rs . get Int ( NUM_ ) , rs . get String ( NUM_ ) ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } }
public static synchronized void redirect Platform Loggers ( ) { if ( logging Enabled || ! Logging Support . is Available ( ) ) return ; logging Enabled = true ; for ( Map . Entry < String , Weak Reference < Platform Logger > > entry : loggers . entry Set ( ) ) { Weak Reference < Platform Logger > ref = entry . get Value ( ) ; Platform Logger plog = ref . get ( ) ; if ( plog != null ) { plog . redirect To Java Logger Proxy ( ) ; } } }
public static void sample Subtract ( Fixed Bit Set vector , Fixed Bit Set subvector ) { long numchanges = vector . length ( ) / NUM_ - xor Count ( vector , subvector ) ; java . util . Random random = new java . util . Random ( ) ; random . set Seed ( ( long ) NUM_ ) ; Fixed Bit Set common Ground = ( Fixed Bit Set ) vector . clone ( ) ; common Ground . xor ( subvector ) ; int cnt = NUM_ ; if ( numchanges > NUM_ ) for ( int x = NUM_ ; cnt < numchanges ; x ++ ) { if ( x >= vector . length ( ) ) x = NUM_ ; double change = random . next Double ( ) ; if ( ! common Ground . get ( x ) && change > NUM_ ) { vector . flip ( x ) ; cnt ++ ; } } else if ( numchanges < NUM_ ) { for ( int x = NUM_ ; cnt > numchanges ; x ++ ) { if ( x >= vector . length ( ) ) x = NUM_ ; double change = random . next Double ( ) ; if ( common Ground . get ( x ) && change > NUM_ ) { vector . flip ( x ) ; cnt -- ; } } } }
private boolean is Vmdk File ( Input Stream input Stream ) throws IO Exception { return VMDK FILE SIGNATURE . equals Ignore Case ( Data Field . get String ( VMDK SIGNATURE FIELD , input Stream ) ) ; }
public Type Variable BV type Variable ( Type Node type Node ) { Type Variable BV result = type Variable Map . get ( type Node ) ; if ( result == null ) { int id = type Variable List . size ( ) ; type Variable List . add ( null ) ; result = new Type Variable BV ( id , this , type Node ) ; type Variable List . set ( id , result ) ; type Variable Map . put ( type Node , result ) ; } return result ; }
protected static Tuple < String , String > create Tuple ( String one , double two ) { return Matsim Xml Writer . create Tuple ( one , Double . to String ( two ) ) ; }
public static Bundle create Fragment Args For Site ( String url ) { Bundle fragment Args = new Bundle ( ) ; String origin = Url Utilities . format Url For Security Display ( URI . create ( url ) , true ) ; fragment Args . put String ( Single Website Preferences . EXTRA ORIGIN , origin ) ; return fragment Args ; }
private void notify Money ( final User Action Attachment uaa ) { send Notification ( STR_ + uaa . get Cost PU ( ) + STR_ ) ; }
public J Frame construct Application Frame ( ) { J Frame frame = new J Frame ( ) ; J Panel panel = new Tic Tac Toe Panel ( ) ; frame . add ( panel , Border Layout . CENTER ) ; frame . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; return frame ; }
private void delete Target Group ( Storage System system , String replication Group Instance ) throws Exception { if ( system . get Using Smis 80 ( ) ) { if ( ! replication Group Instance . contains ( STR_ ) ) { replication Group Instance = String . format ( STR_ , system . get Serial Number ( ) , replication Group Instance ) ; } } CIM Object Path group Path = cim Path . get Replication Group Object Path ( system , replication Group Instance ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM_ ] ; CIM Argument [ ] delete Group In Args = helper . get Delete Replication Group Input Arguments ( system , group Path , true ) ; helper . invoke Method ( system , cim Path . get Controller Replication Svc Path ( system ) , DELETE GROUP , delete Group In Args , out Args ) ; }
private void print To Host ( String host , int port , byte [ ] cmds ) throws IO Exception { log . debug ( STR_ , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; Data Output Stream out = new Data Output Stream ( socket . get Output Stream ( ) ) ) { out . write ( cmds ) ; } }
Member Popup Menu ( String member , boolean show Leader Ops ) { this . member = member ; J Menu Item item = new J Menu Item ( STR_ ) ; item . add Action Listener ( new Where Action ( ) ) ; add ( item ) ; if ( show Leader Ops ) { item = new J Menu Item ( STR_ ) ; add ( item ) ; item . add Action Listener ( new Kick Action ( ) ) ; item = new J Menu Item ( STR_ ) ; add ( item ) ; item . add Action Listener ( new Transfer Leadership Action ( ) ) ; } }
public Java Version ( ) throws Version Exception { this ( System . get Property ( STR_ ) ) ; }
public boolean is Valid Current ( long check Time ) { if ( check Time == NUM_ || ( r Date List == null && r Rules List == null ) ) { return false ; } boolean found = false ; Iterator < Recurrence Rule > rules Iterator = get Recurrence Rule Iterator ( ) ; while ( rules Iterator . has Next ( ) ) { Recurrence Rule rule = rules Iterator . next ( ) ; long current Time = rule . valid Current ( get Start Time ( ) , check Time , get Current Count ( ) ) ; current Time = check Date List ( r Date List , current Time , check Time ) ; if ( ( current Time > NUM_ ) && is Valid ( check Time ) ) { found = true ; } else { return false ; } } return found ; }
public Node select Single Node ( Node context Node , String str , Node namespace Node ) throws Transformer Exception { Node Iterator nl = select Node Iterator ( context Node , str , namespace Node ) ; return nl . next Node ( ) ; }
public void add State ( int [ ] specs , Animation animation ) { Tuple tuple = new Tuple ( specs , animation ) ; animation . set Animation Listener ( m Animation Listener ) ; m Tuples . add ( tuple ) ; }
public Process execute Async ( final Command Line command , Map < String , String > environment ) throws IO Exception { if ( working Directory != null && ! working Directory . exists ( ) ) { throw new IO Exception ( working Directory + STR_ ) ; } return execute Internal ( command , environment , working Directory , stream Handler , null ) ; }
public void await ( ) throws Interrupted Exception { lock . lock ( ) ; try { while ( ! is Done ) { done . await ( ) ; } } finally { is Done = false ; lock . unlock ( ) ; } }
public void flush ( ) throws IO Exception { if ( closed ) { return ; } if ( gzipstream != null ) { gzipstream . flush ( ) ; } }
public double error Value ( boolean calculate ) { if ( ! Double . is Na N ( m unit Value ) && Double . is Na N ( m unit Error ) && calculate ) { m unit Error = m methods . error Value ( this ) ; } return m unit Error ; }
private void show Popup Menu ( final Mouse Event event ) { final I Tag Tree Node selected Node = ( I Tag Tree Node ) Tree Helpers . get Node At ( this , event . get X ( ) , event . get Y ( ) ) ; if ( selected Node == null ) { final J Popup Menu popup Menu = new J Popup Menu ( ) ; popup Menu . add ( C Action Proxy . proxy ( new C Add Root Tag Node Action ( m parent , m tag Manager , m root Node . get Tag ( ) ) ) ) ; popup Menu . show ( this , event . get X ( ) , event . get Y ( ) ) ; } else { final J Popup Menu menu = selected Node . get Popup Menu ( ) ; if ( menu != null ) { menu . show ( this , event . get X ( ) , event . get Y ( ) ) ; } } }
public void add Include Glob ( final String pattern ) { include Globs . add ( STR_ + pattern ) ; }
protected void process Window Event ( Window Event e ) { if ( e . get ID ( ) == Window Event . WINDOW CLOSING ) { cancel ( ) ; } super . process Window Event ( e ) ; }
@ Override public void batch Size ( int size ) { A . ensure ( size > NUM_ , STR_ + size ) ; lock . lock ( ) ; try { batch Size = size ; } finally { lock . unlock ( ) ; } }
private float calculate Angle Spacing ( float radius , float half Child Size ) { float desired Space = get Dimension ( R . dimen . material button spacing ) + NUM_ * half Child Size ; float cos Ratio = ( ( desired Space * desired Space ) - NUM_ * ( radius * radius ) ) / ( - NUM_ * radius * radius ) ; float radians = ( float ) Math . acos ( cos Ratio ) ; return ( float ) Math . to Degrees ( radians ) ; }
private void perform Frame Tasks ( ) { synchronized ( m Frame Task Queue ) { A Frame Task task = m Frame Task Queue . poll ( ) ; while ( task != null ) { task . run ( ) ; task = m Frame Task Queue . poll ( ) ; } } }
public static String to Hex ( byte [ ] bytes , int bytes Per Row ) { if ( bytes == null ) return STR_ ; String Buffer sb = new String Buffer ( ) ; sb . append ( STR_ + bytes . length + STR_ ) ; int i = NUM_ ; while ( i < bytes . length ) { if ( bytes Per Row > NUM_ && i % bytes Per Row == NUM_ ) sb . append ( STR_ ) ; sb . append ( HEX CHARS [ ( bytes [ i ] > > NUM_ ) & NUM_ ] ) ; sb . append ( HEX CHARS [ bytes [ i ] & NUM_ ] ) ; i ++ ; } return sb . to String ( ) ; }
public static Simple Date Format make Input Formatter ( ) { Simple Date Format fmt = new Simple Date Format ( DEFAULT IFORMAT ) ; fmt . set Time Zone ( GMT ZONE ) ; return ( fmt ) ; }
protected final void serialize ( Object Output Stream oos , Collection coll ) throws IO Exception { int count = NUM_ ; Object [ ] objects = coll . to Array ( ) ; for ( int i = NUM_ ; i < objects . length ; i ++ ) { if ( objects [ i ] instanceof Serializable ) count ++ ; else objects [ i ] = null ; } oos . write Int ( count ) ; for ( int i = NUM_ ; count > NUM_ ; i ++ ) { Object o = objects [ i ] ; if ( o != null ) { oos . write Object ( o ) ; count -- ; } } }
public Component create Edit Component ( Value Property value Property ) { Component component ; switch ( type ) { case DATATYPE : component = create Datatype Field ( Datatypes . get NN ( java Class ) , value Property ) ; break ; case ENTITY : component = create Entity Lookup ( value Property ) ; break ; case UNARY : component = create Unary Field ( value Property ) ; break ; case ENUM : component = create Enum Lookup ( value Property ) ; break ; case RUNTIME ENUM : component = create Runtime Enum Lookup ( value Property ) ; break ; default : throw new Unsupported Operation Exception ( STR_ + type ) ; } this . edit Component = component ; return component ; }
public static boolean is Network Available ( final Context c ) { boolean state = false ; if ( c != null ) { Connectivity Manager cm = ( Connectivity Manager ) c . get System Service ( Context . CONNECTIVITY SERVICE ) ; Network Info net Info = cm . get Active Network Info ( ) ; if ( net Info != null && net Info . is Connected ( ) ) { Log . i ( TAG , STR_ ) ; state = true ; } else { Log . i ( TAG , STR_ ) ; state = false ; } } return state ; }
public Signer ( Request request , String content Sha 256 , Date Time date , String region , String access Key , String secret Key ) { this . request = request ; this . content Sha 256 = content Sha 256 ; this . date = date ; this . region = region ; this . access Key = access Key ; this . secret Key = secret Key ; }
private void draw Op Anno ( final Operator operator , final Graphics 2 D g 2 , final Process Renderer Model renderer Model , final boolean printing ) { Workflow Annotations annotations = renderer Model . get Operator Annotations ( operator ) ; if ( annotations == null ) { return ; } for ( Workflow Annotation anno : annotations . get Annotations Draw Order ( ) ) { if ( anno . equals ( model . get Selected ( ) ) ) { continue ; } Graphics 2 D g 2 P = ( Graphics 2 D ) g 2 . create ( ) ; drawer . draw Annotation ( anno , g 2 P , printing ) ; g 2 P . dispose ( ) ; } }
private void check Member Access ( int type ) { Security Manager security = System . get Security Manager ( ) ; if ( security != null ) { security . check Member Access ( this , type ) ; String package Name = get Package Name ( ) ; if ( ! package Name . is Empty ( ) ) { security . check Package Access ( package Name ) ; } } }
public synchronized boolean remove ( File file ) { if ( file == null ) return false ; int index = index Of ( file ) ; if ( index == - NUM_ ) { return false ; } File [ ] new Value = new File [ value . length - NUM_ ] ; System . arraycopy ( value , NUM_ , new Value , NUM_ , index ) ; System . arraycopy ( value , index + NUM_ , new Value , index , value . length - index - NUM_ ) ; set Value ( new Value ) ; return true ; }
public static byte [ ] encrypt Key ( byte [ ] password , byte [ ] raw Key ) { try { Cipher c = Cipher . get Instance ( ENCRYPT KEY ALGORITHM ) ; c . init ( Cipher . ENCRYPT MODE , new Secret Key Spec ( password , SECRET KEY ALGORITHM ) , CBC SALT KEY ) ; return c . do Final ( raw Key ) ; } catch ( Exception e ) { throw new Illegal State Exception ( ENCRYPT KEY ALGORITHM + STR_ , e ) ; } }
@ Override public I Long Putter put ( long index , long value ) { if ( index < limit ( ) ) { index <<= NUM_ ; final Byte Buffer buf = buffers [ get Which Buffer ( index ) ] ; int index Buffer = get Index In Buffer ( index ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > NUM_ ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > NUM_ ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > NUM_ ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > NUM_ ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > NUM_ ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > NUM_ ) ) ; buf . put ( index Buffer ++ , ( byte ) ( value > > NUM_ ) ) ; buf . put ( index Buffer , ( byte ) ( value ) ) ; } else throw new Array Index Out Of Bounds Exception ( STR_ + index ) ; return this ; }
void prepare Views ( Rectangle area ) { visible Views . clear ( ) ; synchronized ( views ) { for ( Entity View < I Entity > view : views ) { view . apply Changes ( ) ; if ( area . intersects ( view . get Area ( ) ) ) { visible Views . add ( view ) ; } } } Collections . sort ( visible Views , entity View Comparator ) ; }
@ Non Null private static List < Rave Error > create String Def Error ( @ Nullable String value , @ Non Null String [ ] acceptable Values , @ Non Null Validation Context validation Context ) { String Builder string Builder = new String Builder ( ) ; boolean first = true ; for ( String string : acceptable Values ) { if ( ! first ) { string Builder . append ( STR_ ) ; } else { string Builder . append ( STR_ ) ; } string Builder . append ( string ) ; first = false ; } string Builder . append ( STR_ ) ; return create New List ( new Rave Error ( validation Context , value + STR_ + Rave Error Strings . STRING DEF ERROR + string Builder . to String ( ) ) ) ; }
private void remove Observed File ( String local Path ) { File file = new File ( local Path ) ; String parent Path = file . get Parent ( ) ; Folder Observer observer = m Folder Observers Map . get ( parent Path ) ; if ( observer != null ) { observer . stop Watching ( file . get Name ( ) ) ; if ( observer . is Empty ( ) ) { m Folder Observers Map . remove ( parent Path ) ; Log OC . d ( TAG , STR_ + parent Path + STR_ ) ; } } else { Log OC . d ( TAG , STR_ + local Path ) ; } }
public static Location convert Lat Lng ( Lat Lng location ) { return convert Lat Lng ( location . latitude , location . longitude ) ; }
private boolean ensure Target Directory Is Valid ( File target Directory ) { if ( target Directory . exists ( ) && ! target Directory . is Directory ( ) ) { display Error Dialog ( Data Transfer Messages . File Export directory Exists ) ; give Focus To Destination ( ) ; return false ; } return ensure Directory Exists ( target Directory ) ; }
private String read Response ( Input Stream in ) { Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( in ) ) ; String input Line ; String Builder builder = new String Builder ( ) ; try { while ( ( input Line = reader . read Line ( ) ) != null ) { builder . append ( input Line ) ; } } catch ( IO Exception e ) { throw new MC Api Runtime Exception ( e ) ; } return builder . to String ( ) ; }
public void sort Rules ( ) { Collections . sort ( rules ) ; }
protected void invoke ( Type type , String namespace , String local Part , String state ) { core Declaration Handler . invoke ( type , namespace , local Part , state ) ; }
static boolean write Out Text ( Glyph Data glyph Data , float [ ] [ ] Trm , boolean has Content , final float current Width , final String Buffer text Data , final String spaces ) { final String unicode Value = glyph Data . get Unicode Value ( ) ; final float font Scale = glyph Data . get Font Scale ( ) ; if ( ! unicode Value . is Empty ( ) ) { if ( Decoder Options . embed Width Data ) { final float xx = Trm [ NUM_ ] [ NUM_ ] ; final float yy = Trm [ NUM_ ] [ NUM_ ] ; text Data . append ( spaces ) ; if ( glyph Data . is Horizontal ( ) ) { text Data . append ( Pdf Data . marker ) ; text Data . append ( xx ) ; text Data . append ( Pdf Data . marker ) ; } else { text Data . append ( Pdf Data . marker ) ; text Data . append ( yy ) ; text Data . append ( Pdf Data . marker ) ; } text Data . append ( current Width * font Scale ) ; text Data . append ( Pdf Data . marker ) ; } else { text Data . append ( spaces ) ; } final int length = unicode Value . length ( ) ; char next ; boolean is XML Extraction = glyph Data . is XML Extraction ( ) ; for ( int ii = NUM_ ; ii < length ; ii ++ ) { next = unicode Value . char At ( ii ) ; has Content = true ; if ( next == NUM_ ) { next = NUM_ ; } if ( next == STR_ && is XML Extraction ) { text Data . append ( STR_ ) ; } else if ( next == STR_ && is XML Extraction ) { text Data . append ( STR_ ) ; } else if ( next == NUM_ ) { text Data . append ( STR_ ) ; } else if ( next > NUM_ ) { text Data . append ( next ) ; } else if ( next == NUM_ || next == NUM_ ) { text Data . append ( STR_ ) ; } else { text Data . append ( hex [ next ] ) ; } } } else { text Data . append ( spaces ) ; } return has Content ; }
private static synchronized void init Doc Builder Factory ( ) { doc Builder Factory = Document Builder Factory . new Instance ( ) ; doc Builder Factory . set Ignoring Comments ( true ) ; doc Builder Factory . set Coalescing ( true ) ; }
public void or With ( Or Condition other ) { children . add All ( other . get And Terms ( ) ) ; }
public Core Admin Handler ( final Core Container core Container ) { this . core Container = core Container ; Hash Map < String , Map < String , Task Object > > map = new Hash Map < > ( NUM_ , NUM_ ) ; map . put ( RUNNING , Collections . synchronized Map ( new Linked Hash Map < String , Task Object > ( ) ) ) ; map . put ( COMPLETED , Collections . synchronized Map ( new Linked Hash Map < String , Task Object > ( ) ) ) ; map . put ( FAILED , Collections . synchronized Map ( new Linked Hash Map < String , Task Object > ( ) ) ) ; request Status Map = Collections . unmodifiable Map ( map ) ; }
protected double [ ] calculate Bar L 0 L 1 ( double value ) { double lclip = get Lower Clip ( ) ; double uclip = get Upper Clip ( ) ; double bar Low = Math . min ( this . base , value ) ; double bar High = Math . max ( this . base , value ) ; if ( bar High < lclip ) { return null ; } if ( bar Low > uclip ) { return null ; } bar Low = Math . max ( bar Low , lclip ) ; bar High = Math . min ( bar High , uclip ) ; return new double [ ] { bar Low , bar High } ; }
private boolean check Select For Swipe ( int action , Motion Event motion Event , int pointer Index ) { if ( m Selected != null || action != Motion Event . ACTION MOVE || m Action State == ACTION STATE DRAG || ! m Callback . is Item View Swipe Enabled ( ) ) { return false ; } if ( m Recycler View . get Scroll State ( ) == Recycler View . SCROLL STATE DRAGGING ) { return false ; } final Recycler View . View Holder vh = find Swiped View ( motion Event ) ; if ( vh == null ) { return false ; } final int movement Flags = m Callback . get Absolute Movement Flags ( m Recycler View , vh ) ; final int swipe Flags = ( movement Flags & ACTION MODE SWIPE MASK ) > > ( DIRECTION FLAG COUNT * ACTION STATE SWIPE ) ; if ( swipe Flags == NUM_ ) { return false ; } final float x = Motion Event Compat . get X ( motion Event , pointer Index ) ; final float y = Motion Event Compat . get Y ( motion Event , pointer Index ) ; final float dx = x - m Initial Touch X ; final float dy = y - m Initial Touch Y ; final float abs Dx = Math . abs ( dx ) ; final float abs Dy = Math . abs ( dy ) ; if ( abs Dx < m Slop && abs Dy < m Slop ) { return false ; } if ( abs Dx > abs Dy ) { if ( dx < NUM_ && ( swipe Flags & LEFT ) == NUM_ ) { return false ; } if ( dx > NUM_ && ( swipe Flags & RIGHT ) == NUM_ ) { return false ; } } else { if ( dy < NUM_ && ( swipe Flags & UP ) == NUM_ ) { return false ; } if ( dy > NUM_ && ( swipe Flags & DOWN ) == NUM_ ) { return false ; } } m Dx = m Dy = NUM_ ; m Active Pointer Id = Motion Event Compat . get Pointer Id ( motion Event , NUM_ ) ; select ( vh , ACTION STATE SWIPE ) ; return true ; }
@ Override public boolean is Multicast Address ( ) { return holder 6 . is Multicast Address ( ) ; }
@ Override public < T > T instance ( Key < T > key ) { Objects . require Non Null ( key ) ; Class < T > type = ( Class ) key . raw Class ( ) ; if ( type . equals ( Provider . class ) ) { Type Ref type Ref = Type Ref . of ( key . type ( ) ) ; Type Ref param = type Ref . param ( NUM_ ) ; return ( T ) provider ( Key . of ( param . type ( ) ) ) ; } Provider < T > provider = provider ( key ) ; if ( provider != null ) { return provider . get ( ) ; } else { return null ; } }
private static Element add Problem List Section ( String name , Element body Node , Hashtable < String , Element > repeat Controls , Element model Node ) { Element group Node = body Node . create Element ( NAMESPACE XFORMS , null ) ; group Node . set Name ( NODE GROUP ) ; Element label Node = group Node . create Element ( NAMESPACE XFORMS , null ) ; label Node . set Name ( NODE LABEL ) ; group Node . add Child ( Element . ELEMENT , label Node ) ; body Node . add Child ( Element . ELEMENT , group Node ) ; Element repeat Control = build Repeat Control ( group Node , null , name , model Node ) ; repeat Controls . put ( name , repeat Control ) ; add Control ( group Node , repeat Control ) ; return label Node ; }
private void sync Meta Transients ( ) { if ( m meta Transient Bits == null || m meta Transient Bits . length != m meta Bits . length ) { m meta Transient Bits = ( int [ ] ) m meta Bits . clone ( ) ; } else { System . arraycopy ( m meta Bits , NUM_ , m meta Transient Bits , NUM_ , m meta Transient Bits . length ) ; } }
public static Memory Allocator create Off Heap Storage ( Statistics Factory sf , long off Heap Memory Size , Distributed System system ) { if ( off Heap Memory Size == NUM_ || Boolean . get Boolean ( Internal Locator . FORCE LOCATOR DM TYPE ) ) { return null ; } if ( off Heap Memory Size < MIN SLAB SIZE ) { throw new Illegal Argument Exception ( STR_ + MIN SLAB SIZE + STR_ + off Heap Memory Size ) ; } validate Vm Compatibility ( ) ; if ( system == null ) { throw new Illegal Argument Exception ( STR_ ) ; } Out Of Off Heap Memory Listener ooohml = new Disconnecting Out Of Off Heap Memory Listener ( ( Internal Distributed System ) system ) ; return basic Create Off Heap Storage ( sf , off Heap Memory Size , ooohml ) ; }
public void decoding ( ) { int i , j , k , m , stripe ; int rs nbr = NUM_ ; int rs data nbr = NUM_ ; int rs check nbr = NUM_ ; int rs disk 1 = - NUM_ ; int rs disk 2 = - NUM_ ; int rs disk 3 = - NUM_ ; if ( stripe unit size % block nbr != NUM_ ) { throw new Runtime Exception ( STR_ ) ; } for ( i = NUM_ ; i < data disk nbr + NUM_ ; i ++ ) { if ( restarts [ i ] == NUM_ ) { rs disk 1 = i ; break ; } } if ( rs disk 1 != - NUM_ ) { for ( i = rs disk 1 + NUM_ ; i < data disk nbr + NUM_ ; i ++ ) { if ( restarts [ i ] == NUM_ ) { rs disk 2 = i ; break ; } } } if ( rs disk 2 != - NUM_ ) { for ( i = rs disk 2 + NUM_ ; i < data disk nbr + NUM_ ; i ++ ) { if ( restarts [ i ] == NUM_ ) { rs disk 3 = i ; break ; } } } if ( rs disk 1 != - NUM_ ) { Arrays . fill ( check data [ rs disk 1 ] , ( char ) NUM_ ) ; } if ( rs disk 2 != - NUM_ ) { Arrays . fill ( check data [ rs disk 2 ] , ( char ) NUM_ ) ; } if ( rs disk 3 != - NUM_ ) { Arrays . fill ( check data [ rs disk 3 ] , ( char ) NUM_ ) ; } for ( i = NUM_ ; i <= data disk nbr + NUM_ ; i ++ ) rs nbr += restarts [ i ] ; if ( TOLERENCE < rs nbr ) { throw new Runtime Exception ( STR_ ) ; } for ( i = NUM_ ; i < data disk nbr ; i ++ ) rs data nbr += restarts [ i ] ; rs check nbr = rs nbr - rs data nbr ; if ( rs data nbr == NUM_ ) { if ( restarts [ data disk nbr ] == NUM_ ) STAR encoding row ( ) ; if ( restarts [ data disk nbr + NUM_ ] == NUM_ ) STAR encoding diag 1 ( ) ; if ( restarts [ data disk nbr + NUM_ ] == NUM_ ) STAR encoding diag 2 ( ) ; } if ( rs data nbr == NUM_ ) { if ( rs check nbr <= NUM_ ) { Evenodd decoding ( restarts ) ; if ( restarts [ data disk nbr + NUM_ ] == NUM_ ) STAR encoding diag 2 ( ) ; } if ( rs check nbr == NUM_ ) { if ( restarts [ data disk nbr ] == NUM_ ) { for ( i = NUM_ ; i < stripe unit size ; i ++ ) { for ( j = NUM_ ; j <= data disk nbr ; j ++ ) { if ( j != rs disk 1 ) check data [ rs disk 1 ] [ i ] ^= check data [ j ] [ i ] ; } } STAR encoding diag 1 ( ) ; STAR encoding diag 2 ( ) ; } if ( restarts [ data disk nbr ] == NUM_ ) { if ( restarts [ data disk nbr + NUM_ ] == NUM_ ) { Evenodd decoding ( restarts ) ; STAR encoding diag 2 ( ) ; } if ( restarts [ data disk nbr + NUM_ ] == NUM_ ) { Evenodd decoding 1 ( rs disk 1 , rs disk 2 ) ; STAR encoding diag 1 ( ) ; } } } } if ( rs data nbr == NUM_ ) { if ( rs check nbr == NUM_ ) { Evenodd decoding ( restarts ) ; } else { if ( restarts [ data disk nbr ] == NUM_ ) { char [ ] tmp for s 1 s 2 ; tmp for s 1 s 2 = new char [ block size ] ; for ( i = NUM_ ; i < block nbr ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { tmp for s 1 s 2 [ j ] ^= check data [ data disk nbr + NUM_ ] [ i * block size + j ] ; tmp for s 1 s 2 [ j ] ^= check data [ data disk nbr + NUM_ ] [ i * block size + j ] ; } } char [ ] [ ] tmp ; tmp = new char [ NUM_ ] [ p * block size ] ; for ( i = NUM_ ; i < stripe unit size ; i ++ ) { for ( j = NUM_ ; j <= data disk nbr ; j ++ ) { tmp [ NUM_ ] [ i ] ^= check data [ j ] [ i ] ; } } for ( stripe = NUM_ ; stripe < block nbr + NUM_ ; stripe ++ ) { for ( i = NUM_ ; i < data disk nbr ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { k = ( stripe - i + p ) % p ; if ( k < block nbr ) { tmp [ NUM_ ] [ stripe * block size + j ] ^= check data [ i ] [ k * block size + j ] ; } } } } for ( i = NUM_ ; i < stripe unit size ; i ++ ) { tmp [ NUM_ ] [ i ] ^= check data [ data disk nbr + NUM_ ] [ i ] ; } for ( stripe = NUM_ ; stripe < block nbr + NUM_ ; stripe ++ ) { for ( i = NUM_ ; i < data disk nbr ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { k = ( stripe + i + p ) % p ; if ( k < block nbr ) { tmp [ NUM_ ] [ stripe * block size + j ] ^= check data [ i ] [ k * block size + j ] ; } } } } for ( i = NUM_ ; i < stripe unit size ; i ++ ) { tmp [ NUM_ ] [ i ] ^= check data [ data disk nbr + NUM_ ] [ i ] ; } char [ ] [ ] tmp for xor ; tmp for xor = new char [ p ] [ block size ] ; for ( i = NUM_ ; i < block nbr + NUM_ ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { tmp for xor [ i ] [ j ] = ( char ) ( tmp [ NUM_ ] [ i * block size + j ] ^ tmp [ NUM_ ] [ ( ( rs disk 2 - rs disk 1 + i ) % p ) * block size + j ] ^ tmp [ NUM_ ] [ ( ( rs disk 2 + p + i ) % p ) * block size + j ] ^ tmp [ NUM_ ] [ ( ( p - rs disk 1 + i ) % p ) * block size + j ] ^ tmp for s 1 s 2 [ j ] ) ; } } k = p - NUM_ - ( rs disk 2 - rs disk 1 ) ; for ( i = NUM_ ; i < block size ; i ++ ) { check data [ data disk nbr ] [ k * block size + i ] = tmp for xor [ k ] [ i ] ; } m = block nbr - NUM_ ; while ( NUM_ != m ) { i = ( k + rs disk 1 - rs disk 2 + p ) % p ; for ( j = NUM_ ; j < block size ; j ++ ) { check data [ data disk nbr ] [ i * block size + j ] = ( char ) ( tmp for xor [ i ] [ j ] ^ check data [ data disk nbr ] [ k * block size + j ] ) ; } k = i ; m -- ; } restarts [ data disk nbr ] = NUM_ ; Evenodd decoding ( restarts ) ; } } if ( restarts [ data disk nbr + NUM_ ] == NUM_ ) { Evenodd decoding 1 ( rs disk 1 , rs disk 2 ) ; STAR encoding diag 1 ( ) ; } if ( restarts [ data disk nbr + NUM_ ] == NUM_ ) { Evenodd decoding ( restarts ) ; STAR encoding diag 2 ( ) ; } } if ( rs data nbr == NUM_ ) { int r , s , t , u , v ; char [ ] [ ] tmp ; tmp = new char [ NUM_ ] [ p * block size ] ; char [ ] tmp for s 1 ; tmp for s 1 = new char [ block size ] ; char [ ] tmp for s 2 ; tmp for s 2 = new char [ block size ] ; char [ ] [ ] tmp for xor ; tmp for xor = new char [ p ] [ block size ] ; for ( i = NUM_ ; i < block nbr ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { tmp for s 1 [ j ] ^= check data [ data disk nbr ] [ i * block size + j ] ; tmp for s 1 [ j ] ^= check data [ data disk nbr + NUM_ ] [ i * block size + j ] ; tmp for s 2 [ j ] ^= check data [ data disk nbr ] [ i * block size + j ] ; tmp for s 2 [ j ] ^= check data [ data disk nbr + NUM_ ] [ i * block size + j ] ; } } for ( i = NUM_ ; i < stripe unit size ; i ++ ) { for ( j = NUM_ ; j <= data disk nbr ; j ++ ) { tmp [ NUM_ ] [ i ] ^= check data [ j ] [ i ] ; } } for ( stripe = NUM_ ; stripe < block nbr + NUM_ ; stripe ++ ) { for ( i = NUM_ ; i < data disk nbr ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { k = ( stripe - i + p ) % p ; if ( k < block nbr ) { tmp [ NUM_ ] [ stripe * block size + j ] ^= check data [ i ] [ k * block size + j ] ; } } } } for ( i = NUM_ ; i < block nbr + NUM_ ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { if ( i < block nbr ) tmp [ NUM_ ] [ i * block size + j ] ^= ( check data [ data disk nbr + NUM_ ] [ i * block size + j ] ^ tmp for s 1 [ j ] ) ; else tmp [ NUM_ ] [ i * block size + j ] ^= tmp for s 1 [ j ] ; } } for ( stripe = NUM_ ; stripe < block nbr + NUM_ ; stripe ++ ) { for ( i = NUM_ ; i < data disk nbr ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { k = ( stripe + i + p ) % p ; if ( k < block nbr ) { tmp [ NUM_ ] [ stripe * block size + j ] ^= check data [ i ] [ k * block size + j ] ; } } } } for ( i = NUM_ ; i < block nbr + NUM_ ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { if ( i < block nbr ) tmp [ NUM_ ] [ i * block size + j ] ^= ( check data [ data disk nbr + NUM_ ] [ i * block size + j ] ^ tmp for s 2 [ j ] ) ; else tmp [ NUM_ ] [ i * block size + j ] ^= tmp for s 2 [ j ] ; } } r = rs disk 1 ; s = rs disk 2 ; t = rs disk 3 ; u = s - r ; v = t - s ; if ( u == v ) { for ( i = NUM_ ; i < block nbr + NUM_ ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { tmp for xor [ i ] [ j ] = ( char ) ( tmp [ NUM_ ] [ i * block size + j ] ^ tmp [ NUM_ ] [ ( ( t - r + i ) % p ) * block size + j ] ^ tmp [ NUM_ ] [ ( ( t + p + i ) % p ) * block size + j ] ^ tmp [ NUM_ ] [ ( ( p - r + i ) % p ) * block size + j ] ) ; } } k = p - NUM_ - ( t - r ) ; for ( i = NUM_ ; i < block size ; i ++ ) { check data [ s ] [ k * block size + i ] = tmp for xor [ k ] [ i ] ; } m = block nbr - NUM_ ; while ( NUM_ != m ) { i = ( r - t + k + p ) % p ; for ( j = NUM_ ; j < block size ; j ++ ) { check data [ s ] [ i * block size + j ] = ( char ) ( tmp for xor [ i ] [ j ] ^ check data [ s ] [ k * block size + j ] ) ; } k = i ; m -- ; } } else if ( u != v ) { int d ; char [ ] [ ] flag ; flag = new char [ NUM_ ] [ p ] ; for ( d = NUM_ ; d <= p ; d ++ ) { if ( ( u + v * d ) % p == NUM_ ) { break ; } } for ( i = NUM_ ; i < d ; i ++ ) { flag [ NUM_ ] [ ( NUM_ + i * v ) % p ] ++ ; flag [ NUM_ ] [ ( s - r + i * v ) % p ] ++ ; flag [ NUM_ ] [ ( t - r + i * v ) % p ] ++ ; flag [ NUM_ ] [ ( NUM_ + i * v ) % p ] ++ ; flag [ NUM_ ] [ ( t - s + i * v ) % p ] ++ ; flag [ NUM_ ] [ ( t - r + i * v ) % p ] ++ ; } int [ ] count ; count = new int [ p ] ; for ( i = NUM_ ; i < p ; i ++ ) { for ( j = NUM_ ; j < NUM_ ; j ++ ) { if ( flag [ j ] [ i ] == NUM_ ) count [ i ] ++ ; } } for ( m = NUM_ ; m < block nbr + NUM_ ; m ++ ) { for ( i = NUM_ ; i < p ; i ++ ) { if ( count [ i ] == NUM_ || count [ i ] == NUM_ ) { for ( j = NUM_ ; j < block size ; j ++ ) tmp for xor [ m ] [ j ] ^= tmp [ NUM_ ] [ ( ( i + m ) % p ) * block size + j ] ; } } for ( i = NUM_ ; i < d ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { tmp for xor [ m ] [ j ] ^= tmp [ NUM_ ] [ ( ( t + p + NUM_ + i * v + m ) % p ) * block size + j ] ; tmp for xor [ m ] [ j ] ^= tmp [ NUM_ ] [ ( ( p - r + NUM_ + i * v + m ) % p ) * block size + j ] ; } } } i = u - NUM_ ; k = ( u + i ) % p ; for ( j = NUM_ ; j < block size ; j ++ ) { check data [ s ] [ k * block size + j ] = tmp for xor [ i ] [ j ] ; } m = block nbr - NUM_ ; while ( NUM_ != m ) { i = ( k + u ) % p ; for ( j = NUM_ ; j < block size ; j ++ ) { check data [ s ] [ ( ( u + i ) % p ) * block size + j ] = ( char ) ( tmp for xor [ i ] [ j ] ^ check data [ s ] [ k * block size + j ] ) ; } k = ( u + i ) % p ; m -- ; } } restarts [ s ] = NUM_ ; Evenodd decoding ( restarts ) ; } }
public synchronized void remove Property Change Listener ( Property Change Listener l ) { pcs . remove Property Change Listener ( l ) ; }
public static Area punch ( Area shape Area , double gap , boolean rounded , Point 2 D point Pos , Shape point Shape ) { if ( gap <= NUM_ || point Pos == null || point Shape == null ) { return shape Area ; } Affine Transform tx = Affine Transform . get Translate Instance ( point Pos . get X ( ) , point Pos . get Y ( ) ) ; int gap Join = rounded ? Basic Stroke . JOIN ROUND : Basic Stroke . JOIN MITER ; Area gap Area = Geometry Utils . grow ( tx . create Transformed Shape ( point Shape ) , gap , gap Join , NUM_ ) ; shape Area . subtract ( gap Area ) ; return shape Area ; }
private static int write Size ( List < ? extends Offsetted Item > items ) { Offsetted Item first = items . get ( NUM_ ) ; return ( items . size ( ) * first . write Size ( ) ) + get Alignment ( items ) ; }
@ React Method public void function Call Completed ( final String call Id , final String error , final Readable Map return Value ) { if ( ! callbacks . contains Key ( call Id ) ) { return ; } Evaluator Callback cb = ( Evaluator Callback ) callbacks . get ( call Id ) ; cb . invoke ( error , return Value . has Key ( VALUE KEY ) ? Conversion Util . to Object ( return Value , VALUE KEY ) : null ) ; callbacks . remove ( call Id ) ; }
protected void exiting ( String method Name ) { logger . exiting ( class Name , method Name ) ; }
public static String create Container Present Name ( String host Name , String container Name ) { if ( host Name == null ) host Name = STR_ ; else host Name += STR_ ; return host Name + container Name ; }
public boolean evaluate Is Zero ( final double x , final double y , final double z ) { return Math . abs ( evaluate ( x , y , z ) ) < MINIMUM RESOLUTION ; }
public static void clear Bitmap Cache ( ) { bitmap Cache . clear ( ) ; }
private static String num 2 Short ID ( int num , char [ ] ID Chars , int ID Width ) { char ID [ ] = new char [ ID Width ] ; int i ; for ( i = ID Width - NUM_ ; i >= NUM_ ; i -- ) { ID [ i ] = ID Chars [ num % ID Chars . length ] ; num = num / ID Chars . length - NUM_ ; if ( num < NUM_ ) { break ; } } for ( i -- ; i >= NUM_ ; i -- ) { ID [ i ] = STR_ ; } return new String ( ID ) ; }
@ Override public void on Bind View Holder ( final Recycler View . View Holder holder , int positions ) { int view Type = holder . get Item View Type ( ) ; switch ( view Type ) { case NUM_ : convert ( ( Base View Holder ) holder , m Data . get ( holder . get Layout Position ( ) - get Header Layout Count ( ) ) ) ; break ; case LOADING VIEW : add Load More ( holder ) ; break ; case HEADER VIEW : break ; case EMPTY VIEW : break ; case FOOTER VIEW : break ; default : convert ( ( Base View Holder ) holder , m Data . get ( holder . get Layout Position ( ) - get Header Layout Count ( ) ) ) ; on Bind Def View Holder ( ( Base View Holder ) holder , m Data . get ( holder . get Layout Position ( ) - get Header Layout Count ( ) ) ) ; break ; } }
public void prefer Connection ( String identifier ) { preferred Connections . add ( identifier ) ; }
protected void paint Target Panel ( Graphics g ) { Graphics 2 D g 2 = ( Graphics 2 D ) g ; if ( antialiasing On ) { g 2 . set Rendering Hints ( antialiasing ) ; } if ( is Editable ( ) && draw Grid ) { draw Panel Grid ( g 2 ) ; } g 2 . set Color ( default Track Color ) ; main = false ; g 2 . set Stroke ( new Basic Stroke ( side Track Width , Basic Stroke . CAP ROUND , Basic Stroke . JOIN ROUND ) ) ; draw Hidden Track ( g 2 ) ; draw Dashed Track ( g 2 , false ) ; draw Dashed Track ( g 2 , true ) ; draw Solid Track ( g 2 , false ) ; draw Solid Track ( g 2 , true ) ; draw Turnouts ( g 2 ) ; draw Xings ( g 2 ) ; draw Slips ( g 2 ) ; draw Turntables ( g 2 ) ; draw Track In Progress ( g 2 ) ; g 2 . set Stroke ( new Basic Stroke ( NUM_ , Basic Stroke . CAP ROUND , Basic Stroke . JOIN ROUND ) ) ; draw Points ( g 2 ) ; if ( is Editable ( ) ) { draw Turnout Rects ( g 2 ) ; draw Xing Rects ( g 2 ) ; draw Slip Rects ( g 2 ) ; draw Track Ovals ( g 2 ) ; draw Selection Rect ( g 2 ) ; draw Turntable Rects ( g 2 ) ; draw Memory Rects ( g 2 ) ; draw Block Contents Rects ( g 2 ) ; draw Track Circle Centre ( g 2 ) ; high Light Selection ( g 2 ) ; } else if ( turnout Circles Without Edit Mode ) { draw Turnout Circles ( g 2 ) ; } }
public static X 509 Certificate [ ] create Certificate Chain ( String cert Chain PEM ) { Assert Util . assert Not Null ( cert Chain PEM , STR_ ) ; List < X 509 Certificate > chain = new Array List < > ( ) ; try ( PEM Parser parser = new PEM Parser ( new String Reader ( cert Chain PEM ) ) ) { Jca X 509 Certificate Converter converter = new Jca X 509 Certificate Converter ( ) ; X 509 Certificate Holder certificate Holder ; while ( ( certificate Holder = ( X 509 Certificate Holder ) parser . read Object ( ) ) != null ) { chain . add ( converter . get Certificate ( certificate Holder ) ) ; } } catch ( IO Exception | Certificate Exception e ) { throw new Runtime Exception ( STR_ + cert Chain PEM , e ) ; } if ( chain . is Empty ( ) ) { throw new Runtime Exception ( STR_ + cert Chain PEM ) ; } return chain . to Array ( new X 509 Certificate [ chain . size ( ) ] ) ; }
private boolean condition M 0 ( String value , int index ) { if ( char At ( value , index + NUM_ ) == STR_ ) { return true ; } return contains ( value , index - NUM_ , NUM_ , STR_ ) && ( ( index + NUM_ ) == value . length ( ) - NUM_ || contains ( value , index + NUM_ , NUM_ , STR_ ) ) ; }
@ Suppress Warnings ( { STR_ } ) private void update Local ( int p , UUID node Id , Grid Dht Partition State state , long update Seq ) { assert lock . is Write Locked By Current Thread ( ) ; assert node Id . equals ( cctx . local Node Id ( ) ) ; Cluster Node oldest = CU . oldest Alive Cache Server Node ( cctx , top Ver ) ; if ( oldest . id ( ) . equals ( cctx . local Node Id ( ) ) ) { long seq = node 2 part . update Sequence ( ) ; if ( seq != update Seq ) { if ( seq > update Seq ) { if ( this . update Seq . get ( ) < seq ) { boolean b = this . update Seq . compare And Set ( this . update Seq . get ( ) , seq + NUM_ ) ; assert b : STR_ + update Seq + STR_ + seq + STR_ + this . update Seq . get ( ) + STR_ + node 2 part . to Full String ( ) + STR_ ; update Seq = seq + NUM_ ; } else update Seq = seq ; } node 2 part . update Sequence ( update Seq ) ; } } Grid Dht Partition Map 2 map = node 2 part . get ( node Id ) ; if ( map == null ) node 2 part . put ( node Id , map = new Grid Dht Partition Map 2 ( node Id , update Seq , top Ver , Collections . < Integer , Grid Dht Partition State > empty Map ( ) , false ) ) ; map . update Sequence ( update Seq , top Ver ) ; map . put ( p , state ) ; Set < UUID > ids = part 2 node . get ( p ) ; if ( ids == null ) part 2 node . put ( p , ids = U . new Hash Set ( NUM_ ) ) ; ids . add ( node Id ) ; }
private static Map < I Block Node , C Code Node > create Nodes ( final I Navi View view , final I Navi Function function , final I Navi Group Node parent Group ) { final Linked Hash Map < I Block Node , C Code Node > map = new Linked Hash Map < I Block Node , C Code Node > ( ) ; for ( final I Block Node block Node : function . get Basic Blocks ( ) ) { create Node ( view , function , block Node , map , parent Group ) ; } return map ; }
public void sort ( ) { Collections . sort ( tasks ) ; for ( Plot Item subitem : subitems ) { subitem . sort ( ) ; } }
public static void symbols ( Print Stream out , boolean emit non terms ) { terminal term ; non terminal nt ; long start time = System . current Time Millis ( ) ; out . println ( ) ; out . println ( STR_ ) ; out . println ( STR_ + version . title str ) ; out . println ( STR_ + new Date ( ) ) ; out . println ( STR_ ) ; out . println ( ) ; emit package ( out ) ; out . println ( STR_ ) ; out . println ( STR_ + symbol const class name + STR_ ) ; out . println ( STR_ ) ; for ( Enumeration e = terminal . all ( ) ; e . has More Elements ( ) ; ) { term = ( terminal ) e . next Element ( ) ; out . println ( STR_ + term . name ( ) + STR_ + term . index ( ) + STR_ ) ; } if ( emit non terms ) { out . println ( STR_ ) ; for ( Enumeration e = non terminal . all ( ) ; e . has More Elements ( ) ; ) { nt = ( non terminal ) e . next Element ( ) ; out . println ( STR_ + nt . name ( ) + STR_ + nt . index ( ) + STR_ ) ; } } out . println ( STR_ ) ; symbols time = System . current Time Millis ( ) - start time ; }
private J Panel make Preview Panel ( ) { J Panel preview Panel = new J Panel ( ) ; preview Panel . set Layout ( new Box Layout ( preview Panel , Box Layout . Y AXIS ) ) ; preview Panel . add ( preview Label ) ; preview = new J Panel ( ) ; J Scroll Pane js = new J Scroll Pane ( preview ) ; preview Panel . add ( js ) ; return preview Panel ; }
public void add Lock ( Table table ) { if ( Sys Properties . CHECK ) { if ( locks . contains ( table ) ) { Db Exception . throw Internal Error ( ) ; } } locks . add ( table ) ; }
@ Specialization ( rewrite On = Slow Path Exception . class ) protected int do Integer Sequence Position ( R Abstract Vector left , Object left Store , int left Base , int left Length , Object target Dimensions , @ Suppress Warnings ( STR_ ) int target Dimension , Object [ ] positions , R Int Sequence position , int position Offset , int position Length , R Typed Value right , Object right Store , int right Base , int right Length , boolean parent NA , @ Cached ( STR_ ) Int Value Profile start Profile , @ Cached ( STR_ ) Int Value Profile stride Profile , @ Cached ( STR_ ) Condition Profile condition Profile , @ Cached ( STR_ ) Loop Condition Profile profile ) throws Slow Path Exception { int right Index = right Base ; int start = start Profile . profile ( position . get Start ( ) - NUM_ ) ; int stride = stride Profile . profile ( position . get Stride ( ) ) ; int end = start + position Length * stride ; if ( start < NUM_ || end <= NUM_ ) { throw new Slow Path Exception ( STR_ ) ; } init Right Index Check ( right Base , position Length , left Length , right Length ) ; boolean ascending = condition Profile . profile ( start < end ) ; profile . profile Counted ( position Length ) ; for ( int position Value = start ; profile . inject ( ascending ? position Value < end : position Value > end ) ; position Value += stride ) { right Index = apply Inner ( left , left Store , left Base , left Length , target Dimensions , positions , position Offset , position Value , right , right Store , right Length , right Index , parent NA ) ; } return right Index ; }
public M Security Manager ( ) { privileged Threads = new Copy On Write Array Set < > ( ) ; privileged Threads . add ( Thread . current Thread ( ) ) ; default Manager = System . get Security Manager ( ) ; executing Test Case = false ; privileged Thread To Ignore = null ; unrecognized Permissions = new Copy On Write Array Set < > ( ) ; files To Delete = new Copy On Write Array Set < > ( ) ; }
public String generate Device Specific Remove Volumes Workflow ( Workflow workflow , String previous Step , Export Group export Group , Export Mask mask , Storage System storage , List < URI > volumes To Remove , List < URI > initiator UR Is , Export Task Completer completer ) throws Exception { String un Mask Step = generate Export Mask Remove Volumes Workflow ( workflow , previous Step , storage , export Group , mask , volumes To Remove , initiator UR Is , completer ) ; return generate Zoning Remove Volumes Workflow ( workflow , un Mask Step , export Group , Arrays . as List ( mask ) , volumes To Remove ) ; }
public static void cleanup Collection Level Snapshots ( Solr Zk Client zk Client , String collection Name ) throws Interrupted Exception , Keeper Exception { String zk Path = get Snapshot Meta Data Zk Path ( collection Name , Optional . empty ( ) ) ; try { Collection < String > snapshots = zk Client . get Children ( zk Path , null , true ) ; for ( String snapshot : snapshots ) { String path = get Snapshot Meta Data Zk Path ( collection Name , Optional . of ( snapshot ) ) ; try { zk Client . delete ( path , - NUM_ , true ) ; } catch ( Keeper Exception ex ) { if ( ex . code ( ) != Keeper Exception . Code . NONODE ) { throw ex ; } } } zk Client . delete ( zk Path , - NUM_ , true ) ; } catch ( Keeper Exception ex ) { if ( ex . code ( ) != Keeper Exception . Code . NONODE ) { throw ex ; } } }
private void grow ( int min Capacity ) { int old Capacity = element Data . length ; int new Capacity = old Capacity + ( old Capacity > > NUM_ ) ; if ( new Capacity - min Capacity < NUM_ ) new Capacity = min Capacity ; if ( new Capacity - MAX ARRAY SIZE > NUM_ ) new Capacity = huge Capacity ( min Capacity ) ; element Data = Arrays . copy Of ( element Data , new Capacity ) ; }
public void inv Dct In Place Nx N ( double [ ] [ ] coeffs ) { int u = NUM_ ; int v = NUM_ ; double two over sqrtncolsnrows = NUM_ / Math . sqrt ( ( double ) this . N * this . M ) ; for ( u = NUM_ ; u <= this . M - NUM_ ; u ++ ) { inv Fct No Scale ( coeffs [ u ] ) ; } for ( v = NUM_ ; v <= this . N - NUM_ ; v ++ ) { for ( u = NUM_ ; u <= this . M - NUM_ ; u ++ ) { this . nxn Tmp [ u ] = coeffs [ u ] [ v ] ; } inv Fct No Scale ( this . nxn Tmp ) ; for ( u = NUM_ ; u <= this . M - NUM_ ; u ++ ) { coeffs [ u ] [ v ] = this . nxn Tmp [ u ] * two over sqrtncolsnrows ; } } }
private void calculate Unique Value ( Object [ ] min Value , Object [ ] unique Value ) { for ( int i = NUM_ ; i < measure Count ; i ++ ) { if ( type [ i ] == Carbon Common Constants . BIG INT MEASURE ) { unique Value [ i ] = ( long ) min Value [ i ] - NUM_ ; } else if ( type [ i ] == Carbon Common Constants . BIG DECIMAL MEASURE ) { Big Decimal val = ( Big Decimal ) min Value [ i ] ; unique Value [ i ] = ( val . subtract ( new Big Decimal ( NUM_ ) ) ) ; } else { unique Value [ i ] = ( double ) min Value [ i ] - NUM_ ; } } }
static String debug Encode ( String input ) { final int n = input . length ( ) ; String Builder buf = new String Builder ( n * NUM_ ) ; for ( int i = NUM_ ; i < n ; ++ i ) { char ch = input . char At ( i ) ; switch ( ch ) { case STR_ : buf . append ( STR_ ) ; break ; case STR_ : buf . append ( STR_ ) ; break ; case STR_ : buf . append ( STR_ ) ; break ; case STR_ : buf . append ( STR_ ) ; break ; case STR_ : buf . append ( STR_ ) ; break ; case STR_ : buf . append ( STR_ ) ; break ; default : if ( STR_ <= ch && ch <= STR_ ) { buf . append ( ch ) ; } else { buf . append ( String . format ( STR_ , ( int ) ch ) ) ; } break ; } } return buf . to String ( ) ; }
@ Override public void load XML ( Node stepnode , List < Database Meta > databases , Map < String , Counter > counters ) throws Kettle XML Exception { try { database Name = XML Handler . get Tag Value ( stepnode , STR_ ) ; tabel Name = XML Handler . get Tag Value ( stepnode , STR_ ) ; mdkey Size = XML Handler . get Tag Value ( stepnode , STR_ ) ; measure Count = XML Handler . get Tag Value ( stepnode , STR_ ) ; heir And Key Size = XML Handler . get Tag Value ( stepnode , STR_ ) ; table Name = XML Handler . get Tag Value ( stepnode , STR_ ) ; group By Enabled = XML Handler . get Tag Value ( stepnode , STR_ ) ; aggregator Class String = XML Handler . get Tag Value ( stepnode , STR_ ) ; aggregator String = XML Handler . get Tag Value ( stepnode , STR_ ) ; fact Dim Lens String = XML Handler . get Tag Value ( stepnode , STR_ ) ; level Anddata Type String = XML Handler . get Tag Value ( stepnode , STR_ ) ; partition ID = XML Handler . get Tag Value ( stepnode , STR_ ) ; segment Id = XML Handler . get Tag Value ( stepnode , STR_ ) ; task No = XML Handler . get Tag Value ( stepnode , STR_ ) ; } catch ( Exception e ) { throw new Kettle XML Exception ( STR_ , e ) ; } }
protected J Popup Menu build Popup Menu ( ) { J Popup Menu ret = new J Popup Menu ( ) ; if ( get Data ( ) instanceof Mutable Table ) { if ( show Insert Row Popup Menu ) { ret . add ( Table Action Manager . get Insert Row Action ( this ) ) ; } if ( show Insert Column Popup Menu ) { if ( get Selected Column ( ) >= NUM_ ) { ret . add ( Table Action Manager . get Insert Column Action ( this ) ) ; } } if ( show Delete Row Popup Menu ) { ret . add ( Table Action Manager . get Delete Row Action ( this ) ) ; } if ( show Delete Column Popup Menu ) { if ( get Selected Column ( ) != NUM_ ) { ret . add ( Table Action Manager . get Delete Column Action ( this ) ) ; } } } if ( show Edit In Popup Menu ) { J Menu Item edit Item = get Menu Edit ( ) ; if ( edit Item != null ) { ret . add ( edit Item ) ; } } if ( show Randomize In Popup Menu ) { J Menu Item randomize Item = get Menu Randomize ( ) ; if ( randomize Item != null ) { ret . add ( randomize Item ) ; } } if ( show Normalize In Popup Menu ) { J Menu Item normalize Item = get Menu Normalize ( ) ; if ( normalize Item != null ) { ret . add ( normalize Item ) ; } } if ( show Fill In Popup Menu ) { J Menu Item fill Item = get Menu Fill ( ) ; if ( fill Item != null ) { ret . add ( fill Item ) ; } } return ret ; }
public static Container Description build Core Agent Container Description ( ) { Container Description cd = new Container Description ( ) ; cd . document Self Link = AGENT CONTAINER DESCRIPTION LINK ; cd . name = AGENT CONTAINER NAME ; cd . image = get Agent Image Name And Version ( ) ; cd . publish All = true ; cd . volumes = AGENT CONTAINER VOLUMES ; cd . restart Policy = STR_ ; return cd ; }
void add Event Info ( long event Id , boolean all Day , long begin , int reminder Minutes ) { m Events . add ( new Event Info ( event Id , all Day , begin , reminder Minutes ) ) ; }
public void update Srl Streams ( String active , List < String > popout ) { srl Streams . remove All ( ) ; if ( active == null || active . is Empty ( ) ) { add Item ( srl Streams , STR_ , STR_ ) ; } else { add Item ( srl Streams , STR_ , active ) ; } if ( ! popout . is Empty ( ) ) { srl Streams . add Separator ( ) ; for ( String chan : popout ) { add Item ( srl Streams , STR_ + chan , chan ) ; } } }
public boolean accept ( File dir , String name ) { return extensions . contains ( get Extension ( name ) ) ; }
protected void connection Down ( ) { if ( connected Status != null ) { connected Status . set Text ( STATUS IDLE ) ; connected Status . set Background ( Color . red ) ; } }
private Widget pack Widget ( int dpi , Widget Preview Loader preview Loader , Icon Cache icon Cache , Component Name provider ) { final App Widget Provider Info info = find App Widget Provider Info ( provider ) ; Widget widget = new Widget ( ) ; widget . provider = provider . flatten To Short String ( ) ; widget . label = info . label ; widget . configure = info . configure != null ; if ( info . icon != NUM_ ) { widget . icon = new Resource ( ) ; Drawable full Res Icon = icon Cache . get Full Res Icon ( provider . get Package Name ( ) , info . icon ) ; Bitmap icon = Utilities . create Icon Bitmap ( full Res Icon , m Context ) ; Byte Array Output Stream os = new Byte Array Output Stream ( ) ; if ( icon . compress ( IMAGE FORMAT , IMAGE COMPRESSION QUALITY , os ) ) { widget . icon . data = os . to Byte Array ( ) ; widget . icon . dpi = dpi ; } } if ( info . preview Image != NUM_ ) { widget . preview = new Resource ( ) ; Bitmap preview = preview Loader . generate Widget Preview ( info , null ) ; Byte Array Output Stream os = new Byte Array Output Stream ( ) ; if ( preview . compress ( IMAGE FORMAT , IMAGE COMPRESSION QUALITY , os ) ) { widget . preview . data = os . to Byte Array ( ) ; widget . preview . dpi = dpi ; } } return widget ; }
public static SSL Server Socket Factory make SSL Socket Factory ( Key Store loaded Key Store , Key Manager Factory loaded Key Factory ) throws IO Exception { try { return make SSL Socket Factory ( loaded Key Store , loaded Key Factory . get Key Managers ( ) ) ; } catch ( Exception e ) { throw new IO Exception ( e . get Message ( ) ) ; } }
public Fetched Data handle ( Content Handler Args args , Message Queue mq ) { Fetched Data result = do Handle ( args , mq ) ; if ( result == null ) { Byte Array Output Stream intermediate Response = new Byte Array Output Stream ( ) ; Pair < Content Type , String > content Params = get Returned Content Params ( args ) ; Output Stream Writer writer = new Output Stream Writer ( intermediate Response , Charsets . UTF 8 ) ; try { render As JSON ( ( String ) null , ( String ) null , content Params . b , mq , writer , false ) ; } catch ( IO Exception e ) { throw new Something Widgy Happened Error ( e ) ; } result = Fetched Data . from Bytes ( intermediate Response . to Byte Array ( ) , content Params . a . mime Type , STR_ , Input Source . UNKNOWN ) ; } return result ; }
public boolean add Note ( Note bug , Note Comment comment ) { if ( bug . is New ( ) ) { Log . d ( DEBUG TAG , STR_ ) ; Http URL Connection connection = null ; try { try { String encoded Comment = URL Encoder . encode ( comment . get Text ( ) , STR_ ) ; URL add Note Url = get Add Note Url ( ( bug . get Lat ( ) / NUM_ ) , ( bug . get Lon ( ) / NUM_ ) , encoded Comment ) ; connection = open Connection For Write Access ( add Note Url , STR_ , STR_ ) ; Output Stream Writer out = new Output Stream Writer ( connection . get Output Stream ( ) , Charset . default Charset ( ) ) ; out . flush ( ) ; if ( connection . get Response Code ( ) != Http URL Connection . HTTP OK ) { throw Unexpected Request Exception ( connection ) ; } parse Bug ( bug , connection . get Input Stream ( ) ) ; return true ; } catch ( Xml Pull Parser Exception e ) { Log . e ( DEBUG TAG , STR_ , e ) ; } catch ( IO Exception e ) { Log . e ( DEBUG TAG , STR_ , e ) ; } } finally { disconnect ( connection ) ; } } return false ; }
public static int height ( final Segment document , final int max Width , final Font Renderer renderer ) { int current X = NUM_ ; int current Y = NUM_ ; Segment segment = document ; while ( segment != null ) { current Y += segment . next Y ( current X , max Width , renderer ) ; current X = segment . next X ( current X , max Width , renderer ) ; segment = segment . next ( ) ; } return current Y ; }
void deregister Spring ( Spring spring ) { if ( spring == null ) { throw new Illegal Argument Exception ( STR_ ) ; } m Active Springs . remove ( spring ) ; m Spring Registry . remove ( spring . get Id ( ) ) ; }
@ Override public void end Window ( ) { if ( current Window Id > window Data Manager . get Largest Completed Window ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holding Buffer . poll ( ) ) != null ) { process Message ( msg ) ; emit Count ++ ; last Msg = msg ; } window Data Manager . save ( current Window Recovery State , current Window Id ) ; current Window Recovery State . clear ( ) ; if ( last Msg != null ) { acknowledge ( ) ; } pending Ack . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emit Count = NUM_ ; } else if ( current Window Id < window Data Manager . get Largest Completed Window ( ) ) { pending Ack . clear ( ) ; } context . set Counters ( counters ) ; }
public void fire Property Change ( String name , Object old Value , Object new Value ) { bean Context Child Support . fire Property Change ( name , old Value , new Value ) ; }
private static int escape ( char [ ] cc , char c , int index ) { cc [ index ++ ] = STR_ ; cc [ index ++ ] = Character . for Digit ( ( c > > NUM_ ) & NUM_ , NUM_ ) ; cc [ index ++ ] = Character . for Digit ( c & NUM_ , NUM_ ) ; return index ; }
public void traverse ( Object vertex , boolean directed , mx I Cell Visitor visitor , Object edge , Set < Object > visited ) { if ( vertex != null && visitor != null ) { if ( visited == null ) { visited = new Hash Set < Object > ( ) ; } if ( ! visited . contains ( vertex ) ) { visited . add ( vertex ) ; if ( visitor . visit ( vertex , edge ) ) { int edge Count = model . get Edge Count ( vertex ) ; if ( edge Count > NUM_ ) { for ( int i = NUM_ ; i < edge Count ; i ++ ) { Object e = model . get Edge At ( vertex , i ) ; boolean is Source = model . get Terminal ( e , true ) == vertex ; if ( ! directed || is Source ) { Object next = model . get Terminal ( e , ! is Source ) ; traverse ( next , directed , visitor , e , visited ) ; } } } } } } }
public void cleanup ( ) { if ( ! this . keeper Cleaned Up ) { this . keeper Cleaned Up = true ; keeper . remove ( get Processor Id ( ) ) ; } }
public static Properties load Properties ( String configuration Path ) throws Exception { Properties props = new Properties ( ) ; try ( File Input Stream input Stream = new File Input Stream ( configuration Path ) ) { props . load ( input Stream ) ; } return props ; }
public void randomize ( ) { int n Probs = m f Probs [ NUM_ ] . length ; Random random = new Random ( ) ; for ( int i = NUM_ ; i < m f Probs . length ; i ++ ) { for ( int j = NUM_ ; j < n Probs - NUM_ ; j ++ ) { m f Probs [ i ] [ j ] = random . next Double ( ) ; } for ( int j = NUM_ ; j < n Probs - NUM_ ; j ++ ) { for ( int k = j + NUM_ ; k < n Probs - NUM_ ; k ++ ) { if ( m f Probs [ i ] [ j ] > m f Probs [ i ] [ k ] ) { double h = m f Probs [ i ] [ j ] ; m f Probs [ i ] [ j ] = m f Probs [ i ] [ k ] ; m f Probs [ i ] [ k ] = h ; } } } double sum = m f Probs [ i ] [ NUM_ ] ; for ( int j = NUM_ ; j < n Probs - NUM_ ; j ++ ) { m f Probs [ i ] [ j ] = m f Probs [ i ] [ j ] - sum ; sum += m f Probs [ i ] [ j ] ; } m f Probs [ i ] [ n Probs - NUM_ ] = NUM_ - sum ; } }
private void add Processor Options ( Map < Plugin Util . Checker Prop , Object > opts , I Preference Store store ) { String skip Uses = store . get String ( Checker Preferences . PREF CHECKER A SKIP CLASSES ) ; if ( ! skip Uses . is Empty ( ) ) { opts . put ( Plugin Util . Checker Prop . A SKIP , skip Uses ) ; } String lint Opts = store . get String ( Checker Preferences . PREF CHECKER A LINT ) ; if ( ! lint Opts . is Empty ( ) ) { opts . put ( Plugin Util . Checker Prop . A LINT , lint Opts ) ; } if ( store . get Boolean ( Checker Preferences . PREF CHECKER A WARNS ) ) { opts . put ( Plugin Util . Checker Prop . A WARNS , Boolean . TRUE ) ; } if ( store . get Boolean ( Checker Preferences . PREF CHECKER A NO MSG TEXT ) ) opts . put ( Plugin Util . Checker Prop . A NO MSG TXT , Boolean . TRUE ) ; if ( store . get Boolean ( Checker Preferences . PREF CHECKER A SHOW CHECKS ) ) opts . put ( Plugin Util . Checker Prop . A SHOW CHECKS , Boolean . TRUE ) ; if ( store . get Boolean ( Checker Preferences . PREF CHECKER A FILENAMES ) ) opts . put ( Plugin Util . Checker Prop . A FILENAMES , Boolean . TRUE ) ; }
public void hide Keyboard ( ) { appium Driver . hide Keyboard ( ) ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; if ( lineno < NUM_ ) throw new Invalid Object Exception ( STR_ + STR_ ) ; if ( override < NUM_ ) throw new Invalid Object Exception ( STR_ + STR_ ) ; if ( description == null ) throw new Invalid Object Exception ( STR_ + STR_ ) ; if ( t instanceof Error ) throw new Invalid Object Exception ( STR_ + STR_ ) ; }
public void annotate ( Method Invocation Tree tree , Annotated Executable Type type ) { if ( poly Quals . is Empty ( ) ) return ; if ( Tree Utils . is Enum Super ( tree ) ) return ; List < Annotated Type Mirror > required Args = Annotated Types . expand Var Args ( atype Factory , type , tree . get Arguments ( ) ) ; List < Annotated Type Mirror > arguments = Annotated Types . get Annotated Types ( atype Factory , required Args , tree . get Arguments ( ) ) ; Map < Annotation Mirror , Set < ? extends Annotation Mirror > > matching Mapping = collector . visit ( arguments , required Args ) ; if ( type . get Receiver Type ( ) != null && ! Tree Utils . is Super Call ( tree ) && ! Tree Utils . is This Call ( tree ) ) { matching Mapping = collector . reduce ( matching Mapping , collector . visit ( atype Factory . get Receiver Type ( tree ) , type . get Receiver Type ( ) ) ) ; } if ( matching Mapping != null && ! matching Mapping . is Empty ( ) ) { replacer . visit ( type , matching Mapping ) ; } else { completer . visit ( type ) ; } }
public synchronized boolean generate ( Projection p , boolean force Project All ) { boolean is Generated = super . generate ( p , force Project All ) ; General Path projected Shape = get Shape ( ) ; if ( projected Shape != null ) { projected Shape . close Path ( ) ; } return is Generated ; }
public synchronized void add Pv Change Listener ( Pv Change Listener l , int event Mask ) { Object old Listener = Pv Change Listeners . get ( l ) ; Pv Change Listeners . put ( l , new Integer ( event Mask ) ) ; if ( old Listener == null ) { log . debug ( STR_ + String . value Of ( this ) + STR_ + String . value Of ( l ) ) ; } }
protected Image trim Excess Pixels ( ) { if ( filtered Width <= width && filtered Height <= height ) { if ( DEBUG ) { logger . fine ( STR_ ) ; } return null ; } if ( DEBUG ) { logger . fine ( STR_ ) ; } float width Scale = ( float ) filtered Width / ( float ) width ; float height Scale = ( float ) filtered Height / ( float ) height ; int start X Pixel In Source = point 1 . x < NUM_ ? ( int ) ( ( - NUM_ * point 1 . x ) / width Scale ) : NUM_ ; int start Y Pixel In Source = point 1 . y < NUM_ ? ( int ) ( ( - NUM_ * point 1 . y ) / height Scale ) : NUM_ ; Point scaled Dim = new Point ( ( int ) ( point 1 . x + ( width * width Scale ) ) , ( int ) ( point 1 . y + ( height * height Scale ) ) ) ; int end X Pixel In Source = ( scaled Dim . x > proj Width ? ( int ) ( ( proj Width - point 1 . x ) / width Scale ) + NUM_ : width ) ; int end Y Pixel In Source = scaled Dim . y > proj Height ? ( int ) ( ( proj Height - point 1 . y ) / height Scale ) + NUM_ : height ; if ( DEBUG ) { logger . fine ( STR_ + start X Pixel In Source + STR_ + start Y Pixel In Source + STR_ + end X Pixel In Source + STR_ + end Y Pixel In Source ) ; } if ( DEBUG ) { logger . fine ( STR_ + STR_ + ( int ) ( ( end X Pixel In Source - start X Pixel In Source ) * width Scale ) + STR_ + ( int ) ( ( end Y Pixel In Source - start Y Pixel In Source ) * height Scale ) ) ; } Pixel Grabber pg = new Pixel Grabber ( bitmap , start X Pixel In Source , start Y Pixel In Source , end X Pixel In Source - start X Pixel In Source , end Y Pixel In Source - start Y Pixel In Source , true ) ; int [ ] pix = Image Helper . grab Pixels ( pg ) ; if ( pix == null ) { return null ; } actual Filter = new Trim Scale Filter ( ( int ) ( ( end X Pixel In Source - start X Pixel In Source ) * width Scale ) , ( int ) ( ( end Y Pixel In Source - start Y Pixel In Source ) * height Scale ) , algorithm Type ) ; Toolkit tk = Toolkit . get Default Toolkit ( ) ; Image image = tk . create Image ( new Memory Image Source ( end X Pixel In Source - start X Pixel In Source , end Y Pixel In Source - start Y Pixel In Source , pix , NUM_ , end X Pixel In Source - start X Pixel In Source ) ) ; return image ; }
private Workflow . Method create Rollback Forget Volumes Method ( URI vplex System URI , List < URI > volume UR Is ) { return new Workflow . Method ( RB FORGET VOLUMES METHOD NAME , vplex System URI , volume UR Is ) ; }
public final void decrease Scheduled Write Messages ( ) { throughput Calculation Lock . lock ( ) ; try { scheduled Write Messages -- ; } finally { throughput Calculation Lock . unlock ( ) ; } }
public int decrypt Block ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STR_ ) ; } if ( ( out Off + block Size ) > out . length ) { throw new Data Length Exception ( STR_ ) ; } cipher . process Block ( cfb V , NUM_ , cfb Out V , NUM_ ) ; System . arraycopy ( cfb V , block Size , cfb V , NUM_ , cfb V . length - block Size ) ; System . arraycopy ( in , in Off , cfb V , cfb V . length - block Size , block Size ) ; for ( int i = NUM_ ; i < block Size ; i ++ ) { out [ out Off + i ] = ( byte ) ( cfb Out V [ i ] ^ in [ in Off + i ] ) ; } return block Size ; }
public void acquire Write Lock On Key ( K id ) { if ( id == null ) { LOGGER . error ( STR_ ) ; throw new Illegal Argument Exception ( STR_ ) ; } if ( LOGGER . is Trace Enabled ( ) ) { LOGGER . trace ( cache . get Name ( ) + STR_ + String . value Of ( id ) ) ; } cache . acquire Write Lock On Key ( id ) ; if ( LOGGER . is Trace Enabled ( ) ) { LOGGER . trace ( cache . get Name ( ) + STR_ + String . value Of ( id ) ) ; } }
private void update Server Settings File ( ) { Map < String , String > properties Map = current Settings . properties Map ( ) ; if ( properties Map . is Empty ( ) ) { return ; } File old File = new File ( NEO 4 J CONF ) ; try { debug ( STR_ + old File . get Canonical Path ( ) ) ; for ( Map . Entry < String , String > property : properties Map . entry Set ( ) ) { String name = property . get Key ( ) ; Object value = property . get Value ( ) ; debug ( STR_ , name , value ) ; } update Properties ( old File , properties Map , current Settings . excludes ( ) ) ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
private String build Job Trigger Name ( String file Basename ) { String job Trigger Name = JOB INITIALIZATION PLUGIN NAME + STR_ + get Name ( ) + STR_ + file Basename . replace ( STR_ , STR_ ) ; if ( job Trigger Name . length ( ) > MAX JOB TRIGGER NAME LEN ) { job Trigger Name = job Trigger Name . substring ( NUM_ , MAX JOB TRIGGER NAME LEN ) ; } int current Index = NUM_ ; while ( job Trigger Name Set . add ( job Trigger Name ) == false ) { if ( current Index > NUM_ ) { job Trigger Name = job Trigger Name . substring ( NUM_ , job Trigger Name . last Index Of ( STR_ ) ) ; } String numeric Suffix = STR_ + current Index ++ ; if ( job Trigger Name . length ( ) > ( MAX JOB TRIGGER NAME LEN - numeric Suffix . length ( ) ) ) { job Trigger Name = job Trigger Name . substring ( NUM_ , ( MAX JOB TRIGGER NAME LEN - numeric Suffix . length ( ) ) ) ; } job Trigger Name += numeric Suffix ; } return job Trigger Name ; }
public synchronized void remove Property Change Listener ( String property Name , Property Change Listener listener ) { if ( listener == null || change Support == null ) { return ; } change Support . remove Property Change Listener ( property Name , listener ) ; }
protected final void fire Property Change ( String property Name , int old Value , int new Value ) { Property Change Support a Change Support = this . change Support ; if ( a Change Support == null ) { return ; } a Change Support . fire Property Change ( property Name , Integer . value Of ( old Value ) , Integer . value Of ( new Value ) ) ; }
@ Request Mapping ( value = STR_ , method = Request Method . GET ) public void metadata Default Tenant ( Locale locale , Model model , Http Servlet Response response ) throws IO Exception { logger . info ( STR_ , locale . to String ( ) ) ; metadata ( locale , Shared . get Default Tenant ( ) , model , response ) ; }
public static String format Csv ( Number nr ) { if ( nr == null ) { return STR_ ; } return nr . to String ( ) ; }
public ASCII Hex Output Stream ( Output Stream out ) { super ( out ) ; characters = MAX CHARS PER LINE ; end = false ; try { newline = System . get Property ( STR_ ) ; } catch ( Security Exception e ) { } }
public static void fix Tab Keys ( final J Component component ) { final Set < AWT Key Stroke > forward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS ) ) ; forward . add ( Key Stroke . get Key Stroke ( STR_ ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . FORWARD TRAVERSAL KEYS , forward ) ; final Set < AWT Key Stroke > backward = new Hash Set < AWT Key Stroke > ( component . get Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS ) ) ; backward . add ( Key Stroke . get Key Stroke ( STR_ ) ) ; component . set Focus Traversal Keys ( Keyboard Focus Manager . BACKWARD TRAVERSAL KEYS , backward ) ; }
public Member Select Tree build Iterator Method Access ( Expression Tree iterable Expr ) { Declared Type expr Type = ( Declared Type ) Types Utils . upper Bound ( Internal Utils . type Of ( iterable Expr ) ) ; assert expr Type != null : STR_ ; Type Element expr Element = ( Type Element ) expr Type . as Element ( ) ; Symbol . Method Symbol iterator Method = null ; for ( Executable Element method : Element Filter . methods In ( elements . get All Members ( expr Element ) ) ) { Name method Name = method . get Simple Name ( ) ; if ( method . get Parameters ( ) . size ( ) == NUM_ ) { if ( method Name . content Equals ( STR_ ) ) { iterator Method = ( Symbol . Method Symbol ) method ; } } } assert iterator Method != null : STR_ ; Type . Method Type method Type = ( Type . Method Type ) iterator Method . as Type ( ) ; Symbol . Type Symbol method Class = method Type . as Element ( ) ; Declared Type iterator Type = ( Declared Type ) method Type . get Return Type ( ) ; Type Mirror element Type ; if ( iterator Type . get Type Arguments ( ) . size ( ) > NUM_ ) { element Type = iterator Type . get Type Arguments ( ) . get ( NUM_ ) ; if ( element Type instanceof Type . Captured Type ) { element Type = ( ( Type . Captured Type ) element Type ) . wildcard ; } iterator Type = model Types . get Declared Type ( ( Type Element ) model Types . as Element ( iterator Type ) , element Type ) ; } Type . Method Type updated Method Type = new Type . Method Type ( com . sun . tools . javac . util . List . < Type > nil ( ) , ( Type ) iterator Type , com . sun . tools . javac . util . List . < Type > nil ( ) , method Class ) ; JC Tree . JC Field Access iterator Access = ( JC Tree . JC Field Access ) maker . Select ( ( JC Tree . JC Expression ) iterable Expr , iterator Method ) ; iterator Access . set Type ( updated Method Type ) ; return iterator Access ; }
protected void reject Drop ( ) { Drop Target Context Peer peer = get Drop Target Context Peer ( ) ; if ( peer != null ) { peer . reject Drop ( ) ; } }
public static void update Artwork ( Movie Set movie Set ) { find Artwork In Artwork Folder ( movie Set ) ; for ( Movie movie : new Array List < > ( movie Set . get Movies ( ) ) ) { find Artwork In Movie Folder ( movie Set , movie ) ; } }
public String generate Challan ( final Receipt Header receipt , final boolean flag ) { final List < Bill Receipt Info > receipt List = new Array List < Bill Receipt Info > ( NUM_ ) ; receipt List . add ( new Bill Receipt Info Impl ( receipt , egov Common , new Receipt Header ( ) , chart Of Accounts Hibernate DAO , persistence Service ) ) ; final String template Name = Collection Constants . CHALLAN TEMPLATE NAME ; final Map < String , Object > report Params = new Hash Map < String , Object > ( NUM_ ) ; report Params . put ( STR_ , egov Common ) ; final Report Request report Input = new Report Request ( template Name , receipt List , report Params ) ; report Input . set Print Dialog On Open Report ( flag ) ; return report Viewer Util . add Report To Temp Cache ( collections Util . create Report ( report Input ) ) ; }
private static int uarimax Le ( double value , double [ ] bv , int [ ] bvi , Binary Operator b Op ) throws DML Runtime Exception { int ix Max = bv . length ; if ( value <= bv [ NUM_ ] || value > bv [ bv . length - NUM_ ] ) return ix Max ; int ix = Arrays . binary Search ( bv , value ) ; if ( ix < NUM_ ) ix = Math . abs ( ix ) - NUM_ ; ix Max = bvi [ ix ] + NUM_ ; return ix Max ; }
public static Plugin load Custom Plugin ( URL url String , @ Check For Null Project project ) throws Plugin Exception { Plugin plugin = add Custom Plugin ( url String ) ; if ( project != null ) { project . set Plugin Status Trinary ( plugin . get Plugin Id ( ) , true ) ; } return plugin ; }
private void report Exception ( Kind kind , Element element , Throwable t ) { String Writer buf = new String Writer ( ) ; t . print Stack Trace ( new Print Writer ( buf ) ) ; buf . to String ( ) ; message ( kind , element , STR_ , buf . to String ( ) ) ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . mark Supported ( ) ) bytes Left At Mark = bytes Left ; }
public synchronized void unregister ( Object subscriber , Class < ? > ... event Types ) { if ( event Types . length == NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } List < Class < ? > > subscribed Classes = types By Subscriber . get ( subscriber ) ; if ( subscribed Classes != null ) { for ( Class < ? > event Type : event Types ) { unubscribe By Event Type ( subscriber , event Type ) ; subscribed Classes . remove ( event Type ) ; } if ( subscribed Classes . is Empty ( ) ) { types By Subscriber . remove ( subscriber ) ; } } else { Log . w ( TAG , STR_ + subscriber . get Class ( ) ) ; } }
public static String encode Path ( String path ) { return encode Path ( path , true ) ; }
private void check Token ( String token ) { for ( int i = NUM_ ; i < token . length ( ) ; i ++ ) { char ch = token . char At ( i ) ; if ( ! TOKEN . get ( ch ) ) { throw new Illegal Argument Exception ( STR_ + ch + STR_ + token + STR_ ) ; } } }
public Outfit Changer Behaviour ( final Map < String , Integer > price List ) { this ( price List , NEVER WEARS OFF , null ) ; }
public int hash Code ( ) { try { byte [ ] b 1 = get Encoded Internal ( ) ; int r = b 1 . length ; for ( int i = NUM_ ; i < b 1 . length ; i ++ ) { r += ( b 1 [ i ] & NUM_ ) * NUM_ ; } return r ; } catch ( Invalid Key Exception e ) { return NUM_ ; } }
public static File create Temp File ( ) { File temp File ; try { temp File = File . create Temp File ( STR_ , STR_ ) ; } catch ( Exception e ) { throw new Illegal State Exception ( STR_ , e ) ; } return temp File ; }
private Plan build Plan 2 ( ) { Plan plan = Population Utils . create Plan ( ) ; Activity a = Population Utils . create Activity From Coord ( STR_ , Coord Utils . create Coord ( NUM_ , NUM_ ) ) ; a . set End Time ( Time . parse Time ( STR_ ) ) ; plan . add Activity ( a ) ; plan . add Leg ( Population Utils . create Leg ( STR_ ) ) ; double travel Time = Time . parse Time ( STR_ ) ; double distance = Math . round ( ( travel Time * Chain Chopper . AVERAGE SPEED ) / Chain Chopper . CROWFLY FACTOR ) ; Activity b = Population Utils . create Activity From Coord ( STR_ , Coord Utils . create Coord ( distance , NUM_ ) ) ; b . set Maximum Duration ( Time . parse Time ( STR_ ) ) ; plan . add Activity ( b ) ; plan . add Leg ( Population Utils . create Leg ( STR_ ) ) ; Activity c = Population Utils . create Activity From Coord ( STR_ , Coord Utils . create Coord ( NUM_ * distance , NUM_ ) ) ; plan . add Activity ( c ) ; return plan ; }
public static Volume Mount [ ] format Flume Container Volume Mount ( Log Draft log Draft ) { List < Volume Mount > volume Mounts = new Array List < > ( ) ; int idx Suffix = NUM_ ; for ( Log Item Draft log Item Draft : log Draft . get Log Item Drafts ( ) ) { if ( log Item Draft . is Auto Collect ( ) || log Item Draft . is Auto Delete ( ) ) { Volume Mount volume Mount = new Volume Mount ( ) ; volume Mount . set Name ( STR_ + idx Suffix ) ; volume Mount . set Mount Path ( FLUME MOUNT PATH PREFIX + idx Suffix ) ; volume Mounts . add ( volume Mount ) ; idx Suffix ++ ; } } return volume Mounts . to Array ( new Volume Mount [ ] { } ) ; }
protected boolean prompt Boolean ( final String prompt , final Optional < Boolean > default Value ) throws IO Exception { require Non Null ( prompt ) ; require Non Null ( default Value ) ; final Console Reader reader = get Reader ( ) ; reader . set Prompt ( prompt ) ; Boolean value = null ; boolean prompting = true ; while ( prompting ) { final String input = reader . read Line ( ) ; if ( input . is Empty ( ) && default Value . is Present ( ) ) { value = default Value . get ( ) ; prompting = false ; } if ( is Affirmative ( input ) ) { value = true ; prompting = false ; } if ( is Negative ( input ) ) { value = false ; prompting = false ; } if ( prompting ) { reader . println ( STR_ ) ; } } return value ; }
public static void parse Model To Content Values ( Object model , Content Values content Values ) { if ( content Values . size ( ) > NUM_ ) content Values . clear ( ) ; Class < ? > clazz = model . get Class ( ) ; Field [ ] fields = clazz . get Declared Fields ( ) ; Class < ? > field Type = null ; Object field Val = null ; for ( Field field : fields ) { try { if ( field . is Accessible ( ) == false ) field . set Accessible ( true ) ; Column column = field . get Annotation ( Column . class ) ; field Type = field . get Type ( ) ; field Val = field . get ( model ) ; if ( column == null || field Val == null ) continue ; if ( field Type . equals ( int . class ) ) { content Values . put ( column . name ( ) , field . get Int ( model ) ) ; } else if ( field Type . equals ( Integer . class ) ) { content Values . put ( column . name ( ) , ( Integer ) field . get ( model ) ) ; } else if ( field Type . equals ( short . class ) ) { content Values . put ( column . name ( ) , field . get Short ( model ) ) ; } else if ( field Type . equals ( Short . class ) ) { content Values . put ( column . name ( ) , ( Short ) field . get ( model ) ) ; } else if ( field Type . equals ( long . class ) ) { content Values . put ( column . name ( ) , field . get Long ( model ) ) ; } else if ( field Type . equals ( Long . class ) ) { content Values . put ( column . name ( ) , ( Long ) field . get ( model ) ) ; } else if ( field Type . equals ( float . class ) ) { content Values . put ( column . name ( ) , field . get Float ( model ) ) ; } else if ( field Type . equals ( Float . class ) ) { content Values . put ( column . name ( ) , ( Float ) field . get ( model ) ) ; } else if ( field Type . equals ( double . class ) ) { content Values . put ( column . name ( ) , field . get Double ( model ) ) ; } else if ( field Type . equals ( Double . class ) ) { content Values . put ( column . name ( ) , ( Double ) field . get ( model ) ) ; } else if ( field Type . equals ( boolean . class ) ) { if ( field . get Boolean ( model ) == true ) { content Values . put ( column . name ( ) , STR_ ) ; } else { content Values . put ( column . name ( ) , STR_ ) ; } } else if ( field Type . equals ( Boolean . class ) ) { if ( ( Boolean ) field . get ( model ) == true ) { content Values . put ( column . name ( ) , STR_ ) ; } else { content Values . put ( column . name ( ) , STR_ ) ; } } else if ( field Type . equals ( String . class ) ) { content Values . put ( column . name ( ) , ( String ) field . get ( model ) ) ; } else if ( field Type . equals ( byte [ ] . class ) ) { content Values . put ( column . name ( ) , ( byte [ ] ) field . get ( model ) ) ; } else if ( field Type . equals ( Date . class ) ) { Date date = ( Date ) field . get ( model ) ; content Values . put ( column . name ( ) , Date Utils . format Date 2 Str ( date ) ) ; } } catch ( Illegal Argument Exception e ) { e . print Stack Trace ( ) ; } catch ( Illegal Access Exception e ) { e . print Stack Trace ( ) ; } } }
void STAR encoding diag 1 ( ) { int i , j , stripe , k ; char [ ] [ ] tmp ; tmp = new char [ block nbr + NUM_ ] [ block size ] ; for ( stripe = NUM_ ; stripe < block nbr + NUM_ ; stripe ++ ) { for ( i = NUM_ ; i < data disk nbr ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { k = ( stripe - i + p ) % p ; if ( k < block nbr ) { tmp [ stripe ] [ j ] ^= check data [ i ] [ ( stripe - i + p ) % p * block size + j ] ; } } } } for ( i = NUM_ ; i < block nbr ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { tmp [ i ] [ j ] = ( char ) ( tmp [ i ] [ j ] ^ tmp [ block nbr ] [ j ] ) ; } } for ( i = NUM_ ; i < block nbr ; i ++ ) { System . arraycopy ( tmp [ i ] , NUM_ , check data [ data disk nbr + NUM_ ] , i * block size , block size ) ; } }
private final void add To Ties ( int id ) { if ( ties . length == numties ) { ties = Arrays . copy Of ( ties , ( ties . length << NUM_ ) + NUM_ ) ; } ties [ numties ] = id ; ++ numties ; }
public String preview Next Token ( ) { matcher . find ( ) ; String next One = matcher . group ( ) ; update Matcher ( ) ; return next One ; }
public Sort Response Control ( String id , boolean criticality , byte [ ] value ) throws IO Exception { super ( id , criticality , value ) ; Ber Decoder ber = new Ber Decoder ( value , NUM_ , value . length ) ; ber . parse Seq ( null ) ; result Code = ber . parse Enumeration ( ) ; if ( ( ber . bytes Left ( ) > NUM_ ) && ( ber . peek Byte ( ) == Ber . ASN CONTEXT ) ) { bad Attr Id = ber . parse String With Tag ( Ber . ASN CONTEXT , true , null ) ; } }
public void remove Overflow Command ( Command cmd ) { overflow Commands . remove ( cmd ) ; }
public Str Tokenizer reset ( final String input ) { reset ( ) ; if ( input != null ) { this . chars = input . to Char Array ( ) ; } else { this . chars = null ; } return this ; }
@ React Method public void r Clear All ( Callback error Callback , Callback success Callback ) { try { m Notification Manager . clear All ( ) ; success Callback . invoke ( ) ; } catch ( Exception e ) { error Callback . invoke ( e . get Message ( ) ) ; Log . e ( STR_ , STR_ + Log . get Stack Trace String ( e ) ) ; } }
public Thread Monitor ( M Bean Server Connection server ) throws IO Exception { this . server = server ; this . tmbean = new Platform MX Bean Proxy ( server , THREAD MXBEAN NAME , Thread MX Bean . class ) ; try { objname = new Object Name ( THREAD MXBEAN NAME ) ; } catch ( Malformed Object Name Exception e ) { Internal Error ie = new Internal Error ( e . get Message ( ) ) ; ie . init Cause ( e ) ; throw ie ; } parse M Bean Info ( ) ; }
public static Collection < String > log Files ( ) { Collection < String > res = new Array List < > ( file Appenders . size ( ) ) ; for ( File Appender a : file Appenders ) res . add ( a . get File ( ) ) ; return res ; }
public static double binomial Standard Error ( double p , int n ) { if ( n == NUM_ ) { return NUM_ ; } return Math . sqrt ( ( p * ( NUM_ - p ) ) / ( double ) n ) ; }
@ Override public Rectangle 2 D scale ( Rectangle 2 D rect ) { Insets insets = get Insets ( ) ; double x = rect . get X ( ) * get Scale X ( ) + insets . left ; double y = rect . get Y ( ) * get Scale Y ( ) + insets . top ; double w = rect . get Width ( ) * get Scale X ( ) ; double h = rect . get Height ( ) * get Scale Y ( ) ; return new Rectangle 2 D . Double ( x , y , w , h ) ; }
public Recent Key Store File Action Listener ( File recent File , Kse Frame kse Frame ) { this . recent File = recent File ; this . kse Frame = kse Frame ; }
protected synchronized void add Enter Listener ( Hashtable < Tx State , Set < Event Listener > > listeners , Event Listener lstnr , Tx State state ) { Set < Event Listener > lstnrs = listeners . get ( state ) ; if ( lstnrs == null ) lstnrs = new Hash Set < Event Listener > ( ) ; if ( ! lstnrs . contains ( lstnr ) ) lstnrs . add ( lstnr ) ; listeners . put ( state , lstnrs ) ; }
private String unicode ( char ch ) { return Integer . to String ( ch ) ; }
private void create Movements ( ) throws Exception { m script Ctx . clear ( ) ; m script Ctx . put ( STR_ , this ) ; m script Ctx . put ( STR_ , get HR Process ID ( ) ) ; m script Ctx . put ( STR_ , get HR Period ID ( ) ) ; m script Ctx . put ( STR_ , get HR Payroll ID ( ) ) ; m script Ctx . put ( STR_ , get HR Department ID ( ) ) ; log . info ( STR_ + STR_ + get HR Process ID ( ) + STR_ + get HR Period ID ( ) + STR_ + get HR Payroll ID ( ) + STR_ + get HR Department ID ( ) ) ; MHR Period hr Period = null ; if ( get HR Period ID ( ) > NUM_ ) { hr Period = MHR Period . get ( get Ctx ( ) , get HR Period ID ( ) ) ; } else { hr Period = new MHR Period ( get Ctx ( ) , NUM_ , get Trx Name ( ) ) ; M Period period = M Period . get ( get Ctx ( ) , get Date Acct ( ) , get AD Org ID ( ) ) ; if ( period != null ) { hr Period . set Start Date ( period . get Start Date ( ) ) ; hr Period . set End Date ( period . get End Date ( ) ) ; } else { hr Period . set Start Date ( get Date Acct ( ) ) ; hr Period . set End Date ( get Date Acct ( ) ) ; } } m date From = hr Period . get Start Date ( ) ; m date To = hr Period . get End Date ( ) ; m script Ctx . put ( STR_ , m date From ) ; m script Ctx . put ( STR_ , m date To ) ; m script Ctx . put ( STR_ , hr Period . get Period No ( ) ) ; if ( get HR Payroll ID ( ) > NUM_ ) { m HR Payroll ID = get HR Payroll ID ( ) ; } if ( get HR Department ID ( ) > NUM_ ) { m HR Department ID = get HR Department ID ( ) ; } if ( get HR Job ID ( ) > NUM_ ) { m HR Job ID = get HR Job ID ( ) ; } int no = DB . execute Update Ex ( STR_ , new Object [ ] { get HR Process ID ( ) , true } , get Trx Name ( ) ) ; log . info ( STR_ + no ) ; lines Concept = MHR Payroll Concept . get Payroll Concepts ( this ) ; MB Partner [ ] lines Employee = MHR Employee . get Employees ( this ) ; int count = NUM_ ; for ( MB Partner bp : lines Employee ) { log . info ( STR_ + count + STR_ + bp . get Name ( ) ) ; count ++ ; m C B Partner ID = bp . get ID ( ) ; m employee = MHR Employee . get Active Employee ( get Ctx ( ) , m C B Partner ID , get Trx Name ( ) ) ; m script Ctx . remove ( STR_ ) ; m script Ctx . remove ( STR_ ) ; m script Ctx . remove ( STR_ ) ; m script Ctx . remove ( STR_ ) ; m script Ctx . put ( STR_ , m employee . get Start Date ( ) ) ; m script Ctx . put ( STR_ , m employee . get End Date ( ) == null ? Time Util . get Day ( NUM_ , NUM_ , NUM_ ) : m employee . get End Date ( ) ) ; m script Ctx . put ( STR_ , Time Util . get Days Between ( hr Period . get Start Date ( ) , hr Period . get End Date ( ) ) + NUM_ ) ; m script Ctx . put ( STR_ , bp . get C B Partner ID ( ) ) ; if ( get HR Period ID ( ) > NUM_ ) create Cost Collector Movements ( bp . get ID ( ) , hr Period ) ; m movement . clear ( ) ; load Movements ( m movement , m C B Partner ID ) ; for ( MHR Payroll Concept pc : lines Concept ) { m HR Concept ID = pc . get HR Concept ID ( ) ; MHR Concept concept = MHR Concept . get ( get Ctx ( ) , m HR Concept ID ) ; boolean printed = pc . is Printed ( ) || concept . is Printed ( ) ; MHR Movement movement = m movement . get ( concept . get ID ( ) ) ; if ( movement == null ) { movement = create Movement From Concept ( concept , printed ) ; movement . set HR Payroll ID ( pc . get HR Payroll ID ( ) ) ; movement . set HR Payroll Concept ID ( pc . get HR Payroll Concept ID ( ) ) ; movement = m movement . get ( concept . get ID ( ) ) ; } if ( movement == null ) { throw new Adempiere Exception ( STR_ + concept . get Value ( ) + STR_ ) ; } } for ( MHR Movement m : m movement . values ( ) ) { MHR Concept c = ( MHR Concept ) m . get HR Concept ( ) ; if ( c . is Manual ( ) || m . is Empty ( ) ) { log . fine ( STR_ + m ) ; } else { boolean save This Record = m . is Printed ( ) || c . is Paid ( ) || c . is Printed ( ) ; if ( save This Record ) m . save Ex ( ) ; } } } if ( get HR Period ID ( ) > NUM_ ) { hr Period . set Processed ( true ) ; hr Period . save Ex ( ) ; } }
public static void put PF Stat ( long id , Stat type , double s ) { if ( disabled ) return ; if ( ! pfstats . contains Key ( id ) ) pfstats . put ( id , new Hash Map < Stat , Linked List < Double > > ( ) ) ; Hash Map < Stat , Linked List < Double > > allstats = pfstats . get ( id ) ; if ( ! allstats . contains Key ( type ) ) allstats . put ( type , new Linked List < Double > ( ) ) ; Linked List < Double > stats = allstats . get ( type ) ; stats . add Last ( s ) ; }
public static final int [ ] resize ( int [ ] a , int size ) { if ( a . length >= size ) return a ; int [ ] b = new int [ size ] ; System . arraycopy ( a , NUM_ , b , NUM_ , a . length ) ; return b ; }
private static void write Table Page Header ( Byte Buffer buffer ) { buffer . put ( Page Types . TABLE DEF ) ; buffer . put ( ( byte ) NUM_ ) ; buffer . put ( ( byte ) NUM_ ) ; buffer . put ( ( byte ) NUM_ ) ; buffer . put Int ( NUM_ ) ; }
public void select New Photo ( ) { remove From Cache ( ) ; final Intent intent = new Intent ( ) ; if ( Build . VERSION . SDK INT < NUM_ ) { intent . set Action ( Intent . ACTION GET CONTENT ) ; } else { intent . set Action ( STR_ ) ; intent . add Category ( Intent . CATEGORY OPENABLE ) ; } intent . set Type ( STR_ ) ; start Activity For Result ( intent , NEW PHOTO ) ; }
public String pick Color ( final Shell shell , final RGB initial Color ) { Check . not Null ( shell , STR_ ) ; final Color Dialog dialog = new Color Dialog ( shell ) ; if ( initial Color != null ) { dialog . set RGB ( initial Color ) ; } final RGB rgb = dialog . open ( ) ; if ( rgb != null ) { return String . format ( STR_ , rgb . red , rgb . green , rgb . blue ) ; } return null ; }
protected Http URL Connection create Undeploy Connection ( WAR war ) throws IO Exception { String undeploy URL = this . deployer Url + STR_ + war . get Context ( ) ; URL url = new URL ( undeploy URL ) ; Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Allow User Interaction ( false ) ; connection . set Do Input ( true ) ; connection . set Do Output ( true ) ; connection . set Use Caches ( false ) ; connection . set Do Output ( false ) ; connection . set Request Method ( STR_ ) ; if ( this . username != null ) { String authorization = to Authorization ( this . username , this . password ) ; connection . set Request Property ( STR_ , authorization ) ; } connection . connect ( ) ; return connection ; }
@ Override public boolean equals ( Object o ) { if ( this == o ) return true ; if ( o == null || get Class ( ) != o . get Class ( ) ) return false ; Abstract User Notification that = ( Abstract User Notification ) o ; return ! ( notification Configuration != null ? ! notification Configuration . equals ( that . notification Configuration ) : that . notification Configuration != null ) ; }
public Real Vector Format ( final String prefix , final String suffix , final String separator , final Number Format format ) { this . prefix = prefix ; this . suffix = suffix ; this . separator = separator ; trimmed Prefix = prefix . trim ( ) ; trimmed Suffix = suffix . trim ( ) ; trimmed Separator = separator . trim ( ) ; this . format = format ; }
public void update Event Seq Num ( long l ) { Atomics . set If Greater ( this . event Seq Num , l ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ , get Id ( ) , l ) ; } }
private void add Name ( String name , Search Index Entry Type type ) { index . add ( new Search Index Entry ( name , type . get Entity Type ( ) , name , NUM_ + type . get Minor Score ( ) ) ) ; if ( name . index Of ( STR_ ) > - NUM_ ) { add Description ( name , name , type , NUM_ ) ; } }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( this == POINT INFINITY ) return false ; if ( obj instanceof EC Point ) { return ( ( x . equals ( ( ( EC Point ) obj ) . x ) ) && ( y . equals ( ( ( EC Point ) obj ) . y ) ) ) ; } return false ; }
public static Buffered Input Stream new Input Stream ( URL url ) throws Malformed URL Exception , IO Exception { return new Buffered Input Stream ( configured Input Stream ( null , url ) ) ; }
public void remove Size Listener ( Size Listener listener ) { check Widget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR NULL ARGUMENT ) ; } size Listeners . remove ( listener ) ; }
private static int estimate Filter Order ( int sample Rate , int frequency 1 , int frequency 2 , double pass Band Ripple , double stop Band Ripple ) { double df = Math . abs ( frequency 2 - frequency 1 ) / ( double ) sample Rate ; double ddp = Math . log 10 ( stop Band Ripple <= pass Band Ripple ? pass Band Ripple : stop Band Ripple ) ; double dds = Math . log 10 ( stop Band Ripple <= pass Band Ripple ? stop Band Ripple : pass Band Ripple ) ; double a 1 = NUM_ ; double a 2 = NUM_ ; double a 3 = - NUM_ ; double a 4 = - NUM_ ; double a 5 = - NUM_ ; double a 6 = - NUM_ ; double b 1 = NUM_ ; double b 2 = NUM_ ; double t 1 = a 1 * ddp * ddp ; double t 2 = a 2 * ddp ; double t 3 = a 4 * ddp * ddp ; double t 4 = a 5 * ddp ; double dinf = ( ( t 1 + t 2 + a 3 ) * dds ) + ( t 3 + t 4 + a 6 ) ; double ff = b 1 + b 2 * ( ddp - dds ) ; double n = dinf / df - ff * df + NUM_ ; return ( int ) Math . ceil ( n ) ; }
private boolean find Destination And Track ( Car car , Route Location rl , Route Location rld ) throws Build Failed Exception { int index ; for ( index = NUM_ ; index < route List . size ( ) ; index ++ ) { if ( rld == route List . get ( index ) ) { break ; } } if ( route List . size ( ) == NUM_ ) { return find Destination And Track ( car , rl , index , index + NUM_ ) ; } return find Destination And Track ( car , rl , index - NUM_ , index + NUM_ ) ; }
public Quarter Date Format ( ) { this ( Time Zone . get Default ( ) ) ; }
public static Create Participant [ ] load Create Participants ( Refactoring Status status , Refactoring Processor processor , Object element , Create Arguments arguments , I Participant Descriptor Filter filter , String affected Natures [ ] , Sharable Participants shared ) { Refactoring Participant [ ] participants = fg Create Instance . get Participants ( status , processor , element , arguments , filter , affected Natures , shared ) ; Create Participant [ ] result = new Create Participant [ participants . length ] ; System . arraycopy ( participants , NUM_ , result , NUM_ , participants . length ) ; return result ; }
@ After public void unmock Eligible Response Getter ( ) { System . clear Property ( CUSTOM URL STREAM HANDLER PROPERTY NAME ) ; }
public static boolean create Production ( M Acct Schema as , int AD Org ID , int M Product ID , int M Attribute Set Instance ID , int M Production Line ID , int M Cost Element ID , Big Decimal Amt , Big Decimal Qty , String Description , String trx Name ) { String sql = STR_ + STR_ + STR_ + M Production Line ID + STR_ + as . get C Acct Schema ID ( ) + STR_ + M Attribute Set Instance ID ; int no = DB . execute Update ( sql , trx Name ) ; if ( no != NUM_ ) s log . config ( STR_ + no ) ; M Cost Detail cd = get ( as . get Ctx ( ) , STR_ , M Production Line ID , M Attribute Set Instance ID , as . get C Acct Schema ID ( ) , trx Name ) ; if ( cd == null ) { cd = new M Cost Detail ( as , AD Org ID , M Product ID , M Attribute Set Instance ID , M Cost Element ID , Amt , Qty , Description , trx Name ) ; cd . set M Production Line ID ( M Production Line ID ) ; } else { cd . set Delta Amt ( Amt . subtract ( cd . get Amt ( ) ) ) ; cd . set Delta Qty ( Qty . subtract ( cd . get Qty ( ) ) ) ; if ( cd . is Delta ( ) ) { cd . set Processed ( false ) ; cd . set Amt ( Amt ) ; cd . set Qty ( Qty ) ; } else return true ; } boolean ok = cd . save ( ) ; if ( ok && ! cd . is Processed ( ) ) { M Client client = M Client . get ( as . get Ctx ( ) , as . get AD Client ID ( ) ) ; if ( client . is Cost Immediate ( ) ) cd . process ( ) ; } s log . config ( STR_ + ok + STR_ + cd ) ; return ok ; }
public synchronized Platform query Capability ( Capability capability ) throws No Capable Platform Exception { Platform platform = preferences . get ( check Not Null ( capability ) ) ; if ( platform != null ) { return platform ; } else { throw new No Capable Platform Exception ( STR_ + capability . name ( ) ) ; } }
public void add Check Box Listener ( Change Listener listener ) { listener List . add ( Change Listener . class , listener ) ; }
private void back Button Invoked ( ) { final String back Url = browser History . move Back ( ) ; set Toolbar Button State ( ) ; is Back Or Forward In Progress = true ; navigate To URL ( back Url ) ; }
public static double Cramers V ( double [ ] [ ] matrix ) { int row , col , nrows , ncols , min ; double n = NUM_ ; nrows = matrix . length ; ncols = matrix [ NUM_ ] . length ; for ( row = NUM_ ; row < nrows ; row ++ ) { for ( col = NUM_ ; col < ncols ; col ++ ) { n += matrix [ row ] [ col ] ; } } min = nrows < ncols ? nrows - NUM_ : ncols - NUM_ ; if ( ( min == NUM_ ) || Utils . eq ( n , NUM_ ) ) return NUM_ ; return Math . sqrt ( chi Val ( matrix , false ) / ( n * ( double ) min ) ) ; }
@ Override public boolean log Modified ( Logger log ) { if ( is Modified Log ) return true ; for ( int i = dependency List . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Dependency dependency = dependency List . get ( i ) ; if ( dependency . log Modified ( log ) ) { is Modified Log = true ; return true ; } } return false ; }
protected void add Link ( String field , int len , int n , int e ) { int [ ] array = ( int [ ] ) m links . get ( n , field ) ; if ( array == null ) { array = new int [ ] { e } ; m links . set ( n , field , array ) ; return ; } else if ( len == array . length ) { int [ ] narray = new int [ Math . max ( NUM_ * array . length / NUM_ , len + NUM_ ) ] ; System . arraycopy ( array , NUM_ , narray , NUM_ , array . length ) ; array = narray ; m links . set ( n , field , array ) ; } array [ len ] = e ; }
public static void stash Application Repositories ( String classpath ) { if ( DBG APP CL ) { VM . sys Writeln ( STR_ + STR_ , classpath ) ; } if ( app CL != null && ! classpath . equals ( application Repositories ) ) { app CL = null ; if ( DBG APP CL ) { VM . sys Writeln ( STR_ ) ; } } application Repositories = classpath ; }
public void end Element ( ) throws IO Exception { String element Q Name = element Stack . pop ( ) ; ns Stack . pop ( ) ; if ( writing Start Tag ) { writer . write ( STR_ ) ; writing Start Tag = false ; return ; } writer . write ( STR_ ) ; writer . write ( element Q Name ) ; writer . write ( STR_ ) ; }
private void check State ( ) throws Illegal State Exception { if ( consonants == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( vowels == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( consonants . size ( ) == NUM_ ) { throw new Illegal State Exception ( STR_ ) ; } if ( vowels . size ( ) == NUM_ ) { throw new Illegal State Exception ( STR_ ) ; } }
public static void clear Keyboard Focus ( final Actor actor ) { if ( actor != null ) { clear Keyboard Focus ( actor . get Stage ( ) ) ; } }
private void pre Paint Dirty Regions ( ) { Map < Component , Rectangle > dirty Components ; java . util . List < Runnable > runnable List ; synchronized ( this ) { dirty Components = this . dirty Components ; runnable List = this . runnable List ; this . runnable List = null ; } if ( runnable List != null ) { for ( Runnable runnable : runnable List ) { runnable . run ( ) ; } } paint Dirty Regions ( ) ; if ( dirty Components . size ( ) > NUM_ ) { paint Dirty Regions ( dirty Components ) ; } }
public boolean cg Modify Rollback Step ( URI rp System Id , String token ) throws Workflow Exception { Workflow Step Completer . step Succeded ( token ) ; return true ; }
public Payment Channel Server State ( Transaction Broadcaster broadcaster , Wallet wallet , EC Key server Key , long min Expire Time ) { this . state = State . WAITING FOR REFUND TRANSACTION ; this . server Key = check Not Null ( server Key ) ; this . wallet = check Not Null ( wallet ) ; this . broadcaster = check Not Null ( broadcaster ) ; this . min Expire Time = min Expire Time ; }
private Sprite prepare Placeholder ( Sprite original ) { if ( ( original == null ) || ( Transparency Mode . TRANSPARENCY == Transparency . BITMASK ) ) { return original ; } Buffered Image img = new Buffered Image ( original . get Width ( ) , original . get Height ( ) , Buffered Image . TYPE INT ARGB ) ; Graphics g = img . create Graphics ( ) ; original . draw ( g , NUM_ , NUM_ ) ; Rescale Op rescale Op = new Rescale Op ( new float [ ] { NUM_ , NUM_ , NUM_ , NUM_ } , new float [ ] { - NUM_ , - NUM_ , - NUM_ , NUM_ } , null ) ; rescale Op . filter ( img , img ) ; g . dispose ( ) ; return new Image Sprite ( img ) ; }
protected void close ( ) { in Use Msg Ids . clear ( ) ; pending Messages . clear ( ) ; pending Flows . clear ( ) ; outbound Qo S 2 . clear ( ) ; outbound Qo S 1 . clear ( ) ; outbound Qo S 0 . clear ( ) ; inbound Qo S 2 . clear ( ) ; token Store . clear ( ) ; in Use Msg Ids = null ; pending Messages = null ; pending Flows = null ; outbound Qo S 2 = null ; outbound Qo S 1 = null ; outbound Qo S 0 = null ; inbound Qo S 2 = null ; token Store = null ; callback = null ; client Comms = null ; persistence = null ; ping Command = null ; }
private Double read Next Number ( Stack < Calculation Token > calculation Stack ) { Calculation Token calculation Token = calculation Stack . pop ( ) ; Double Token double Token ; Double next Number ; if ( calculation Token instanceof Operation Token ) { calculation Token = calculation Stack . pop ( ) ; double Token = ( Double Token ) calculation Token ; next Number = - double Token . get Number ( ) ; } else { double Token = ( Double Token ) calculation Token ; next Number = double Token . get Number ( ) ; } return next Number ; }
@ Override protected void add Sorting ( final Table Viewer table Viewer ) { final Table Viewer Sorter sorter = new Table Viewer Sorter ( table Viewer ) ; for ( int i = NUM_ ; i < column Metadatas . length ; i ++ ) { final Column Metadata column Metadata = column Metadatas [ i ] ; final Comparator < Link > comparator = column Metadata . get Comparator ( ) ; if ( comparator != null ) { sorter . set Comparator ( i , comparator ) ; } } table Viewer . set Sorter ( sorter ) ; }
public static void create Writer ( String file Name ) { try { create Writer ( new File Output Stream ( file Name ) ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } }
private void read From Version 1 Stream ( Status From Bytes Stream dis ) throws IO Exception { String url Copied From String = dis . read UTF ( ) ; if ( url Copied From String . equals ( STR_ ) ) { url Copied From = null ; } else { url Copied From = url ; } file = new File ( dis . read UTF ( ) ) ; path Conflict Old = dis . read UTF ( ) ; if ( path Conflict Old . equals ( STR_ ) ) path Conflict Old = null ; path Conflict New = dis . read UTF ( ) ; if ( path Conflict New . equals ( STR_ ) ) path Conflict New = null ; path Conflict Working = dis . read UTF ( ) ; if ( path Conflict Working . equals ( STR_ ) ) path Conflict Working = null ; lock Owner = null ; lock Creation Date = NUM_ ; lock Comment = null ; read Only = false ; }
private Group parse Group Result ( Result Set result Set ) throws SQL Exception , Ade Internal Exception { int uid = result Set . get Int ( STR_ ) ; String name = result Set . get String ( STR_ ) ; Short group Type Val = result Set . get Short ( STR_ ) ; Group Type group Type = Group Type . get Group Type ( group Type Val ) ; Short data Type Val = result Set . get Short ( STR_ ) ; Data Type data Type = Data Type . get Data Type ( data Type Val ) ; short evaluation Order = result Set . get Short ( STR_ ) ; int rid = result Set . get Int ( STR_ ) ; String rule Name = get Rule Name ( rid ) ; return new Group ( uid , name , group Type , data Type , evaluation Order , rule Name ) ; }
public Id < Dg Street > convert Link Id 2 Street Id ( Id < Link > link Id ) { String id String = link Id . to String ( ) + STR_ ; return id Pool . create Id ( id String , Dg Street . class ) ; }
private void open Counter Data Output Stream ( ) throws Data Fallback Exception { if ( d Output == null ) { if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STR_ + counter File . get Name ( ) + STR_ ) ; try { d Output = new Buffered Writer ( new File Writer ( counter File ) ) ; } catch ( IO Exception e ) { throw new Data Fallback Exception ( e . get Message ( ) ) ; } } }
private Future < Stream State > stream Ranges ( Map < String , Multimap < Range < Token > , Inet Address > > ranges To Stream By Keyspace ) { Map < String , Map < Inet Address , List < Range < Token > > > > sessions To Stream By Keyspace = new Hash Map < > ( ) ; for ( Map . Entry < String , Multimap < Range < Token > , Inet Address > > entry : ranges To Stream By Keyspace . entry Set ( ) ) { String keyspace = entry . get Key ( ) ; Multimap < Range < Token > , Inet Address > ranges With Endpoints = entry . get Value ( ) ; if ( ranges With Endpoints . is Empty ( ) ) continue ; Map < Inet Address , List < Range < Token > > > ranges Per Endpoint = new Hash Map < > ( ) ; for ( Map . Entry < Range < Token > , Inet Address > end Point Entry : ranges With Endpoints . entries ( ) ) { Range < Token > range = end Point Entry . get Key ( ) ; Inet Address endpoint = end Point Entry . get Value ( ) ; List < Range < Token > > cur Ranges = ranges Per Endpoint . get ( endpoint ) ; if ( cur Ranges == null ) { cur Ranges = new Linked List < > ( ) ; ranges Per Endpoint . put ( endpoint , cur Ranges ) ; } cur Ranges . add ( range ) ; } sessions To Stream By Keyspace . put ( keyspace , ranges Per Endpoint ) ; } Stream Plan stream Plan = new Stream Plan ( STR_ ) ; for ( Map . Entry < String , Map < Inet Address , List < Range < Token > > > > entry : sessions To Stream By Keyspace . entry Set ( ) ) { String keyspace Name = entry . get Key ( ) ; Map < Inet Address , List < Range < Token > > > ranges Per Endpoint = entry . get Value ( ) ; for ( Map . Entry < Inet Address , List < Range < Token > > > ranges Entry : ranges Per Endpoint . entry Set ( ) ) { List < Range < Token > > ranges = ranges Entry . get Value ( ) ; Inet Address new Endpoint = ranges Entry . get Key ( ) ; Inet Address preferred = System Keyspace . get Preferred IP ( new Endpoint ) ; stream Plan . transfer Ranges ( new Endpoint , preferred , keyspace Name , ranges ) ; } } return stream Plan . execute ( ) ; }
public int current As Source ( ) { return current As Source . get ( ) ; }
protected Object normalize Property ( Object property Value ) { return force Strings ? String . value Of ( property Value ) : property Value ; }
Cipher Handler ( final Secret Key key , final byte [ ] nonce , final byte [ ] content Aad , final int cipher Mode , final Crypto Algorithm crypto Algorithm ) { if ( nonce . length != crypto Algorithm . get Nonce Len ( ) ) { throw new Illegal Argument Exception ( STR_ + nonce . length ) ; } final Algorithm Parameter Spec spec = new GCM Parameter Spec ( crypto Algorithm . get Tag Len ( ) * NUM_ , nonce , NUM_ , nonce . length ) ; try { cipher = build Cipher Object ( crypto Algorithm ) ; cipher . init ( cipher Mode , key , spec ) ; if ( content Aad != null ) { cipher . update AAD ( content Aad ) ; } } catch ( final General Security Exception gsx ) { throw new Aws Crypto Exception ( gsx ) ; } }
public static void chmod File Read Only ( File f ) throws IO Exception { if ( ! ( f . set Read Only ( ) && f . set Readable ( false , false ) && f . set Readable ( true , true ) ) ) { } }
Word Entry normalize Adjective ( final String word ) { final String trimmed Word = trim Word ( word ) ; final String normalized = Grammar . normalize Derived Adjective ( trimmed Word ) ; if ( normalized != null ) { final Word Entry entry = words . get ( normalized ) ; return entry ; } else { return null ; } }
private void cooldown ( ) { final Text View status = ( Text View ) find View By Id ( R . id . status ) ; if ( m Cooldown <= NUM_ ) { m Password Entry . set Enabled ( true ) ; set Back Functionality ( true ) ; status . set Text ( R . string . enter password ) ; } else { Char Sequence template = get Text ( R . string . crypt keeper cooldown ) ; status . set Text ( Text Utils . expand Template ( template , Integer . to String ( m Cooldown ) ) ) ; m Cooldown -- ; m Handler . remove Messages ( MESSAGE COOLDOWN ) ; m Handler . send Empty Message Delayed ( MESSAGE COOLDOWN , NUM_ ) ; } }
public void on Open Conversation ( Conversation conversation , Conversation Legacy conversation Legacy ) { long thread Id = m Conversation != null ? m Conversation . get Thread Id ( ) : - NUM_ ; if ( thread Id > NUM_ ) send Pending Delayed Message ( ) ; long new Thread Id = conversation != null ? conversation . get Thread Id ( ) : - NUM_ ; if ( m Conversation != null && m Conversation Legacy != null && thread Id != new Thread Id ) { save Draft ( ) ; } m Conversation = conversation ; m Conversation Legacy = conversation Legacy ; if ( thread Id != new Thread Id || new Thread Id == - NUM_ ) { setup Draft ( ) ; } }
private String retrieve Attribute Value ( final Start Element element , final Q Name attribute Q Name , final boolean mandatory , final String x Path ) { Attribute attribute = element . get Attribute By Name ( attribute Q Name ) ; if ( attribute == null ) { if ( mandatory ) { throw new Illegal State Exception ( STR_ + x Path + STR_ ) ; } return null ; } else { return attribute . get Value ( ) ; } }
public J Popup Menu create Network Context Menu ( ) { context Menu = new J Popup Menu ( ) ; context Menu . add ( action Manager . get New Neuron Action ( ) ) ; context Menu . add ( new Add Neurons Action ( this ) ) ; context Menu . add ( action Manager . get New Group Menu ( ) ) ; context Menu . add ( action Manager . get New Network Menu ( ) ) ; context Menu . add Separator ( ) ; for ( Action action : action Manager . get Clipboard Actions ( ) ) { context Menu . add ( action ) ; } context Menu . add Separator ( ) ; context Menu . add ( action Manager . get Clear Source Neurons Action ( ) ) ; context Menu . add ( action Manager . get Set Source Neurons Action ( ) ) ; context Menu . add Separator ( ) ; context Menu . add ( action Manager . get Show Network Preferences Action ( ) ) ; return context Menu ; }
public Properties add Prefix ( Properties props ) { Properties result = new Properties ( ) ; for ( String name : props . string Property Names ( ) ) { String val = props . get Property ( name ) ; name = add Prefix ( name ) ; result . set Property ( name , val ) ; } return result ; }
public Workflow . Method zone Export Add Volumes Method ( URI export Group URI , List < URI > export Mask UR Is , Collection < URI > volume UR Is ) { return new Workflow . Method ( STR_ , export Group URI , export Mask UR Is , volume UR Is ) ; }
boolean define Char 2 String Mapping ( String output String , char input Char ) { Char Key character = new Char Key ( input Char ) ; m char To String . put ( character , output String ) ; set ( input Char ) ; boolean extra Mapping = extra Entity ( output String , input Char ) ; return extra Mapping ; }
public static String compute Chaining Value ( final String input , final RK Suite Identifier rk Suite ) throws No Such Algorithm Exception { final Message Digest md = Message Digest . get Instance ( rk Suite . get Hash Algorithm For Previous Signature Value ( ) ) ; md . update ( input . get Bytes ( ) ) ; final byte [ ] digest = md . digest ( ) ; final int bytes To Extract = rk Suite . get Number Of Bytes Extracted From Prev Sig Hash ( ) ; final byte [ ] con Digest = new byte [ bytes To Extract ] ; System . arraycopy ( digest , NUM_ , con Digest , NUM_ , bytes To Extract ) ; return Cash Box Utils . base 64 Encode ( con Digest , false ) ; }
public Stream Consumer ( Input Stream stream , String charset ) { in = new Buffered Input Stream ( stream ) ; this . charset = charset ; thread . start ( ) ; }
private static void create Parents ( File file ) { File Misc . mkdirs ( file . get Parent File ( ) ) ; }
private Input Node read Start ( Input Node from , Event Node event ) throws Exception { Input Element input = new Input Element ( from , this , event ) ; if ( text . length ( ) > NUM_ ) { text . set Length ( NUM_ ) ; } if ( event . is Start ( ) ) { return stack . push ( input ) ; } return input ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) return true ; if ( ! ( obj instanceof Code Source ) ) return false ; Code Source cs = ( Code Source ) obj ; if ( location == null ) { if ( cs . location != null ) return false ; } else { if ( ! location . equals ( cs . location ) ) return false ; } return match Certs ( cs , true ) ; }
private I Build Query Result query Builds ( final TFS Team Project Collection connection , final String build Name , final String team Project , final Build Status status ) { Check . not Null ( connection , STR_ ) ; Check . not Null Or Empty ( build Name , STR_ ) ; Check . not Null Or Empty ( team Project , STR_ ) ; final I Build Server build Server = connection . get Build Server ( ) ; final I Build Detail Spec build Detail Spec = build Server . create Build Detail Spec ( team Project ) ; build Detail Spec . set Build Number ( build Name ) ; build Detail Spec . set Information Types ( new String [ ] { Information Types . CHECK IN OUTCOME } ) ; if ( status != null ) { build Detail Spec . set Status ( status ) ; } return build Server . query Builds ( build Detail Spec ) ; }
public static Sip Response create 200 Ok Invite Response ( Sip Dialog Path dialog , String [ ] feature Tags , String sdp ) throws Payload Exception { return create 200 Ok Invite Response ( dialog , feature Tags , feature Tags , sdp ) ; }
public long schedule ( int tenant Id , double cost Estimate ) throws Interrupted Exception { Tenant tenant = tenants . get ( tenant Id ) ; Disk Request request = current request . get ( ) ; if ( request . is Active ( ) ) { request . reenter ( ) ; if ( DEBUG ) print ( STR_ , STR_ , request . entrance count ) ; return NUM_ ; } else { request . reset ( tenant , cost Estimate ) ; tenant . add New Request ( request ) ; } if ( slots . add Request ( ) ) { if ( DEBUG ) print ( STR_ , STR_ ) ; trigger Next Request ( ) ; } else { if ( DEBUG ) print ( STR_ , STR_ ) ; } long begin Wait = System . nano Time ( ) ; boolean waited = request . await ( ) ; if ( DEBUG ) print ( STR_ , STR_ ) ; if ( waited ) { return System . nano Time ( ) - begin Wait ; } else { return NUM_ ; } }
private static String change First Character Case ( boolean capitalize , String string ) { int str Len = string . length ( ) ; if ( str Len == NUM_ ) { return string ; } char ch = string . char At ( NUM_ ) ; char modified Ch ; if ( capitalize ) { modified Ch = Character . to Upper Case ( ch ) ; } else { modified Ch = Character . to Lower Case ( ch ) ; } if ( modified Ch == ch ) { return string ; } char chars [ ] = string . to Char Array ( ) ; chars [ NUM_ ] = modified Ch ; return new String ( chars ) ; }
private void show Time Sending Strategy Validation Message ( ) { sending Value Decoration . set Description Text ( STR_ ) ; }
protected Args Base ( ) { argv = null ; start Time = NUM_ ; program Info = null ; env = null ; }
public static void pojos ( Pojo Descriptor pojo , String out Folder , String pkg , boolean constructor , boolean include Keys , Confirm Callable ask Overwrite ) throws IO Exception { File pkg Folder = new File ( out Folder , pkg . replace ( STR_ , File . separator Char ) ) ; generate Code ( pojo , true , pkg , pkg Folder , constructor , false , ask Overwrite ) ; generate Code ( pojo , false , pkg , pkg Folder , constructor , include Keys , ask Overwrite ) ; }
public Jerry css ( String ... css ) { for ( Node node : nodes ) { String style Attr Value = node . get Attribute ( STR_ ) ; Map < String , String > styles = create Properties Map ( style Attr Value , STR_ , STR_ ) ; for ( int i = NUM_ ; i < css . length ; i += NUM_ ) { String property Name = css [ i ] ; property Name = String Util . from Camel Case ( property Name , STR_ ) ; String value = css [ i + NUM_ ] ; if ( value . length ( ) == NUM_ ) { styles . remove ( property Name ) ; } else { styles . put ( property Name , value ) ; } } style Attr Value = generate Attribute Value ( styles , STR_ , STR_ ) ; node . set Attribute ( STR_ , style Attr Value ) ; } return this ; }
public void assign Services ( Map service Names And Attr , boolean store ) throws AM Exception , SSO Exception { if ( ! ( ( profile Type == AM Object . ORGANIZATION ) || ( profile Type == AM Object . USER ) || ( profile Type == AM Object . STATIC GROUP ) || ( profile Type == AM Object . DYNAMIC GROUP ) || ( profile Type == AM Object . ORGANIZATIONAL UNIT ) || ( profile Type == AM Object . ASSIGNABLE DYNAMIC GROUP ) || ( profile Type == AM Object . GROUP ) ) ) { throw new Unsupported Operation Exception ( ) ; } if ( ( service Names And Attr == null ) || service Names And Attr . is Empty ( ) ) { return ; } Set new O Cs = new Hash Set ( ) ; Set can Assign = new Hash Set ( ) ; if ( store ) { Set assigned Services = get Assigned Services ( ) ; Set to Assign = service Names And Attr . key Set ( ) ; Iterator it = to Assign . iterator ( ) ; while ( it . has Next ( ) ) { String this Service = ( String ) it . next ( ) ; if ( ! assigned Services . contains ( this Service ) ) { can Assign . add ( this Service ) ; } else { if ( debug . warning Enabled ( ) ) { debug . warning ( STR_ + this Service + STR_ + entry DN ) ; } } } Set registered = null ; if ( profile Type == ORGANIZATION ) { registered = ds Services . get Registered Service Names ( null , entry DN ) ; } else { registered = ds Services . get Registered Service Names ( null , get Organization DN ( ) ) ; } it = can Assign . iterator ( ) ; while ( it . has Next ( ) ) { if ( ! registered . contains ( ( String ) it . next ( ) ) ) { throw new AM Exception ( AMSDK Bundle . get String ( STR_ , locale ) , STR_ ) ; } } } else { can Assign = service Names And Attr . key Set ( ) ; } new O Cs = AM Service Utils . get Service Object Classes ( token , can Assign ) ; if ( store ) { Set old O Cs = get Attribute ( STR_ ) ; new O Cs = AM Common Utils . combine O Cs ( new O Cs , old O Cs ) ; } set Attribute ( STR_ , new O Cs ) ; Iterator it = can Assign . iterator ( ) ; while ( it . has Next ( ) ) { String this Service = ( String ) it . next ( ) ; Map attr Map = ( Map ) service Names And Attr . get ( this Service ) ; if ( ( attr Map == null ) || attr Map . is Empty ( ) ) { attr Map = new Hash Map ( ) ; } try { Service Schema Manager ssm = new Service Schema Manager ( this Service , token ) ; Service Schema ss = null ; Object args [ ] = { this Service } ; if ( profile Type == AM Object . USER ) { ss = ssm . get Schema ( Schema Type . USER ) ; if ( ss == null ) { ss = ssm . get Schema ( Schema Type . DYNAMIC ) ; } } else if ( ( profile Type == AM Object . ORGANIZATION ) || ( profile Type == AM Object . ORGANIZATIONAL UNIT ) ) { ss = ssm . get Schema ( Schema Type . DOMAIN ) ; } else if ( ( profile Type == AM Object . STATIC GROUP ) || ( profile Type == AM Object . DYNAMIC GROUP ) || ( profile Type == AM Object . ASSIGNABLE DYNAMIC GROUP ) || ( profile Type == AM Object . GROUP ) ) { ss = ssm . get Schema ( Schema Type . GROUP ) ; } if ( ss == null ) { debug . warning ( AMSDK Bundle . get String ( STR_ ) ) ; throw new AM Exception ( AMSDK Bundle . get String ( STR_ , args , locale ) , STR_ , args ) ; } if ( ss . get Service Type ( ) != Schema Type . DYNAMIC ) { attr Map = ss . validate And Inherit Defaults ( attr Map , true ) ; } attr Map = AM Common Utils . remove Empty Values ( attr Map ) ; } catch ( SMS Exception smse ) { debug . error ( STR_ + STR_ + this Service , smse ) ; throw new AM Exception ( AMSDK Bundle . get String ( STR_ , locale ) , STR_ ) ; } set Attributes ( attr Map ) ; } if ( store ) { store ( ) ; } }
public static Class Name generate Migration Name ( String package Name , Schema from , Schema to ) { return Class Name . get ( package Name , String . format ( Locale . US , STR_ , from . get Version ( ) , to . get Version ( ) ) ) ; }
public Letter Or Number Validator ( @ Non Null final Char Sequence error Message , @ Non Null final Case case Sensitivity , final boolean allow Spaces , @ Non Null final char ... allowed Characters ) { super ( error Message ) ; set Case Sensitivity ( case Sensitivity ) ; allow Spaces ( allow Spaces ) ; set Allowed Characters ( allowed Characters ) ; }
public Value evaluate ( Context cx , Type Expression Node node ) { return super . evaluate ( cx , node ) ; }
public static boolean visit Dom Text Regions ( IDOM Node node , Dom Text Region Visitor visitor ) { I Structured Document Region region = node . get First Structured Document Region ( ) ; return visit Dom Text Regions ( node , region , visitor ) ; }
protected synchronized void establish Store Home ( ) throws IO Exception { if ( m store Dir OK ) { return ; } if ( ! m store Home . exists ( ) ) { if ( ! m store Home . mkdir ( ) ) { throw new IO Exception ( STR_ + m store Home . to String ( ) ) ; } } if ( ! m store Home . is Directory ( ) ) { throw new IO Exception ( STR_ + m store Home + STR_ ) ; } m store Dir OK = true ; lock Store ( ) ; File [ ] contents = m store Home . list Files ( ) ; for ( File f : contents ) { if ( f . is Directory ( ) ) { Map < String , File > store = new Linked Hash Map < String , File > ( ) ; m stores . put ( f . get Name ( ) , store ) ; File [ ] store Entries = f . list Files ( ) ; for ( File se : store Entries ) { store . put ( se . get Name ( ) , se ) ; } } } unlock Store ( ) ; }
private void write To File ( Path path , String content ) throws IO Exception { try ( final Buffered Writer writer = Files . new Buffered Writer ( path , Charset . default Charset ( ) ) ) { writer . write ( content ) ; } }
protected void thread Start ( ) { if ( thread != null ) { return ; } thread Done = false ; thread = new Thread ( this , thread Name ) ; thread . set Daemon ( true ) ; thread . start ( ) ; }
public void add Conf Listener ( Runnable runnable ) { conf Listeners . add ( runnable ) ; }
protected void assign Array ( Test Case test , Variable Reference array , int array Index , int position , List < Variable Reference > objects ) throws Construction Failed Exception { assert ( array instanceof Array Reference ) ; Array Reference arr Ref = ( Array Reference ) array ; if ( ! objects . is Empty ( ) && Randomness . next Double ( ) <= Properties . OBJECT REUSE PROBABILITY ) { Variable Reference choice = Randomness . choice ( objects ) ; logger . debug ( STR_ + choice ) ; Array Index index = new Array Index ( test , arr Ref , array Index ) ; Statement st = new Assignment Statement ( test , index , choice ) ; test . add Statement ( st , position ) ; } else { int old Length = test . size ( ) ; logger . debug ( STR_ + array . get Component Type ( ) ) ; Variable Reference var = attempt Generation ( test , array . get Component Type ( ) , position ) ; if ( ! var . is Assignable To ( arr Ref . get Component Type ( ) ) ) { throw new Construction Failed Exception ( STR_ ) ; } position += test . size ( ) - old Length ; Array Index index = new Array Index ( test , arr Ref , array Index ) ; Statement st = new Assignment Statement ( test , index , var ) ; test . add Statement ( st , position ) ; } }
public String format Mount Cmd ( String data Mover , String file System , String path ) { String Builder cmd = new String Builder ( ) ; cmd . append ( STR_ ) ; cmd . append ( data Mover ) ; cmd . append ( STR_ ) ; cmd . append ( file System ) ; cmd . append ( STR_ ) ; cmd . append ( path ) ; return cmd . to String ( ) ; }
public Object visit ( And filter , Object extra Data ) { return visit ( ( Binary Logic Operator ) filter , STR_ ) ; }
public static Intent create Email Attendees Intent ( Resources resources , String event Title , String body , List < String > to Emails , List < String > cc Emails , String owner Account ) { List < String > to List = to Emails ; List < String > cc List = cc Emails ; if ( to Emails . size ( ) <= NUM_ ) { if ( cc Emails . size ( ) <= NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } to List = cc Emails ; cc List = null ; } String subject = null ; if ( event Title != null ) { subject = resources . get String ( R . string . email subject prefix ) + event Title ; } Uri . Builder uri Builder = new Uri . Builder ( ) ; uri Builder . scheme ( STR_ ) ; if ( to List . size ( ) > NUM_ ) { for ( int i = NUM_ ; i < to List . size ( ) ; i ++ ) { uri Builder . append Query Parameter ( STR_ , to List . get ( i ) ) ; } } if ( subject != null ) { uri Builder . append Query Parameter ( STR_ , subject ) ; } if ( body != null ) { uri Builder . append Query Parameter ( STR_ , body ) ; } if ( cc List != null && cc List . size ( ) > NUM_ ) { for ( String email : cc List ) { uri Builder . append Query Parameter ( STR_ , email ) ; } } String uri = uri Builder . to String ( ) ; if ( uri . starts With ( STR_ ) ) { String Builder builder = new String Builder ( uri ) ; builder . insert ( NUM_ , Uri . encode ( to List . get ( NUM_ ) ) ) ; uri = builder . to String ( ) ; } Intent email Intent = new Intent ( android . content . Intent . ACTION SENDTO , Uri . parse ( uri ) ) ; email Intent . put Extra ( STR_ , owner Account ) ; if ( body != null ) { email Intent . put Extra ( Intent . EXTRA TEXT , body ) ; } return Intent . create Chooser ( email Intent , resources . get String ( R . string . email picker label ) ) ; }
public boolean is Xmt Busy ( ) { if ( controller == null ) { return false ; } return ( ! controller . ok To Send ( ) ) ; }
public Registered Project remove Project Type ( String project Path , String type ) throws Conflict Exception , Forbidden Exception , Not Found Exception , Server Exception { final Registered Project project = get Project ( project Path ) ; if ( project == null ) { return null ; } List < String > new Mixins = project . get Mixins ( ) ; String new Type = project . get Type ( ) ; if ( new Mixins . contains ( type ) ) { new Mixins . remove ( type ) ; } else if ( new Type . equals ( type ) ) { if ( project . is Detected ( ) ) { projects . remove ( project . get Path ( ) ) ; return null ; } new Type = Base Project Type . ID ; } final New Project Config conf = new New Project Config ( project . get Path ( ) , new Type , new Mixins , project . get Name ( ) , project . get Description ( ) , project . get Attributes ( ) , project . get Source ( ) ) ; return put Project ( conf , project . get Base Folder ( ) , true , project . is Detected ( ) ) ; }
private void build Lines ( ) { while ( ! node Edge Stack . empty ( ) ) { Half Edge e = ( Half Edge ) node Edge Stack . pop ( ) ; if ( Mark Half Edge . is Marked ( e ) ) continue ; build Line ( e ) ; } }
public static String [ ] analyze Scoped Name ( String name ) { String [ ] results = name . split ( STR_ ) ; return ( results . length != NUM_ ) ? null : results ; }
static String build Origin ( URI uri ) { return String . format ( STR_ , uri . get Host ( ) , uri . get Port ( ) ) ; }
public static void check For Export Rule To Delete ( Hash Map < String , Export Rule > source Export Rule Map , Hash Map < String , Export Rule > target Export Rule Map , List < Export Rule > export Rules To Delete ) { for ( String sec Flavour : target Export Rule Map . key Set ( ) ) { if ( ! source Export Rule Map . contains Key ( sec Flavour ) ) { export Rules To Delete . add ( target Export Rule Map . get ( sec Flavour ) ) ; } } }
public void add Op Auths ( final Class < ? extends Operation > op Class , final String ... auths ) { Set < String > op Auths = op Auths Map . get ( op Class ) ; if ( null == op Auths ) { op Auths = new Hash Set < > ( ) ; op Auths Map . put ( op Class , op Auths ) ; } Collections . add All ( op Auths , auths ) ; Collections . add All ( all Op Auths , auths ) ; }
public static final void apply Window Fix ( Window window ) { if ( ! instance . needs Window Fix ) { return ; } window . remove Window State Listener ( instance ) ; window . add Window State Listener ( instance ) ; instance . window State Changed ( null ) ; }
public final String offset String ( ) { return STR_ + Integer . to Hex String ( get Absolute Offset ( ) ) + STR_ ; }
@ Transactional public void create Voucherfrom Pre Approved Voucher ( final long vouhcerheaderid ) throws Application Runtime Exception { String voucher Status = null ; try { final List v Status List = app Config Values Service . get Config Values By Module And Key ( STR_ , STR_ ) ; if ( ! v Status List . is Empty ( ) && v Status List . size ( ) == NUM_ ) { final App Config Values app Val = ( App Config Values ) v Status List . get ( NUM_ ) ; voucher Status = app Val . get Value ( ) ; } else throw new Application Runtime Exception ( STR_ + MISSINGMSG ) ; create Voucher . create Voucher From Pre Approved Voucher ( vouhcerheaderid , voucher Status ) ; } catch ( final Application Runtime Exception e ) { LOGGER . error ( e . get Message ( ) ) ; throw new Application Runtime Exception ( e . get Message ( ) ) ; } }
@ Nullable public Grid Cache Mvcc Candidate remove Explicit Node Candidates ( UUID node Id ) { if ( rmts != null ) { for ( Iterator < Grid Cache Mvcc Candidate > it = rmts . iterator ( ) ; it . has Next ( ) ; ) { Grid Cache Mvcc Candidate cand = it . next ( ) ; if ( ! cand . tx ( ) && ( node Id . equals ( cand . node Id ( ) ) || node Id . equals ( cand . other Node Id ( ) ) ) ) { cand . set Used ( ) ; cand . set Removed ( ) ; it . remove ( ) ; } } if ( rmts . is Empty ( ) ) rmts = null ; } if ( locs != null ) { for ( Iterator < Grid Cache Mvcc Candidate > it = locs . iterator ( ) ; it . has Next ( ) ; ) { Grid Cache Mvcc Candidate cand = it . next ( ) ; if ( ! cand . tx ( ) && node Id . equals ( cand . other Node Id ( ) ) && cand . dht Local ( ) ) { cand . set Used ( ) ; cand . set Removed ( ) ; it . remove ( ) ; } } if ( locs . is Empty ( ) ) locs = null ; } reassign ( ) ; return any Owner ( ) ; }
protected void append Byte Array Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
public XML Parser ( final Class class To Be Bound , final String [ ] schemas ) throws XML Exception { try { JAXB Context jc = JAXB Context . new Instance ( class To Be Bound ) ; marshaller = jc . create Marshaller ( ) ; marshaller . set Schema ( XML Schema Utils . create Schema ( schemas ) ) ; unmarshaller = jc . create Unmarshaller ( ) ; unmarshaller . set Schema ( XML Schema Utils . create Schema ( schemas ) ) ; } catch ( JAXB Exception e ) { throw new XML Exception ( STR_ + class To Be Bound , e ) ; } }
private void adjust For Bottom Fading Edge ( View child In Selected Row , int top Selection Pixel , int bottom Selection Pixel ) { if ( child In Selected Row . get Bottom ( ) > bottom Selection Pixel ) { int space Above = child In Selected Row . get Top ( ) - top Selection Pixel ; int space Below = child In Selected Row . get Bottom ( ) - bottom Selection Pixel ; int offset = Math . min ( space Above , space Below ) ; offset Children Top And Bottom ( - offset ) ; } }
public boolean is State ( String cls ) { return CLASS STATE . equals ( cls ) ; }
synchronized String add Listener ( Service Listener listener ) { String id = SMS Utils . get Unique ID ( ) ; listener Objects . put ( id , listener ) ; return ( id ) ; }
static public List < Range > compact Ranges ( List < Range > ranges ) { List < Range > new Ranges = new Linked List < > ( ) ; if ( ranges . is Empty ( ) ) { return new Ranges ; } Collections . sort ( ranges ) ; Range prev Range = new Range ( ranges . get ( NUM_ ) . start Index , ranges . get ( NUM_ ) . end Index ) ; for ( int i = NUM_ ; i < ranges . size ( ) ; i ++ ) { Range current Range = ranges . get ( i ) ; if ( current Range . start Index == prev Range . end Index + NUM_ ) { prev Range . end Index = current Range . end Index ; } else { new Ranges . add ( prev Range ) ; prev Range = new Range ( current Range . start Index , current Range . end Index ) ; } } new Ranges . add ( prev Range ) ; return new Ranges ; }
public synchronized T acquire Modify ( ) throws Cache Exception { if ( LOG . is Trace Enabled ( ) ) LOG . trace ( STR_ + get Var Name ( ) ) ; long t 0 = DML Script . STATISTICS ? System . nano Time ( ) : NUM_ ; if ( ! is Available To Modify ( ) ) throw new Cache Exception ( STR_ ) ; if ( data == null ) get Cache ( ) ; if ( is Empty ( true ) && data == null ) { if ( hdfs File Name == null ) throw new Cache Exception ( STR_ ) ; try { data = read Blob From HDFS ( hdfs File Name ) ; } catch ( IO Exception e ) { throw new Cache Exception ( STR_ + hdfs File Name + STR_ + get Var Name ( ) + STR_ , e ) ; } } acquire ( true , data == null ) ; update Status Pinned ( true ) ; set Dirty ( true ) ; is Acquire From Empty = false ; if ( DML Script . STATISTICS ) { long t 1 = System . nano Time ( ) ; Cache Statistics . increment Acquire M Time ( t 1 - t 0 ) ; } return data ; }
protected synchronized Object extract ( ) { Object x = null ; Linked Node first = head . next ; if ( first != null ) { x = first . value ; first . value = null ; head = first ; count -- ; } return x ; }
private void add Endpoints ( ) { int max Seg Index = edge . size ( ) - NUM_ ; add ( edge . get Coordinate ( NUM_ ) , NUM_ ) ; add ( edge . get Coordinate ( max Seg Index ) , max Seg Index ) ; }
public static boolean equals Null Safe ( String s 1 , String s 2 ) { return s 1 == null ? s 2 == null : s 1 . equals ( s 2 ) ; }
private static File ensure Suffix ( File file , String suffix ) { String file Name = file . get Name ( ) ; if ( ! file Name . ends With ( suffix ) ) { file Name += STR_ + suffix ; return new File ( file . get Parent ( ) , file Name ) ; } else { return file ; } }
public boolean equals ( Object obj ) { if ( obj instanceof Command Environment ) { Command Environment env = ( Command Environment ) obj ; return ( ( command == null ? env . command == null : command . equals ( env . command ) ) && Arrays . equals ( options , env . options ) ) ; } else { return false ; } }
void wait Until Update DB Done ( ) { synchronized ( m Pending Writes Lock ) { while ( s Updating DB ) { try { Thread . sleep ( NUM_ ) ; } catch ( Interrupted Exception e ) { } } return ; } }
@ Override public boolean supports ( final Cloud Trail Event event ) { final Cloud Trail Event Data event Data = event . get Event Data ( ) ; final String event Source = event Data . get Event Source ( ) ; final String event Name = event Data . get Event Name ( ) ; return event Source . equals ( EC 2 EVENTS ) && event Name . starts With ( DELETE ) ; }
private double find Level Max Coeff ( Image Tree img Tree ) { double h = NUM_ ; double v = NUM_ ; double d = NUM_ ; h = find Sub Band Max Coeff ( img Tree . get Horizontal ( ) , NUM_ ) ; v = find Sub Band Max Coeff ( img Tree . get Vertical ( ) , NUM_ ) ; d = find Sub Band Max Coeff ( img Tree . get Diagonal ( ) , NUM_ ) ; return Common Util . max ( h , Common Util . max ( v , d ) ) ; }
public Bookmark add Bookmark ( Bookmark bookmark ) { Assert . not Null ( bookmark ) ; bookmarks . add ( bookmark ) ; bookmark . set User ( this ) ; return bookmark ; }
@ Override public List < Work Order > search WO For MB ( final Map < String , Object > criteria Map ) { logger . info ( STR_ ) ; final List < Work Order > filtered List = new Array List < Work Order > ( ) ; criteria Map . put ( ACTION FLAG , STR_ ) ; for ( final Work Order workorder : search WO ( criteria Map ) ) if ( ! is Approval Limit Reached For WO ( workorder . get Id ( ) ) ) filtered List . add ( workorder ) ; return filtered List ; }
public static File file ( String s ) { File f = new File ( s ) ; return f ; }
public Baseline Compiler Impl ( Baseline Compiled Method cm , short [ ] local Fixed Locations , short [ ] local Float Locations ) { super ( cm ) ; stack Heights = new int [ bcodes . length ( ) ] ; parameter Words = method . get Parameter Words ( ) + ( method . is Static ( ) ? NUM_ : NUM_ ) ; asm = new Assembler ( bcodes . length ( ) , should Print , this ) ; }
public static void add Combo Box ( final J Panel panel , final J Combo Box < String > combo Box , final String description , final String hint , final boolean value ) { Preconditions . check Not Null ( panel , STR_ ) ; Preconditions . check Not Null ( combo Box , STR_ ) ; Preconditions . check Not Null ( description , STR_ ) ; combo Box . add Item ( STR_ ) ; combo Box . add Item ( STR_ ) ; combo Box . set Selected Item ( value ? STR_ : STR_ ) ; combo Box . set Preferred Size ( new Dimension ( PREFERRED WIDTH , PREFERRED HEIGHT ) ) ; add Component ( panel , combo Box , description , hint ) ; }
private String print D Format ( short x ) { return print D Format ( Short . to String ( x ) ) ; }
public final Location location For Type ( Class < ? > type , Enum Set < Location Modifier > modifiers ) { return location For Type ( type , modifiers . contains ( Location Modifier . Final ) , modifiers . contains ( Location Modifier . Non Null ) ) ; }
private void start Camera ( ) { Intent take Picture Intent = new Intent ( Media Store . ACTION IMAGE CAPTURE ) ; take Picture Intent . put Extra ( Media Store . EXTRA OUTPUT , Uri . from File ( new File ( m Camera File ) ) ) ; start Activity For Result ( take Picture Intent , CAMERA REQUEST CODE ) ; }
public static int convert To Color Int ( String argb ) throws Number Format Exception { if ( argb . starts With ( STR_ ) ) { argb = argb . replace ( STR_ , STR_ ) ; } int alpha = - NUM_ , red = - NUM_ , green = - NUM_ , blue = - NUM_ ; if ( argb . length ( ) == NUM_ ) { alpha = Integer . parse Int ( argb . substring ( NUM_ , NUM_ ) , NUM_ ) ; red = Integer . parse Int ( argb . substring ( NUM_ , NUM_ ) , NUM_ ) ; green = Integer . parse Int ( argb . substring ( NUM_ , NUM_ ) , NUM_ ) ; blue = Integer . parse Int ( argb . substring ( NUM_ , NUM_ ) , NUM_ ) ; } else if ( argb . length ( ) == NUM_ ) { alpha = NUM_ ; red = Integer . parse Int ( argb . substring ( NUM_ , NUM_ ) , NUM_ ) ; green = Integer . parse Int ( argb . substring ( NUM_ , NUM_ ) , NUM_ ) ; blue = Integer . parse Int ( argb . substring ( NUM_ , NUM_ ) , NUM_ ) ; } return Color . argb ( alpha , red , green , blue ) ; }
public int countk NN ( T Object Int Hash Map < Object > counters , Object l ) { if ( l instanceof Label List ) { Label List ll = ( Label List ) l ; int m = NUM_ ; for ( int i = NUM_ , e = ll . size ( ) ; i < e ; i ++ ) { m = Math . max ( m , counters . adjust Or Put Value ( ll . get ( i ) , NUM_ , NUM_ ) ) ; } return m ; } return counters . adjust Or Put Value ( l , NUM_ , NUM_ ) ; }
public static String name For Stream Id ( String stream Id ) { Objects . require Non Null ( stream Id , STR_ ) ; return ID PREFIX + stream Id ; }
public void merge ( Register r 1 , Register r 2 ) { Iterator < Live Interval Element > i = iterate Live Intervals ( r 2 ) ; while ( i . has Next ( ) ) { Live Interval Element interval = i . next ( ) ; interval . set Register ( r 1 ) ; add To Register Map ( r 1 , interval ) ; i . remove ( ) ; } }
protected int timeout Wait ( int current Total Wait Time , long poll , long max Timeout Millis , String timed Out Message ) throws Timeout Exception { long now = System Clock . elapsed Realtime ( ) ; long end = now + poll ; while ( now < end ) { try { Thread . sleep ( end - now ) ; } catch ( Interrupted Exception e ) { } now = System Clock . elapsed Realtime ( ) ; } current Total Wait Time += poll ; if ( current Total Wait Time > max Timeout Millis ) { throw new Timeout Exception ( timed Out Message ) ; } return current Total Wait Time ; }
public synchronized static < T > T unmarshal ( String content , Class < T > t Class ) { String Reader string Reader = new String Reader ( content ) ; try { JAXB Context context = JAXB Context . new Instance ( t Class ) ; Unmarshaller un Marshaller = context . create Unmarshaller ( ) ; return t Class . cast ( un Marshaller . unmarshal ( string Reader ) ) ; } catch ( JAXB Exception je ) { log . error ( STR_ , je ) ; } return null ; }
public static int compare Version Strings ( String version 1 , String version 2 ) throws Number Format Exception { version 1 = Sdk Utils . cleanup Version ( version 1 ) ; version 2 = Sdk Utils . cleanup Version ( version 2 ) ; String split Regex = STR_ ; String [ ] array 1 = version 1 . split ( split Regex ) ; String [ ] array 2 = version 2 . split ( split Regex ) ; int n = Math . max ( array 1 . length , array 2 . length ) ; for ( int i = NUM_ ; i < n ; i ++ ) { int i 1 = parse Version Component ( array 1 , i ) ; int i 2 = parse Version Component ( array 2 , i ) ; if ( i 1 != i 2 ) { return i 1 - i 2 ; } } return NUM_ ; }
@ Suppress Warnings ( STR_ ) private boolean is Token Valid For Compression ( byte [ ] blob ) { if ( blob == null ) { return false ; } String contents ; try { contents = blob Utils . to UTF 8 ( blob ) ; } catch ( Unsupported Encoding Exception e ) { return false ; } if ( ! contents . starts With ( STR_ ) ) { return false ; } if ( ! contents . ends With ( STR_ ) ) { return false ; } Set < String > keys = new Hash Set < String > ( ) ; keys . add All ( replacement . key Set ( ) ) ; keys . add All ( replacement . values ( ) ) ; for ( String key : keys ) { if ( contents . contains ( key ) ) { return true ; } } return false ; }
public static Result Set simple Result Set ( Integer row Count , int ip , boolean bp , float fp , double dp , long lp , byte by Param , short sp ) { Simple Result Set rs = new Simple Result Set ( ) ; rs . add Column ( STR_ , Types . INTEGER , NUM_ , NUM_ ) ; rs . add Column ( STR_ , Types . VARCHAR , NUM_ , NUM_ ) ; if ( row Count == null ) { if ( ip != NUM_ || bp || fp != NUM_ || dp != NUM_ || sp != NUM_ || lp != NUM_ || by Param != NUM_ ) { throw new Assertion Error ( STR_ ) ; } } if ( row Count != null ) { if ( ip != NUM_ || ! bp || fp != NUM_ || dp != NUM_ || sp != NUM_ || lp != NUM_ || by Param != NUM_ ) { throw new Assertion Error ( STR_ ) ; } if ( row Count . int Value ( ) >= NUM_ ) { rs . add Row ( NUM_ , STR_ ) ; } if ( row Count . int Value ( ) >= NUM_ ) { rs . add Row ( NUM_ , STR_ ) ; } } return rs ; }
public static void database Migrations ( ) { Data data = injector . get Instance ( Data . class ) ; Repo repo = injector . get Instance ( Repo . class ) ; Api api = injector . get Instance ( Api . class ) ; data . create Table If Missing ( ) ; repo . add Source To Table ( ) ; repo . add Branch To Table ( ) ; api . create Table If Missing ( ) ; }
private static String replace Number ( String s , Pattern number Pattern , int base , int skip First , int skip Last ) { Matcher m = number Pattern . matcher ( s ) ; int matchstart = NUM_ ; while ( m . find ( matchstart ) ) { String n = m . group ( NUM_ ) ; s = s . replace First ( n , Long . to String ( Long . parse Long ( n . substring ( skip First , n . length ( ) - skip Last ) , base ) ) ) ; matchstart = m . end ( NUM_ ) ; } return s ; }
@ Suppress Warnings ( STR_ ) public void add ( final Class < ? extends Fragment > class Name , final Bundle params ) { final Holder m Holder = new Holder ( ) ; m Holder . m Class Name = class Name . get Name ( ) ; m Holder . m Params = params ; final int m Position = m Holder List . size ( ) ; m Holder List . add ( m Position , m Holder ) ; notify Data Set Changed ( ) ; }
protected static String create Id From Jndi Location ( String jndi Location ) { int [ ] delimeters = new int [ ] { jndi Location . last Index Of ( STR_ ) , jndi Location . last Index Of ( STR_ ) , jndi Location . last Index Of ( STR_ ) } ; Arrays . sort ( delimeters ) ; int highest Index = delimeters [ NUM_ ] ; return jndi Location . substring ( highest Index + NUM_ ) ; }
public static < T > Object [ ] merge ( Object [ ] a , Object [ ] b , Class < T > klass ) { if ( a == null ) return b ; if ( b == null ) return a ; Object [ ] arrrrray = ( Object [ ] ) Array . new Instance ( klass , ( a . length + b . length ) ) ; System . arraycopy ( a , NUM_ , arrrrray , NUM_ , a . length ) ; System . arraycopy ( b , NUM_ , arrrrray , a . length , b . length ) ; return arrrrray ; }
private void compute Statistics ( Profile Request req , int access Time , int egress Time ) { int count = NUM_ ; int sum = NUM_ ; this . min = Integer . MAX VALUE ; this . max = NUM_ ; for ( int start = req . from Time ; start < req . to Time ; start += NUM_ ) { int time At Origin Stop = start + access Time + Raptor Worker . BOARD SLACK SECONDS ; int best Time At Destination Stop = Integer . MAX VALUE ; for ( Itinerary itin : this . itineraries ) { if ( itin . board Times [ NUM_ ] < time At Origin Stop ) continue ; if ( itin . alight Times [ this . length - NUM_ ] < best Time At Destination Stop ) best Time At Destination Stop = itin . alight Times [ this . length - NUM_ ] ; } if ( best Time At Destination Stop == Integer . MAX VALUE ) continue ; int best Time At Destination = best Time At Destination Stop + egress Time ; int travel Time = best Time At Destination - start ; count ++ ; sum += travel Time ; min = Math . min ( min , travel Time ) ; max = Math . max ( max , travel Time ) ; } if ( count == NUM_ ) throw new Illegal State Exception ( STR_ ) ; avg = sum / count ; }
protected void init Component Defaults ( UI Defaults table ) { super . init Component Defaults ( table ) ; Color c = table . get Color ( STR_ ) ; table . put ( STR_ , c ) ; table . put ( STR_ , c ) ; Class lf = com . jgoodies . looks . plastic . Plastic Look And Feel . class ; table . put ( STR_ , make Icon ( lf , STR_ ) ) ; table . put ( STR_ , make Icon ( lf , STR_ ) ) ; table . put ( STR_ , make Icon ( lf , STR_ ) ) ; }
public void on Draw Frame ( GL 10 gl Unused ) { boolean is New Frame = false ; int frame Number = NUM_ ; synchronized ( this ) { if ( update Surface ) { is New Frame = true ; frame Number = m Frame Number ; m Surface . update Tex Image ( ) ; m Surface . get Transform Matrix ( m ST Matrix ) ; update Surface = false ; } } GLES 20 . gl Clear Color ( NUM_ , NUM_ , NUM_ , NUM_ ) ; GLES 20 . gl Clear ( GLES 20 . GL DEPTH BUFFER BIT | GLES 20 . GL COLOR BUFFER BIT ) ; GLES 20 . gl Use Program ( m Program ) ; check Gl Error ( STR_ ) ; GLES 20 . gl Active Texture ( GLES 20 . GL TEXTURE 0 ) ; GLES 20 . gl Bind Texture ( GL TEXTURE EXTERNAL OES , m Texture ID ) ; m Triangle Vertices . position ( TRIANGLE VERTICES DATA POS OFFSET ) ; GLES 20 . gl Vertex Attrib Pointer ( ma Position Handle , NUM_ , GLES 20 . GL FLOAT , false , TRIANGLE VERTICES DATA STRIDE BYTES , m Triangle Vertices ) ; check Gl Error ( STR_ ) ; GLES 20 . gl Enable Vertex Attrib Array ( ma Position Handle ) ; check Gl Error ( STR_ ) ; m Triangle Vertices . position ( TRIANGLE VERTICES DATA UV OFFSET ) ; GLES 20 . gl Vertex Attrib Pointer ( ma Texture Handle , NUM_ , GLES 20 . GL FLOAT , false , TRIANGLE VERTICES DATA STRIDE BYTES , m Triangle Vertices ) ; check Gl Error ( STR_ ) ; GLES 20 . gl Enable Vertex Attrib Array ( ma Texture Handle ) ; check Gl Error ( STR_ ) ; Matrix . set Identity M ( m MVP Matrix , NUM_ ) ; GLES 20 . gl Uniform Matrix 4 fv ( mu MVP Matrix Handle , NUM_ , false , m MVP Matrix , NUM_ ) ; GLES 20 . gl Uniform Matrix 4 fv ( mu ST Matrix Handle , NUM_ , false , m ST Matrix , NUM_ ) ; GLES 20 . gl Draw Arrays ( GLES 20 . GL TRIANGLE STRIP , NUM_ , NUM_ ) ; check Gl Error ( STR_ ) ; GLES 20 . gl Finish ( ) ; if ( is New Frame ) { Log . d ( TAG , m Draw Number + STR_ + frame Number + STR_ + System . current Time Millis ( ) ) ; Dump To File ( frame Number ) ; Log . d ( TAG , m Draw Number + STR_ + frame Number + STR_ + System . current Time Millis ( ) ) ; m Draw Number ++ ; } }
protected void process Initiators ( Export Group export Group , Collection < URI > initiator UR Is , Collection < String > port Names , Map < String , URI > port Name To Initiator URI , Collection < URI > host UR Is ) { Collection < String > initiator URI Strs = Collections 2 . transform ( initiator UR Is , Common Transformer Functions . FCTN URI TO STRING ) ; Collection < Initiator > initiators = Collections 2 . transform ( initiator URI Strs , Common Transformer Functions . fctn String To Initiator ( db Client ) ) ; process Initiators ( export Group , initiators , port Names , port Name To Initiator URI , host UR Is , null ) ; }
public Snmp Var Bind [ ] decode Var Bind List ( Ber Decoder bdec ) throws Ber Exception { bdec . open Sequence ( ) ; Vector < Snmp Var Bind > tmp = new Vector < Snmp Var Bind > ( ) ; while ( bdec . cannot Close Sequence ( ) ) { Snmp Var Bind bind = new Snmp Var Bind ( ) ; bdec . open Sequence ( ) ; bind . oid = new Snmp Oid ( bdec . fetch Oid ( ) ) ; bind . set Snmp Value ( decode Var Bind Value ( bdec ) ) ; bdec . close Sequence ( ) ; tmp . add Element ( bind ) ; } bdec . close Sequence ( ) ; Snmp Var Bind [ ] var Bind List = new Snmp Var Bind [ tmp . size ( ) ] ; tmp . copy Into ( var Bind List ) ; return var Bind List ; }
public Zone Info Provider ( File file Dir ) throws IO Exception { if ( file Dir == null ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( ! file Dir . exists ( ) ) { throw new IO Exception ( STR_ + file Dir ) ; } if ( ! file Dir . is Directory ( ) ) { throw new IO Exception ( STR_ + file Dir ) ; } i File Dir = file Dir ; i Resource Path = null ; i Loader = null ; i Zone Info Map = load Zone Info Map ( open Resource ( STR_ ) ) ; }
@ Not Null private static String default Directory Name ( @ Not Null final String url , @ Not Null final String vcs Dir Name ) { String non System Name ; if ( url . ends With ( STR_ + vcs Dir Name ) || url . ends With ( File . separator + vcs Dir Name ) ) { non System Name = url . substring ( NUM_ , url . length ( ) - vcs Dir Name . length ( ) - NUM_ ) ; } else { if ( url . ends With ( vcs Dir Name ) ) { non System Name = url . substring ( NUM_ , url . length ( ) - vcs Dir Name . length ( ) ) ; } else { non System Name = url ; } } int i = non System Name . last Index Of ( STR_ ) ; if ( i == - NUM_ && File . separator Char != STR_ ) { i = non System Name . last Index Of ( File . separator Char ) ; } return i >= NUM_ ? non System Name . substring ( i + NUM_ ) : STR_ ; }
public void clear ( ) { i Formatter = null ; i Element Pairs . clear ( ) ; }
public static Writer writer ( String uri ) throws IO Exception { return utf 8 ( output Stream ( uri ) ) ; }
public void load And Parse R Class Silently ( ) { final String r Class Name = get R Class Name ( my Module ) ; try { if ( r Class Name == null ) { LOG . info ( String . format ( STR_ , my Module . get Project ( ) . get Name ( ) ) ) ; return ; } my Logger . set Resource Class ( r Class Name ) ; load And Parse R Class ( r Class Name ) ; } catch ( Class Not Found Exception e ) { my Logger . set Missing Resource Class ( true ) ; } catch ( No Class Def Found Error e ) { my Logger . set Missing Resource Class ( true ) ; } catch ( Inconvertible Class Error e ) { assert r Class Name != null ; my Logger . add Incorrect Format Class ( r Class Name , e ) ; } }
protected String do Get Value At Index ( Frame And Sub Id format Key , int index ) throws Key Not Found Exception { List < String > values = do Get Values ( format Key ) ; if ( values . size ( ) > index ) { return values . get ( index ) ; } return STR_ ; }
private synchronized void draw Isometric Sprites For Hex ( Coords c , Graphics g , Collection < Isometric Sprite > sprite Array List ) { Rectangle view = g . get Clip Bounds ( ) ; for ( Isometric Sprite sprite : sprite Array List ) { Coords cp = sprite . get Position ( ) ; Rectangle sprite Bounds = sprite . get Bounds ( ) ; if ( cp . equals ( c ) && view . intersects ( sprite Bounds ) && ! sprite . is Hidden ( ) ) { if ( ! sprite . is Ready ( ) ) { sprite . prepare ( ) ; } sprite . draw Onto ( g , sprite Bounds . x , sprite Bounds . y , this , false ) ; } } }
MAC ( Mac Alg mac Alg , Protocol Version protocol Version , Secret Key key ) throws No Such Algorithm Exception , Invalid Key Exception { super ( protocol Version ) ; this . mac Alg = mac Alg ; String algorithm ; boolean tls = ( protocol Version . v >= Protocol Version . TLS 10 . v ) ; if ( mac Alg == M MD 5 ) { algorithm = tls ? STR_ : STR_ ; } else if ( mac Alg == M SHA ) { algorithm = tls ? STR_ : STR_ ; } else if ( mac Alg == M SHA 256 ) { algorithm = STR_ ; } else if ( mac Alg == M SHA 384 ) { algorithm = STR_ ; } else { throw new Runtime Exception ( STR_ + mac Alg ) ; } mac = Jsse Jce . get Mac ( algorithm ) ; mac . init ( key ) ; }
public void update Button Action Performed ( ) { node Type = node Type Box . get Selected Index ( ) ; log . debug ( STR_ + cur Node . get Node Type ( ) + STR_ + node Type ) ; if ( cur Node . get Node Type ( ) != node Type ) { cur Node . set Node Type ( node Type ) ; } set Node Parameters ( ) ; changed Node = true ; edit Mode = false ; cur Node = null ; add Button . set Visible ( true ) ; edit Button . set Visible ( true ) ; delete Button . set Visible ( true ) ; done Button . set Visible ( true ) ; update Button . set Visible ( false ) ; cancel Button . set Visible ( false ) ; node Addr Box . set Visible ( true ) ; node Addr Static . set Visible ( false ) ; node Type Box . set Visible ( false ) ; node Type Static . set Visible ( true ) ; status Text 2 . set Text ( std Status 2 ) ; status Text 3 . set Text ( std Status 3 ) ; status Text 1 . set Text ( rb . get String ( STR_ ) + STR_ + Integer . to String ( node Address ) ) ; error In Status 1 = true ; d 8 output Config Model . set Edit Mode ( false ) ; swoutput Config Model . set Edit Mode ( false ) ; ymoutput Config Model . set Edit Mode ( false ) ; T Boutput Config Model . set Edit Mode ( false ) ; T Bsensor Config Model . set Edit Mode ( false ) ; smoutput Config Model . set Edit Mode ( false ) ; wmsensor Config Model . set Edit Mode ( false ) ; sysensor Config Model . set Edit Mode ( false ) ; content Pane . repaint ( ) ; }
public static Map < String , Class Node > load Classes ( File jar File ) throws IO Exception { Map < String , Class Node > classes = new Hash Map < String , Class Node > ( ) ; Jar File jar = new Jar File ( jar File ) ; Stream < Jar Entry > str = jar . stream ( ) ; str . for Each ( null ) ; jar . close ( ) ; return classes ; }
private Constraint create New Constraint ( String name ) throws SQL Exception { Result Set rs = stmtdb 2 . execute Query ( STR_ + STR_ + STR_ + name + STR_ ) ; String table Name = STR_ ; String constraint Type = STR_ ; String condition = STR_ ; String r Constraint Name = STR_ ; String delete Rule = STR_ ; String column = STR_ ; if ( rs . next ( ) ) { constraint Type = rs . get String ( STR_ ) ; table Name = rs . get String ( STR_ ) ; condition = rs . get String ( STR_ ) ; r Constraint Name = rs . get String ( STR_ ) ; delete Rule = rs . get String ( STR_ ) ; } rs . close ( ) ; if ( constraint Type . equals ( Constraint . FOREIGN KEY ) ) { Constraint ref Constraint = null ; rs = stmtdb 2 . execute Query ( STR_ + name + STR_ ) ; if ( rs . next ( ) ) { column = rs . get String ( STR_ ) ; } rs . close ( ) ; rs = stmtdb 2 . execute Query ( STR_ + r Constraint Name + STR_ ) ; if ( rs . next ( ) ) { String ref Column = rs . get String ( STR_ ) ; String ref Table Name = rs . get String ( STR_ ) ; ref Constraint = new Constraint ( r Constraint Name , ref Table Name ) ; ref Constraint . add Column Name ( ref Column ) ; ref Constraint . set Delete Rule ( delete Rule ) ; } rs . close ( ) ; Constraint c = new Constraint ( name , table Name ) ; c . set Type ( Constraint . FOREIGN KEY ) ; c . add Column Name ( column ) ; c . set R Constraint ( ref Constraint ) ; c . add Column Name ( column ) ; c . set Delete Rule ( delete Rule ) ; return ( c ) ; } else if ( constraint Type . equals ( Constraint . PRIMARY KEY ) ) { rs = stmtdb 2 . execute Query ( STR_ + name + STR_ ) ; Constraint c = new Constraint ( name , table Name ) ; c . set Type ( Constraint . PRIMARY KEY ) ; c . set Delete Rule ( delete Rule ) ; while ( rs . next ( ) ) { c . add Column Name ( rs . get String ( STR_ ) ) ; } rs . close ( ) ; return ( c ) ; } else if ( constraint Type . equals ( Constraint . CHECK ) ) { rs = stmtdb 2 . execute Query ( STR_ + name + STR_ ) ; if ( rs . next ( ) ) { column = rs . get String ( STR_ ) ; } rs . close ( ) ; Constraint c = new Constraint ( name , table Name ) ; c . set Type ( Constraint . CHECK ) ; c . add Column Name ( column ) ; c . set Check Condition ( condition ) ; c . set Delete Rule ( delete Rule ) ; return ( c ) ; } return null ; }
@ Override public void draw Background ( Graphics 2 D g 2 , Category Plot plot , Rectangle 2 D data Area ) { float x 0 = ( float ) data Area . get X ( ) ; float x 1 = x 0 + ( float ) Math . abs ( this . x Offset ) ; float x 3 = ( float ) data Area . get Max X ( ) ; float x 2 = x 3 - ( float ) Math . abs ( this . x Offset ) ; float y 0 = ( float ) data Area . get Max Y ( ) ; float y 1 = y 0 - ( float ) Math . abs ( this . y Offset ) ; float y 3 = ( float ) data Area . get Min Y ( ) ; float y 2 = y 3 + ( float ) Math . abs ( this . y Offset ) ; General Path clip = new General Path ( ) ; clip . move To ( x 0 , y 0 ) ; clip . line To ( x 0 , y 2 ) ; clip . line To ( x 1 , y 3 ) ; clip . line To ( x 3 , y 3 ) ; clip . line To ( x 3 , y 1 ) ; clip . line To ( x 2 , y 0 ) ; clip . close Path ( ) ; Composite original Composite = g 2 . get Composite ( ) ; g 2 . set Composite ( Alpha Composite . get Instance ( Alpha Composite . SRC OVER , plot . get Background Alpha ( ) ) ) ; Paint background Paint = plot . get Background Paint ( ) ; if ( background Paint != null ) { g 2 . set Paint ( background Paint ) ; g 2 . fill ( clip ) ; } General Path left Wall = new General Path ( ) ; left Wall . move To ( x 0 , y 0 ) ; left Wall . line To ( x 0 , y 2 ) ; left Wall . line To ( x 1 , y 3 ) ; left Wall . line To ( x 1 , y 1 ) ; left Wall . close Path ( ) ; g 2 . set Paint ( get Wall Paint ( ) ) ; g 2 . fill ( left Wall ) ; General Path bottom Wall = new General Path ( ) ; bottom Wall . move To ( x 0 , y 0 ) ; bottom Wall . line To ( x 1 , y 1 ) ; bottom Wall . line To ( x 3 , y 1 ) ; bottom Wall . line To ( x 2 , y 0 ) ; bottom Wall . close Path ( ) ; g 2 . set Paint ( get Wall Paint ( ) ) ; g 2 . fill ( bottom Wall ) ; g 2 . set Paint ( Color . light Gray ) ; Line 2 D corner = new Line 2 D . Double ( x 0 , y 0 , x 1 , y 1 ) ; g 2 . draw ( corner ) ; corner . set Line ( x 1 , y 1 , x 1 , y 3 ) ; g 2 . draw ( corner ) ; corner . set Line ( x 1 , y 1 , x 3 , y 1 ) ; g 2 . draw ( corner ) ; Image background Image = plot . get Background Image ( ) ; if ( background Image != null ) { Rectangle 2 D adjusted = new Rectangle 2 D . Double ( data Area . get X ( ) + get X Offset ( ) , data Area . get Y ( ) , data Area . get Width ( ) - get X Offset ( ) , data Area . get Height ( ) - get Y Offset ( ) ) ; plot . draw Background Image ( g 2 , adjusted ) ; } g 2 . set Composite ( original Composite ) ; }
private static int [ ] compute Diff Line ( Image Line Int l 1 , Image Line Int l 2 ) { double max Dif = - NUM_ ; int max Dif Col = - NUM_ ; double dif ; int channels = l 1 . img Info . channels ; int [ ] scanline 1 = l 1 . get Scanline ( ) ; int [ ] scanline 2 = l 2 . get Scanline ( ) ; for ( int col = NUM_ ; col < l 1 . img Info . cols ; col ++ ) { dif = Math . abs ( scanline 1 [ col * channels ] - scanline 2 [ col * channels ] ) + Math . abs ( scanline 1 [ col * channels + NUM_ ] - scanline 2 [ col * channels + NUM_ ] ) + Math . abs ( scanline 1 [ col * channels + NUM_ ] - scanline 2 [ col * channels + NUM_ ] ) ; if ( channels == NUM_ ) dif += Math . abs ( scanline 1 [ col * channels + NUM_ ] - scanline 2 [ col * channels + NUM_ ] ) ; if ( dif > max Dif ) { max Dif = dif ; max Dif Col = col ; } } return new int [ ] { ( int ) ( max Dif + NUM_ ) , max Dif Col } ; }
public static void add Sub Tile To Creative Menu ( String key ) { subtiles For Creative Menu . add ( key ) ; }
@ Override public void lock Colors ( final Pdf Paint stroke Paint , final Pdf Paint nonstroke Paint , final boolean lock Colour ) { colors Locked = lock Colour ; Color stroke Color = Color . white , nonstroke Color = Color . white ; if ( stroke Paint != null && ! stroke Paint . is Pattern ( ) ) { stroke Color = ( Color ) stroke Paint ; } stroke Col = new Pdf Color ( stroke Color . get Red ( ) , stroke Color . get Green ( ) , stroke Color . get Blue ( ) ) ; if ( ! nonstroke Paint . is Pattern ( ) ) { nonstroke Color = ( Color ) nonstroke Paint ; } fill Col = new Pdf Color ( nonstroke Color . get Red ( ) , nonstroke Color . get Green ( ) , nonstroke Color . get Blue ( ) ) ; }
private static String canonize Tree String ( String str ) { String canon = str . trim ( ) ; Pattern pattern = Pattern . compile ( STR_ ) ; Matcher matcher = pattern . matcher ( canon ) ; while ( matcher . find ( ) ) { canon = matcher . replace First ( matcher . group ( NUM_ ) ) ; matcher . reset ( canon ) ; } return canon . trim ( ) ; }
private static File rename To Bak ( File file ) { Date Format fmt = new Simple Date Format ( STR_ ) ; if ( file . exists ( ) && ! file . rename To ( new File ( file . get Absolute Path ( ) + STR_ + fmt . format ( new Date ( ) ) + STR_ ) ) ) exit ( STR_ + file . get Path ( ) + STR_ , null ) ; return file ; }
public static double black Formula Cash Itm Probability ( final Option . Type option Type , @ Real final double strike , @ Real final double forward , @ Std Dev final double stddev , @ Real final double displacement ) { if ( stddev == NUM_ ) return ( forward * option Type . to Integer ( ) > strike * option Type . to Integer ( ) ? NUM_ : NUM_ ) ; if ( strike == NUM_ ) return ( option Type == Option . Type . Call ? NUM_ : NUM_ ) ; final double d 1 = Math . log ( ( forward + displacement ) / ( strike + displacement ) ) / stddev + NUM_ * stddev ; final double d 2 = d 1 - stddev ; final Cumulative Normal Distribution phi = new Cumulative Normal Distribution ( ) ; return phi . op ( option Type . to Integer ( ) * d 2 ) ; }
private static Topic Partition register Consumer To Specific Partition ( Kafka Consumer < String , String > consumer , String topic , int partition ) { Topic Partition topic Partition = new Topic Partition ( topic , partition ) ; List < Topic Partition > partitions = Arrays . as List ( topic Partition ) ; consumer . assign ( partitions ) ; return topic Partition ; }
public boolean is GPS Enabled ( Context m Context ) { Location Manager location Manager = ( Location Manager ) m Context . get System Service ( Context . LOCATION SERVICE ) ; return location Manager . is Provider Enabled ( Location Manager . GPS PROVIDER ) ; }
public void destroy ( ) { services = null ; if ( matches Array Thread Local != null ) { matches Array Thread Local . remove ( ) ; } if ( matches Per Stmt Thread Local != null ) { matches Per Stmt Thread Local . remove ( ) ; } if ( schedule Array Thread Local != null ) { schedule Array Thread Local . remove ( ) ; } if ( schedule Per Stmt Thread Local != null ) { schedule Per Stmt Thread Local . remove ( ) ; } matches Array Thread Local = null ; matches Per Stmt Thread Local = null ; schedule Array Thread Local = null ; schedule Per Stmt Thread Local = null ; }
public Polyline ( Pla Point Int Alist points alist ) { int initial len = points alist . size ( ) ; if ( initial len < NUM_ ) throw new Illegal Argument Exception ( classname + STR_ ) ; Array List < Pla Point Int > corners alist = new Array List < Pla Point Int > ( initial len ) ; for ( Pla Point Int a point : points alist ) { if ( a point == null ) continue ; if ( has point ( corners alist , a point ) ) continue ; if ( has colinear ( corners alist , a point ) ) continue ; corners alist . add ( a point ) ; } int input len = corners alist . size ( ) ; lines list = new Array List < Pla Line Int > ( input len + NUM_ ) ; if ( input len < NUM_ ) throw new Illegal Argument Exception ( classname + STR_ ) ; Pla Point Int acorner = corners alist . get ( NUM_ ) ; Pla Direction dir = new Pla Direction ( acorner , corners alist . get ( NUM_ ) ) ; lines list . add ( new Pla Line Int ( acorner , dir . rotate 45 deg ( NUM_ ) ) ) ; for ( int index = NUM_ ; index < input len ; ++ index ) lines list . add ( new Pla Line Int ( corners alist . get ( index - NUM_ ) , corners alist . get ( index ) ) ) ; acorner = corners alist . get ( input len - NUM_ ) ; dir = new Pla Direction ( acorner , corners alist . get ( input len - NUM_ ) ) ; lines list . add ( new Pla Line Int ( acorner , dir . rotate 45 deg ( NUM_ ) ) ) ; corners allocate ( corner count ( ) ) ; for ( int index = NUM_ ; index < input len ; index ++ ) precalculated corners [ index ] = corners alist . get ( index ) ; }
public static String Break Line ( String str ) { int line Len = NUM_ ; int next Char = NUM_ ; String new Str = STR_ ; char ch = STR_ ; while ( next Char < str . length ( ) ) { ch = str . char At ( next Char ) ; if ( ch == STR_ ) { if ( line Len > MAXLEN ) { new Str = new Str + STR_ ; line Len = NUM_ ; } } else { new Str = new Str + ch ; line Len = line Len + NUM_ ; } ; next Char = next Char + NUM_ ; } ; return new Str ; }
protected int hash ( final Object key ) { int h = key . hash Code ( ) ; h += ~ ( h << NUM_ ) ; h ^= h > > > NUM_ ; h += h << NUM_ ; h ^= h > > > NUM_ ; return h ; }
public static Map < String , Object > update File ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = null ; try { result = update File Method ( dctx , context ) ; } catch ( Generic Service Exception e ) { return Service Util . return Error ( e . get Message ( ) ) ; } return result ; }
public static String refresh Lock ( Entity Manager em , long type , String key , String note ) { Entity Transaction tx = null ; try { tx = em . get Transaction ( ) ; tx . begin ( ) ; Global Interlock lock = find And Refresh Lock ( em , type ) ; if ( lock == null ) { throw new Global Interlock Exception ( STR_ + type + STR_ + key + STR_ ) ; } String ref = Long . to Hex String ( lock . lock Time ) ; if ( ref . equals Ignore Case ( key ) ) { lock . lock Time = System . current Time Millis ( ) ; lock . note = note ; em . merge ( lock ) ; em . flush ( ) ; tx . commit ( ) ; return Long . to Hex String ( lock . lock Time ) ; } throw new Global Interlock Exception ( STR_ + type + STR_ + key + STR_ ) ; } finally { if ( tx != null && tx . is Active ( ) ) { tx . rollback ( ) ; } } }
public static boolean is Java Version At Least ( String expected Version ) { String actual Version Digits ; if ( is Azul JVM ( ) ) { actual Version Digits = String Utils . get Digits Only ( System . get Property ( STR_ ) ) ; int dot Idx = expected Version . index Of ( STR_ ) ; if ( dot Idx != - NUM_ ) { dot Idx = expected Version . index Of ( STR_ , dot Idx + NUM_ ) ; if ( dot Idx != - NUM_ ) { expected Version = expected Version . substring ( NUM_ , dot Idx ) ; } } } else { actual Version Digits = String Utils . get Digits Only ( System . get Property ( STR_ ) ) ; } String expected Version Digits = String Utils . pad Ending ( String Utils . get Digits Only ( expected Version ) , STR_ , actual Version Digits . length ( ) ) ; try { return ( Long . parse Long ( actual Version Digits ) >= Long . parse Long ( expected Version Digits ) ) ; } catch ( Number Format Exception ignore ) { return false ; } }
protected void draw Horizontal Item ( Graphics 2 D g 2 , Category Item Renderer State state , Rectangle 2 D data Area , Category Plot plot , Category Axis domain Axis , Value Axis range Axis , Category Dataset dataset , int row , int column ) { Number data Value = dataset . get Value ( row , column ) ; if ( data Value == null ) { return ; } double value = data Value . double Value ( ) ; double base = NUM_ ; double lclip = get Lower Clip ( ) ; double uclip = get Upper Clip ( ) ; if ( uclip <= NUM_ ) { if ( value >= uclip ) { return ; } base = uclip ; if ( value <= lclip ) { value = lclip ; } } else if ( lclip <= NUM_ ) { if ( value >= uclip ) { value = uclip ; } else { if ( value <= lclip ) { value = lclip ; } } } else { if ( value <= lclip ) { return ; } base = lclip ; if ( value >= uclip ) { value = uclip ; } } Rectangle Edge edge = plot . get Range Axis Edge ( ) ; double trans X 1 = range Axis . value To Java 2 D ( base , data Area , edge ) ; double trans X 2 = range Axis . value To Java 2 D ( value , data Area , edge ) ; double rect X = Math . min ( trans X 1 , trans X 2 ) ; double rect Width = Math . abs ( trans X 2 - trans X 1 ) ; double rect Y = domain Axis . get Category Middle ( column , get Column Count ( ) , data Area , plot . get Domain Axis Edge ( ) ) - state . get Bar Width ( ) / NUM_ ; int series Count = get Row Count ( ) ; double shift = NUM_ ; double rect Height ; double width Factor = NUM_ ; double series Bar Width = get Series Bar Width ( row ) ; if ( ! Double . is Na N ( series Bar Width ) ) { width Factor = series Bar Width ; } rect Height = width Factor * state . get Bar Width ( ) ; rect Y = rect Y + ( NUM_ - width Factor ) * state . get Bar Width ( ) / NUM_ ; if ( series Count > NUM_ ) { shift = rect Height * NUM_ / ( series Count - NUM_ ) ; } Rectangle 2 D bar = new Rectangle 2 D . Double ( rect X , ( rect Y + ( ( series Count - NUM_ - row ) * shift ) ) , rect Width , ( rect Height - ( series Count - NUM_ - row ) * shift * NUM_ ) ) ; if ( state . get Element Hinting ( ) ) { begin Element Group ( g 2 , dataset . get Row Key ( row ) , dataset . get Column Key ( column ) ) ; } Paint item Paint = get Item Paint ( row , column ) ; Gradient Paint Transformer t = get Gradient Paint Transformer ( ) ; if ( t != null && item Paint instanceof Gradient Paint ) { item Paint = t . transform ( ( Gradient Paint ) item Paint , bar ) ; } g 2 . set Paint ( item Paint ) ; g 2 . fill ( bar ) ; if ( is Draw Bar Outline ( ) && state . get Bar Width ( ) > BAR OUTLINE WIDTH THRESHOLD ) { Stroke stroke = get Item Outline Stroke ( row , column ) ; Paint paint = get Item Outline Paint ( row , column ) ; if ( stroke != null && paint != null ) { g 2 . set Stroke ( stroke ) ; g 2 . set Paint ( paint ) ; g 2 . draw ( bar ) ; } } Category Item Label Generator generator = get Item Label Generator ( row , column ) ; if ( generator != null && is Item Label Visible ( row , column ) ) { draw Item Label ( g 2 , dataset , row , column , plot , generator , bar , ( trans X 1 > trans X 2 ) ) ; } Entity Collection entities = state . get Entity Collection ( ) ; if ( entities != null ) { add Item Entity ( entities , dataset , row , column , bar ) ; } }
@ Override public void debug Print ( Print Stream out ) throws Ade Exception { super . debug Print ( out ) ; out . println ( STR_ + m percentiles With Empty Intervals ) ; out . println ( STR_ + m interval Count ) ; out . println ( STR_ ) ; for ( int i = NUM_ ; i < NUM BUCKETS ; ++ i ) { out . printf ( STR_ , i , m percentiles [ i ] ) ; } }
@ Deprecated public static void encode ( String s , String encoding , Appendable out ) throws Unsupported Encoding Exception , IO Exception { encode ( s , encoding , DEFAULT SAFE OCTETS , true , out ) ; }
public static Http Response execute Put Request ( String service End Point , String pay Load , boolean secure ) throws IO Exception { URL url = ( secure ) ? new URL ( SERVICE ROOT URI + STR_ + service End Point ) : new URL ( SERVICE ROOT URI + service End Point ) ; Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; try { connection . set Request Method ( STR_ ) ; connection . set Do Input ( true ) ; connection . set Do Output ( true ) ; connection . set Use Caches ( false ) ; if ( secure ) { connection . set Request Property ( STR_ , AUTHORIZATION ) ; } connection . set Request Property ( STR_ , STR_ ) ; connection . set Request Property ( STR_ , STR_ ) ; Data Output Stream out Stream = new Data Output Stream ( connection . get Output Stream ( ) ) ; try { out Stream . write Bytes ( pay Load ) ; out Stream . close ( ) ; return new Http Response ( connection ) ; } finally { out Stream . close ( ) ; } } finally { connection . disconnect ( ) ; } }
private void ensure Capacity ( int num Mappings ) { int new Capacity = Collections . round Up To Power Of Two ( capacity For Init Size ( num Mappings ) ) ; Hashtable Entry < K , V > [ ] old Table = table ; int old Capacity = old Table . length ; if ( new Capacity <= old Capacity ) { return ; } rehash ( ) ; if ( new Capacity == old Capacity * NUM_ ) { double Capacity ( ) ; return ; } Hashtable Entry < K , V > [ ] new Table = make Table ( new Capacity ) ; if ( size != NUM_ ) { int new Mask = new Capacity - NUM_ ; for ( int i = NUM_ ; i < old Capacity ; i ++ ) { for ( Hashtable Entry < K , V > e = old Table [ i ] ; e != null ; ) { Hashtable Entry < K , V > old Next = e . next ; int new Index = e . hash & new Mask ; Hashtable Entry < K , V > new Next = new Table [ new Index ] ; new Table [ new Index ] = e ; e . next = new Next ; e = old Next ; } } } }
public void cleanup ( Pdf Canvas cb ) { int k = saved States . size ( ) ; while ( k -- > NUM_ ) cb . restore State ( ) ; }
private static void enable File Access ( SAX Parser parser ) throws SAX Not Supported Exception { try { parser . set Property ( STR_ , STR_ ) ; } catch ( SAX Not Recognized Exception ignore ) { } }
protected static String extract Encoding ( String line ) { Pattern p = Pattern . compile ( EXTRACT ENCODING REGEX ) ; String [ ] matches = p . split ( line ) ; String value = matches [ NUM_ ] ; String [ ] cleanup = value . split ( STR_ ) ; String encoding = cleanup [ NUM_ ] ; return encoding . to Lower Case ( ) ; }
public static byte [ ] pack Byte Buffer Into Single Byte Array ( Byte Buffer [ ] byte Buffer Arr ) { if ( null == byte Buffer Arr || byte Buffer Arr . length == NUM_ ) { return null ; } int no Of Col = byte Buffer Arr . length ; short to Determine Length Of Byte Arr = NUM_ ; short offset Len = ( short ) ( no Of Col * NUM_ + to Determine Length Of Byte Arr ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( ( short ) ( total Bytes - to Determine Length Of Byte Arr ) ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM_ ; index < byte Buffer Arr . length - NUM_ ; index ++ ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; int no Of Bytes = individual Col . capacity ( ) ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len += no Of Bytes ; individual Col . rewind ( ) ; } for ( int index = NUM_ ; index < byte Buffer Arr . length ; index ++ ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; buffer . put ( individual Col . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
private void save ( Tuple tuple ) { byte [ ] row Key = mapper . row Key ( tuple ) ; Column List cols = mapper . columns ( tuple ) ; Durability durability = write To WAL ? Durability . SYNC WAL : Durability . SKIP WAL ; Optional < Long > ttl = mapper . get TTL ( tuple ) ; if ( ttl . is Present ( ) ) { hbase Client . add Mutation ( row Key , cols , durability , ttl . get ( ) ) ; } else { hbase Client . add Mutation ( row Key , cols , durability ) ; } batch Helper . add Batch ( tuple ) ; }
public void dummy Convert YUV 420 Image To Packed NV 21 ( byte [ ] data Copy , final int w , final int h ) { final int y size = w * h ; final int data offset = w * h ; for ( int i = NUM_ ; i < y size ; i ++ ) { data Copy [ i ] = ( byte ) ( ( ( ( i % w ) * NUM_ ) / w ) & NUM_ ) ; data Copy [ i ] = NUM_ ; } for ( int i = NUM_ ; i < h / NUM_ ; i ++ ) { for ( int j = NUM_ ; j < w / NUM_ ; j ++ ) { int offset = data offset + w * i + j * NUM_ ; data Copy [ offset ] = ( byte ) ( ( NUM_ * i ) / ( h / NUM_ ) & NUM_ ) ; data Copy [ offset + NUM_ ] = ( byte ) ( ( NUM_ * j ) / ( w / NUM_ ) & NUM_ ) ; } } }
static public J Label create J Label For Table ( String str ) { Argument Checking . not Null ( str , STR_ ) ; J Label label = create J Label For Table ( ) ; label . set Text ( str ) ; return label ; }
public User Config fetch ( User Config config ) { config . add Credentials ( this ) ; String xml = POST ( this . url + STR_ , config . to XML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { User Config user = new User Config ( ) ; user . parse XML ( root ) ; return user ; } catch ( Exception exception ) { this . exception = SDK Exception . parse Failure ( exception ) ; throw this . exception ; } }
void process activity ( Activity activity ) throws Exception { final Soot Class cn = activity . get Soot Class ( ) ; String class Name = cn . get Name ( ) ; if ( class Name . matches ( STR_ ) ) { logger . info ( STR_ ) ; return ; } if ( class Node Is An Android Activity ( cn ) ) { for ( Soot Method m : cn . get Methods ( ) ) { logger . info ( STR_ , m . get Name ( ) ) ; process method ( activity , cn , m ) ; } } else { logger . info ( STR_ + STR_ , cn ) ; } }
public static boolean is Left Mouse Button ( Mouse Event an Event ) { return ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 1 DOWN MASK ) > NUM_ ; }
private T Input create Input ( String type , String name , String value ) { String out Val = value ; if ( value . contains ( STR_ ) || value . contains ( STR_ ) ) { if ( unique Sources . contains Key ( value ) && value . contains ( STR_ ) ) { out Val = STR_ + unique Sources . get ( value ) ; } else { int s = num Sources ; num Sources ++ ; unique Sources . put ( value , s ) ; out Val = STR_ + s ; } } else if ( value . contains ( STR_ ) ) { out Val = STR_ ; } return new T Input ( type , name , out Val ) ; }
public static double F 1 ( int s 1 [ ] , int s 2 [ ] ) { double p = P Precision ( s 1 , s 2 ) ; double r = P Recall ( s 1 , s 2 ) ; if ( Double . is Na N ( r ) || Double . is Na N ( p ) ) { return Double . Na N ; } if ( p == NUM_ && r == NUM_ ) return NUM_ ; return NUM_ * p * r / ( p + r ) ; }
private Eclipse Namespace Stack create Namespace Stack ( ) { return new Eclipse Namespace Stack ( ) ; }
private void adjust For Left Fading Edge ( View child In Selected Row , int left Selection Pixel , int right Selection Pixel ) { if ( child In Selected Row . get Left ( ) < left Selection Pixel ) { int space To Left = left Selection Pixel - child In Selected Row . get Left ( ) ; int space To Right = right Selection Pixel - child In Selected Row . get Right ( ) ; int offset = Math . min ( space To Left , space To Right ) ; offset Children Left And Right ( offset ) ; } }
private void clean Up Database Resources ( Database conn , Statement st , Result Set rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQL Exception ignore ) { } } if ( st != null ) { try { st . close ( ) ; } catch ( SQL Exception ignore ) { } } if ( conn != null ) conn . close ( ) ; }
private Rectangle 2 D [ ] split Vertical Bar ( Rectangular Shape bar , double a , double b , double c ) { Rectangle 2 D [ ] result = new Rectangle 2 D [ NUM_ ] ; double x 0 = bar . get Min X ( ) ; double x 1 = Math . rint ( x 0 + ( bar . get Width ( ) * a ) ) ; double x 2 = Math . rint ( x 0 + ( bar . get Width ( ) * b ) ) ; double x 3 = Math . rint ( x 0 + ( bar . get Width ( ) * c ) ) ; result [ NUM_ ] = new Rectangle 2 D . Double ( bar . get Min X ( ) , bar . get Min Y ( ) , x 1 - x 0 , bar . get Height ( ) ) ; result [ NUM_ ] = new Rectangle 2 D . Double ( x 1 , bar . get Min Y ( ) , x 2 - x 1 , bar . get Height ( ) ) ; result [ NUM_ ] = new Rectangle 2 D . Double ( x 2 , bar . get Min Y ( ) , x 3 - x 2 , bar . get Height ( ) ) ; result [ NUM_ ] = new Rectangle 2 D . Double ( x 3 , bar . get Min Y ( ) , bar . get Max X ( ) - x 3 , bar . get Height ( ) ) ; return result ; }
public void increment Node Capacity ( RM Node rm Node , Resource added Capacity ) { set Node Capacity ( rm Node , Resources . add ( rm Node . get Total Capability ( ) , added Capacity ) ) ; }
private double calc Normalized Distance ( double [ ] point ) { double [ ] center = get Center ( ) ; double res = NUM_ ; for ( int i = NUM_ ; i < center . length ; i ++ ) { double diff = center [ i ] - point [ i ] ; res += ( diff * diff ) ; } return Math . sqrt ( res ) ; }
private static Instruction make Phi Instruction ( Heap Variable < Object > H , Basic Block bb ) { int n = bb . get Number Of In ( ) ; Enumeration < Basic Block > in = bb . get In ( ) ; Heap Operand < Object > lhs = new Heap Operand < Object > ( H ) ; Instruction s = Phi . create ( PHI , lhs , n ) ; lhs . set Instruction ( s ) ; for ( int i = NUM_ ; i < n ; i ++ ) { Heap Operand < Object > op = new Heap Operand < Object > ( H ) ; op . set Instruction ( s ) ; Phi . set Value ( s , i , op ) ; Basic Block pred = in . next Element ( ) ; Phi . set Pred ( s , i , new Basic Block Operand ( pred ) ) ; } return s ; }
@ Override public void collect Statistics Information ( Access Profile access Profile ) throws Base Collection Exception { initialize Context ( access Profile ) ; stats Collector . collect ( access Profile , key Map ) ; dump Stat Records ( ) ; inject Stats ( ) ; }
private boolean verify Signature ( String [ ] record , int sign Pos , int rec Pos ) throws Exception { String cur Sign = record [ sign Pos ] ; byte [ ] prev MAC = helper . to Byte Array ( cur MAC ) ; byte [ ] new MAC ; if ( ( prev Signature == null ) || prev Signature . equals ( STR_ ) ) { new MAC = new byte [ prev MAC . length ] ; System . arraycopy ( prev MAC , NUM_ , new MAC , NUM_ , prev MAC . length ) ; } else { new MAC = new byte [ prev MAC . length + helper . to Byte Array ( prev Signature ) . length ] ; System . arraycopy ( prev MAC , NUM_ , new MAC , NUM_ , prev MAC . length ) ; System . arraycopy ( helper . to Byte Array ( prev Signature ) , NUM_ , new MAC , prev MAC . length , helper . to Byte Array ( prev Signature ) . length ) ; } if ( rec Pos != NUM_ ) { prev Signature = cur Sign ; } verified = helper . verify Signature ( helper . to Byte Array ( cur Sign ) , new MAC ) ; return verified ; }
private void email Attendees ( ) { Intent i = new Intent ( get Activity ( ) , Quick Response Activity . class ) ; i . put Extra ( Quick Response Activity . EXTRA EVENT ID , m Event Id ) ; i . add Flags ( Intent . FLAG ACTIVITY NEW TASK ) ; start Activity ( i ) ; }
@ Override public void flip ( W Component Peer peer , Component target , Volatile Image back Buffer , int x 1 , int y 1 , int x 2 , int y 2 , Buffer Capabilities . Flip Contents flip Action ) { Surface Manager d 3 dvsm = Surface Manager . get Manager ( back Buffer ) ; Surface Data sd = d 3 dvsm . get Primary Surface Data ( ) ; if ( sd instanceof D 3 D Surface Data ) { D 3 D Surface Data d 3 dsd = ( D 3 D Surface Data ) sd ; D 3 D Surface Data . swap Buffers ( d 3 dsd , x 1 , y 1 , x 2 , y 2 ) ; } else { Graphics g = peer . get Graphics ( ) ; try { g . draw Image ( back Buffer , x 1 , y 1 , x 2 , y 2 , x 1 , y 1 , x 2 , y 2 , null ) ; } finally { g . dispose ( ) ; } } if ( flip Action == Buffer Capabilities . Flip Contents . BACKGROUND ) { Graphics g = back Buffer . get Graphics ( ) ; try { g . set Color ( target . get Background ( ) ) ; g . fill Rect ( NUM_ , NUM_ , back Buffer . get Width ( ) , back Buffer . get Height ( ) ) ; } finally { g . dispose ( ) ; } } }
public void add Enabled Rule ( Enabled Rule enabled Rule ) { Preconditions . check Not Null Argument ( enabled Rule ) ; if ( enabled Rules == null ) { enabled Rules = new Array List < > ( ) ; } if ( ! enabled Rules . contains ( enabled Rule ) ) { enabled Rules . add ( enabled Rule ) ; } }
@ Override public void do Run Keys ( int run ) throws Exception { if ( m Instances == null ) { throw new Exception ( STR_ ) ; } Object [ ] se Key = m Split Evaluator . get Key ( ) ; Object [ ] key = new Object [ se Key . length + NUM_ ] ; key [ NUM_ ] = Utils . back Quote Chars ( m Instances . relation Name ( ) ) ; key [ NUM_ ] = STR_ + ( ( ( run - NUM_ ) % m Num Folds ) + NUM_ ) ; key [ NUM_ ] = STR_ + ( ( ( run - NUM_ ) / m Num Folds ) + NUM_ ) ; System . arraycopy ( se Key , NUM_ , key , NUM_ , se Key . length ) ; if ( m Result Listener . is Result Required ( this , key ) ) { try { m Result Listener . accept Result ( this , key , null ) ; } catch ( Exception ex ) { throw ex ; } } }
@ Override public void on Init ( List < ? extends Index Commit > commits ) throws IO Exception { if ( commits . is Empty ( ) ) { return ; } log . debug ( STR_ , new Commits Logging Debug ( commits ) ) ; update Commits ( commits ) ; }
public int grid Magnitude Model ( ) { double pixel Size Model = to Model ( NUM_ ) ; double pixel Size Model Log = Math Util . log 10 ( pixel Size Model ) ; int grid Mag = ( int ) Math . ceil ( pixel Size Model Log ) ; double grid Size Model = Math . pow ( NUM_ , grid Mag ) ; double grid Size View = to View ( grid Size Model ) ; if ( grid Size View <= MIN GRID RESOLUTION PIXELS ) grid Mag += NUM_ ; return grid Mag ; }
public static < U > Function < U , Predicate < U > > not Self ( ) { return null ; }
public boolean validate Embed Action ( ) throws Open Stego Exception { return true ; }
protected void add Axioms ( final Collection < Bigdata Statement > axioms ) { super . add Axioms ( axioms ) ; final Bigdata Value Factory value Factory = get Value Factory ( ) ; axioms . add ( value Factory . create Statement ( RDF . TYPE , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . SUBJECT , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . PREDICATE , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . OBJECT , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . FIRST , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . REST , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . VALUE , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . NIL , RDF . TYPE , RDF . LIST , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . TYPE , RDFS . DOMAIN , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . DOMAIN , RDFS . DOMAIN , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . RANGE , RDFS . DOMAIN , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SUBPROPERTYOF , RDFS . DOMAIN , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SUBCLASSOF , RDFS . DOMAIN , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . SUBJECT , RDFS . DOMAIN , RDF . STATEMENT , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . PREDICATE , RDFS . DOMAIN , RDF . STATEMENT , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . OBJECT , RDFS . DOMAIN , RDF . STATEMENT , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . MEMBER , RDFS . DOMAIN , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . FIRST , RDFS . DOMAIN , RDF . LIST , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . REST , RDFS . DOMAIN , RDF . LIST , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SEEALSO , RDFS . DOMAIN , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . ISDEFINEDBY , RDFS . DOMAIN , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . COMMENT , RDFS . DOMAIN , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . LABEL , RDFS . DOMAIN , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . VALUE , RDFS . DOMAIN , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . TYPE , RDFS . RANGE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . DOMAIN , RDFS . RANGE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . RANGE , RDFS . RANGE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SUBPROPERTYOF , RDFS . RANGE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SUBCLASSOF , RDFS . RANGE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . SUBJECT , RDFS . RANGE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . PREDICATE , RDFS . RANGE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . OBJECT , RDFS . RANGE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . MEMBER , RDFS . RANGE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . FIRST , RDFS . RANGE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . REST , RDFS . RANGE , RDF . LIST , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SEEALSO , RDFS . RANGE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . ISDEFINEDBY , RDFS . RANGE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . COMMENT , RDFS . RANGE , RDFS . LITERAL , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . LABEL , RDFS . RANGE , RDFS . LITERAL , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . VALUE , RDFS . RANGE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . ALT , RDFS . SUBCLASSOF , RDFS . CONTAINER , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . BAG , RDFS . SUBCLASSOF , RDFS . CONTAINER , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . SEQ , RDFS . SUBCLASSOF , RDFS . CONTAINER , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CONTAINERMEMBERSHIPPROPERTY , RDFS . SUBCLASSOF , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . ISDEFINEDBY , RDFS . SUBPROPERTYOF , RDFS . SEEALSO , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . XMLLITERAL , RDF . TYPE , RDFS . DATATYPE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . XMLLITERAL , RDFS . SUBCLASSOF , RDFS . LITERAL , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . DATATYPE , RDFS . SUBCLASSOF , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . RESOURCE , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . OBJECT , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . REST , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . XMLLITERAL , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . NIL , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . FIRST , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . VALUE , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . SUBJECT , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . TYPE , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . PREDICATE , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . RESOURCE , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . DOMAIN , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . RESOURCE , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CLASS , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . PROPERTY , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CLASS , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . DOMAIN , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . PROPERTY , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . DOMAIN , RDFS . SUBPROPERTYOF , RDFS . DOMAIN , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CLASS , RDFS . SUBCLASSOF , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . PROPERTY , RDFS . SUBCLASSOF , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CLASS , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . PROPERTY , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . DATATYPE , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CONTAINERMEMBERSHIPPROPERTY , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SEEALSO , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . RANGE , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SEEALSO , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . RANGE , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SEEALSO , RDFS . SUBPROPERTYOF , RDFS . SEEALSO , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . RANGE , RDFS . SUBPROPERTYOF , RDFS . RANGE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . STATEMENT , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . STATEMENT , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . STATEMENT , RDFS . SUBCLASSOF , RDF . STATEMENT , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . STATEMENT , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . LITERAL , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . LABEL , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . LABEL , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . LITERAL , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . LITERAL , RDFS . SUBCLASSOF , RDFS . LITERAL , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . LABEL , RDFS . SUBPROPERTYOF , RDFS . LABEL , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . LITERAL , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . XMLLITERAL , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CONTAINER , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . ALT , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SUBCLASSOF , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . ALT , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CONTAINER , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CONTAINER , RDFS . SUBCLASSOF , RDFS . CONTAINER , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . ALT , RDFS . SUBCLASSOF , RDF . ALT , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SUBCLASSOF , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SUBCLASSOF , RDFS . SUBPROPERTYOF , RDFS . SUBCLASSOF , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CONTAINER , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . ALT , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . SEQ , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . BAG , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . OBJECT , RDFS . SUBPROPERTYOF , RDF . OBJECT , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . MEMBER , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . MEMBER , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . MEMBER , RDFS . SUBPROPERTYOF , RDFS . MEMBER , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . ISDEFINEDBY , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SUBPROPERTYOF , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SUBPROPERTYOF , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . ISDEFINEDBY , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . ISDEFINEDBY , RDFS . SUBPROPERTYOF , RDFS . ISDEFINEDBY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . SUBPROPERTYOF , RDFS . SUBPROPERTYOF , RDFS . SUBPROPERTYOF , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . DATATYPE , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . XMLLITERAL , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . DATATYPE , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . DATATYPE , RDFS . SUBCLASSOF , RDFS . DATATYPE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . XMLLITERAL , RDFS . SUBCLASSOF , RDF . XMLLITERAL , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . REST , RDFS . SUBPROPERTYOF , RDF . REST , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . SEQ , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . SEQ , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . SEQ , RDFS . SUBCLASSOF , RDF . SEQ , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . LIST , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . LIST , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . LIST , RDFS . SUBCLASSOF , RDF . LIST , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . LIST , RDFS . SUBCLASSOF , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . COMMENT , RDF . TYPE , RDF . PROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . COMMENT , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . COMMENT , RDFS . SUBPROPERTYOF , RDFS . COMMENT , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . BAG , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . BAG , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . BAG , RDFS . SUBCLASSOF , RDF . BAG , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . FIRST , RDFS . SUBPROPERTYOF , RDF . FIRST , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . VALUE , RDFS . SUBPROPERTYOF , RDF . VALUE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CONTAINERMEMBERSHIPPROPERTY , RDF . TYPE , RDFS . CLASS , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CONTAINERMEMBERSHIPPROPERTY , RDFS . SUBCLASSOF , RDFS . CONTAINERMEMBERSHIPPROPERTY , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDFS . CONTAINERMEMBERSHIPPROPERTY , RDF . TYPE , RDFS . RESOURCE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . SUBJECT , RDFS . SUBPROPERTYOF , RDF . SUBJECT , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . TYPE , RDFS . SUBPROPERTYOF , RDF . TYPE , null , Statement Enum . Axiom ) ) ; axioms . add ( value Factory . create Statement ( RDF . PREDICATE , RDFS . SUBPROPERTYOF , RDF . PREDICATE , null , Statement Enum . Axiom ) ) ; }
public String property ( Property Type p ) { return prop + p . suffix ( ) ; }
protected void estimate Cardinality ( Statement Pattern Node sp , final AST 2 B Op Context ctx , final I Binding Set exogenous Bindings , final int nr Exogeneous Bindings ) { final Atomic Boolean uses Exogeneous Bindings = new Atomic Boolean ( false ) ; final IV < ? , ? > s = get IV ( sp . s ( ) , exogenous Bindings , uses Exogeneous Bindings ) ; final IV < ? , ? > p = get IV ( sp . p ( ) , exogenous Bindings , uses Exogeneous Bindings ) ; final IV < ? , ? > o = get IV ( sp . o ( ) , exogenous Bindings , uses Exogeneous Bindings ) ; final IV < ? , ? > c = get IV ( sp . c ( ) , exogenous Bindings , uses Exogeneous Bindings ) ; final int exogenous Bindings Adjustment Factor = uses Exogeneous Bindings . get ( ) ? Math . max ( NUM_ , nr Exogeneous Bindings ) : NUM_ ; estimate Cardinalities ( sp , s , p , o , c , ctx , exogenous Bindings Adjustment Factor ) ; }
public Stream Consumer ( Input Stream stream ) { in = new Buffered Input Stream ( stream ) ; thread . start ( ) ; }
public void scan ( String original Xml ) { Matcher matcher = INSTRUCTION PATTERN . matcher ( original Xml ) ; while ( matcher . find ( ) ) { scan One Instruction ( matcher . group ( NUM_ ) ) ; contains Ignored Sections = true ; } if ( expected Next Instruction != IGNORE ) { add Error ( String . format ( STR_ , IGNORE , RESUME ) ) ; } }
private void unmark Removed Default Session Token ( String site , String token ) { if ( removed Default Tokens == null ) return ; Hash Set < String > removed = removed Default Tokens . get ( site ) ; if ( removed == null ) return ; removed . remove ( token ) ; }
protected static double ludcmp ( double [ ] [ ] A , int [ ] index ) { final double TINY = NUM_ ; double [ ] vv = new double [ NUM_ ] ; double d = NUM_ ; double temp , sum ; for ( int i = NUM_ ; i < NUM_ ; i += NUM_ ) { double big = NUM_ ; for ( int j = NUM_ ; j < NUM_ ; j += NUM_ ) { if ( ( temp = Math . abs ( A [ i ] [ j ] ) ) > big ) { big = temp ; } } if ( big == NUM_ ) { return NUM_ ; } else { vv [ i ] = NUM_ / big ; } } for ( int j = NUM_ ; j < NUM_ ; j += NUM_ ) { for ( int i = NUM_ ; i < j ; i += NUM_ ) { sum = A [ i ] [ j ] ; for ( int k = NUM_ ; k < i ; k += NUM_ ) { sum -= A [ i ] [ k ] * A [ k ] [ j ] ; } A [ i ] [ j ] = sum ; } double big = NUM_ ; double dum ; int imax = - NUM_ ; for ( int i = j ; i < NUM_ ; i += NUM_ ) { sum = A [ i ] [ j ] ; for ( int k = NUM_ ; k < j ; k ++ ) { sum -= A [ i ] [ k ] * A [ k ] [ j ] ; } A [ i ] [ j ] = sum ; if ( ( dum = vv [ i ] * Math . abs ( sum ) ) >= big ) { big = dum ; imax = i ; } } if ( j != imax ) { for ( int k = NUM_ ; k < NUM_ ; k += NUM_ ) { dum = A [ imax ] [ k ] ; A [ imax ] [ k ] = A [ j ] [ k ] ; A [ j ] [ k ] = dum ; } d = - d ; vv [ imax ] = vv [ j ] ; } index [ j ] = imax ; if ( A [ j ] [ j ] == NUM_ ) A [ j ] [ j ] = TINY ; if ( j != NUM_ ) { dum = NUM_ / A [ j ] [ j ] ; for ( int i = j + NUM_ ; i < NUM_ ; i += NUM_ ) { A [ i ] [ j ] *= dum ; } } } return d ; }
private static void add Curve ( Path 2 D line , Point 2 D p 0 , Point 2 D p 1 , Point 2 D p 2 , Point 2 D p 3 , Point 2 D ctrl 1 , Point 2 D ctrl 2 , double smoothness ) { if ( p 1 == null ) { return ; } if ( line . get Current Point ( ) == null ) { line . move To ( p 1 . get X ( ) , p 1 . get Y ( ) ) ; } if ( p 2 == null ) { return ; } get Controls Points ( p 0 , p 1 , p 2 , p 3 , ctrl 1 , ctrl 2 , smoothness ) ; line . curve To ( ctrl 1 . get X ( ) , ctrl 1 . get Y ( ) , ctrl 2 . get X ( ) , ctrl 2 . get Y ( ) , p 2 . get X ( ) , p 2 . get Y ( ) ) ; }
private void draw Result Points ( Bitmap barcode , float scale Factor , Result raw Result ) { Result Point [ ] points = raw Result . get Result Points ( ) ; if ( points != null && points . length > NUM_ ) { Canvas canvas = new Canvas ( barcode ) ; Paint paint = new Paint ( ) ; paint . set Color ( Context Compat . get Color ( this , R . color . result points ) ) ; if ( points . length == NUM_ ) { paint . set Stroke Width ( NUM_ ) ; draw Line ( canvas , paint , points [ NUM_ ] , points [ NUM_ ] , scale Factor ) ; } else if ( points . length == NUM_ && ( raw Result . get Barcode Format ( ) == Barcode Format . UPC A || raw Result . get Barcode Format ( ) == Barcode Format . EAN 13 ) ) { draw Line ( canvas , paint , points [ NUM_ ] , points [ NUM_ ] , scale Factor ) ; draw Line ( canvas , paint , points [ NUM_ ] , points [ NUM_ ] , scale Factor ) ; } else { paint . set Stroke Width ( NUM_ ) ; for ( Result Point point : points ) { if ( point != null ) { canvas . draw Point ( scale Factor * point . get X ( ) , scale Factor * point . get Y ( ) , paint ) ; } } } } }
public Color Triangle ( ) { Byte Buffer vbb = Byte Buffer . allocate Direct ( triangle Coords . length * NUM_ ) ; vbb . order ( Byte Order . native Order ( ) ) ; vertex Buffer = vbb . as Float Buffer ( ) ; vertex Buffer . put ( triangle Coords ) ; vertex Buffer . position ( NUM_ ) ; Byte Buffer cbb = Byte Buffer . allocate Direct ( colors . length * NUM_ ) ; cbb . order ( Byte Order . native Order ( ) ) ; color Buffer = cbb . as Float Buffer ( ) ; color Buffer . put ( colors ) ; color Buffer . position ( NUM_ ) ; index Buffer = Byte Buffer . allocate Direct ( indices . length ) ; index Buffer . order ( Byte Order . native Order ( ) ) ; index Buffer . put ( indices ) ; index Buffer . position ( NUM_ ) ; }
synchronized RVM Type load VM Class ( String class Name ) throws No Class Def Found Error { try { Input Stream is = get Resource As Stream ( class Name . replace ( STR_ , File . separator Char ) + STR_ ) ; if ( is == null ) throw new No Class Def Found Error ( class Name ) ; Data Input Stream data Input Stream = new Data Input Stream ( is ) ; RVM Type type = null ; try { type = RVM Class Loader . define Class Internal ( class Name , data Input Stream , this ) ; loaded . put ( class Name , type ) ; } finally { try { data Input Stream . close ( ) ; } catch ( IO Exception e ) { } } return type ; } catch ( No Class Def Found Error e ) { throw e ; } catch ( Throwable e ) { No Class Def Found Error ncdf = new No Class Def Found Error ( class Name ) ; ncdf . init Cause ( e ) ; throw ncdf ; } }
public static String TO STRING ( String txt ) { return TO STRING ( txt , NUM_ ) ; }
protected void initialize Column Labels ( ) { if ( get Num Objective Functions ( ) == NUM_ ) { column Labels . add ( STR_ ) ; } column Labels . add ( STR_ ) ; for ( int i = NUM_ ; i < get Original Num Decision Variables ( ) ; i ++ ) { column Labels . add ( STR_ + i ) ; } if ( ! restrict To Non Negative ) { column Labels . add ( NEGATIVE VAR COLUMN LABEL ) ; } for ( int i = NUM_ ; i < get Num Slack Variables ( ) ; i ++ ) { column Labels . add ( STR_ + i ) ; } for ( int i = NUM_ ; i < get Num Artificial Variables ( ) ; i ++ ) { column Labels . add ( STR_ + i ) ; } column Labels . add ( STR_ ) ; }
private static int compute Capacity ( final int expected Size ) { if ( expected Size == NUM_ ) { return NUM_ ; } final int capacity = ( int ) Fast Math . ceil ( expected Size / LOAD FACTOR ) ; final int power Of Two = Integer . highest One Bit ( capacity ) ; if ( power Of Two == capacity ) { return capacity ; } return next Power Of Two ( capacity ) ; }
public void write Host Port Format ( Data Output out ) throws IO Exception { if ( csf != null ) { throw new Internal Error ( STR_ + STR_ ) ; } out . write UTF ( host ) ; out . write Int ( port ) ; }
public Map < String , Object > for Thread ( Thread t ) { return new Hash Map < String , Object > ( PER THREAD CONTEXTS . get Unchecked ( t ) ) ; }
protected void draw Domain Markers ( Graphics 2 D g 2 , Rectangle 2 D data Area , int index , Layer layer ) { XY Item Renderer r = get Renderer ( index ) ; if ( r == null ) { return ; } if ( index >= get Dataset Count ( ) ) { return ; } Collection markers = get Domain Markers ( index , layer ) ; Value Axis axis = get Domain Axis For Dataset ( index ) ; if ( markers != null && axis != null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . has Next ( ) ) { Marker marker = ( Marker ) iterator . next ( ) ; r . draw Domain Marker ( g 2 , this , axis , marker , data Area ) ; } } }
private void validate Add Params ( T source , String source ID , T target , Position p ) { if ( source == null || source ID == null || source ID . length ( ) < NUM_ || target == null || p == null ) { String message = null ; if ( source == null ) { message = STR_ ; } else if ( source ID == null ) { message = STR_ + source + STR_ + source ID ; } else if ( target == null ) { message = STR_ ; } else if ( p == null ) { message = STR_ + p ; } throw new Illegal Argument Exception ( message ) ; } }
private void fetch Users Service Cards From Server ( String user Id ) { Retro Callback retro Callback ; retro Callback = new Retro Callback ( this ) ; retro Callback . set Request Id ( Api Response Codes . GET USERS SERVICES ) ; retro Callback List . add ( retro Callback ) ; m Yelo Api . get Users Service Cards ( user Id , retro Callback ) ; }
public static void compute Polygon Normal ( Float Buffer vertex Buffer , Float Buffer normal Buffer , boolean z Pos ) { int n = vertex Buffer . limit ( ) ; double count = NUM_ ; Vector 3 mean Normal = new Vector 3 ( ) ; Vector 3 vec 0 = new Vector 3 ( ) ; Vector 3 vec 1 = new Vector 3 ( ) ; Vector 3 vec 2 = new Vector 3 ( ) ; mean Normal . set ( NUM_ , NUM_ , NUM_ ) ; for ( int i = NUM_ ; i < n ; i += NUM_ ) { vec 0 . set ( vertex Buffer . get ( i ) , vertex Buffer . get ( i + NUM_ ) , vertex Buffer . get ( i + NUM_ ) ) ; vec 1 . set ( vertex Buffer . get ( i + NUM_ ) , vertex Buffer . get ( i + NUM_ ) , vertex Buffer . get ( i + NUM_ ) ) ; vec 2 . set ( vertex Buffer . get ( i + NUM_ ) , vertex Buffer . get ( i + NUM_ ) , vertex Buffer . get ( i + NUM_ ) ) ; vec 0 . subtract Local ( vec 1 ) ; vec 1 . subtract Local ( vec 2 ) ; vec 0 . cross Local ( vec 1 ) ; if ( z Pos && ( vec 0 . get Z ( ) < NUM_ ) ) { vec 0 . negate Local ( ) ; } mean Normal . add Local ( vec 0 ) ; count ++ ; } mean Normal . multiply Local ( NUM_ / count ) ; mean Normal . normalize Local ( ) ; for ( int i = NUM_ ; i < vertex Buffer . limit ( ) ; i += NUM_ ) { normal Buffer . put ( mean Normal . get Xf ( ) ) ; normal Buffer . put ( mean Normal . get Yf ( ) ) ; normal Buffer . put ( mean Normal . get Zf ( ) ) ; } normal Buffer . flip ( ) ; }
public String create Modified Ref ( String base Ref , Color color , Composite blend ) { String color Name = Integer . to Hex String ( color . get RGB ( ) ) ; return base Ref + STR_ + blend . to String ( ) + STR_ + color Name ; }
static boolean recover Lock Grantor ( Set members , D Lock Service service , D Lock Grantor new Grantor , DM dm , Internal Distributed Member elder ) { D Lock Recover Grantor Processor processor = new D Lock Recover Grantor Processor ( dm , members , new Grantor ) ; D Lock Recover Grantor Message msg = new D Lock Recover Grantor Message ( ) ; msg . service Name = service . get Name ( ) ; msg . processor Id = processor . get Processor Id ( ) ; msg . grantor Version = new Grantor . get Version Id ( ) ; msg . grantor Serial Number = service . get Serial Number ( ) ; msg . elder = elder ; Set recipients = new Hash Set ( members ) ; recipients . remove ( dm . get Id ( ) ) ; if ( ! recipients . is Empty ( ) ) { msg . set Recipients ( recipients ) ; dm . put Outgoing ( msg ) ; } if ( msg . get Sender ( ) == null ) msg . set Sender ( dm . get Id ( ) ) ; msg . schedule Message ( dm ) ; try { processor . wait For Replies Uninterruptibly ( ) ; } catch ( Reply Exception e ) { e . handle As Unexpected ( ) ; } if ( processor . error ) { return false ; } return true ; }
@ Nullable public byte [ ] find Class Definition ( @ Not Null String name , @ Not Null App Resource Repository app Repo ) { int index = name . last Index Of ( STR_ ) ; if ( index != - NUM_ && name . char At ( index + NUM_ ) == STR_ && ( index == name . length ( ) - NUM_ || name . char At ( index + NUM_ ) == STR_ ) && index > NUM_ ) { String pkg = name . substring ( NUM_ , index ) ; if ( my Packages != null && my Packages . contains ( pkg ) ) { Aar Resource Class Generator generator = my Generator Map . get ( app Repo ) ; if ( generator != null ) { return generator . generate ( name ) ; } } } return null ; }
@ Override public void stop All Mutators ( ) { Trace . trace ( Item . SCHEDULER , STR_ ) ; synchronized ( trigger ) { set State ( BLOCKING ) ; trigger . notify All ( ) ; } wait For GC Start ( ) ; Trace . trace ( Item . SCHEDULER , STR_ ) ; }
private boolean run Constant Check ( Data Identifier dat 1 ) throws Language Exception { LOG . trace ( STR_ ) ; boolean ret = true ; Linear Function f 1 = get Linear Function ( dat 1 ) ; if ( f 1 == null ) return true ; LOG . trace ( STR_ + f 1 . to String ( ) ) ; boolean gcheck = true ; for ( String var : bounds . local ) { if ( var . starts With ( INTERAL FN INDEX ROW ) || var . starts With ( INTERAL FN INDEX COL ) ) { continue ; } boolean lcheck = false ; for ( int i = NUM_ ; i < f 1 . vars . length ; i ++ ) if ( var . equals ( f 1 . vars [ i ] ) ) if ( f 1 . b [ i ] != NUM_ ) lcheck = true ; if ( ! lcheck ) { gcheck = false ; break ; } } if ( gcheck ) ret = false ; return ret ; }
@ Suppress Warnings ( STR_ ) public void query For List ( String cf Name , String [ ] ids ) throws Exception { final Class clazz = get Class From CF Name ( cf Name ) ; if ( clazz == null ) { return ; } for ( String id : ids ) { query And Print Record ( URI . create ( id ) , clazz , Db Cli Operation . LIST ) ; } }
@ Override public void run ( ) { am I Active = true ; String input File ; String output File ; double x , y ; int progress ; int i , j , k ; int feature Num , num Features ; int filter Size , half Filter Size ; double [ ] [ ] geometry ; int num Points , num Parts , part , starting Point In Part , ending Point In Part ; int num Points In Filter ; Shape Type shape Type ; Shape File Record output Record ; double sum X , sum Y ; if ( args . length <= NUM_ ) { show Feedback ( STR_ ) ; return ; } input File = args [ NUM_ ] ; output File = args [ NUM_ ] ; filter Size = Integer . parse Int ( args [ NUM_ ] ) ; if ( filter Size < NUM_ ) { filter Size = NUM_ ; } if ( filter Size % NUM_ == NUM_ ) { show Feedback ( STR_ + STR_ ) ; filter Size ++ ; } half Filter Size = ( int ) Math . floor ( filter Size / NUM_ ) ; if ( ( input File == null ) || ( output File == null ) ) { show Feedback ( STR_ ) ; return ; } try { Shape File input = new Shape File ( input File ) ; shape Type = input . get Shape Type ( ) ; if ( shape Type . get Base Type ( ) != Shape Type . POLYLINE && shape Type . get Base Type ( ) != Shape Type . POLYGON ) { show Feedback ( STR_ ) ; return ; } Shape File output = new Shape File ( output File , shape Type ) ; File Utilities . copy File ( new File ( input . get Database File ( ) ) , new File ( output . get Database File ( ) ) ) ; output . set Projection String From Other Shapefile ( input ) ; num Features = input . get Number Of Records ( ) ; feature Num = NUM_ ; for ( Shape File Record record : input . records ) { feature Num ++ ; Points List points = new Points List ( ) ; geometry = get XY From Shapefile Record ( record ) ; num Points = geometry . length ; num Parts = part Data . length ; for ( part = NUM_ ; part < num Parts ; part ++ ) { starting Point In Part = part Data [ part ] ; if ( part < num Parts - NUM_ ) { ending Point In Part = part Data [ part + NUM_ ] ; } else { ending Point In Part = num Points ; } if ( geometry [ starting Point In Part ] [ NUM_ ] == geometry [ ending Point In Part - NUM_ ] [ NUM_ ] && geometry [ starting Point In Part ] [ NUM_ ] == geometry [ ending Point In Part - NUM_ ] [ NUM_ ] ) { for ( i = starting Point In Part ; i < ending Point In Part ; i ++ ) { num Points In Filter = NUM_ ; sum X = NUM_ ; sum Y = NUM_ ; for ( j = i - half Filter Size ; j <= i + half Filter Size ; j ++ ) { k = j ; if ( k < starting Point In Part ) { k = ending Point In Part + k - NUM_ ; } if ( k >= ending Point In Part ) { k = starting Point In Part + ( k - ending Point In Part ) + NUM_ ; } if ( k >= starting Point In Part && k < ending Point In Part ) { num Points In Filter ++ ; sum X += geometry [ k ] [ NUM_ ] ; sum Y += geometry [ k ] [ NUM_ ] ; } } x = sum X / num Points In Filter ; y = sum Y / num Points In Filter ; points . add Point ( x , y ) ; } } else { for ( i = starting Point In Part ; i < ending Point In Part ; i ++ ) { num Points In Filter = NUM_ ; sum X = NUM_ ; sum Y = NUM_ ; for ( j = i - half Filter Size ; j <= i + half Filter Size ; j ++ ) { if ( j >= starting Point In Part && j < ending Point In Part ) { num Points In Filter ++ ; sum X += geometry [ j ] [ NUM_ ] ; sum Y += geometry [ j ] [ NUM_ ] ; } } x = sum X / num Points In Filter ; y = sum Y / num Points In Filter ; points . add Point ( x , y ) ; } } } switch ( shape Type ) { case POLYLINE : Poly Line line = new Poly Line ( part Data , points . get Points Array ( ) ) ; output . add Record ( line ) ; break ; case POLYLINEZ : Poly Line Z poly Line Z = ( Poly Line Z ) ( record . get Geometry ( ) ) ; Poly Line Z linez = new Poly Line Z ( part Data , points . get Points Array ( ) , poly Line Z . getz Array ( ) , poly Line Z . getm Array ( ) ) ; output . add Record ( linez ) ; break ; case POLYLINEM : Poly Line M poly Line M = ( Poly Line M ) ( record . get Geometry ( ) ) ; Poly Line M linem = new Poly Line M ( part Data , points . get Points Array ( ) , poly Line M . getm Array ( ) ) ; output . add Record ( linem ) ; break ; case POLYGON : Polygon poly = new Polygon ( part Data , points . get Points Array ( ) ) ; output . add Record ( poly ) ; break ; case POLYGONZ : Polygon Z polygon Z = ( Polygon Z ) ( record . get Geometry ( ) ) ; Polygon Z polyz = new Polygon Z ( part Data , points . get Points Array ( ) , polygon Z . getz Array ( ) , polygon Z . getm Array ( ) ) ; output . add Record ( polyz ) ; break ; case POLYGONM : Polygon M polygon M = ( Polygon M ) ( record . get Geometry ( ) ) ; Polygon M polym = new Polygon M ( part Data , points . get Points Array ( ) , polygon M . getm Array ( ) ) ; output . add Record ( polym ) ; break ; } if ( cancel Op ) { cancel Operation ( ) ; return ; } progress = ( int ) ( feature Num * NUM_ / num Features ) ; update Progress ( progress ) ; } output . write ( ) ; return Data ( output File ) ; } catch ( Out Of Memory Error oe ) { my Host . show Feedback ( STR_ ) ; } catch ( Exception e ) { my Host . show Feedback ( STR_ ) ; my Host . log Exception ( STR_ + get Descriptive Name ( ) , e ) ; } finally { update Progress ( STR_ , NUM_ ) ; am I Active = false ; my Host . plugin Complete ( ) ; } }
public void schedule Fsync ( long sequence , K key , Result < Boolean > result ) { request Sequence = Math . max ( request Sequence , sequence ) ; if ( sequence <= tail Sequence ) { result . ok ( Boolean . TRUE ) ; } else { store Fsync . add Result ( key , result ) ; } }
public String format Delete Share Cmd ( String data Mover , String file Share , String net Bios ) { String Builder cmd = new String Builder ( ) ; cmd . append ( data Mover ) ; cmd . append ( STR_ ) ; cmd . append ( file Share ) ; if ( net Bios != null && net Bios . length ( ) > NUM_ ) { cmd . append ( STR_ ) ; cmd . append ( STR_ + net Bios + STR_ ) ; } return cmd . to String ( ) ; }
private boolean is On List ( Vector < String > list , String name ) { if ( list . size ( ) == NUM_ ) return false ; for ( int i = NUM_ ; i < list . size ( ) ; i ++ ) { String list Name = ( String ) list . get ( i ) ; if ( name . ends With ( list Name ) ) { return true ; } } return false ; }
public Ansible Runner extra Params ( String params ) { if ( params != null && params . length ( ) > NUM_ ) { extra Params = params ; } return this ; }
protected Key Pair Generator ( String algorithm ) { this . algorithm = algorithm ; }
public static synchronized void log Start ( ) { I Product product = Platform . get Product ( ) ; String about Text = product . get Property ( STR_ ) ; String application = STR_ ; if ( about Text != null ) { String lines [ ] = about Text . split ( STR_ ) ; if ( lines != null && lines . length > NUM_ ) { application = lines [ NUM_ ] ; } } LOG . info ( STR_ + application + STR_ + DF . format ( System . current Time Millis ( ) ) ) ; }
public static long reserve Sequence Id ( ) { Thread And Sequence ID Wrapper wrapper = ( Thread And Sequence ID Wrapper ) thread ID Local . get ( ) ; return wrapper . get And Increment Sequence ID ( ) ; }
private void service Notify Do ( Service Item old Item , Service Item item , int action ) { Array List notifies ; synchronized ( s Item Listeners ) { if ( s Item Listeners . is Empty ( ) ) return ; notifies = ( Array List ) s Item Listeners . clone ( ) ; } Iterator iter = notifies . iterator ( ) ; while ( iter . has Next ( ) ) { Service Discovery Listener sl = ( Service Discovery Listener ) iter . next ( ) ; service Notify Do ( old Item , item , action , sl ) ; } }
@ Suppress Warnings ( STR_ ) public static < T > T context Lookup ( Class < T > clazz ) { if ( ENABLED ) { for ( Object o : context ( ) ) { if ( clazz . is Instance ( o ) ) { return ( ( T ) o ) ; } } } return null ; }
protected void build Relation Table Fields ( Managed Class managed Class , Attribute managed Attribute , Linked List < Entity > intrinsic Entity , Linked List < Attribute > intrinsic Attribute , boolean inverse , boolean is Inherited , Foreign Reference Mapping mapping , Table Definition table , List < Database Field > fk Fields , List < Database Field > target Fields ) { assert fk Fields . size ( ) > NUM_ && fk Fields . size ( ) == target Fields . size ( ) ; Database Field fk Field ; Database Field target Field = null ; List < String > fk Field Names = new Array List ( ) ; List < String > target Field Names = new Array List ( ) ; for ( int index = NUM_ ; index < fk Fields . size ( ) ; index ++ ) { fk Field = fk Fields . get ( index ) ; target Field = target Fields . get ( index ) ; fk Field Names . add ( fk Field . get Name Delimited ( database Platform ) ) ; target Field Names . add ( target Field . get Name Delimited ( database Platform ) ) ; fk Field = resolve Database Field ( fk Field , target Field ) ; set Field To Relation Table ( intrinsic Entity . get ( NUM_ ) , intrinsic Attribute , managed Attribute , inverse , is Inherited , fk Field , table ) ; } Database Table target Table = target Field . get Table ( ) ; Table Definition target Tbl Def = get Table Def From DB Table ( managed Class , managed Attribute , intrinsic Entity , target Table ) ; if ( mapping . get Descriptor ( ) . has Table Per Class Policy ( ) ) { return ; } if ( mapping . get Reference Descriptor ( ) . has Table Per Class Policy ( ) && mapping . get Reference Descriptor ( ) . get Table Per Class Policy ( ) . has Child ( ) ) { return ; } add Foreign Key Constraint ( table , target Tbl Def , fk Field Names , target Field Names , mapping . is Cascade On Delete Set On Database ( ) ) ; }
public boolean remove Data Row ( Data Row data Row ) { return data List . remove ( data Row ) ; }
public float drop Gain Chance ( ) { return ( float ) Math . pow ( NUM_ , tier ( ) ) ; }
private void update Promo Visibility ( float percentage ) { if ( is Promo Visible ( ) ) { m Promo Visible = true ; m Promo Height Px = Math . round ( Math Utils . clamp ( percentage * m Promo Content Height Px , NUM_ , m Promo Content Height Px ) ) ; m Promo Opacity = percentage ; } else { m Promo Visible = false ; m Promo Height Px = NUM_ ; m Promo Opacity = NUM_ ; } }
@ Visible For Testing protected static List < String > extract Logcat From Reader ( Buffered Reader reader , int max Lines ) throws IO Exception { return extract Logcat From Reader Internal ( reader , max Lines ) ; }
public static boolean equals ( double [ ] va , double [ ] vb ) { return Arrays . equals ( va , vb ) ; }
public Map < Context , List < Outlier Classification Result > > search Context Given Outliers ( List < Contextual Datum > data , List < Contextual Datum > input Outliers ) throws Exception { List < Context > result = new Array List < Context > ( ) ; if ( input Outliers == null || input Outliers . size ( ) == NUM_ ) { log . info ( STR_ ) ; return context 2 Outliers ; } Stopwatch sw = Stopwatch . create Unstarted ( ) ; log . debug ( STR_ , data . size ( ) ) ; sw . start ( ) ; Hash Set < Contextual Datum > sample = random Sampling ( data , NUM_ ) ; global Context = new Context ( sample , density Pruning , dependency Pruning , alpha ) ; List < Datum > global Outliers = contextual Outlier Detection ( data , global Context ) ; if ( global Outliers != null && global Outliers . contains ( input Outliers ) ) { result . add ( global Context ) ; } sw . stop ( ) ; long global Outlier Detecion Time = sw . elapsed ( Time Unit . MILLISECONDS ) ; sw . reset ( ) ; log . debug ( STR_ , data . size ( ) , global Outlier Detecion Time ) ; List < Lattice Node > pre Lattice Nodes = new Array List < Lattice Node > ( ) ; List < Lattice Node > cur Lattice Nodes = new Array List < Lattice Node > ( ) ; for ( int level = NUM_ ; level <= total Contextual Dimensions ; level ++ ) { if ( level > max Predicates ) break ; log . debug ( STR_ , level ) ; sw . start ( ) ; if ( level == NUM_ ) { cur Lattice Nodes = build One Dimensional Lattice Nodes Given Outliers ( data , input Outliers ) ; } else { cur Lattice Nodes = level Up Lattice ( pre Lattice Nodes , data ) ; } sw . stop ( ) ; long lattice Nodes Build Time Cur Level = sw . elapsed ( Time Unit . MILLISECONDS ) ; sw . reset ( ) ; log . debug ( STR_ , level , lattice Nodes Build Time Cur Level ) ; log . debug ( STR_ , Memory Util . check Memory Usage ( ) ) ; if ( cur Lattice Nodes . size ( ) == NUM_ ) { log . debug ( STR_ ) ; break ; } log . debug ( STR_ , level ) ; sw . start ( ) ; int num Dense Contexts Cur Level = NUM_ ; for ( Lattice Node node : cur Lattice Nodes ) { for ( Context context : node . get Dense Contexts ( ) ) { List < Datum > outliers = contextual Outlier Detection ( data , context ) ; if ( outliers != null && outliers . contains All ( input Outliers ) ) { result . add ( context ) ; } num Dense Contexts Cur Level ++ ; } } sw . stop ( ) ; long contextual Outlier Detection Time Cur Level = sw . elapsed ( Time Unit . MILLISECONDS ) ; sw . reset ( ) ; log . debug ( STR_ , level , contextual Outlier Detection Time Cur Level ) ; log . debug ( STR_ , level , num Dense Contexts Cur Level , ( num Dense Contexts Cur Level == NUM_ ) ? NUM_ : contextual Outlier Detection Time Cur Level / num Dense Contexts Cur Level ) ; log . debug ( STR_ + STR_ + STR_ + STR_ , level , density Pruning 2 , num Outlier Detection Runs Without Training Without Scoring , num Outlier Detection Runs Without Training With Scoring , num Outlier Detection Runs With Training With Scoring ) ; log . debug ( STR_ ) ; if ( level >= NUM_ ) { for ( Lattice Node node : pre Lattice Nodes ) { for ( Context context : node . get Dense Contexts ( ) ) { context 2 Bit Set . remove ( context ) ; } } } pre Lattice Nodes = cur Lattice Nodes ; } Map < Context , List < Outlier Classification Result > > context 2 Outlier Classifier Given Outlier = new Hash Map < > ( ) ; for ( Context context : result ) { context 2 Outlier Classifier Given Outlier . put ( context , context 2 Outliers . get ( context ) ) ; } return context 2 Outlier Classifier Given Outlier ; }
private int compute Num Additional Containers ( Map < String , Integer > component Changes , Packing Plan packing Plan ) { Resource scale Down Resource = Packing Utils . compute Total Resource Change ( topology , component Changes , default Instance Resources , Packing Utils . Scaling Direction . DOWN ) ; Resource scale Up Resource = Packing Utils . compute Total Resource Change ( topology , component Changes , default Instance Resources , Packing Utils . Scaling Direction . UP ) ; Resource additional Resource = scale Up Resource . subtract Absolute ( scale Down Resource ) ; return ( int ) additional Resource . divide By ( packing Plan . get Max Container Resources ( ) ) ; }
public Socket Rpc Channel ( String host , int port ) { this ( host , port , Socket Factory . get Default ( ) ) ; }
private void process Q Cmd ( ) { cmds . add Pop ( ) ; state = ( Parser State ) parser States . pop ( ) ; }
static D Lock Grantor create Grantor ( D Lock Service dlock , long version Id ) { return new D Lock Grantor ( dlock , version Id ) ; }
public Runnable decrement As Runnable ( ) { return m Decrement Runnable ; }
private static char to Lower Case ( char value ) { return Character . to Lower Case ( value ) ; }
private void update Next Clock ( final Pseudo TCP Base tcp , final Object lock ) { try { long now = Pseudo TCP Base . now ( ) ; synchronized ( tcp ) { tcp . notify Clock ( now ) ; } long interval ; synchronized ( tcp ) { interval = tcp . get Next Clock ( Pseudo TCP Base . now ( ) ) ; } if ( logger . is Loggable ( Level . FINEST ) ) { logger . log ( Level . FINEST , tcp . debug Name + STR_ + interval ) ; } if ( interval < NUM_ ) { if ( interval == - NUM_ ) { interval = NUM_ ; } else { return ; } } synchronized ( lock ) { lock . wait ( interval ) ; } } catch ( Interrupted Exception ex ) { } }
public Field Analysis Request add Field Name ( String field Name ) { if ( field Names == null ) { field Names = new Linked List < > ( ) ; } field Names . add ( field Name ) ; return this ; }
private static String compute Digest ( Input Stream in , String algorithm ) throws IO Exception , No Such Algorithm Exception { try { if ( ! ( in instanceof Buffered Input Stream ) ) { in = new Buffered Input Stream ( in , NUM_ ) ; } Message Digest md = Message Digest . get Instance ( algorithm ) ; byte [ ] buf = new byte [ NUM_ ] ; while ( true ) { int n = in . read ( buf ) ; if ( n < NUM_ ) { break ; } md . update ( buf , NUM_ , n ) ; } return digest String ( md . digest ( ) ) ; } finally { try { in . close ( ) ; } catch ( IO Exception e ) { } } }
private void release ( ) { pages . clear ( ) ; pages rendered . clear ( ) ; error = null ; is Working = false ; file name = null ; file = null ; if ( ring Progress Dialog != null ) { ring Progress Dialog . dismiss ( ) ; ring Progress Dialog = null ; } }
public static Cart create Wallet Cart ( com . shopify . buy . model . Cart shopify Cart , Shop shop ) { if ( shopify Cart == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( shop == null ) { throw new Null Pointer Exception ( STR_ ) ; } Cart . Builder builder = Cart . new Builder ( ) ; builder . set Currency Code ( shop . get Currency ( ) ) ; Big Decimal total Price = new Big Decimal ( NUM_ ) ; for ( com . shopify . buy . model . Line Item shopify Line Item : shopify Cart . get Line Items ( ) ) { Line Item line Item = create Wallet Line Item ( shopify Line Item , shop . get Currency ( ) ) ; total Price = total Price . add ( new Big Decimal ( line Item . get Total Price ( ) ) ) ; builder . add Line Item ( line Item ) ; } builder . set Total Price ( total Price . to String ( ) ) ; return builder . build ( ) ; }
private Matching Part create Emo Permission Part ( String part , Part Type part Type ) { part = unescape Separators ( part ) ; switch ( part . char At ( NUM_ ) ) { case STR_ : if ( is Table Resource ( part Type ) && part . starts With ( STR_ ) && part . ends With ( STR_ ) ) { String rison = part . substring ( NUM_ , part . length ( ) - NUM_ ) ; return Rison Helper . from O Rison ( rison , Create Table Part . class ) ; } break ; case STR_ : if ( part . starts With ( STR_ ) && part . ends With ( STR_ ) ) { String condition = part . substring ( NUM_ , part . length ( ) - NUM_ ) ; switch ( part Type ) { case SOR TABLE : return new Sor Table Condition Part ( Conditions . from String ( condition ) , data Store ) ; case BLOB TABLE : return new Blob Table Condition Part ( Conditions . from String ( condition ) , blob Store ) ; default : return new Condition Part ( Conditions . from String ( condition ) ) ; } } break ; case STR_ : if ( part . length ( ) == NUM_ ) { return get Any Part ( ) ; } break ; } Condition condition = Conditions . like ( part ) ; if ( condition instanceof Equal Condition ) { return new Emo Constant Part ( part ) ; } return new Condition Part ( condition ) ; }
public String substitute ( String source ) throws Exception { int index = source . index Of ( STR_ ) ; while ( index >= NUM_ ) { index += NUM_ ; int end Index = source . index Of ( STR_ ) ; if ( end Index >= NUM_ && end Index > index + NUM_ ) { String key = source . substring ( index , end Index ) ; String replace = m env Vars . get ( key ) ; if ( replace != null ) { String to Replace = STR_ + key + STR_ ; source = source . replace ( to Replace , replace ) ; } else { throw new Exception ( STR_ + key + STR_ ) ; } } else { break ; } index = source . index Of ( STR_ ) ; } return source ; }
@ Suppress Warnings ( STR_ ) public Selection Builder reset ( ) { m Table = null ; m Selection . set Length ( NUM_ ) ; m Selection Args . clear ( ) ; return this ; }
@ Override protected void prepare New Batch ( String stmt ) throws SQL Exception { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ ) ; } this . pending Sql Statement = stmt ; this . pending Prepared Statement = conn . prepare Statement ( stmt ) ; this . pending Row Changes = new Linked List < Row Reference > ( ) ; }
public static Progress Dialog create Progress Dialog ( Context c , String message ) { Progress Dialog dialog = new Progress Dialog ( c , Progress Dialog . STYLE SPINNER ) ; dialog . set Indeterminate ( true ) ; dialog . set Message ( message ) ; dialog . set Canceled On Touch Outside ( false ) ; return dialog ; }
@ Override public void unindent ( ) { next Indent -= format . get Indent ( ) ; if ( next Indent < NUM_ ) next Indent = NUM_ ; if ( ( line . length ( ) + spaces + text . length ( ) ) == NUM_ ) this Indent = next Indent ; }
public static Term Vectors From Lucene create Term Based RRI Vectors ( Flag Config flag Config ) throws IO Exception , Runtime Exception { Term Vectors From Lucene term Vectors = new Term Vectors From Lucene ( flag Config ) ; term Vectors . lucene Utils = new Lucene Utils ( flag Config ) ; term Vectors . create Term Based RRI Vectors Impl ( ) ; return term Vectors ; }
protected int hash ( Object o ) { int h = o == null ? NUM_ : o . hash Code ( ) ; h += ( h << NUM_ ) ^ NUM_ ; h ^= ( h > > > NUM_ ) ; h += ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; h += ( h << NUM_ ) + ( h << NUM_ ) ; return h ^ ( h > > > NUM_ ) ; }
public void randomize ( Random random ) { for ( int j = num Instances ( ) - NUM_ ; j > NUM_ ; j -- ) { swap ( j , random . next Int ( j + NUM_ ) ) ; } }
public Object group Change ( String group Column Name , Object value ) { if ( ! is Group Column ( group Column Name ) ) return null ; Object new Value = value ; if ( new Value == null ) new Value = NULL ; if ( m group Map . contains Key ( group Column Name ) ) { Object old Value = m group Map . get ( group Column Name ) ; if ( new Value . equals ( old Value ) ) return null ; m group Map . put ( group Column Name , new Value ) ; return old Value ; } m group Map . put ( group Column Name , new Value ) ; return null ; }
public void stop ( ) { stop Streaming Quote ( ) ; }
public static synchronized Unit Table find Table ( Faction Record faction , int unit Type , int year , String rating , Collection < Integer > weight Classes , int network Mask , Collection < Entity Movement Mode > movement Modes , Collection < Mission Role > roles , int role Strictness , Faction Record deploying Faction ) { Objects . require Non Null ( faction ) ; Cache Key key = new Cache Key ( faction , unit Type , year , rating , weight Classes , network Mask , movement Modes , roles , role Strictness , deploying Faction ) ; Unit Table ret Val = cache . get ( key ) ; if ( ret Val == null ) { ret Val = new Unit Table ( key ) ; if ( ret Val . has Units ( ) ) { cache . put ( key , ret Val ) ; } } return ret Val ; }
public static SSL Context create SSL Context ( String trusted Cert , String client Key , String client Cert ) { try { SSL Context ctx = SSL Context . get Instance ( STR_ ) ; ctx . init ( Certificate Util . get Key Managers ( STR_ , client Key , client Cert ) , Certificate Util . get Trust Managers ( STR_ , trusted Cert ) , null ) ; return ctx ; } catch ( No Such Algorithm Exception | Key Management Exception e ) { throw new Runtime Exception ( STR_ , e ) ; } }
public boolean unregister Client ( Unregister Profile profile , Server Config utils , Context context , API Result Call Back api Result Callback ) throws Android Agent Exception { String Builder end Point = new String Builder ( ) ; end Point . append ( utils . get API Server URL ( context ) ) ; end Point . append ( Constants . DYNAMIC CLIENT REGISTER ENDPOINT ) ; end Point . append ( STR_ + USER ID + STR_ + profile . get User Id ( ) ) ; end Point . append ( STR_ + CONSUMER KEY + STR_ + profile . get Consumer Key ( ) ) ; end Point . append ( STR_ + APPLICATION NAME + STR_ + profile . get Application Name ( ) ) ; End Point Info end Point Info = new End Point Info ( ) ; end Point Info . set Http Method ( org . wso 2 . emm . agent . proxy . utils . Constants . HTTP METHODS . DELETE ) ; end Point Info . set End Point ( end Point . to String ( ) ) ; send Request ( end Point Info , api Result Callback , Constants . DYNAMIC CLIENT UNREGISTER REQUEST CODE ) ; return true ; }
public void create All Proxies ( Distributed Member member , Region < String , Object > monitoring Region ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ , member . get Id ( ) ) ; } if ( remote Filter Chain . is Server Group Filtered ( STR_ ) ) { if ( logger . is Trace Enabled ( ) ) { logger . trace ( STR_ ) ; } return ; } if ( remote Filter Chain . is Managed Node Filtered ( member ) ) { if ( logger . is Trace Enabled ( ) ) { logger . trace ( STR_ ) ; } return ; } Set < String > mbean Names = monitoring Region . key Set ( ) ; Iterator < String > it = mbean Names . iterator ( ) ; while ( it . has Next ( ) ) { Object Name object Name = null ; if ( remote Filter Chain . is Remote M Bean Filtered ( object Name ) ) { if ( logger . is Trace Enabled ( ) ) { logger . trace ( STR_ ) ; } continue ; } try { object Name = Object Name . get Instance ( it . next ( ) ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ + object Name . to String ( ) ) ; } create Proxy ( member , object Name , monitoring Region , monitoring Region . get ( object Name . to String ( ) ) ) ; } catch ( Management Exception e ) { logger . warn ( STR_ , object Name , e . get Message ( ) , e ) ; continue ; } catch ( Exception e ) { logger . warn ( STR_ , object Name , e . get Message ( ) , e ) ; continue ; } } }
protected void query Segment Metadata ( final Physical Table table ) { String resource Path = String . format ( SEGMENT METADATA QUERY FORMAT , table . get Name ( ) ) ; Success Callback success = build Segment Metadata Success Callback ( table ) ; druid Web Service . get Json Object ( success , error Callback , failure Callback , resource Path ) ; }
public void put ( Unique String key , Object val ) { int loc = key . get Defn Loc ( ) ; if ( loc == - NUM_ ) { loc = defn Idx ++ ; key . set Loc ( loc ) ; } if ( loc >= this . table . length ) { int old Size = this . table . length ; int new Size = Math . max ( NUM_ * old Size , loc + NUM_ ) ; Object [ ] old = this . table ; this . table = new Object [ new Size ] ; System . arraycopy ( old , NUM_ , this . table , NUM_ , old . length ) ; } this . table [ loc ] = val ; }
public String event Topic ( String event Id ) { if ( event Id == null ) { event Id = STR_ ; } return evt Topic . replace ( STR_ , event Id ) ; }
private float calculate Translation Height After Field Rot ( Rectangle b Box , double page Rotation , double rel Field Rotation ) { if ( rel Field Rotation == NUM_ ) { return NUM_ ; } if ( page Rotation == NUM_ ) { if ( rel Field Rotation == Math . PI / NUM_ ) { return b Box . get Height ( ) ; } if ( rel Field Rotation == Math . PI ) { return b Box . get Height ( ) ; } } if ( page Rotation == - Math . PI / NUM_ ) { if ( rel Field Rotation == - Math . PI / NUM_ ) { return b Box . get Width ( ) - b Box . get Height ( ) ; } if ( rel Field Rotation == Math . PI / NUM_ ) { return b Box . get Height ( ) ; } if ( rel Field Rotation == Math . PI ) { return b Box . get Width ( ) ; } } if ( page Rotation == - Math . PI ) { if ( rel Field Rotation == - NUM_ * Math . PI ) { return b Box . get Height ( ) ; } if ( rel Field Rotation == - NUM_ * Math . PI / NUM_ ) { return b Box . get Height ( ) - b Box . get Width ( ) ; } if ( rel Field Rotation == Math . PI / NUM_ ) { return b Box . get Width ( ) ; } } if ( page Rotation == - NUM_ * Math . PI / NUM_ ) { if ( rel Field Rotation == - NUM_ * Math . PI / NUM_ ) { return b Box . get Width ( ) ; } if ( rel Field Rotation == - Math . PI ) { return b Box . get Width ( ) ; } } return NUM_ ; }
@ Override public void add Active ( final Active actor ) { if ( m is Shut Down ) { close Actor ( actor ) ; return ; } synchronized ( this ) { if ( m is Shut Down ) { close Actor ( actor ) ; return ; } m active To Deactivate . add ( actor ) ; } }
public void toggle Timestamp For Message ( @ Nullable Example Message message ) { final int current Timestamp Shown Index = m Messages . index Of ( m Show Timestamp For ) ; final int new Timestamp Shown Index = m Messages . index Of ( message ) ; if ( m Show Timestamp For == message ) { m Show Timestamp For = null ; } else { m Show Timestamp For = message ; notify Item Changed ( current Timestamp Shown Index ) ; } notify Item Changed ( new Timestamp Shown Index ) ; }
public static void main ( String [ ] args ) { Javap Task t = new Javap Task ( ) ; int rc = t . run ( args ) ; System . exit ( rc ) ; }
public static String create Thumbnail Url ( String video Id , String quality ) { if ( quality == null ) { quality = THUMBNAIL QUALITY DEFAULT ; } if ( ! quality . equals Ignore Case ( THUMBNAIL QUALITY DEFAULT ) && ! quality . equals Ignore Case ( THUMBNAIL QUALITY MQ ) && ! quality . equals Ignore Case ( THUMBNAIL QUALITY HQ ) && ! quality . equals Ignore Case ( THUMBNAIL QUALITY SD ) ) { throw new Illegal Argument Exception ( STR_ ) ; } return STR_ + video Id + STR_ + quality + STR_ ; }
private static boolean val Equals ( Object o 1 , Object o 2 ) { return ( o 1 == null ? o 2 == null : o 1 . equals ( o 2 ) ) ; }
public void expectation Only ( ) { expectation ( estimated Im ) ; }
private static void write Effective Pom ( Maven Project project , XML Writer writer ) throws Mojo Execution Exception { Model pom = project . get Model ( ) ; clean Model ( pom ) ; String effective Pom ; String Writer s Writer = new String Writer ( ) ; Maven Xpp 3 Writer pom Writer = new Maven Xpp 3 Writer ( ) ; try { pom Writer . write ( s Writer , pom ) ; } catch ( IO Exception e ) { throw new Mojo Execution Exception ( STR_ , e ) ; } effective Pom = add Maven Namespace ( s Writer . to String ( ) , true ) ; write Comment ( writer , STR_ + project . get Id ( ) + STR_ ) ; writer . write Markup ( effective Pom ) ; }
protected void build Substitutable Properties ( ) { for ( String prop Name : core Properties . string Property Names ( ) ) { String prop Value = core Properties . get Property ( prop Name ) ; if ( ! is User Defined Property ( prop Name ) ) prop Name = SOLR CORE PROP PREFIX + prop Name ; substitutable Properties . set Property ( prop Name , prop Value ) ; } }
private double [ ] line Intersect ( double x 1 , double y 1 , double x 2 , double y 2 , double x , double y , double offset ) { double xval ; double yval ; double xn = - NUM_ , yn = - NUM_ ; double change ; if ( x == NUM_ ) { if ( ( x 1 <= offset && offset < x 2 ) || ( x 1 >= offset && offset > x 2 ) ) { xval = x 1 - x 2 ; change = ( offset - x 2 ) / xval ; yn = ( y 1 - y 2 ) * change + y 2 ; if ( NUM_ <= yn && yn <= y ) { xn = offset ; } else { xn = - NUM_ ; } } } else if ( y == NUM_ ) { if ( ( y 1 <= offset && offset < y 2 ) || ( y 1 >= offset && offset > y 2 ) ) { yval = ( y 1 - y 2 ) ; change = ( offset - y 2 ) / yval ; xn = ( x 1 - x 2 ) * change + x 2 ; if ( NUM_ <= xn && xn <= x ) { yn = offset ; } else { xn = - NUM_ ; } } } double [ ] ret = new double [ NUM_ ] ; ret [ NUM_ ] = xn ; ret [ NUM_ ] = yn ; return ret ; }
public boolean is Wrapper For ( Class iface ) throws SQL Exception { return true ; }
static public M Print Format create From Table ( Properties ctx , int AD Table ID , int AD Print Format ID ) { int AD Client ID = Env . get AD Client ID ( ctx ) ; s log . info ( STR_ + AD Table ID + STR_ + AD Client ID ) ; M Print Format pf = new M Print Format ( ctx , AD Print Format ID , null ) ; pf . set AD Table ID ( AD Table ID ) ; String sql = STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; boolean error = true ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM_ , AD Table ID ) ; pstmt . set Int ( NUM_ , AD Client ID ) ; rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { String Table Name = rs . get String ( NUM_ ) ; String Column Name = Table Name + STR_ ; String s = Column Name ; if ( ! Column Name . equals ( STR_ ) ) { s = Msg . translate ( ctx , Column Name ) ; if ( Column Name . equals ( s ) ) s = Msg . translate ( ctx , Table Name ) ; } int count = rs . get Int ( NUM_ ) ; if ( count > NUM_ ) s += STR_ + ( count + NUM_ ) ; pf . set Name ( s ) ; pf . set AD Print Color ID ( rs . get Int ( NUM_ ) ) ; pf . set AD Print Font ID ( rs . get Int ( NUM_ ) ) ; pf . set AD Print Paper ID ( rs . get Int ( NUM_ ) ) ; error = false ; } else s log . log ( Level . SEVERE , STR_ + AD Table ID ) ; } catch ( SQL Exception e ) { s log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( error ) return null ; if ( ! pf . save ( ) ) return null ; pf . set Items ( create Items ( ctx , pf ) ) ; return pf ; }
public static void log Result ( String log Entry ) { try { va Results Log . write ( log Entry + STR_ ) ; } catch ( IO Exception ioe ) { logger . warn ( STR_ , ioe ) ; } }
public void update Count ( int highlights Count New , int highlights Count , int ignored Count New , int ignored Count ) { highlights . set Text ( build Count ( HIGHLIGHTS LABEL , highlights Count New , highlights Count ) ) ; ignored . set Text ( build Count ( IGNORED LABEL , ignored Count New , ignored Count ) ) ; }
public static Required Graph Model serializable Instance ( ) { return new Required Graph Model ( new Parameters ( ) , Graph Wrapper . serializable Instance ( ) ) ; }
public static String generate Native Guid ( Db Client db Client , Storage HA Domain adapter ) { Storage System device = db Client . query Object ( Storage System . class , adapter . get Storage Device URI ( ) ) ; return String . format ( STR_ + ADAPTER + STR_ , device Type Map . get ( device . get System Type ( ) ) , device . get Serial Number ( ) , adapter . get Adapter Name ( ) ) ; }
@ Override public List < Period > generate Periods ( Date Time Unit date Time Unit ) { date Time Unit . set Month ( NUM_ ) ; date Time Unit . set Day ( NUM_ ) ; List < Period > periods = Lists . new Array List ( ) ; int year = date Time Unit . get Year ( ) ; Calendar calendar = get Calendar ( ) ; while ( year == date Time Unit . get Year ( ) ) { periods . add ( create Period ( date Time Unit , null ) ) ; date Time Unit = calendar . plus Days ( date Time Unit , NUM_ ) ; } return periods ; }
public void start ( ) { Java Core . add Element Changed Listener ( classpath Changed Listener ) ; }
public Character read ( String value ) throws Exception { if ( value . length ( ) != NUM_ ) { throw new Invalid Format Exception ( STR_ , value ) ; } return value . char At ( NUM_ ) ; }
private void copy Action ( File src File , File dest File ) throws File Not Found Exception , IO Exception { File Input Stream istream = new File Input Stream ( src File ) ; File Output Stream ostream = new File Output Stream ( dest File ) ; File Channel input = istream . get Channel ( ) ; File Channel output = ostream . get Channel ( ) ; try { input . transfer To ( NUM_ , input . size ( ) , output ) ; } finally { istream . close ( ) ; ostream . close ( ) ; input . close ( ) ; output . close ( ) ; } }
private final static boolean valid Back Ref ( int index ) { return ( index & NUM_ ) < NUM_ ; }
public static void jenkins ( final Bit Vector bv , final long prefix Length , final long [ ] aa , final long bb [ ] , final long cc [ ] , final long [ ] h ) { if ( prefix Length == NUM_ ) { final long seed = aa [ NUM_ ] ; h [ NUM_ ] = seed ^ NUM_ ; h [ NUM_ ] = seed ^ NUM_ ; h [ NUM_ ] = seed ^ NUM_ ; return ; } int state Offset = ( int ) ( prefix Length / ( NUM_ * Long . SIZE ) ) ; long from = ( state Offset * NUM_ ) * Long . SIZE ; long a = aa [ state Offset ] ; long b = bb [ state Offset ] ; long c = cc [ state Offset ] ; if ( prefix Length - from > Long . SIZE * NUM_ ) { a += bv . get Long ( from , from + Long . SIZE ) ; b += bv . get Long ( from + Long . SIZE , from + NUM_ * Long . SIZE ) ; c += bv . get Long ( from + NUM_ * Long . SIZE , Math . min ( from + NUM_ * Long . SIZE , prefix Length ) ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; from += NUM_ * Long . SIZE ; } c += prefix Length ; long residual = prefix Length - from ; if ( residual > NUM_ ) { if ( residual > Long . SIZE ) { a += bv . get Long ( from , from + Long . SIZE ) ; residual -= Long . SIZE ; } if ( residual != NUM_ ) b += bv . get Long ( prefix Length - residual , prefix Length ) ; } a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; a -= b ; a -= c ; a ^= ( c > > > NUM_ ) ; b -= c ; b -= a ; b ^= ( a << NUM_ ) ; c -= a ; c -= b ; c ^= ( b > > > NUM_ ) ; h [ NUM_ ] = a ; h [ NUM_ ] = b ; h [ NUM_ ] = c ; }
protected T on Create Item ( String name , Attribute Set attrs ) throws Class Not Found Exception { return create Item ( name , m Default Package , attrs ) ; }
public static SSL Server Socket Factory make SSL Socket Factory ( Key Store loaded Key Store , Key Manager [ ] key Managers ) throws IO Exception { SSL Server Socket Factory res = null ; try { Trust Manager Factory trust Manager Factory = Trust Manager Factory . get Instance ( Trust Manager Factory . get Default Algorithm ( ) ) ; trust Manager Factory . init ( loaded Key Store ) ; SSL Context ctx = SSL Context . get Instance ( STR_ ) ; ctx . init ( key Managers , trust Manager Factory . get Trust Managers ( ) , null ) ; res = ctx . get Server Socket Factory ( ) ; } catch ( Exception e ) { throw new IO Exception ( e . get Message ( ) ) ; } return res ; }
@ Nonnull public Bug Instance add Class And Method ( Method Annotation method Annotation ) { add Class ( method Annotation . get Class Name ( ) ) ; add Method ( method Annotation ) ; return this ; }
void add Extra Line ( final Template Line line ) { extra Lines . add ( line ) ; }
public void find Min And Max Vals ( ) { double [ ] data ; double min = Double . MAX VALUE ; double max = - Double . MAX VALUE ; double z ; for ( int stack = NUM_ ; stack < number Stacks ; stack ++ ) { for ( int row = NUM_ ; row < number Rows ; row ++ ) { data = get Row Values ( row , stack ) ; for ( int col = NUM_ ; col < number Columns ; col ++ ) { z = data [ col ] ; if ( z != no Data Value ) { if ( z < min ) { min = z ; } if ( z > max ) { max = z ; } } } } } maximum Value = max ; minimum Value = min ; }
Resource Index Entry find Closest Match ( Service Type resource Type , String resource Name ) { Resource Index Entry resource Index Entry = null ; Resource Match rm = resource Type . compare ( resource Name , this . resource Name , false ) ; if ( rm . equals ( Resource Match . EXACT MATCH ) || rm . equals ( Resource Match . SUB RESOURCE MATCH ) ) { resource Index Entry = this ; } else if ( rm . equals ( Resource Match . SUPER RESOURCE MATCH ) ) { Iterator iter = child Entries . iterator ( ) ; boolean processed = false ; while ( ( ! processed ) && ( iter . has Next ( ) ) ) { Resource Index Entry rie = ( Resource Index Entry ) iter . next ( ) ; resource Index Entry = rie . find Closest Match ( resource Type , resource Name ) ; if ( resource Index Entry != null ) { processed = true ; } } if ( resource Index Entry == null ) { resource Index Entry = this ; } } return resource Index Entry ; }
@ Override public void write ( int b ) throws IO Exception { for ( Output Stream stream : outs ) stream . write ( b ) ; }
public Month Date Format ( Time Zone zone ) { this ( zone , Locale . get Default ( ) , NUM_ , true , false ) ; }
private String print X Format ( long x ) { String sx = null ; if ( x == Long . MIN VALUE ) sx = STR_ ; else if ( x < NUM_ ) { String t = Long . to String ( ( ~ ( - x - NUM_ ) ) ^ Long . MIN VALUE , NUM_ ) ; switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : switch ( t . char At ( NUM_ ) ) { case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; case STR_ : sx = STR_ + t . substring ( NUM_ , NUM_ ) ; break ; } break ; } } else sx = Long . to String ( x , NUM_ ) ; return print X Format ( sx ) ; }
private String print O Format ( final short x ) { String sx = null ; if ( x == Short . MIN VALUE ) { sx = STR_ ; } else if ( x < NUM_ ) { final String t = Integer . to String ( ( ~ ( - x - NUM_ ) ) ^ Short . MIN VALUE , NUM_ ) ; switch ( t . length ( ) ) { case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; case NUM_ : sx = STR_ + t ; break ; } } else { sx = Integer . to String ( x , NUM_ ) ; } return print O Format ( sx ) ; }
public void add Data Row ( Data Row data Row ) { data Row . trim ( ) ; data List . add ( data Row ) ; data Row . ensure Number Of Columns ( columns ) ; }
private void add New Model For Associated Model ( Collection < Data Support > associated Model Collection , Data Support base Obj ) { if ( ! associated Model Collection . contains ( base Obj ) ) { associated Model Collection . add ( base Obj ) ; } }
private void await Termination ( ) { try { executor . await Termination ( NUM_ , Time Unit . MILLISECONDS ) ; } catch ( final Exception e ) { throw new Runtime Exception ( e ) ; } }
private Date Time Zone load Zone Data ( String id ) { Input Stream in = null ; try { in = open Resource ( id ) ; Date Time Zone tz = Date Time Zone Builder . read From ( in , id ) ; i Zone Info Map . put ( id , new Soft Reference < Date Time Zone > ( tz ) ) ; return tz ; } catch ( IO Exception ex ) { uncaught Exception ( ex ) ; i Zone Info Map . remove ( id ) ; return null ; } finally { try { if ( in != null ) { in . close ( ) ; } } catch ( IO Exception ex ) { } } }
private void update Bounds For Removed Item ( Time Series Data Item item ) { Number y N = item . get Value ( ) ; if ( y N != null ) { double y = y N . double Value ( ) ; if ( ! Double . is Na N ( y ) ) { if ( y <= this . min Y || y >= this . max Y ) { update Min Max Y By Iteration ( ) ; } } } }
protected void draw Rect ( int x , int y , int w , int h , Color fill Color , Paint fill Paint , Color pen Color , boolean shadow , boolean rounded ) { int radius = ( rounded ) ? get Arc Size ( w , h ) : NUM_ ; if ( fill Color != null || fill Paint != null ) { if ( shadow ) { g . set Color ( mx Constants . SHADOW COLOR ) ; if ( rounded ) { g . fill Round Rect ( x + mx Constants . SHADOW OFFSETX , y + mx Constants . SHADOW OFFSETY , w , h , radius , radius ) ; } else { g . fill Rect ( x + mx Constants . SHADOW OFFSETX , y + mx Constants . SHADOW OFFSETY , w , h ) ; } } if ( fill Paint != null ) { g . set Paint ( fill Paint ) ; } else { g . set Color ( fill Color ) ; } if ( rounded ) { g . fill Round Rect ( x , y , w , h , radius , radius ) ; } else { if ( g . get Clip Bounds ( ) != null ) { Rectangle rect = new Rectangle ( x , y , w , h ) ; g . fill ( rect . intersection ( g . get Clip Bounds ( ) ) ) ; } else { g . fill Rect ( x , y , w , h ) ; } } } if ( pen Color != null ) { g . set Color ( pen Color ) ; if ( rounded ) { g . draw Round Rect ( x , y , w , h , radius , radius ) ; } else { g . draw Rect ( x , y , w , h ) ; } } }
public static Map < String , Object > update Binary File ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = null ; try { result = update Binary File Method ( dctx , context ) ; } catch ( Generic Service Exception e ) { return Service Util . return Error ( e . get Message ( ) ) ; } return result ; }
public String node Label ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; sb . append ( Formatter . convert ( alpha ) ) ; sb . append ( STR_ ) ; sb . append ( Formatter . convert ( beta ) ) ; if ( set ) { sb . append ( STR_ ) ; sb . append ( Formatter . convert ( value ) ) ; } sb . append ( STR_ ) ; return sb . to String ( ) ; }
public Parameter Type File ( String key , String description , boolean optional , String [ ] extensions ) { super ( key , description , null ) ; set Optional ( optional ) ; this . extensions = extensions ; }
public void encode Parity ( byte [ ] [ ] shards , int offset , int byte Count ) { check Buffers And Sizes ( shards , offset , byte Count ) ; byte [ ] [ ] outputs = new byte [ parity Shard Count ] [ ] ; System . arraycopy ( shards , data Shard Count , outputs , NUM_ , parity Shard Count ) ; coding Loop . code Some Shards ( parity Rows , shards , data Shard Count , outputs , parity Shard Count , offset , byte Count ) ; }
@ Override public boolean equals ( Object o ) { return this == o || ( o instanceof Storage && uuid . equals ( ( ( Storage ) o ) . uuid ) ) ; }
private boolean check Row ( Cursor c , int col Query , int col Disp 1 , int col Disp 2 , String match Display 1 , String match Display 2 ) { String query = c . get String ( col Query ) ; String display 1 = c . get String ( col Disp 1 ) ; String display 2 = ( col Disp 2 >= NUM_ ) ? c . get String ( col Disp 2 ) : null ; assert Equals ( query , display 1 ) ; boolean result = true ; if ( match Display 1 != null ) { result = result && ( display 1 != null ) && display 1 . starts With ( match Display 1 ) ; } if ( match Display 2 != null ) { result = result && ( display 2 != null ) && display 2 . starts With ( match Display 2 ) ; } return result ; }
protected void append Long Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
public static void show ( J Internal Frame internal Frame , J Desktop Pane desktop Pane ) throws Property Veto Exception { if ( ! desktop Pane . is Ancestor Of ( internal Frame ) ) desktop Pane . add ( internal Frame ) ; internal Frame . set Closed ( false ) ; internal Frame . set Visible ( true ) ; internal Frame . to Front ( ) ; }
public static boolean is Object Class Present ( Set object Classes , String object Class ) { if ( object Classes != null && ! object Classes . is Empty ( ) ) { Iterator itr = object Classes . iterator ( ) ; while ( itr . has Next ( ) ) { String service OC = ( String ) itr . next ( ) ; if ( service OC . equals Ignore Case ( object Class ) ) { return true ; } } } return false ; }
public void end Extract Interval ( ) { end Millis = System . current Time Millis ( ) ; total Extract Millis += ( end Millis - interval Start Millis ) ; state = Task State . other ; }
public static Buffered Output Stream new Output Stream ( Path self ) throws IO Exception { return new Buffered Output Stream ( Files . new Output Stream ( self ) ) ; }
public void wait For Ready ( ) { if ( ! is Loaded ) { synchronized ( LOAD LOCK ) { if ( ! is Loaded ) { try { long start = Runtime . get Actor Time ( ) ; LOAD LOCK . wait ( ) ; Log . d ( TAG , STR_ + ( Runtime . get Actor Time ( ) - start ) + STR_ ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } } } } }
public int hash Code ( ) { if ( hash Code == - NUM_ ) { hash Code = ASCII Case Insensitive Comparator . lower Case Hash Code ( name ) ; } return hash Code ; }
private void fetch Features ( Gapis Features features ) throws Execution Exception , Rpc Exception , Timeout Exception { String [ ] list = Rpc . get ( my Client . get Features ( ) , FETCH FEATURES TIMEOUT MS , Time Unit . MILLISECONDS ) ; features . set Feature List ( list ) ; LOG . info ( STR_ + Arrays . to String ( list ) ) ; }
protected String strip Quotes ( String rvalue ) { String Buffer buf = new String Buffer ( ) ; int rvlen = rvalue . length ( ) ; for ( int i = NUM_ ; i < rvlen ; i ++ ) { char ch = rvalue . char At ( i ) ; if ( ch != STR_ && ch != STR_ ) { buf . append ( ch ) ; } } return buf . to String ( ) ; }
@ Override public float generator Sort Value ( String url , Web Page row , float init Sort ) throws Scoring Filter Exception { for ( Scoring Filter filter : filters ) { init Sort = filter . generator Sort Value ( url , row , init Sort ) ; } return init Sort ; }
public void add Chat Session Listener ( Chat Session Listener listener ) { if ( ( listener != null ) && ! m Listeners . contains ( listener ) ) { m Listeners . add ( listener ) ; } }
protected List < String > edits ( String word ) { List < String > candidates = new Array List < String > ( ) ; for ( int i = NUM_ ; i < word . length ( ) ; i ++ ) { candidates . add ( word . substring ( NUM_ , i ) + word . substring ( i + NUM_ ) ) ; for ( char c = STR_ ; c <= STR_ ; c ++ ) { candidates . add ( word . substring ( NUM_ , i ) + c + word . substring ( i + NUM_ ) ) ; candidates . add ( word . substring ( NUM_ , i ) + c + word . substring ( i ) ) ; } } for ( char c = STR_ ; c <= STR_ ; c ++ ) { candidates . add ( word + c ) ; } for ( int i = NUM_ ; i < word . length ( ) - NUM_ ; i ++ ) { candidates . add ( word . substring ( NUM_ , i ) + word . substring ( i + NUM_ , i + NUM_ ) + word . substring ( i , i + NUM_ ) + word . substring ( i + NUM_ ) ) ; } return candidates ; }
public boolean log Modified ( Logger log ) { if ( is Modified ( ) ) { log . info ( class Name + STR_ ) ; return true ; } else return false ; }
public void check Jvm Mem Pool Threshold ( Long x ) throws Snmp Status Exception { if ( ! pool . is Usage Threshold Supported ( ) ) throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Inconsistent Value ) ; final long val = x . long Value ( ) ; if ( val < NUM_ ) throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Wrong Value ) ; }
@ Deprecated public static Font Program create Type 1 Font ( String name , byte [ ] afm , byte [ ] pfb , boolean cached ) throws java . io . IO Exception { Font Program font Program ; String font Key = null ; if ( cached ) { if ( name != null ) { font Key = name ; } else { font Key = Integer . to String ( Array Util . hash Code ( afm ) ) ; } font Program = Font Cache . get Font ( font Key ) ; if ( font Program != null ) { return font Program ; } } font Program = new Type 1 Font ( name , null , afm , pfb ) ; return cached ? Font Cache . save Font ( font Program , font Key ) : font Program ; }
public void find And Init ( Iterator it ) { while ( it . has Next ( ) ) { find And Init ( ( Object ) it . next ( ) ) ; } }
public boolean equals ( Object obj ) { if ( obj == null || ( ! ( obj instanceof Code Signer ) ) ) { return false ; } Code Signer that = ( Code Signer ) obj ; if ( this == that ) { return true ; } Timestamp that Timestamp = that . get Timestamp ( ) ; if ( timestamp == null ) { if ( that Timestamp != null ) { return false ; } } else { if ( that Timestamp == null || ( ! timestamp . equals ( that Timestamp ) ) ) { return false ; } } return signer Cert Path . equals ( that . get Signer Cert Path ( ) ) ; }
@ Override public void reset Options ( ) { super . reset Options ( ) ; set Retrieval ( NONE ) ; try { if ( m Data Base Connection != null && m Data Base Connection . is Connected ( ) ) { m Data Base Connection . disconnect From Database ( ) ; } m Data Base Connection = new Database Connection ( ) ; } catch ( Exception ex ) { print Exception ( ex ) ; } m URL = m Data Base Connection . get Database URL ( ) ; m table Name = STR_ ; m Username = m Data Base Connection . get Username ( ) ; m Password = m Data Base Connection . get Password ( ) ; m count = NUM_ ; m id = false ; m tab Name = true ; }
public final void remove Helper Text Color ( @ Color Int final int color ) { int index = helper Text Colors . index Of ( color ) ; if ( index != - NUM_ ) { helper Text Colors . remove ( index ) ; verify Password Strength ( ) ; } }
public void write Expression ( Expression old Exp ) { boolean internal = this . internal ; this . internal = true ; Object old Value = get Value ( old Exp ) ; if ( get ( old Value ) == null || ( old Value instanceof String && ! internal ) ) { get Value Data ( old Value ) . exp = old Exp ; super . write Expression ( old Exp ) ; } this . internal = internal ; }
@ Parameterized . Parameters public static Collection < Object [ ] > methods ( ) { return Arrays . as List ( new Object [ ] [ ] { { Rq Method . POST , STR_ } , { Rq Method . GET , STR_ } , { Rq Method . PUT , STR_ } , { Rq Method . DELETE , STR_ } , { Rq Method . TRACE , STR_ } } ) ; }
public void prefer Proportional Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Proportional Fonts ( ) ; }
private void write Flow Pair ( Flow Pair pair , Document document , Element parent Element ) { Element flow Pair = document . create Element ( STR_ ) ; parent Element . append Child ( flow Pair ) ; write Domain Spec ( pair . get First Domain ( ) , document , flow Pair ) ; write Domain Spec ( pair . get Second Domain ( ) , document , flow Pair ) ; }
private static boolean is Optimizable For Descendant Iterator ( Compiler compiler , int step Op Code Pos , int step Index ) throws javax . xml . transform . Transformer Exception { int step Type ; int step Count = NUM_ ; boolean found Dor DS = false ; boolean found Self = false ; boolean found DS = false ; int node Test Type = Op Codes . NODETYPE NODE ; while ( Op Codes . ENDOP != ( step Type = compiler . get Op ( step Op Code Pos ) ) ) { if ( node Test Type != Op Codes . NODETYPE NODE && node Test Type != Op Codes . NODETYPE ROOT ) return false ; step Count ++ ; if ( step Count > NUM_ ) return false ; boolean might Be Proximate = might Be Proximate ( compiler , step Op Code Pos , step Type ) ; if ( might Be Proximate ) return false ; switch ( step Type ) { case Op Codes . FROM FOLLOWING : case Op Codes . FROM FOLLOWING SIBLINGS : case Op Codes . FROM PRECEDING : case Op Codes . FROM PRECEDING SIBLINGS : case Op Codes . FROM PARENT : case Op Codes . OP VARIABLE : case Op Codes . OP EXTFUNCTION : case Op Codes . OP FUNCTION : case Op Codes . OP GROUP : case Op Codes . FROM NAMESPACE : case Op Codes . FROM ANCESTORS : case Op Codes . FROM ANCESTORS OR SELF : case Op Codes . FROM ATTRIBUTES : case Op Codes . MATCH ATTRIBUTE : case Op Codes . MATCH ANY ANCESTOR : case Op Codes . MATCH IMMEDIATE ANCESTOR : return false ; case Op Codes . FROM ROOT : if ( NUM_ != step Count ) return false ; break ; case Op Codes . FROM CHILDREN : if ( ! found DS && ! ( found Dor DS && found Self ) ) return false ; break ; case Op Codes . FROM DESCENDANTS OR SELF : found DS = true ; case Op Codes . FROM DESCENDANTS : if ( NUM_ == step Count ) return false ; found Dor DS = true ; break ; case Op Codes . FROM SELF : if ( NUM_ != step Count ) return false ; found Self = true ; break ; default : throw new Runtime Exception ( XSL Messages . create XPATH Message ( XPATH Error Resources . ER NULL ERROR HANDLER , new Object [ ] { Integer . to String ( step Type ) } ) ) ; } node Test Type = compiler . get Step Test Type ( step Op Code Pos ) ; int next Step Op Code Pos = compiler . get Next Step Pos ( step Op Code Pos ) ; if ( next Step Op Code Pos < NUM_ ) break ; if ( Op Codes . ENDOP != compiler . get Op ( next Step Op Code Pos ) ) { if ( compiler . count Predicates ( step Op Code Pos ) > NUM_ ) { return false ; } } step Op Code Pos = next Step Op Code Pos ; } return true ; }
private void define Schemes ( ) { schemes = new Array List < > ( ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . GREEN , Color . BLACK ) ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . ORANGE , Color . BLACK ) ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . WHITE , Color . BLACK ) ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . BLACK , Color . WHITE ) ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . WHITE , Color . BLUE ) ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . BLACK , Color . LIGHT GRAY ) ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . BLACK , Color . GRAY ) ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . WHITE , Color . GRAY ) ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . WHITE , Color . DARK GRAY ) ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . GREEN , Color . DARK GRAY ) ) ; schemes . add ( new Scheme ( rbc . get String ( STR_ ) , Color . ORANGE , Color . DARK GRAY ) ) ; }
public Data Source create Custom Volume Name Data Source ( Project project , Tenant Org tenant , String volume Label , String volume WWN , String export Name , String config Name ) { List < Data Object > data Objects List = new Array List < > ( ) ; data Objects List . add ( project ) ; data Objects List . add ( tenant ) ; Volume volume = new Volume ( ) ; volume . set Label ( volume Label ) ; volume . set WWN ( volume WWN ) ; data Objects List . add ( volume ) ; Map < String , String > computed Value Map = new Hash Map < String , String > ( ) ; if ( export Name != null ) { computed Value Map . put ( Custom Config Constants . CUSTOM VOLUME EXPORT NAME , export Name ) ; } Data Object [ ] data Objects = new Data Object [ data Objects List . size ( ) ] ; return create Data Source ( config Name , data Objects List . to Array ( data Objects ) , computed Value Map ) ; }
public Builder source Section Equals ( Source Section ... section ) { verify Not Null ( section ) ; expressions . add ( new Event Filter Expression . Source Section Equals ( section ) ) ; return this ; }
public synchronized void clear ( ) { Entry tab [ ] = table ; mod Count ++ ; for ( int index = tab . length ; -- index >= NUM_ ; ) tab [ index ] = null ; lru Tracker . clear ( ) ; count = NUM_ ; }
public static Long write Op CRC 32 ( String stream , byte [ ] payload ) { CRC 32 crc = request CRC . get ( ) ; try { crc . update ( stream . get Bytes ( UTF 8 ) ) ; crc . update ( payload ) ; return crc . get Value ( ) ; } finally { crc . reset ( ) ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof XY Bubble Renderer ) ) { return false ; } XY Bubble Renderer that = ( XY Bubble Renderer ) obj ; if ( this . scale Type != that . scale Type ) { return false ; } return super . equals ( obj ) ; }
private static Point find Location ( final Stendhal RP Zone zone , final Entity entity , final Shape allowed Area , final int x , final int y , final boolean check Path ) { for ( int total Shift = NUM_ ; total Shift <= max Displacement ; total Shift ++ ) { for ( int tilt = ( total Shift + NUM_ ) / NUM_ ; tilt > NUM_ ; tilt -- ) { final int spread = total Shift - tilt ; int tmpx = x - tilt ; int tmpy = y - spread ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } tmpx = x + tilt ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } tmpy = y + spread ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } tmpx = x - tilt ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } if ( spread == tilt ) { continue ; } tmpx = x - spread ; tmpy = y - tilt ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } tmpx = x + spread ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } tmpy = y + tilt ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } tmpx = x - spread ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } } int tmpx = x ; int tmpy = y - total Shift ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } tmpy = y + total Shift ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } tmpy = y ; tmpx = x - total Shift ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } tmpx = x + total Shift ; if ( is Valid Placement ( zone , entity , allowed Area , x , y , tmpx , tmpy , check Path ) ) { return new Point ( tmpx , tmpy ) ; } } return null ; }
private String [ ] split Tfvc Collection Url ( final String collection Url ) { final String [ ] result = new String [ NUM_ ] ; if ( String Utils . is Empty ( collection Url ) ) { return result ; } final String trimmed Url = Url Helper . trim Trailing Separators ( collection Url ) ; final int index = trimmed Url . last Index Of ( Url Helper . URL SEPARATOR ) ; if ( index >= NUM_ ) { result [ NUM_ ] = trimmed Url . substring ( NUM_ , index + NUM_ ) ; result [ NUM_ ] = trimmed Url . substring ( index + NUM_ ) ; } else { result [ NUM_ ] = collection Url ; result [ NUM_ ] = String Utils . EMPTY ; } return result ; }
private Recycler View . Item Decoration parse Transforms ( String raw ) { if ( raw == null ) { return null ; } float scale X = NUM_ , scale Y = NUM_ ; int translate X = NUM_ , translate Y = NUM_ ; float opacity = NUM_ ; int rotate = NUM_ ; Matcher matcher = transform Pattern . matcher ( raw ) ; while ( matcher . find ( ) ) { String match = matcher . group ( ) ; String name = matcher . group ( NUM_ ) ; try { switch ( name ) { case STR_ : scale X = Float . parse Float ( matcher . group ( NUM_ ) ) ; scale Y = Float . parse Float ( matcher . group ( NUM_ ) ) ; break ; case STR_ : translate X = Integer . parse Int ( matcher . group ( NUM_ ) ) ; translate Y = Integer . parse Int ( matcher . group ( NUM_ ) ) ; break ; case STR_ : opacity = Float . parse Float ( matcher . group ( NUM_ ) ) ; break ; case STR_ : rotate = Integer . parse Int ( matcher . group ( NUM_ ) ) ; break ; default : WX Log Utils . e ( TAG , STR_ + match ) ; break ; } } catch ( Number Format Exception e ) { WX Log Utils . e ( STR_ , e ) ; WX Log Utils . e ( TAG , STR_ + match ) ; } } return new Transform Item Decoration ( get Orientation ( ) == VERTICAL , opacity , translate X , translate Y , rotate , scale X , scale Y ) ; }
public String list Feature Processor Names ( ) { String bytes = list Byte Valued Feature Processor Names ( ) ; String shorts = list Short Valued Feature Processor Names ( ) ; String conts = list Continuous Feature Processor Names ( ) ; String Builder sb = new String Builder ( bytes . length ( ) + shorts . length ( ) + conts . length ( ) + NUM_ ) ; sb . append ( bytes ) ; if ( bytes . length ( ) > NUM_ && shorts . length ( ) > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( shorts ) ; if ( conts . length ( ) > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( conts ) ; return sb . to String ( ) ; }
public void add Action Listener ( Action Listener a ) { m Colour Change Listeners . add ( a ) ; }
public static void put At ( String Buffer self , Empty Range range , Object value ) { Range Info info = sub List Borders ( self . length ( ) , range ) ; self . replace ( info . from , info . to , value . to String ( ) ) ; }
private static int index Of ( Object o , @ Not Null Object [ ] elements , int index , int fence ) { if ( o == null ) { for ( int i = index ; i < fence ; i ++ ) { if ( elements [ i ] == null ) { return i ; } } } else { for ( int i = index ; i < fence ; i ++ ) { if ( o . equals ( elements [ i ] ) ) { return i ; } } } return - NUM_ ; }
public void remove Datatransfer Progress Listener ( On Datatransfer Progress Listener listener , OC Upload oc Upload ) { if ( oc Upload == null || listener == null ) return ; String target Key = build Remote Name ( oc Upload . get Account Name ( ) , oc Upload . get Remote Path ( ) ) ; if ( m Bound Listeners . get ( target Key ) == listener ) { m Bound Listeners . remove ( target Key ) ; } }
private static void analyze Hadoop Configuration ( ) { Job Conf job = Configuration Manager . get Cached Job Conf ( ) ; remote MR Sort Mem = ( NUM_ * NUM_ ) * job . get Long ( MR Configuration Names . MR TASK IO SORT MB , NUM_ ) ; String java Opts 1 = job . get ( MR Configuration Names . MR CHILD JAVA OPTS ) ; String java Opts 2 = job . get ( MR Configuration Names . MR MAP JAVA OPTS , null ) ; String java Opts 3 = job . get ( MR Configuration Names . MR REDUCE JAVA OPTS , null ) ; if ( java Opts 2 != null ) remote JVM Max Mem Map = extract Max Memory Opt ( java Opts 2 ) ; else remote JVM Max Mem Map = extract Max Memory Opt ( java Opts 1 ) ; if ( java Opts 3 != null ) remote JVM Max Mem Reduce = extract Max Memory Opt ( java Opts 3 ) ; else remote JVM Max Mem Reduce = extract Max Memory Opt ( java Opts 1 ) ; String blocksize = job . get ( MR Configuration Names . DFS BLOCKSIZE , STR_ ) ; blocksize = Long . parse Long ( blocksize ) ; String framework = job . get ( MR Configuration Names . MR FRAMEWORK NAME ) ; yarn Enabled = ( framework != null && framework . equals ( STR_ ) ) ; local JT = analyze Local Mode ( job ) ; }
public static void silent Close Output Stream ( Output Stream os ) { try { if ( os != null ) { os . close ( ) ; } } catch ( IO Exception e ) { log . w ( LOG TAG , STR_ , e ) ; } }
private String normalize Type Value ( String type ) { if ( INSERT . equals ( type ) ) return INSERT ; if ( REMOVE . equals ( type ) ) return REMOVE ; return null ; }
public static long decrypt CFB ( final byte [ ] concatenated Hash Value , final String base 64 Encrypted Turn Over Value , final Secret Key symmetric Key ) throws No Such Algorithm Exception , No Such Provider Exception , No Such Padding Exception , Invalid Key Exception , Invalid Algorithm Parameter Exception , Illegal Block Size Exception , Bad Padding Exception { final Byte Buffer byte Buffer IV = Byte Buffer . allocate ( NUM_ ) ; byte Buffer IV . put ( concatenated Hash Value ) ; final byte [ ] IV = byte Buffer IV . array ( ) ; final byte [ ] encrypted Turn Over Value = Cash Box Utils . base 64 Decode ( base 64 Encrypted Turn Over Value , false ) ; final Iv Parameter Spec iv Spec = new Iv Parameter Spec ( IV ) ; final Cipher cipher = Cipher . get Instance ( STR_ , STR_ ) ; cipher . init ( Cipher . DECRYPT MODE , symmetric Key , iv Spec ) ; final byte [ ] test Plain Turn Over Value Complete = cipher . do Final ( encrypted Turn Over Value ) ; return get Long ( test Plain Turn Over Value Complete ) ; }
String compute Description ( I Method method ) { String Buffer buf = new String Buffer ( ) ; buf . append ( STR_ ) ; buf . append ( method . get Element Name ( ) ) ; buf . append ( STR_ ) ; boolean first = true ; for ( String param Type : method . get Parameter Types ( ) ) { if ( first ) first = false ; else buf . append ( STR_ ) ; buf . append ( Signature . to String ( param Type ) ) ; } buf . append ( STR_ ) ; return buf . to String ( ) ; }
void register Local Symbol ( String source File , String full Local Name , String required Namespace , String local Name ) { value Rewrite . put ( source File , full Local Name , local Name ) ; type Rewrite . put ( source File , full Local Name , local Name ) ; type Rewrite . put ( source File , required Namespace , local Name ) ; }
public static String encrypt CTR ( final byte [ ] concatenated Hash Value , Long turnover Counter , final Secret Key symmetric Key , int turn Over Counter Length In Bytes ) throws No Such Algorithm Exception , No Such Provider Exception , No Such Padding Exception , Invalid Key Exception , Invalid Algorithm Parameter Exception , Illegal Block Size Exception , Bad Padding Exception { final Byte Buffer byte Buffer IV = Byte Buffer . allocate ( NUM_ ) ; byte Buffer IV . put ( concatenated Hash Value ) ; final byte [ ] IV = byte Buffer IV . array ( ) ; final Byte Buffer byte Buffer Data = Byte Buffer . allocate ( NUM_ ) ; byte Buffer Data . put Long ( turnover Counter ) ; final byte [ ] data = byte Buffer Data . array ( ) ; byte [ ] turn Over Counter Byte Rep = get 2 Complement Rep For Long ( turnover Counter , turn Over Counter Length In Bytes ) ; System . arraycopy ( turn Over Counter Byte Rep , NUM_ , data , NUM_ , turn Over Counter Byte Rep . length ) ; final Iv Parameter Spec iv Spec = new Iv Parameter Spec ( IV ) ; final Cipher cipher = Cipher . get Instance ( STR_ , STR_ ) ; cipher . init ( Cipher . ENCRYPT MODE , symmetric Key , iv Spec ) ; final byte [ ] encrypted Turn Over Value Complete = cipher . do Final ( data ) ; final byte [ ] encrypted Turn Over Value = new byte [ turn Over Counter Length In Bytes ] ; System . arraycopy ( encrypted Turn Over Value Complete , NUM_ , encrypted Turn Over Value , NUM_ , turn Over Counter Length In Bytes ) ; return Cash Box Utils . base 64 Encode ( encrypted Turn Over Value , false ) ; }
public Push Device Settings create Device Profile ( ) { byte [ ] secret Bytes = new byte [ SECRET BYTE LENGTH ] ; secure Random . next Bytes ( secret Bytes ) ; String shared Secret = Base 64 . encode ( secret Bytes ) ; return new Push Device Settings ( shared Secret , DEVICE NAME ) ; }
public static final void store Default Parameters ( Configuration Parameters params ) { default Parameters . set ( params ) ; }
public static void register M Bean ( Object mbean , Class < ? > mbean Interface , String mbean Name , boolean ignored ) { M Bean Server mbs = Management Factory . get Platform M Bean Server ( ) ; try { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + mbean . get Class ( ) ) ; Object Name name = generate M Bean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; if ( mbs . is Registered ( name ) ) mbs . unregister M Bean ( name ) ; mbs . register M Bean ( mbean , name ) ; } catch ( Exception e ) { throw new Server Runtime Exception ( STR_ + mbean . get Class ( ) + STR_ + mbean Interface + STR_ + mbean Name , e ) ; } }
@ Override protected Integer initial Value ( ) { return Integer . value Of ( NUM_ ) ; }
public final Json Serializer < ? > find Serializer By Lookup ( Java Type type , Serialization Config config , Basic Bean Description bean Desc , Bean Property property , boolean static Typing ) { Class < ? > raw = type . get Raw Class ( ) ; String cls Name = raw . get Name ( ) ; Json Serializer < ? > ser = concrete . get ( cls Name ) ; if ( ser != null ) { return ser ; } Class < ? extends Json Serializer < ? > > ser Class = concrete Lazy . get ( cls Name ) ; if ( ser Class != null ) { try { return ser Class . new Instance ( ) ; } catch ( Exception e ) { throw new Illegal State Exception ( STR_ + ser Class . get Name ( ) + STR_ + e . get Message ( ) , e ) ; } } return null ; }
private void init BPRMA Details ( int C B Partner ID ) { rma Field . remove Action Listener ( this ) ; rma Field . remove All Items ( ) ; Key Name Pair pp = new Key Name Pair ( NUM_ , STR_ ) ; rma Field . add Item ( pp ) ; Array List < Key Name Pair > list = load RMA Data ( C B Partner ID ) ; for ( Key Name Pair knp : list ) rma Field . add Item ( knp ) ; rma Field . set Selected Index ( NUM_ ) ; rma Field . add Action Listener ( this ) ; }
public double calculate Usable Capacity ( double storageparentusablecapacity , double storagereplicausablecapacity , double storagecloneusablecapacity , double storagepersistentusablecapacity , double storagesuspendusablecapacity , double swappowerstatecapacityreduction ) { double d = ( storageparentusablecapacity + storagereplicausablecapacity + storagecloneusablecapacity + storagepersistentusablecapacity + storagesuspendusablecapacity + swappowerstatecapacityreduction ) ; d = ( double ) Math . round ( d * NUM_ ) / NUM_ ; return d ; }
public static Attribute Meta Data generate Attribute Meta Data ( Example Set Meta Data emd , String name , Expression Type expression Type ) { Attribute Meta Data new Attribute = null ; Attribute Meta Data existing Att = emd . get Attribute By Name ( name ) ; int ontology = expression Type . get Attribute Type ( ) ; if ( ontology == Ontology . BINOMINAL ) { new Attribute = new Attribute Meta Data ( name , Ontology . BINOMINAL ) ; Hash Set < String > values = new Hash Set < > ( ) ; values . add ( STR_ ) ; values . add ( STR_ ) ; new Attribute . set Value Set ( values , Set Relation . EQUAL ) ; } else { new Attribute = new Attribute Meta Data ( name , ontology ) ; } if ( existing Att != null ) { new Attribute . set Role ( existing Att . get Role ( ) ) ; } return new Attribute ; }
private void init Labels ( ) { Compare Configuration cc = get Compare Configuration ( ) ; I Typed Element left = this . left ; I Typed Element right = this . right ; I Typed Element ancestor = this . ancestor ; if ( left != null ) { left Label = get Label ( left ) ; cc . set Left Label ( left Label ) ; cc . set Left Image ( left Image ) ; } if ( right != null ) { right Label = get Label ( right ) ; cc . set Right Label ( right Label ) ; cc . set Right Image ( right Image ) ; } if ( ancestor != null ) { cc . set Ancestor Label ( get Label ( ancestor ) ) ; cc . set Ancestor Image ( ancestor Image ) ; } String title ; if ( ancestor != null ) { title = Policy . bind ( STR_ , new Object [ ] { guess Resource Name ( ) , get Version Label ( ancestor ) , get Version Label ( left ) , get Version Label ( right ) } ) ; } else { String left Name = null ; if ( left != null ) left Name = left . get Name ( ) ; String right Name = null ; if ( right != null ) right Name = right . get Name ( ) ; if ( left Name != null && ! left Name . equals ( right Name ) ) { title = Policy . bind ( STR_ , new Object [ ] { left Name , get Version Label ( left ) , right Name , get Version Label ( right ) } ) ; } else { title = Policy . bind ( STR_ , new Object [ ] { guess Resource Name ( ) , get Version Label ( left ) , get Version Label ( right ) } ) ; } } set Title ( title ) ; }
static byte [ ] encrypt Data ( byte [ ] password , int size , byte [ ] data ) { try { Cipher c = Cipher . get Instance ( ENCRYPT DATA ALGORITHM ) ; c . init ( Cipher . ENCRYPT MODE , new Secret Key Spec ( password , SECRET KEY ALGORITHM ) , CBC SALT DATA ) ; c . update ( new byte [ ] { ( byte ) ( size > > NUM_ ) , ( byte ) ( size > > NUM_ ) , ( byte ) ( size > > NUM_ ) , ( byte ) ( size ) } ) ; return c . do Final ( data ) ; } catch ( Exception e ) { throw new Illegal State Exception ( ENCRYPT DATA ALGORITHM + STR_ , e ) ; } }
private boolean validate ID ( String s Id ) { return ! site Id Set . is Empty ( ) && site Id Set . contains ( s Id ) ; }
public Parse Query < T > where Contains ( String key , String substring ) { String regex = Pattern . quote ( substring ) ; where Matches ( key , regex ) ; return this ; }
protected Queue create Queue ( String name ) { return Active MQJMS Client . create Queue ( name ) ; }
private void proc Functions 0 4 ( int curr Cab Id , int c ) { if ( ( c & Nce Cmd Station Memory . FUNC L F 0 ) != NUM_ ) { cab Data [ curr Cab Id ] . F 0 = true ; } else { cab Data [ curr Cab Id ] . F 0 = false ; } if ( ( c & Nce Cmd Station Memory . FUNC L F 1 ) != NUM_ ) { cab Data [ curr Cab Id ] . F 1 = true ; } else { cab Data [ curr Cab Id ] . F 1 = false ; } if ( ( c & Nce Cmd Station Memory . FUNC L F 2 ) != NUM_ ) { cab Data [ curr Cab Id ] . F 2 = true ; } else { cab Data [ curr Cab Id ] . F 2 = false ; } if ( ( c & Nce Cmd Station Memory . FUNC L F 3 ) != NUM_ ) { cab Data [ curr Cab Id ] . F 3 = true ; } else { cab Data [ curr Cab Id ] . F 3 = false ; } if ( ( c & Nce Cmd Station Memory . FUNC L F 4 ) != NUM_ ) { cab Data [ curr Cab Id ] . F 4 = true ; } else { cab Data [ curr Cab Id ] . F 4 = false ; } }
public Total Target Count Status ( final Long total Target Count ) { this ( Collections . empty List ( ) , total Target Count ) ; }
private static void create Observation Points ( ) { zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; zona Id 2 Coord . put ( STR_ , new Coord ( NUM_ , NUM_ ) ) ; }
private void add Driver Attributes ( ) { buffer . append ( STR_ ) ; buffer . append ( STR_ + ds . get Driver Class ( ) + STR_ ) ; }
private static void write Header String ( Buffered Writer output ) throws IO Exception { output . write ( STR_ ) ; output . write ( delimiter ) ; output . write ( STR_ ) ; output . write ( delimiter ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { output . write ( STR_ ) ; output . write ( String . value Of ( i ) ) ; output . write ( delimiter ) ; } for ( int i = NUM_ ; i < NUM_ ; i ++ ) { output . write ( STR_ ) ; output . write ( String . value Of ( i ) ) ; output . write ( delimiter ) ; } output . write ( STR_ ) ; output . new Line ( ) ; }
@ Override public void on Bind View Holder ( K holder , int position ) { holder . bind Item ( items . get ( position ) ) ; }
private void visitx ( Generator Adapter mv , List < String > strings ) { if ( strings . size ( ) == NUM_ ) { visit Case ( strings . get ( NUM_ ) ) ; return ; } for ( int i = NUM_ ; i < strings . size ( ) ; ++ i ) { String string = strings . get ( i ) ; Label label = new Label ( ) ; visit String ( ) ; mv . visit Ldc Insn ( string ) ; mv . invoke Virtual ( STRING TYPE , Method . get Method ( STR_ ) ) ; mv . visit Jump Insn ( Opcodes . IFEQ , label ) ; visit Case ( string ) ; mv . visit Label ( label ) ; } visit Default ( ) ; }
public boolean can Be Negative ( ) { boolean negative = true ; return negative ; }
public static Object default Value ( Class < ? > cls ) { if ( cls == Integer . TYPE ) { return Integer . value Of ( NUM_ ) ; } if ( cls == Long . TYPE ) { return Long . value Of ( NUM_ ) ; } if ( cls == Boolean . TYPE ) { return Boolean . FALSE ; } if ( cls == Double . TYPE ) { return Double . value Of ( NUM_ ) ; } if ( cls == Float . TYPE ) { return Float . value Of ( NUM_ ) ; } if ( cls == Byte . TYPE ) { return Byte . value Of ( ( byte ) NUM_ ) ; } if ( cls == Short . TYPE ) { return Short . value Of ( ( short ) NUM_ ) ; } if ( cls == Character . TYPE ) { return STR_ ; } throw new Illegal Argument Exception ( STR_ + cls . get Name ( ) + STR_ ) ; }
public void generate Code ( Compilation Unit Scope unit Scope ) { generate Code ( ) ; }
protected void append Boolean Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
void update Time ( ) { if ( clock . get Run ( ) || show Time ) { show Time = false ; set Time Label ( ) ; time Label . set Visible ( true ) ; } }
private Start build ( Start event ) { Iterator < Attribute > list = event . get Attributes ( ) ; while ( list . has Next ( ) ) { Attribute node = list . next ( ) ; Entry entry = attribute ( node ) ; if ( ! entry . is Reserved ( ) ) { event . add ( entry ) ; } } return event ; }
public final void init ( final String current key ) { key = current key + System . current Time Millis ( ) ; final File f = new File ( temp dir ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } }
public default < E 2 > void for Each Remaining ( final Class < E 2 > end Type , final Consumer < E 2 > consumer ) { try { while ( true ) { consumer . accept ( ( E 2 ) next ( ) ) ; } } catch ( final No Such Element Exception ignore ) { } }
public boolean can Be Statically Bound ( ) { return Modifier . is Final ( flags | clazz . get Modifiers ( ) ) ; }
protected void decode Base 64 ( String str , Byte Array Builder builder , Base 64 Variant b 64 variant ) throws IO Exception , Json Parse Exception { int ptr = NUM_ ; int len = str . length ( ) ; main loop : while ( ptr < len ) { char ch ; do { ch = str . char At ( ptr ++ ) ; if ( ptr >= len ) { break main loop ; } } while ( ch <= INT SPACE ) ; int bits = b 64 variant . decode Base 64 Char ( ch ) ; if ( bits < NUM_ ) { report Invalid Base 64 ( b 64 variant , ch , NUM_ , null ) ; } int decoded Data = bits ; if ( ptr >= len ) { report Base 64 EOF ( ) ; } ch = str . char At ( ptr ++ ) ; bits = b 64 variant . decode Base 64 Char ( ch ) ; if ( bits < NUM_ ) { report Invalid Base 64 ( b 64 variant , ch , NUM_ , null ) ; } decoded Data = ( decoded Data << NUM_ ) | bits ; if ( ptr >= len ) { if ( ! b 64 variant . uses Padding ( ) ) { decoded Data >>= NUM_ ; builder . append ( decoded Data ) ; break ; } report Base 64 EOF ( ) ; } ch = str . char At ( ptr ++ ) ; bits = b 64 variant . decode Base 64 Char ( ch ) ; if ( bits < NUM_ ) { if ( bits != Base 64 Variant . BASE 64 VALUE PADDING ) { report Invalid Base 64 ( b 64 variant , ch , NUM_ , null ) ; } if ( ptr >= len ) { report Base 64 EOF ( ) ; } ch = str . char At ( ptr ++ ) ; if ( ! b 64 variant . uses Padding Char ( ch ) ) { report Invalid Base 64 ( b 64 variant , ch , NUM_ , STR_ + b 64 variant . get Padding Char ( ) + STR_ ) ; } decoded Data >>= NUM_ ; builder . append ( decoded Data ) ; continue ; } decoded Data = ( decoded Data << NUM_ ) | bits ; if ( ptr >= len ) { if ( ! b 64 variant . uses Padding ( ) ) { decoded Data >>= NUM_ ; builder . append Two Bytes ( decoded Data ) ; break ; } report Base 64 EOF ( ) ; } ch = str . char At ( ptr ++ ) ; bits = b 64 variant . decode Base 64 Char ( ch ) ; if ( bits < NUM_ ) { if ( bits != Base 64 Variant . BASE 64 VALUE PADDING ) { report Invalid Base 64 ( b 64 variant , ch , NUM_ , null ) ; } decoded Data >>= NUM_ ; builder . append Two Bytes ( decoded Data ) ; } else { decoded Data = ( decoded Data << NUM_ ) | bits ; builder . append Three Bytes ( decoded Data ) ; } } }
protected void remove Service Listener ( SMS Entry Update Listener update Listener ) { service Objects . remove ( update Listener ) ; if ( service Objects . is Empty ( ) ) { subscription . cancel ( ) ; } }
private void display Changed ( ) { clock . set 12 Hour Display ( display Check Box . is Selected ( ) , true ) ; changed = true ; }
private static Class < ? > find Class ( Class Loader loader , Class < ? > clazz ) { final String name = clazz . get Name ( ) ; if ( name . starts With ( STR_ ) || name . starts With ( STR_ ) ) return null ; String generated Class Name = generate Retainer Class Name ( name ) ; try { if ( Akatsuki . logging Level == Akatsuki Config . Logging Level . VERBOSE ) Log . i ( Akatsuki . TAG , STR_ + clazz ) ; return Class . for Name ( generated Class Name , true , loader ) ; } catch ( Class Not Found Exception e ) { return find Class ( loader , clazz . get Superclass ( ) ) ; } }
@ Override public void pop Values ( List < Node > values ) { left = values . remove ( NUM_ ) ; }
private void verify Name Constraints ( X 509 Certificate curr Cert ) throws Cert Path Validator Exception { String msg = STR_ ; if ( debug != null ) { debug . println ( STR_ + msg + STR_ ) ; } if ( prev NC != null && ( ( i == cert Path Length ) || ! X 509 Cert Impl . is Self Issued ( curr Cert ) ) ) { if ( debug != null ) { debug . println ( STR_ + prev NC + STR_ + curr Cert . get Subject X 500 Principal ( ) ) ; } try { if ( ! prev NC . verify ( curr Cert ) ) { throw new Cert Path Validator Exception ( msg + STR_ , null , null , - NUM_ , PKIX Reason . INVALID NAME ) ; } } catch ( IO Exception ioe ) { throw new Cert Path Validator Exception ( ioe ) ; } } prev NC = merge Name Constraints ( curr Cert , prev NC ) ; if ( debug != null ) debug . println ( msg + STR_ ) ; }
@ Override public boolean needs Materialization ( ) { return true ; }
public void replace Data ( String value ) { data = value ; }
protected < T extends Data Object > void check For Pending Tasks ( T object , URI tenant URI ) { Block Service Utils . check For Pending Tasks ( tenant URI , Arrays . as List ( object ) , db Client ) ; }
public static Stored Cell Probs Obs serializable Instance ( ) { return new Stored Cell Probs Obs ( new Array List < Node > ( ) ) ; }
@ Override public boolean input ( Instance instance ) { if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = false ; } if ( is First Batch Done ( ) ) { push ( instance ) ; return true ; } else { buffer Input ( instance ) ; return false ; } }
@ Override public void run ( ) { am I Active = true ; String input Header = null ; String output Header = null ; double SMALL NUM = NUM_ ; if ( args . length <= NUM_ ) { show Feedback ( STR_ ) ; return ; } input Header = args [ NUM_ ] ; output Header = args [ NUM_ ] ; SMALL NUM = Double . parse Double ( args [ NUM_ ] ) ; if ( ( input Header == null ) || ( output Header == null ) ) { show Feedback ( STR_ ) ; return ; } try { update Progress ( STR_ , - NUM_ ) ; int row n , col n ; int row , col ; double z n ; long k = NUM_ ; Grid Cell gc = null ; double z ; int [ ] Dy = { - NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ } ; int [ ] Dx = { NUM_ , NUM_ , NUM_ , NUM_ , - NUM_ , - NUM_ , - NUM_ , NUM_ } ; int progress = NUM_ ; int old Progress ; Whitebox Raster image = new Whitebox Raster ( input Header , STR_ ) ; int rows = image . get Number Rows ( ) ; int rows Less One = rows - NUM_ ; int cols = image . get Number Columns ( ) ; int num Cells = NUM_ ; String preferred Palette = image . get Preferred Palette ( ) ; double no Data = image . get No Data Value ( ) ; double [ ] [ ] output = new double [ rows ] [ cols ] ; double [ ] [ ] input = new double [ rows + NUM_ ] [ cols + NUM_ ] ; for ( row = NUM_ ; row < rows + NUM_ ; row ++ ) { input [ row ] [ NUM_ ] = no Data ; input [ row ] [ cols + NUM_ ] = no Data ; } for ( col = NUM_ ; col < cols + NUM_ ; col ++ ) { input [ NUM_ ] [ col ] = no Data ; input [ rows + NUM_ ] [ col ] = no Data ; } double [ ] data ; for ( row = NUM_ ; row < rows ; row ++ ) { data = image . get Row Values ( row ) ; for ( col = NUM_ ; col < cols ; col ++ ) { output [ row ] [ col ] = - NUM_ ; input [ row + NUM_ ] [ col + NUM_ ] = data [ col ] ; } } image . close ( ) ; update Progress ( STR_ , - NUM_ ) ; int num Cells Total = rows * cols ; int num Solved Cells = NUM_ ; Priority Queue < Grid Cell > queue = new Priority Queue < > ( ( NUM_ * rows + NUM_ * cols ) * NUM_ ) ; old Progress = - NUM_ ; for ( row = NUM_ ; row < rows ; row ++ ) { for ( col = NUM_ ; col < cols ; col ++ ) { z = input [ row + NUM_ ] [ col + NUM_ ] ; if ( z != no Data ) { num Cells ++ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { row n = row + Dy [ i ] ; col n = col + Dx [ i ] ; z n = input [ row n + NUM_ ] [ col n + NUM_ ] ; if ( z n == no Data ) { gc = new Grid Cell ( row , col , z ) ; queue . add ( gc ) ; output [ row ] [ col ] = z ; num Cells Total ++ ; break ; } } } else { num Solved Cells ++ ; output [ row ] [ col ] = no Data ; } } progress = ( int ) ( NUM_ * row / rows Less One ) ; if ( progress > old Progress ) { update Progress ( progress ) ; old Progress = progress ; if ( my Host . is Request For Operation Cancel Set ( ) ) { my Host . show Feedback ( STR_ ) ; return ; } } } update Progress ( STR_ , NUM_ ) ; old Progress = ( int ) ( NUM_ * num Solved Cells / num Cells Total ) ; do { gc = queue . poll ( ) ; row = gc . row ; col = gc . col ; z = gc . z ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { row n = row + Dy [ i ] ; col n = col + Dx [ i ] ; z n = input [ row n + NUM_ ] [ col n + NUM_ ] ; if ( ( z n != no Data ) && ( output [ row n ] [ col n ] == - NUM_ ) ) { if ( z n <= z ) { z n = z + SMALL NUM ; } output [ row n ] [ col n ] = z n ; num Solved Cells ++ ; gc = new Grid Cell ( row n , col n , z n ) ; queue . add ( gc ) ; } } progress = ( int ) ( NUM_ * num Solved Cells / num Cells Total ) ; if ( ( progress - old Progress ) == NUM_ ) { update Progress ( progress ) ; old Progress = progress ; if ( my Host . is Request For Operation Cancel Set ( ) ) { my Host . show Feedback ( STR_ ) ; return ; } } } while ( queue . is Empty ( ) == false ) ; update Progress ( STR_ , NUM_ ) ; Whitebox Raster output File = new Whitebox Raster ( output Header , STR_ , input Header , Whitebox Raster . Data Type . DOUBLE , - NUM_ ) ; output File . set Preferred Palette ( preferred Palette ) ; old Progress = - NUM_ ; for ( row = NUM_ ; row < rows ; row ++ ) { output File . set Row Values ( row , output [ row ] ) ; progress = ( int ) ( NUM_ * row / rows Less One ) ; if ( progress > old Progress ) { update Progress ( progress ) ; old Progress = progress ; if ( my Host . is Request For Operation Cancel Set ( ) ) { my Host . show Feedback ( STR_ ) ; return ; } } } output File . add Metadata Entry ( STR_ + get Descriptive Name ( ) + STR_ ) ; output File . add Metadata Entry ( STR_ + new Date ( ) ) ; output File . close ( ) ; return Data ( output Header ) ; } catch ( Out Of Memory Error oe ) { my Host . show Feedback ( STR_ ) ; } catch ( Exception e ) { my Host . show Feedback ( STR_ ) ; my Host . log Exception ( STR_ + get Descriptive Name ( ) , e ) ; } finally { update Progress ( STR_ , NUM_ ) ; am I Active = false ; my Host . plugin Complete ( ) ; } }
public Canvas Component Builder painter ( Canvas Painter painter ) { painters . add ( painter ) ; return this ; }
protected void post Runnable ( Runnable runnable ) { if ( runnable != null ) { if ( get Use Synchronous Mode ( ) || handler == null ) { runnable . run ( ) ; } else { handler . post ( runnable ) ; } } }
@ Skip Validation public DCB Display Info prepare Display Info ( ) { DCB Display Info dcb Disp Info = new DCB Display Info ( ) ; LOGGER . debug ( STR_ ) ; List < String > reason Category Codes = new Array List < String > ( ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE TAX ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE PENALTY ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE FINES ) ; reason Category Codes . add ( Property Tax Constants . REASON CATEGORY CODE ADVANCE ) ; dcb Disp Info . set Reason Category Codes ( reason Category Codes ) ; List < String > reason List = new Array List < String > ( ) ; reason List . add All ( ORDERED DEMAND RSNS LIST ) ; reason List . remove ( Property Tax Constants . DEMANDRSN CODE ADVANCE ) ; dcb Disp Info . set Reason Master Codes ( reason List ) ; LOGGER . debug ( STR_ + dcb Disp Info ) ; LOGGER . debug ( STR_ + ( reason List != null ? reason List . size ( ) : ZERO ) ) ; LOGGER . debug ( STR_ ) ; return dcb Disp Info ; }
public int current As Target ( ) { return current As Target . get ( ) ; }
public static void load Model ( ) throws IO Exception , T Exception , Unknown Word Exception { final Word 2 Vec Model model ; try ( Profiling Timer timer = Profiling Timer . create ( LOG , STR_ ) ) { String json = Common . read File To String ( new File ( STR_ ) ) ; model = Word 2 Vec Model . from Thrift ( Thrift Utils . deserialize Json ( new Word 2 Vec Model Thrift ( ) , json ) ) ; } interact ( model . for Search ( ) ) ; }
public byte [ ] create Image ( Projection proj , int scaled Width , int scaled Height , int included Layer Mask ) { return create Image ( proj , scaled Width , scaled Height , included Layer Mask , get Background ( ) ) ; }
@ Override public Scan open ( ) { Scan ss = sp . open ( ) ; return new Group By Scan ( ss , group Flds , agg Fns ) ; }
public void start Element ( String uri , String local Name , String q Name , Attributes attributes ) throws SAX Exception { try { if ( ! config Map . contains Key ( q Name ) ) { skip Characters = false ; writer . new Line ( ) ; writer . write ( STR_ + q Name ) ; for ( int i = NUM_ ; i < attributes . get Length ( ) ; i ++ ) { writer . write ( STR_ + attributes . get Q Name ( i ) + STR_ + attributes . get Value ( i ) + STR_ ) ; } writer . write ( STR_ ) ; } else { skip Characters = true ; } } catch ( IO Exception ioe ) { throw new SAX Exception ( ioe ) ; } }
public static void put PW Stat ( long id , Stat type , double s ) { if ( disabled ) return ; if ( ! pwstats . contains Key ( id ) ) pwstats . put ( id , new Hash Map < Stat , Linked List < Double > > ( ) ) ; Hash Map < Stat , Linked List < Double > > allstats = pwstats . get ( id ) ; if ( ! allstats . contains Key ( type ) ) allstats . put ( type , new Linked List < Double > ( ) ) ; Linked List < Double > stats = allstats . get ( type ) ; stats . add Last ( s ) ; }
final public boolean equals Ignore Case ( final Mutable String s ) { if ( this == s ) return true ; if ( s == null ) return false ; final int n = length ( ) ; if ( n == s . length ( ) ) { final char [ ] a 1 = array ; final char [ ] a 2 = s . array ; for ( int i = NUM_ ; i < n ; i ++ ) { if ( a 1 [ i ] != a 2 [ i ] && Character . to Lower Case ( a 1 [ i ] ) != Character . to Lower Case ( a 2 [ i ] ) && Character . to Upper Case ( a 1 [ i ] ) != Character . to Upper Case ( a 2 [ i ] ) ) return false ; } return true ; } return false ; }
private void process Reserved Symbols ( Tree Set < String > provides , Typed Scope top Scope ) { Set < String > collapsed Namespaces = new Tree Set < > ( ) ; for ( String reserved Provide : provides ) { if ( reserved Js Words . contains ( get Unqualified Name ( reserved Provide ) ) ) { String namespace = get Namespace ( reserved Provide ) ; if ( collapsed Namespaces . contains ( namespace ) ) continue ; collapsed Namespaces . add ( namespace ) ; Set < String > properties = get Sub Namespace ( provides , namespace ) ; emit Namespace Begin ( get Namespace ( namespace ) ) ; emit ( STR_ ) ; emit ( get Unqualified Name ( namespace ) ) ; emit ( STR_ ) ; Iterator < String > bundled It = properties . iterator ( ) ; while ( bundled It . has Next ( ) ) { emit ( get Unqualified Name ( bundled It . next ( ) ) ) ; emit ( STR_ ) ; Typed Var var = top Scope . get Own Slot ( reserved Provide ) ; if ( var != null ) { Tree Walker walker = new Tree Walker ( compiler . get Type Registry ( ) , provides , false ) ; walker . visit Type ( var . get Type ( ) ) ; } else { emit ( STR_ ) ; } if ( bundled It . has Next ( ) ) emit ( STR_ ) ; } emit ( STR_ ) ; emit Break ( ) ; emit Namespace End ( ) ; for ( String property : properties ) { declare Module ( property , true , property , true ) ; } } } Iterator < String > it = provides . iterator ( ) ; while ( it . has Next ( ) ) { if ( collapsed Namespaces . contains ( get Namespace ( it . next ( ) ) ) ) it . remove ( ) ; } }
public Object Reader with Value To Update ( Object value ) { if ( value == value To Update ) return this ; if ( value == null ) { throw new Illegal Argument Exception ( STR_ ) ; } Java Type t = ( value Type == null ) ? config . construct Type ( value . get Class ( ) ) : value Type ; return new Object Reader ( this , config , t , value , schema , injectable Values ) ; }
public static void save Credentials ( String server , String user , String password ) { server = server . replace All ( STR_ , STR_ ) ; server 2 Credentials . put ( server , new Pair < > ( user , password ) ) ; save Credentials To Properties ( ) ; }
private static boolean equal ( double [ ] [ ] array 1 , double [ ] [ ] array 2 ) { if ( array 1 == null ) { return ( array 2 == null ) ; } if ( array 2 == null ) { return false ; } if ( array 1 . length != array 2 . length ) { return false ; } for ( int i = NUM_ ; i < array 1 . length ; i ++ ) { if ( ! Arrays . equals ( array 1 [ i ] , array 2 [ i ] ) ) { return false ; } } return true ; }
public void choose Meta ( Meta Class Impl mci ) { if ( mci == null ) return ; Object receiver = get Corrected Receiver ( ) ; Object [ ] new Args = remove Real Receiver ( args ) ; if ( receiver instanceof Class ) { if ( LOG ENABLED ) LOG . info ( STR_ ) ; if ( ! mci . has Custom Static Invoke Method ( ) ) method = mci . retrieve Static Method ( name , new Args ) ; } else { String changed Name = name ; if ( receiver instanceof Generated Closure && changed Name . equals ( STR_ ) ) { changed Name = STR_ ; } if ( ! mci . has Custom Invoke Method ( ) ) method = mci . get Method With Caching ( selection Base , changed Name , new Args , false ) ; } if ( LOG ENABLED ) LOG . info ( STR_ + method ) ; }
public int update ( String table , Content Values values , String where Clause , String [ ] where Args ) { verify Db Is Open ( ) ; if ( values == null || values . size ( ) == NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } String Builder sql = new String Builder ( NUM_ ) ; sql . append ( STR_ ) ; sql . append ( table ) ; sql . append ( STR_ ) ; int set Values Size = values . size ( ) ; int bind Args Size = ( where Args == null ) ? set Values Size : ( set Values Size + where Args . length ) ; Object [ ] bind Args = new Object [ bind Args Size ] ; int i = NUM_ ; for ( String col Name : values . key Set ( ) ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; sql . append ( col Name ) ; bind Args [ i ++ ] = values . get ( col Name ) ; sql . append ( STR_ ) ; } if ( where Args != null ) { for ( i = set Values Size ; i < bind Args Size ; i ++ ) { bind Args [ i ] = where Args [ i - set Values Size ] ; } } if ( ! String Utils . is Empty ( where Clause ) ) { sql . append ( STR_ ) ; sql . append ( where Clause ) ; } return execute Sql ( sql . to String ( ) , bind Args ) ; }
public void notify Hide Hack ( ) { if ( local Hack List == null ) { return ; } Component Event ce = new Component Event ( this , Component Event . COMPONENT HIDDEN ) ; for ( Component Listener listener : local Hack List ) { listener . component Hidden ( ce ) ; } }
private String create Timestamp Uuid ( Soap Message message ) throws Parser Exception { Node List timestamp List = message . get Header ( ) . get Owner Document ( ) . get Elements By Tag Name NS ( WSU NAMESPACE , WSU TIMESTAMP LOCAL NAME ) ; assert timestamp List . get Length ( ) <= NUM_ ; if ( timestamp List . get Length ( ) == NUM_ ) { assert timestamp List . item ( NUM_ ) . get Node Type ( ) == Node . ELEMENT NODE ; Element timestamp = ( Element ) timestamp List . item ( NUM_ ) ; String timestamp Id = Util . random NC Name UUID ( ) ; Attr wsu Id = timestamp . get Owner Document ( ) . create Attribute NS ( WSU NAMESPACE , WSU ID LOCAL NAME ) ; wsu Id . set Prefix ( timestamp . get Prefix ( ) ) ; wsu Id . set Value ( timestamp Id ) ; timestamp . set Attribute Node NS ( wsu Id ) ; timestamp . set Id Attribute Node ( wsu Id , true ) ; log . trace ( STR_ + timestamp Id ) ; return timestamp Id ; } log . trace ( STR_ ) ; return null ; }
public static void exponential Sleep ( int attempt , int base , int max ) throws Interrupted Exception { long sleep Seconds = ( long ) Math . min ( max , Math . pow ( base , attempt ) ) ; LOG . debug ( String . format ( STR_ , attempt , sleep Seconds ) ) ; Thread . sleep ( NUM_ * sleep Seconds ) ; }
public static void v block filter ( Mpeg Enc Context s , int [ ] dst base , int dst offset , int w , int h , int stride , int is luma ) { int b x , b y , mvx stride , mvy stride ; int [ ] cm base = H 264 DSP Context . ff crop Tbl ; int cm offset = H 264 DSP Context . MAX NEG CROP ; int [ ] param = new int [ NUM_ ] ; set mv strides ( s , param ) ; mvx stride = param [ NUM_ ] ; mvy stride = param [ NUM_ ] ; mvx stride >>= is luma ; mvy stride *= mvx stride ; for ( b y = NUM_ ; b y < h - NUM_ ; b y ++ ) { for ( b x = NUM_ ; b x < w ; b x ++ ) { int x ; int top status = s . error status table [ ( b x > > is luma ) + ( b y > > is luma ) * s . mb stride ] ; int bottom status = s . error status table [ ( b x > > is luma ) + ( ( b y + NUM_ ) > > is luma ) * s . mb stride ] ; int top intra = NUM_ & ( int ) ( s . current picture . mb type base [ s . current picture . mb type offset + ( b x > > is luma ) + ( b y > > is luma ) * s . mb stride ] ) ; int bottom intra = NUM_ & ( int ) ( s . current picture . mb type base [ s . current picture . mb type offset + ( b x > > is luma ) + ( ( b y + NUM_ ) > > is luma ) * s . mb stride ] ) ; int top damage = top status & ( Mpeg Enc Context . DC ERROR | Mpeg Enc Context . AC ERROR | Mpeg Enc Context . MV ERROR ) ; int bottom damage = bottom status & ( Mpeg Enc Context . DC ERROR | Mpeg Enc Context . AC ERROR | Mpeg Enc Context . MV ERROR ) ; int offset = b x * NUM_ + b y * stride * NUM_ ; int [ ] top mv = s . current picture . motion val base [ NUM_ ] [ s . current picture . motion val offset [ NUM_ ] + mvy stride * b y + mvx stride * b x ] ; int [ ] bottom mv = s . current picture . motion val base [ NUM_ ] [ s . current picture . motion val offset [ NUM_ ] + mvy stride * ( b y + NUM_ ) + mvx stride * b x ] ; if ( ! ( top damage != NUM_ || bottom damage != NUM_ ) ) continue ; if ( ( NUM_ == top intra ) && ( NUM_ == bottom intra ) && Math . abs ( top mv [ NUM_ ] - bottom mv [ NUM_ ] ) + Math . abs ( top mv [ NUM_ ] + bottom mv [ NUM_ ] ) < NUM_ ) continue ; for ( x = NUM_ ; x < NUM_ ; x ++ ) { int a , b , c , d ; a = dst base [ dst offset + offset + x + NUM_ * stride ] - dst base [ dst offset + offset + x + NUM_ * stride ] ; b = dst base [ dst offset + offset + x + NUM_ * stride ] - dst base [ dst offset + offset + x + NUM_ * stride ] ; c = dst base [ dst offset + offset + x + NUM_ * stride ] - dst base [ dst offset + offset + x + NUM_ * stride ] ; d = Math . abs ( b ) - ( ( Math . abs ( a ) + Math . abs ( c ) + NUM_ ) > > NUM_ ) ; d = Math . max ( d , NUM_ ) ; if ( b < NUM_ ) d = - d ; if ( d == NUM_ ) continue ; if ( ! ( NUM_ != top damage && NUM_ != bottom damage ) ) d = d * NUM_ / NUM_ ; if ( NUM_ != top damage ) { dst base [ dst offset + offset + x + NUM_ * stride ] = cm base [ cm offset + dst base [ dst offset + offset + x + NUM_ * stride ] + ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + x + NUM_ * stride ] = cm base [ cm offset + dst base [ dst offset + offset + x + NUM_ * stride ] + ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + x + NUM_ * stride ] = cm base [ cm offset + dst base [ dst offset + offset + x + NUM_ * stride ] + ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + x + NUM_ * stride ] = cm base [ cm offset + dst base [ dst offset + offset + x + NUM_ * stride ] + ( ( d * NUM_ ) > > NUM_ ) ] ; } if ( NUM_ != bottom damage ) { dst base [ dst offset + offset + x + NUM_ * stride ] = cm base [ cm offset + dst base [ dst offset + offset + x + NUM_ * stride ] - ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + x + NUM_ * stride ] = cm base [ cm offset + dst base [ dst offset + offset + x + NUM_ * stride ] - ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + x + NUM_ * stride ] = cm base [ cm offset + dst base [ dst offset + offset + x + NUM_ * stride ] - ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + x + NUM_ * stride ] = cm base [ cm offset + dst base [ dst offset + offset + x + NUM_ * stride ] - ( ( d * NUM_ ) > > NUM_ ) ] ; } } } } }
private boolean process Key Up ( int key Code ) { if ( key Code == Key Event . KEYCODE ESCAPE || key Code == Key Event . KEYCODE BACK ) { dismiss ( ) ; return true ; } else if ( key Code == Key Event . KEYCODE TAB ) { if ( m In Kb Mode ) { if ( is Typed Time Fully Legal ( ) ) { finish Kb Mode ( true ) ; } return true ; } } else if ( key Code == Key Event . KEYCODE ENTER ) { if ( m In Kb Mode ) { if ( ! is Typed Time Fully Legal ( ) ) { return true ; } finish Kb Mode ( false ) ; } on Time Set ( m Time Picker , m Time Picker . get Hours ( ) , m Time Picker . get Minutes ( ) ) ; return true ; } else if ( key Code == Key Event . KEYCODE DEL ) { if ( m In Kb Mode ) { if ( ! m Typed Times . is Empty ( ) ) { int deleted = delete Last Typed Key ( ) ; String deleted Key Str ; if ( deleted == get Am Or Pm Key Code ( HALF DAY 1 ) ) { deleted Key Str = m Am Text ; } else if ( deleted == get Am Or Pm Key Code ( HALF DAY 2 ) ) { deleted Key Str = m Pm Text ; } else { deleted Key Str = String . format ( STR_ , get Val From Key Code ( deleted ) ) ; } Utils . try Accessibility Announce ( m Time Picker , String . format ( m Deleted Key Format , deleted Key Str ) ) ; update Display ( true ) ; } } } else if ( key Code == Key Event . KEYCODE 0 || key Code == Key Event . KEYCODE 1 || key Code == Key Event . KEYCODE 2 || key Code == Key Event . KEYCODE 3 || key Code == Key Event . KEYCODE 4 || key Code == Key Event . KEYCODE 5 || key Code == Key Event . KEYCODE 6 || key Code == Key Event . KEYCODE 7 || key Code == Key Event . KEYCODE 8 || key Code == Key Event . KEYCODE 9 || ( ! m Is 24 Hour Mode && ( key Code == get Am Or Pm Key Code ( HALF DAY 1 ) || key Code == get Am Or Pm Key Code ( HALF DAY 2 ) ) ) ) { if ( ! m In Kb Mode ) { if ( m Time Picker == null ) { Log . e ( TAG , STR_ ) ; return true ; } m Typed Times . clear ( ) ; try Starting Kb Mode ( key Code ) ; return true ; } if ( add Key If Legal ( key Code ) ) { update Display ( false ) ; } return true ; } return false ; }
public void unpin Connection ( String host , Integer port ) { connection Lock . lock ( ) ; try { String host And Port = Connection Manager . generate Connection Cache Key ( host , port ) ; if ( pinned Connections . contains Key ( host And Port ) ) { Integer count = pinned Connections . get ( host And Port ) - NUM_ ; if ( count == NUM_ ) { s logger . info ( STR_ , host And Port ) ; pinned Connections . remove ( host And Port ) ; } else { s logger . info ( STR_ , host And Port , count ) ; pinned Connections . put ( host And Port , count ) ; } } } finally { connection Lock . unlock ( ) ; } }
public void start Heartbeat ( Database database , String name ) throws SQL Exception { Array List < Column > where Clause = new Array List < Column > ( ) ; Array List < Column > values = new Array List < Column > ( ) ; Timestamp now = new Timestamp ( System . current Time Millis ( ) ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + name + STR_ + now ) ; hb Id . set Value ( KEY ) ; where Clause . add ( hb Id ) ; hb Source Tstamp . set Value ( now ) ; hb Salt . set Value ( salt Value . get And Increment ( ) ) ; hb Name . set Value ( name ) ; values . add ( hb Source Tstamp ) ; values . add ( hb Salt ) ; values . add ( hb Name ) ; database . update ( hb Table , where Clause , values ) ; }
public void register Critter Remove Listener ( Critter Remove Listener remove Listener ) { if ( ! l Listeners . contains ( remove Listener ) ) { l Listeners . add ( remove Listener ) ; } }
@ Override public void remove Alias ( String alias ) { Jedis Pool pool = null ; Jedis jedis = null ; try { pool = new Jedis Pool ( new Jedis Pool Config ( ) , redis Ip , Integer . parse Int ( redis Port ) , NUM_ ) ; jedis = pool . get Resource ( ) ; String frontend = STR_ + alias . to Lower Case ( ) + suffix Cloud Unit IO ; jedis . del ( frontend ) ; if ( logger . is Info Enabled ( ) ) { logger . info ( STR_ + frontend + STR_ ) ; } } catch ( Jedis Connection Exception e ) { logger . error ( STR_ , e ) ; } finally { if ( jedis != null ) { pool . destroy ( ) ; } } }
public void add Action Listener ( Action Listener al ) { if ( back Button != null && forward Button != null ) { back Button . add Action Listener ( al ) ; forward Button . add Action Listener ( al ) ; } else { if ( listeners == null ) { listeners = new Vector ( ) ; } listeners . add ( al ) ; } }
public static boolean decode To File ( String data To Decode , String filename ) { boolean success = false ; Base 64 . Output Stream bos = null ; try { bos = new Base 64 . Output Stream ( new java . io . File Output Stream ( filename ) , Base 64 . DECODE ) ; bos . write ( data To Decode . get Bytes ( PREFERRED ENCODING ) ) ; success = true ; } catch ( java . io . IO Exception e ) { success = false ; } finally { try { bos . close ( ) ; } catch ( Exception e ) { } } return success ; }
void activate Status Attribute ( String attribute Name ) { RP Entity entity = entity Ref . get ( ) ; if ( entity == null ) { return ; } if ( ! entity . has ( attribute Name ) ) { entity . put ( attribute Name , NUM_ ) ; entity . notify World About Changes ( ) ; } }
@ Override public double [ ] [ ] process Query Results ( Double DBID List results , Relation < ? extends Number Vector > database , int k ) { final int dim = Relation Util . dimensionality ( database ) ; final Covariance Matrix cmat = new Covariance Matrix ( dim ) ; if ( k > results . size ( ) ) { k = results . size ( ) ; } double maxdist = NUM_ ; double stddev = NUM_ ; { int i = NUM_ ; for ( Double DBID List Iter it = results . iter ( ) ; it . valid ( ) && i < k ; it . advance ( ) , k ++ ) { final double dist = it . double Value ( ) ; stddev += dist * dist ; if ( dist > maxdist ) { maxdist = dist ; } } if ( maxdist == NUM_ ) { maxdist = NUM_ ; } stddev = Math . sqrt ( stddev / k ) ; } int i = NUM_ ; for ( Double DBID List Iter it = results . iter ( ) ; it . valid ( ) && i < k ; it . advance ( ) , k ++ ) { final double dist = it . double Value ( ) ; Number Vector obj = database . get ( it ) ; double weight = weightfunction . get Weight ( dist , maxdist , stddev ) ; cmat . put ( obj , weight ) ; } return cmat . destroy To Naive Matrix ( ) ; }
public void add Time Bounds Provider ( Time Bounds Provider tbp ) { if ( ! time Bounds Providers . contains ( tbp ) ) { time Bounds Providers . add ( tbp ) ; reset Time Bounds ( ) ; } }
public final long read Unsigned Int ( ) throws IO Exception { m Position += NUM_ ; d . read Fully ( w , NUM_ , NUM_ ) ; return ( ( long ) ( w [ NUM_ ] ) << NUM_ | ( w [ NUM_ ] & NUM_ ) << NUM_ | ( w [ NUM_ ] & NUM_ ) << NUM_ | ( w [ NUM_ ] & NUM_ ) ) & NUM_ ; }
private boolean is Anomaly ( Instance instance , Active Rule rule ) { boolean is Anomaly = false ; if ( this . no Anomaly Detection == false ) { if ( rule . get Instances Seen ( ) >= this . anomaly Num Inst Threshold ) { is Anomaly = rule . is Anomaly ( instance , this . univariate Anomalyprobability Threshold , this . multivariate Anomaly Probability Threshold , this . anomaly Num Inst Threshold ) ; } } return is Anomaly ; }
@ Override public void add Date ( String word , Date date ) { add Date Internal ( new Index ( word . length ( ) ) , word , date ) ; }
private void populate Volume Recommendations ( Virtual Pool Capability Values Wrapper capabilities , Virtual Pool source Volume V Pool , Volume source Volume , String task Id , Task List task List , Integer volume Count , int volume Counter , String volume Label , List < Volume > prepared Volumes , List < Recommendation > volume Recommendations ) { List < Recommendation > current Recommendation = new Array List < Recommendation > ( ) ; Virtual Pool mirror V Pool = source Volume V Pool ; if ( ! is Null Or Empty ( source Volume V Pool . get Mirror Virtual Pool ( ) ) ) { URI mirror Pool Uri = URI . create ( source Volume V Pool . get Mirror Virtual Pool ( ) ) ; if ( ! URI Util . is Null ( mirror Pool Uri ) ) { mirror V Pool = db Client . query Object ( Virtual Pool . class , mirror Pool Uri ) ; } } for ( int i = NUM_ ; i < capabilities . get Resource Count ( ) ; i ++ ) { Volume Recommendation volume Recommendation = new Volume Recommendation ( Volume Recommendation . Volume Type . BLOCK VOLUME , source Volume . get Capacity ( ) , source Volume V Pool , source Volume . get Virtual Array ( ) ) ; volume Recommendation . set Id ( source Volume . get Id ( ) ) ; volume Recommendation . add Storage Pool ( source Volume . get Pool ( ) ) ; current Recommendation . add ( volume Recommendation ) ; } Virtual Array v Array = db Client . query Object ( Virtual Array . class , source Volume . get Virtual Array ( ) ) ; scheduler . get Recommendations For Mirrors ( v Array , mirror V Pool , capabilities , current Recommendation ) ; scheduler . prepare Recommended Volumes ( null , task Id , task List , null , null , source Volume V Pool , volume Count , current Recommendation , null , volume Counter , volume Label , prepared Volumes , capabilities , false ) ; volume Recommendations . add All ( current Recommendation ) ; }
private void wildcard ( XS Wildcard wc , String extra Atts ) { Schema Tree Node new Node = new Schema Tree Node ( Message Format . format ( STR_ , new Object [ ] { extra Atts } ) , wc . get Locator ( ) ) ; curr Node . add ( new Node ) ; }
@ Override public double [ ] distribution For Instance ( Instance instance ) throws Exception { double [ ] result ; init Model ( ) ; result = m Model . distribution For Instance ( instance ) ; return result ; }
public void add Property Change Listener ( Property Change Listener listener ) { List < Property Change Listener > l = Arrays . as List ( listener List . get Listeners ( Property Change Listener . class ) ) ; if ( ! l . contains ( listener ) ) { listener List . add ( Property Change Listener . class , listener ) ; } }
@ Rpc Method public void delete Disks ( List < String > disk Ids , Async Method Callback < Host . Async Client . delete disks call > handler ) throws Rpc Exception { ensure Client ( ) ; Delete Disks Request delete Disks Request = new Delete Disks Request ( disk Ids ) ; client Proxy . set Timeout ( DELETE DISK TIMEOUT MS ) ; logger . info ( STR_ , disk Ids , get Host Ip ( ) , delete Disks Request ) ; try { client Proxy . delete disks ( delete Disks Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
private void scroll To Position ( final long position ) { m scrollbar . set Value ( ( int ) position / ( NUM_ * m bytes Per Row ) ) ; }
default String format ( Object ... values ) { return String . format ( get Message Format ( ) , values ) ; }
public void stop Thread ( ) { this . stop Updates = true ; try { join ( ) ; } catch ( Interrupted Exception e ) { if ( LOGGER . info Enabled ( ) ) { LOGGER . info ( STR_ + e . get Message ( ) ) ; } } }
private void handle Browse ( ) { container . set Text ( Workspace Tools . select Project ( get Shell ( ) , container . get Text ( ) ) ) ; }
static < F extends Enum < F > & Mapper Config . Config Feature > int collect Feature Defaults ( Class < F > enum Class ) { int flags = NUM_ ; for ( F value : enum Class . get Enum Constants ( ) ) { if ( value . enabled By Default ( ) ) { flags |= value . get Mask ( ) ; } } return flags ; }
public Regression Data Set ( List < Data Point > data , int predicting ) { Data Point tmp = data . get ( NUM_ ) ; categories = new Categorical Data [ tmp . num Categorical Values ( ) ] ; System . arraycopy ( tmp . get Categorical Data ( ) , NUM_ , categories , NUM_ , categories . length ) ; num Numer Vals = tmp . num Numerical Values ( ) - NUM_ ; data Points = new Array List < Data Point Pair < Double > > ( data . size ( ) ) ; for ( Data Point dp : data ) { Vec orig V = dp . get Numerical Values ( ) ; Vec new Vec ; double target = NUM_ ; if ( orig V . is Sparse ( ) ) new Vec = new Sparse Vector ( orig V . length ( ) - NUM_ , orig V . nnz ( ) ) ; else new Vec = new Dense Vector ( orig V . length ( ) - NUM_ ) ; for ( Index Value iv : orig V ) if ( iv . get Index ( ) < predicting ) new Vec . set ( iv . get Index ( ) , iv . get Value ( ) ) ; else if ( iv . get Index ( ) == predicting ) target = iv . get Value ( ) ; else new Vec . set ( iv . get Index ( ) - NUM_ , iv . get Value ( ) ) ; Data Point new Dp = new Data Point ( new Vec , dp . get Categorical Values ( ) , categories , dp . get Weight ( ) ) ; Data Point Pair < Double > dpp = new Data Point Pair < Double > ( new Dp , target ) ; data Points . add ( dpp ) ; } this . numerical Variable Names = new Array List < String > ( get Num Numerical Vars ( ) ) ; set Up Generic Numeric Names ( ) ; }
private void create V Ms ( ) { Host host = Host . get Host ( NUM_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { vm Arr [ i ] = host . get VM ( i ) ; } }
public Lease Map Exception ( String s , Map exception Map ) { super ( s ) ; final Set map Entries = exception Map . entry Set ( ) ; for ( Iterator i = map Entries . iterator ( ) ; i . has Next ( ) ; ) { final Map . Entry entry = ( Entry ) i . next ( ) ; final Object key = entry . get Key ( ) ; final Object value = entry . get Value ( ) ; if ( key == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( ! ( key instanceof Lease ) ) { throw new Illegal Argument Exception ( STR_ + STR_ + key ) ; } if ( value == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( ! ( value instanceof Throwable ) ) { throw new Illegal Argument Exception ( STR_ + STR_ + value ) ; } } this . exception Map = exception Map ; }
public static Weighted Address [ ] resize Array ( Weighted Address [ ] array , int size ) { Weighted Address [ ] result = new Weighted Address [ size ] ; System . arraycopy ( array , NUM_ , result , NUM_ , array . length ) ; for ( int i = array . length ; i < result . length ; i ++ ) result [ i ] = new Weighted Address ( ) ; return result ; }
private boolean is Simple Polygonal ( Geometry geom ) { List rings = Linear Component Extracter . get Lines ( geom ) ; for ( Iterator i = rings . iterator ( ) ; i . has Next ( ) ; ) { Linear Ring ring = ( Linear Ring ) i . next ( ) ; if ( ! is Simple Linear Geometry ( ring ) ) return false ; } return true ; }
public static Extension Registry create Registry With Default Extensions ( ) { Extension Registry extension Registry = new Extension Registry ( null ) ; DEFAULT EXTENSIONS . for Each ( null ) ; return extension Registry ; }
public void export PEM Object ( Object pem Object , String filename ) throws IO Exception { Writer writer ; writer = new File Writer ( filename ) ; Jca PEM Writer jca Pem Writer = new Jca PEM Writer ( writer ) ; jca Pem Writer . write Object ( pem Object ) ; jca Pem Writer . flush ( ) ; jca Pem Writer . close ( ) ; }
public static String generate Native Guid For Virtual NAS ( String system Native Guid , String v Nas Name ) { return String . format ( STR_ + VIRTUAL NAS + STR_ , system Native Guid , v Nas Name ) ; }
@ Deprecated private Jdbc Type Field [ ] translate Fields ( Collection < Cache Type Field Metadata > old Flds ) { Jdbc Type Field [ ] new Flds = new Jdbc Type Field [ old Flds . size ( ) ] ; int idx = NUM_ ; for ( Cache Type Field Metadata old Field : old Flds ) { new Flds [ idx ] = new Jdbc Type Field ( old Field . get Database Type ( ) , old Field . get Database Name ( ) , old Field . get Java Type ( ) , old Field . get Java Name ( ) ) ; idx ++ ; } return new Flds ; }
protected Route Calculator create Route Calculator ( ) { return new Route Calculator ( ) ; }
public static String construct Hash Redis Key Prefix ( String queue Name , String shard Name ) { return String . format ( STR_ , PINLATER JOB HASH KEY PREFIX , shard Name , queue Name ) ; }
private boolean on Notification Clicked ( long persistent Notification Id , String origin , String tag ) { m Last Notification Click Ms = System . current Time Millis ( ) ; return native On Notification Clicked ( m Native Notification Manager , persistent Notification Id , origin , tag ) ; }
public Function lookup ( Class < ? > function Class , String name , Class < ? > ... param Types ) { List < Method > function Methods = new Array List < Method > ( ) ; add Function Methods ( function Class , function Methods ) ; Collections . sort ( function Methods , new Polymorphic Comparator ( ) ) ; for ( Method f Method : function Methods ) { Function Method f Anno = f Method . get Annotation ( Function Method . class ) ; if ( ( name . equals ( f Method . get Name ( ) ) ) || name . equals ( f Anno . value ( ) ) ) { if ( is Callable ( param Types , f Method . get Parameter Types ( ) ) ) { return create Function ( function Class , f Method ) ; } } } return null ; }
public String html tooltip xref ( String txt , String popup txt , String attrs , String xref ) { String out = String . format ( STR_ , popup txt , TARGET , attrs , xref , txt ) ; return out ; }
private Service Builder Impl ( Service Builder Impl < T > builder ) { Objects . require Non Null ( builder ) ; services = null ; address = builder . address ( ) ; if ( address != null ) { name = address ; } else { name = builder . name ( ) ; } workers = builder . workers ( ) ; api = builder . api ( ) ; queue Size = builder . queue Size ( ) ; queue Size Max = builder . queue Size Max ( ) ; offer Timeout = builder . queue Timeout ( ) ; queue Full Handler = builder . queue Full Handler ( ) ; is Public = builder . is Public ( ) ; is Auto Start = builder . is Auto Start ( ) ; is Journal = builder . is Journal ( ) ; journal Max Count = builder . journal Max Count ( ) ; journal Delay = builder . journal Delay ( ) ; }
private static void edge Split Predecessors ( Ssa Method result ) { Array List < Ssa Basic Block > blocks = result . get Blocks ( ) ; for ( int i = blocks . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Ssa Basic Block block = blocks . get ( i ) ; if ( node Needs Unique Predecessor ( block ) ) { block . insert New Predecessor ( ) ; } } }
public static R Args Values And Names match Arguments Evaluated ( R Root Node target , R Args Values And Names evaluated Args , S 3 Default Arguments s 3 Default Arguments , boolean for Next Method , R Base Node calling Node ) { Formal Arguments formals = target . get Formal Arguments ( ) ; Match Permutation match = permute Arguments ( evaluated Args . get Signature ( ) , formals . get Signature ( ) , calling Node , for Next Method , null , null , null ) ; Object [ ] evaled Args = new Object [ match . result Permutation . length ] ; for ( int formal Index = NUM_ ; formal Index < match . result Permutation . length ; formal Index ++ ) { int supplied Index = match . result Permutation [ formal Index ] ; if ( supplied Index == Match Permutation . VARARGS ) { int var Args Len = match . varargs Permutation . length ; Object [ ] new Var Args = new Object [ var Args Len ] ; boolean non Null = false ; for ( int i = NUM_ ; i < var Args Len ; i ++ ) { new Var Args [ i ] = evaluated Args . get Arguments ( ) [ match . varargs Permutation [ i ] ] ; non Null |= new Var Args [ i ] != null ; } if ( non Null ) { evaled Args [ formal Index ] = new R Args Values And Names ( new Var Args , match . varargs Signature ) ; } else { evaled Args [ formal Index ] = R Args Values And Names . EMPTY ; } } else if ( supplied Index == Match Permutation . UNMATCHED || evaluated Args . get Argument ( supplied Index ) == null ) { Object default Value = get S 3 Default Argument Value ( s 3 Default Arguments , formals , formal Index ) ; if ( default Value == null ) { default Value = formals . get Internal Default Argument At ( formal Index ) ; } evaled Args [ formal Index ] = default Value ; } else { evaled Args [ formal Index ] = evaluated Args . get Argument ( supplied Index ) ; } } return new R Args Values And Names ( evaled Args , formals . get Signature ( ) ) ; }
private void skip Entry ( ) throws Parsing Exception , IO Exception { while ( lookahead != STR_ ) { switch ( lookahead ) { case Stream Tokenizer . TT NUMBER : throw new Parsing Exception ( st . lineno ( ) , STR_ , Resources Mgr . get String ( STR_ ) + String . value Of ( st . nval ) ) ; case Stream Tokenizer . TT EOF : throw new Parsing Exception ( Resources Mgr . get String ( STR_ ) ) ; default : lookahead = st . next Token ( ) ; } } }
protected void remove State For Cell ( Object cell ) { int child Count = model . get Child Count ( cell ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { remove State For Cell ( model . get Child At ( cell , i ) ) ; } view . remove State ( cell ) ; }
private void populate Child Gallery ( ) { Array List < Data Holder > files = read Gallery ( ( Gallery Activity ) get Activity ( ) ) ; System . gc ( ) ; m Gallery Adapter = new Gallery Adapter ( get Activity ( ) , R . layout . gridview child gallery item , m Gallery Type , files , m Cache Manager , my Context . get File Paths List ( ) , my Context . get Max Photo ( ) ) ; m Gallery Adapter . set Photo Click Listener ( ( Gallery Activity ) get Activity ( ) ) ; m Gallery View . set Adapter ( m Gallery Adapter ) ; }
public static int compare ( Location a , Location b ) { return Integer . compare ( ORDERED ZONES . index Of ( a . uuid ) , ORDERED ZONES . index Of ( b . uuid ) ) ; }
private void read From Version 2 Stream ( Status From Bytes Stream dis ) throws IO Exception { read From Version 1 Stream ( dis ) ; lock Owner = dis . read UTF ( ) ; if ( lock Owner . equals ( STR_ ) ) lock Owner = null ; lock Creation Date = dis . read Long ( ) ; lock Comment = dis . read UTF ( ) ; if ( lock Comment . equals ( STR_ ) ) lock Comment = null ; read Only = dis . read Boolean ( ) ; }
public IRI Validator ( @ Non Null final Char Sequence error Message ) { super ( error Message , REGEX ) ; }
public static boolean delete Files ( final File file ) { boolean ok = true ; if ( file != null ) { if ( file . is Directory ( ) ) { final File [ ] files = file . list Files ( ) ; if ( files != null ) { for ( final File f : files ) { if ( f . is File ( ) ) { ok &= f . delete ( ) ; } } } else { ok = false ; } ok &= file . delete ( ) ; } } return ok ; }
public Exception [ ] cancel All ( String [ ] entry Uids , String [ ] class Names , int [ ] object Types ) { Array List < Exception > exceptions List = new Array List < Exception > ( NUM_ ) ; for ( int i = NUM_ ; i < entry Uids . length ; i ++ ) { try { cancel ( entry Uids [ i ] , class Names [ i ] , object Types [ i ] , false , true , false ) ; } catch ( Exception ex ) { exceptions List . add ( ex ) ; } } return exceptions List . to Array ( new Exception [ exceptions List . size ( ) ] ) ; }
public Timestamp recalculate Estimated Completion Date ( ) { this . update Completion Date = false ; return recalculate Estimated Completion Date ( Long . value Of ( NUM_ ) , estimated Start Date ) ; }
private table create Tabs ( String sel Tab ) { td tabbar = new td ( STR_ , Align Type . LEFT , Align Type . MIDDLE , false ) ; a tab = new a ( STR_ , new span ( STR_ ) ) ; if ( sel Tab . equals ( STR_ ) ) { tab . set ID ( STR_ ) ; } else { tab . set ID ( STR_ ) ; tab . set Href ( Mobile Env . get Base Directory ( STR_ ) ) ; } tab . set On Mouse Over ( STR_ ) ; tabbar . add Element ( tab ) ; tab = new a ( STR_ , new span ( STR_ ) ) ; if ( sel Tab . equals ( STR_ ) ) { tab . set ID ( STR_ ) ; } else { tab . set ID ( STR_ ) ; tab . set Href ( Mobile Env . get Base Directory ( STR_ ) ) ; } tab . set On Mouse Over ( STR_ ) ; tabbar . add Element ( tab ) ; table top Table = new table ( STR_ , STR_ , STR_ , STR_ , null ) ; top Table . set ID ( STR_ ) ; top Table . add Element ( new tr ( tabbar ) ) ; return top Table ; }
public Key Pair generate Key Pair ( ) throws Key Store Exception { Key Pair key Pair ; try { Key Pair Generator generator = Key Pair Generator . get Instance ( STR_ ) ; generator . initialize ( NUM_ ) ; key Pair = generator . generate Key Pair ( ) ; } catch ( No Such Algorithm Exception e ) { throw new Key Store Exception ( STR_ , e ) ; } return key Pair ; }
public static void silent Close Input Stream ( Input Stream is ) { try { if ( is != null ) { is . close ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } }
@ Suppress Warnings ( { STR_ , STR_ } ) void append Query Fields ( final String Buffer buf , final Map fields ) { final List field Names = new Array List ( fields . key Set ( ) ) ; final Iterator itr = field Names . iterator ( ) ; while ( itr . has Next ( ) ) { final String field Name = ( String ) itr . next ( ) ; final String field Value = ( String ) fields . get ( field Name ) ; if ( field Value != null && field Value . length ( ) > NUM_ ) try { buf . append ( URL Encoder . encode ( field Name , STR_ ) ) ; buf . append ( STR_ ) ; buf . append ( URL Encoder . encode ( field Value , STR_ ) ) ; } catch ( final Unsupported Encoding Exception e ) { throw new Runtime Exception ( e . get Message ( ) ) ; } if ( itr . has Next ( ) ) buf . append ( STR_ ) ; } }
@ Override public void initialize ( ) { super . initialize ( ) ; set Root ( ) ; }
private boolean check Requested Key Age ( String key Entry ) throws Number Format Exception { long requested Token Key TS = Long . parse Long ( key Entry ) ; long now = System . current Time Millis ( ) ; long diff = now - requested Token Key TS ; if ( diff > ( NUM_ * key Rotation Interval In Msecs ) ) { log . debug ( STR_ , key Entry ) ; return false ; } long youngest Key = Long . parse Long ( cached Token Keys Bundle . get Current Key Entry ( ) ) ; if ( youngest Key < Long . parse Long ( key Entry ) ) { log . debug ( STR_ , key Entry ) ; return false ; } return true ; }
private static int calculate In Sample Size ( Bitmap Factory . Options options , int req Width , int req Height ) { final int height = options . out Height ; final int width = options . out Width ; int in Sample Size = NUM_ ; if ( height > req Height || width > req Width ) { if ( width > height ) { in Sample Size = Math . round ( ( float ) height / ( float ) req Height ) ; } else { in Sample Size = Math . round ( ( float ) width / ( float ) req Width ) ; } } return in Sample Size ; }
@ Suppress Warnings ( STR_ ) public static Class < ? extends Enum < ? > > find Enum Type ( Class < ? > cls ) { if ( cls . get Superclass ( ) != Enum . class ) { cls = cls . get Superclass ( ) ; } return ( Class < ? extends Enum < ? > > ) cls ; }
public double sigmoid ( double z ) { double answer = NUM_ ; if ( z >= max Exponent ) return NUM_ ; else if ( z <= - max Exponent ) return NUM_ ; else { double index = table Size * Math . abs ( z ) / ( double ) max Exponent ; answer = sigmoid Table [ ( int ) index ] ; if ( z < NUM_ ) answer = NUM_ - answer ; } return answer ; }
private void adjust For Right Fading Edge ( View child In Selected Row , int left Selection Pixel , int right Selection Pixel ) { if ( child In Selected Row . get Right ( ) > right Selection Pixel ) { int space To Left = child In Selected Row . get Left ( ) - left Selection Pixel ; int space To Right = child In Selected Row . get Right ( ) - right Selection Pixel ; int offset = Math . min ( space To Left , space To Right ) ; offset Children Left And Right ( - offset ) ; } }
public static String [ ] split ( final Char Sequence char Sequence , final char separator ) { if ( is Empty ( char Sequence ) ) { return EMPTY ARRAY ; } final int original Separators Count = count Separated Char Appearances ( char Sequence , separator ) ; int separators Count = original Separators Count ; if ( starts With ( char Sequence , separator ) ) { separators Count -- ; } if ( char Sequence . length ( ) > NUM_ && ends With ( char Sequence , separator ) ) { separators Count -- ; } if ( separators Count <= NUM_ ) { if ( original Separators Count == NUM_ ) { return new String [ ] { char Sequence . to String ( ) } ; } else if ( is Same Char ( char Sequence ) ) { return EMPTY ARRAY ; } return new String [ ] { remove Character ( char Sequence . to String ( ) , separator ) } ; } final String [ ] result = new String [ separators Count + NUM_ ] ; int current Result Index = NUM_ ; final String Builder builder = new String Builder ( ) ; for ( int index = NUM_ , length = char Sequence . length ( ) ; index < length ; index ++ ) { final char character = char Sequence . char At ( index ) ; if ( character == separator ) { if ( is Not Empty ( builder ) ) { result [ current Result Index ++ ] = builder . to String ( ) ; clear Builder ( builder ) ; } } else { builder . append ( character ) ; } } if ( is Not Empty ( builder ) ) { result [ current Result Index ++ ] = builder . to String ( ) ; } return result ; }
public static String object String ( Object obj ) { String Builder sb = new String Builder ( ) ; object String ( obj , sb ) ; return sb . to String ( ) ; }
public boolean is Normal ( boolean b Only Value , double d P Value For Rejection ) { double d P Res = NUM_ ; double d SD = standard Deviation ( b Only Value ) ; double d Skewness = get Central Moment ( b Only Value , NUM_ ) / Math . pow ( d SD , NUM_ ) ; double d Kurtosis = get Central Moment ( b Only Value , NUM_ ) / Math . pow ( d SD , NUM_ ) ; double d JB = ( observation Count ( b Only Value ) / NUM_ ) * ( Math . pow ( d Skewness , NUM_ ) + ( Math . pow ( d Kurtosis - NUM_ , NUM_ ) / NUM_ ) ) ; d P Res = Chi Square Distribution Base . get P Value ( d JB ) ; return d P Res > d P Value For Rejection ; }
public static Explanation match ( float value , String description , Explanation ... details ) { return new Explanation ( true , value , description , Arrays . as List ( details ) ) ; }
private static int fill Poms From Children ( final Collection < Artifact Information > poms , final Artifact Information art , final Map < String , Artifact Information > artifacts ) { int cnt = NUM_ ; for ( final String child Id : art . get Child Ids ( ) ) { final Artifact Information child = artifacts . get ( child Id ) ; if ( child != null ) { final String child Name = child . get Name ( ) ; if ( is Pom File Name ( child Name ) ) { poms . add ( child ) ; ++ cnt ; } } } return cnt ; }
@ Json Value public List < Interval > as List ( ) { return Collections . unmodifiable List ( this ) ; }
protected boolean switch Profiles ( I Profile new Selection ) { if ( new Selection == null ) { return false ; } if ( m Current Profile == new Selection ) { return true ; } if ( m Alternative Profile Header Switching ) { int prev Selection = - NUM_ ; if ( m Profile First == new Selection ) { prev Selection = NUM_ ; } else if ( m Profile Second == new Selection ) { prev Selection = NUM_ ; } else if ( m Profile Third == new Selection ) { prev Selection = NUM_ ; } I Profile tmp = m Current Profile ; m Current Profile = new Selection ; if ( prev Selection == NUM_ ) { m Profile First = tmp ; } else if ( prev Selection == NUM_ ) { m Profile Second = tmp ; } else if ( prev Selection == NUM_ ) { m Profile Third = tmp ; } } else { if ( m Profiles != null ) { Array List < I Profile > previous Active Profiles = new Array List < > ( Arrays . as List ( m Current Profile , m Profile First , m Profile Second , m Profile Third ) ) ; if ( previous Active Profiles . contains ( new Selection ) ) { int position = - NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( previous Active Profiles . get ( i ) == new Selection ) { position = i ; break ; } } if ( position != - NUM_ ) { previous Active Profiles . remove ( position ) ; previous Active Profiles . add ( NUM_ , new Selection ) ; m Current Profile = previous Active Profiles . get ( NUM_ ) ; m Profile First = previous Active Profiles . get ( NUM_ ) ; m Profile Second = previous Active Profiles . get ( NUM_ ) ; m Profile Third = previous Active Profiles . get ( NUM_ ) ; } } else { m Profile Third = m Profile Second ; m Profile Second = m Profile First ; m Profile First = m Current Profile ; m Current Profile = new Selection ; } } } build Profiles ( ) ; return false ; }
public static String name For Task ( Hadoop Task Info info , boolean prefix ) { if ( prefix ) return STR_ + info . job Id ( ) + STR_ ; else return STR_ + info . job Id ( ) + STR_ + info . type ( ) + STR_ + info . task Number ( ) ; }
protected void swap Dataset Key And Result Key ( ) { int [ ] tmp Selected ; Range tmp Range ; tmp Selected = m Dataset Key List . get Selected Indices ( ) ; m Dataset Key List . set Selected Indices ( m Result Key List . get Selected Indices ( ) ) ; m Result Key List . set Selected Indices ( tmp Selected ) ; tmp Range = m T Tester . get Dataset Key Columns ( ) ; m T Tester . set Dataset Key Columns ( m T Tester . get Resultset Key Columns ( ) ) ; m T Tester . set Resultset Key Columns ( tmp Range ) ; set T Tester ( ) ; }
public String generate Name ( final Int Unary Operator random In Range , final int length , final char starting Symbol ) { if ( length == NUM_ ) { return STR_ ; } final String Builder sb = new String Builder ( ) ; sb . append ( starting Symbol ) ; while ( sb . length ( ) < length ) { for ( int i = NUM_ ; i < sb . length ( ) ; i ++ ) { final char current Char = sb . char At ( i ) ; final boolean is Current Char Upper Case = Character . is Upper Case ( current Char ) ; if ( is Current Char Upper Case ) { final String substitution = choose Random Rule Option ( random In Range , current Char ) ; if ( substitution != null ) { String temp = sb . to String ( ) ; temp = temp . replace ( String . value Of ( current Char ) , substitution ) ; sb . set Length ( NUM_ ) ; sb . append ( temp ) ; i -- ; } } } if ( sb . length ( ) < length ) { sb . set Length ( NUM_ ) ; sb . append ( starting Symbol ) ; } } if ( length >= NUM_ ) { return sb . substring ( NUM_ , length ) ; } else { return sb . to String ( ) ; } }
private static long packed Code Size ( Int List cases ) { int sz = cases . size ( ) ; long low = cases . get ( NUM_ ) ; long high = cases . get ( sz - NUM_ ) ; long result = ( ( high - low + NUM_ ) ) * NUM_ + NUM_ ; return ( result <= NUM_ ) ? result : - NUM_ ; }
@ Suppress Warnings ( STR_ ) @ Override public synchronized void clear Readers ( ) { rdrs = Reader Id . EMPTY ARRAY ; }
private void populate Time Fields ( ) { left Store . set Time Fields ( time Field Str . split ( STR_ ) [ NUM_ ] ) ; right Store . set Time Fields ( time Field Str . split ( STR_ ) [ NUM_ ] ) ; }
public void abort Connect For Communication Channel ( ) { if ( connecting Communication Channel Socket != null ) { try { connecting Communication Channel Socket . close ( ) ; } catch ( Throwable t ) { } } }
protected void verify Attributes ( Attr Set attr Set ) throws AM Exception { String user Status = attr Set . get Value ( USER STATUS ATTRIBUTE ) ; if ( user Status != null && user Status . equals Ignore Case ( STR_ ) ) { debug . warning ( STR_ + USER STATUS ATTRIBUTE + STR_ + user Status ) ; throw new AM Exception ( AMSDK Bundle . get String ( STR_ ) , STR_ ) ; } }
protected void make Widgets ( ) { String loc Text ; Grid Bag Layout gridbag = new Grid Bag Layout ( ) ; Grid Bag Constraints c = new Grid Bag Constraints ( ) ; Insets left Insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; Insets center Insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; Insets right Insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; set Layout ( gridbag ) ; loc Text = i 18 n . get ( DMS Coord Panel . class , STR_ , STR_ ) ; set Border ( new Titled Border ( new Etched Border ( ) , loc Text ) ) ; loc Text = i 18 n . get ( DMS Coord Panel . class , STR_ , STR_ ) ; J Label latlabel = new J Label ( loc Text ) ; c . gridx = NUM_ ; c . fill = Grid Bag Constraints . NONE ; c . weightx = NUM_ ; c . insets = left Insets ; c . anchor = Grid Bag Constraints . EAST ; gridbag . set Constraints ( latlabel , c ) ; add ( latlabel ) ; c . gridx = Grid Bag Constraints . RELATIVE ; deg Lat = new J Text Field ( NUM_ ) ; c . fill = Grid Bag Constraints . HORIZONTAL ; c . weightx = NUM_ ; c . insets = center Insets ; gridbag . set Constraints ( deg Lat , c ) ; add ( deg Lat ) ; min Lat = new J Text Field ( NUM_ ) ; gridbag . set Constraints ( min Lat , c ) ; add ( min Lat ) ; sec Lat = new J Text Field ( NUM_ ) ; c . insets = right Insets ; gridbag . set Constraints ( sec Lat , c ) ; add ( sec Lat ) ; loc Text = i 18 n . get ( DMS Coord Panel . class , STR_ , STR_ ) ; J Label lonlabel = new J Label ( loc Text ) ; c . gridx = NUM_ ; c . gridy = NUM_ ; c . fill = Grid Bag Constraints . NONE ; c . weightx = NUM_ ; c . insets = left Insets ; c . anchor = Grid Bag Constraints . EAST ; gridbag . set Constraints ( lonlabel , c ) ; add ( lonlabel ) ; c . gridx = Grid Bag Constraints . RELATIVE ; deg Lon = new J Text Field ( NUM_ ) ; c . fill = Grid Bag Constraints . HORIZONTAL ; c . weightx = NUM_ ; c . insets = center Insets ; gridbag . set Constraints ( deg Lon , c ) ; add ( deg Lon ) ; min Lon = new J Text Field ( NUM_ ) ; gridbag . set Constraints ( min Lon , c ) ; add ( min Lon ) ; sec Lon = new J Text Field ( NUM_ ) ; c . insets = right Insets ; gridbag . set Constraints ( sec Lon , c ) ; add ( sec Lon ) ; }
private static boolean should Force Classic VM ( Sdk jdk ) { if ( System Info . is Mac ) { return false ; } if ( jdk == null ) return false ; String version = Jdk Util . get Jdk Main Attribute ( jdk , Attributes . Name . IMPLEMENTATION VERSION ) ; if ( version != null ) { if ( version . compare To ( STR_ ) >= NUM_ ) { return false ; } if ( version . starts With ( STR_ ) && System Info . is Windows ) { return true ; } version += STR_ ; if ( version . starts With ( STR_ ) && System Info . is Windows ) { return true ; } if ( ( version . starts With ( STR_ ) || version . starts With ( STR_ ) ) && System Info . is Windows ) { return false ; } } return Debugger Settings . get Instance ( ) . FORCE CLASSIC VM ; }
public static Delete Sub Command Handler create ( Sub Command Argument Parser parser , Managed Object Path < ? , ? > p , Instantiable Relation Definition < ? , ? > r ) throws Argument Exception { return new Delete Sub Command Handler ( parser , p , r , p . child ( r , STR_ ) ) ; }
private void configure Charset Properties ( ) throws SQL Exception { if ( get Encoding ( ) != null ) { try { String test String = STR_ ; String Utils . get Bytes ( test String , get Encoding ( ) ) ; } catch ( Unsupported Encoding Exception UE ) { String old Encoding = get Encoding ( ) ; try { set Encoding ( Charset Mapping . get Java Encoding For Mysql Charset ( old Encoding ) ) ; } catch ( Runtime Exception ex ) { SQL Exception sql Ex = SQL Error . create SQL Exception ( ex . to String ( ) , SQL Error . SQL STATE ILLEGAL ARGUMENT , null ) ; sql Ex . init Cause ( ex ) ; throw sql Ex ; } if ( get Encoding ( ) == null ) { throw SQL Error . create SQL Exception ( STR_ + old Encoding + STR_ , SQL Error . SQL STATE INVALID CONNECTION ATTRIBUTE , get Exception Interceptor ( ) ) ; } try { String test String = STR_ ; String Utils . get Bytes ( test String , get Encoding ( ) ) ; } catch ( Unsupported Encoding Exception encoding Ex ) { throw SQL Error . create SQL Exception ( STR_ + get Encoding ( ) + STR_ , SQL Error . SQL STATE INVALID CONNECTION ATTRIBUTE , get Exception Interceptor ( ) ) ; } } } }
private void adjust And Map Source Range Range ( Normal Ssa Insn insn ) { int new Reg Start = find Range And Adjust ( insn ) ; Register Spec List sources = insn . get Sources ( ) ; int sz Sources = sources . size ( ) ; int next Rop Reg = new Reg Start ; for ( int i = NUM_ ; i < sz Sources ; i ++ ) { Register Spec source = sources . get ( i ) ; int source Reg = source . get Reg ( ) ; int category = source . get Category ( ) ; int cur Rop Reg = next Rop Reg ; next Rop Reg += category ; if ( ssa Regs Mapped . get ( source Reg ) ) { continue ; } Local Item local Item = get Local Item For Reg ( source Reg ) ; add Mapping ( source , cur Rop Reg ) ; if ( local Item != null ) { mark Reserved ( cur Rop Reg , category ) ; Array List < Register Spec > similar Registers = local Variables . get ( local Item ) ; int sz Similar = similar Registers . size ( ) ; for ( int j = NUM_ ; j < sz Similar ; j ++ ) { Register Spec similar Spec = similar Registers . get ( j ) ; int similar Reg = similar Spec . get Reg ( ) ; if ( - NUM_ != sources . index Of Register ( similar Reg ) ) { continue ; } try Map Reg ( similar Spec , cur Rop Reg , category ) ; } } } }
void update IM ( Intersection Matrix im ) { Edge . update IM ( label , im ) ; }
@ Override public void register Callback ( I Provider Callback cb ) { synchronized ( m Callbacks ) { m Callbacks . add ( cb ) ; } }
public void add New Spawn Map ( Spawn Map spawn Map ) { if ( templates == null ) { templates = new Array List < Spawn Map > ( ) ; } templates . add ( spawn Map ) ; }
@ Reference ( title = STR_ , authors = STR_ , booktitle = STR_ , url = STR_ ) public static double pmf ( double x , int n , double p ) { if ( x < NUM_ || x > n ) { return NUM_ ; } if ( p <= NUM_ ) { return x == NUM_ ? NUM_ : NUM_ ; } if ( p >= NUM_ ) { return x == n ? NUM_ : NUM_ ; } final double q = NUM_ - p ; if ( x == NUM_ ) { if ( p < NUM_ ) { return Math . exp ( - deviance Term ( n , n * q ) - n * p ) ; } else { return Math . exp ( n * Math . log ( q ) ) ; } } if ( x == n ) { if ( p > NUM_ ) { return Math . exp ( - deviance Term ( n , n * p ) - n * q ) ; } else { return Math . exp ( n * Math . log ( p ) ) ; } } final double lc = stirling Error ( n ) - stirling Error ( x ) - stirling Error ( n - x ) - deviance Term ( x , n * p ) - deviance Term ( n - x , n * q ) ; final double f = ( Math Util . TWOPI * x * ( n - x ) ) / n ; return Math . exp ( lc ) / Math . sqrt ( f ) ; }
private void validate Annotation Methods ( Method [ ] member Methods ) { boolean valid = true ; for ( Method method : member Methods ) { if ( method . get Modifiers ( ) != ( Modifier . PUBLIC | Modifier . ABSTRACT ) || method . is Default ( ) || method . get Parameter Count ( ) != NUM_ || method . get Exception Types ( ) . length != NUM_ ) { valid = false ; break ; } Class < ? > return Type = method . get Return Type ( ) ; if ( return Type . is Array ( ) ) { return Type = return Type . get Component Type ( ) ; if ( return Type . is Array ( ) ) { valid = false ; break ; } } if ( ! ( ( return Type . is Primitive ( ) && return Type != void . class ) || return Type == java . lang . String . class || return Type == java . lang . Class . class || return Type . is Enum ( ) || return Type . is Annotation ( ) ) ) { valid = false ; break ; } String method Name = method . get Name ( ) ; if ( ( method Name . equals ( STR_ ) && return Type == java . lang . String . class ) || ( method Name . equals ( STR_ ) && return Type == int . class ) || ( method Name . equals ( STR_ ) && return Type == java . lang . Class . class ) ) { valid = false ; break ; } } if ( valid ) return ; else throw new Annotation Format Error ( STR_ ) ; }
public boolean has Split Token By ( ) { return ! split Token By . is Empty ( ) ; }
private static Path qualified ( Path root Path , Path path ) { URI root Uri = root Path . to Uri ( ) ; return path . make Qualified ( root Uri , new Path ( root Uri . get Path ( ) ) ) ; }
@ Override Observed Object create Observed Object ( Object Name object ) { final Counter Monitor Observed Object cmo = new Counter Monitor Observed Object ( object ) ; cmo . set Threshold ( init Threshold ) ; cmo . set Modulus Exceeded ( false ) ; cmo . set Event Already Notified ( false ) ; cmo . set Previous Scan Counter ( null ) ; return cmo ; }
public boolean check Label ( final String a Label ) { if ( a Label == null || a Label . equals ( STR_ ) ) { logger . debug ( STR_ ) ; return false ; } return a Label . equals ( this . label ) ; }
final public void compute Time Limit ( Search Params s Par ) { min Time Limit = - NUM_ ; max Time Limit = - NUM_ ; max Depth = - NUM_ ; max Nodes = - NUM_ ; if ( s Par . infinite ) { min Time Limit = - NUM_ ; max Time Limit = - NUM_ ; max Depth = - NUM_ ; } else if ( s Par . depth > NUM_ ) { max Depth = s Par . depth ; } else if ( s Par . mate > NUM_ ) { max Depth = s Par . mate * NUM_ - NUM_ ; } else if ( s Par . move Time > NUM_ ) { min Time Limit = max Time Limit = s Par . move Time ; } else if ( s Par . nodes > NUM_ ) { max Nodes = s Par . nodes ; } else { int moves = s Par . moves To Go ; if ( moves == NUM_ ) { moves = NUM_ ; } moves = Math . min ( moves , NUM_ ) ; if ( ponder Mode ) { final double ponder Hit Rate = NUM_ ; moves = ( int ) Math . ceil ( moves * ( NUM_ - ponder Hit Rate ) ) ; } boolean white = pos . white Move ; int time = white ? s Par . w Time : s Par . b Time ; int inc = white ? s Par . w Inc : s Par . b Inc ; final int margin = Math . min ( NUM_ , time * NUM_ / NUM_ ) ; int time Limit = ( time + inc * ( moves - NUM_ ) - margin ) / moves ; min Time Limit = ( int ) ( time Limit * NUM_ ) ; max Time Limit = ( int ) ( min Time Limit * ( Math . max ( NUM_ , Math . min ( NUM_ , moves / NUM_ ) ) ) ) ; min Time Limit = clamp ( min Time Limit , NUM_ , time - margin ) ; max Time Limit = clamp ( max Time Limit , NUM_ , time - margin ) ; } }
private List < Volume > create Block Volumes ( String volume Name , int num Volumes , URI storage System ) { List < Volume > volumes = new Array List < Volume > ( ) ; for ( int i = NUM_ ; i <= num Volumes ; i ++ ) { Volume volume = new Volume ( ) ; URI volume URI = URI Util . create Id ( Volume . class ) ; block Volume UR Is . add ( volume URI ) ; volume . set Id ( volume URI ) ; volume . set Label ( volume Name + i ) ; volume . set Storage Controller ( storage System ) ; db Client . create Object ( volume ) ; volumes . add ( volume ) ; } return volumes ; }
public static String generate Native Guid ( Db Client db Client , Storage Port port ) { Storage System device = db Client . query Object ( Storage System . class , port . get Storage Device ( ) ) ; return String . format ( STR_ + PORT + STR_ , device Type Map . get ( device . get System Type ( ) ) , device . get Serial Number ( ) , port . get Port Network Id ( ) ) ; }
private void read Object ( java . io . Object Input Stream s ) throws java . io . IO Exception , Class Not Found Exception { s . default Read Object ( ) ; int n = s . read Int ( ) ; values = new Vector < > ( n ) ; while ( -- n >= NUM_ ) { values . add Element ( s . read Object ( ) ) ; } }
private final String [ ] expand Seen Names ( String [ ] old Shared ) { int len = old Shared . length ; String [ ] new Shared ; if ( len == NUM_ ) { new Shared = smile Buffer Recycler . alloc Seen Names Buffer ( ) ; if ( new Shared == null ) { new Shared = new String [ Smile Buffer Recycler . DEFAULT NAME BUFFER LENGTH ] ; } } else if ( len == Smile Constants . MAX SHARED NAMES ) { new Shared = old Shared ; seen Name Count = NUM_ ; } else { int new Size = ( len == Smile Buffer Recycler . DEFAULT STRING VALUE BUFFER LENGTH ) ? NUM_ : Smile Constants . MAX SHARED NAMES ; new Shared = new String [ new Size ] ; System . arraycopy ( old Shared , NUM_ , new Shared , NUM_ , old Shared . length ) ; } return new Shared ; }
protected String format Date ( Date date , String format Key , int default Format ) { Locale locale = get Locale ( ) ; Date Format date Formatter ; String format String = get String ( format Key ) ; if ( String Utils . is Empty ( format String ) ) { date Formatter = Date Format . get Date Instance ( default Format , locale ) ; } else { date Formatter = new Simple Date Format ( format String , locale ) ; } return date Formatter . format ( date ) ; }
public static Runtime Exception approx Source Exception ( Node node , Throwable cause ) { final Stack Trace Element [ ] elements = approx Source Stack Trace Element ( node ) ; return create Bailout Exception ( cause == null ? STR_ : cause . get Message ( ) , cause , elements ) ; }
public static Array List < Stock > from Json ( JSON Array json Quotes ) throws JSON Exception { Array List < Stock > stocks = new Array List < Stock > ( ) ; for ( int i = NUM_ ; i < json Quotes . length ( ) ; i ++ ) { JSON Object json Quote Item = ( JSON Object ) json Quotes . get ( i ) ; stocks . add ( new Stock ( json Quote Item ) ) ; } return stocks ; }
private boolean install Vm Prereqs ( I Test Device device , Cts Build Helper cts Build ) throws Device Not Available Exception { cleanup Device Files ( device ) ; C Log . d ( STR_ ) ; create Remote Dir ( device , VM TEST TEMP DIR + STR_ ) ; try { File local Tmp Dir = File Util . create Temp Dir ( STR_ , new File ( STR_ ) ) ; C Log . d ( STR_ , local Tmp Dir . get Path ( ) ) ; File jar File = new File ( cts Build . get Test Cases Dir ( ) , get Jar File Name ( ) ) ; if ( ! jar File . exists ( ) ) { C Log . e ( STR_ , jar File . get Path ( ) ) ; return false ; } C Log . d ( STR_ , jar File . get Path ( ) , local Tmp Dir . get Path ( ) ) ; Zip File zip File = new Zip File ( jar File ) ; File Util . extract Zip ( zip File , local Tmp Dir ) ; File local Test Tmp Dir = new File ( local Tmp Dir , STR_ ) ; C Log . d ( STR_ , local Test Tmp Dir . get Path ( ) , VM TEST TEMP DIR ) ; if ( ! device . push Dir ( local Test Tmp Dir , VM TEST TEMP DIR ) ) { C Log . e ( STR_ ) ; return false ; } C Log . d ( STR_ , local Tmp Dir . get Path ( ) ) ; File Util . recursive Delete ( local Tmp Dir ) ; } catch ( IO Exception e ) { C Log . e ( STR_ , get Jar File Name ( ) , device . get Serial Number ( ) ) ; return false ; } return true ; }
protected void make Widgets ( ) { String loc Text ; Grid Bag Layout gridbag = new Grid Bag Layout ( ) ; Grid Bag Constraints c = new Grid Bag Constraints ( ) ; Insets left Insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; Insets center Insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; Insets right Insets = new Insets ( NUM_ , NUM_ , NUM_ , NUM_ ) ; set Layout ( gridbag ) ; loc Text = i 18 n . get ( UTM Coord Panel . class , STR_ , STR_ ) ; set Border ( new Titled Border ( new Etched Border ( ) , loc Text ) ) ; loc Text = i 18 n . get ( UTM Coord Panel . class , STR_ , STR_ ) ; J Label utm Label = new J Label ( loc Text ) ; c . gridx = NUM_ ; c . fill = Grid Bag Constraints . NONE ; c . weightx = NUM_ ; c . insets = left Insets ; c . anchor = Grid Bag Constraints . EAST ; gridbag . set Constraints ( utm Label , c ) ; add ( utm Label ) ; c . gridx = Grid Bag Constraints . RELATIVE ; zone Number = new J Text Field ( NUM_ ) ; zone Number . set Tool Tip Text ( i 18 n . get ( UTM Coord Panel . class , STR_ , I 18 n . TOOLTIP , STR_ ) ) ; c . insets = center Insets ; gridbag . set Constraints ( zone Number , c ) ; add ( zone Number ) ; zone Letter = new J Text Field ( NUM_ ) ; zone Letter . set Tool Tip Text ( i 18 n . get ( UTM Coord Panel . class , STR_ , I 18 n . TOOLTIP , STR_ ) ) ; gridbag . set Constraints ( zone Letter , c ) ; add ( zone Letter ) ; easting = new J Text Field ( NUM_ ) ; c . fill = Grid Bag Constraints . HORIZONTAL ; c . weightx = NUM_ ; gridbag . set Constraints ( easting , c ) ; add ( easting ) ; northing = new J Text Field ( NUM_ ) ; c . insets = right Insets ; gridbag . set Constraints ( northing , c ) ; add ( northing ) ; }
public static void register Context Menu Action ( Class < ? > associated Class , Selection Dependent Action action ) { List < Selection Dependent Action > actions = context Menu Actions . get ( associated Class ) ; if ( actions == null ) { actions = new Linked List < Selection Dependent Action > ( ) ; context Menu Actions . put ( associated Class , actions ) ; } actions . add ( action ) ; }
private boolean check Select For Swipe ( int action , Motion Event motion Event , int pointer Index ) { if ( m Selected != null || action != Motion Event . ACTION MOVE || m Action State == ACTION STATE DRAG || ! m Callback . is Item View Swipe Enabled ( ) ) { return false ; } if ( m Recycler View . get Scroll State ( ) == Recycler View . SCROLL STATE DRAGGING ) { return false ; } final View Holder vh = find Swiped View ( motion Event ) ; if ( vh == null ) { return false ; } final int movement Flags = m Callback . get Absolute Movement Flags ( m Recycler View , vh ) ; final int swipe Flags = ( movement Flags & ACTION MODE SWIPE MASK ) > > ( DIRECTION FLAG COUNT * ACTION STATE SWIPE ) ; if ( swipe Flags == NUM_ ) { return false ; } final float x = Motion Event Compat . get X ( motion Event , pointer Index ) ; final float y = Motion Event Compat . get Y ( motion Event , pointer Index ) ; final float dx = x - m Initial Touch X ; final float dy = y - m Initial Touch Y ; final float abs Dx = Math . abs ( dx ) ; final float abs Dy = Math . abs ( dy ) ; if ( abs Dx < m Slop && abs Dy < m Slop ) { return false ; } if ( abs Dx > abs Dy ) { if ( dx < NUM_ && ( swipe Flags & LEFT ) == NUM_ ) { return false ; } if ( dx > NUM_ && ( swipe Flags & RIGHT ) == NUM_ ) { return false ; } } else { if ( dy < NUM_ && ( swipe Flags & UP ) == NUM_ ) { return false ; } if ( dy > NUM_ && ( swipe Flags & DOWN ) == NUM_ ) { return false ; } } m Dx = m Dy = NUM_ ; m Active Pointer Id = Motion Event Compat . get Pointer Id ( motion Event , NUM_ ) ; select ( vh , ACTION STATE SWIPE ) ; return true ; }
public void update Last Commit Seqno ( Repl DBMS Header header , long applied Latency ) throws Replicator Exception { try { if ( low Seqno == Long . MIN VALUE ) { Repl DBMS Header low Header = last Commit Seqno ( ) ; if ( low Header == null ) low Seqno = - NUM_ ; else low Seqno = low Header . get Seqno ( ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + low Seqno ) ; } if ( header . get Seqno ( ) >= low Seqno ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + header . get Seqno ( ) ) ; commit Seqno Update . set Long ( NUM_ , header . get Seqno ( ) ) ; commit Seqno Update . set Short ( NUM_ , header . get Fragno ( ) ) ; commit Seqno Update . set Boolean ( NUM_ , header . get Last Frag ( ) ) ; commit Seqno Update . set String ( NUM_ , header . get Source Id ( ) ) ; commit Seqno Update . set Long ( NUM_ , header . get Epoch Number ( ) ) ; commit Seqno Update . set String ( NUM_ , header . get Event Id ( ) ) ; commit Seqno Update . set Long ( NUM_ , Math . max ( applied Latency , NUM_ ) ) ; commit Seqno Update . set Timestamp ( NUM_ , new Timestamp ( System . current Time Millis ( ) ) ) ; commit Seqno Update . set String ( NUM_ , header . get Shard Id ( ) ) ; commit Seqno Update . set Timestamp ( NUM_ , header . get Extracted Tstamp ( ) ) ; commit Seqno Update . set Int ( NUM_ , task Id ) ; commit Seqno Update . execute Update ( ) ; } else { if ( low Seqno Warning ) { if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + header . get Seqno ( ) + STR_ + low Seqno ) ; } else { logger . warn ( STR_ + header . get Seqno ( ) + STR_ + low Seqno ) ; low Seqno Warning = true ; } } } catch ( SQL Exception e ) { throw new Replicator Exception ( STR_ + e . get Message ( ) , e ) ; } }
public boolean is Login Timeout ( long last Callback Sent , long timeout ) { long now = current Time Millis ( ) ; long timeout Val = last Callback Sent + ( timeout - NUM_ ) * NUM_ ; return ( timeout Val < now ) ; }
private void persist Un Managed Volumes ( List < Un Managed Volume > un Managed Volumes To Create , List < Un Managed Volume > un Managed Volumes To Update , boolean flush ) { if ( null != un Managed Volumes To Create ) { if ( flush || ( un Managed Volumes To Create . size ( ) >= BATCH SIZE ) ) { partition Manager . insert In Batches ( un Managed Volumes To Create , BATCH SIZE , db Client , UNMANAGED VOLUME ) ; un Managed Volumes To Create . clear ( ) ; } } if ( null != un Managed Volumes To Update ) { if ( flush || ( un Managed Volumes To Update . size ( ) >= BATCH SIZE ) ) { partition Manager . update And Re Index In Batches ( un Managed Volumes To Update , BATCH SIZE , db Client , UNMANAGED VOLUME ) ; un Managed Volumes To Update . clear ( ) ; } } }
public void write ( CDATA cdata ) throws SAX Exception { String text = cdata . get Text ( ) ; if ( lexical Handler != null ) { lexical Handler . start CDATA ( ) ; write ( text ) ; lexical Handler . end CDATA ( ) ; } else { write ( text ) ; } }
public static String read Pem String From File ( File file ) { try { byte [ ] file Contents = File Utils . read File To Byte Array ( file ) ; return new String ( file Contents , Charset . for Name ( STR_ ) ) ; } catch ( IO Exception e ) { throw new Import Exception ( STR_ + file . get Name ( ) ) ; } }
public void register Save Participant ( ) throws Core Exception { I Workspace ws = Resources Plugin . get Workspace ( ) ; I Saved State ss = ws . add Save Participant ( SVN Provider Plugin . get Plugin ( ) , this ) ; if ( ss != null ) { ss . process Resource Change Events ( this ) ; } ws . remove Save Participant ( SVN Provider Plugin . get Plugin ( ) ) ; }
private void trigger Ip Lease Delete Service ( final State current , List < Dhcp Subnet Service . State > dhcp Subnet List ) { if ( dhcp Subnet List . size ( ) == NUM_ ) { Service Utils . log Info ( this , STR_ ) ; send Stage Progress Patch ( current ) ; return ; } for ( Dhcp Subnet Service . State state : dhcp Subnet List ) { trigger Ip Lease Delete Service ( Service Utils . get ID From Document Self Link ( state . document Self Link ) ) ; } send Stage Progress Patch ( current ) ; }
public Group Shards Iterator active Primary Shards Grouped ( String [ ] indices , boolean include Empty ) { Array List < Shard Iterator > set = new Array List < > ( ) ; for ( String index : indices ) { Index Routing Table index Routing Table = index ( index ) ; if ( index Routing Table == null ) { throw new Index Not Found Exception ( index ) ; } for ( Index Shard Routing Table index Shard Routing Table : index Routing Table ) { Shard Routing primary = index Shard Routing Table . primary Shard ( ) ; if ( primary . active ( ) ) { set . add ( primary . shards It ( ) ) ; } else if ( include Empty ) { set . add ( new Plain Shard Iterator ( primary . shard Id ( ) , Collections . < Shard Routing > empty List ( ) ) ) ; } } } return new Group Shards Iterator ( set ) ; }
public void instrument method ( Method m , Method Gen mg ) { Instruction List il = mg . get Instruction List ( ) ; for ( Instruction Handle ih = il . get Start ( ) ; ih != null ; ) { if ( debug instrument inst . enabled ( ) ) { debug instrument inst . log ( STR_ , ih ) ; } Instruction Handle next ih = ih . get Next ( ) ; Instruction List new il = xform inst ( mg , ih . get Instruction ( ) ) ; if ( debug instrument inst . enabled ( ) ) debug instrument inst . log ( STR_ , new il ) ; replace instructions ( il , ih , new il ) ; ih = next ih ; } }
public void save State ( Affine Transform at , Shape clip , Rectangle 2 D region , double sx , double sy ) { Graphics State gstate = new Graphics State ( ) ; gstate . the Transform = at ; gstate . the Clip = clip ; gstate . region = region ; gstate . sx = sx ; gstate . sy = sy ; redraw List . add ( gstate ) ; }
private static void build Module Instance Table ( SSO Token token , String realm ) { try { if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STR_ + STR_ + realm ) ; } for ( String service : MODULE SERVICE NAMES . values ( ) ) { build Module Instance For Service ( realm , service ) ; } } catch ( Exception e ) { if ( DEBUG . message Enabled ( ) ) { DEBUG . message ( STR_ , e ) ; } } }
public static String response ( final String c Question , final String c Title , final String c Default , final boolean b Password , final String c Label ) { final Border Layout layout = new Border Layout ( ) ; layout . set Hgap ( NUM_ ) ; final J Panel panel = new J Panel ( layout ) ; final J Label question = new J Label ( c Question ) ; final J Text Field field ; if ( b Password ) { field = new J Password Field ( ) ; } else { field = new J Text Field ( ) ; } if ( c Default != null ) { field . set Text ( c Default ) ; } final String title ; if ( c Title != null ) { title = c Title ; } else { title = STR_ ; } panel . add ( question , Border Layout . NORTH ) ; if ( c Label != null ) { final J Label label = new J Label ( c Label ) ; panel . add ( label , Border Layout . WEST ) ; } panel . add ( field , Border Layout . CENTER ) ; final String [ ] options = { STR_ , STR_ } ; final int option = J Option Pane . show Option Dialog ( null , panel , title , J Option Pane . NO OPTION , J Option Pane . PLAIN MESSAGE , null , options , options [ NUM_ ] ) ; if ( option == NUM_ ) { return field . get Text ( ) ; } else { return null ; } }
private int parse Current Number ( Byte Buf buffer ) { int number = NUM_ ; int reader Index = buffer . reader Index ( ) ; byte b = NUM_ ; while ( true ) { if ( ! buffer . is Readable ( ) ) return Integer . MIN VALUE ; b = buffer . read Byte ( ) ; if ( Character . is Digit ( b ) ) { number = number * NUM_ + ( int ) ( b - STR_ ) ; reader Index ++ ; } else { buffer . reader Index ( reader Index ) ; break ; } } return number ; }
private String apply Drunk Effect ( String text , int amount ) { amount = Math . max ( amount / NUM_ + NUM_ , amount * ( NUM_ + text . length ( ) ) / NUM_ ) ; String Builder b = new String Builder ( text ) ; while ( amount > NUM_ ) { switch ( Rand . rand ( NUM_ ) ) { case NUM_ : swap Letters ( b ) ; break ; case NUM_ : remove Letter ( b ) ; break ; case NUM_ : duplicate Letter ( b ) ; } amount -- ; } b . append ( STR_ ) ; return b . to String ( ) ; }
public void add Remote Entity Modifiers ( World world , int ent ID , String mods ) { Entity ent = world . get Entity By ID ( ent ID ) ; if ( ent != null ) { add Entity Modifiers By String ( ( Entity Living Base ) ent , mods ) ; } }
protected void rollback From Within Callback ( boolean indoubt , boolean heuristic ) throws Heur Commit Exception , Heur Mixed Exception , Sys Exception , Heur Hazard Exception , java . lang . Illegal State Exception { Coordinator State Handler next State Handler = null ; try { coordinator . set State ( Tx State . ABORTING ) ; committed = new Boolean ( false ) ; Vector < Participant > participants = coordinator . get Participants ( ) ; int count = ( participants . size ( ) - read Only Table . size ( ) ) ; Termination Result rollbackresult = new Termination Result ( count ) ; Enumeration < Participant > enumm = participants . elements ( ) ; while ( enumm . has More Elements ( ) ) { Participant p = enumm . next Element ( ) ; if ( ! read Only Table . contains ( p ) ) { Rollback Message rm = new Rollback Message ( p , rollbackresult , indoubt ) ; propagator . submit Propagation Message ( rm ) ; } } rollbackresult . wait For Replies ( ) ; int res = rollbackresult . get Result ( ) ; if ( indoubt && res != Termination Result . ALL OK ) { if ( res == Termination Result . HEUR MIXED ) { Set < Participant > hazards = rollbackresult . get Possibly Indoubts ( ) ; next State Handler = new Heur Mixed State Handler ( this , hazards ) ; coordinator . set State Handler ( next State Handler ) ; throw new Heur Mixed Exception ( ) ; } else if ( res == Termination Result . HEUR COMMIT ) { next State Handler = new Heur Committed State Handler ( this ) ; coordinator . set State Handler ( next State Handler ) ; throw new Heur Commit Exception ( ) ; } else if ( res == Termination Result . HEUR HAZARD ) { Set < Participant > hazards = rollbackresult . get Possibly Indoubts ( ) ; next State Handler = new Heur Hazard State Handler ( this , hazards ) ; coordinator . set State Handler ( next State Handler ) ; throw new Heur Hazard Exception ( ) ; } } else { if ( heuristic ) { next State Handler = new Heur Aborted State Handler ( this ) ; } else next State Handler = new Terminated State Handler ( this ) ; coordinator . set State Handler ( next State Handler ) ; } } catch ( Runtime Exception runerr ) { throw new Sys Exception ( STR_ + runerr . get Message ( ) , runerr ) ; } catch ( Interrupted Exception e ) { Interrupted Exception Helper . handle Interrupted Exception ( e ) ; throw new Sys Exception ( STR_ + e . get Message ( ) , e ) ; } }
protected static boolean is Object Class Present ( Set object Classes , String object Class ) { if ( object Classes != null && ! object Classes . is Empty ( ) ) { Iterator itr = object Classes . iterator ( ) ; while ( itr . has Next ( ) ) { String service OC = ( String ) itr . next ( ) ; if ( service OC . equals Ignore Case ( object Class ) ) { return true ; } } } return false ; }
public int hash ( final Currency c 1 , final Currency c 2 ) { return Math . min ( c 1 . numeric Code ( ) , c 2 . numeric Code ( ) ) * NUM_ + Math . max ( c 1 . numeric Code ( ) , c 2 . numeric Code ( ) ) ; }
@ Override public Expected Partition Values Information create Expected Partition Values ( Expected Partition Values Create Request expected Partition Values Create Request ) { validate Expected Partition Values Create Request ( expected Partition Values Create Request ) ; Partition Key Group Entity partition Key Group Entity = partition Key Group Dao Helper . get Partition Key Group Entity ( expected Partition Values Create Request . get Partition Key Group Key ( ) ) ; Map < String , Expected Partition Value Entity > expected Partition Value Entity Map = get Expected Partition Value Entity Map ( partition Key Group Entity . get Expected Partition Values ( ) ) ; for ( String expected Partition Value : expected Partition Values Create Request . get Expected Partition Values ( ) ) { if ( expected Partition Value Entity Map . contains Key ( expected Partition Value ) ) { throw new Illegal Argument Exception ( String . format ( STR_ , expected Partition Value , partition Key Group Entity . get Partition Key Group Name ( ) ) ) ; } } Collection < Expected Partition Value Entity > created Expected Partition Value Entities = new Array List < > ( ) ; for ( String expected Partition Value : expected Partition Values Create Request . get Expected Partition Values ( ) ) { Expected Partition Value Entity expected Partition Value Entity = new Expected Partition Value Entity ( ) ; created Expected Partition Value Entities . add ( expected Partition Value Entity ) ; expected Partition Value Entity . set Partition Key Group ( partition Key Group Entity ) ; expected Partition Value Entity . set Partition Value ( expected Partition Value ) ; expected Partition Value Dao . save And Refresh ( expected Partition Value Entity ) ; } expected Partition Value Dao . save And Refresh ( partition Key Group Entity ) ; return create Expected Partition Values Information From Entities ( partition Key Group Entity , created Expected Partition Value Entities ) ; }
private Replace Tokens create Hostname Token ( ) { Replace Tokens . Token token Hostname = new Replace Tokens . Token ( ) ; token Hostname . set Key ( General Property Set . HOSTNAME ) ; String hostname = get Property Value ( General Property Set . HOSTNAME ) ; if ( hostname == null ) { hostname = DEFAULT HOSTNAME ; } token Hostname . set Value ( hostname ) ; Replace Tokens replace Hostname = new Replace Tokens ( ) ; replace Hostname . add Configured Token ( token Hostname ) ; return replace Hostname ; }
protected void append Long String Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
protected Plugin Specification specify Plugin ( String prefix , String name ) throws Replicator Exception { String plugin Prefix = prefix + STR_ + name . trim ( ) ; String raw Class Name = properties . get String ( plugin Prefix ) ; if ( raw Class Name == null ) throw new Replicator Exception ( STR_ + plugin Prefix ) ; String plugin Class Name = raw Class Name . trim ( ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + plugin Prefix + STR_ + plugin Class Name ) ; Tungsten Properties plugin Properties = properties . subset ( plugin Prefix + STR_ , true ) ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + plugin Properties . to String ( ) ) ; Class < ? > plugin Class ; try { plugin Class = Plugin Loader . load Class ( plugin Class Name ) ; } catch ( Plugin Exception e ) { throw new Replicator Exception ( STR_ + plugin Prefix + STR_ + plugin Class Name , e ) ; } return new Plugin Specification ( plugin Prefix , name , plugin Class , plugin Properties ) ; }
public Data File Footer read Data File Footer ( String file Path , long block Offset , long block Length ) throws IO Exception { Data File Footer data File Footer = new Data File Footer ( ) ; File Holder file Reader = null ; try { long complete Block Length = block Offset + block Length ; long footer Pointer = complete Block Length - NUM_ ; file Reader = File Factory . get File Holder ( File Factory . get File Type ( file Path ) ) ; long actual Footer Offset = file Reader . read Long ( file Path , footer Pointer ) ; Carbon Footer Reader reader = new Carbon Footer Reader ( file Path , actual Footer Offset ) ; File Footer footer = reader . read Footer ( ) ; data File Footer . set Version Id ( footer . get Version ( ) ) ; data File Footer . set Number Of Rows ( footer . get Num rows ( ) ) ; data File Footer . set Segment Info ( get Segment Info ( footer . get Segment info ( ) ) ) ; List < Column Schema > column Schema List = new Array List < Column Schema > ( ) ; List < org . carbondata . format . Column Schema > table columns = footer . get Table columns ( ) ; for ( int i = NUM_ ; i < table columns . size ( ) ; i ++ ) { column Schema List . add ( thrift Column Schmea To Wrapper Column Schema ( table columns . get ( i ) ) ) ; } data File Footer . set Column In Table ( column Schema List ) ; List < org . carbondata . format . Blocklet Index > leaf node indices Thrift = footer . get Blocklet index list ( ) ; List < Blocklet Index > blocklet Index List = new Array List < Blocklet Index > ( ) ; for ( int i = NUM_ ; i < leaf node indices Thrift . size ( ) ; i ++ ) { Blocklet Index blocklet Index = get Blocklet Index ( leaf node indices Thrift . get ( i ) ) ; blocklet Index List . add ( blocklet Index ) ; } List < org . carbondata . format . Blocklet Info > leaf node infos Thrift = footer . get Blocklet info list ( ) ; List < Blocklet Info > blocklet Info List = new Array List < Blocklet Info > ( ) ; for ( int i = NUM_ ; i < leaf node infos Thrift . size ( ) ; i ++ ) { Blocklet Info blocklet Info = get Blocklet Info ( leaf node infos Thrift . get ( i ) ) ; blocklet Info . set Blocklet Index ( blocklet Index List . get ( i ) ) ; blocklet Info List . add ( blocklet Info ) ; } data File Footer . set Blocklet List ( blocklet Info List ) ; data File Footer . set Blocklet Index ( get Blocklet Index For Data File Footer ( blocklet Index List ) ) ; } finally { if ( null != file Reader ) { file Reader . finish ( ) ; } } return data File Footer ; }
protected void process Node And Observe ( Node node ) { if ( is Parent ( node ) ) { Parent parent = ( Parent ) node ; final Observable List < Node > children = parent . get Children Unmodifiable ( ) ; for ( int i = NUM_ ; i < children . size ( ) ; i ++ ) { Node child = children . get ( i ) ; process Node And Observe ( child ) ; } final List Change Listener < Node > children List Change Listener = ( List Change Listener < Node > ) null ; listeners . add ( children List Change Listener ) ; children . add Listener ( new Weak List Change Listener < Node > ( children List Change Listener ) ) ; } register Leak Detection ( node ) ; }
public Int Pointer ( String s ) { this ( s . length ( ) + NUM_ ) ; put String ( s ) ; }
public static Tree from String ( String ptb Str ) { Penn Tree Reader reader = new Penn Tree Reader ( new String Reader ( ptb Str ) ) ; return reader . next ( ) ; }
void destruct ( ) { lock . lock ( ) ; try { for ( long n = head , prev = NUM_ ; n != NUM_ ; prev = n , n = next ( n ) ) mem . release System ( prev , NODE ) ; } finally { lock . unlock ( ) ; } }
public static void add Record ( Object target , long dispose Method , long p Data ) { disposer Instance . add ( target , new Default Disposer Record ( dispose Method , p Data ) ) ; }
public void register Push Token ( String token ) { push Token = token ; if ( instances . size ( ) > NUM_ ) { register Push Services ( ) ; } }
private Event Node read ( ) throws Exception { XML Event event = reader . next Event ( ) ; if ( ! event . is End Document ( ) ) { if ( event . is Start Element ( ) ) { return start ( event ) ; } if ( event . is Characters ( ) ) { return text ( event ) ; } if ( event . is End Element ( ) ) { return end ( ) ; } return read ( ) ; } return null ; }
public static void main ( String [ ] args ) { if ( args . length != NUM_ ) { throw new Runtime Exception ( STR_ ) ; } File configuration = new File ( args [ NUM_ ] ) ; if ( configuration . is Directory ( ) || ! configuration . exists ( ) ) { throw new Runtime Exception ( STR_ + configuration . get Absolute Path ( ) + STR_ + STR_ ) ; } Input Stream is = null ; try { is = new File Input Stream ( configuration ) ; Properties props = new Properties ( ) ; props . load ( is ) ; String server = props . get Property ( STR_ ) ; String from = props . get Property ( STR_ ) ; String subject = props . get Property ( STR_ ) ; String mime Type = props . get Property ( STR_ ) ; String reply To = props . get Property ( STR_ ) ; String template Name = props . get Property ( STR_ ) ; String recipients File Name = props . get Property ( STR_ ) ; String template = get Template ( template Name ) ; send Mails ( server , from , recipients File Name , reply To , subject , mime Type , template ) ; } catch ( Api Exception | IO Exception | Messaging Exception | Interrupted Exception e ) { LOG . error ( STR_ , e . get Localized Message ( ) , e ) ; throw new Runtime Exception ( e . get Localized Message ( ) , e ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( IO Exception e ) { LOG . error ( STR_ , e . get Localized Message ( ) , e ) ; throw new Runtime Exception ( e . get Localized Message ( ) , e ) ; } } } }
public List Iterator < Variable Map Element > iterator ( ) { return list . list Iterator ( NUM_ ) ; }
public Connection Quality register ( Connection Class State Change Listener listener ) { if ( listener != null ) { m Listener List . add ( listener ) ; } return m Current Bandwidth Connection Quality . get ( ) ; }
public Key Uri ( String uri , byte [ ] address , int port ) { if ( uri == null ) { throw new Null Pointer Exception ( STR_ ) ; } else if ( address == null ) { throw new Null Pointer Exception ( STR_ ) ; } else if ( port < NUM_ || port > MAX PORT NO ) { throw new Illegal Argument Exception ( STR_ ) ; } else { this . uri = uri ; this . address = address ; this . port = port ; this . hash = ( port * NUM_ + uri . hash Code ( ) ) * NUM_ + Arrays . hash Code ( address ) ; } }
private void draw Anno Drag Indicators ( final Graphics 2 D g , final Workflow Annotation anno , final Rectangle 2 D loc , final boolean printing ) { if ( printing ) { return ; } Annotation Drag Helper dragged = model . get Dragged ( ) ; if ( dragged . get Hovered Operator ( ) == null ) { return ; } Graphics 2 D g 2 = ( Graphics 2 D ) g . create ( ) ; int padding = NUM_ ; Rectangle 2 D op Rect = renderer Model . get Operator Rect ( dragged . get Hovered Operator ( ) ) ; op Rect = new Rectangle 2 D . Double ( op Rect . get X ( ) , op Rect . get Y ( ) , op Rect . get Width ( ) , op Rect . get Height ( ) ) ; Rectangle 2 D shadow Rect = new Rectangle 2 D . Double ( op Rect . get X ( ) - padding - NUM_ , op Rect . get Y ( ) - padding - NUM_ , op Rect . get Width ( ) + NUM_ * padding + NUM_ , op Rect . get Height ( ) + NUM_ * padding + NUM_ ) ; g 2 . set Color ( DRAG LINK COLOR ) ; g 2 . set Stroke ( DRAG BORDER STROKE ) ; g 2 . draw ( shadow Rect ) ; g 2 . dispose ( ) ; }
public static String force To String ( Object o ) { try { return object To String ( o , true , MAX ARRAY ELEMENTS TO CONVERT ) ; } catch ( Runtime Exception ex ) { return STR_ + ex ; } }
public void start ( int total Seeds , int max NFE , long max Time ) { this . total Seeds = total Seeds ; this . max NFE = max NFE ; this . max Time = max Time ; last Seed = NUM_ ; last NFE = NUM_ ; current Seed = NUM_ ; current NFE = NUM_ ; statistics . clear ( ) ; start Time = System . current Time Millis ( ) ; last Time = start Time ; }
@ Override public String generate Device Specific Export Mask Add Initiators Workflow ( Workflow workflow , String zoning Group Id , Storage System storage , Export Group export Group , Export Mask mask , List < URI > volumes , List < URI > new Initiators , String token ) throws Exception { Set < URI > volume UR Is = new Hash Set < URI > ( ) ; if ( volumes != null ) { volume UR Is . add All ( volumes ) ; } return generate Export Mask Add Initiators Workflow ( workflow , null , storage , export Group , mask , new Initiators , volume UR Is , token ) ; }
public static boolean check Valid Keys ( JSON Object jo , Fields fields ) { @ Suppress Warnings ( STR_ ) Set < String > field Set = fields . get Fields ( ) ; Set < String > json Keys = get Set Of JSON Keys ( jo ) ; return json Keys . contains All ( field Set ) ; }
private double unstandardized ( double [ ] [ ] samples , int N ) { final int k = samples . length ; final double [ ] combined = new double [ N ] ; { int p = NUM_ ; for ( double [ ] samp : samples ) { Arrays . sort ( samp ) ; System . arraycopy ( samp , NUM_ , combined , p , samp . length ) ; p += samp . length ; } assert ( p == N ) ; } Arrays . sort ( combined ) ; int [ ] m = new int [ k ] ; double [ ] Ak = new double [ k ] ; for ( int j = NUM_ ; j < N ; ) { final double x = combined [ j ++ ] ; int lj = NUM_ ; while ( j < N && combined [ j ] == x ) { ++ j ; ++ lj ; } for ( int i = NUM_ ; i < k ; i ++ ) { final double [ ] sam = samples [ i ] ; int mi = m [ i ] ; assert ( mi >= sam . length || sam [ mi ] >= x ) ; int fi = NUM_ ; while ( mi < sam . length && sam [ mi ] == x ) { ++ mi ; ++ fi ; } if ( fi > NUM_ ) { assert ( m [ i ] + fi == mi ) ; m [ i ] = mi ; } double bi = j - NUM_ * lj ; double v = N * ( mi - NUM_ * fi ) - sam . length * bi ; Ak [ i ] += lj * v * v / ( bi * ( N - bi ) - NUM_ * N * lj ) ; } } double A 2 = NUM_ ; for ( int j = NUM_ ; j < k ; j ++ ) { A 2 += Ak [ j ] / samples [ j ] . length ; } A 2 *= ( N - NUM_ ) / ( N * N ) ; return A 2 ; }
public static boolean verify File Existence ( String path ) { File file = new File ( path ) ; return file . exists ( ) && file . is File ( ) ; }
public void load Attachments ( ) { log . fine ( STR_ + m vo . Tab No ) ; if ( ! can Have Attachment ( ) ) return ; String SQL = STR_ + STR_ ; try { if ( m Attachments == null ) m Attachments = new Hash Map < Integer , Integer > ( ) ; else m Attachments . clear ( ) ; Prepared Statement pstmt = DB . prepare Statement ( SQL , null ) ; pstmt . set Int ( NUM_ , m vo . AD Table ID ) ; Result Set rs = pstmt . execute Query ( ) ; while ( rs . next ( ) ) { Integer key = new Integer ( rs . get Int ( NUM_ ) ) ; Integer value = new Integer ( rs . get Int ( NUM_ ) ) ; m Attachments . put ( key , value ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , STR_ , e ) ; } log . config ( STR_ + m Attachments . size ( ) ) ; }
public static final void exception ( String message , Throwable e ) { if ( message == null && e != null ) { message = e . get Message ( ) ; } log Expensive ( Level . SEVERE , message , e ) ; }
public static Predicate < Api Filter > is Non Aggregatable In Filter ( ) { return null ; }
public void run ( ) { try { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ ) ; } String ret Value = command Runner . run Command ( source Command Tag Value ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ ) ; } synchronized ( command Exec Lock ) { this . return Value = ret Value ; cmd Execution Status = STATUS OK ; command Exec Lock . notify All ( ) ; } } catch ( Eq Command Tag Exception ex 1 ) { logger . error ( STR_ + ex 1 . get Error Description ( ) ) ; synchronized ( command Exec Lock ) { cmd Execution Status = STATUS NOK FROM EQUIPMENTD ; cmd Execution Description = ex 1 . get Error Description ( ) ; } } catch ( Exception ex 2 ) { logger . error ( STR_ + ex 2 . get Message ( ) ) ; synchronized ( command Exec Lock ) { cmd Execution Status = STATUS NOK FROM EQUIPMENTD ; cmd Execution Description = ex 2 . get Message ( ) ; } } }
private static Api Usage of ( List < IN 4 JS Project > projects , Map < IN 4 JS Project , IN 4 JS Project > concrete Api Impl Project Mapping , Api Impl Mapping api Impl Mapping ) { return new Api Usage ( null , projects , concrete Api Impl Project Mapping , api Impl Mapping , Collections . empty List ( ) , false ) ; }
static Collection < Element > create Parent Elements ( Path path , Element root Element , Element Metadata < ? , ? > root Metadata , int element Count ) throws Parse Exception { Preconditions . check Not Null ( path , STR_ ) ; Preconditions . check Not Null ( root Element , STR_ ) ; List < Metadata Key < ? > > steps = path . get Steps ( ) ; if ( steps . is Empty ( ) ) { return Immutable List . of ( ) ; } Element parent = root Element ; List < Element > parents = null ; Element Metadata < ? , ? > parent Metadata = root Metadata ; for ( int i = NUM_ ; i < steps . size ( ) - NUM_ ; i ++ ) { Element Key < ? , ? > child Key = ( Element Key < ? , ? > ) steps . get ( i ) ; Element Metadata < ? , ? > child Metadata = ( parent Metadata == null ) ? null : parent Metadata . bind Element ( child Key ) ; if ( parents != null ) { check Not Multiple ( child Metadata ) ; List < Element > children = Lists . new Array List With Capacity ( parents . size ( ) ) ; for ( Element p : parents ) { children . add ( get Or Create Child ( p , child Key ) ) ; } parents = children ; parent Metadata = child Metadata ; continue ; } if ( child Metadata == null || child Metadata . get Cardinality ( ) == Cardinality . SINGLE ) { Element child = get Or Create Child ( parent , child Key ) ; parent = child ; parent Metadata = child Metadata ; continue ; } List < Element > children = Lists . new Array List With Capacity ( element Count ) ; for ( int j = NUM_ ; j < element Count ; j ++ ) { try { Element child = Element . create Element ( child Key ) ; parent . add Element ( child ) ; children . add ( child ) ; } catch ( Content Creation Exception e ) { throw new Parse Exception ( e ) ; } } parents = children ; parent Metadata = child Metadata ; } if ( parents != null ) { return parents ; } return Immutable List . of ( parent ) ; }
public Live Ref ( Obj ID obj ID , int port ) { this ( obj ID , TCP Endpoint . get Local Endpoint ( port ) , true ) ; }
private static List < Path > file listing ( Path dir ) throws IO Exception { try ( Stream < Path > files = Files . list ( dir ) ) { return files . collect ( Collectors . to List ( ) ) ; } }
protected Shape Tile offset shape ( Polyline p polyline , int p half width , int p no ) { return p polyline . offset shape ( p half width , p no ) ; }
public void add Name ( String type , String name ) { if ( contains Name ( type , name ) ) { return ; } List < Car Load > loads = list Car Loads . get ( type ) ; if ( loads == null ) { log . debug ( STR_ , type ) ; return ; } loads . add ( NUM_ , new Car Load ( name ) ) ; max Name Length = NUM_ ; set Dirty And Fire Property Change ( LOAD CHANGED PROPERTY , null , name ) ; }
private void display Popup Menu ( final Mouse Event event ) { final int selected Index = m table . row At Point ( event . get Point ( ) ) ; if ( selected Index != - NUM_ ) { final C Cross Reference reference = m cross References . get ( selected Index ) ; final C Cross References Table Menu popup Menu = new C Cross References Table Menu ( m parent , m view Container , reference . get Calling Function ( ) ) ; popup Menu . show ( m table , event . get X ( ) , event . get Y ( ) ) ; } }
public static String to Type Desc ( Soot Method Ref m ) { String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; for ( Type t : m . parameter Types ( ) ) { sb . append ( to Type Desc ( t ) ) ; } sb . append ( STR_ ) ; sb . append ( to Type Desc ( m . return Type ( ) ) ) ; return sb . to String ( ) ; }
public void register High Pressure Biome ( Biome Gen Base biome ) { registered High Pressure Biomes . add ( biome ) ; register Black List Biome ( biome ) ; }
protected void revert Setting ( String key ) { Key Panel kp = key Panels . get ( key ) ; kp . set Value ( get Setting ( key ) ) ; }
public static void collect Imports ( final I Java Project project , final AST Node node , final Collection < I Type Binding > type Bindings , final Collection < I Binding > static Bindings , final Collection < I Binding > exclude Bindings , final boolean declarations ) { Assert . is Not Null ( project ) ; Assert . is Not Null ( node ) ; Assert . is Not Null ( type Bindings ) ; Assert . is Not Null ( static Bindings ) ; final Set < Simple Name > types = new Hash Set < Simple Name > ( ) ; final Set < Simple Name > members = new Hash Set < Simple Name > ( ) ; Import References Collector . collect ( node , project , null , declarations , types , members ) ; Name name = null ; I Binding binding = null ; for ( final Iterator < Simple Name > iterator = types . iterator ( ) ; iterator . has Next ( ) ; ) { name = iterator . next ( ) ; binding = name . resolve Binding ( ) ; if ( binding instanceof I Type Binding ) { final I Type Binding type = ( I Type Binding ) binding ; if ( exclude Bindings == null || ! exclude Bindings . contains ( type ) ) type Bindings . add ( type ) ; } } for ( final Iterator < Simple Name > iterator = members . iterator ( ) ; iterator . has Next ( ) ; ) { name = iterator . next ( ) ; binding = name . resolve Binding ( ) ; if ( binding != null && ( exclude Bindings == null || ! exclude Bindings . contains ( binding ) ) ) static Bindings . add ( binding ) ; } }
public Earning ( final Integer value , final String seller Name , final boolean should Reward ) { super ( ) ; set RP Class ( EARNING RPCLASS NAME ) ; hide ( ) ; put ( VALUE ATTRIBUTE , value ) ; this . value = value ; this . seller Name = seller Name ; put ( NAME ATTRIBUTE , seller Name ) ; put ( REWARD ATTRIBUTE , should Reward ? NUM_ : NUM_ ) ; put ( TIMESTAMP ATTRIBUTE , Long . to String ( System . current Time Millis ( ) ) ) ; }
public int hash Code ( ) { int retval = crypto Permission . hash Code ( ) ; if ( alg != null ) retval ^= alg . hash Code ( ) ; if ( exemption Mechanism != null ) { retval ^= exemption Mechanism . hash Code ( ) ; } retval ^= max Key Size ; if ( check Param ) retval ^= NUM_ ; if ( alg Param Spec != null ) { retval ^= alg Param Spec . hash Code ( ) ; } return retval ; }
protected Date compute ( String date String , String pattern String , String locale String ) { if ( date String == null || pattern String == null || locale String == null ) { return null ; } Locale locale = new Locale ( locale String ) ; Simple Date Format simple Date Formatter = null ; Date parsed Date = null ; try { simple Date Formatter = new Simple Date Format ( pattern String , locale ) ; parsed Date = simple Date Formatter . parse ( date String ) ; } catch ( Illegal Argument Exception e ) { throw new Function Input Exception ( STR_ , get Function Name ( ) ) ; } catch ( java . text . Parse Exception e ) { throw new Function Input Exception ( STR_ , get Function Name ( ) ) ; } Calendar cal = Calendar . get Instance ( locale ) ; cal . set Time ( parsed Date ) ; return cal . get Time ( ) ; }
@ Override protected void process Component Key Event ( final Key Event e ) { if ( e . get Key Code ( ) == Key Event . VK SPACE || e . get Key Code ( ) == Key Event . VK ENTER ) { e . consume ( ) ; notify Action Listeners ( ) ; } }
@ Override public List < byte [ ] > row Keys ( String profile , String entity , List < Object > groups , long start , long end ) { List < byte [ ] > row Keys = new Array List < > ( ) ; end = Math . max ( start , end ) ; start = Math . min ( start , end ) ; Profile Period period = new Profile Period ( start , period Duration Millis , Time Unit . MILLISECONDS ) ; while ( period . get Start Time Millis ( ) <= end ) { byte [ ] k = row Key ( profile , entity , period , groups ) ; row Keys . add ( k ) ; period = period . next ( ) ; } return row Keys ; }
public static < K , V > Map < K , V > make Immutable ( Map < K , V > mutable Map ) { Map < K , V > new Map = new Hash Map < > ( ) ; for ( Map . Entry < K , V > entry : mutable Map . entry Set ( ) ) { new Map . put ( entry . get Key ( ) , Utils . make Immutable ( entry . get Value ( ) ) ) ; } return Collections . unmodifiable Map ( new Map ) ; }
Resource Thread ( String image Url , Component img Label , HTML Component html C , Resource Thread Queue thread Queue ) { this . image Url = image Url ; this . img Label = img Label ; this . handler = html C . get Request Handler ( ) ; this . thread Queue = thread Queue ; this . html C = html C ; }
public Atomic Long read ( String value ) { Long number = Long . value Of ( value ) ; return new Atomic Long ( number ) ; }
public void select Next Overlay ( ) { if ( m Current Overlay Index == NO OVERLAY ) { if ( m Overlays . is Empty ( ) ) { return ; } m Current Overlay Index = NUM_ ; } else { m Current Overlay Index = ++ m Current Overlay Index % m Overlays . size ( ) ; if ( m Current Overlay Index == NUM_ ) { m Current Overlay Index = NO OVERLAY ; } } do Set Overlay ( get Current Overlay ( ) ) ; }
protected double compute Random Projection ( int rp Index , int class Index , Instance instance ) { double sum = NUM_ ; for ( int i = NUM_ ; i < instance . num Values ( ) ; i ++ ) { int index = instance . index ( i ) ; if ( index != class Index ) { double value = instance . value Sparse ( i ) ; if ( ! Utils . is Missing Value ( value ) ) { sum += m rmatrix [ rp Index ] [ index ] * value ; } } } return sum ; }
public static void h block filter ( Mpeg Enc Context s , int [ ] dst base , int dst offset , int w , int h , int stride , int is luma ) { int b x , b y , mvx stride , mvy stride ; int [ ] cm base = H 264 DSP Context . ff crop Tbl ; int cm offset = H 264 DSP Context . MAX NEG CROP ; int [ ] param = new int [ NUM_ ] ; set mv strides ( s , param ) ; mvx stride = param [ NUM_ ] ; mvy stride = param [ NUM_ ] ; mvx stride >>= is luma ; mvy stride *= mvx stride ; for ( b y = NUM_ ; b y < h ; b y ++ ) { for ( b x = NUM_ ; b x < w - NUM_ ; b x ++ ) { int y ; int left status = s . error status table [ ( b x > > is luma ) + ( b y > > is luma ) * s . mb stride ] ; int right status = s . error status table [ ( ( b x + NUM_ ) > > is luma ) + ( b y > > is luma ) * s . mb stride ] ; int left intra = NUM_ & ( int ) ( s . current picture . mb type base [ s . current picture . mb type offset + ( b x > > is luma ) + ( b y > > is luma ) * s . mb stride ] ) ; int right intra = NUM_ & ( int ) ( s . current picture . mb type base [ s . current picture . mb type offset + ( ( b x + NUM_ ) > > is luma ) + ( b y > > is luma ) * s . mb stride ] ) ; int left damage = left status & ( Mpeg Enc Context . DC ERROR | Mpeg Enc Context . AC ERROR | Mpeg Enc Context . MV ERROR ) ; int right damage = right status & ( Mpeg Enc Context . DC ERROR | Mpeg Enc Context . AC ERROR | Mpeg Enc Context . MV ERROR ) ; int offset = b x * NUM_ + b y * stride * NUM_ ; int [ ] left mv = s . current picture . motion val base [ NUM_ ] [ s . current picture . motion val offset [ NUM_ ] + mvy stride * b y + mvx stride * b x ] ; int [ ] right mv = s . current picture . motion val base [ NUM_ ] [ s . current picture . motion val offset [ NUM_ ] + mvy stride * b y + mvx stride * ( b x + NUM_ ) ] ; if ( ! ( left damage != NUM_ || right damage != NUM_ ) ) continue ; if ( ( NUM_ == left intra ) && ( NUM_ == right intra ) && Math . abs ( left mv [ NUM_ ] - right mv [ NUM_ ] ) + Math . abs ( left mv [ NUM_ ] + right mv [ NUM_ ] ) < NUM_ ) continue ; for ( y = NUM_ ; y < NUM_ ; y ++ ) { int a , b , c , d ; a = dst base [ dst offset + offset + NUM_ + y * stride ] - dst base [ dst offset + offset + NUM_ + y * stride ] ; b = dst base [ dst offset + offset + NUM_ + y * stride ] - dst base [ dst offset + offset + NUM_ + y * stride ] ; c = dst base [ dst offset + offset + NUM_ + y * stride ] - dst base [ dst offset + offset + NUM_ + y * stride ] ; d = Math . abs ( b ) - ( ( Math . abs ( a ) + Math . abs ( c ) + NUM_ ) > > NUM_ ) ; d = Math . max ( d , NUM_ ) ; if ( b < NUM_ ) d = - d ; if ( d == NUM_ ) continue ; if ( ! ( left damage != NUM_ && right damage != NUM_ ) ) d = d * NUM_ / NUM_ ; if ( left damage != NUM_ ) { dst base [ dst offset + offset + NUM_ + y * stride ] = cm base [ cm offset + dst base [ dst offset + offset + NUM_ + y * stride ] + ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + NUM_ + y * stride ] = cm base [ cm offset + dst base [ dst offset + offset + NUM_ + y * stride ] + ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + NUM_ + y * stride ] = cm base [ cm offset + dst base [ dst offset + offset + NUM_ + y * stride ] + ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + NUM_ + y * stride ] = cm base [ cm offset + dst base [ dst offset + offset + NUM_ + y * stride ] + ( ( d * NUM_ ) > > NUM_ ) ] ; } if ( right damage != NUM_ ) { dst base [ dst offset + offset + NUM_ + y * stride ] = cm base [ cm offset + dst base [ dst offset + offset + NUM_ + y * stride ] - ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + NUM_ + y * stride ] = cm base [ cm offset + dst base [ dst offset + offset + NUM_ + y * stride ] - ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + NUM_ + y * stride ] = cm base [ cm offset + dst base [ dst offset + offset + NUM_ + y * stride ] - ( ( d * NUM_ ) > > NUM_ ) ] ; dst base [ dst offset + offset + NUM_ + y * stride ] = cm base [ cm offset + dst base [ dst offset + offset + NUM_ + y * stride ] - ( ( d * NUM_ ) > > NUM_ ) ] ; } } } } }
public void hide Table Item Control Decoration ( Table Viewer table Viewer , Object data ) { if ( null == table Viewer ) { return ; } for ( Table Item Control Decoration decoration : table Item Control Decorations ) { if ( data == decoration . get Data ( ) ) { decoration . hide ( ) ; return ; } } }
public String to Xml Error Message ( boolean include Debug Info ) { String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; for ( Service Exception sibling : siblings ) { add Xml Error ( sibling , sb , include Debug Info ) ; } sb . append ( STR_ ) ; return sb . to String ( ) ; }
public Maxwell Triangle ( ) { Byte Buffer vbb = Byte Buffer . allocate Direct ( triangle Coords . length * NUM_ ) ; vbb . order ( Byte Order . native Order ( ) ) ; vertex Buffer = vbb . as Float Buffer ( ) ; vertex Buffer . put ( triangle Coords ) ; vertex Buffer . position ( NUM_ ) ; Byte Buffer cbb = Byte Buffer . allocate Direct ( colors . length * NUM_ ) ; cbb . order ( Byte Order . native Order ( ) ) ; color Buffer = cbb . as Float Buffer ( ) ; color Buffer . put ( colors ) ; color Buffer . position ( NUM_ ) ; index Buffer = Byte Buffer . allocate Direct ( indices . length ) ; index Buffer . order ( Byte Order . native Order ( ) ) ; index Buffer . put ( indices ) ; index Buffer . position ( NUM_ ) ; }
protected String generate Samples Info Text ( String container Id ) throws Exception { String url = get Container Server Download Url ( container Id ) ; if ( url != null ) { String Builder output = new String Builder ( ) ; output . append ( STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ + STR_ + STR_ ) ; output . append ( LINE SEPARATOR ) ; output . append ( STR_ ) ; output . append ( url ) ; output . append ( LINE SEPARATOR ) ; output . append ( LINE SEPARATOR ) ; return output . to String ( ) ; } else { return STR_ ; } }
private byte [ ] create Segment Table ( int new Comment Length , int setup Header Length , List < Ogg Page Header . Packet Start And Length > extra Packets ) { logger . finest ( STR_ + new Comment Length + STR_ + setup Header Length ) ; Byte Array Output Stream result Baos = new Byte Array Output Stream ( ) ; byte [ ] new Start ; byte [ ] rest Should Be ; byte [ ] next Packet ; if ( setup Header Length == NUM_ ) { new Start = create Segments ( new Comment Length , false ) ; return new Start ; } else { new Start = create Segments ( new Comment Length , true ) ; } if ( extra Packets . size ( ) > NUM_ ) { rest Should Be = create Segments ( setup Header Length , true ) ; } else { rest Should Be = create Segments ( setup Header Length , false ) ; } logger . finest ( STR_ + new Start . length + STR_ ) ; logger . finest ( STR_ + rest Should Be . length + STR_ ) ; try { result Baos . write ( new Start ) ; result Baos . write ( rest Should Be ) ; if ( extra Packets . size ( ) > NUM_ ) { logger . finer ( STR_ + extra Packets . size ( ) + STR_ ) ; for ( Ogg Page Header . Packet Start And Length packet : extra Packets ) { next Packet = create Segments ( packet . get Length ( ) , false ) ; result Baos . write ( next Packet ) ; } } } catch ( IO Exception ioe ) { throw new Runtime Exception ( STR_ + ioe . get Message ( ) ) ; } return result Baos . to Byte Array ( ) ; }
private void update Search Style ( J Text Component c , Sea Glass Context context , String prefix ) { search Icon Width = NUM_ ; Object o = style . get ( context , prefix + STR_ ) ; if ( o != null && o instanceof Integer ) { search Icon Width = ( Integer ) o ; } popup Icon Width = NUM_ ; o = style . get ( context , prefix + STR_ ) ; if ( o != null && o instanceof Integer ) { popup Icon Width = ( Integer ) o ; } cancel Icon Width = NUM_ ; o = style . get ( context , prefix + STR_ ) ; if ( o != null && o instanceof Integer ) { cancel Icon Width = ( Integer ) o ; } search Left Inner Margin = NUM_ ; o = style . get ( context , prefix + STR_ ) ; if ( o != null && o instanceof Integer ) { search Left Inner Margin = ( Integer ) o ; } search Right Inner Margin = NUM_ ; o = style . get ( context , prefix + STR_ ) ; if ( o != null && o instanceof Integer ) { search Right Inner Margin = ( Integer ) o ; } placeholder Color = Color . GRAY ; o = style . get ( context , STR_ ) ; if ( o != null && o instanceof Color ) { placeholder Color = ( Color ) o ; } Border border = c . get Border ( ) ; if ( border == null || border instanceof UI Resource && ! ( border instanceof Text Field Border ) ) { c . set Border ( create Text Field Border ( context ) ) ; } if ( is Search Field . is In State ( c ) ) { o = c . get Client Property ( STR_ ) ; if ( o != null && o instanceof String ) { placeholder Text = ( String ) o ; } else if ( placeholder Text != null ) { placeholder Text = null ; } o = c . get Client Property ( STR_ ) ; if ( o != null && o instanceof Action Listener ) { if ( find Action == null ) { find Action = ( Action Listener ) o ; } } o = c . get Client Property ( STR_ ) ; if ( o != null && o instanceof J Popup Menu ) { if ( find Popup == null ) { find Popup = ( J Popup Menu ) o ; } } o = c . get Client Property ( STR_ ) ; if ( o != null && o instanceof Action Listener ) { if ( cancel Action == null ) { cancel Action = ( Action Listener ) o ; } } install Mouse Listeners ( ) ; } else { placeholder Text = null ; if ( find Action != null ) { find Action = null ; } if ( find Popup != null ) { find Popup = null ; } if ( cancel Action != null ) { cancel Action = null ; } uninstall Mouse Listeners ( ) ; } }
static String gen Access ( String tbl , String var , int bits ) { String access = null ; int bitoffset = bits == NUM_ ? NUM_ : bits == NUM_ ? NUM_ : bits == NUM_ ? NUM_ : NUM_ ; for ( int k = NUM_ ; k < sizes . length ; k ++ ) { int offset = ( ( k < sizes . length - NUM_ ) ? NUM_ : bitoffset ) ; int shift = shifts [ k ] + offset ; String shifted = ( shift == NUM_ ) ? var : STR_ + var + STR_ + shift + STR_ ; int mask = ( NUM_ << ( sizes [ k ] - offset ) ) - NUM_ ; String masked = ( k == NUM_ ) ? shifted : STR_ + shifted + STR_ + hex ( mask ) + STR_ ; String index = ( k == NUM_ ) ? masked : ( mask == NUM_ ) ? access : STR_ + access + STR_ + masked + STR_ ; String index No Parens = ( index . char At ( NUM_ ) != STR_ ) ? index : index . substring ( NUM_ , index . length ( ) - NUM_ ) ; String tblname = ( k == sizes . length - NUM_ ) ? tbl : table Name ( k ) ; String fetched = tblname + STR_ + index No Parens + STR_ ; String zeroextended = ( zeroextend [ k ] == NUM_ ) ? fetched : STR_ + fetched + STR_ + hex ( zeroextend [ k ] ) + STR_ ; int adjustment = preshifted [ k ] ? NUM_ : sizes [ k + NUM_ ] - ( ( k == sizes . length - NUM_ ) ? bitoffset : NUM_ ) ; String adjusted = ( preshifted [ k ] || adjustment == NUM_ ) ? zeroextended : STR_ + zeroextended + STR_ + adjustment + STR_ ; String bitshift = ( bits == NUM_ ) ? STR_ + var + STR_ : ( bits == NUM_ ) ? STR_ + var + STR_ : ( bits == NUM_ ) ? STR_ + var + STR_ : null ; String extracted = ( ( k < sizes . length - NUM_ ) || ( bits >= NUM_ ) ) ? adjusted : STR_ + adjusted + STR_ + bitshift + STR_ + ( bits == NUM_ ? STR_ : STR_ + ( ( NUM_ << bits ) - NUM_ ) ) + STR_ ; access = extracted ; } return access ; }
public void accept Field Entry ( Render Field Entry field Entry ) { field Entries . add ( field Entry ) ; }
private Double interpolate ( Number av 1 , Number av 2 , int year 1 , int year 2 , int now ) { if ( av 1 == null && av 2 == null ) { return null ; } if ( av 1 == null ) { av 1 = NUM_ ; } if ( av 2 == null ) { av 2 = NUM_ ; } if ( year 1 == year 2 ) { return av 1 . double Value ( ) ; } return av 1 . double Value ( ) + ( av 2 . double Value ( ) - av 1 . double Value ( ) ) * ( now - year 1 ) / ( year 2 - year 1 ) ; }
private void close Counter Data Output Stream ( ) throws Data Fallback Exception { if ( LOG . is Debug Enabled ( ) ) LOG . debug ( STR_ + counter File . get Name ( ) ) ; if ( d Output != null ) { try { d Output . close ( ) ; } catch ( IO Exception e ) { throw new Data Fallback Exception ( e . get Message ( ) ) ; } finally { d Output = null ; } } }
public Bios Command Result do Fail Back ( Storage System primary System , Storage System secondary System , String policy Name , Task Completer task Completer ) { String mirror Policy Name = policy Name . concat ( STR_ ) ; Bios Command Result result ; try { result = isi Resync Prep ( primary System , secondary System , policy Name , null ) ; if ( ! result . is Command Success ( ) ) { return result ; } result = do Start Replication Policy ( secondary System , mirror Policy Name , null ) ; if ( ! result . is Command Success ( ) ) { return result ; } result = do Failover ( primary System , mirror Policy Name , null ) ; if ( ! result . is Command Success ( ) ) { return result ; } result = isi Resync Prep ( secondary System , primary System , mirror Policy Name , null ) ; if ( ! result . is Command Success ( ) ) { return result ; } log . info ( STR_ , secondary System . get Ip Address ( ) , primary System . get Ip Address ( ) ) ; return Bios Command Result . create Successful Result ( ) ; } catch ( Isilon Exception e ) { return Bios Command Result . create Error Result ( e ) ; } }
public static final void send Wake On Lan Packet ( String mac Addr ) { final String IP = STR_ ; final int port = NUM_ ; try { final byte [ ] MACBYTE = new byte [ NUM_ ] ; final String [ ] hex = mac Addr . split ( STR_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { MACBYTE [ i ] = ( byte ) Integer . parse Int ( hex [ i ] , NUM_ ) ; } final byte [ ] bytes = new byte [ NUM_ + NUM_ * MACBYTE . length ] ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { bytes [ i ] = ( byte ) NUM_ ; } for ( int i = NUM_ ; i < bytes . length ; i += MACBYTE . length ) { System . arraycopy ( MACBYTE , NUM_ , bytes , i , MACBYTE . length ) ; } final Inet Address address = Inet Address . get By Name ( IP ) ; final Datagram Packet packet = new Datagram Packet ( bytes , bytes . length , address , port ) ; final Datagram Socket socket = new Datagram Socket ( ) ; socket . send ( packet ) ; socket . close ( ) ; LOGGER . info ( STR_ + mac Addr ) ; } catch ( final Exception e ) { LOGGER . error ( STR_ + mac Addr , e ) ; } }
public void append Variable ( String Builder sb , Variable v , int isolate Id ) { String name = v . get Name ( ) ; sb . append ( name ) ; sb . append ( STR_ ) ; append Variable Value ( sb , v . get Value ( ) , name , isolate Id ) ; }
public Bottom Navigation Bar remove Item ( Bottom Navigation Item item ) { m Bottom Navigation Items . remove ( item ) ; return this ; }
public void flush ( ) throws IO Exception { output Stream . flush ( ) ; }
private Marshaller create Marshaller ( JAXB Context jaxb Context , String schema Path ) throws SAX Exception , JAXB Exception { Schema schema = Xml Parser . get Schema ( new String [ ] { schema Path } ) ; Marshaller jaxb Marshaller = jaxb Context . create Marshaller ( ) ; jaxb Marshaller . set Schema ( schema ) ; jaxb Marshaller . set Property ( Marshaller . JAXB FORMATTED OUTPUT , true ) ; jaxb Marshaller . set Property ( Marshaller . JAXB ENCODING , STR_ ) ; return jaxb Marshaller ; }
public Recognition Request add Tag For Select Classes ( String tag ) { select Classes . add ( tag ) ; return this ; }
public Time Series Data ( Tetrad Matrix matrix , List < String > var Names ) { if ( matrix == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( var Names == null ) { throw new Null Pointer Exception ( STR_ ) ; } for ( int i = NUM_ ; i < var Names . size ( ) ; i ++ ) { if ( var Names . get ( i ) == null ) { throw new Null Pointer Exception ( STR_ + i + STR_ ) ; } } this . data 2 = matrix ; if ( var Names . size ( ) != matrix . columns ( ) ) { throw new Illegal Argument Exception ( STR_ + STR_ ) ; } this . var Names = var Names ; this . name = STR_ ; }
private void prepare Transfers ( ) throws Lib Usb Exception { if ( m Available Transfers == null ) { m Available Transfers = new Linked Transfer Queue < > ( ) ; for ( int x = NUM_ ; x < TRANSFER BUFFER POOL SIZE ; x ++ ) { Transfer transfer = Lib Usb . alloc Transfer ( ) ; if ( transfer == null ) { throw new Lib Usb Exception ( STR_ , Lib Usb . ERROR NO MEM ) ; } final Byte Buffer buffer = Byte Buffer . allocate Direct ( m Buffer Size ) ; Lib Usb . fill Bulk Transfer ( transfer , m Device Handle , USB BULK ENDPOINT , buffer , Buffer Processor . this , STR_ , TIMEOUT US ) ; m Available Transfers . add ( transfer ) ; } } }
private void synchronize Tag Values ( final Set < Long > new Tags ) throws JMS Exception { if ( ! new Tags . is Empty ( ) ) { Client Data Tag Impl new Tag = null ; Collection < Tag Value Update > requested Tag Values = tag Request Handler . request Tag Values ( new Tags ) ; for ( Tag Value Update tag Value Update : requested Tag Values ) { new Tag = live Cache . get ( tag Value Update . get Id ( ) ) ; if ( new Tag != null ) { new Tag . update ( tag Value Update ) ; } } } }
public URL Class Path ( URL [ ] urls , URL Stream Handler Factory factory ) { for ( int i = NUM_ ; i < urls . length ; i ++ ) { path . add ( urls [ i ] ) ; } push ( urls ) ; if ( factory != null ) { jar Handler = factory . create URL Stream Handler ( STR_ ) ; } }
public void add Categories Listener ( Snapshot Categories Listener listener ) { listeners . add ( listener ) ; }
private static void add Rules ( List < String > batch List , List < Rule > rules To Add ) { String add Statement = STR_ + RULES TABLE + STR_ + STR_ + STR_ + STR_ + STR_ ; for ( Rule rule : rules To Add ) { batch List . add ( String . format ( add Statement , rule . get Name ( ) , rule . get Description ( ) , rule . get Membership Rule ( ) ) ) ; } }
private void initialize Feature Structures ( ) { int num blocks = features . get Int ( NUM_ ) ; estimated = new float [ num blocks ] ; precomputable = new float [ num blocks ] ; Arrays . fill ( estimated , Float . NEGATIVE INFINITY ) ; Arrays . fill ( precomputable , Float . NEGATIVE INFINITY ) ; feature Size = features . get Int ( NUM_ ) ; }
public static void save Image ( final Bitmap bitmap , final File save To File ) { if ( save To File . exists ( ) ) { save To File . delete ( ) ; } try { final File Output Stream out = new File Output Stream ( save To File ) ; bitmap . compress ( Bitmap . Compress Format . PNG , NUM_ , out ) ; out . flush ( ) ; out . close ( ) ; } catch ( final Exception e ) { e . print Stack Trace ( ) ; } }
protected void init Rebuild From ( ) throws Messaging Exception { set Rebuild From ( ( get Init Parameter ( STR_ ) == null ) ? false : Boolean . value Of ( get Init Parameter ( STR_ ) ) ) ; if ( is Debug ( ) ) { if ( is Rebuild From ( ) ) { log ( STR_ ) ; } else { log ( STR_ ) ; } } }
@ Override public void on Paint ( View Transform transform , Graphics 2 D g ) { int x = transform . get Swing X ( m Bounds . x ) ; int y = transform . get Swing Y ( m Bounds . y ) ; int w = transform . get Swing Dimension ( m Bounds . width ) ; int h = transform . get Swing Dimension ( m Bounds . height ) ; double progress = get Progress ( ) ; int alpha = get Pulsating Alpha ( progress ) ; Color highlight = new Color ( m Color . get Red ( ) , m Color . get Green ( ) , m Color . get Blue ( ) , alpha ) ; g . set Color ( highlight ) ; int extra = get Extra ( progress ) ; g . fill Rect ( x - extra , y - extra , w + NUM_ * extra + NUM_ , h + NUM_ * extra + NUM_ ) ; }
public Client Http Request ( URL url ) throws IO Exception { this ( url . open Connection ( ) ) ; }
public String canon Serialize ( Node node ) throws Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; canon . set Writer ( baos ) ; canon . not Reset ( ) ; canon . canonicalize Subtree ( node ) ; String ret = baos . to String ( STR_ ) ; baos . reset ( ) ; return ret ; }
private String gen Get Column Method ( Field field ) { return gen Get Column Method ( field . get Type ( ) ) ; }
public void disable Schedule Renewal ( ) { current Lease . set ( null ) ; Set < Lease > leases = new Hash Set < > ( schedules . key Set ( ) ) ; for ( Lease lease : leases ) { cancel Schedule ( lease ) ; schedules . remove ( lease ) ; } }
protected int timed Read ( byte [ ] b , int off , int len ) throws IO Exception { return ( in . read ( b , off , len ) ) ; }
public void remove ( byte [ ] id ) { Byte Buffer id Buffer = Byte Buffer . wrap ( id ) ; while ( id Buffer . has Remaining ( ) ) { switch ( id Buffer . get ( ) ) { case NUM_ : int len = Data Utils . read Var Int ( id Buffer ) ; id Buffer . position ( id Buffer . position ( ) + len ) ; break ; case NUM_ : Data Utils . read Var Int ( id Buffer ) ; long k = Data Utils . read Var Long ( id Buffer ) ; map . remove ( k ) ; break ; case NUM_ : Data Utils . read Var Long ( id Buffer ) ; long k 2 = Data Utils . read Var Long ( id Buffer ) ; remove ( map . get ( k 2 ) ) ; map . remove ( k 2 ) ; break ; default : throw Data Utils . new Illegal Argument Exception ( STR_ , Arrays . to String ( id ) ) ; } } }
public static void sleep ( long ms ) { try { Thread . sleep ( ms ) ; } catch ( Interrupted Exception e ) { throw new Lua Error ( e ) ; } }
private void copy To Arrays ( ) { color Extracted = pdf data . is Color Extracted ( ) ; final int count = pdf data . get Raw Text Element Count ( ) ; is Used = new boolean [ count ] ; font Size = new int [ count ] ; writing Mode = new int [ count ] ; space Width = new float [ count ] ; content = new String Builder [ count ] ; text Length = new int [ count ] ; f x 1 = new float [ count ] ; f color Tag = new String [ count ] ; f x 2 = new float [ count ] ; f y 1 = new float [ count ] ; f y 2 = new float [ count ] ; for ( int i = NUM_ ; i < count ; i ++ ) { content [ i ] = new String Builder ( pdf data . contents [ i ] ) ; font Size [ i ] = pdf data . f end font size [ i ] ; writing Mode [ i ] = pdf data . f writing Mode [ i ] ; f x 1 [ i ] = pdf data . f x 1 [ i ] ; f color Tag [ i ] = pdf data . color Tag [ i ] ; f x 2 [ i ] = pdf data . f x 2 [ i ] ; f y 1 [ i ] = pdf data . f y 1 [ i ] ; f y 2 [ i ] = pdf data . f y 2 [ i ] ; space Width [ i ] = pdf data . space width [ i ] ; text Length [ i ] = pdf data . text length [ i ] ; } }
@ Override protected int handle Next ( ) { Character Iterator text = get Text ( ) ; if ( cached Break Positions == null || position In Cache == cached Break Positions . length - NUM_ ) { int start Pos = text . get Index ( ) ; dictionary Char Count = NUM_ ; int result = super . handle Next ( ) ; if ( dictionary Char Count > NUM_ && result - start Pos > NUM_ ) { divide Up Dictionary Range ( start Pos , result ) ; } else { cached Break Positions = null ; return result ; } } if ( cached Break Positions != null ) { ++ position In Cache ; text . set Index ( cached Break Positions [ position In Cache ] ) ; return cached Break Positions [ position In Cache ] ; } return - NUM_ ; }
protected Diff process Revision ( final Revision revision ) throws Unsupported Encoding Exception { Diff diff = super . process Revision ( revision ) ; if ( diff == null ) { this . ignored Revisions Counter ++ ; } else { this . revision Counter ++ ; this . diff Part Counter += diff . size ( ) ; } return diff ; }
protected void write Column ( Table table , Column column , String Builder ddl ) { write Column Type Default Required ( table , column , ddl ) ; if ( column . is Primary Key ( ) && database Info . is Primary Key Embedded ( ) ) { write Column Embedded Primary Key ( table , column , ddl ) ; } if ( column . is Auto Increment ( ) && ! database Info . is Default Value Used For Identity Spec ( ) ) { if ( ! database Info . is Non PK Identity Columns Supported ( ) && ! column . is Primary Key ( ) ) { throw new Model Exception ( STR_ + column . get Name ( ) + STR_ + table . get Name ( ) + STR_ ) ; } ddl . append ( STR_ ) ; write Column Auto Increment Stmt ( table , column , ddl ) ; } }
public synchronized void put All ( Map map , int action ) { put All ( map , action , true ) ; }
private String find Highest To Version ( String to Version ) { if ( version Changes . get ( to Version ) == null ) { List < String > to Versions = new Array List < String > ( version Changes . key Set ( ) ) ; Collections . sort ( to Versions , Collections . reverse Order ( ) ) ; for ( String version : to Versions ) { if ( version . compare To ( to Version ) <= NUM_ ) { return version ; } } throw new Illegal Argument Exception ( STR_ + to Version ) ; } else { return to Version ; } }
private void create Operator ( boolean topic , Operator Context context ) { create Operator ( topic , context , NUM_ ) ; }
public void children Added ( Bean Context Membership Event bcme ) { Iterator it = bcme . iterator ( ) ; find And Init ( it ) ; }
private boolean add Lifeline ( Lifeline lifeline ) throws Semantic Error { if ( lifeline . get Diagram ( ) != this ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( lifeline Map . get ( lifeline . get Name ( ) ) != null ) { throw new Semantic Error ( provider , lifeline . get Name ( ) + STR_ ) ; } if ( lifeline . has Thread ( ) ) { if ( ! threaded ) { throw new Semantic Error ( provider , lifeline . get Name ( ) + STR_ ) ; } int thread = spawn Thread ( ) ; first . set ( thread , lifeline ) ; lifeline . set Thread ( thread ) ; } if ( ! lifeline . is Variable ( ) ) { position Map . put ( lifeline . get Name ( ) , add ( lifeline ) ) ; } lifeline Map . put ( lifeline . get Name ( ) , lifeline ) ; return true ; }
public void clear All ( ) { m Tab Container . remove All Views ( ) ; m Bottom Navigation Tabs . clear ( ) ; m Bottom Navigation Items . clear ( ) ; m Background Overlay . set Visibility ( View . GONE ) ; m Container . set Background Color ( Color . TRANSPARENT ) ; m Selected Position = DEFAULT SELECTED POSITION ; }
public void submit One ( final R resource ) throws Exception { lock . lock ( ) ; try { final Callable < ? > task = new Parser Task ( resource ) ; submit One ( resource , task ) ; } finally { lock . unlock ( ) ; } }
private Collection < Integer > all Reducers ( Hadoop Map Reduce Plan plan ) { Collection < Integer > res = new Hash Set < > ( ) ; for ( int i = NUM_ ; i < plan . reducers ( ) ; i ++ ) res . add ( i ) ; return res ; }
Quick Select Sketch ( final int nom Entries , final int lg Resize Factor , final float sampling Probability , final Summary Factory < S > summary Factory ) { this ( nom Entries , lg Resize Factor , sampling Probability , summary Factory , NUM_ << starting Sub Multiple ( Integer . number Of Trailing Zeros ( ceiling Power Of 2 ( nom Entries ) * NUM_ ) , Resize Factor . get RF ( lg Resize Factor ) , MIN LG ARR LONGS ) ) ; }
public Builder index Not In ( Index Range ... ranges ) { verify Not Null ( ranges ) ; expressions . add ( new Not ( new Event Filter Expression . Index In ( ranges ) ) ) ; return this ; }
public void start ( Calendar start Time , Calendar end Time ) { if ( start Time == null || end Time == null || start Time . after ( end Time ) ) { throw new Illegal Argument Exception ( STR_ ) ; } m Start Time = start Time ; start ( end Time ) ; }
@ Rpc Method public void place ( Resource resource , Async Method Callback < Host . Async Client . place call > handler ) throws Rpc Exception { ensure Client ( ) ; Place Request place Request = new Place Request ( resource ) ; client Proxy . set Timeout ( PLACE TIMEOUT MS ) ; logger . debug ( STR_ , resource , get Host Ip ( ) , place Request ) ; try { client Proxy . place ( place Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return false ; } if ( ! ( o instanceof Collection ) ) { return false ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self iter = iterator ( ) ; final Iterator < ? > othr iter = other . iterator ( ) ; while ( self iter . has Next ( ) && othr iter . has Next ( ) ) { if ( ! Objects . equals ( self iter . next ( ) , othr iter . next ( ) ) ) return false ; } return ! ( self iter . has Next ( ) || othr iter . has Next ( ) ) ; }
public boolean has Aggregation Levels ( ) { return aggregation Levels != null && aggregation Levels . size ( ) > NUM_ ; }
@ Override public List < Application > find All ( ) throws Service Exception { try { logger . debug ( STR_ ) ; List < Application > list Applications = application DAO . find All ( ) ; for ( Application application : list Applications ) { application . set Server ( server Service . find By App ( application ) ) ; application . set Modules ( module Service . find By App And User ( application . get User ( ) , application . get Name ( ) ) ) ; } logger . debug ( STR_ ) ; return list Applications ; } catch ( Persistence Exception e ) { logger . error ( STR_ + e ) ; throw new Service Exception ( e . get Localized Message ( ) , e ) ; } }
@ Override protected void show Attempt ( Attempt attempt ) { Dataset dataset = attempt . get Dataset ( ) ; if ( dataset == null ) return ; List < String > options = dataset . get Options ( ) ; if ( options == null || options . is Empty ( ) ) return ; choice Container . remove All Views ( ) ; for ( String option : options ) { Stepik Option View option View Item ; if ( dataset . is multiple choice ( ) ) { option View Item = new Stepik Check Box ( get Activity ( ) ) ; } else { option View Item = new Stepik Radio Button ( get Activity ( ) ) ; } build Choice Item ( option View Item , option ) ; } }
protected void append Serializable Type ( String Builder sb , Field Type field Type , int field Width ) { sb . append ( STR_ ) ; }
public void add Param ( String name , String value , int type ) { params . add ( new Name Value Pair ( type , name , value , params . size ( ) ) ) ; }
@ Override protected void delete Behind ( final int n , final Iterator < byte [ ] > keys ) { final Lock lock = write Lock ( ) ; lock . lock ( ) ; try { super . delete Behind ( n , keys ) ; } finally { unlock ( lock ) ; } }
public static void overflow Condition ( final long offset , final I Translation Environment environment , final I Instruction instruction , final List < Reil Instruction > instructions , final String first Operand ) { final Operand Size qw = Operand Size . QWORD ; final Operand Size dw = Operand Size . DWORD ; final Operand Size bt = Operand Size . BYTE ; final String is Not Overflowed = environment . get Next Variable String ( ) ; final String tmp Var 7 = environment . get Next Variable String ( ) ; long base Offset = offset ; instructions . add ( Reil Helpers . create Bsh ( base Offset ++ , qw , first Operand , dw , String . value Of ( - NUM_ ) , dw , tmp Var 7 ) ) ; instructions . add ( Reil Helpers . create Bisz ( base Offset ++ , dw , tmp Var 7 , bt , is Not Overflowed ) ) ; instructions . add ( Reil Helpers . create Bisz ( base Offset ++ , bt , is Not Overflowed , bt , STR_ ) ) ; }
public void remove Property Change Listener ( Scene Property Change Listener listener ) { if ( listener != null ) { logger . log ( Level . FINE , STR_ , listener ) ; listeners . remove ( listener ) ; } }
@ Override public final void wake Up ( ) throws Ade Exception { super . wake Up ( ) ; create Usage Variables ( ) ; }
public boolean write ( String p design name ) { String session name = p design name . replace ( STR_ , STR_ ) ; try { String [ ] reserved chars = { STR_ , STR_ , STR_ , STR_ } ; Dsn Identifier identifier type = new Dsn Identifier ( reserved chars , r board . host com . specctra parser info . string quote ) ; write session scope ( identifier type , session name , p design name ) ; output file . close ( ) ; stat . user Println ( classname + STR_ ) ; } catch ( Exception exc ) { stat . user Println ( STR_ , exc ) ; return false ; } return true ; }
Dynamic Playlist Session create Playlist Session ( ) { m Session Ready = false ; m Session Error = false ; Echo Nest echo Nest = new Echo Nest ( ) ; String type = generate Taste Catalog If Needed And Get Type ( echo Nest ) ; if ( ! m Session Error ) { if ( DEBUG ) Log . d ( TAG , STR_ ) ; String catalog Id = ( m Catalog != null ? m Catalog . get ID ( ) : null ) ; try { m Playlist Session = echo Nest . create Dynamic Playlist ( type , catalog Id , m Moods , m Styles ) ; } catch ( Echo Nest Exception e ) { Log . e ( TAG , STR_ , e ) ; m Session Error = true ; } } if ( ! m Session Error ) { Dynamic Playlist Steer Params p = new Dynamic Playlist Steer Params ( ) ; if ( m Energy >= NUM_ ) { p . add Target Value ( Dynamic Playlist Steer Params . Steering Parameter . energy , m Energy ) ; } if ( m Familiar >= NUM_ ) { p . add Target Value ( Dynamic Playlist Steer Params . Steering Parameter . artist familiarity , m Familiar ) ; } if ( m Speechiness >= NUM_ ) { p . add ( STR_ , m Speechiness ) ; } if ( m Adventurousness >= NUM_ ) { p . set Adventurousness ( m Adventurousness ) ; } if ( m Song Types != null && m Song Types . length > NUM_ ) { for ( String song Type : m Song Types ) { if ( ! song Type . is Empty ( ) ) { p . add ( STR_ , song Type ) ; } } } try { m Playlist Session . steer ( p ) ; } catch ( Echo Nest Exception e ) { Log . e ( TAG , STR_ , e ) ; m Session Error = true ; } } m Session Ready = true ; return m Playlist Session ; }
private void handle Browse ( ) { container Text . set Text ( Workspace Tools . select Project ( containing Page . get Shell ( ) , get Container Name ( ) ) ) ; }
public void commit ( int task Id ) throws Interrupted Exception , Replicator Exception { Concurrent Linked Queue < Repl DBMS Event > queue = task Queues . get ( task Id ) ; if ( queue . size ( ) == NUM_ ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ + task Id ) ; } return ; } if ( commit Action != null ) commit Action . execute ( task Id ) ; synchronized ( serial Queue ) { while ( queue . peek ( ) != null ) { Repl DBMS Event event = queue . poll ( ) ; boolean ok = serial Queue . offer ( event , commit Timeout , Time Unit . SECONDS ) ; if ( ! ok ) { throw new Replicator Exception ( STR_ + task Id + STR_ + commit Timeout ) ; } if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ + task Id + STR_ + event . get Seqno ( ) + STR_ + event . get Shard Id ( ) ) ; } } queue . clear ( ) ; commit Count ++ ; } }
private static int uarimax Eq ( double value , double [ ] bv , int bvi [ ] , Binary Operator b Op ) throws DML Runtime Exception { int ix = Arrays . binary Search ( bv , value ) ; int ix Max = bv . length ; if ( ix >= NUM_ ) ix Max = bvi [ ix ] + NUM_ ; return ix Max ; }
public DTLS Session ( Inet Socket Address peer Address , boolean is Client ) { this ( peer Address , is Client , NUM_ ) ; }
public void on Draw Frame ( GL 10 gl ) { gl . gl Clear ( GL 10 . GL COLOR BUFFER BIT ) ; gl . gl Matrix Mode ( GL 10 . GL MODELVIEW ) ; gl . gl Load Identity ( ) ; if ( show Cube Inside Out ) { float dist = NUM_ ; gl . gl Translatef ( NUM_ , NUM_ , - dist ) ; if ( orientation Provider != null ) { Quaternion q = orientation Provider . get Quaternion ( ) ; gl . gl Rotatef ( ( float ) ( NUM_ * Math . acos ( q . get W ( ) ) * NUM_ / Math . PI ) , q . get X ( ) , q . get Y ( ) , q . get Z ( ) ) ; } gl . gl Enable Client State ( GL 10 . GL VERTEX ARRAY ) ; gl . gl Enable Client State ( GL 10 . GL COLOR ARRAY ) ; m Cube . draw ( gl ) ; } else { if ( orientation Provider != null ) { Quaternion q = orientation Provider . get Quaternion ( ) ; gl . gl Rotatef ( ( float ) ( NUM_ * Math . acos ( q . get W ( ) ) * NUM_ / Math . PI ) , q . get X ( ) , q . get Y ( ) , q . get Z ( ) ) ; } float dist = NUM_ ; draw Translated Cube ( gl , NUM_ , NUM_ , - dist ) ; draw Translated Cube ( gl , NUM_ , NUM_ , dist ) ; draw Translated Cube ( gl , NUM_ , - dist , NUM_ ) ; draw Translated Cube ( gl , NUM_ , dist , NUM_ ) ; draw Translated Cube ( gl , - dist , NUM_ , NUM_ ) ; draw Translated Cube ( gl , dist , NUM_ , NUM_ ) ; } gl . gl Enable Client State ( GL 10 . GL VERTEX ARRAY ) ; gl . gl Enable Client State ( GL 10 . GL COLOR ARRAY ) ; m Cube . draw ( gl ) ; }
@ GET @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) public Host List list Hosts ( @ Query Param ( STR_ ) final URI tid ) throws Database Exception { URI tenant Id ; Storage OS User user = get User From Context ( ) ; if ( tid == null || String Utils . is Blank ( tid . to String ( ) ) ) { tenant Id = URI . create ( user . get Tenant Id ( ) ) ; } else { tenant Id = tid ; } Tenant Org tenant = permissions Helper . get Object By Id ( tenant Id , Tenant Org . class ) ; Arg Validator . check Entity ( tenant , tenant Id , is Id Embedded In URL ( tenant Id ) , true ) ; verify Authorized In Tenant Org ( tenant Id , user ) ; Host List list = new Host List ( ) ; list . set Hosts ( map ( Resource Type Enum . HOST , list Children ( tenant Id , Host . class , STR_ , STR_ ) ) ) ; return list ; }
void update Running Button ( ) { boolean running = clock . get Run ( ) ; if ( running ) { clock Status . set Text ( Bundle . get Message ( STR_ ) ) ; start Button . set Visible ( false ) ; stop Button . set Visible ( true ) ; } else { clock Status . set Text ( Bundle . get Message ( STR_ ) ) ; start Button . set Visible ( true ) ; stop Button . set Visible ( false ) ; } clock Status . set Visible ( true ) ; }
void lightweight Print ( Graphics g ) { print ( g ) ; }
static boolean wait For ( Process process , long timeout ) throws Interrupted Exception { final int interval = NUM_ * NUM_ ; long time Waiting = NUM_ ; while ( time Waiting < timeout ) { if ( ! is Process Alive ( process ) ) return true ; if ( logger . is Debug Enabled ( ) ) logger . debug ( STR_ + process + STR_ + ( timeout - time Waiting ) + STR_ + timeout + STR_ ) ; try { Thread . sleep ( interval ) ; } catch ( Interrupted Exception e ) { e . fill In Stack Trace ( ) ; throw e ; } time Waiting += interval ; } return false ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
protected void create Renderers ( Combined Chart chart , Chart Animator animator , View Port Handler view Port Handler ) { m Renderers = new Array List < > ( ) ; Draw Order [ ] orders = chart . get Draw Order ( ) ; for ( Draw Order order : orders ) { switch ( order ) { case BAR : if ( chart . get Bar Data ( ) != null ) m Renderers . add ( new Bar Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case BUBBLE : if ( chart . get Bubble Data ( ) != null ) m Renderers . add ( new Bubble Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case LINE : if ( chart . get Line Data ( ) != null ) m Renderers . add ( new Line Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case CANDLE : if ( chart . get Candle Data ( ) != null ) m Renderers . add ( new Candle Stick Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; case SCATTER : if ( chart . get Scatter Data ( ) != null ) m Renderers . add ( new Scatter Chart Renderer ( chart , animator , view Port Handler ) ) ; break ; } } }
public double unstandardized ( double [ ] sample 1 , double [ ] sample 2 ) { final int n 1 = sample 1 . length , n 2 = sample 2 . length , N = n 1 + n 2 ; final double [ ] combined = new double [ N ] ; Arrays . sort ( sample 1 ) ; System . arraycopy ( sample 1 , NUM_ , combined , NUM_ , n 1 ) ; Arrays . sort ( sample 2 ) ; System . arraycopy ( sample 2 , NUM_ , combined , n 1 , n 2 ) ; Arrays . sort ( combined ) ; int m 1 = NUM_ , m 2 = NUM_ ; double Ak 1 = NUM_ , Ak 2 = NUM_ ; for ( int j = NUM_ ; j < N ; ) { final double x = combined [ j ++ ] ; int lj = NUM_ ; while ( j < N && combined [ j ] == x ) { ++ j ; ++ lj ; } final double bi = j - NUM_ * lj ; { assert ( m 1 >= n 1 || sample 1 [ m 1 ] >= x ) ; int f 1 = NUM_ ; while ( m 1 < n 1 && sample 1 [ m 1 ] == x ) { ++ m 1 ; ++ f 1 ; } double v = N * ( m 1 - NUM_ * f 1 ) - n 1 * bi ; Ak 1 += lj * v * v / ( bi * ( N - bi ) - NUM_ * N * lj ) ; } { assert ( m 2 >= n 2 || sample 2 [ m 2 ] >= x ) ; int f 2 = NUM_ ; while ( m 2 < n 2 && sample 2 [ m 2 ] == x ) { ++ m 2 ; ++ f 2 ; } double v = N * ( m 2 - NUM_ * f 2 ) - n 2 * bi ; Ak 2 += lj * v * v / ( bi * ( N - bi ) - NUM_ * N * lj ) ; } } double A 2 = Ak 1 / n 1 + Ak 2 / n 2 ; A 2 *= ( N - NUM_ ) / ( N * N ) ; return A 2 ; }
protected List < Process Change > remove Equipment Control Tags ( final T abstract Equipment , final Configuration Element Report equipment Report ) { List < Process Change > changes = new Array List < > ( ) ; LOGGER . debug ( STR_ ) ; Long alive Tag Id = abstract Equipment . get Alive Tag Id ( ) ; if ( alive Tag Id != null ) { Configuration Element Report tag Report = new Configuration Element Report ( Action . REMOVE , Entity . CONTROLTAG , alive Tag Id ) ; Process Change change = control Tag Config Handler . remove Control Tag ( alive Tag Id , tag Report ) ; if ( change . process Action Required ( ) ) { change . set Nested Sub Report ( tag Report ) ; changes . add ( change ) ; } else { equipment Report . add Sub Report ( tag Report ) ; } } Long comm Tag Id = abstract Equipment . get Comm Fault Tag Id ( ) ; if ( comm Tag Id != null ) { Configuration Element Report tag Report = new Configuration Element Report ( Action . REMOVE , Entity . CONTROLTAG , comm Tag Id ) ; Process Change change = control Tag Config Handler . remove Control Tag ( comm Tag Id , tag Report ) ; if ( change . process Action Required ( ) ) { change . set Nested Sub Report ( tag Report ) ; changes . add ( change ) ; } else { equipment Report . add Sub Report ( tag Report ) ; } } Long state Tag Id = abstract Equipment . get State Tag Id ( ) ; Configuration Element Report tag Report = new Configuration Element Report ( Action . REMOVE , Entity . CONTROLTAG , state Tag Id ) ; Process Change change = control Tag Config Handler . remove Control Tag ( state Tag Id , tag Report ) ; if ( change . process Action Required ( ) ) { change . set Nested Sub Report ( tag Report ) ; changes . add ( change ) ; } else { equipment Report . add Sub Report ( tag Report ) ; } return changes ; }
public void create Panel ( Layer [ ] layers ) { create Layer Classes ( layers ) ; create Panel ( ) ; }
@ Override public List < Period > generate Periods ( Date Time Unit date Time Unit ) { org . hisp . dhis . calendar . Calendar cal = get Calendar ( ) ; date Time Unit . set Month ( NUM_ ) ; date Time Unit . set Day ( NUM_ ) ; int year = date Time Unit . get Year ( ) ; List < Period > periods = Lists . new Array List ( ) ; while ( year == date Time Unit . get Year ( ) ) { periods . add ( create Period ( date Time Unit , cal ) ) ; date Time Unit = cal . plus Months ( date Time Unit , NUM_ ) ; } return periods ; }
public static boolean is Relay State URL Valid ( Http Servlet Request request , String relay State , String role ) { String meta Alias = SAML 2 Meta Utils . get Meta Alias By Uri ( request . get Request URI ( ) ) ; if ( meta Alias == null ) { meta Alias = request . get Parameter ( SAML 2 Meta Manager . NAME META ALIAS IN URI ) ; } return is Relay State URL Valid ( meta Alias , relay State , role ) ; }
@ Parameters ( { STR_ } ) @ Before Suite ( groups = { STR_ , STR_ } ) public void suite Setup ( String realm ) throws Exception { Object [ ] params = { realm } ; entering ( STR_ , params ) ; try { lmgr = Log Manager Util . get Log Manager ( ) ; } catch ( Exception e ) { log ( Level . SEVERE , STR_ , e . get Message ( ) , params ) ; e . print Stack Trace ( ) ; throw e ; } the Realm = realm ; exiting ( STR_ ) ; }
private void build ( ) { int count = names . size ( ) ; int last = count - NUM_ ; for ( int i = NUM_ ; i < count ; i ++ ) { String prefix = prefixes . get ( i ) ; String segment = names . get ( i ) ; int index = indexes . get ( i ) ; if ( i > NUM_ ) { builder . append ( STR_ ) ; } if ( attribute && i == last ) { builder . append ( STR_ ) ; builder . append ( segment ) ; } else { if ( prefix != null ) { builder . append ( prefix ) ; builder . append ( STR_ ) ; } builder . append ( segment ) ; builder . append ( STR_ ) ; builder . append ( index ) ; builder . append ( STR_ ) ; } } location = builder . to String ( ) ; }
Node < V > find ( int h , long k ) { Node < V > e = this ; do { if ( ( e . key == k ) ) { return e ; } } while ( ( e = e . next ) != null ) ; return null ; }
static void make Category Map ( String filename ) { specfile = filename ; generate New Data ( ) ; category Map = new int [ category Names . length - NUM_ ] [ ] ; for ( int i = NUM_ ; i < category Names . length - NUM_ ; i ++ ) { int len = new List Count [ BMP ] [ i ] + new List Count [ non BMP ] [ i ] ; category Map [ i ] = new int [ len ] ; System . arraycopy ( new List [ i ] , NUM_ , category Map [ i ] , NUM_ , len ) ; } }
private void change Value Randomly ( Random r , int num Of Values , int index Of Att , Instance instance , boolean use Missing ) { int curr Value ; if ( instance . is Missing ( index Of Att ) ) { curr Value = num Of Values ; } else { curr Value = ( int ) instance . value ( index Of Att ) ; } if ( ( num Of Values == NUM_ ) && ( ! instance . is Missing ( index Of Att ) ) ) { instance . set Value ( index Of Att , ( curr Value + NUM_ ) % NUM_ ) ; } else { while ( true ) { int new Value ; if ( use Missing ) { new Value = ( int ) ( r . next Double ( ) * ( num Of Values + NUM_ ) ) ; } else { new Value = ( int ) ( r . next Double ( ) * num Of Values ) ; } if ( new Value != curr Value ) { if ( new Value == num Of Values ) { instance . set Missing ( index Of Att ) ; } else { instance . set Value ( index Of Att , new Value ) ; } break ; } } } }
private Memory Manager new Memory Manager ( ) { final Direct Buffer Pool pool = Direct Buffer Pool . INSTANCE ; long max Memory Bytes Per Query = Query Hints . DEFAULT ANALYTIC MAX MEMORY PER QUERY ; if ( max Memory Bytes Per Query < NUM_ ) { max Memory Bytes Per Query = NUM_ ; } final boolean blocking ; final int nsectors ; if ( max Memory Bytes Per Query == NUM_ ) { blocking = true ; nsectors = Integer . MAX VALUE ; } else { blocking = false ; final int buffer Capacity = pool . get Buffer Capacity ( ) ; nsectors = ( int ) Math . ceil ( max Memory Bytes Per Query / ( double ) buffer Capacity ) ; } return new Memory Manager ( pool , nsectors , blocking , null ) ; }
void add ( Algorithm Result result ) { algorithm Results . add ( result ) ; }
public Joiner push Set ( String alias ) { if ( map Builder == null ) { map Builder = new Map Builder ( this ) ; } map Builder . add Term ( Map Builder Term Type . SET , lookup Alias ( alias ) , alias ) ; return this ; }
public void retrieve File ( String path , Output Stream os , int limit ) throws IO Exception , Ftp Exception Can Not Have Data Connection , Ftp Exception Unknown Forced Data Close , Ftp Exception Control Closed By Forced Data Close { Socket socket = open Passive Data Connection ( FTP Command . RETR , path ) ; if ( socket == null ) throw new Ftp Exception Can Not Have Data Connection ( STR_ + ( ( path == null ) ? STR_ : path ) ) ; Input Stream input = socket . get Input Stream ( ) ; int len ; int count = NUM_ ; byte [ ] buf = new byte [ org . apache . commons . net . io . Util . DEFAULT COPY BUFFER SIZE ] ; while ( ( len = input . read ( buf , NUM_ , buf . length ) ) != - NUM_ ) { count += len ; if ( limit >= NUM_ && count > limit ) { os . write ( buf , NUM_ , len - ( count - limit ) ) ; break ; } os . write ( buf , NUM_ , len ) ; os . flush ( ) ; } socket . close ( ) ; try { int reply = get Reply ( ) ; if ( ! not Bad Reply ( reply ) ) throw new Ftp Exception Unknown Forced Data Close ( get Reply String ( ) ) ; } catch ( FTP Connection Closed Exception e ) { throw new Ftp Exception Control Closed By Forced Data Close ( e . get Message ( ) ) ; } }
public void display Info Message ( String text ) { display Message ( name , text , Tray Icon . Message Type . INFO ) ; }
public void remove Directory Set ( Context context , String path ) { Tiny DB tinydb = new Tiny DB ( context ) ; Array List < String > file = tinydb . get List String ( STR_ ) ; file . remove ( path ) ; tinydb . put List String ( STR_ , file ) ; }
@ Override public Double DBID List reverse KNN Query ( DBID Ref id , int k ) { Modifiable Double DBID List result = DBID Util . new Distance DBID List ( ) ; final Heap < Generic M Tree Distance Search Candidate > pq = new Updatable Heap < > ( ) ; pq . add ( new Generic M Tree Distance Search Candidate ( NUM_ , get Root ID ( ) , null ) ) ; while ( ! pq . is Empty ( ) ) { Generic M Tree Distance Search Candidate pq Node = pq . poll ( ) ; Mk App Tree Node < O > node = get Node ( pq Node . node ID ) ; if ( ! node . is Leaf ( ) ) { for ( int i = NUM_ ; i < node . get Num Entries ( ) ; i ++ ) { Mk App Entry entry = node . get Entry ( i ) ; double distance = distance ( entry . get Routing Object ID ( ) , id ) ; double min Dist = ( entry . get Covering Radius ( ) > distance ) ? NUM_ : distance - entry . get Covering Radius ( ) ; double approx Value = settings . log ? Math . exp ( entry . approximated Value At ( k ) ) : entry . approximated Value At ( k ) ; if ( approx Value < NUM_ ) { approx Value = NUM_ ; } if ( min Dist <= approx Value ) { pq . add ( new Generic M Tree Distance Search Candidate ( min Dist , get Page ID ( entry ) , entry . get Routing Object ID ( ) ) ) ; } } } else { for ( int i = NUM_ ; i < node . get Num Entries ( ) ; i ++ ) { Mk App Leaf Entry entry = ( Mk App Leaf Entry ) node . get Entry ( i ) ; double distance = distance ( entry . get Routing Object ID ( ) , id ) ; double approx Value = settings . log ? Strict Math . exp ( entry . approximated Value At ( k ) ) : entry . approximated Value At ( k ) ; if ( approx Value < NUM_ ) { approx Value = NUM_ ; } if ( distance <= approx Value ) { result . add ( distance , entry . get Routing Object ID ( ) ) ; } } } } return result ; }
protected Vector 2 D [ ] create Triangle Vertices ( float triangle Size ) { Vector 2 D [ ] p = new Vector 2 D [ NUM_ ] ; double f ; f = NUM_ * Math . PI / NUM_ ; p [ NUM_ ] = new Vector 2 D ( triangle Size * Math . sin ( f ) , triangle Size * Math . cos ( f ) ) ; f = NUM_ * Math . PI / NUM_ ; p [ NUM_ ] = new Vector 2 D ( triangle Size * Math . sin ( f ) , triangle Size * Math . cos ( f ) ) ; f = NUM_ * Math . PI / NUM_ ; p [ NUM_ ] = new Vector 2 D ( triangle Size * Math . sin ( f ) , triangle Size * Math . cos ( f ) ) ; return p ; }
public Builder tag Is Not ( Class < ? > ... tags ) { verify Not Null ( tags ) ; expressions . add ( new Not ( new Event Filter Expression . Tag Is ( tags ) ) ) ; return this ; }
protected final void fire Property Change ( String property Name , Object old Value , Object new Value ) { Property Change Support a Change Support = this . change Support ; if ( a Change Support == null ) { return ; } a Change Support . fire Property Change ( property Name , old Value , new Value ) ; }
public boolean act As Proxy For ( Map Mouse Mode mmm , int pdm ) { Map Mouse Mode omm = mouse Support . get Proxied ( ) ; boolean ret = false ; if ( mmm != null && ! mmm . equals ( omm ) ) { ret = mouse Support . set Proxy For ( mmm , pdm ) ; property Change Support . fire Property Change ( Mouse Delegator . Proxy Mouse Mode Property , omm , mmm ) ; } return ret ; }
public Time Zone read ( String zone ) { return Time Zone . get Time Zone ( zone ) ; }
public static Builder < File > of ( String ... files ) { check For Null ( files , STR_ ) ; check For Empty ( files , STR_ ) ; return Builder . of Strings ( Arrays . as List ( files ) ) ; }
< T > T on Find First ( Class < T > model Class , boolean is Eager ) { List < T > data List = query ( model Class , null , null , null , null , null , STR_ , STR_ , get Foreign Key Associations ( model Class . get Name ( ) , is Eager ) ) ; if ( data List . size ( ) > NUM_ ) { return data List . get ( NUM_ ) ; } return null ; }
public boolean add ( OM Graphic shape ) { return super . add ( shape ) ; }
protected void install Listeners ( ) { super . install Listeners ( ) ; split Pane . add Property Change Listener ( this ) ; }
protected void build Profiles ( ) { m Current Profile View . set Visibility ( View . INVISIBLE ) ; m Account Header Text Section . set Visibility ( View . INVISIBLE ) ; m Account Switcher Arrow . set Visibility ( View . INVISIBLE ) ; m Profile First View . set Visibility ( View . GONE ) ; m Profile First View . set On Click Listener ( null ) ; m Profile Second View . set Visibility ( View . GONE ) ; m Profile Second View . set On Click Listener ( null ) ; m Profile Third View . set Visibility ( View . GONE ) ; m Profile Third View . set On Click Listener ( null ) ; m Current Profile Name . set Text ( STR_ ) ; m Current Profile Email . set Text ( STR_ ) ; handle Selection View ( m Current Profile , true ) ; if ( m Current Profile != null ) { if ( m Profile Images Visible || m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Current Profile View , m Current Profile . get Icon ( ) ) ; if ( m Profile Images Clickable ) { m Current Profile View . set On Click Listener ( on Profile Click Listener ) ; m Current Profile View . disable Touch Feedback ( false ) ; } else { m Current Profile View . disable Touch Feedback ( true ) ; } m Current Profile View . set Visibility ( View . VISIBLE ) ; m Current Profile View . invalidate ( ) ; } else if ( m Compact Style ) { m Current Profile View . set Visibility ( View . GONE ) ; } m Account Header Text Section . set Visibility ( View . VISIBLE ) ; handle Selection View ( m Current Profile , true ) ; m Account Switcher Arrow . set Visibility ( View . VISIBLE ) ; m Current Profile View . set Tag ( R . id . material drawer profile header , m Current Profile ) ; String Holder . apply To ( m Current Profile . get Name ( ) , m Current Profile Name ) ; String Holder . apply To ( m Current Profile . get Email ( ) , m Current Profile Email ) ; if ( m Profile First != null && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile First View , m Profile First . get Icon ( ) ) ; m Profile First View . set Tag ( R . id . material drawer profile header , m Profile First ) ; if ( m Profile Images Clickable ) { m Profile First View . set On Click Listener ( on Profile Click Listener ) ; m Profile First View . disable Touch Feedback ( false ) ; } else { m Profile First View . disable Touch Feedback ( true ) ; } m Profile First View . set Visibility ( View . VISIBLE ) ; m Profile First View . invalidate ( ) ; } if ( m Profile Second != null && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile Second View , m Profile Second . get Icon ( ) ) ; m Profile Second View . set Tag ( R . id . material drawer profile header , m Profile Second ) ; if ( m Profile Images Clickable ) { m Profile Second View . set On Click Listener ( on Profile Click Listener ) ; m Profile Second View . disable Touch Feedback ( false ) ; } else { m Profile Second View . disable Touch Feedback ( true ) ; } m Profile Second View . set Visibility ( View . VISIBLE ) ; m Profile Second View . invalidate ( ) ; } if ( m Profile Third != null && m Three Small Profile Images && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile Third View , m Profile Third . get Icon ( ) ) ; m Profile Third View . set Tag ( R . id . material drawer profile header , m Profile Third ) ; if ( m Profile Images Clickable ) { m Profile Third View . set On Click Listener ( on Profile Click Listener ) ; m Profile Third View . disable Touch Feedback ( false ) ; } else { m Profile Third View . disable Touch Feedback ( true ) ; } m Profile Third View . set Visibility ( View . VISIBLE ) ; m Profile Third View . invalidate ( ) ; } } else if ( m Profiles != null && m Profiles . size ( ) > NUM_ ) { I Profile profile = m Profiles . get ( NUM_ ) ; m Account Header Text Section . set Tag ( R . id . material drawer profile header , profile ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; handle Selection View ( m Current Profile , true ) ; m Account Switcher Arrow . set Visibility ( View . VISIBLE ) ; if ( m Current Profile != null ) { String Holder . apply To ( m Current Profile . get Name ( ) , m Current Profile Name ) ; String Holder . apply To ( m Current Profile . get Email ( ) , m Current Profile Email ) ; } } if ( ! m Selection First Line Shown ) { m Current Profile Name . set Visibility ( View . GONE ) ; } if ( ! Text Utils . is Empty ( m Selection First Line ) ) { m Current Profile Name . set Text ( m Selection First Line ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; } if ( ! m Selection Second Line Shown ) { m Current Profile Email . set Visibility ( View . GONE ) ; } if ( ! Text Utils . is Empty ( m Selection Second Line ) ) { m Current Profile Email . set Text ( m Selection Second Line ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; } if ( ! m Selection List Enabled ) { m Account Switcher Arrow . set Visibility ( View . INVISIBLE ) ; handle Selection View ( null , false ) ; } if ( ! m Selection List Enabled For Single Profile && m Profile First == null && ( m Profiles == null || m Profiles . size ( ) == NUM_ ) ) { m Account Switcher Arrow . set Visibility ( View . INVISIBLE ) ; handle Selection View ( null , false ) ; } if ( m On Account Header Selection View Click Listener != null ) { handle Selection View ( m Current Profile , true ) ; } }
private String [ ] compute Segments ( String path ) { int segment Count = compute Segment Count ( path ) ; if ( segment Count == NUM_ ) return NO SEGMENTS ; String [ ] new Segments = new String [ segment Count ] ; int len = path . length ( ) ; int first Position = ( path . char At ( NUM_ ) == SEPARATOR ) ? NUM_ : NUM_ ; if ( first Position == NUM_ && len > NUM_ && ( path . char At ( NUM_ ) == SEPARATOR ) ) first Position = NUM_ ; int last Position = ( path . char At ( len - NUM_ ) != SEPARATOR ) ? len - NUM_ : len - NUM_ ; int next = first Position ; for ( int i = NUM_ ; i < segment Count ; i ++ ) { int start = next ; int end = path . index Of ( SEPARATOR , next ) ; if ( end == - NUM_ ) { new Segments [ i ] = path . substring ( start , last Position + NUM_ ) ; } else { new Segments [ i ] = path . substring ( start , end ) ; } next = end + NUM_ ; } return new Segments ; }
private static void write Op ( byte [ ] in Buffer , int in Offset , int count , byte [ ] out Buffer , int write pos , int buff len ) { if ( ( write pos + count ) <= buff len ) { System . arraycopy ( in Buffer , in Offset , out Buffer , write pos , count ) ; } else { int till End Count ; int from Start Count ; till End Count = buff len - write pos ; from Start Count = count - till End Count ; System . arraycopy ( in Buffer , in Offset , out Buffer , write pos , till End Count ) ; System . arraycopy ( in Buffer , in Offset + till End Count , out Buffer , NUM_ , from Start Count ) ; } }
public static Matrix linear Gradient Matrix ( Scalable Gradient Node gradient , Rect path Bounds ) { FXG Matrix matrix = new FXG Matrix ( ) ; Matrix Node mtx Node = gradient . get Matrix Node ( ) ; if ( mtx Node != null ) { matrix . translate ( GRADIENT DIMENSION / NUM_ , GRADIENT DIMENSION / NUM_ ) ; matrix . scale ( NUM_ / GRADIENT DIMENSION , NUM_ / GRADIENT DIMENSION ) ; FXG Matrix node Matrix = new FXG Matrix ( mtx Node ) ; matrix . concat ( node Matrix ) ; return matrix . to SWF Matrix ( ) ; } double width = ( path Bounds . x Max - path Bounds . x Min ) / ( double ) Swf Constants . TWIPS PER PIXEL ; double height = ( path Bounds . y Max - path Bounds . y Min ) / ( double ) Swf Constants . TWIPS PER PIXEL ; double scale X = gradient . get Scale X ( ) ; double rotation = gradient . get Rotation ( ) ; double tx = gradient . get X ( ) ; double ty = gradient . get Y ( ) ; if ( Double . is Na N ( scale X ) ) { if ( rotation % NUM_ != NUM_ ) { double normalized Angle = rotation % NUM_ ; if ( normalized Angle < NUM_ ) normalized Angle += NUM_ ; normalized Angle %= NUM_ ; if ( normalized Angle > NUM_ ) normalized Angle = NUM_ - normalized Angle ; double side = width ; double hypotenuse = Math . sqrt ( width * width + height * height ) ; double hypotenuse Angle = Math . acos ( width / hypotenuse ) * NUM_ / Math . PI ; if ( normalized Angle > hypotenuse Angle ) { normalized Angle = NUM_ - normalized Angle ; side = height ; } scale X = side / Math . cos ( normalized Angle / NUM_ * Math . PI ) ; } else { scale X = ( rotation % NUM_ ) == NUM_ ? width : height ; } } if ( ! Double . is Na N ( tx ) && Double . is Na N ( ty ) ) ty = NUM_ ; if ( Double . is Na N ( tx ) && ! Double . is Na N ( ty ) ) tx = NUM_ ; if ( ! Double . is Na N ( tx ) && ! Double . is Na N ( ty ) ) matrix . translate ( Swf Constants . GRADIENT SQUARE / ( NUM_ * Swf Constants . TWIPS PER PIXEL ) , Swf Constants . GRADIENT SQUARE / ( NUM_ * Swf Constants . TWIPS PER PIXEL ) ) ; if ( Math . abs ( scale X ) < NUM_ ) scale X = ( scale X < NUM_ ) ? - NUM_ : NUM_ ; scale X = ( scale X * Swf Constants . TWIPS PER PIXEL ) / Swf Constants . GRADIENT SQUARE ; matrix . scale ( scale X , NUM_ ) ; if ( ! Double . is Na N ( rotation ) ) matrix . rotate ( rotation ) ; if ( Double . is Na N ( tx ) ) tx = width / NUM_ + path Bounds . x Min / ( double ) Swf Constants . TWIPS PER PIXEL ; if ( Double . is Na N ( ty ) ) ty = height / NUM_ + + path Bounds . y Min / ( double ) Swf Constants . TWIPS PER PIXEL ; matrix . translate ( tx , ty ) ; return matrix . to SWF Matrix ( ) ; }
public static boolean is Same Event ( Calendar Event Model model , Calendar Event Model original Model ) { if ( original Model == null ) { return true ; } if ( model . m Calendar Id != original Model . m Calendar Id ) { return false ; } if ( model . m Id != original Model . m Id ) { return false ; } return true ; }
public static Remote export Object ( Remote obj ) throws Remote Exception { int port = NUM_ ; port += Randomness . next Int ( NUM_ ) ; final int TRIES = NUM_ ; for ( int i = NUM_ ; i < TRIES ; i ++ ) { try { int candidate Port = port + i ; return Unicast Remote Object . export Object ( obj , candidate Port ) ; } catch ( Remote Exception e ) { } } return Unicast Remote Object . export Object ( obj , port ) ; }
protected void add Auth Config Listener ( String service , String name ) { Set < String > set = auth Config Listener Map . get ( service ) ; if ( set == null ) { set = new Copy On Write Array Set < > ( ) ; set . add ( name ) ; auth Config Listener Map . put ( service , set ) ; } else { set . add ( name ) ; } }
private boolean is Model Useful ( Ada Boost Performance Measures wp ) { return ( wp . get Error Rate ( ) < NUM_ ) ; }
@ Override public Value sample ( Assignment condition ) { Independent Distribution result = get Prob Distrib ( condition ) ; return result . sample ( ) ; }
public synchronized void remove Consumer ( Image Consumer ic ) { the Consumers . remove Element ( ic ) ; }
public ISO 9796 d 2 Signer ( Asymmetric Block Cipher cipher , Digest digest , boolean implicit ) { this . cipher = cipher ; this . digest = digest ; if ( implicit ) { trailer = TRAILER IMPLICIT ; } else { Integer trailer Obj = ( Integer ) trailer Map . get ( digest . get Algorithm Name ( ) ) ; if ( trailer Obj != null ) { trailer = trailer Obj . int Value ( ) ; } else { throw new Illegal Argument Exception ( STR_ ) ; } } }
public static boolean is Bridge Method ( Method some Method ) { Trait Bridge annotation = some Method . get Annotation ( Trait Bridge . class ) ; return annotation != null ; }
public Bean Property Mutator build Mutator ( My Class Loader class Loader ) { if ( class Loader == null ) { class Loader = new My Class Loader ( bean Class . get Class Loader ( ) , true ) ; } final Class Name base Name = Class Name . construct For ( bean Class , STR_ ) ; Class < ? > accessor Class = generate Mutator Class ( class Loader , base Name ) ; try { return ( Bean Property Mutator ) accessor Class . new Instance ( ) ; } catch ( Exception e ) { throw new Illegal State Exception ( STR_ + accessor Class . get Name ( ) + STR_ + e . get Message ( ) , e ) ; } }
public static final int hash Code ( final double [ ] v 1 ) { return Arrays . hash Code ( v 1 ) ; }
protected void install Key Handler ( ) { text Area . add Key Listener ( key Listener ) ; editor Pane . add Key Listener ( key Listener ) ; }
public void add Split ( String split Label ) { if ( m Disabled ) return ; long now = System Clock . elapsed Realtime ( ) ; m Splits . add ( now ) ; m Split Labels . add ( split Label ) ; }
public Ssh Pair Impl generate Pair ( String owner , String service , String name ) throws Server Exception , Conflict Exception { Key Pair key Pair ; try { key Pair = Key Pair . gen Key Pair ( gen J Sch , NUM_ , NUM_ ) ; } catch ( J Sch Exception e ) { throw new Server Exception ( STR_ , e ) ; } Byte Array Output Stream private Buff = new Byte Array Output Stream ( ) ; key Pair . write Private Key ( private Buff ) ; Byte Array Output Stream public Buff = new Byte Array Output Stream ( ) ; key Pair . write Public Key ( public Buff , null ) ; final Ssh Pair Impl generated Ssh Pair = new Ssh Pair Impl ( owner , service , name , public Buff . to String ( ) , private Buff . to String ( ) ) ; ssh Dao . create ( generated Ssh Pair ) ; return generated Ssh Pair ; }
public void bind ( Object object ) { Class < ? > object Class = object . get Class ( ) ; while ( object Class != null && object Class != Object . class ) { Binder Cache cache = class Binder Cache Map . get ( object Class ) ; if ( cache == null ) { cache = create Cache ( object Class ) ; class Binder Cache Map . put ( object Class , cache ) ; } bind ( object , cache ) ; object Class = object Class . get Superclass ( ) ; } }
public Builder source Is ( Source ... source ) { verify Not Null ( source ) ; expressions . add ( new Event Filter Expression . Source Is ( source ) ) ; return this ; }
protected void layout Minor Axis ( int target Span , int axis , int [ ] offsets , int [ ] spans ) { int n = get View Count ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { View v = get View ( i ) ; int max = ( int ) v . get Maximum Span ( axis ) ; if ( max < target Span ) { float align = v . get Alignment ( axis ) ; offsets [ i ] = ( int ) ( ( target Span - max ) * align ) ; spans [ i ] = max ; } else { int min = ( int ) v . get Minimum Span ( axis ) ; offsets [ i ] = NUM_ ; spans [ i ] = Math . max ( min , target Span ) ; } } }
private Server Target find Target Server ( String address , int port ) { for ( Server Target target : targets ) { Server Bartender server = target . get Server ( ) ; if ( address . equals ( server . get Address ( ) ) && port == server . port ( ) ) { return target ; } } return null ; }
public void remove Change Listener ( Change Listener cl ) { listeners . remove ( cl ) ; }
@ Override public void show ( Class < ? > parent Class , Class < ? > class Selected ) { if ( class Selected != null ) { String key = class Selected . to String ( ) ; Populate Details Interface panel = get Panel ( parent Class , key ) ; if ( panel != null ) { Card Layout cl = ( Card Layout ) ( details Panel . get Layout ( ) ) ; cl . show ( details Panel , encode Panel Key ( key , panel ) ) ; Selected Symbol selected Symbol = Selected Symbol . get Instance ( ) ; panel . populate ( selected Symbol ) ; } } repaint ( ) ; }
public static < Rule Type extends Message > Config Rule Set < Rule Type > of ( Descriptor rule Descriptor , List < Rule Type > rules , Model model ) { return new Config Rule Set < Rule Type > ( rule Descriptor , rules , model ) ; }
private double [ ] interpolate Non Zero Values ( double [ ] contour ) { for ( int i = NUM_ ; i < contour . length ; i ++ ) { if ( contour [ i ] == NUM_ ) { int index = find Next Index Non Zero ( contour , i ) ; if ( index == - NUM_ ) { for ( int j = i ; j < contour . length ; j ++ ) { contour [ j ] = contour [ j - NUM_ ] ; } break ; } else { for ( int j = i ; j < index ; j ++ ) { if ( i == NUM_ ) { contour [ j ] = contour [ index ] ; } else { contour [ j ] = contour [ j - NUM_ ] + ( ( contour [ index ] - contour [ i - NUM_ ] ) / ( index - i ) ) ; } } i = index - NUM_ ; } } } return contour ; }
public boolean is Native ( ) { return Modifier . is Native ( flags ) ; }
public static int direct Blow Infantry Damage ( double damage , int mos , int damage Type , boolean is Non Infantry Against Mechanized , boolean is Attack Thru Building , int attacker Id , Vector < Report > v Report ) { int orig Damage Type = damage Type ; damage Type += mos ; double orig Damage = damage ; switch ( damage Type ) { case Weapon Type . WEAPON DIRECT FIRE : damage /= NUM_ ; break ; case Weapon Type . WEAPON CLUSTER BALLISTIC : damage /= NUM_ ; damage ++ ; break ; case Weapon Type . WEAPON PULSE : damage /= NUM_ ; damage += NUM_ ; break ; case Weapon Type . WEAPON CLUSTER MISSILE : damage /= NUM_ ; break ; case Weapon Type . WEAPON CLUSTER MISSILE 1 D 6 : damage /= NUM_ ; damage += Compute . d 6 ( ) ; break ; case Weapon Type . WEAPON CLUSTER MISSILE 2 D 6 : damage /= NUM_ ; damage += Compute . d 6 ( NUM_ ) ; break ; case Weapon Type . WEAPON CLUSTER MISSILE 3 D 6 : damage /= NUM_ ; damage += Compute . d 6 ( NUM_ ) ; break ; case Weapon Type . WEAPON BURST HALFD 6 : damage = Compute . d 6 ( ) / NUM_ ; if ( is Attack Thru Building ) { damage *= NUM_ ; } break ; case Weapon Type . WEAPON BURST 1 D 6 : damage = Compute . d 6 ( ) ; if ( is Attack Thru Building ) { damage *= NUM_ ; } break ; case Weapon Type . WEAPON BURST 2 D 6 : damage = Compute . d 6 ( NUM_ ) ; if ( is Attack Thru Building ) { damage *= NUM_ ; } break ; case Weapon Type . WEAPON BURST 3 D 6 : damage = Compute . d 6 ( NUM_ ) ; if ( is Attack Thru Building ) { damage *= NUM_ ; } break ; case Weapon Type . WEAPON BURST 4 D 6 : damage = Compute . d 6 ( NUM_ ) ; if ( is Attack Thru Building ) { damage *= NUM_ ; } break ; case Weapon Type . WEAPON BURST 5 D 6 : damage = Compute . d 6 ( NUM_ ) ; if ( is Attack Thru Building ) { damage *= NUM_ ; } break ; case Weapon Type . WEAPON BURST 6 D 6 : damage = Compute . d 6 ( NUM_ ) ; if ( is Attack Thru Building ) { damage *= NUM_ ; } break ; case Weapon Type . WEAPON BURST 7 D 6 : damage = Compute . d 6 ( NUM_ ) ; if ( is Attack Thru Building ) { damage *= NUM_ ; } break ; } damage = Math . ceil ( damage ) ; if ( is Non Infantry Against Mechanized ) { if ( damage Type < Weapon Type . WEAPON BURST HALFD 6 ) { damage *= NUM_ ; } else { damage /= NUM_ ; } } if ( v Report != null ) { Report r = new Report ( ) ; r . subject = attacker Id ; r . indent ( NUM_ ) ; r . add ( get Damage Type String ( orig Damage Type ) ) ; if ( orig Damage Type != damage Type ) { if ( is Attack Thru Building ) { r . message Id = NUM_ ; } else { r . message Id = NUM_ ; } r . add ( get Damage Type String ( damage Type ) ) ; } else if ( is Attack Thru Building ) { r . message Id = NUM_ ; } else { r . message Id = NUM_ ; } r . add ( ( int ) orig Damage ) ; r . add ( ( int ) damage ) ; v Report . add Element ( r ) ; } return ( int ) damage ; }
@ Override public URI to Vertex URI ( final Object key ) { return to URI ( key . to String ( ) ) ; }
public MGRS Point ( ) { DEBUG = logger . is Loggable ( Level . FINE ) ; }
protected void thread Stop ( ) { if ( thread == null ) { return ; } thread Done = true ; thread . interrupt ( ) ; try { thread . join ( ) ; } catch ( Interrupted Exception e ) { ; } thread = null ; }
private void add Programmer Box ( ) { J Panel pane 3 a = new J Panel ( ) ; pane 3 a . set Layout ( new Box Layout ( pane 3 a , Box Layout . X AXIS ) ) ; pane 3 a . add ( new J Label ( Bundle . get Message ( STR_ ) ) ) ; programmer Box = new J Combo Box < String > ( Prog Default . find List Of Prog Files ( ) ) ; programmer Box . set Selected Index ( NUM_ ) ; if ( Prog Default . get Default Prog File ( ) != null ) { programmer Box . set Selected Item ( Prog Default . get Default Prog File ( ) ) ; } pane 3 a . add ( programmer Box ) ; add ( pane 3 a ) ; }
private Token create Vm Args Token ( ) { String Builder jvm Args = new String Builder ( ) ; File hot Fix Jar = new File ( jrun Container . get Home ( ) + STR_ ) ; if ( hot Fix Jar . exists ( ) ) { jvm Args . append ( STR_ ) ; } jvm Args . append ( STR_ ) ; jvm Args . append ( STR_ ) ; jvm Args . append ( STR_ ) ; jvm Args . append ( STR_ ) ; Replace Tokens . Token token Vm Args = new Replace Tokens . Token ( ) ; token Vm Args . set Key ( STR_ ) ; token Vm Args . set Value ( jvm Args . to String ( ) ) ; return token Vm Args ; }
private void initialize Population 2 D ( int population Size ) { population = new Array List < Individual > ( population Size ) ; population . add ( new Individual ( new double [ ] { NUM_ , NUM_ } ) ) ; population . add ( new Individual ( new double [ ] { NUM_ , NUM_ } ) ) ; for ( int i = NUM_ ; i < population Size - NUM_ ; i ++ ) { double a = i / ( double ) ( population Size - NUM_ ) ; population . add ( new Individual ( new double [ ] { a , NUM_ - a } ) ) ; } }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof Object Identifier == false ) { return false ; } Object Identifier other = ( Object Identifier ) obj ; return Arrays . equals ( encoding , other . encoding ) ; }
private V User Manager Service ( Context context , V Package Manager Service pm , Object install Lock , Object packages Lock , File data Dir , File base User Path ) { m Context = context ; m Pm = pm ; m Install Lock = install Lock ; m Packages Lock = packages Lock ; synchronized ( m Install Lock ) { synchronized ( m Packages Lock ) { m Users Dir = new File ( data Dir , USER INFO DIR ) ; m Users Dir . mkdirs ( ) ; File user Zero Dir = new File ( m Users Dir , STR_ ) ; user Zero Dir . mkdirs ( ) ; m Base User Path = base User Path ; m User List File = new File ( m Users Dir , USER LIST FILENAME ) ; read User List Locked ( ) ; Array List < V User Info > partials = new Array List < V User Info > ( ) ; for ( int i = NUM_ ; i < m Users . size ( ) ; i ++ ) { V User Info ui = m Users . value At ( i ) ; if ( ui . partial && i != NUM_ ) { partials . add ( ui ) ; } } for ( int i = NUM_ ; i < partials . size ( ) ; i ++ ) { V User Info ui = partials . get ( i ) ; V Log . w ( LOG TAG , STR_ + i + STR_ + ui . name + STR_ ) ; remove User State Locked ( ui . id ) ; } s Instance = this ; } } }
public synchronized void reset ( ) { timer . start ( STR_ ) ; if ( line != null ) { wait Resume ( ) ; if ( is Cancelled ( ) && ! is Done ( ) ) { cancelled = false ; line . start ( ) ; } } }
protected void notify On Size Change Listener ( int width , int height ) { if ( last Notified Size . x == width && last Notified Size . y == height ) { return ; } last Notified Size . x = width ; last Notified Size . y = height ; if ( on Size Change Listener != null ) { on Size Change Listener . on Video Surface Size Change ( width , height ) ; } }
public void release Write Lock On Key ( K id ) { if ( id != null ) { cache . release Write Lock On Key ( id ) ; if ( LOGGER . is Trace Enabled ( ) ) { LOGGER . trace ( cache . get Name ( ) + STR_ + String . value Of ( id ) ) ; } } else { LOGGER . error ( STR_ ) ; throw new Illegal Argument Exception ( STR_ ) ; } }
private static void add Children ( Lop node , Array List < Lop > node v , Array List < Lop > exec n ) { if ( exec n . contains ( node ) && node . get Exec Location ( ) != Exec Location . Control Program ) { if ( ! node v . contains ( node ) ) { node v . add ( node ) ; if ( LOG . is Trace Enabled ( ) ) LOG . trace ( STR_ + node . to String ( ) ) ; } } if ( ! exec n . contains ( node ) ) return ; for ( Lop n : node . get Inputs ( ) ) { add Children ( n , node v , exec n ) ; } }
public synchronized I Tag read Tag ( ) { if ( ! first Tags . is Empty ( ) ) { return first Tags . remove First ( ) ; } MP 4 Frame frame = frames . get ( current Frame ) ; log . debug ( STR_ , current Frame , frame ) ; int sample Size = frame . get Size ( ) ; int time = ( int ) Math . round ( frame . get Time ( ) * NUM_ ) ; long sample Pos = frame . get Offset ( ) ; byte type = frame . get Type ( ) ; int pad = NUM_ ; if ( type == TYPE AUDIO ) { pad = NUM_ ; } Byte Buffer data = Byte Buffer . allocate ( sample Size + pad ) ; try { if ( type == TYPE VIDEO ) { if ( frame . is Key Frame ( ) ) { data . put ( PREFIX VIDEO KEYFRAME ) ; } else { data . put ( PREFIX VIDEO FRAME ) ; } int time Offset = prev Video TS != - NUM_ ? time - prev Video TS : NUM_ ; data . put ( ( byte ) ( ( time Offset > > > NUM_ ) & NUM_ ) ) ; data . put ( ( byte ) ( ( time Offset > > > NUM_ ) & NUM_ ) ) ; data . put ( ( byte ) ( time Offset & NUM_ ) ) ; if ( log . is Trace Enabled ( ) ) { byte [ ] prefix = new byte [ NUM_ ] ; int p = data . position ( ) ; data . position ( NUM_ ) ; data . get ( prefix ) ; data . position ( p ) ; log . trace ( STR_ , prefix ) ; } video Count ++ ; prev Video TS = time ; } else { data . put ( PREFIX AUDIO FRAME ) ; audio Count ++ ; } channel . position ( sample Pos ) ; channel . read ( data ) ; } catch ( IO Exception e ) { log . error ( STR_ , e ) ; } Io Buffer payload = Io Buffer . wrap ( data . array ( ) ) ; I Tag tag = new Tag ( type , time , payload . limit ( ) , payload , prev Frame Size ) ; current Frame ++ ; prev Frame Size = tag . get Body Size ( ) ; return tag ; }
private Workflow . Method create Detach Mirror Method ( URI vplex URI , URI vplex Volume URI , URI mirror Volume URI , URI cg URI ) { return new Workflow . Method ( DETACH MIRROR METHOD NAME , vplex URI , vplex Volume URI , mirror Volume URI , cg URI ) ; }
public static void push Node Namespace ( Node node , Stack < Prefix Mapping > namespaces ) { String uri = node . get Namespace ( ) ; for ( int i = NUM_ , size = namespaces . size ( ) ; i < size ; i ++ ) { Prefix Mapping pm = namespaces . get ( i ) ; if ( pm . equals ( uri ) ) { namespaces . push ( pm ) ; return ; } } namespaces . push ( new Prefix Mapping ( uri ) ) ; }
public Builder add Integer Derived Column ( String column Name , Date Time Field Type type ) { derived Columns . add ( new Derived Column ( column Name , Column Type . Integer , null , null , type ) ) ; return this ; }
public void add Target ( Point target ) { targets . add ( target ) ; }
public String Hmm F 0 Generation ( HTS Utt Model um , HMM Data hts Data ) throws Exception { int frame , utt Frame , lf 0 Frame ; int hmm State , k , n , i ; boolean nobound ; HTS Model m ; HTSP Stream lf 0 Pst = null ; boolean voiced [ ] ; Cart Tree Set ms = hts Data . get Cart Tree Set ( ) ; lf 0 Pst = new HTSP Stream ( ms . get Lf 0 Stream ( ) , um . get Lf 0 Frame ( ) , HMM Data . Feature Type . LF 0 , NUM_ ) ; utt Frame = lf 0 Frame = NUM_ ; voiced = new boolean [ um . get Total Frame ( ) ] ; for ( i = NUM_ ; i < um . get Num Utt Model ( ) ; i ++ ) { m = um . get Utt Model ( i ) ; for ( hmm State = NUM_ ; hmm State < ms . get Num States ( ) ; hmm State ++ ) for ( frame = NUM_ ; frame < m . get Dur ( hmm State ) ; frame ++ ) { voiced [ utt Frame ] = m . get Voiced ( hmm State ) ; utt Frame ++ ; if ( m . get Voiced ( hmm State ) ) lf 0 Frame ++ ; } } utt Frame = NUM_ ; lf 0 Frame = NUM_ ; for ( i = NUM_ ; i < um . get Num Utt Model ( ) ; i ++ ) { m = um . get Utt Model ( i ) ; for ( hmm State = NUM_ ; hmm State < ms . get Num States ( ) ; hmm State ++ ) { for ( frame = NUM_ ; frame < m . get Dur ( hmm State ) ; frame ++ ) { for ( k = NUM_ ; k < ms . get Lf 0 Stream ( ) ; k ++ ) { int lw = lf 0 Pst . get DW Left Boundary ( k ) ; int rw = lf 0 Pst . get DW Right Boundary ( k ) ; nobound = true ; for ( n = lw ; n <= rw ; n ++ ) if ( ( utt Frame + n ) <= NUM_ || um . get Total Frame ( ) <= ( utt Frame + n ) ) nobound = false ; else nobound = ( nobound && voiced [ utt Frame + n ] ) ; if ( voiced [ utt Frame ] ) { lf 0 Pst . set Mseq ( lf 0 Frame , k , m . get Lf 0 Mean ( hmm State , k ) ) ; if ( nobound || k == NUM_ ) lf 0 Pst . set Ivseq ( lf 0 Frame , k , HTS Parameter Generation . finv ( m . get Lf 0 Variance ( hmm State , k ) ) ) ; else lf 0 Pst . set Ivseq ( lf 0 Frame , k , NUM_ ) ; } } if ( voiced [ utt Frame ] ) lf 0 Frame ++ ; utt Frame ++ ; } } } double f 0 s [ ] = new double [ voiced . length ] ; i = NUM_ ; if ( lf 0 Frame > NUM_ ) { Log . i ( Mary . LOG , STR_ ) ; lf 0 Pst . mlpg ( hts Data , hts Data . get Use GV ( ) ) ; for ( int t = NUM_ ; t < voiced . length ; t ++ ) { if ( voiced [ t ] ) { f 0 s [ t ] = Math . exp ( lf 0 Pst . get Par ( i , NUM_ ) ) ; i ++ ; } else f 0 s [ t ] = NUM_ ; } } double total Dur ; int total Frames ; String f 0 Values = STR_ ; int t = NUM_ ; for ( i = NUM_ ; i < um . get Num Utt Model ( ) ; i ++ ) { m = um . get Utt Model ( i ) ; f 0 Values += m . get Phone Name ( ) + STR_ + m . get Total Dur Millisec ( ) + STR_ ; total Dur = m . get Total Dur ( ) ; total Frames = NUM_ ; if ( check Model Voiced ( m , ms . get Num States ( ) ) ) { for ( int j = NUM_ ; j < ms . get Num States ( ) ; j ++ ) { for ( frame = NUM_ ; frame < m . get Dur ( j ) ; frame ++ ) { total Frames ++ ; if ( f 0 s [ t ] > NUM_ ) f 0 Values += STR_ + Integer . to String ( ( int ) ( ( total Frames / total Dur ) * NUM_ ) ) + STR_ + Integer . to String ( ( int ) f 0 s [ t ] ) + STR_ ; t ++ ; } } } else { t = t + m . get Total Dur ( ) ; f 0 Values += STR_ ; } f 0 Values += STR_ ; } return ( f 0 Values ) ; }
protected final void fire Property Change ( String property Name , float old Value , float new Value ) { fire Property Change ( property Name , Float . value Of ( old Value ) , Float . value Of ( new Value ) ) ; }
public static String to Header Element ( String name , String value ) { return O Auth . percent Encode ( name ) + STR_ + O Auth . percent Encode ( value ) + STR_ ; }
protected void init Postmaster Signs ( ) { set Postmaster Signs ( ( get Init Parameter ( STR_ ) == null ) ? false : Boolean . value Of ( get Init Parameter ( STR_ ) ) ) ; }
public Repl DBMS Header last Commit Seqno ( ) throws Replicator Exception { try { Repl DBMS Header Data header = null ; Result Set res = null ; try { last Seqno Query . set Int ( NUM_ , task Id ) ; res = last Seqno Query . execute Query ( ) ; if ( res . next ( ) ) { header = header From Result ( res ) ; } } finally { connection Manager . close ( res ) ; } return header ; } catch ( SQL Exception e ) { throw new Replicator Exception ( STR_ + e . get Message ( ) , e ) ; } }
protected static MV Store open Store ( String file Name ) { return open Store ( file Name , NUM_ ) ; }
public List < Shard Routing > all Shards ( String index ) { List < Shard Routing > shards = new Array List < > ( ) ; Index Routing Table index Routing Table = index ( index ) ; if ( index Routing Table == null ) { throw new Index Not Found Exception ( index ) ; } for ( Index Shard Routing Table index Shard Routing Table : index Routing Table ) { for ( Shard Routing shard Routing : index Shard Routing Table ) { shards . add ( shard Routing ) ; } } return shards ; }
public static < T > List < T > unpatch ( List < T > revised , Patch < T > patch ) { return patch . restore ( revised ) ; }
public static void run ( String cmd ) throws Keyword Optimizer Exception { if ( cmd . is Empty ( ) ) { run ( new String [ ] { } ) ; } else { run ( cmd . split ( STR_ ) ) ; } }
protected final void fire Vetoable Change ( String property Name , boolean old Value , boolean new Value ) throws Property Veto Exception { Vetoable Change Support a Veto Support = this . veto Support ; if ( a Veto Support == null ) { return ; } a Veto Support . fire Vetoable Change ( property Name , old Value , new Value ) ; }
private void pad ( String Builder sb , int length ) { while ( sb . length ( ) < length ) { sb . append ( STR_ ) ; } }
public void find Charge Element ID ( ) { m C Acct Schema ID = Env . get Context As Int ( Env . get Ctx ( ) , STR_ ) ; String sql = STR_ + STR_ + STR_ ; try { Prepared Statement pstmt = DB . prepare Statement ( sql , null ) ; pstmt . set Int ( NUM_ , m C Acct Schema ID ) ; Result Set rs = pstmt . execute Query ( ) ; if ( rs . next ( ) ) { m C Element ID = rs . get Int ( NUM_ ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( SQL Exception exception ) { log . log ( Level . SEVERE , sql , exception ) ; } }
private static Path 2 D create Top Tab Shape ( int x , int y , int w , int h , double r Top , boolean add Bottom ) { Path 2 D path = new Path 2 D . Double ( ) ; path . append ( new Line 2 D . Double ( x , y + h - NUM_ , x , y + r Top ) , true ) ; Quad Curve 2 D curve = new Quad Curve 2 D . Double ( x , y + r Top , x , y , x + r Top , y ) ; path . append ( curve , true ) ; path . append ( new Line 2 D . Double ( x + r Top , y , x + w - r Top , y ) , true ) ; curve = new Quad Curve 2 D . Double ( x + w - r Top , y , x + w , y , x + w , y + r Top ) ; path . append ( curve , true ) ; path . append ( new Line 2 D . Double ( x + w , y + r Top , x + w , y + h ) , true ) ; if ( add Bottom ) { path . append ( new Line 2 D . Double ( x + w , y + h - NUM_ , x , y + h - NUM_ ) , true ) ; } return path ; }
public static void swap Pivot ( Matrix source , long diag , Matrix s , Matrix t ) { long swap Row = diag ; long swap Col = diag ; double max Value = Math . abs ( source . get As Double ( diag , diag ) ) ; long rows = source . get Row Count ( ) ; long cols = source . get Column Count ( ) ; double abs = NUM_ ; for ( long row = diag ; row < rows ; row ++ ) { for ( long col = diag ; col < cols ; col ++ ) { abs = Math . abs ( source . get As Double ( row , col ) ) ; if ( abs > max Value ) { max Value = abs ; swap Row = row ; swap Col = col ; } } } if ( swap Row != diag ) { swap Rows ( source , swap Row , diag ) ; swap Rows ( t , swap Row , diag ) ; } if ( swap Col != diag ) { swap Cols ( source , swap Col , diag ) ; swap Cols ( s , swap Col , diag ) ; } }
public static int create Serial Number ( ) { for ( ; ; ) { int result = serial Number Sequencer . increment And Get ( ) ; if ( result != ILLEGAL SERIAL ) { return result ; } } }
private Map map Name To Display Name ( Set names ) { Map map = new Hash Map ( names . size ( ) * NUM_ ) ; AM View Config v Config = AM View Config . get Instance ( ) ; for ( Iterator iter = names . iterator ( ) ; iter . has Next ( ) ; ) { String name = ( String ) iter . next ( ) ; if ( v Config . is Service Visible ( name ) ) { String display Name = get Localized Service Name ( name ) ; if ( ! name . equals ( display Name ) ) { map . put ( name , display Name ) ; } } } return map ; }
public int compare To ( @ Non Null Cpu State other ) { return Integer . compare ( freq , other . freq ) ; }
public void unregister ( String key ) throws Registry Exception { try { registry . unbind ( key ) ; } catch ( Exception e ) { throw new Registry Exception ( STR_ + key + STR_ , e ) ; } }
private boolean load Section Order ( ) { return load Section Order ( service Name + FILENAME SUFFIX ) ; }
public static void assert Chi Square Accept ( int [ ] values , double [ ] expected , long [ ] observed , double alpha ) { String [ ] labels = new String [ values . length ] ; for ( int i = NUM_ ; i < values . length ; i ++ ) { labels [ i ] = Integer . to String ( values [ i ] ) ; } assert Chi Square Accept ( labels , expected , observed , alpha ) ; }
private void scan ( Call Graph Node node ) throws CFG Builder Exception { Method method = node . get Method ( ) ; CFG cfg = class Context . get CFG ( method ) ; if ( method . is Synchronized ( ) ) { has Synchronization = true ; } Iterator < Basic Block > i = cfg . block Iterator ( ) ; while ( i . has Next ( ) ) { Basic Block block = i . next ( ) ; Iterator < Instruction Handle > j = block . instruction Iterator ( ) ; while ( j . has Next ( ) ) { Instruction Handle handle = j . next ( ) ; Instruction ins = handle . get Instruction ( ) ; if ( ins instanceof Invoke Instruction ) { Invoke Instruction inv = ( Invoke Instruction ) ins ; Method called = is Self Call ( inv ) ; if ( called != null ) { Call Site call Site = new Call Site ( method , block , handle ) ; call Graph . create Edge ( node , call Graph . get Node For Method ( called ) , call Site ) ; called Method Set . add ( called ) ; } } else if ( ins instanceof MONITORENTER || ins instanceof MONITOREXIT ) { has Synchronization = true ; } } } }
@ Override public void on Tab Closing ( long time , int id ) { reset ( ) ; force Animation To Finish ( ) ; Tab Model model = m Tab Model Selector . get Model For Tab Id ( id ) ; if ( model != null ) { m Closed Tab = create Layout Tab ( id , model . is Incognito ( ) , NO CLOSE BUTTON , NO TITLE ) ; m Closed Tab . set Border Alpha ( NUM_ ) ; m Layout Tabs = new Layout Tab [ ] { m Closed Tab } ; update Cache Visible Ids ( new Linked List < Integer > ( Arrays . as List ( id ) ) ) ; } else { m Layout Tabs = null ; m Closed Tab = null ; } super . on Tab Closing ( time , id ) ; }
public void on Stopping ( ) { sys Stopping = true ; }
public boolean remove Allowed ( Class < ? > c , String display Name ) { boolean result ; Hash Set < String > list ; result = false ; list = m Allowed . get ( c ) ; if ( list != null ) { result = list . remove ( display Name ) ; } return result ; }
public static void main ( String [ ] args ) { Log . print Line ( STR_ ) ; try { int num user = NUM_ ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = false ; Cloud Sim . init ( num user , calendar , trace flag ) ; @ Suppress Warnings ( STR_ ) Datacenter datacenter 0 = create Datacenter ( STR_ ) ; Datacenter Broker broker = create Broker ( ) ; int broker Id = broker . get Id ( ) ; vmlist = new Array List < Vm > ( ) ; int vmid = NUM_ ; int mips = NUM_ ; long size = NUM_ ; int ram = NUM_ ; long bw = NUM_ ; int pes Number = NUM_ ; String vmm = STR_ ; Vm vm 1 = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmid ++ ; Vm vm 2 = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmlist . add ( vm 1 ) ; vmlist . add ( vm 2 ) ; broker . submit Vm List ( vmlist ) ; cloudlet List = new Array List < Cloudlet > ( ) ; int id = NUM_ ; pes Number = NUM_ ; long length = NUM_ ; long file Size = NUM_ ; long output Size = NUM_ ; Utilization Model utilization Model = new Utilization Model Full ( ) ; Cloudlet cloudlet 1 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 1 . set User Id ( broker Id ) ; id ++ ; Cloudlet cloudlet 2 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 2 . set User Id ( broker Id ) ; cloudlet List . add ( cloudlet 1 ) ; cloudlet List . add ( cloudlet 2 ) ; broker . submit Cloudlet List ( cloudlet List ) ; broker . bind Cloudlet To Vm ( cloudlet 1 . get Cloudlet Id ( ) , vm 1 . get Id ( ) ) ; broker . bind Cloudlet To Vm ( cloudlet 2 . get Cloudlet Id ( ) , vm 2 . get Id ( ) ) ; Cloud Sim . start Simulation ( ) ; List < Cloudlet > new List = broker . get Cloudlet Received List ( ) ; Cloud Sim . stop Simulation ( ) ; print Cloudlet List ( new List ) ; Log . print Line ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STR_ ) ; } }
public void disable Out And Expected Deletion ( ) { set Out And Expected Deletion Disabled ( true ) ; }
private void write ( FCD Command command ) throws Lib Usb Exception { Byte Buffer buffer = Byte Buffer . allocate Direct ( NUM_ ) ; buffer . put ( NUM_ , command . get Command ( ) ) ; buffer . put ( NUM_ , ( byte ) NUM_ ) ; write ( buffer ) ; }
public void replace Header ( int state , String header ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + state + STR_ + header ) ; } if ( last State != state ) { already Replaced = false ; } last State = state ; if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STR_ , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state , true ) ; if ( ext . length <= NUM_ ) { throw new Auth Login Exception ( bundle Name , STR_ , null ) ; } if ( ( header != null ) && ( header . length ( ) != NUM_ ) ) { Page Properties Callback pc = ( Page Properties Callback ) ( ( Callback [ ] ) internal . get ( state - NUM_ ) ) [ NUM_ ] ; if ( ! ( already Replaced ) ) { header With Replace Tag = pc . get Header ( ) ; } int idx = header With Replace Tag . index Of ( STR_ ) ; if ( idx != - NUM_ ) { String new Header = header With Replace Tag . substring ( NUM_ , idx ) + header ; pc . set Header ( new Header ) ; already Replaced = true ; } else { String new Header = header With Replace Tag . substring ( NUM_ , header With Replace Tag . index Of ( STR_ ) ) + STR_ + header ; pc . set Header ( new Header ) ; } } }
@ Override public String generate URL ( XY Dataset dataset , int series , int item ) { String url = this . prefix ; boolean first Parameter = url . index Of ( STR_ ) == - NUM_ ; url += first Parameter ? STR_ : STR_ ; url += this . series Parameter Name + STR_ + series + STR_ + this . item Parameter Name + STR_ + item ; return url ; }
private void create Single Style Legend ( Map < String , Style > style Map , Styled Layer selected Styled Layer , Style selected Style ) { List < Style > style List = null ; if ( selected Styled Layer instanceof Named Layer Impl ) { Named Layer Impl named Layer = ( Named Layer Impl ) selected Styled Layer ; style List = named Layer . styles ( ) ; } else if ( selected Styled Layer instanceof User Layer Impl ) { User Layer Impl user Layer = ( User Layer Impl ) selected Styled Layer ; style List = user Layer . user Styles ( ) ; } String style Name ; if ( selected Style . get Name ( ) != null ) { style Name = selected Style . get Name ( ) ; } else { style Name = String . format ( STR_ , style List . index Of ( selected Style ) ) ; } style Map . put ( style Name , selected Style ) ; }
protected void process View Events ( Source Printer printer ) { process History Changed Evt ( printer ) ; process Closing Evt ( printer ) ; process Close Evt ( printer ) ; process Resized Evt ( printer ) ; process Load Evt ( printer ) ; process Unload Evt ( printer ) ; process Activate Evt ( printer ) ; process Deactivate Evt ( printer ) ; }
protected void mark Flushed ( ) { if ( done Lock != null ) { if ( NS Logger . debug Logger ) Log . v ( STR_ , String . format ( STR_ , sequence Number ) ) ; done Lock . lock ( ) ; done Condition . signal ( ) ; done Lock . unlock ( ) ; } }
protected void write Nothing ( ) throws IO Exception { fos . write Int ( NUM_ ) ; fos . flush ( ) ; }
private void do Auto Scroll ( final J Text Area ta , final boolean scroll ) { Swing Utilities . invoke Later ( null ) ; }
public final void increase Scheduled Write Messages ( ) { throughput Calculation Lock . lock ( ) ; try { scheduled Write Messages ++ ; } finally { throughput Calculation Lock . unlock ( ) ; } }
public static void dump Update Params ( String prefix , Object [ ] new Data , Object [ ] old Data ) { if ( ! log . is Debug Enabled ( ) ) { return ; } String Writer buffer = new String Writer ( ) ; Print Writer writer = new Print Writer ( buffer ) ; if ( new Data == null ) { writer . println ( prefix + STR_ ) ; } else { writer . println ( prefix + STR_ + new Data . length + STR_ ) ; print Object Array ( prefix , writer , new Data ) ; } if ( old Data == null ) { writer . println ( prefix + STR_ ) ; } else { writer . println ( prefix + STR_ + old Data . length + STR_ ) ; print Object Array ( prefix , writer , old Data ) ; } }
private double max Ignore Na N ( double a , double b ) { if ( Double . is Na N ( a ) ) { return b ; } if ( Double . is Na N ( b ) ) { return a ; } return Math . max ( a , b ) ; }
protected Example Set Meta Data modify Inner Output Example Set ( Example Set Meta Data meta Data ) { return meta Data ; }
public boolean add Comment ( Note bug , Note Comment comment ) { if ( ! bug . is New ( ) ) { Log . d ( DEBUG TAG , STR_ + bug . get Id ( ) ) ; Http URL Connection connection = null ; try { try { String encoded Comment = URL Encoder . encode ( comment . get Text ( ) , STR_ ) ; URL add Comment Url = get Add Comment Url ( Long . to String ( bug . get Id ( ) ) , encoded Comment ) ; connection = open Connection For Write Access ( add Comment Url , STR_ , STR_ ) ; Output Stream Writer out = new Output Stream Writer ( connection . get Output Stream ( ) , Charset . default Charset ( ) ) ; out . flush ( ) ; if ( connection . get Response Code ( ) != Http URL Connection . HTTP OK ) { throw Unexpected Request Exception ( connection ) ; } parse Bug ( bug , connection . get Input Stream ( ) ) ; return true ; } catch ( Xml Pull Parser Exception e ) { Log . e ( DEBUG TAG , STR_ , e ) ; } catch ( IO Exception e ) { Log . e ( DEBUG TAG , STR_ , e ) ; } } finally { disconnect ( connection ) ; } } return false ; }
public List < Vmfs Datastore Option > query Vmfs Datastore Expand Options ( Datastore datastore ) { Host Datastore System datastore System = get Datastore System ( ) ; try { return create List ( datastore System . query Vmfs Datastore Expand Options ( datastore ) ) ; } catch ( Host Config Fault e ) { throw new VM Ware Exception ( e ) ; } catch ( Not Found e ) { throw new VM Ware Exception ( e ) ; } catch ( Runtime Fault e ) { throw new VM Ware Exception ( e ) ; } catch ( Remote Exception e ) { throw new VM Ware Exception ( e ) ; } }
public static void copy File ( File orig Path , File dest Path ) throws IO Exception { try ( File Input Stream ins = new File Input Stream ( orig Path ) ; File Output Stream outs = new File Output Stream ( dest Path ) ) { File Channel in = ins . get Channel ( ) ; File Channel out = outs . get Channel ( ) ; in . transfer To ( NUM_ , in . size ( ) , out ) ; } }
private void parse Menu ( Xml Pull Parser parser , Attribute Set attrs , Icon Data menu ) throws Xml Pull Parser Exception , IO Exception { Menu State menu State = new Menu State ( menu ) ; int event Type = parser . get Event Type ( ) ; String tag Name ; boolean looking For End Of Unknown Tag = false ; String unknown Tag Name = null ; do { if ( event Type == Xml Pull Parser . START TAG ) { tag Name = parser . get Name ( ) ; if ( tag Name . equals ( XML MENU ) ) { event Type = parser . next ( ) ; break ; } throw new Runtime Exception ( STR_ + tag Name ) ; } event Type = parser . next ( ) ; } while ( event Type != Xml Pull Parser . END DOCUMENT ) ; boolean reached End Of Menu = false ; while ( ! reached End Of Menu ) { switch ( event Type ) { case Xml Pull Parser . START TAG : if ( looking For End Of Unknown Tag ) { break ; } tag Name = parser . get Name ( ) ; if ( tag Name . equals ( XML GROUP ) ) { menu State . read Group ( attrs ) ; } else if ( tag Name . equals ( XML ITEM ) ) { menu State . read Item ( attrs ) ; } else if ( tag Name . equals ( XML MENU ) ) { Icon Data sub Menu = menu State . add Sub Menu Item ( ) ; parse Menu ( parser , attrs , sub Menu ) ; } else { looking For End Of Unknown Tag = true ; unknown Tag Name = tag Name ; } break ; case Xml Pull Parser . END TAG : tag Name = parser . get Name ( ) ; if ( looking For End Of Unknown Tag && tag Name . equals ( unknown Tag Name ) ) { looking For End Of Unknown Tag = false ; unknown Tag Name = null ; } else if ( tag Name . equals ( XML GROUP ) ) { menu State . reset Group ( ) ; } else if ( tag Name . equals ( XML ITEM ) ) { if ( ! menu State . has Added Item ( ) ) { menu State . add Item ( ) ; } } else if ( tag Name . equals ( XML MENU ) ) { reached End Of Menu = true ; } break ; case Xml Pull Parser . END DOCUMENT : throw new Runtime Exception ( STR_ ) ; } event Type = parser . next ( ) ; } }
public void register ( String key , Remote value ) throws Registry Exception { try { registry . rebind ( key , value ) ; } catch ( Exception e ) { throw new Registry Exception ( STR_ + key + STR_ , e ) ; } }
public void do Edit Chart Properties ( ) { Chart Editor editor = Chart Editor Manager . get Chart Editor ( this . chart ) ; int result = J Option Pane . show Confirm Dialog ( this , editor , localization Resources . get String ( STR_ ) , J Option Pane . OK CANCEL OPTION , J Option Pane . PLAIN MESSAGE ) ; if ( result == J Option Pane . OK OPTION ) { editor . update Chart ( this . chart ) ; } }
public void expand ( int level ) { Array List < S 2 Cell Id > output = new Array List < S 2 Cell Id > ( ) ; long level Lsb = S 2 Cell Id . lowest On Bit For Level ( level ) ; int i = size ( ) - NUM_ ; do { S 2 Cell Id id = cell Id ( i ) ; if ( id . lowest On Bit ( ) < level Lsb ) { id = id . parent ( level ) ; while ( i > NUM_ && id . contains ( cell Id ( i - NUM_ ) ) ) { -- i ; } } output . add ( id ) ; id . get All Neighbors ( level , output ) ; } while ( -- i >= NUM_ ) ; init Swap ( output ) ; }
public void reset ( ) { len = NUM_ ; pos = NUM_ ; Arrays . fill ( buf , ( byte ) NUM_ ) ; }
public static String generate Native Guid ( Storage System device , String unique Id , String type ) { String type Str = STR_ ; if ( OBJECT TYPE SET . contains ( type ) ) { type Str = type ; } return String . format ( STR_ , device Type Map . get ( device . get System Type ( ) ) , device . get Serial Number ( ) , type Str , unique Id ) ; }
protected int normalize ( char [ ] src , int src Start , int src Limit , char [ ] dest , int dest Start , int dest Limit , Unicode Set nx ) { int src Len = ( src Limit - src Start ) ; int dest Len = ( dest Limit - dest Start ) ; if ( src Len > dest Len ) { return src Len ; } System . arraycopy ( src , src Start , dest , dest Start , src Len ) ; return src Len ; }
public void add On Complete Call ( Runnable r ) { if ( post == null ) { post = new Array List < Runnable > ( ) ; } post . add ( r ) ; }
public void offer ( Byte Buffer buf ) throws Buffer Overflow Exception { if ( get Writeable Bytes Remaining ( ) < buf . remaining ( ) ) throw new Buffer Overflow Exception ( ) ; if ( ! buf . has Remaining ( ) ) return ; flush Write Chunk ( ) ; bytes Written += buf . remaining ( ) ; list . add Last ( buf ) ; }
public static SSL Context create SSL Context ( Trust Manager trust Manager , Key Manager key Manager ) { try { SSL Context ctx = SSL Context . get Instance ( STR_ ) ; ctx . init ( new Key Manager [ ] { key Manager } , new Trust Manager [ ] { trust Manager } , null ) ; return ctx ; } catch ( No Such Algorithm Exception | Key Management Exception e ) { throw new Runtime Exception ( STR_ , e ) ; } }
public long insert With On Conflict ( String table , String null Column Hack , Values Storage initial Values , int conflict Algorithm ) { acquire Reference ( ) ; try { String Builder sql = new String Builder ( ) ; sql . append ( STR_ ) ; sql . append ( CONFLICT VALUES [ conflict Algorithm ] ) ; sql . append ( STR_ ) ; sql . append ( table ) ; sql . append ( STR_ ) ; Object [ ] bind Args = null ; int size = ( initial Values != null && initial Values . size ( ) > NUM_ ) ? initial Values . size ( ) : NUM_ ; if ( size > NUM_ ) { bind Args = new Object [ size ] ; int i = NUM_ ; for ( String col Name : initial Values . key Set ( ) ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; sql . append ( col Name ) ; bind Args [ i ++ ] = initial Values . get ( col Name ) ; } sql . append ( STR_ ) ; sql . append ( STR_ ) ; for ( i = NUM_ ; i < size ; i ++ ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; } } else { sql . append ( null Column Hack + STR_ ) ; } sql . append ( STR_ ) ; SQ Lite Statement statement = new SQ Lite Statement ( this , sql . to String ( ) , bind Args ) ; try { return statement . execute Insert ( ) ; } finally { statement . close ( ) ; } } finally { release Reference ( ) ; } }
public static Process Builder rtl Sdr Snif ( String dir , String frequency , String gain , String samplerate ) { Process Builder pb = new Process Builder ( STR_ , STR_ , frequency , STR_ , gain , frequency + STR_ , STR_ , samplerate ) ; pb . directory ( new File ( dir ) ) ; return pb ; }
public int remove Direction Sensors From SSL ( Layout Editor le Panel ) { if ( le Panel == null ) { return - NUM_ ; } jmri . jmrit . display . layout Editor . Connectivity Util c Util = le Panel . get Connectivity Util ( ) ; List < String > list = get System Name List ( ) ; if ( list . size ( ) <= NUM_ ) { return - NUM_ ; } int num Errors = NUM_ ; Array List < String > sensor List = new Array List < String > ( ) ; for ( int i = NUM_ ; i < list . size ( ) ; i ++ ) { Section s = get By System Name ( list . get ( i ) ) ; String name = s . get Reverse Blocking Sensor Name ( ) ; if ( ( name != null ) && ( ! name . equals ( STR_ ) ) ) { sensor List . add ( name ) ; } name = s . get Forward Blocking Sensor Name ( ) ; if ( ( name != null ) && ( ! name . equals ( STR_ ) ) ) { sensor List . add ( name ) ; } } jmri . Signal Head Manager sh Manager = Instance Manager . get Default ( jmri . Signal Head Manager . class ) ; List < String > signal List = sh Manager . get System Name List ( ) ; for ( int j = NUM_ ; j < signal List . size ( ) ; j ++ ) { Signal Head sh = sh Manager . get By System Name ( signal List . get ( j ) ) ; if ( ! c Util . remove Sensors From Signal Head Logic ( sensor List , sh ) ) { num Errors ++ ; } } return num Errors ; }
public boolean has Logical Mapping ( String logical Name ) { return logical To Physical Column Names . contains Key ( logical Name ) ; }
public String Get Element Attr ( String x Path Expression ) { try { org . jdom . Attribute node = ( Attribute ) X Path . select Single Node ( this . xml Document , x Path Expression ) ; return node . get Value ( ) ; } catch ( Exception ex ) { LOG . error ( STR_ + ex . get Message ( ) , ex ) ; return STR_ ; } }
private void retry Bad Nics ( ) { if ( retry Nics == null ) return ; if ( ! retry Nics . is Empty ( ) ) { String recovered Str = STR_ + STR_ ; Array List tmp List = ( Array List ) retry Nics . clone ( ) ; retry Nics . clear ( ) ; for ( int i = NUM_ ; i < tmp List . size ( ) ; i ++ ) { Network Interface nic = ( Network Interface ) tmp List . get ( i ) ; try { sock . set Network Interface ( nic ) ; sock . join Group ( Constants . get Announcement Address ( ) ) ; if ( nics To Use == NICS USE LIST ) { logger . log ( Level . INFO , recovered Str , nic ) ; } else { logger . log ( Level . FINE , recovered Str , nic ) ; } } catch ( IO Exception e 1 ) { retry Nics . add ( nic ) ; } } if ( retry Nics . is Empty ( ) ) retry Nics = null ; } else { try { sock . join Group ( Constants . get Announcement Address ( ) ) ; retry Nics = null ; logger . log ( Level . INFO , STR_ + STR_ + STR_ ) ; } catch ( IO Exception e 1 ) { } } }
public void add Board View Listener ( Board View Listener listener ) { if ( ! board Listeners . contains ( listener ) ) { board Listeners . add ( listener ) ; } }
public synchronized void clear ( ) { int i ; int len = password . length ; for ( i = NUM_ ; i < len ; i ++ ) { password [ i ] = NUM_ ; } cleared = true ; }
protected < T > Handler < Async Result < T > > result Handler ( Routing Context context , Handler < T > handler ) { return null ; }
public static Calendar create Calendar Midnight ( final Date date ) { Calendar cal = new Gregorian Calendar ( get Time Zone ( STR_ ) ) ; cal . set Time ( date ) ; cal . set ( HOUR OF DAY , NUM_ ) ; cal . set ( MINUTE , NUM_ ) ; cal . set ( SECOND , NUM_ ) ; cal . set ( MILLISECOND , NUM_ ) ; return cal ; }
public static long [ ] zero I ( long [ ] v ) { Arrays . fill ( v , NUM_ ) ; return v ; }
public boolean unregister Client ( Unregister Profile profile , Server Config utils , Context context ) throws App Catalog Exception { String Builder end Point = new String Builder ( ) ; end Point . append ( utils . get API Server URL ( context ) ) ; end Point . append ( Constants . DYNAMIC CLIENT REGISTER ENDPOINT ) ; end Point . append ( STR_ + USER ID + STR_ + profile . get User Id ( ) ) ; end Point . append ( STR_ + CONSUMER KEY + STR_ + profile . get Consumer Key ( ) ) ; end Point . append ( STR_ + APPLICATION NAME + STR_ + profile . get Application Name ( ) ) ; End Point Info end Point Info = new End Point Info ( ) ; end Point Info . set Http Method ( org . wso 2 . emm . agent . proxy . utils . Constants . HTTP METHODS . DELETE ) ; end Point Info . set End Point ( end Point . to String ( ) ) ; send Request ( end Point Info , null , Constants . DYNAMIC CLIENT UNREGISTER REQUEST CODE ) ; return true ; }
public static String generate And ( final I Translation Environment environment , final long offset , final Operand Size size , final String operand 1 , final String operand 2 , final List < Reil Instruction > instructions ) throws Illegal Argument Exception { Preconditions . check Not Null ( environment , STR_ ) ; Preconditions . check Not Null ( size , STR_ ) ; Preconditions . check Not Null ( operand 1 , STR_ ) ; Preconditions . check Not Null ( operand 2 , STR_ ) ; final String result = environment . get Next Variable String ( ) ; instructions . add ( Reil Helpers . create And ( offset , size , operand 1 , size , operand 2 , size , result ) ) ; generate Binary Operation Flags ( environment , offset + NUM_ , result , size , instructions ) ; return result ; }
static boolean is Accessible ( final Member m ) { return m != null && Modifier . is Public ( m . get Modifiers ( ) ) && ! Member Utils . is Synthetic ( m ) ; }
private List < String > match Almost Recursion ( TST Node current Node , int char Index , int d , Char Sequence match Almost Key , int match Almost Num Return Values , List < String > match Almost Result 2 , boolean up To ) { if ( ( current Node == null ) || ( match Almost Num Return Values != - NUM_ && match Almost Result 2 . size ( ) >= match Almost Num Return Values ) || ( d < NUM_ ) || ( char Index >= match Almost Key . length ( ) ) ) { return match Almost Result 2 ; } int char Comp = compare Chars Alphabetically ( match Almost Key . char At ( char Index ) , current Node . splitchar ) ; List < String > match Almost Result = match Almost Result 2 ; if ( ( d > NUM_ ) || ( char Comp < NUM_ ) ) { match Almost Result = match Almost Recursion ( current Node . relatives [ TST Node . LOKID ] , char Index , d , match Almost Key , match Almost Num Return Values , match Almost Result , up To ) ; } int next D = ( char Comp == NUM_ ) ? d : d - NUM_ ; boolean cond = ( up To ) ? ( next D >= NUM_ ) : ( next D == NUM_ ) ; if ( ( match Almost Key . length ( ) == char Index + NUM_ ) && cond && ( current Node . data != null ) ) { match Almost Result . add ( get Key ( current Node ) ) ; } match Almost Result = match Almost Recursion ( current Node . relatives [ TST Node . EQKID ] , char Index + NUM_ , next D , match Almost Key , match Almost Num Return Values , match Almost Result , up To ) ; if ( ( d > NUM_ ) || ( char Comp > NUM_ ) ) { match Almost Result = match Almost Recursion ( current Node . relatives [ TST Node . HIKID ] , char Index , d , match Almost Key , match Almost Num Return Values , match Almost Result , up To ) ; } return match Almost Result ; }
public static void replace Styles ( List < Shape Record > shape Records , int line Style Index , int fill Style 0 Index , int fill Style 1 Index ) { if ( shape Records != null && shape Records . size ( ) > NUM_ ) { for ( int i = NUM_ ; i < shape Records . size ( ) ; i ++ ) { Shape Record record = shape Records . get ( i ) ; if ( record instanceof Style Change Record ) { Style Change Record old scr = ( Style Change Record ) record ; Style Change Record new scr = new Style Change Record ( ) ; if ( fill Style 0 Index > NUM_ ) new scr . set Fill Style 0 ( fill Style 0 Index ) ; if ( fill Style 1 Index > NUM_ ) new scr . set Fill Style 1 ( fill Style 1 Index ) ; if ( ( ! old scr . state Line Style ) && ( line Style Index > NUM_ ) ) new scr . set Linestyle ( line Style Index ) ; else new scr . set Linestyle ( old scr . linestyle ) ; if ( old scr . state Move To ) new scr . set Move ( old scr . move Delta X , old scr . move Delta Y ) ; shape Records . set ( i , new scr ) ; } } } }
private static List < List < String > > search In LDAP Schema ( Ldap Template template , String [ ] return Attributes , final Root DSE root DSE , final List < String > ldap Server Urls , String Builder error String ) { try { String schema DN = root DSE . get Schema Naming Context ( ) ; log . debug ( STR_ , schema DN ) ; @ Suppress Warnings ( STR_ ) List < List < String > > attribute List = template . search ( schema DN , STR_ , Search Controls . OBJECT SCOPE , return Attributes , new LDAP Schema Context Mapper ( ) ) ; if ( Collection Utils . is Empty ( attribute List ) ) { error String . append ( Message Format . format ( STR_ , return Attributes . to String ( ) , schema DN , ldap Server Urls . to String ( ) ) ) ; } return attribute List ; } catch ( Communication Exception e ) { error String . append ( Message Format . format ( STR_ , ldap Server Urls . to String ( ) , return Attributes . to String ( ) , strip Non Printable Characters ( e . get Message ( ) ) ) ) ; return null ; } catch ( Exception e ) { error String . append ( Message Format . format ( STR_ , return Attributes . to String ( ) , ldap Server Urls . to String ( ) , strip Non Printable Characters ( e . get Message ( ) ) ) ) ; return null ; } }
private int read Index With Field Type ( char ft ) throws EOF Exception , Format Exception { switch ( ft ) { case STR_ : return ( int ) input File . read Short ( ) ; case STR_ : return input File . read Integer ( ) ; } throw new Format Exception ( STR_ ) ; }
public void display State ( ) { Print Writer xout = context . get ( Log . out Key ) ; xout . println ( STR_ + file Object History ) ; xout . println ( STR_ + open Type Names ) ; xout . println ( STR_ + generated Source Names ) ; xout . println ( STR_ + generated Classes . key Set ( ) ) ; xout . println ( STR_ + aggregate Generated Source Names ) ; xout . println ( STR_ + aggregate Generated Class Names ) ; }
Operation Store ( final Operation Rate Factory operation Rate Factory , final Map < CTS Operation , Operation Monitor > operation Rate ) { this . operation Rate Factory = operation Rate Factory ; this . operation Rate = Collections . synchronized Map ( operation Rate ) ; }
public static String trim ( final String value ) { return ( value == null ? null : value . trim ( ) ) ; }
private String read Fully ( Input Stream input ) throws IO Exception { if ( input == null ) { throw new File Not Found Exception ( ) ; } final Buffered Reader in = new Buffered Reader ( new Input Stream Reader ( input , charset ) ) ; try { String Builder sb = new String Builder ( ) ; String line ; while ( ( line = in . read Line ( ) ) != null ) { if ( sb . length ( ) > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( line ) ; } return sb . to String ( ) ; } finally { in . close ( ) ; } }
protected void print Result ( final Command Result command Result , Print Stream print Stream ) { assert ( command Result != null ) ; assert ( print Stream != null ) ; command Result . reset To First Line ( ) ; print Stream . print ( command Result To String ( command Result ) ) ; }
protected int calculate Tab Width ( int tab Placement , int tab Index , Font Metrics metrics ) { final Font font = metrics . get Font ( ) ; final Font Metrics plain Metrics = font . is Plain ( ) ? metrics : tab Pane . get Font Metrics ( font . derive Font ( Font . PLAIN ) ) ; final int width Plain = super . calculate Tab Width ( tab Placement , tab Index , plain Metrics ) ; final Font Metrics bold Metrics = font . is Bold ( ) ? metrics : tab Pane . get Font Metrics ( font . derive Font ( Font . BOLD ) ) ; final int width Bold = super . calculate Tab Width ( tab Placement , tab Index , bold Metrics ) ; final int width = Math . max ( width Plain , width Bold ) ; my Layout Metrics = ( width == width Plain ) ? plain Metrics : bold Metrics ; return width ; }
@ Inject private void init ( Node Runner Descriptor Provider descriptor Provider ) { if ( ! runner Registry . is Registered ( Node Runner . ID ) ) { runner Registry . register ( descriptor Provider . get ( ) ) ; } }
private void validate Page Number ( int page Number ) throws IO Exception { int next Page Number = get Next Page Number ( channel . size ( ) ) ; if ( ( page Number <= INVALID PAGE NUMBER ) || ( page Number >= next Page Number ) ) { throw new Illegal State Exception ( STR_ + page Number ) ; } }
public static float ulp ( float x ) { if ( Float . is Infinite ( x ) ) { return Float . POSITIVE INFINITY ; } return abs ( x - Float . int Bits To Float ( Float . float To Int Bits ( x ) ^ NUM_ ) ) ; }
public void remove Event Listener ( One To One Chat Listener listener ) throws Rcs Service Not Available Exception , Rcs Generic Exception { if ( m Api == null ) { throw new Rcs Service Not Available Exception ( ) ; } try { Weak Reference < I One To One Chat Listener > weak Ref = m One To One Chat Listeners . remove ( listener ) ; if ( weak Ref == null ) { return ; } I One To One Chat Listener rcs Listener = weak Ref . get ( ) ; if ( rcs Listener != null ) { m Api . remove Event Listener 2 ( rcs Listener ) ; } } catch ( Exception e ) { Rcs Illegal Argument Exception . assert Exception ( e ) ; throw new Rcs Generic Exception ( e ) ; } }
public void register Prerender Request ( String url ) { m Url = url ; long now = System . current Time Millis ( ) ; m Score = Math . min ( MAX SCORE , m Score - NUM_ + ALPHA * ( now - m Last Prerender Request Ms ) ) ; m Last Prerender Request Ms = now ; Shared Preferences . Editor editor = m Shared Preferences . edit ( ) ; editor . put Long ( LAST REQUEST + m Uid , m Last Prerender Request Ms ) ; update Ban ( editor ) ; editor . apply ( ) ; }
public void write To File And Parse JSON ( ) throws IO Exception , Ade Exception { file Writer . write ( json Group Object . to String ( ) ) ; file Writer . flush ( ) ; json Group Parser . parse JSON ( json File ) ; }
private void create Attributes Ele ( Element parent ) throws Exception { Collection < Attribute > attributes = idm Client . get Attribute Definitions ( tenant Name ) ; for ( Attribute attr : attributes ) { Element attr Ele = doc . create Element ( SAML Names . ATTRIBUTE ) ; attr Ele . set Attribute ( SAML Names . NAME , attr . get Name ( ) ) ; attr Ele . set Attribute ( SAML Names . NAMEFORMAT , attr . get Name Format ( ) ) ; attr Ele . set Attribute ( SAML Names . FRIENDLYNAME , attr . get Friendly Name ( ) ) ; parent . append Child ( attr Ele ) ; } }
public Open Spaces Queue Object new Queue Template ( String queue Name ) { Open Spaces Queue Object queue Object = is Fifo ( ) ? new Open Spaces Fifo Queue Object ( ) : new Open Spaces Queue Object ( ) ; queue Object . set Persistent ( is Persistent ( ) ) ; queue Object . set Endpoint URI ( queue Name ) ; return queue Object ; }
public static Tailer create ( File file , Tailer Listener listener , long delay Millis , boolean end , int buf Size ) { Tailer tailer = new Tailer ( file , listener , delay Millis , end , buf Size ) ; Thread thread = new Thread ( tailer ) ; thread . set Daemon ( true ) ; thread . start ( ) ; return tailer ; }
private Size choose Video Size ( Size [ ] choices ) { int sw = m Texture View . get Width ( ) ; int sh = m Texture View . get Height ( ) ; m Preview Surface Aspect Ratio = ( float ) sw / sh ; Log . i ( TAG , STR_ + ( m Preview Surface Aspect Ratio > NUM_ ) + STR_ + m Preview Surface Aspect Ratio + STR_ + Arrays . to String ( choices ) ) ; Size size To Return = null ; if ( m Preview Surface Aspect Ratio > NUM_ ) { for ( Size size : choices ) { if ( size . get Height ( ) == size . get Width ( ) * NUM_ / NUM_ && size . get Height ( ) <= NUM_ ) { size To Return = size ; } } if ( size To Return == null ) size To Return = choices [ NUM_ ] ; m Video Size Aspect Ratio = ( float ) size To Return . get Width ( ) / size To Return . get Height ( ) ; } else { Array List < Size > potentials = new Array List < > ( ) ; for ( Size size : choices ) { float aspect = ( float ) size . get Height ( ) / size . get Width ( ) ; if ( aspect == m Preview Surface Aspect Ratio ) potentials . add ( size ) ; } Log . i ( TAG , STR_ + potentials . size ( ) ) ; if ( potentials . size ( ) > NUM_ ) { for ( Size potential : potentials ) if ( potential . get Height ( ) == sw ) { size To Return = potential ; break ; } if ( size To Return == null ) Log . i ( TAG , STR_ ) ; for ( Size potential : potentials ) if ( potential . get Height ( ) == NUM_ || potential . get Height ( ) == NUM_ ) { size To Return = potential ; break ; } if ( size To Return == null ) Log . i ( TAG , STR_ ) ; if ( size To Return == null ) size To Return = potentials . get ( NUM_ ) ; } if ( size To Return == null ) size To Return = choices [ NUM_ ] ; m Video Size Aspect Ratio = ( float ) size To Return . get Height ( ) / size To Return . get Width ( ) ; } return size To Return ; }
public static Data Output Stream new Data Output Stream ( Path self ) throws IO Exception { return new Data Output Stream ( Files . new Output Stream ( self ) ) ; }
void update Rate ( ) { factor Field . set Text ( three Digits . format ( clock . user Get Rate ( ) ) ) ; changed = true ; }
private static void try success ( String s , String e ) { print ( STR_ + s + STR_ ) ; if ( e != STR_ ) { print ( STR_ + e + STR_ ) ; } }
private String print X Format ( String sx ) { int n Leading Zeros = NUM_ ; int n Blanks = NUM_ ; if ( sx . equals ( STR_ ) && precision Set && precision == NUM_ ) { sx = STR_ ; } if ( precision Set ) { n Leading Zeros = precision - sx . length ( ) ; } if ( n Leading Zeros < NUM_ ) { n Leading Zeros = NUM_ ; } if ( field Width Set ) { n Blanks = field Width - n Leading Zeros - sx . length ( ) ; if ( alternate Form ) { n Blanks -= NUM_ ; } } if ( n Blanks < NUM_ ) { n Blanks = NUM_ ; } int n = NUM_ ; if ( alternate Form ) { n += NUM_ ; } n += n Leading Zeros ; n += sx . length ( ) ; n += n Blanks ; final char [ ] ca = new char [ n ] ; int i = NUM_ ; if ( left Justify ) { if ( alternate Form ) { ca [ i ++ ] = STR_ ; ca [ i ++ ] = STR_ ; } for ( int j = NUM_ ; j < n Leading Zeros ; j ++ , i ++ ) { ca [ i ] = STR_ ; } final char [ ] csx = sx . to Char Array ( ) ; for ( int j = NUM_ ; j < csx . length ; j ++ , i ++ ) { ca [ i ] = csx [ j ] ; } for ( int j = NUM_ ; j < n Blanks ; j ++ , i ++ ) { ca [ i ] = STR_ ; } } else { if ( ! leading Zeros ) { for ( int j = NUM_ ; j < n Blanks ; j ++ , i ++ ) { ca [ i ] = STR_ ; } } if ( alternate Form ) { ca [ i ++ ] = STR_ ; ca [ i ++ ] = STR_ ; } if ( leading Zeros ) { for ( int j = NUM_ ; j < n Blanks ; j ++ , i ++ ) { ca [ i ] = STR_ ; } } for ( int j = NUM_ ; j < n Leading Zeros ; j ++ , i ++ ) { ca [ i ] = STR_ ; } final char [ ] csx = sx . to Char Array ( ) ; for ( int j = NUM_ ; j < csx . length ; j ++ , i ++ ) { ca [ i ] = csx [ j ] ; } } String ca Return = new String ( ca ) ; if ( conversion Character == STR_ ) { ca Return = ca Return . to Upper Case ( ) ; } return ca Return ; }
private void cache Sizes ( ) { m Adapter Sizes . clear ( ) ; int size = NUM_ ; if ( m Adapters . size ( ) > NUM_ ) { m Adapter Sizes . put ( NUM_ , m Adapters . value At ( NUM_ ) ) ; } for ( I Adapter < Item > adapter : m Adapters . values ( ) ) { if ( adapter . get Adapter Item Count ( ) > NUM_ ) { m Adapter Sizes . put ( size , adapter ) ; size = size + adapter . get Adapter Item Count ( ) ; } } m Global Size = size ; }
private Class Loader lookup Loader ( final URL [ ] urls , final Class Loader parent ) { if ( urls == null ) { return parent ; } synchronized ( loader Table ) { Object ref ; while ( ( ref = ref Queue . poll ( ) ) != null ) { if ( ref instanceof Loader Key ) { Loader Key key = ( Loader Key ) ref ; loader Table . remove ( key ) ; } else if ( ref instanceof Loader Entry ) { Loader Entry entry = ( Loader Entry ) ref ; if ( ! entry . removed ) { loader Table . remove ( entry . key ) ; } } } Loader Key key = new Loader Key ( urls , parent ) ; Loader Entry entry = ( Loader Entry ) loader Table . get ( key ) ; Class Loader loader ; if ( entry == null || ( loader = ( Class Loader ) entry . get ( ) ) == null ) { if ( entry != null ) { loader Table . remove ( key ) ; entry . removed = true ; } loader = find Origin Loader ( urls , parent ) ; if ( loader == null ) { loader = create Class Loader ( urls , parent , require Dl Perm ) ; } entry = new Loader Entry ( key , loader ) ; loader Table . put ( key , entry ) ; } return loader ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Y Interval Renderer ) ) { return false ; } Y Interval Renderer that = ( Y Interval Renderer ) obj ; if ( ! Object Utilities . equal ( this . additional Item Label Generator , that . additional Item Label Generator ) ) { return false ; } return super . equals ( obj ) ; }
@ Override public void merge And Output Transformation Metadata ( Iterator < Distinct Value > values , String output Dir , int col ID , File System fs , Tf Utils agents ) throws IO Exception { Hash Map < String , Long > map = new Hash Map < String , Long > ( ) ; Distinct Value d = new Distinct Value ( ) ; String word = null ; Long count = null , val = null ; while ( values . has Next ( ) ) { d . reset ( ) ; d = values . next ( ) ; word = d . get Word ( ) ; count = d . get Count ( ) ; val = map . get ( word ) ; if ( val == null ) map . put ( word , count ) ; else map . put ( word , val + count ) ; } write Metadata ( map , output Dir , col ID , fs , agents , false ) ; }
public Soot Field add Ref Type For Concretes ( Ref Type type , Info Kind unmodeled Flow Type , boolean deep Clone ) { Soot Class clz = type . get Soot Class ( ) ; clz = Class Cloner . get Cloned Class From Clone ( clz ) ; List < Soot Class > concretes = Soot Utils . get All Concrete Subs Imps ( clz ) ; if ( concretes . is Empty ( ) ) { logger . debug ( STR_ , type . get Soot Class ( ) ) ; return null ; } int created = NUM_ ; for ( Soot Class concrete : concretes ) { if ( Class Cloner . is Cloned Class ( concrete ) ) continue ; logger . debug ( STR_ , type , concrete ) ; Soot Class real Concrete = Class Cloner . get Cloned Class From Clone ( concrete ) ; if ( ! type To Added Field . contains Key ( real Concrete . get Type ( ) ) ) { logger . debug ( STR_ , real Concrete ) ; add Ref Type Internal ( dummy Object Field , real Concrete , unmodeled Flow Type , deep Clone ) ; created ++ ; } if ( created > MAX SUBS AND IMPLEMENTORS TO ADD ) { logger . debug ( STR_ , clz ) ; break ; } } return dummy Object Field ; }
protected < T > Local Object Entry create Local Object Entry ( final Remote Reference < T > reference , final T object ) { final Normal Object Entry local Object = new Normal Object Entry ( ) ; local Object . object = object ; local Object . reference = reference ; return local Object ; }
public static Cli Diagnostic Listener initialize Logs ( final String [ ] args , final Print Stream err , final Log Stream init Log ) { if ( init Log != null ) { Diagnostic . set Log Stream ( init Log ) ; Diagnostic . log Environment ( ) ; } else { Diagnostic . set Log Stream ( ) ; } Diagnostic . user Log ( STR_ + Arrays . to String ( args ) ) ; final Cli Diagnostic Listener listener = new Cli Diagnostic Listener ( err ) ; Diagnostic . add Listener ( listener ) ; return listener ; }
@ Override public void write ( byte b [ ] ) throws IO Exception { for ( Output Stream stream : outs ) stream . write ( b ) ; }
public boolean gc Requested ( ) { return gc Every Safepoint || Scheduler . gc Triggered ( ) ; }
private final boolean check Int ( int in , Condition condition ) { String value = condition . get Value ( ) ; int v ; try { v = Integer . parse Int ( value ) ; } catch ( Number Format Exception e ) { return false ; } switch ( condition . get Condition Type ( ) ) { case EQUALS : { return ( in == v ) ; } case NOT EQUALS : { return ( in != v ) ; } case GREATER : { return ( in > v ) ; } case GREATER EQ : { return ( in >= v ) ; } case LESS : { return ( in < v ) ; } case LESS EQ : { return ( in <= v ) ; } default : { return false ; } } }
private void update Range Display For Ammo ( Mounted m Ammo ) { if ( ! ( m Ammo . get Type ( ) instanceof Ammo Type ) ) { return ; } Ammo Type atype = ( Ammo Type ) m Ammo . get Type ( ) ; if ( atype . get Ammo Type ( ) == Ammo Type . T ATM ) { if ( atype . get Munition Type ( ) == Ammo Type . M EXTENDED RANGE ) { w Min R . set Text ( STR_ ) ; w Short R . set Text ( STR_ ) ; w Med R . set Text ( STR_ ) ; w Long R . set Text ( STR_ ) ; w Ext R . set Text ( STR_ ) ; } else if ( atype . get Munition Type ( ) == Ammo Type . M HIGH EXPLOSIVE ) { w Min R . set Text ( STR_ ) ; w Short R . set Text ( STR_ ) ; w Med R . set Text ( STR_ ) ; w Long R . set Text ( STR_ ) ; w Ext R . set Text ( STR_ ) ; } else { w Min R . set Text ( STR_ ) ; w Short R . set Text ( STR_ ) ; w Med R . set Text ( STR_ ) ; w Long R . set Text ( STR_ ) ; w Ext R . set Text ( STR_ ) ; } } else if ( atype . get Ammo Type ( ) == Ammo Type . T MML ) { if ( atype . has Flag ( Ammo Type . F MML LRM ) ) { w Min R . set Text ( STR_ ) ; w Short R . set Text ( STR_ ) ; w Med R . set Text ( STR_ ) ; w Long R . set Text ( STR_ ) ; w Ext R . set Text ( STR_ ) ; } else { w Min R . set Text ( STR_ ) ; w Short R . set Text ( STR_ ) ; w Med R . set Text ( STR_ ) ; w Long R . set Text ( STR_ ) ; w Ext R . set Text ( STR_ ) ; } } else if ( atype . get Ammo Type ( ) == Ammo Type . T IATM ) { if ( atype . get Munition Type ( ) == Ammo Type . M EXTENDED RANGE ) { w Min R . set Text ( STR_ ) ; w Short R . set Text ( STR_ ) ; w Med R . set Text ( STR_ ) ; w Long R . set Text ( STR_ ) ; w Ext R . set Text ( STR_ ) ; } else if ( atype . get Munition Type ( ) == Ammo Type . M HIGH EXPLOSIVE ) { w Min R . set Text ( STR_ ) ; w Short R . set Text ( STR_ ) ; w Med R . set Text ( STR_ ) ; w Long R . set Text ( STR_ ) ; w Ext R . set Text ( STR_ ) ; } else if ( atype . get Munition Type ( ) == Ammo Type . M IATM IIW ) { w Min R . set Text ( STR_ ) ; w Short R . set Text ( STR_ ) ; w Med R . set Text ( STR_ ) ; w Long R . set Text ( STR_ ) ; w Ext R . set Text ( STR_ ) ; } else if ( atype . get Munition Type ( ) == Ammo Type . M IATM IMP ) { w Min R . set Text ( STR_ ) ; w Short R . set Text ( STR_ ) ; w Med R . set Text ( STR_ ) ; w Long R . set Text ( STR_ ) ; w Ext R . set Text ( STR_ ) ; } else { w Min R . set Text ( STR_ ) ; w Short R . set Text ( STR_ ) ; w Med R . set Text ( STR_ ) ; w Long R . set Text ( STR_ ) ; w Ext R . set Text ( STR_ ) ; } } if ( m Ammo . is Hot Loaded ( ) ) { w Min R . set Text ( STR_ ) ; } on Resize ( ) ; }
protected final void clear Serialization Caches ( ) { try { clear Serialization Cache ( Class . for Name ( STR_ ) , STR_ ) ; clear Serialization Cache ( Class . for Name ( STR_ ) , STR_ ) ; clear Serialization Cache ( Class . for Name ( STR_ ) , STR_ ) ; clear Serialization Cache ( Class . for Name ( STR_ ) , STR_ ) ; } catch ( Class Not Found Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + e . get Message ( ) ) ; } catch ( No Such Field Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + e . get Message ( ) ) ; } catch ( Illegal Access Exception e ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + e . get Message ( ) ) ; } }
private static void decimate ( double tolerance , Array List < Location > locations , Array List < Location > decimated ) { final int n = locations . size ( ) ; if ( n < NUM_ ) { return ; } int idx ; int max Idx = NUM_ ; Stack < int [ ] > stack = new Stack < int [ ] > ( ) ; double [ ] dists = new double [ n ] ; dists [ NUM_ ] = NUM_ ; dists [ n - NUM_ ] = NUM_ ; double max Dist ; double dist = NUM_ ; int [ ] current ; if ( n > NUM_ ) { int [ ] stack Val = new int [ ] { NUM_ , ( n - NUM_ ) } ; stack . push ( stack Val ) ; while ( stack . size ( ) > NUM_ ) { current = stack . pop ( ) ; max Dist = NUM_ ; for ( idx = current [ NUM_ ] + NUM_ ; idx < current [ NUM_ ] ; ++ idx ) { dist = Location Utils . distance ( locations . get ( idx ) , locations . get ( current [ NUM_ ] ) , locations . get ( current [ NUM_ ] ) ) ; if ( dist > max Dist ) { max Dist = dist ; max Idx = idx ; } } if ( max Dist > tolerance ) { dists [ max Idx ] = max Dist ; int [ ] stack Val Cur Max = { current [ NUM_ ] , max Idx } ; stack . push ( stack Val Cur Max ) ; int [ ] stack Val Max Cur = { max Idx , current [ NUM_ ] } ; stack . push ( stack Val Max Cur ) ; } } } int i = NUM_ ; idx = NUM_ ; decimated . clear ( ) ; for ( Location l : locations ) { if ( dists [ idx ] != NUM_ ) { decimated . add ( l ) ; i ++ ; } idx ++ ; } Log . d ( TAG , STR_ + n + STR_ + i + STR_ + tolerance ) ; }
public Array List < T > add All ( Array List < T > elist , int upto Index ) { if ( upto Index > elist . size ( ) ) { log . error ( STR_ ) ; return elist ; } for ( int index = NUM_ ; index < upto Index ; index ++ ) { T e = elist . get ( index ) ; if ( e != null ) { elist . set ( index , add ( e ) ) ; } } return elist ; }
public synchronized void connected ( Bluetooth Socket socket , Bluetooth Device device , final String socket Type ) { log . debug ( STR_ + socket Type ) ; if ( m Bt Connect Thread != null ) { m Bt Connect Thread . cancel ( ) ; m Bt Connect Thread = null ; } if ( m Bt Worker Thread != null ) { m Bt Worker Thread . cancel ( ) ; m Bt Worker Thread = null ; } connection Established ( device . get Name ( ) ) ; m Bt Worker Thread = new Bt Worker Thread ( socket , socket Type ) ; m Bt Worker Thread . start ( ) ; }
private static float alignment Probability ( Rectangle [ ] widget ) { float [ ] start = new float [ widget . length ] ; float [ ] center = new float [ widget . length ] ; float [ ] end = new float [ widget . length ] ; float width Sum = NUM_ ; int count = NUM_ ; for ( int i = NUM_ ; i < end . length ; i ++ ) { if ( widget [ i ] == null ) { start [ i ] = Float . Na N ; end [ i ] = Float . Na N ; center [ i ] = Float . Na N ; continue ; } start [ i ] = widget [ i ] . x ; end [ i ] = start [ i ] + widget [ i ] . width ; center [ i ] = ( start [ i ] + end [ i ] ) / NUM_ ; width Sum += widget [ i ] . width ; count ++ ; } float start Div = standard Deviation ( start ) ; float center Div = standard Deviation ( center ) ; float end Div = standard Deviation ( end ) ; if ( count > NUM_ ) { return NUM_ - Math . min ( start Div , Math . min ( center Div , end Div ) ) / ( width Sum / count ) ; } return NUM_ ; }
public List < Value Box > add Argument Hotspots ( String signature , int arg , List < Value Box > sig Spots ) { logger . debug ( STR_ + signature + STR_ + arg + STR_ + sig Spots . size ( ) + STR_ ) ; if ( ! sig Spots . is Empty ( ) ) { add Signature To Hotspot Map ( signature , new Hotspot ( signature , arg , sig Spots ) ) ; hotspots . add All ( sig Spots ) ; } return sig Spots ; }
public T File Index ( int entry Count , Data Input in , Bytes Comparator comparator ) throws IO Exception { index = new Array List < T File Index Entry > ( entry Count ) ; record Num Index = new Array List < Long > ( entry Count ) ; int size = Utils . read V Int ( in ) ; if ( size > NUM_ ) { byte [ ] buffer = new byte [ size ] ; in . read Fully ( buffer ) ; Data Input Stream first Key Input Stream = new Data Input Stream ( new Byte Array Input Stream ( buffer , NUM_ , size ) ) ; int first Key Length = Utils . read V Int ( first Key Input Stream ) ; first Key = new Byte Array ( new byte [ first Key Length ] ) ; first Key Input Stream . read Fully ( first Key . buffer ( ) ) ; for ( int i = NUM_ ; i < entry Count ; i ++ ) { size = Utils . read V Int ( in ) ; if ( buffer . length < size ) { buffer = new byte [ size ] ; } in . read Fully ( buffer , NUM_ , size ) ; T File Index Entry idx = new T File Index Entry ( new Data Input Stream ( new Byte Array Input Stream ( buffer , NUM_ , size ) ) ) ; index . add ( idx ) ; sum += idx . entries ( ) ; record Num Index . add ( sum ) ; } } else { if ( entry Count != NUM_ ) { throw new Runtime Exception ( STR_ ) ; } } this . comparator = comparator ; }
public void scan Child Nodes ( Node node , Type type ) { reset State ( ) ; for ( Iterator iter = node . get Child Iterator ( ) ; iter . has Next ( ) ; ) { invoke ( node , type , ( Node ) iter . next ( ) ) ; } }
public Moving Average Processor ( String type , double alpha ) { if ( ! VALID TYPES . contains ( type ) ) { throw new Illegal Argument Exception ( type + STR_ + STR_ ) ; } if ( ( alpha < NUM_ ) || ( alpha > NUM_ ) ) { throw new Illegal Argument Exception ( STR_ ) ; } this . type = type ; this . alpha = alpha ; }
public static void unforce Severe Alert Processing ( ) { Force Severe Alert Processing . set ( Boolean . FALSE ) ; }
public Internal Distributed Member ( Server Location location ) { this . host Name = location . get Host Name ( ) ; Inet Address addr = null ; try { addr = Inet Address . get By Name ( this . host Name ) ; } catch ( Unknown Host Exception e ) { throw new Gem Fire Config Exception ( STR_ + location , e ) ; } this . net Mbr = Member Factory . new Net Member ( addr , location . get Port ( ) ) ; this . vm Kind = Distribution Manager . NORMAL DM TYPE ; this . version Obj = Version . CURRENT ; }
public void edit Button Action Performed ( ) { cur Node = ( X Bee Node ) node Field . get Selected Item ( ) ; if ( cur Node == null ) { status Text 1 . set Text ( Bundle . get Message ( STR_ ) ) ; status Text 1 . set Visible ( true ) ; error In Status 1 = true ; reset Notes 2 ( ) ; return ; } jmri . util . Jmri J Frame edit Frame = new Edit Node Frame ( xtc , ( X Bee Node ) cur Node , this ) ; try { edit Frame . init Components ( ) ; } catch ( Exception ex ) { log . error ( STR_ , ex . to String ( ) ) ; return ; } edit Frame . set Visible ( true ) ; }
public static void create Project ( String qualified Module Name , String out Dir , Gwt Sdk gwt Runtime , I Progress Monitor monitor , String [ ] extra Class Path , String ... templates ) throws Core Exception { try { int process Status = Process Utilities . launch Process And Wait For ( compute Web App Creator Command Line ( qualified Module Name , out Dir , gwt Runtime , templates , extra Class Path ) , null , System . out , null ) ; if ( process Status != NUM_ ) { throw new Core Exception ( new Status ( I Status . ERROR , GWT Plugin . PLUGIN ID , STR_ + compute Web App Creator Class Name ( ) + STR_ ) ) ; } } catch ( IO Exception e ) { throw new Core Exception ( new Status ( I Status . ERROR , GWT Plugin . PLUGIN ID , e . get Localized Message ( ) , e ) ) ; } catch ( Interrupted Exception e ) { throw new Core Exception ( new Status ( I Status . ERROR , GWT Plugin . PLUGIN ID , e . get Localized Message ( ) , e ) ) ; } }
private static boolean is Out Of Memory ( Throwable t ) { boolean is Out Of Memory = false ; while ( ! is Out Of Memory && t != null ) { if ( t instanceof Out Of Memory Error ) { is Out Of Memory = true ; } else if ( t instanceof IO Exception ) { final String msg = t . to String ( ) ; if ( msg != null ) { is Out Of Memory = msg . contains ( STR_ ) ; } } t = t . get Cause ( ) ; } return is Out Of Memory ; }
public static Sha 256 Hash compute Hash ( byte [ ] bytes ) { Message Digest digest = get Message Digest ( ) ; return new Sha 256 Hash ( digest . digest ( bytes ) ) ; }
public synchronized void new Pixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = NUM_ ; w = width ; h = height ; } else { if ( x < NUM_ ) { w += x ; x = NUM_ ; } if ( x + w > width ) { w = width - x ; } if ( y < NUM_ ) { h += y ; y = NUM_ ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= NUM_ || h <= NUM_ ) && ! framenotify ) { return ; } Enumeration enum = the Consumers . elements ( ) ; while ( enum . has More Elements ( ) ) { Image Consumer ic = ( Image Consumer ) enum . next Element ( ) ; if ( w > NUM_ && h > NUM_ ) { send Pixels ( ic , x , y , w , h ) ; } if ( framenotify && is Consumer ( ic ) ) { ic . image Complete ( Image Consumer . SINGLEFRAMEDONE ) ; } } } }
private void write ( FCD Command command , long argument ) throws Lib Usb Exception { Byte Buffer buffer = Byte Buffer . allocate Direct ( NUM_ ) ; buffer . order ( Byte Order . LITTLE ENDIAN ) ; buffer . put ( NUM_ , command . get Command ( ) ) ; buffer . put Long ( NUM_ , argument ) ; write ( buffer ) ; }
public static List < File > remove Redundant Paths ( List < File > files ) throws IO Exception { final List < File > out = new Array List < > ( ) ; final Set < String > paths = new Hash Set < > ( ) ; for ( File file : files ) { if ( paths . add ( file . get Canonical Path ( ) ) ) { out . add ( file ) ; } } return out ; }
public static JSON Object read JSON Object ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Object . get JSON Object ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } JSON Object value = null ; if ( ! json Object . is Null ( key ) ) { value = json Object . get JSON Object ( key ) ; } return value ; }
public boolean equals ( Snmp Index index ) { if ( size != index . get Nb Components ( ) ) return false ; Snmp Oid oid 1 ; Snmp Oid oid 2 ; Vector < Snmp Oid > components = index . get Components ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { oid 1 = oids . element At ( i ) ; oid 2 = components . element At ( i ) ; if ( oid 1 . equals ( oid 2 ) == false ) return false ; } return true ; }
private static String format Exec Status ( Tungsten Properties props ) { Echo Status echo Status = ( Echo Status ) props . get Object ( STATUS KEY ) ; String status Message = props . get String ( STATUS MESSAGE KEY ) ; return String . format ( STR_ , echo Status . to String ( ) , status Message ) ; }
@ Override public int compare To ( Projected Energy o ) { return Double . compare ( projected Energy , o . projected Energy ) ; }
public static void copy File ( Carbon File source Location , String des Tination Location ) throws IO Exception { Input Stream input Stream = null ; Output Stream output Stream = null ; try { input Stream = File Factory . get Data Input Stream ( source Location . get Absolute Path ( ) , File Factory . get File Type ( source Location . get Absolute Path ( ) ) ) ; output Stream = File Factory . get Data Output Stream ( des Tination Location , File Factory . get File Type ( des Tination Location ) , NUM_ , true ) ; copy File ( input Stream , output Stream ) ; } finally { Carbon Util . close Streams ( input Stream , output Stream ) ; } }
protected Size 2 D arrange NF ( Block Container container , Graphics 2 D g 2 , Rectangle Constraint constraint ) { double height = constraint . get Height ( ) / this . rows ; Rectangle Constraint bc = constraint . to Fixed Height ( height ) ; List blocks = container . get Blocks ( ) ; double max W = NUM_ ; for ( int r = NUM_ ; r < this . rows ; r ++ ) { for ( int c = NUM_ ; c < this . columns ; c ++ ) { int index = r * this . columns + c ; if ( index >= blocks . size ( ) ) { break ; } Block b = ( Block ) blocks . get ( index ) ; if ( b != null ) { Size 2 D s = b . arrange ( g 2 , bc ) ; max W = Math . max ( max W , s . get Width ( ) ) ; } } } Rectangle Constraint cc = constraint . to Fixed Width ( max W * this . columns ) ; return arrange ( container , g 2 , cc ) ; }
protected Query Builder raw Query ( @ Nullable final String table , @ Non Null String sql ) { return raw Query On Many Tables ( table == null ? null : Collections . singleton ( table ) , sql ) ; }
public void lazy K Best Extract On HG ( Hyper Graph hg , int top N ) throws IO Exception { lazy K Best Extract On HG ( hg , top N , new Buffered Writer ( new Output Stream Writer ( System . out ) ) ) ; }
public void replace Callback ( int state , int index , Callback callback ) throws Auth Login Exception { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + state + STR_ + index + STR_ + callback ) ; } if ( state > state Length ) { throw new Auth Login Exception ( bundle Name , STR_ , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = get Callback ( state ) ; if ( index < NUM_ || index >= ext . length ) { throw new Auth Login Exception ( bundle Name , STR_ , new Object [ ] { new Integer ( index ) } ) ; } if ( callback == null ) { throw new Auth Login Exception ( bundle Name , STR_ , null ) ; } ext [ index ] = callback ; ( ( Callback [ ] ) internal . get ( state - NUM_ ) ) [ index + NUM_ ] = callback ; }
public static Serializable Object create PR Serializable Object ( String name , int id ) { Object obj = new Serializable Object ( name , id ) ; return ( Serializable Object ) obj ; }
public static int build table ( VLC vlc , int table nb bits , int nb codes , VL Ccode [ ] codes base , int codes offset , int flags ) { int table size , table index , index , code prefix , symbol , subtable bits ; int i , k , n , nb , inc ; long j ; long code ; short [ ] [ ] table base ; int table offset ; table size = NUM_ << table nb bits ; table index = alloc table ( vlc , table size , flags & INIT VLC USE NEW STATIC ) ; if ( table index < NUM_ ) return - NUM_ ; table base = vlc . table base ; table offset = vlc . table offset + table index ; for ( i = NUM_ ; i < table size ; i ++ ) { table base [ table offset + i ] [ NUM_ ] = NUM_ ; table base [ table offset + i ] [ NUM_ ] = - NUM_ ; } for ( i = NUM_ ; i < nb codes ; i ++ ) { n = codes base [ codes offset + i ] . bits ; code = codes base [ codes offset + i ] . code ; symbol = codes base [ codes offset + i ] . symbol ; if ( n <= table nb bits ) { long tmp = code & NUM_ ; j = ( int ) ( tmp > > ( NUM_ - table nb bits ) ) ; nb = NUM_ << ( table nb bits - n ) ; inc = NUM_ ; if ( ( flags & INIT VLC LE ) != NUM_ ) { j = bitswap 32 ( code ) ; inc = NUM_ << n ; } for ( k = NUM_ ; k < nb ; k ++ ) { if ( table base [ ( int ) ( table offset + j ) ] [ NUM_ ] != NUM_ ) { return - NUM_ ; } table base [ ( int ) ( table offset + j ) ] [ NUM_ ] = ( short ) n ; table base [ ( int ) ( table offset + j ) ] [ NUM_ ] = ( short ) symbol ; j += inc ; } } else { n -= table nb bits ; long tmp = code & NUM_ ; code prefix = ( int ) ( tmp > > ( NUM_ - table nb bits ) ) ; subtable bits = n ; codes base [ codes offset + i ] . bits = n ; codes base [ codes offset + i ] . code = code << table nb bits ; for ( k = i + NUM_ ; k < nb codes ; k ++ ) { n = codes base [ codes offset + k ] . bits - table nb bits ; if ( n <= NUM_ ) break ; code = codes base [ codes offset + k ] . code ; if ( code > > ( NUM_ - table nb bits ) != code prefix ) break ; codes base [ codes offset + k ] . bits = n ; codes base [ codes offset + k ] . code = code << table nb bits ; subtable bits = Math . max ( subtable bits , n ) ; } subtable bits = Math . min ( subtable bits , table nb bits ) ; j = ( ( flags & INIT VLC LE ) != NUM_ ) ? ( bitswap 32 ( code prefix ) > > ( NUM_ - table nb bits ) ) : code prefix ; table base [ ( int ) ( table offset + j ) ] [ NUM_ ] = ( short ) - subtable bits ; index = build table ( vlc , subtable bits , k - i , codes base , codes offset + i , flags ) ; if ( index < NUM_ ) return - NUM_ ; table base = vlc . table base ; table offset = vlc . table offset + table index ; table base [ ( int ) ( table offset + j ) ] [ NUM_ ] = ( short ) index ; i = k - NUM_ ; } } return table index ; }
private static boolean has Specialized Handler Intents ( Context context , Intent intent ) { try { Package Manager pm = context . get Package Manager ( ) ; List < Resolve Info > handlers = pm . query Intent Activities ( intent , Package Manager . GET RESOLVED FILTER ) ; if ( handlers == null || handlers . size ( ) == NUM_ ) { return false ; } for ( Resolve Info resolve Info : handlers ) { Intent Filter filter = resolve Info . filter ; if ( filter == null ) continue ; if ( filter . count Data Authorities ( ) == NUM_ || filter . count Data Paths ( ) == NUM_ ) continue ; if ( resolve Info . activity Info == null ) continue ; return true ; } } catch ( Runtime Exception e ) { App Log . e ( TAG , STR_ ) ; } return false ; }
public void exit Program ( ) { fire Property Change ( STR_ , null , null ) ; }
@ Override public void build Classifier ( Database database , Relation < ? extends Class Label > labelrep ) { T Object Int Map < Class Label > count = new T Object Int Hash Map < > ( ) ; for ( DBID Iter iter = labelrep . iter DBI Ds ( ) ; iter . valid ( ) ; iter . advance ( ) ) { count . adjust Or Put Value ( labelrep . get ( iter ) , NUM_ , NUM_ ) ; } int max = Integer . MIN VALUE ; double size = labelrep . size ( ) ; distribution = new double [ count . size ( ) ] ; labels = new Array List < > ( count . size ( ) ) ; T Object Int Iterator < Class Label > iter = count . iterator ( ) ; for ( int i = NUM_ ; iter . has Next ( ) ; ++ i ) { iter . advance ( ) ; distribution [ i ] = iter . value ( ) / size ; labels . add ( iter . key ( ) ) ; if ( iter . value ( ) > max ) { max = iter . value ( ) ; prediction = iter . key ( ) ; } } }
public static final G Code Flavor taste Flavor ( Resources res , int res Id ) throws IO Exception , Not Found Exception { Buffered Input Stream buffer = new Buffered Input Stream ( res . open Raw Resource ( res Id ) ) ; G Code Flavor ret = taste Flavor ( buffer ) ; buffer . close ( ) ; return ret ; }
public void clean Up Listeners ( ) { synchronized ( listener Object Map ) { for ( Object Name object Name : listener Object Map . key Set ( ) ) { Notification Hub Listener listener = listener Object Map . get ( object Name ) ; if ( listener != null ) { try { mbean Server . remove Notification Listener ( object Name , listener ) ; } catch ( Listener Not Found Exception e ) { } catch ( Instance Not Found Exception e ) { } } } } listener Object Map . clear ( ) ; }
public boolean add Extent ( Geo Extent extent ) { boolean ret = false ; try { Bounding Circle bc = extent . get Bounding Circle ( ) ; if ( bc == null ) { discarded . add ( extent ) ; return false ; } Geo center = bc . get Center ( ) ; double clon = center . get Longitude ( ) ; double clat = center . get Latitude ( ) ; double rnm = Geo . nm ( bc . get Radius ( ) ) ; if ( ( clat == NUM_ && clon == - NUM_ ) || rnm >= NUM_ * NUM_ ) { discarded . add ( extent ) ; } else { all . add ( extent ) ; double latfactor = Geo . npd At Lat ( clat ) ; if ( latfactor == NUM_ ) { polar . add ( extent ) ; ret = true ; } else { double xd = ( rnm + margin ) / latfactor ; if ( xd >= NUM_ ) { polar . add ( extent ) ; ret = true ; } else { double [ ] lons = normalize Lons ( new double [ ] { clon - xd , clon + xd } ) ; int lb = bucket For ( lons [ NUM_ ] ) ; int rb = bucket For ( lons [ NUM_ ] ) ; if ( rb < lb ) rb += nbuckets ; for ( int i = lb ; i <= rb ; i ++ ) { int x = i % nbuckets ; Collection b = buckets [ x ] ; if ( b == null ) { b = make Bucket ( NUM_ ) ; buckets [ x ] = b ; } b . add ( extent ) ; ret = true ; } } } } } catch ( Exception e ) { } return ret ; }
public Service Config create Global Config ( Map attrs ) throws SMS Exception , SSO Exception { validate SSM ( ) ; Service Schema Impl ss = ssm . get Schema ( Schema Type . GLOBAL ) ; if ( ss == null ) { String [ ] args = { service Name } ; throw ( new SMS Exception ( IUMS Constants . UMS BUNDLE NAME , STR_ , args ) ) ; } String org DN = scm . construct Service Config DN ( SMS Utils . DEFAULT , Create Service Config . GLOBAL CONFIG NODE , null ) ; try { Create Service Config . create Sub Config Entry ( token , org DN , ss , null , null , attrs , SMS Entry . base DN ) ; } catch ( Service Already Exists Exception slee ) { } return ( get Global Config ( null ) ) ; }
private void reset Filter Flags ( List < T > items ) { for ( int i = NUM_ ; i < items . size ( ) ; i ++ ) { T item = items . get ( i ) ; item . set Hidden ( false ) ; if ( is Expandable ( item ) ) { I Expandable expandable = ( I Expandable ) item ; if ( m Expanded Filter Flags != null ) expandable . set Expanded ( m Expanded Filter Flags . contains ( expandable ) ) ; if ( has Sub Items ( expandable ) ) { List < T > sub Items = expandable . get Sub Items ( ) ; for ( T sub Item : sub Items ) { sub Item . set Hidden ( false ) ; if ( expandable . is Expanded ( ) ) { i ++ ; if ( i < items . size ( ) ) items . add ( i , sub Item ) ; else items . add ( sub Item ) ; } } } } } m Expanded Filter Flags = null ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! super . equals ( obj ) ) { return false ; } if ( ! ( obj instanceof Waterfall Bar Renderer ) ) { return false ; } Waterfall Bar Renderer that = ( Waterfall Bar Renderer ) obj ; if ( ! Paint Utilities . equal ( this . first Bar Paint , that . first Bar Paint ) ) { return false ; } if ( ! Paint Utilities . equal ( this . last Bar Paint , that . last Bar Paint ) ) { return false ; } if ( ! Paint Utilities . equal ( this . positive Bar Paint , that . positive Bar Paint ) ) { return false ; } if ( ! Paint Utilities . equal ( this . negative Bar Paint , that . negative Bar Paint ) ) { return false ; } return true ; }
public void delete Metadata Entry ( int i ) { if ( i < metadata . size ( ) ) { metadata . remove ( i ) ; } }
private static synchronized void start Transaction ( Connection C ) throws Ade Exception { logger . trace ( STR_ ) ; try { C . set Auto Commit ( false ) ; } catch ( Throwable t ) { surface Throwable ( STR_ , t ) ; throw ade Exception Of ( t ) ; } logger . trace ( STR_ ) ; }
public static long start ( @ Non Null String key ) { long now = System . current Time Millis ( ) ; Map < String , Long > current Map = map . get ( ) ; Optional < Long > maybe Previous Instant = Optional . with ( current Map . get ( key ) ) ; if ( maybe Previous Instant . is Defined ( ) ) { Log . warn ( Timer . class , STR_ , key ) ; } current Map . put ( key , now ) ; map . get And Set ( current Map ) ; return now ; }
public Fact Line balance Source ( ) { if ( ! m acct Schema . is Suspense Balancing ( ) || m doc . is Multi Currency ( ) ) return null ; Big Decimal diff = get Source Balance ( ) ; log . finer ( STR_ + diff ) ; Fact Line line = new Fact Line ( m doc . get Ctx ( ) , m doc . get Table ID ( ) , m doc . get ID ( ) , NUM_ , m trx Name ) ; line . set Document Info ( m doc , null ) ; line . set Posting Type ( m posting Type ) ; line . set Account ( m acct Schema , m acct Schema . get Suspense Balancing Acct ( ) ) ; if ( diff . signum ( ) < NUM_ ) line . set Amt Source ( m doc . get C Currency ID ( ) , diff . abs ( ) , Env . ZERO ) ; else line . set Amt Source ( m doc . get C Currency ID ( ) , Env . ZERO , diff ) ; line . convert ( ) ; log . fine ( line . to String ( ) ) ; m lines . add ( line ) ; return line ; }
private void reflect Member Variables In Right Button ( ) { final boolean last Page Reached = ( view Pager . get Current Item ( ) + NUM_ ) == pages . size ( ) ; final boolean button Should Be Invisible = last Page Reached || right Button Disabled ; final boolean button Is Currently Invisible = right Button . get Visibility ( ) == View . INVISIBLE ; final boolean should Update Button = button Should Be Invisible != button Is Currently Invisible ; if ( should Update Button ) { final Animator button Animator = button Should Be Invisible ? button Animator Factory . new Right Button Disappear Animator ( right Button ) : button Animator Factory . new Right Button Appear Animator ( right Button ) ; if ( button Should Be Invisible ) { disable Button ( button Animator , right Button ) ; } else { enable Button ( button Animator , right Button ) ; } } }
@ Override public Axis Space reserve Space ( Graphics 2 D g 2 , Plot plot , Rectangle 2 D plot Area , Rectangle Edge edge , Axis Space space ) { if ( space == null ) { space = new Axis Space ( ) ; } if ( ! is Visible ( ) ) { return space ; } double tick Label Height = NUM_ ; double tick Label Width = NUM_ ; if ( is Tick Labels Visible ( ) ) { g 2 . set Font ( get Tick Label Font ( ) ) ; Axis State state = new Axis State ( ) ; refresh Ticks ( g 2 , state , plot Area , edge ) ; if ( edge == Rectangle Edge . TOP ) { tick Label Height = state . get Max ( ) ; } else if ( edge == Rectangle Edge . BOTTOM ) { tick Label Height = state . get Max ( ) ; } else if ( edge == Rectangle Edge . LEFT ) { tick Label Width = state . get Max ( ) ; } else if ( edge == Rectangle Edge . RIGHT ) { tick Label Width = state . get Max ( ) ; } } Rectangle 2 D label Enclosure = get Label Enclosure ( g 2 , edge ) ; double label Height , label Width ; if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { label Height = label Enclosure . get Height ( ) ; space . add ( label Height + tick Label Height + this . category Label Position Offset , edge ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { label Width = label Enclosure . get Width ( ) ; space . add ( label Width + tick Label Width + this . category Label Position Offset , edge ) ; } return space ; }
private Composite Transaction Imp create CT ( String tid , Coordinator Imp coordinator , Stack < Composite Transaction > lineage , boolean serial ) throws Sys Exception { if ( LOGGER . is Trace Enabled ( ) ) LOGGER . log Trace ( STR_ + tid ) ; Composite Transaction Imp ct = new Composite Transaction Imp ( this , lineage , tid , serial , coordinator ) ; set Tid To Tx ( ct . get Tid ( ) , ct ) ; return ct ; }
@ Override protected Map < String , Object > generate Config ( Subject subject , Map shared State , Map options ) { String idle Time String = Collection Helper . get Map Attr ( options , COOKIE IDLE TIMEOUT SETTING KEY ) ; String max Life String = Collection Helper . get Map Attr ( options , COOKIE MAX LIFE SETTING KEY ) ; if ( String Utils . is Empty ( idle Time String ) ) { DEBUG . warning ( STR_ ) ; idle Time String = STR_ ; } if ( String Utils . is Empty ( max Life String ) ) { DEBUG . warning ( STR_ ) ; max Life String = STR_ ; } token Idle Time = Integer . parse Int ( idle Time String ) * MINUTES IN HOUR ; max Token Life = Integer . parse Int ( max Life String ) * MINUTES IN HOUR ; enforce Client IP = Collection Helper . get Boolean Map Attr ( options , ENFORCE CLIENT IP SETTING KEY , false ) ; secure Cookie = Collection Helper . get Boolean Map Attr ( options , SECURE COOKIE KEY , true ) ; http Only Cookie = Collection Helper . get Boolean Map Attr ( options , HTTP ONLY COOKIE KEY , true ) ; cookie Name = Collection Helper . get Map Attr ( options , COOKIE NAME KEY ) ; cookie Domains = core Wrapper . get Cookie Domains For Request ( get Http Servlet Request ( ) ) ; String hmac Key = Collection Helper . get Map Attr ( options , HMAC KEY ) ; encrypted Hmac Key = Access Controller . do Privileged ( new Encode Action ( hmac Key ) ) ; try { return persistent Cookie Module Wrapper . generate Config ( token Idle Time . to String ( ) , max Token Life . to String ( ) , enforce Client IP , get Request Org ( ) , secure Cookie , http Only Cookie , cookie Name , cookie Domains , hmac Key ) ; } catch ( SMS Exception e ) { DEBUG . error ( STR_ , e ) ; return null ; } catch ( SSO Exception e ) { DEBUG . error ( STR_ , e ) ; return null ; } }
public static boolean looks Like Bluetooth Address ( String s ) { return Pattern . matches ( STR_ , s ) ; }
protected String generate User Password Line ( User user , String realm ) { String to Hash = user . get Name ( ) + STR_ + realm + STR_ + user . get Password ( ) ; byte [ ] hash ; try { hash = md 5 . digest ( to Hash . get Bytes ( STR_ ) ) ; } catch ( Unsupported Encoding Exception e ) { throw new Cargo Exception ( STR_ + STR_ , e ) ; } String Builder sb = new String Builder ( ) ; sb . append ( user . get Name ( ) ) ; sb . append ( STR_ ) ; for ( byte hash Byte : hash ) { sb . append ( String . format ( STR_ , hash Byte ) ) ; } sb . append ( STR_ ) ; return sb . to String ( ) ; }
private Workflow . Method create Attach Mirror Method ( URI vplex URI , URI vplex Volume URI , URI mirror Volume URI , URI cg URI , String detach Step Id ) { return new Workflow . Method ( ATTACH MIRROR METHOD NAME , vplex URI , vplex Volume URI , mirror Volume URI , cg URI , detach Step Id ) ; }
@ Override public void incoming Object ( I Analyzed Interval analyzed Interval ) throws Ade Exception { for ( I Analyzed Message Summary ams : analyzed Interval . get Analyzed Messages ( ) ) { final String id = ams . get Message Id ( ) ; Msg Data data = m msg Data . get ( id ) ; if ( data == null ) { data = new Msg Data ( ) ; m msg Data . put ( id , data ) ; } if ( ! is Clustered ( ams ) ) { data . m total Log Counts += Math . log ( ams . get Number Of Appearances ( ) ) ; data . m interval Count ++ ; } data . m all Count += ams . get Number Of Appearances ( ) ; data . m interval All Count ++ ; if ( data . m max Num Appearance < ams . get Number Of Appearances ( ) ) { data . m max Num Appearance = ams . get Number Of Appearances ( ) ; } } ++ m total Interval Count ; }
public Managed Resource cleanup Region Resources ( String region Path ) { Managed Resource cleaned = null ; synchronized ( this . managed Region Resources Map ) { Set < Entry < String , System Member Region Jmx Impl > > entries = managed Region Resources Map . entry Set ( ) ; for ( Iterator < Entry < String , System Member Region Jmx Impl > > it = entries . iterator ( ) ; it . has Next ( ) ; ) { Entry < String , System Member Region Jmx Impl > entry = it . next ( ) ; System Member Region Jmx Impl managed Resource = entry . get Value ( ) ; Object Name obj Name = managed Resource . get Object Name ( ) ; String path Prop = obj Name . get Key Property ( STR_ ) ; if ( path Prop != null && path Prop . equals ( region Path ) ) { cleaned = managed Resource ; it . remove ( ) ; break ; } } } return cleaned ; }
public Trie lookup ( Char Sequence s ) { Trie t = this ; for ( int i = NUM_ , n = s . length ( ) ; i < n ; ++ i ) { t = t . lookup ( s . char At ( i ) ) ; if ( null == t ) { break ; } } return t ; }
@ Override public boolean print Dialog ( ) throws Headless Exception { if ( Graphics Environment . is Headless ( ) ) { throw new Headless Exception ( ) ; } if ( attributes == null ) { attributes = new Hash Print Request Attribute Set ( ) ; } if ( ! ( get Print Service ( ) instanceof Win 32 Print Service ) ) { return super . print Dialog ( attributes ) ; } if ( no Default Printer == true ) { return false ; } else { return display Native Dialog ( ) ; } }
public static long [ ] preprocess Spooky 4 ( final Bit Vector bv , final long seed ) { final long length = bv . length ( ) ; if ( length < Long . SIZE * NUM_ ) return null ; final long [ ] state = new long [ NUM_ * ( int ) ( length + Long . SIZE * NUM_ ) / ( NUM_ * Long . SIZE ) ] ; long h 0 , h 1 , h 2 , h 3 ; h 0 = seed ; h 1 = seed ; h 2 = ARBITRARY BITS ; h 3 = ARBITRARY BITS ; long remaining = length ; long pos = NUM_ ; int p = NUM_ ; for ( ; ; ) { h 2 += bv . get Long ( pos + NUM_ * Long . SIZE , pos + NUM_ * Long . SIZE ) ; h 3 += bv . get Long ( pos + NUM_ * Long . SIZE , pos + NUM_ * Long . SIZE ) ; h 2 = Long . rotate Left ( h 2 , NUM_ ) ; h 2 += h 3 ; h 0 ^= h 2 ; h 3 = Long . rotate Left ( h 3 , NUM_ ) ; h 3 += h 0 ; h 1 ^= h 3 ; h 0 = Long . rotate Left ( h 0 , NUM_ ) ; h 0 += h 1 ; h 2 ^= h 0 ; h 1 = Long . rotate Left ( h 1 , NUM_ ) ; h 1 += h 2 ; h 3 ^= h 1 ; h 2 = Long . rotate Left ( h 2 , NUM_ ) ; h 2 += h 3 ; h 0 ^= h 2 ; h 3 = Long . rotate Left ( h 3 , NUM_ ) ; h 3 += h 0 ; h 1 ^= h 3 ; h 0 = Long . rotate Left ( h 0 , NUM_ ) ; h 0 += h 1 ; h 2 ^= h 0 ; h 1 = Long . rotate Left ( h 1 , NUM_ ) ; h 1 += h 2 ; h 3 ^= h 1 ; h 2 = Long . rotate Left ( h 2 , NUM_ ) ; h 2 += h 3 ; h 0 ^= h 2 ; h 3 = Long . rotate Left ( h 3 , NUM_ ) ; h 3 += h 0 ; h 1 ^= h 3 ; h 0 = Long . rotate Left ( h 0 , NUM_ ) ; h 0 += h 1 ; h 2 ^= h 0 ; h 1 = Long . rotate Left ( h 1 , NUM_ ) ; h 1 += h 2 ; h 3 ^= h 1 ; state [ p + NUM_ ] = h 0 ; state [ p + NUM_ ] = h 1 ; state [ p + NUM_ ] = h 2 ; state [ p + NUM_ ] = h 3 ; p += NUM_ ; if ( remaining >= Long . SIZE * NUM_ ) { h 0 += bv . get Long ( pos + NUM_ * Long . SIZE , pos + NUM_ * Long . SIZE ) ; h 1 += bv . get Long ( pos + NUM_ * Long . SIZE , pos + NUM_ * Long . SIZE ) ; remaining -= NUM_ * Long . SIZE ; pos += NUM_ * Long . SIZE ; } else return state ; } }
void delete Replica Based On Count ( Cluster State cluster State , Zk Node Props message , Named List results , Runnable on Complete , boolean parallel ) throws Keeper Exception , Interrupted Exception { ocmh . check Required ( message , COLLECTION PROP , COUNT PROP ) ; int count = Integer . parse Int ( message . get Str ( COUNT PROP ) ) ; String collection Name = message . get Str ( COLLECTION PROP ) ; String shard = message . get Str ( SHARD ID PROP ) ; Doc Collection coll = cluster State . get Collection ( collection Name ) ; Slice slice = null ; if ( shard != null ) { slice = coll . get Slice ( shard ) ; if ( slice == null ) { throw new Solr Exception ( Solr Exception . Error Code . BAD REQUEST , STR_ + shard + STR_ + collection Name ) ; } } Map < Slice , Set < String > > shard To Replicas Mapping = new Hash Map < Slice , Set < String > > ( ) ; if ( slice != null ) { Set < String > replicas To Be Deleted = pick Replicas Tobe Deleted ( slice , shard , collection Name , count ) ; shard To Replicas Mapping . put ( slice , replicas To Be Deleted ) ; } else { Collection < Slice > all Slices = coll . get Slices ( ) ; for ( Slice individual Slice : all Slices ) { Set < String > replicas To Be Deleted = pick Replicas Tobe Deleted ( individual Slice , individual Slice . get Name ( ) , collection Name , count ) ; shard To Replicas Mapping . put ( individual Slice , replicas To Be Deleted ) ; } } for ( Slice shard Slice : shard To Replicas Mapping . key Set ( ) ) { String shard Id = shard Slice . get Name ( ) ; Set < String > replicas = shard To Replicas Mapping . get ( shard Slice ) ; for ( String replica : replicas ) { log . debug ( STR_ , replica , shard Id , count ) ; delete Core ( shard Slice , collection Name , replica , message , shard , results , on Complete , parallel ) ; } results . add ( STR_ , shard Id ) ; results . add ( STR_ , replicas ) ; } }
private void ask Permissions ( ) { m Permissions To Ask = get Not Granted Permissions ( ) ; if ( m Permissions To Ask . size ( ) > NUM_ && Build . VERSION . SDK INT >= Build . VERSION CODES . M ) { request Permissions ( m Permissions To Ask . to Array ( new String [ m Permissions To Ask . size ( ) ] ) , MY PERMISSION REQUEST ALL ) ; } else { on Click After Check Permissions ( ) ; } }
static private void check Head Of Deadline Queue ( final long now Nanos , final Priority Blocking Queue < Query Deadline > deadline Queue ) { Query Deadline x ; while ( ( x = deadline Queue . poll ( ) ) != null ) { if ( x . check Deadline ( now Nanos ) == null ) { continue ; } if ( x . deadline Nanos > now Nanos ) { deadline Queue . add ( x ) ; break ; } } }
public static double weighted Coefficient ( double [ ] x , double [ ] y , double [ ] weights ) { final int xdim = x . length ; final int ydim = y . length ; if ( xdim != ydim ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( xdim != weights . length ) { throw new Illegal Argument Exception ( STR_ ) ; } double sum XX = NUM_ , sum YY = NUM_ , sum XY = NUM_ , sum We = weights [ NUM_ ] ; double mean X = x [ NUM_ ] , mean Y = y [ NUM_ ] ; for ( int i = NUM_ ; i < xdim ; ++ i ) { final double xv = x [ i ] , yv = y [ i ] , w = weights [ i ] ; final double delta X = xv - mean X ; final double delta Y = yv - mean Y ; sum We += w ; mean X += delta X * w / sum We ; mean Y += delta Y * w / sum We ; final double nelta X = xv - mean X ; final double nelta Y = yv - mean Y ; sum XX += w * delta X * nelta X ; sum YY += w * delta Y * nelta Y ; sum XY += w * delta X * nelta Y ; } if ( ! ( sum XX > NUM_ && sum YY > NUM_ ) ) { return ( sum XX == sum YY ) ? NUM_ : NUM_ ; } return sum XY / Math . sqrt ( sum XX * sum YY ) ; }
void initialize ( ) { on Disk Order . clear ( ) ; }
public static String [ ] retrieve Display Names ( String id , Locale locale ) { Objects . require Non Null ( id ) ; Objects . require Non Null ( locale ) ; return retrieve Display Names Impl ( id , locale ) ; }
public final boolean has Media ( ) { return media Components != null && media Components . size ( ) > NUM_ ; }
synchronized protected void timeout ( ) { if ( boot State == Boot State . CRSENT ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ ) ; } request Boot ( ) ; } else if ( boot State == Boot State . VERREQSENT ) { log . error ( STR_ ) ; J Option Pane . show Message Dialog ( this , STR_ , STR_ , J Option Pane . ERROR MESSAGE ) ; status Bar . set Text ( STR_ ) ; boot State = Boot State . IDLE ; tc . set Sprog State ( Sprog State . NORMAL ) ; } else if ( boot State == Boot State . WRITESENT ) { log . error ( STR_ ) ; J Option Pane . show Message Dialog ( this , STR_ , STR_ , J Option Pane . ERROR MESSAGE ) ; status Bar . set Text ( STR_ ) ; boot State = Boot State . IDLE ; tc . set Sprog State ( Sprog State . NORMAL ) ; } else if ( boot State == Boot State . NULLWRITE ) { if ( hex File . read ( ) > NUM_ ) { send Write ( ) ; } else { done Writing ( ) ; } } }
public Raptor State ( int n Stops ) { this . best Times = new int [ n Stops ] ; this . best Non Transfer Times = new int [ n Stops ] ; Arrays . fill ( best Times , Raptor Worker . UNREACHED ) ; Arrays . fill ( best Non Transfer Times , Raptor Worker . UNREACHED ) ; this . previous Patterns = new int [ n Stops ] ; this . previous Stop = new int [ n Stops ] ; this . transfer Stop = new int [ n Stops ] ; Arrays . fill ( previous Patterns , - NUM_ ) ; Arrays . fill ( previous Stop , - NUM_ ) ; Arrays . fill ( transfer Stop , - NUM_ ) ; this . in Vehicle Travel Time = new int [ n Stops ] ; this . wait Time = new int [ n Stops ] ; this . non Transfer Wait Time = new int [ n Stops ] ; this . non Transfer In Vehicle Travel Time = new int [ n Stops ] ; }
public static void on Pause ( ) { Log . i ( TAG , STR_ ) ; dismiss Dialog ( dialog ) ; if ( timer Task Hide != null ) timer Task Hide . cancel ( ) ; if ( timer Task Show != null ) timer Task Show . cancel ( ) ; Log . i ( TAG , STR_ ) ; }
protected Rect update Fast Scroller Bounds ( Fast Scroll Recycler View rv , int last Touch Y ) { invalidate Rect . set ( background Bounds ) ; if ( is Visible ( ) ) { int edge Padding = rv . get Max Scrollbar Width ( ) ; int bg Padding = ( original Background Size - text Bounds . height ( ) ) / NUM_ ; int bg Height = original Background Size ; int bg Width = Math . max ( original Background Size , text Bounds . width ( ) + ( NUM_ * bg Padding ) ) ; if ( Utilities . is Rtl ( resources ) ) { background Bounds . left = rv . get Background Padding ( ) . left + ( NUM_ * rv . get Max Scrollbar Width ( ) ) ; background Bounds . right = background Bounds . left + bg Width ; } else { background Bounds . right = rv . get Width ( ) - rv . get Background Padding ( ) . right - ( NUM_ * rv . get Max Scrollbar Width ( ) ) ; background Bounds . left = background Bounds . right - bg Width ; } background Bounds . top = last Touch Y - ( int ) ( FAST SCROLL OVERLAY Y OFFSET FACTOR * bg Height ) ; background Bounds . top = Math . max ( edge Padding , Math . min ( background Bounds . top , rv . get Height ( ) - edge Padding - bg Height ) ) ; background Bounds . bottom = background Bounds . top + bg Height ; } else { background Bounds . set Empty ( ) ; } invalidate Rect . union ( background Bounds ) ; return invalidate Rect ; }
private void on Put ( Array List < Watch Entry > list , byte [ ] key ) { if ( list != null ) { int size = list . size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { Watch Entry entry = list . get ( i ) ; Row Cursor row Cursor = table . cursor ( ) ; row Cursor . set Key ( key , NUM_ ) ; Env Kelp env Kelp = null ; Cursor Kraken cursor = new Cursor Kraken ( table ( ) , env Kelp , row Cursor , results ) ; entry . on Put ( cursor ) ; } } }
private static void load Package Data ( Context context ) { if ( context != null ) { try { Package Manager package Manager = context . get Package Manager ( ) ; Package Info package Info = package Manager . get Package Info ( context . get Package Name ( ) , NUM_ ) ; Crash Constants . APP PACKAGE = package Info . package Name ; Crash Constants . APP VERSION = STR_ + package Info . version Code ; Crash Constants . APP VERSION NAME = package Info . version Name ; int build Number = load Build Number ( context , package Manager ) ; if ( ( build Number != NUM_ ) && ( build Number > package Info . version Code ) ) { Crash Constants . APP VERSION = STR_ + build Number ; } } catch ( Package Manager . Name Not Found Exception e ) { L . e ( STR_ ) ; e . print Stack Trace ( ) ; } } }
private String create Aircraft Symbol Code ( String country , String airport Use ) { String identity ; if ( friends . contains ( country ) ) { identity = STR_ ; } else if ( neutrals . contains ( country ) ) { identity = STR_ ; } else if ( hostiles . contains ( country ) ) { identity = STR_ ; } else { identity = STR_ ; } String type ; switch ( airport Use ) { case Airport . MILITARY : case Airport . JOINT : type = STR_ ; break ; case Airport . CIVILIAN : case Airport . OTHER : type = STR_ ; break ; default : type = STR_ ; } return STR_ + identity + STR_ + type + STR_ + country + STR_ ; }
private static void write String To Output ( String str , Data Output out ) throws IO Exception { out . write Int ( str . length ( ) ) ; out . write Chars ( str ) ; }
protected static void emit parser ( ) throws internal error { emit . symbols ( symbol class file , include non terms ) ; emit . parser ( parser class file , action table , reduce table , start state . index ( ) , emit . start production , opt compact red ) ; }
protected static void append Char Type ( String Builder sb ) { sb . append ( STR_ ) ; }
protected synchronized boolean find And Remove Entry ( Map . Entry entry ) { Object key = entry . get Key ( ) ; Object v = get ( key ) ; if ( v != null && v . equals ( entry . get Value ( ) ) ) { remove ( key ) ; return true ; } else return false ; }
public static boolean below Than ( long a , long b ) { return Long . compare Unsigned ( a , b ) < NUM_ ; }
protected int hash Entry ( Object key , Object value ) { return ( key == null ? NUM_ : key . hash Code ( ) ) ^ ( value == null ? NUM_ : value . hash Code ( ) ) ; }
public void add Data To Store ( Object [ ] row ) throws Carbon Data Writer Exception { data Rows . add ( row ) ; this . entry Count ++ ; if ( this . entry Count == this . blocklet Size ) { try { semaphore . acquire ( ) ; producer Executor Service Task List . add ( producer Executor Service . submit ( new Producer ( blocklet Data Holder , data Rows , ++ writer Task Sequence Counter ) ) ) ; blocklet Processing Count . increment And Get ( ) ; processed Data Count += entry Count ; LOGGER . info ( STR_ + processed Data Count ) ; data Rows = new Array List < > ( this . blocklet Size ) ; this . entry Count = NUM_ ; } catch ( Interrupted Exception e ) { LOGGER . error ( e , e . get Message ( ) ) ; throw new Carbon Data Writer Exception ( e . get Message ( ) ) ; } } }
public final String identifier String ( ) { if ( address != - NUM_ ) { return String . format ( STR_ , address ) ; } return Hex . u 4 ( System . identity Hash Code ( this ) ) ; }
private void prepare RP Consistency Group Data ( ) throws Exception { log . info ( STR_ ) ; Tenant Org tenant Org = new Tenant Org ( ) ; URI tenant Org URI = URI Util . create Id ( Tenant Org . class ) ; tenant Org . set Id ( tenant Org URI ) ; db Client . create Object ( tenant Org ) ; Project proj = new Project ( ) ; URI project URI = URI Util . create Id ( Project . class ) ; String project Label = STR_ ; proj . set Id ( project URI ) ; proj . set Label ( project Label ) ; proj . set Tenant Org ( new Named URI ( tenant Org URI , project Label ) ) ; db Client . create Object ( proj ) ; Protection Set cg 1 ps = create Protection Set Data ( STR_ , project URI ) ; List < Volume > cg 1 Volumes = create Rp Volumes ( STR_ , NUM_ , cg 1 ps ) ; cg 1 Volumes . add All ( create Rp Volumes ( STR_ , NUM_ , cg 1 ps ) ) ; add Volumes To Protection Set ( cg 1 ps . get Id ( ) , cg 1 Volumes ) ; create Block Snapshot Data ( STR_ , cg 1 Volumes ) ; Protection Set cg 2 ps = create Protection Set Data ( STR_ , project URI ) ; List < Volume > cg 2 Volumes = create Rp Volumes ( STR_ , NUM_ , cg 2 ps ) ; cg 2 Volumes . add All ( create Rp Volumes ( STR_ , NUM_ , cg 2 ps ) ) ; add Volumes To Protection Set ( cg 2 ps . get Id ( ) , cg 2 Volumes ) ; create Block Snapshot Data ( STR_ , cg 2 Volumes ) ; Protection Set cg 3 ps = create Protection Set Data ( STR_ , project URI ) ; List < Volume > cg 3 Volumes = create Rp Volumes ( STR_ , NUM_ , cg 3 ps ) ; add Volumes To Protection Set ( cg 3 ps . get Id ( ) , cg 3 Volumes ) ; create Block Snapshot Data ( STR_ , cg 3 Volumes ) ; for ( URI volume URI : rp Test Volume UR Is ) { Volume volume = db Client . query Object ( Volume . class , volume URI ) ; Assert . assert Not Null ( String . format ( STR_ , volume URI ) , volume ) ; } }
@ Transactional public Revision Petition update Revision Petition ( Revision Petition objection ) { if ( objection . get Id ( ) == null ) objection = persist ( objection ) ; else objection = update ( objection ) ; return objection ; }
List < I Navi Module > initialize Raw Modules ( final List < I Navi Module > modules , final List < I Navi Raw Module > raw Modules ) { final List < I Navi Module > new Modules = new Array List < I Navi Module > ( ) ; for ( final I Navi Raw Module raw Module : raw Modules ) { if ( ! has Module ( modules , raw Module ) ) { try { new Modules . add ( create Module ( raw Module ) ) ; } catch ( Couldnt Load Data Exception | Couldnt Save Data Exception e ) { C Utility Functions . log Exception ( e ) ; } } } return new Modules ; }
private void extract Job Definitions From Stage Definitions ( List < Stage Definition > stage Definitions , List < Job Definition > job Definitions ) { for ( Stage Definition stage Definition : stage Definitions ) { List < Job Definition > job Definitions List = stage Definition . get Job Definitions ( ) ; job Definitions . add All ( job Definitions List ) ; } }
List < Multi Column Printer . Column > register Additional Columns ( ) { return Collections . empty List ( ) ; }
public static String construct DB Name ( String queue Name , String shard Name ) { return String . format ( STR_ , PINLATER QUEUE DB PREFIX , shard Name , queue Name ) ; }
public synchronized void remove Resource Bundle ( String bundle Name ) { if ( resource Bundles != null ) { resource Bundles . remove ( bundle Name ) ; } resource Cache . clear ( ) ; }
@ Override public void compute ( ) { Spliterator < P IN > rs = spliterator , ls ; long size Estimate = rs . estimate Size ( ) ; long size Threshold = get Target Size ( size Estimate ) ; boolean fork Right = false ; @ Suppress Warnings ( STR_ ) K task = ( K ) this ; Atomic Reference < R > sr = shared Result ; R result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . task Canceled ( ) ) { result = task . get Empty Result ( ) ; break ; } if ( size Estimate <= size Threshold || ( ls = rs . try Split ( ) ) == null ) { result = task . do Leaf ( ) ; break ; } K left Child , right Child , task To Fork ; task . left Child = left Child = task . make Child ( ls ) ; task . right Child = right Child = task . make Child ( rs ) ; task . set Pending Count ( NUM_ ) ; if ( fork Right ) { fork Right = false ; rs = ls ; task = left Child ; task To Fork = right Child ; } else { fork Right = true ; task = right Child ; task To Fork = left Child ; } task To Fork . fork ( ) ; size Estimate = rs . estimate Size ( ) ; } task . set Local Result ( result ) ; task . try Complete ( ) ; }
public void init All Day Heights ( ) { if ( m Max Allday Events <= m Max Unexpanded Allday Event Count ) { return ; } if ( m Show All All Day Events ) { int max AD Height = m View Height - DAY HEADER HEIGHT - MIN HOURS HEIGHT ; max AD Height = Math . min ( max AD Height , ( int ) ( m Max Allday Events * MIN UNEXPANDED ALLDAY EVENT HEIGHT ) ) ; m Animate Day Event Height = max AD Height / m Max Allday Events ; } else { m Animate Day Event Height = ( int ) MIN UNEXPANDED ALLDAY EVENT HEIGHT ; } }
public static void register Local Time M Bean ( String container Name ) { M Bean Server m Bean Server = get M Bean Server ( container Name ) ; if ( m Bean Server == null ) return ; Local Time M Bean local Time M Bean = new Local Time ( ) ; Object Name obj Name = Local Time Constants . MBEAN NAME ; if ( ! m Bean Server . is Registered ( obj Name ) ) { try { m Bean Server . register M Bean ( local Time M Bean , obj Name ) ; } catch ( Instance Already Exists Exception e ) { } catch ( Not Compliant M Bean Exception e ) { if ( logger . is Loggable ( Level . WARNING ) ) { logger . log ( Level . SEVERE , failed Local Time M Bean Registration Message Prefix + container Name + STR_ , e ) ; } } catch ( M Bean Registration Exception e ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , failed Local Time M Bean Registration Message Prefix + container Name + STR_ , e ) ; } } if ( logger . is Loggable ( Level . CONFIG ) ) { logger . config ( successful Transport M Bean Registration Message + container Name + STR_ ) ; } } }
public void exclude ( final Path Matcher matcher ) { exclude Matchers . add ( matcher ) ; }
private void register Wake Locks ( ) { if ( m Wifi Lock != null ) { int mode = Wifi Manager . WIFI MODE SCAN ONLY ; if ( Integer . parse Int ( prefs . get String ( Preferences . KEY WIFI SCAN MODE , Preferences . VAL WIFI SCAN MODE ) ) == NUM_ ) { Log . i ( TAG , STR_ ) ; mode = Wifi Manager . WIFI MODE FULL ; } else if ( Integer . parse Int ( prefs . get String ( Preferences . KEY WIFI SCAN MODE , Preferences . VAL WIFI SCAN MODE ) ) == NUM_ ) { Log . i ( TAG , STR_ ) ; mode = Wifi Manager . WIFI MODE FULL HIGH PERF ; } m Wifi Lock = m Wifi Manager . create Wifi Lock ( mode , WIFILOCK NAME ) ; m Wifi Lock . acquire ( ) ; } }
private void add Composed Chars ( ) throws Parse Exception { Composed Char Iter iter = new Composed Char Iter ( ) ; int c ; while ( ( c = iter . next ( ) ) != Composed Char Iter . DONE ) { if ( get Char Order ( c ) == RB Collation Tables . UNMAPPED ) { String s = iter . decomposition ( ) ; if ( s . length ( ) == NUM_ ) { int order = get Char Order ( s . char At ( NUM_ ) ) ; if ( order != RB Collation Tables . UNMAPPED ) { add Order ( c , order ) ; } continue ; } else if ( s . length ( ) == NUM_ ) { char ch 0 = s . char At ( NUM_ ) ; if ( Character . is High Surrogate ( ch 0 ) ) { int order = get Char Order ( s . code Point At ( NUM_ ) ) ; if ( order != RB Collation Tables . UNMAPPED ) { add Order ( c , order ) ; } continue ; } } int contract Order = get Contract Order ( s ) ; if ( contract Order != RB Collation Tables . UNMAPPED ) { add Order ( c , contract Order ) ; } else { boolean all There = true ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { if ( get Char Order ( s . char At ( i ) ) == RB Collation Tables . UNMAPPED ) { all There = false ; break ; } } if ( all There ) { add Expand Order ( c , s , RB Collation Tables . UNMAPPED ) ; } } } } }
public void clear Js Lib Files ( ) { js Lib Files . clear ( ) ; }
public Builder with Heartbeat Interval ( Duration heartbeat Interval ) { Assert . arg Not ( heartbeat Interval . is Negative ( ) || heartbeat Interval . is Zero ( ) , STR_ ) ; Assert . arg Not ( heartbeat Interval . to Millis ( ) >= election Timeout . to Millis ( ) , STR_ ) ; this . heartbeat Interval = Assert . not Null ( heartbeat Interval , STR_ ) ; return this ; }
public final void remove Hit Box ( String name ) { hit Boxes . remove If ( null ) ; }
@ Model Attribute public void add Data To Model ( Model Map model ) { Search Data advanced Search Data = new Search Data ( ) ; advanced Search Data . set Current Page ( NUM_ ) ; advanced Search Data . set Number Results Per Page ( DEFAULT NUMBER OF RESULTS PER PAGE ) ; advanced Search Data . set Search Mode ( STR_ ) ; advanced Search Data . set Current Page ( NUM_ ) ; advanced Search Data . set Query Text ( null ) ; model . put ( STR_ , advanced Search Data ) ; model . put ( STR_ , start Page Service . get Random Podcasts ( NUMBER OF PODCASTS IN CHART ) ) ; model . add Attribute ( STR_ , Media Type . values ( ) ) ; model . add Attribute ( STR_ , Language Code . values ( ) ) ; model . add Attribute ( STR_ , Order By Option . values ( ) ) ; List < Category > categories By No Of Podcasts = category Service . get Categories Ordered By No Of Podcasts ( ) ; model . put ( STR_ , categories By No Of Podcasts . sub List ( NUM_ , NUMBER OF CATEGORIES IN CHART ) ) ; model . put ( STR_ , categories By No Of Podcasts ) ; List < Podcast > recommended Podcasts = start Page Service . get Recommended Podcasts ( ) ; model . put ( STR_ , recommended Podcasts ) ; Locale locale = Locale Context Holder . get Locale ( ) ; String language = locale . get Language ( ) ; List < String > preferred Languages List = Arrays . as List ( preferred Languages ) ; model . put ( STR_ , start Page Service . get New Entries ( ) ) ; if ( preferred Languages List . contains ( language ) ) { model . put ( STR_ , start Page Service . get Last Updated Podcasts ( Language Code . get ( language ) ) ) ; } else { model . put ( STR_ , start Page Service . get Last Updated Podcasts ( ) ) ; } }
void insert Op ( int pos , int length , int op ) { int total Len = m ops . get Op ( Op Map . MAPINDEX LENGTH ) ; for ( int i = total Len - NUM_ ; i >= pos ; i -- ) { m ops . set Op ( i + length , m ops . get Op ( i ) ) ; } m ops . set Op ( pos , op ) ; m ops . set Op ( Op Map . MAPINDEX LENGTH , total Len + length ) ; }
public void load Previous Settings To Server Info ( ) { String REMOTE SERVER USERNAME = STR_ ; String REMOTE SERVER PASSWORD = STR_ ; String REMOTE SERVER URL = STR_ ; String REMOTE SERVER PORT = STR_ ; String REMOTE SERVER DIRECTORY = STR_ ; String REMOTE SERVER SECURE = STR_ ; String REMOTE SERVER AUTHENTICATION METHOD = STR_ ; String IS LOCAL SERVER ADDRESS DIFFERENT = STR_ ; String USE ONLY LOCAL = STR_ ; String LOCAL SERVER USERNAME = STR_ ; String LOCAL SERVER PASSWORD = STR_ ; String LOCAL SERVER URL = STR_ ; String LOCAL SERVER PORT = STR_ ; String LOCAL SERVER DIRECTORY = STR_ ; String LOCAL SERVER SECURE = STR_ ; String LOCAL SERVER AUTHENTICATION METHOD = STR_ ; String LOCAL SERVER SSID = STR_ ; Server Info o Pref Server = new Server Info ( ) ; o Pref Server . set Remote Server Username ( prefs . get String ( REMOTE SERVER USERNAME , STR_ ) ) ; o Pref Server . set Remote Server Password ( prefs . get String ( REMOTE SERVER PASSWORD , STR_ ) ) ; o Pref Server . set Remote Server Url ( prefs . get String ( REMOTE SERVER URL , STR_ ) ) ; o Pref Server . set Remote Server Directory ( prefs . get String ( REMOTE SERVER DIRECTORY , STR_ ) ) ; o Pref Server . set Remote Server Port ( prefs . get String ( REMOTE SERVER PORT , STR_ ) ) ; o Pref Server . set Remote Server Secure ( prefs . get Boolean ( REMOTE SERVER SECURE , true ) ) ; o Pref Server . set Remote Server Authentication ( prefs . get Boolean ( REMOTE SERVER AUTHENTICATION METHOD , true ) ) ; if ( ! prefs . get Boolean ( IS LOCAL SERVER ADDRESS DIFFERENT , false ) ) o Pref Server . set Local Same Address As Remote ( ) ; o Pref Server . set Use Only Local ( prefs . get Boolean ( USE ONLY LOCAL , false ) ) ; o Pref Server . set Is Local Server Address Different ( prefs . get Boolean ( IS LOCAL SERVER ADDRESS DIFFERENT , false ) ) ; o Pref Server . set Local Server Username ( prefs . get String ( LOCAL SERVER USERNAME , STR_ ) ) ; o Pref Server . set Local Server Password ( prefs . get String ( LOCAL SERVER PASSWORD , STR_ ) ) ; o Pref Server . set Local Server Url ( prefs . get String ( LOCAL SERVER URL , STR_ ) ) ; o Pref Server . set Local Server Port ( prefs . get String ( LOCAL SERVER PORT , STR_ ) ) ; o Pref Server . set Local Server Directory ( prefs . get String ( LOCAL SERVER DIRECTORY , STR_ ) ) ; o Pref Server . set Local Server Secure ( prefs . get Boolean ( LOCAL SERVER SECURE , false ) ) ; o Pref Server . set Local Server Authentication ( prefs . get Boolean ( LOCAL SERVER AUTHENTICATION METHOD , false ) ) ; o Pref Server . set Local Server Ssid ( prefs . get String Set ( LOCAL SERVER SSID , null ) ) ; o Pref Server . set Enabled ( true ) ; set Active Server ( o Pref Server ) ; if ( m Server List == null || m Server List . size ( ) <= NUM_ ) m Server List = new Array List < > ( ) ; m Server List . add ( o Pref Server ) ; save Domoticz Servers ( false ) ; }
public Compactor major Index ( long index ) { this . major Index = Math . max ( this . major Index , index ) ; return this ; }
public void pop ( ) { Deque < Task Context > stack = context Stacks . get ( ) ; if ( stack == null ) { throw new Illegal State Exception ( STR_ + stack + STR_ + this ) ; } final Task Context last = stack . poll Last ( ) ; if ( last != this ) { if ( last != null ) { stack . add Last ( last ) ; } throw new Illegal State Exception ( STR_ + stack + STR_ + this + STR_ + last ) ; } }
private Object [ ] unmarshal Parameters Unchecked ( Method method , Object Input in ) throws IO Exception , Class Not Found Exception { Class < ? > [ ] types = method . get Parameter Types ( ) ; Object [ ] params = new Object [ types . length ] ; for ( int i = NUM_ ; i < types . length ; i ++ ) { params [ i ] = unmarshal Value ( types [ i ] , in ) ; } return params ; }
private void delete Metadata Columns ( final Transaction tx , final String node Id , final List < Column > columns ) { require Non Null ( tx ) ; require Non Null ( columns ) ; require Non Null ( node Id ) ; final Bytes row = Bytes . of ( node Id ) ; for ( final Column column : columns ) { tx . delete ( row , column ) ; } }
public void add Item ( Work List Item item ) { work List . add ( item ) ; }
protected void incremental Update Mean ( double [ ] mean , V vec , int newsize , double op ) { if ( newsize == NUM_ ) { return ; } double [ ] delta = minus Equals ( vec . to Array ( ) , mean ) ; plus Times Equals ( mean , delta , op / newsize ) ; }
private void apply On All In Range ( Example Set example Set , Attribute [ ] all Attributes , int min Number Of Features , int max Number Of Features ) throws Operator Exception { for ( int i = min Number Of Features ; i <= max Number Of Features ; i ++ ) { apply On All With Exact Number ( example Set , all Attributes , i ) ; } }
@ Override public boolean increment Token ( ) throws IO Exception { if ( saved State != null ) { restore State ( saved State ) ; saved State = null ; save Term Buffer ( ) ; return true ; } else if ( ! input . increment Token ( ) ) { return false ; } if ( last Was Common || ( is Common ( ) && buffer . length ( ) > NUM_ ) ) { saved State = capture State ( ) ; gram Token ( ) ; return true ; } save Term Buffer ( ) ; return true ; }
private String compute Authorization Header ( @ Not Null final String request Method , @ Not Null final String request Url , @ Not Null final Map < String , String > request Parameters , @ Not Null final String token , @ Not Null final String token Secret ) { final O Auth Hmac Signer signer = new O Auth Hmac Signer ( ) ; signer . client Shared Secret = client Secret ; signer . token Shared Secret = token Secret ; final O Auth Parameters oauth Parameters = new O Auth Parameters ( ) ; oauth Parameters . consumer Key = client Id ; oauth Parameters . signer = signer ; oauth Parameters . token = token ; oauth Parameters . version = STR_ ; oauth Parameters . compute Nonce ( ) ; oauth Parameters . compute Timestamp ( ) ; final Generic Url generic Request Url = new Generic Url ( request Url ) ; generic Request Url . put All ( request Parameters ) ; try { oauth Parameters . compute Signature ( request Method , generic Request Url ) ; } catch ( General Security Exception e ) { throw new Runtime Exception ( e ) ; } return oauth Parameters . get Authorization Header ( ) ; }
public void cancel Button Action Performed ( ) { edit Mode = false ; cur Node = null ; add Button . set Visible ( true ) ; edit Button . set Visible ( true ) ; delete Button . set Visible ( true ) ; done Button . set Visible ( true ) ; update Button . set Visible ( false ) ; cancel Button . set Visible ( false ) ; status Text 1 . set Text ( std Status 1 ) ; status Text 2 . set Text ( std Status 2 ) ; status Text 3 . set Text ( std Status 3 ) ; }
private void finish Item List ( String Builder result ) { result . append ( STR_ ) ; }
private void explode Product ( int product Id , boolean is Component ) { M Product product = M Product . get ( get Ctx ( ) , product Id ) ; List < MPP Product BOM > list = get BO Ms ( product , is Component ) ; if ( ! is Component && list . size ( ) == NUM_ ) { throw new Adempiere Exception ( STR_ ) ; } for ( MPP Product BOM bom : list ) { if ( ! is Component ) { create Lines ( bom , null ) ; } m Level No ++ ; for ( MPP Product BOM Line bom Line : bom . get Lines ( ) ) { if ( ! bom Line . is Active ( ) ) { continue ; } create Lines ( bom , bom Line ) ; explode Product ( bom Line . get M Product ID ( ) , true ) ; } m Level No -- ; } }
public void read Data ( Data Input din ) throws IO Exception { int byte Count = din . read Unsigned Byte ( ) ; int record Count = byte Count / NUM_ ; records = new Record Request [ record Count ] ; for ( int i = NUM_ ; i < record Count ; i ++ ) { if ( din . read Byte ( ) != NUM_ ) { throw new IO Exception ( ) ; } int file = din . read Unsigned Short ( ) ; int record = din . read Unsigned Short ( ) ; if ( record < NUM_ || record >= NUM_ ) { throw new IO Exception ( ) ; } int count = din . read Unsigned Short ( ) ; records [ i ] = new Record Request ( file , record , count ) ; } }
public static Sorted Map < Integer , Integer > generate Sorted Tag Map ( String [ ] partitions , Map < String , String > tags ) { final Sorted Map < Integer , Integer > tag Hash Map = new Tree Map < Integer , Integer > ( ) ; for ( Map . Entry < String , String > entry : tags . entry Set ( ) ) { final String tag Name = entry . get Key ( ) ; final String tag Value = entry . get Value ( ) ; if ( tag Value == null || is Partition Tag ( partitions , tag Name ) ) continue ; tag Hash Map . put ( tag Name . hash Code ( ) , tag Value . hash Code ( ) ) ; } return tag Hash Map ; }
public File Ext Filter ( String [ ] exts , String description ) { this . exts = new String [ exts . length ] ; System . arraycopy ( exts , NUM_ , this . exts , NUM_ , exts . length ) ; this . description = description ; }
@ Override public void add AS Model ( AS Model abstract Schema ) { f AS Models . add Element ( abstract Schema ) ; }
public static String read String ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Object . get String ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } String value = null ; if ( ! json Object . is Null ( key ) ) { value = json Object . get String ( key ) ; } return value ; }
private void verify V Plex Volume Results ( ) throws Exception { for ( URI volume URI : vplex Test Volume UR Is ) { Volume volume = db Client . query Object ( Volume . class , volume URI ) ; Assert . assert Not Null ( String . format ( STR_ , volume URI ) , volume ) ; String Set associated Volumes = volume . get Associated Volumes ( ) ; if ( ( associated Volumes != null ) && ( ! associated Volumes . is Empty ( ) ) ) { Assert . assert False ( STR_ , volume . check Internal Flags ( Flag . INTERNAL OBJECT ) ) ; } else { Assert . assert True ( STR_ , volume . check Internal Flags ( Flag . INTERNAL OBJECT ) ) ; } } }
private void assert Namespace Iam Role Authorization Not Exist ( Namespace Entity namespace Entity ) { if ( Collection Utils . is Not Empty ( namespace Iam Role Authorization Dao . get Namespace Iam Role Authorizations ( namespace Entity ) ) ) { throw new Already Exists Exception ( String . format ( STR_ , namespace Entity . get Code ( ) ) ) ; } }
protected String sanitize Download Url ( Download Info download Info ) { return download Info . get Url ( ) ; }
private void event Occurred ( I Event Data data , Event Type type ) { if ( supported Events == null || supported Events . contains ( type ) ) { event Listener . event Occurred ( data , type ) ; } }
public static boolean create Invoice ( M Acct Schema as , int AD Org ID , int M Product ID , int M Attribute Set Instance ID , int C Invoice Line ID , int M Cost Element ID , Big Decimal Amt , Big Decimal Qty , String Description , String trx Name ) { String sql = STR_ + STR_ + STR_ + C Invoice Line ID + STR_ + as . get C Acct Schema ID ( ) + STR_ + M Attribute Set Instance ID ; int no = DB . execute Update ( sql , trx Name ) ; if ( no != NUM_ ) s log . config ( STR_ + no ) ; M Cost Detail cd = get ( as . get Ctx ( ) , STR_ , C Invoice Line ID , M Attribute Set Instance ID , as . get C Acct Schema ID ( ) , trx Name ) ; if ( cd == null ) { cd = new M Cost Detail ( as , AD Org ID , M Product ID , M Attribute Set Instance ID , M Cost Element ID , Amt , Qty , Description , trx Name ) ; cd . set C Invoice Line ID ( C Invoice Line ID ) ; } else { cd . set Delta Amt ( Amt . subtract ( cd . get Amt ( ) ) ) ; cd . set Delta Qty ( Qty . subtract ( cd . get Qty ( ) ) ) ; if ( cd . is Delta ( ) ) { cd . set Processed ( false ) ; cd . set Amt ( Amt ) ; cd . set Qty ( Qty ) ; } else return true ; } boolean ok = cd . save ( ) ; if ( ok && ! cd . is Processed ( ) ) { M Client client = M Client . get ( as . get Ctx ( ) , as . get AD Client ID ( ) ) ; if ( client . is Cost Immediate ( ) ) cd . process ( ) ; } s log . config ( STR_ + ok + STR_ + cd ) ; return ok ; }
public static Password Validator build Expire Validator ( Map < String , String > properties ) { List < Rule > rule List = new Array List < Rule > ( ) ; rule List . add ( new Expire Rule ( Number Utils . to Int ( properties . get ( PASSWORD EXPIRE DAYS ) , NUM_ ) ) ) ; Password Validator validator = new Password Validator ( rule List ) ; return validator ; }
Action Map create Action Map ( ) { Action Map map = new Action Map UI Resource ( ) ; map . put ( STR_ , new Show System Menu Action ( true ) ) ; map . put ( STR_ , new Show System Menu Action ( false ) ) ; return map ; }
public void replace All ( List < T > new Data ) { clear All ( ) ; if ( new Data == null ) { new Data = new Array List < > ( ) ; } m Datas = new Data ; notify Item Range Inserted ( NUM_ , m Datas . size ( ) ) ; }
private static void remove Margin Top Of Content Child ( View m Content Child , int status Bar Height ) { if ( m Content Child == null ) { return ; } if ( TAG MARGIN ADDED . equals ( m Content Child . get Tag ( ) ) ) { Frame Layout . Layout Params lp = ( Frame Layout . Layout Params ) m Content Child . get Layout Params ( ) ; lp . top Margin -= status Bar Height ; m Content Child . set Layout Params ( lp ) ; m Content Child . set Tag ( null ) ; } }
public static < T > byte [ ] to Byte Array ( T value , Coder < T > coder ) { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; try { coder . encode ( value , baos , new Coder . Context ( true ) ) ; } catch ( IO Exception e ) { throw new Illegal State Exception ( STR_ + value , e ) ; } return baos . to Byte Array ( ) ; }
protected void prune ( Linked List < Integer > basis Set ) { double [ ] [ ] PHI t Array = new double [ basis Set . size ( ) ] [ ] ; for ( int j = NUM_ ; j < basis Set . size ( ) ; j ++ ) { PHI t Array [ j ] = phi [ basis Set . get ( j ) ] ; } PHI t = new Matrix ( PHI t Array ) ; A = new Matrix ( basis Set . size ( ) , basis Set . size ( ) ) ; for ( int j = NUM_ ; j < basis Set . size ( ) ; j ++ ) { A . set ( j , j , alpha [ basis Set . get ( j ) ] ) ; } }
@ Override public void destroy Module State ( ) { UUID = null ; user Name = null ; }
private synchronized boolean apply Cache Limit ( long extra , long owner ) { long limit = max Cache Size - extra ; if ( limit < NUM_ ) { limit = NUM_ ; } long cache Size = cache Size Bytes ( ) ; while ( cache Size > limit && ! list . is Empty ( ) ) { Cache Element ce = list . get Last ( ) ; if ( ce . owner == owner && owner != NUM_ ) { Log . d ( STR_ , STR_ ) ; return false ; } Bitmap b = remove ( ce . key ) ; if ( b != null && ! b . is Recycled ( ) && ce . recycleable ) { cache Size -= b . get Row Bytes ( ) * b . get Height ( ) ; b . recycle ( ) ; } } return true ; }
void schedule Transmission ( boolean last Attempt Failed ) { this . failed Today = last Attempt Failed ; this . next Transmission = new Date ( last Reset . get Time ( ) + get Transmission Interval ( ) ) ; }
private static Set < String > retrieve Values ( final String key , final Map < String , Set < String > > key Value Map ) { return key Value Map . contains Key ( key ) ? key Value Map . get ( key ) : Collections . < String > empty Set ( ) ; }
private static int transform Class Access For Instant Run ( int access ) { Access Right access Right = Access Right . from Node Access ( access ) ; return access Right == Access Right . PACKAGE PRIVATE ? access | Opcodes . ACC PUBLIC : access ; }
private static String big Integer To Ascii String ( final Big Integer big Integer ) { final byte [ ] byte Array = big Integer . to Byte Array ( ) ; String Buffer string Buffer = new String Buffer ( ) ; for ( int i = NUM_ ; i < byte Array . length ; i ++ ) { final char value = ( char ) ( byte Array [ i ] & NUM_ ) ; if ( i == NUM_ && value == NUM_ ) { continue ; } string Buffer . append ( value ) ; } return string Buffer . to String ( ) ; }
private static int sum Eq Ne ( double value , double [ ] bv , Binary Operator b Op ) throws DML Runtime Exception { int ix = Arrays . binary Search ( bv , value ) ; int cnt = NUM_ ; if ( ix >= NUM_ ) { while ( ix > NUM_ && value == bv [ ix - NUM_ ] ) -- ix ; while ( ix < bv . length && value == bv [ ix ] ) { ix ++ ; cnt ++ ; } } if ( b Op . fn instanceof Not Equals ) cnt = bv . length - cnt ; return cnt ; }
protected Drawing create Drawing ( ) { Drawing drawing = new ODG Drawing ( ) ; Linked List < Input Format > input Formats = new Linked List < Input Format > ( ) ; input Formats . add ( new ODG Input Format ( ) ) ; input Formats . add ( new Image Input Format ( new SVG Image Figure ( ) ) ) ; input Formats . add ( new Text Input Format ( new SVG Text Figure ( ) ) ) ; drawing . set Input Formats ( input Formats ) ; Linked List < Output Format > output Formats = new Linked List < Output Format > ( ) ; output Formats . add ( new SVG Output Format ( ) ) ; output Formats . add ( new SVGZ Output Format ( ) ) ; output Formats . add ( new Image Output Format ( ) ) ; output Formats . add ( new Image Output Format ( STR_ , STR_ , STR_ , Buffered Image . TYPE INT RGB ) ) ; output Formats . add ( new Image Output Format ( STR_ , STR_ , STR_ , Buffered Image . TYPE BYTE INDEXED ) ) ; output Formats . add ( new Image Map Output Format ( ) ) ; drawing . set Output Formats ( output Formats ) ; return drawing ; }
private static void attempt Retry On Exception ( String log Prefix , Request < ? > request , Volley Error exception ) throws Volley Error { Retry Policy retry Policy = request . get Retry Policy ( ) ; int old Timeout = request . get Timeout Ms ( ) ; try { retry Policy . retry ( exception ) ; } catch ( Volley Error e ) { request . add Marker ( String . format ( STR_ , log Prefix , old Timeout ) ) ; throw e ; } request . add Marker ( String . format ( STR_ , log Prefix , old Timeout ) ) ; Request Queue request Queue = get Request Queue ( request ) ; if ( request Queue != null ) { request Queue . add ( request ) ; } throw new Retry Error ( ) ; }
private void disable Selection Buttons ( ) { btn Add . set Enabled ( false ) ; btn Left Paren . set Enabled ( false ) ; }
private void apply ( Repl DBMS Event event , boolean do Commit , boolean do Rollback , boolean sync THL ) throws Replicator Exception , Consistency Exception , Interrupted Exception { try { task Progress . begin Apply Interval ( ) ; applier . apply ( event , do Commit , do Rollback , sync THL ) ; if ( do Commit ) { schedule . commit ( ) ; block Event Count = NUM_ ; last Commit Millis = System . current Time Millis ( ) ; } } catch ( Applier Exception e ) { if ( context . get Applier Failure Policy ( ) == Failure Policy . STOP ) { throw e ; } else { String message = STR_ + event . get Seqno ( ) + STR_ + event . get Fragno ( ) + STR_ + e . get Message ( ) ; log Error ( message , e ) ; } } finally { task Progress . end Apply Interval ( ) ; } }
private void init View ( ) { m Month Title Paint = new Paint ( ) ; m Month Title Paint . set Anti Alias ( true ) ; m Month Title Paint . set Color ( m Month Name Text Color ) ; m Month Title Paint . set Text Size ( m Month Label Text Size ) ; m Month Title Paint . set Typeface ( Typeface . create ( m Month Title Typeface , Typeface . BOLD ) ) ; m Month Title Paint . set Text Align ( Paint . Align . CENTER ) ; m Month Title Paint . set Style ( Paint . Style . FILL ) ; m Month Title Paint . set Fake Bold Text ( true ) ; m Month Day Label Paint = new Paint ( ) ; m Month Day Label Paint . set Anti Alias ( true ) ; m Month Day Label Paint . set Color ( m Day Name Text Color ) ; m Month Day Label Paint . set Text Size ( m Month Day Label Text Size ) ; m Month Day Label Paint . set Typeface ( Typeface . create ( m Day Of Week Typeface , Typeface . NORMAL ) ) ; m Month Day Label Paint . set Text Align ( Paint . Align . CENTER ) ; m Month Day Label Paint . set Style ( Paint . Style . FILL ) ; m Month Day Label Paint . set Fake Bold Text ( true ) ; m Day Number Selected Paint = new Paint ( ) ; m Day Number Selected Paint . set Anti Alias ( true ) ; m Day Number Selected Paint . set Color ( m Selected Day Color ) ; m Day Number Selected Paint . set Alpha ( m Selected Day Circle Alpha ) ; m Day Number Selected Paint . set Text Align ( Paint . Align . CENTER ) ; m Day Number Selected Paint . set Style ( Paint . Style . FILL ) ; m Day Number Selected Paint . set Fake Bold Text ( true ) ; m Day Number Paint = new Paint ( ) ; m Day Number Paint . set Anti Alias ( true ) ; m Day Number Paint . set Text Size ( m Mini Day Number Text Size ) ; m Day Number Paint . set Text Align ( Paint . Align . CENTER ) ; m Day Number Paint . set Style ( Paint . Style . FILL ) ; m Day Number Paint . set Fake Bold Text ( false ) ; m Day Number Disabled Paint = new Paint ( ) ; m Day Number Disabled Paint . set Anti Alias ( true ) ; m Day Number Disabled Paint . set Color ( m Disabled Text Color ) ; m Day Number Disabled Paint . set Text Size ( m Mini Day Number Text Size ) ; m Day Number Disabled Paint . set Text Align ( Paint . Align . CENTER ) ; m Day Number Disabled Paint . set Style ( Paint . Style . FILL ) ; m Day Number Disabled Paint . set Fake Bold Text ( false ) ; }
protected static Object primitive Array Get ( Object self , int idx ) { return Array . get ( self , normalise Index ( idx , Array . get Length ( self ) ) ) ; }
public static List < URI > fetch Cg Ids ( Db Client db Client , List < URI > vol UR Is ) { List < URI > cg Ids = new Array List < > ( ) ; if ( vol UR Is != null ) { for ( URI volume Id : vol UR Is ) { Volume volume = db Client . query Object ( Volume . class , volume Id ) ; if ( volume != null && volume . get Consistency Group ( ) != null && ! cg Ids . contains ( volume . get Consistency Group ( ) ) ) { cg Ids . add ( volume . get Consistency Group ( ) ) ; } } } return cg Ids ; }
public Search Source Builder post Filter ( String post Filter String ) { return post Filter ( post Filter String . get Bytes ( Charsets . UTF 8 ) ) ; }
private boolean has WDSSO Failed ( Http Servlet Request request ) { return Boolean . value Of ( ( String ) request . get Attribute ( STR_ ) ) ; }
public Exec OSA Script Command ( String playlist , File [ ] files ) { this . playlist = playlist ; this . files = files ; }
private boolean poll Stats Broker Topic ( Destination topic ) { stats Message Listener . set Destination ( topic ) ; LOGGER . info ( STR_ + get Queue Name ( topic ) ) ; jms Template . execute ( STATS BROKER DESTINATION + get Topic Name ( topic ) , new Producer Callback Impl ( stats Queue ) ) ; try { Thread . sleep ( NUM_ * NUM_ ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } return stats Message Listener . get Stats ( ) != null ; }
public int editable Properties ( ) { return m Num Editable ; }
private void add Facility To Hash Map ( Activity Facility Impl facility ) { Id < Link > facility Link = get Closest Link ( facility ) ; assure Hash Map Initialized For Link ( facility Link ) ; Array List < Activity Facility Impl > list = link Facility Mapping . get ( facility Link ) ; list . add ( facility ) ; }
public synchronized Collection < Weave Spec > woven ( ) { Collection < Weave Spec > specs = Lists . new Array List ( ) ; for ( Weave w : woven . values ( ) ) { specs . add ( w . spec ) ; } return specs ; }
List Resources ( Monitoring monitoring Service , String project Resource , Print Stream os ) { this . monitoring Service = monitoring Service ; this . project Resource = project Resource ; this . output Stream = os ; }
public static Bitmap create Video Thumbnail ( String file Path , int kind , long time Us ) { Log . i ( TAG , STR_ ) ; Bitmap bitmap = null ; Media Metadata Retriever retriever = new Media Metadata Retriever ( ) ; try { Log . i ( TAG , STR_ ) ; retriever . set Data Source ( file Path ) ; bitmap = retriever . get Frame At Time ( time Us ) ; } catch ( Illegal Argument Exception ex ) { } catch ( Runtime Exception ex ) { } finally { Log . i ( TAG , STR_ ) ; try { Log . i ( TAG , STR_ ) ; retriever . release ( ) ; } catch ( Runtime Exception ex ) { } } if ( bitmap == null ) { Log . i ( TAG , STR_ ) ; return null ; } if ( kind == Images . Thumbnails . MINI KIND ) { int width = bitmap . get Width ( ) ; int height = bitmap . get Height ( ) ; int max = Math . max ( width , height ) ; if ( max > NUM_ ) { float scale = NUM_ / max ; int w = Math . round ( scale * width ) ; int h = Math . round ( scale * height ) ; bitmap = Bitmap . create Scaled Bitmap ( bitmap , width , height , true ) ; } } else if ( kind == Images . Thumbnails . MICRO KIND ) { Log . i ( TAG , STR_ ) ; bitmap = extract Thumbnail ( bitmap , TARGET SIZE MICRO THUMBNAIL , TARGET SIZE MICRO THUMBNAIL , NUM_ ) ; } return bitmap ; }
public boolean equals ( Object obj ) { if ( obj instanceof Activation Desc ) { Activation Desc desc = ( Activation Desc ) obj ; return ( ( group ID == null ? desc . group ID == null : group ID . equals ( desc . group ID ) ) && ( class Name == null ? desc . class Name == null : class Name . equals ( desc . class Name ) ) && ( location == null ? desc . location == null : location . equals ( desc . location ) ) && ( data == null ? desc . data == null : data . equals ( desc . data ) ) && ( restart == desc . restart ) ) ; } else { return false ; } }
public void unsilence ( ) { if ( my Vcs == null ) { return ; } my Vcs . show Command Line ( printable Command Line ( ) ) ; if ( my Stderr . length ( ) != NUM_ ) { my Vcs . show Error Messages ( my Stderr . to String ( ) ) ; } if ( my Stdout . length ( ) != NUM_ ) { my Vcs . show Messages ( my Stdout . to String ( ) ) ; } }
public String enable Module ( String id , String module ) { Tenant tenant = tenants . get ( id ) ; if ( tenant == null ) { return STR_ + id + STR_ ; } Module Descriptor mod = module Manager . get ( module ) ; if ( mod == null ) { return STR_ + module + STR_ ; } String deperr = check Dependencies ( tenant , mod ) ; if ( ! deperr . is Empty ( ) ) { return deperr ; } tenant . enable Module ( module ) ; return STR_ ; }
public void clear Mods Already Requested ( String channel ) { if ( channel == null ) { mods Already Requested . clear ( ) ; } else { mods Already Requested . remove ( channel ) ; } }
protected Criterion Filter Operation build Criterion Filter Operation ( Criteria criteria ) { return new Criterion Filter Operation ( criteria ) ; }
public XML Parser ( final Class class To Be Bound , final String schema ) throws XML Exception { try { JAXB Context jc = JAXB Context . new Instance ( class To Be Bound ) ; marshaller = jc . create Marshaller ( ) ; marshaller . set Schema ( XML Schema Utils . create Schema ( schema ) ) ; unmarshaller = jc . create Unmarshaller ( ) ; unmarshaller . set Schema ( XML Schema Utils . create Schema ( schema ) ) ; } catch ( JAXB Exception e ) { throw new XML Exception ( STR_ + class To Be Bound , e ) ; } }
protected Graphics create Graphics ( Image Formatter formatter , int width , int height ) { java . awt . Graphics graphics = null ; if ( formatter == null ) { logger . warning ( STR_ ) ; return null ; } graphics = formatter . get Graphics ( width , height , get Transparent ( ) ) ; if ( graphics == null ) { logger . warning ( STR_ ) ; return null ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ ) ; } if ( do Anti Aliasing && graphics instanceof java . awt . Graphics 2 D ) { java . awt . Graphics 2 D g 2 d = ( java . awt . Graphics 2 D ) graphics ; g 2 d . set Rendering Hint ( Rendering Hints . KEY TEXT ANTIALIASING , Rendering Hints . VALUE TEXT ANTIALIAS ON ) ; g 2 d . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; } return graphics ; }
private void write Attributes ( Output Node node ) throws Exception { Node Map < Output Node > map = node . get Attributes ( ) ; for ( String name : map ) { Output Node entry = map . get ( name ) ; String value = entry . get Value ( ) ; String prefix = entry . get Prefix ( verbose ) ; writer . write Attribute ( name , value , prefix ) ; } active . remove ( node ) ; }
private long insert Searches In Transaction ( SQ Lite Database db , Content Values values ) { String search = values . get As String ( Searches . SEARCH ) ; if ( Text Utils . is Empty ( search ) ) { throw new Illegal Argument Exception ( STR_ ) ; } Cursor cursor = null ; try { cursor = db . query ( TABLE SEARCHES , new String [ ] { Searches . ID } , Searches . SEARCH + STR_ , new String [ ] { search } , null , null , null ) ; if ( cursor . move To Next ( ) ) { long id = cursor . get Long ( NUM_ ) ; db . update ( TABLE SEARCHES , values , Searches . ID + STR_ , new String [ ] { Long . to String ( id ) } ) ; return id ; } else { return db . insert Or Throw ( TABLE SEARCHES , Searches . SEARCH , values ) ; } } finally { if ( cursor != null ) cursor . close ( ) ; } }
protected void install Components ( ) { if ( scrollable Tab Layout Enabled ( ) ) { if ( tab Scroller == null ) { tab Scroller = new Scrollable Tab Support ( tab Pane . get Tab Placement ( ) ) ; tab Pane . add ( tab Scroller . viewport ) ; } } }
public boolean remove Undefined Attributes ( ) { Linked List < String > undefined = new Linked List < > ( ) ; for ( String attribute : get Attribute Set ( ) ) { Map < String , Object > sample 2 values = get Samples 2 Values ( attribute ) ; boolean ok = false ; for ( String sample : sample 2 values . key Set ( ) ) { if ( sample 2 values . get ( sample ) != null ) { ok = true ; break ; } } if ( ! ok ) undefined . add ( attribute ) ; } if ( undefined . size ( ) > NUM_ ) remove Attributes ( undefined ) ; return undefined . size ( ) > NUM_ ; }
private void prepare Virtual Pool Data ( ) throws Exception { log . info ( STR_ ) ; Virtual Array virtual Array = new Virtual Array ( ) ; URI virtual Array URI = URI Util . create Id ( Virtual Array . class ) ; virtual Array . set Id ( virtual Array URI ) ; virtual Array . set Label ( STR_ ) ; db Client . create Object ( virtual Array ) ; for ( int i = NUM_ ; i <= NUM_ ; i ++ ) { Vpool Protection Varray Settings protection Settings = new Vpool Protection Varray Settings ( ) ; URI protection Settings URI = URI Util . create Id ( Vpool Protection Varray Settings . class ) ; protection Settings . set Id ( protection Settings URI ) ; protection Settings . set Journal Size ( STR_ ) ; db Client . create Object ( protection Settings ) ; Virtual Pool virtual Pool = new Virtual Pool ( ) ; URI virtual Pool URI = URI Util . create Id ( Virtual Pool . class ) ; rp Test Virtual Pool UR Is . add ( virtual Pool URI ) ; virtual Pool . set Id ( virtual Pool URI ) ; virtual Pool . set Label ( STR_ + i ) ; String Map protection Varray Settings = new String Map ( ) ; protection Varray Settings . put ( virtual Array URI . to String ( ) , protection Settings URI . to String ( ) ) ; virtual Pool . set Protection Varray Settings ( protection Varray Settings ) ; db Client . create Object ( virtual Pool ) ; } }
private int read One Line ( Input Stream is ) { int read = NUM_ ; clear Buffer ( ) ; try { log ( STR_ + read Started + STR_ + is . available ( ) ) ; String Builder log = new String Builder ( ) ; while ( ( ! read Started ) || ( is . available ( ) > NUM_ ) ) { int data = is . read ( ) ; if ( data == - NUM_ ) { log ( STR_ ) ; return - NUM_ ; } buf [ read ] = ( byte ) data ; log . append ( ( char ) data ) ; read Started = true ; if ( buf [ read ++ ] == ( byte ) STR_ ) { log ( log . to String ( ) ) ; return read ; } } } catch ( IO Exception e ) { log ( STR_ ) ; } return read ; }
public static void each File ( final Path self , final File Type file Type , @ Closure Params ( value = Simple Type . class , options = STR_ ) final Closure closure ) throws IO Exception { check Dir ( self ) ; try ( Directory Stream < Path > stream = Files . new Directory Stream ( self ) ) { for ( Path path : stream ) { if ( file Type == File Type . ANY || ( file Type != File Type . FILES && Files . is Directory ( path ) ) || ( file Type != File Type . DIRECTORIES && Files . is Regular File ( path ) ) ) { closure . call ( path ) ; } } } }
public static void remove Dns Cache ( String host ) { try { Inet Address Cache Util . remove Inet Address Cache ( host ) ; } catch ( Exception e ) { final String message = String . format ( STR_ , host , e . to String ( ) ) ; throw new Dns Cache Manipulator Exception ( message , e ) ; } }
private static Element build Table Field UI Control Node ( Element node , Element body Node ) { Element control Node = body Node . create Element ( NAMESPACE XFORMS , null ) ; String name = node . get Name ( ) ; if ( name . equals Ignore Case ( NODE ENCOUNTER LOCATION ID ) || name . equals Ignore Case ( NODE ENCOUNTER PROVIDER ID ) ) { if ( use Auto Complete For Node ( name ) ) control Node . set Name ( CONTROL INPUT ) ; else control Node . set Name ( CONTROL SELECT 1 ) ; } else { control Node . set Name ( CONTROL INPUT ) ; } control Node . set Attribute ( null , ATTRIBUTE BIND , name ) ; Element label Node = body Node . create Element ( NAMESPACE XFORMS , null ) ; label Node . set Name ( NODE LABEL ) ; label Node . add Child ( Element . TEXT , get Display Text ( name ) + STR_ ) ; control Node . add Child ( Element . ELEMENT , label Node ) ; add Control ( body Node , control Node ) ; return control Node ; }
@ Override public void refresh ( int year , int month ) { selected Year = year ; selected Month = month ; selected Index = - NUM_ ; calendar . set ( Calendar . YEAR , selected Year ) ; calendar . set ( Calendar . MONTH , selected Month - NUM_ ) ; calendar . set ( Calendar . DAY OF MONTH , NUM_ ) ; initial ( ) ; invalidate ( ) ; if ( on Refresh Listener != null ) { on Refresh Listener . on Refresh ( ) ; } }
public static void update Collection Level Snapshot ( Solr Zk Client zk Client , String collection Name , Collection Snapshot Meta Data meta ) throws Keeper Exception , Interrupted Exception { String zk Path = get Snapshot Meta Data Zk Path ( collection Name , Optional . of ( meta . get Name ( ) ) ) ; zk Client . set Data ( zk Path , Utils . to JSON ( meta ) , - NUM_ , true ) ; }
public void create Vehicle Folder ( String output Directory ) { File output Folder = new File ( output Directory + STR_ ) ; if ( output Folder . exists ( ) ) { String s = STR_ + output Folder . get Path ( ) + STR_ ; throw new Runtime Exception ( s ) ; } else { boolean check Directory = output Folder . mkdirs ( ) ; if ( ! check Directory ) { log . warn ( STR_ + output Folder . to String ( ) + STR_ ) ; } } }
private void show Popup Menu ( final Mouse Event event ) { final J Criterium Tree Node selected Node = ( J Criterium Tree Node ) Tree Helpers . get Node At ( this , event . get X ( ) , event . get Y ( ) ) ; if ( selected Node != null ) { final J Popup Menu menu = selected Node . get Popup Menu ( ) ; if ( menu != null ) { menu . show ( this , event . get X ( ) , event . get Y ( ) ) ; } } }
@ Nullable public static String directory Md 5 ( @ Nullable File dir , @ Nullable Ignite Logger log ) { if ( dir != null ) { if ( ! dir . is Directory ( ) ) { U . warn ( log , STR_ + dir ) ; return null ; } try { Message Digest digest = Message Digest . get Instance ( STR_ ) ; return add Directory Digest ( dir , digest , log ) ? Hex . encode Hex String ( digest . digest ( ) ) : null ; } catch ( No Such Algorithm Exception e ) { throw new Ignite Exception ( STR_ , e ) ; } } return null ; }
private static View find Index Of Icon ( Array List < View > views , int i , int delta ) { final int count = views . size ( ) ; int new I = i + delta ; while ( NUM_ <= new I && new I < count ) { View new V = views . get ( new I ) ; if ( new V instanceof Bubble Text View || new V instanceof Folder Icon ) { return new V ; } new I += delta ; } return null ; }
public Month Date Format ( Locale locale , int chars ) { this ( Time Zone . get Default ( ) , locale , chars , true , false ) ; }
public void store Known Devices ( ) { String Buffer list Known Devices = new String Buffer ( ) ; boolean first = true ; for ( String id : known Devices ) { if ( id . length ( ) > NUM_ ) { if ( ! first ) list Known Devices = list Known Devices . append ( STR_ ) ; else first = false ; list Known Devices = list Known Devices . append ( id ) ; } } Shared Preferences . Editor editor = settings . edit ( ) ; editor . put String ( STR_ , list Known Devices . to String ( ) ) ; editor . commit ( ) ; }
public Remote export Object ( Remote impl , Object data , boolean permanent ) throws Remote Exception { Class < ? > impl Class = impl . get Class ( ) ; Remote stub ; try { stub = Util . create Proxy ( impl Class , get Client Ref ( ) , force Stub Use ) ; } catch ( Illegal Argument Exception e ) { throw new Export Exception ( STR_ , e ) ; } if ( stub instanceof Remote Stub ) { set Skeleton ( impl ) ; } Target target = new Target ( impl , this , stub , ref . get Obj ID ( ) , permanent ) ; ref . export Object ( target ) ; hash To Method Map = hash To Method Maps . get ( impl Class ) ; return stub ; }
private Date Builder ( Locale lc ) { Calendar cal = Calendar . get Instance ( lc ) ; this . lc = lc ; month = cal . get ( Calendar . MONTH ) + NUM_ ; day = cal . get ( Calendar . DAY OF MONTH ) ; year = cal . get ( Calendar . YEAR ) ; hour = cal . get ( Calendar . HOUR OF DAY ) ; minute = cal . get ( Calendar . MINUTE ) ; second = cal . get ( Calendar . SECOND ) ; }
private final int end Game Eval ( Position pos , int old Score ) { int score = old Score ; if ( pos . w Mtrl + pos . b Mtrl > NUM_ * r V ) return score ; final int w Mtrl Pawns = pos . w Mtrl Pawns ; final int b Mtrl Pawns = pos . b Mtrl Pawns ; final int w Mtrl No Pawns = pos . w Mtrl - w Mtrl Pawns ; final int b Mtrl No Pawns = pos . b Mtrl - b Mtrl Pawns ; boolean handled = false ; if ( ( w Mtrl Pawns + b Mtrl Pawns == NUM_ ) && ( w Mtrl No Pawns < r V ) && ( b Mtrl No Pawns < r V ) ) { return NUM_ ; } if ( ! handled && ( pos . w Mtrl == q V ) && ( pos . b Mtrl == p V ) && ( pos . piece Type BB [ Piece . WQUEEN ] != NUM_ ) ) { int wk = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . WKING ] ) ; int wq = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . WQUEEN ] ) ; int bk = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . BKING ] ) ; int bp = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . BPAWN ] ) ; score = eval KQKP ( wk , wq , bk , bp , pos . white Move ) ; handled = true ; } if ( ! handled && ( pos . w Mtrl == r V ) && ( pos . piece Type BB [ Piece . WROOK ] != NUM_ ) ) { if ( pos . b Mtrl == p V ) { int bp = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . BPAWN ] ) ; score = krkp Eval ( pos . get King Sq ( true ) , pos . get King Sq ( false ) , bp , pos . white Move ) ; handled = true ; } else if ( ( pos . b Mtrl == b V ) && ( pos . piece Type BB [ Piece . BBISHOP ] != NUM_ ) ) { score /= NUM_ ; final int k Sq = pos . get King Sq ( false ) ; final int x = Position . get X ( k Sq ) ; final int y = Position . get Y ( k Sq ) ; if ( ( pos . piece Type BB [ Piece . BBISHOP ] & Bit Board . mask Dark Sq ) != NUM_ ) { score += ( NUM_ - dist To H 1 A 8 [ NUM_ - y ] [ NUM_ - x ] ) * NUM_ ; } else { score += ( NUM_ - dist To H 1 A 8 [ NUM_ - y ] [ x ] ) * NUM_ ; } handled = true ; } } if ( ! handled && ( pos . b Mtrl == q V ) && ( pos . w Mtrl == p V ) && ( pos . piece Type BB [ Piece . BQUEEN ] != NUM_ ) ) { int bk = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . BKING ] ) ; int bq = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . BQUEEN ] ) ; int wk = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . WKING ] ) ; int wp = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . WPAWN ] ) ; score = - eval KQKP ( NUM_ - bk , NUM_ - bq , NUM_ - wk , NUM_ - wp , ! pos . white Move ) ; handled = true ; } if ( ! handled && ( pos . b Mtrl == r V ) && ( pos . piece Type BB [ Piece . BROOK ] != NUM_ ) ) { if ( pos . w Mtrl == p V ) { int wp = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . WPAWN ] ) ; score = - krkp Eval ( NUM_ - pos . get King Sq ( false ) , NUM_ - pos . get King Sq ( true ) , NUM_ - wp , ! pos . white Move ) ; handled = true ; } else if ( ( pos . w Mtrl == b V ) && ( pos . piece Type BB [ Piece . WBISHOP ] != NUM_ ) ) { score /= NUM_ ; final int k Sq = pos . get King Sq ( true ) ; final int x = Position . get X ( k Sq ) ; final int y = Position . get Y ( k Sq ) ; if ( ( pos . piece Type BB [ Piece . WBISHOP ] & Bit Board . mask Dark Sq ) != NUM_ ) { score -= ( NUM_ - dist To H 1 A 8 [ NUM_ - y ] [ NUM_ - x ] ) * NUM_ ; } else { score -= ( NUM_ - dist To H 1 A 8 [ NUM_ - y ] [ x ] ) * NUM_ ; } handled = true ; } } if ( ! handled && ( score > NUM_ ) ) { if ( ( w Mtrl Pawns == NUM_ ) && ( w Mtrl No Pawns <= b Mtrl No Pawns + b V ) ) { if ( w Mtrl No Pawns < r V ) { return - pos . b Mtrl / NUM_ ; } else { score /= NUM_ ; handled = true ; } } else if ( ( pos . piece Type BB [ Piece . WROOK ] | pos . piece Type BB [ Piece . WKNIGHT ] | pos . piece Type BB [ Piece . WQUEEN ] ) == NUM_ ) { if ( ( ( pos . piece Type BB [ Piece . WPAWN ] & Bit Board . mask B To H Files ) == NUM_ ) && ( ( pos . piece Type BB [ Piece . WBISHOP ] & Bit Board . mask Light Sq ) == NUM_ ) && ( ( pos . piece Type BB [ Piece . BKING ] & NUM_ ) != NUM_ ) ) { return NUM_ ; } else if ( ( ( pos . piece Type BB [ Piece . WPAWN ] & Bit Board . mask A To G Files ) == NUM_ ) && ( ( pos . piece Type BB [ Piece . WBISHOP ] & Bit Board . mask Dark Sq ) == NUM_ ) && ( ( pos . piece Type BB [ Piece . BKING ] & NUM_ ) != NUM_ ) ) { return NUM_ ; } } } if ( ! handled ) { if ( b Mtrl Pawns == NUM_ ) { if ( w Mtrl No Pawns - b Mtrl No Pawns > b V ) { int w Knights = Long . bit Count ( pos . piece Type BB [ Piece . WKNIGHT ] ) ; int w Bishops = Long . bit Count ( pos . piece Type BB [ Piece . WBISHOP ] ) ; if ( ( w Knights == NUM_ ) && ( pos . w Mtrl == NUM_ * n V ) && ( b Mtrl No Pawns == NUM_ ) ) { score /= NUM_ ; } else if ( ( w Knights == NUM_ ) && ( w Bishops == NUM_ ) && ( w Mtrl No Pawns == n V + b V ) && ( b Mtrl No Pawns == NUM_ ) ) { score /= NUM_ ; score += n V + b V + NUM_ ; final int k Sq = pos . get King Sq ( false ) ; final int x = Position . get X ( k Sq ) ; final int y = Position . get Y ( k Sq ) ; if ( ( pos . piece Type BB [ Piece . WBISHOP ] & Bit Board . mask Dark Sq ) != NUM_ ) { score += ( NUM_ - dist To H 1 A 8 [ NUM_ - y ] [ NUM_ - x ] ) * NUM_ ; } else { score += ( NUM_ - dist To H 1 A 8 [ NUM_ - y ] [ x ] ) * NUM_ ; } } else { score += NUM_ ; } handled = true ; } else if ( ( w Mtrl No Pawns + b Mtrl No Pawns == NUM_ ) && ( w Mtrl Pawns == p V ) ) { int wp = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . WPAWN ] ) ; score = kpk Eval ( pos . get King Sq ( true ) , pos . get King Sq ( false ) , wp , pos . white Move ) ; handled = true ; } } } if ( ! handled && ( score < NUM_ ) ) { if ( ( b Mtrl Pawns == NUM_ ) && ( b Mtrl No Pawns <= w Mtrl No Pawns + b V ) ) { if ( b Mtrl No Pawns < r V ) { return pos . w Mtrl / NUM_ ; } else { score /= NUM_ ; handled = true ; } } else if ( ( pos . piece Type BB [ Piece . BROOK ] | pos . piece Type BB [ Piece . BKNIGHT ] | pos . piece Type BB [ Piece . BQUEEN ] ) == NUM_ ) { if ( ( ( pos . piece Type BB [ Piece . BPAWN ] & Bit Board . mask B To H Files ) == NUM_ ) && ( ( pos . piece Type BB [ Piece . BBISHOP ] & Bit Board . mask Dark Sq ) == NUM_ ) && ( ( pos . piece Type BB [ Piece . WKING ] & NUM_ ) != NUM_ ) ) { return NUM_ ; } else if ( ( ( pos . piece Type BB [ Piece . BPAWN ] & Bit Board . mask A To G Files ) == NUM_ ) && ( ( pos . piece Type BB [ Piece . BBISHOP ] & Bit Board . mask Light Sq ) == NUM_ ) && ( ( pos . piece Type BB [ Piece . WKING ] & NUM_ ) != NUM_ ) ) { return NUM_ ; } } } if ( ! handled ) { if ( w Mtrl Pawns == NUM_ ) { if ( b Mtrl No Pawns - w Mtrl No Pawns > b V ) { int b Knights = Long . bit Count ( pos . piece Type BB [ Piece . BKNIGHT ] ) ; int b Bishops = Long . bit Count ( pos . piece Type BB [ Piece . BBISHOP ] ) ; if ( ( b Knights == NUM_ ) && ( pos . b Mtrl == NUM_ * n V ) && ( w Mtrl No Pawns == NUM_ ) ) { score /= NUM_ ; } else if ( ( b Knights == NUM_ ) && ( b Bishops == NUM_ ) && ( b Mtrl No Pawns == n V + b V ) && ( w Mtrl No Pawns == NUM_ ) ) { score /= NUM_ ; score -= n V + b V + NUM_ ; final int k Sq = pos . get King Sq ( true ) ; final int x = Position . get X ( k Sq ) ; final int y = Position . get Y ( k Sq ) ; if ( ( pos . piece Type BB [ Piece . BBISHOP ] & Bit Board . mask Dark Sq ) != NUM_ ) { score -= ( NUM_ - dist To H 1 A 8 [ NUM_ - y ] [ NUM_ - x ] ) * NUM_ ; } else { score -= ( NUM_ - dist To H 1 A 8 [ NUM_ - y ] [ x ] ) * NUM_ ; } } else { score -= NUM_ ; } handled = true ; } else if ( ( w Mtrl No Pawns + b Mtrl No Pawns == NUM_ ) && ( b Mtrl Pawns == p V ) ) { int bp = Bit Board . number Of Trailing Zeros ( pos . piece Type BB [ Piece . BPAWN ] ) ; score = - kpk Eval ( NUM_ - pos . get King Sq ( false ) , NUM_ - pos . get King Sq ( true ) , NUM_ - bp , ! pos . white Move ) ; handled = true ; } } } return score ; }
protected void build Profiles ( ) { m Current Profile View . set Visibility ( View . INVISIBLE ) ; m Account Header Text Section . set Visibility ( View . INVISIBLE ) ; m Account Switcher Arrow . set Visibility ( View . GONE ) ; m Profile First View . set Visibility ( View . GONE ) ; m Profile First View . set On Click Listener ( null ) ; m Profile Second View . set Visibility ( View . GONE ) ; m Profile Second View . set On Click Listener ( null ) ; m Profile Third View . set Visibility ( View . GONE ) ; m Profile Third View . set On Click Listener ( null ) ; m Current Profile Name . set Text ( STR_ ) ; m Current Profile Email . set Text ( STR_ ) ; if ( ! m Compact Style ) { m Account Header Text Section . set Padding ( NUM_ , NUM_ , ( int ) UI Utils . convert Dp To Pixel ( NUM_ , m Account Header Text Section . get Context ( ) ) , NUM_ ) ; } handle Selection View ( m Current Profile , true ) ; if ( m Current Profile != null ) { if ( ( m Profile Images Visible || m Only Main Profile Image Visible ) && ! m Only Small Profile Images Visible ) { set Image Or Placeholder ( m Current Profile View , m Current Profile . get Icon ( ) ) ; if ( m Profile Images Clickable ) { m Current Profile View . set On Click Listener ( on Current Profile Click Listener ) ; m Current Profile View . set On Long Click Listener ( on Current Profile Long Click Listener ) ; m Current Profile View . disable Touch Feedback ( false ) ; } else { m Current Profile View . disable Touch Feedback ( true ) ; } m Current Profile View . set Visibility ( View . VISIBLE ) ; m Current Profile View . invalidate ( ) ; } else if ( m Compact Style ) { m Current Profile View . set Visibility ( View . GONE ) ; } m Account Header Text Section . set Visibility ( View . VISIBLE ) ; handle Selection View ( m Current Profile , true ) ; m Account Switcher Arrow . set Visibility ( View . VISIBLE ) ; m Current Profile View . set Tag ( R . id . material drawer profile header , m Current Profile ) ; String Holder . apply To ( m Current Profile . get Name ( ) , m Current Profile Name ) ; String Holder . apply To ( m Current Profile . get Email ( ) , m Current Profile Email ) ; if ( m Profile First != null && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile First View , m Profile First . get Icon ( ) ) ; m Profile First View . set Tag ( R . id . material drawer profile header , m Profile First ) ; if ( m Profile Images Clickable ) { m Profile First View . set On Click Listener ( on Profile Click Listener ) ; m Profile First View . set On Long Click Listener ( on Profile Long Click Listener ) ; m Profile First View . disable Touch Feedback ( false ) ; } else { m Profile First View . disable Touch Feedback ( true ) ; } m Profile First View . set Visibility ( View . VISIBLE ) ; m Profile First View . invalidate ( ) ; } if ( m Profile Second != null && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile Second View , m Profile Second . get Icon ( ) ) ; m Profile Second View . set Tag ( R . id . material drawer profile header , m Profile Second ) ; if ( m Profile Images Clickable ) { m Profile Second View . set On Click Listener ( on Profile Click Listener ) ; m Profile Second View . set On Long Click Listener ( on Profile Long Click Listener ) ; m Profile Second View . disable Touch Feedback ( false ) ; } else { m Profile Second View . disable Touch Feedback ( true ) ; } m Profile Second View . set Visibility ( View . VISIBLE ) ; m Profile Second View . invalidate ( ) ; } if ( m Profile Third != null && m Three Small Profile Images && m Profile Images Visible && ! m Only Main Profile Image Visible ) { set Image Or Placeholder ( m Profile Third View , m Profile Third . get Icon ( ) ) ; m Profile Third View . set Tag ( R . id . material drawer profile header , m Profile Third ) ; if ( m Profile Images Clickable ) { m Profile Third View . set On Click Listener ( on Profile Click Listener ) ; m Profile Third View . set On Long Click Listener ( on Profile Long Click Listener ) ; m Profile Third View . disable Touch Feedback ( false ) ; } else { m Profile Third View . disable Touch Feedback ( true ) ; } m Profile Third View . set Visibility ( View . VISIBLE ) ; m Profile Third View . invalidate ( ) ; } } else if ( m Profiles != null && m Profiles . size ( ) > NUM_ ) { I Profile profile = m Profiles . get ( NUM_ ) ; m Account Header Text Section . set Tag ( R . id . material drawer profile header , profile ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; handle Selection View ( m Current Profile , true ) ; m Account Switcher Arrow . set Visibility ( View . VISIBLE ) ; if ( m Current Profile != null ) { String Holder . apply To ( m Current Profile . get Name ( ) , m Current Profile Name ) ; String Holder . apply To ( m Current Profile . get Email ( ) , m Current Profile Email ) ; } } if ( ! m Selection First Line Shown ) { m Current Profile Name . set Visibility ( View . GONE ) ; } if ( ! Text Utils . is Empty ( m Selection First Line ) ) { m Current Profile Name . set Text ( m Selection First Line ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; } if ( ! m Selection Second Line Shown ) { m Current Profile Email . set Visibility ( View . GONE ) ; } if ( ! Text Utils . is Empty ( m Selection Second Line ) ) { m Current Profile Email . set Text ( m Selection Second Line ) ; m Account Header Text Section . set Visibility ( View . VISIBLE ) ; } if ( ! m Selection List Enabled || ! m Selection List Enabled For Single Profile && m Profile First == null && ( m Profiles == null || m Profiles . size ( ) == NUM_ ) ) { m Account Switcher Arrow . set Visibility ( View . GONE ) ; handle Selection View ( null , false ) ; if ( ! m Compact Style ) { m Account Header Text Section . set Padding ( NUM_ , NUM_ , ( int ) UI Utils . convert Dp To Pixel ( NUM_ , m Account Header Text Section . get Context ( ) ) , NUM_ ) ; } } if ( m On Account Header Selection View Click Listener != null ) { handle Selection View ( m Current Profile , true ) ; } }
private synchronized void write Object ( java . io . Object Output Stream s ) throws IO Exception { s . default Write Object ( ) ; }
@ Override public void handle Transaction ( final Loan Transaction loan Transaction , final Monetary Currency currency , final List < Loan Repayment Schedule Installment > installments , final Set < Loan Charge > charges ) { final Money amount To Process = null ; final boolean is Charge Amount = false ; handle Transaction ( loan Transaction , currency , installments , charges , amount To Process , is Charge Amount ) ; }
@ Override public void process Event ( System Event event ) throws Abort Processing Exception { UI Component root = ( UI Component ) event . get Source ( ) ; Faces Context jsf = Faces Context . get Current Instance ( ) ; Enum Set < Visit Hint > hints = Enum Set . of ( Visit Hint . SKIP ITERATION ) ; Visit Context visit Context = Visit Context . create Visit Context ( jsf , null , hints ) ; root . visit Tree ( visit Context , new Validate Form Nesting Callback ( ) ) ; }
private String build Task 1 Gold Elem Reason ( String Builder text Builder , List < String > gold Tokens ) { String str Gold Reason ; text Builder . set Length ( NUM_ ) ; text Builder . append ( STR_ ) ; text Builder . append ( gold Tokens . size ( ) ) ; text Builder . append ( STR_ ) ; text Builder . append ( escape Html ( concat With Separator ( gold Tokens , STR_ ) ) ) ; text Builder . append ( gold NER 1 Reason Hints ) ; str Gold Reason = new String ( text Builder ) ; return str Gold Reason ; }
private void call Graph DFS ( int s ) { int t ; Cg Edge p ; vis cg [ s ] = low cg [ s ] = pre cnt ++ ; queue cg . add Last ( s ) ; p = call graph [ s ] ; while ( p != null ) { t = p . t ; if ( vis cg [ t ] == NUM_ ) call Graph DFS ( t ) ; if ( low cg [ t ] < low cg [ s ] ) low cg [ s ] = low cg [ t ] ; p = p . next ; } if ( low cg [ s ] < vis cg [ s ] ) { scc size [ s ] = NUM_ ; return ; } scc size [ s ] = queue cg . size ( ) ; do { t = queue cg . get Last ( ) ; queue cg . remove Last ( ) ; rep cg [ t ] = s ; low cg [ t ] += n func ; } while ( s != t ) ; scc size [ s ] -= queue cg . size ( ) ; if ( scc size [ s ] > max scc size ) { max scc size = scc size [ s ] ; max scc id = s ; } }
private void linearize ( Node n , String Buffer buf ) { String Buffer end Text = process Node ( n , buf ) ; for ( Node child = n . get First Child ( ) ; child != null ; child = child . get Next Sibling ( ) ) { linearize ( child , buf ) ; } if ( end Text != null ) { buf . append ( end Text ) ; } }
public static Generalized Sem Pm serializable Instance ( ) { Dag dag = new Dag ( ) ; Graph Node node 1 = new Graph Node ( STR_ ) ; dag . add Node ( node 1 ) ; return new Generalized Sem Pm ( Dag . serializable Instance ( ) ) ; }
private List < Object > create Object List ( Object object , List < Object > object List ) { if ( are Filters Passed ( object ) && ! get Expanded State ( object ) ) { if ( children Loaded ( object ) ) { expand To Level ( object , NUM_ ) ; } else { if ( object List == null ) { object List = new Array List < > ( ) ; } object List . add ( object ) ; } } Object parent = get Parent Element ( object ) ; if ( null != parent ) { create Object List ( parent , object List ) ; } return object List ; }
private List < Vcs Exception > parse Exception ( final String stderr ) { final List < Vcs Exception > exceptions = new Array List < Vcs Exception > ( ) ; final String [ ] exception Lines = get Lines ( stderr ) ; for ( int i = exception Lines . length / NUM_ ; i < exception Lines . length ; i ++ ) { if ( String Utils . is Not Empty ( exception Lines [ i ] ) && ! String Utils . contains ( exception Lines [ i ] , CONFLICT MESSAGE ) ) { final Vcs Exception exception = new Vcs Exception ( ( exception Lines [ i ] ) ) ; exception . set Is Warning ( String Utils . starts With ( exception Lines [ i ] , WARNING PREFIX ) ) ; exceptions . add ( exception ) ; } } return exceptions ; }
private void read From Version 2 Stream ( Status From Bytes Stream dis ) throws IO Exception { String url String = dis . read UTF ( ) ; if ( url String . equals ( STR_ ) ) { url = null ; } else { url = url String ; } last Changed Revision = dis . read Long ( ) ; last Changed Date = dis . read Long ( ) ; String last Commit Author String = dis . read UTF ( ) ; if ( ( url == null ) || ( last Commit Author String . equals ( STR_ ) ) ) { last Commit Author = null ; } else { last Commit Author = last Commit Author String ; } text Status = dis . read Int ( ) ; prop Status = dis . read Int ( ) ; set Revision Number ( dis . read Long ( ) ) ; node Kind = dis . read Int ( ) ; }
public void save State ( ) { for ( Field field : declaring Class . get Declared Fields ( ) ) { field . set Accessible ( true ) ; int mods = Modifier . field Modifiers ( ) & field . get Modifiers ( ) ; if ( Modifier . is Static ( mods ) && ! Modifier . is Final ( mods ) ) { Object value ; try { value = field . get ( null ) ; } catch ( Illegal Access Exception e ) { throw new Bug In Randoop Exception ( STR_ + field . get Name ( ) ) ; } value Map . put ( field , value ) ; } } }
private final String decode Short Unicode Name ( int len ) throws IO Exception { int out Ptr = NUM_ ; char [ ] out Buf = text Buffer . empty And Get Current Segment ( ) ; int in Ptr = input Ptr ; input Ptr += len ; final int [ ] codes = Smile Constants . s Utf 8 Unit Lengths ; final byte [ ] in Buf = input Buffer ; for ( int end = in Ptr + len ; in Ptr < end ; ) { int i = in Buf [ in Ptr ++ ] & NUM_ ; int code = codes [ i ] ; if ( code != NUM_ ) { switch ( code ) { case NUM_ : i = ( ( i & NUM_ ) << NUM_ ) | ( in Buf [ in Ptr ++ ] & NUM_ ) ; break ; case NUM_ : i = ( ( i & NUM_ ) << NUM_ ) | ( ( in Buf [ in Ptr ++ ] & NUM_ ) << NUM_ ) | ( in Buf [ in Ptr ++ ] & NUM_ ) ; break ; case NUM_ : i = ( ( i & NUM_ ) << NUM_ ) | ( ( in Buf [ in Ptr ++ ] & NUM_ ) << NUM_ ) | ( ( in Buf [ in Ptr ++ ] & NUM_ ) << NUM_ ) | ( in Buf [ in Ptr ++ ] & NUM_ ) ; i -= NUM_ ; out Buf [ out Ptr ++ ] = ( char ) ( NUM_ | ( i > > NUM_ ) ) ; i = NUM_ | ( i & NUM_ ) ; break ; default : report Error ( STR_ + Integer . to Hex String ( i ) + STR_ ) ; } } out Buf [ out Ptr ++ ] = ( char ) i ; } text Buffer . set Current Length ( out Ptr ) ; return text Buffer . contents As String ( ) ; }
private void find Stale Webapp Directories ( Context context , Set < File > directories To Delete ) { File webapp Base Directory = get Base Webapp Directory ( context ) ; Set < String > live Webapps = new Hash Set < String > ( ) ; Set < Intent > base Intents = get Base Intents For All Tasks ( ) ; for ( Intent intent : base Intents ) { Uri data = intent . get Data ( ) ; if ( data != null && Text Utils . equals ( Webapp Activity . WEBAPP SCHEME , data . get Scheme ( ) ) ) { live Webapps . add ( data . get Host ( ) ) ; } Component Name component = intent . get Component ( ) ; if ( component != null ) { String full Class Name = component . get Class Name ( ) ; int last Period Index = full Class Name . last Index Of ( STR_ ) ; if ( last Period Index != - NUM_ ) { String class Name = full Class Name . substring ( last Period Index + NUM_ ) ; if ( class Name . starts With ( WEBAPP DIRECTORY NAME ) && class Name . length ( ) > WEBAPP DIRECTORY NAME . length ( ) ) { String activity Index = class Name . substring ( WEBAPP DIRECTORY NAME . length ( ) ) ; live Webapps . add ( activity Index ) ; } } } } if ( webapp Base Directory != null ) { File app Directory = new File ( context . get Application Info ( ) . data Dir ) ; String webapp Directory App Base Name = webapp Base Directory . get Name ( ) ; File [ ] files = app Directory . list Files ( ) ; if ( files != null ) { for ( File file : files ) { String filename = file . get Name ( ) ; if ( ! filename . starts With ( webapp Directory App Base Name ) ) continue ; if ( filename . length ( ) == webapp Directory App Base Name . length ( ) ) continue ; directories To Delete . add ( file ) ; } } if ( webapp Base Directory . exists ( ) ) { files = webapp Base Directory . list Files ( ) ; if ( files != null ) { for ( File file : files ) { if ( ! live Webapps . contains ( file . get Name ( ) ) ) directories To Delete . add ( file ) ; } } } } }
public static void main ( String [ ] args ) { Log . print Line ( STR_ ) ; try { int num user = NUM_ ; Calendar calendar = Calendar . get Instance ( ) ; boolean trace flag = false ; Cloud Sim . init ( num user , calendar , trace flag ) ; Datacenter datacenter 0 = create Datacenter ( STR_ ) ; Datacenter Broker broker = create Broker ( ) ; int broker Id = broker . get Id ( ) ; vmlist = new Array List < Vm > ( ) ; int vmid = NUM_ ; int mips = NUM_ ; long size = NUM_ ; int ram = NUM_ ; long bw = NUM_ ; int pes Number = NUM_ ; String vmm = STR_ ; Vm vm 1 = new Vm ( vmid , broker Id , mips , pes Number , ram , bw , size , vmm , new Cloudlet Scheduler Time Shared ( ) ) ; vmlist . add ( vm 1 ) ; broker . submit Vm List ( vmlist ) ; cloudlet List = new Array List < Cloudlet > ( ) ; int id = NUM_ ; long length = NUM_ ; long file Size = NUM_ ; long output Size = NUM_ ; Utilization Model utilization Model = new Utilization Model Full ( ) ; Cloudlet cloudlet 1 = new Cloudlet ( id , length , pes Number , file Size , output Size , utilization Model , utilization Model , utilization Model ) ; cloudlet 1 . set User Id ( broker Id ) ; cloudlet List . add ( cloudlet 1 ) ; broker . submit Cloudlet List ( cloudlet List ) ; Network Topology . build Network Topology ( STR_ ) ; int brite Node = NUM_ ; Network Topology . map Node ( datacenter 0 . get Id ( ) , brite Node ) ; brite Node = NUM_ ; Network Topology . map Node ( broker . get Id ( ) , brite Node ) ; Cloud Sim . start Simulation ( ) ; List < Cloudlet > new List = broker . get Cloudlet Received List ( ) ; Cloud Sim . stop Simulation ( ) ; print Cloudlet List ( new List ) ; Log . print Line ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; Log . print Line ( STR_ ) ; } }
public static Object deserialize Object ( final byte [ ] obj Bytes ) throws IO Exception , Class Not Found Exception { Object Input Stream obj In = null ; try { obj In = new Object Input Stream ( new Byte Array Input Stream ( obj Bytes ) ) ; return obj In . read Object ( ) ; } finally { close ( obj In ) ; } }
@ Override public Hash Map < String , String > create Map ( ) { Hash Map < String , String > query Map = new Hash Map < > ( ) ; if ( query != null ) { query Map . put ( STR_ , query ) ; } if ( tags != null ) { query Map . put ( STR_ , tags ) ; } if ( filter != null ) { query Map . put ( STR_ , filter . to String ( ) ) ; } if ( license != null ) { query Map . put ( STR_ , license . to String ( ) ) ; } if ( bpm From != - NUM_ ) { query Map . put ( STR_ , String . value Of ( bpm From ) ) ; } if ( bpm To != - NUM_ ) { query Map . put ( STR_ , String . value Of ( bpm To ) ) ; } if ( duration From != - NUM_ ) { query Map . put ( STR_ , String . value Of ( duration From ) ) ; } if ( duration To != - NUM_ ) { query Map . put ( STR_ , String . value Of ( duration To ) ) ; } if ( created At From != null ) { query Map . put ( STR_ , created At From ) ; } if ( created At To != null ) { query Map . put ( STR_ , created At To ) ; } if ( ids != null ) { query Map . put ( STR_ , ids ) ; } if ( created At To != null ) { query Map . put ( STR_ , genres ) ; } if ( created At To != null ) { query Map . put ( STR_ , types ) ; } if ( query Map . size ( ) > NUM_ ) { query Map . put ( Pager . LIMIT , String . value Of ( limit ) ) ; return query Map ; } else { return null ; } }
public static String transform Method Signature ( String signature ) { String Builder buf = new String Builder ( ) ; buf . append ( STR_ ) ; Signature Parser parser = new Signature Parser ( signature ) ; for ( Iterator < String > i = parser . parameter Signature Iterator ( ) ; i . has Next ( ) ; ) { String param = i . next ( ) ; param = transform Signature ( param ) ; buf . append ( param ) ; } buf . append ( STR_ ) ; return buf . to String ( ) ; }
@ Override public void disconnection Notification ( String event Name , Object source ) { m listenees . remove ( source ) ; }
public void read All ( ) { try { set Address ( NUM_ ) ; } catch ( Exception e ) { log . debug ( rb . get String ( STR_ ) ) ; read All Button . set Selected ( false ) ; write All Button . set Selected ( false ) ; status . set Text ( STR_ ) ; return ; } if ( response Timer == null ) { initialize Response Timer ( ) ; } if ( pacing Timer == null ) { initialize Pacing Timer ( ) ; } read = true ; state = NUM_ ; next Request ( ) ; }
protected void create X axis ( int i ) { Log . e ( STR_ , graphheight + STR_ ) ; horizontal width = ( ( graphwidth / size ) * i ) + horstart ; horizontal width list . add ( horizontal width ) ; if ( i == NUM_ ) { canvas . draw Line ( horizontal width , graphheight + border , horizontal width , border , paint ) ; } else { canvas . draw Line ( horizontal width , graphheight + border , horizontal width , graphheight + ( NUM_ * border ) , paint ) ; } Draw Labels ( i ) ; }
private < K , V > V force Find ( Navigable Map < K , V > map , K key , V new Object ) { V data = map . get ( key ) ; if ( data == null ) { data = new Object ; map . put ( key , data ) ; } return data ; }
void remove EQ ( Object o ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] array = queue ; for ( int i = NUM_ , n = size ; i < n ; i ++ ) { if ( o == array [ i ] ) { remove At ( i ) ; break ; } } } finally { lock . unlock ( ) ; } }
int traverse Consistency Check ( Text Edit Processor processor , Document document , List < List < Text Edit > > source Edits ) { int result = NUM_ ; if ( f Children != null ) { for ( int i = f Children . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Text Edit child = ( Text Edit ) f Children . get ( i ) ; result = Math . max ( result , child . traverse Consistency Check ( processor , document , source Edits ) ) ; } } if ( processor . consider Edit ( this ) ) { perform Consistency Check ( processor , document ) ; } return result ; }
public File Input Stream open Read ( ) throws File Not Found Exception { if ( m Backup Name . exists ( ) ) { m Base Name . delete ( ) ; m Backup Name . rename To ( m Base Name ) ; } return new File Input Stream ( m Base Name ) ; }
public void refresh Storage ( List < Host System > hosts ) { if ( ! hosts . is Empty ( ) ) { execute ( new Refresh Storage ( hosts ) ) ; } }
@ Override protected List < String > create New Export Mask Workflow For Initiators ( List < URI > initiator UR Is , Export Group export Group , Workflow workflow , Map < URI , Integer > volume Map , Storage System storage , String token , String previous Step ) throws Exception { List < String > new Steps = new Array List < > ( ) ; if ( ! initiator UR Is . is Empty ( ) ) { List < Initiator > initiators = db Client . query Object ( Initiator . class , initiator UR Is ) ; if ( rest Helper . is Clustered Host ( storage , initiators , export Group . get Type ( ) ) ) { log . info ( String . format ( STR_ , export Group . get Label ( ) ) ) ; Gen Export Mask Create Workflow Result result = generate Device Specific Export Mask Create Work Flow ( workflow , previous Step , storage , export Group , initiator UR Is , volume Map , token ) ; previous Step = result . get Step Id ( ) ; } else { Map < String , List < URI > > compute Resource To Initiators = map Initiators To Compute Resource ( export Group , initiator UR Is ) ; for ( Map . Entry < String , List < URI > > resource Entry : compute Resource To Initiators . entry Set ( ) ) { String compute Key = resource Entry . get Key ( ) ; List < URI > compute Initiator UR Is = resource Entry . get Value ( ) ; log . info ( String . format ( STR_ , compute Key ) ) ; Gen Export Mask Create Workflow Result result = generate Device Specific Export Mask Create Work Flow ( workflow , previous Step , storage , export Group , compute Initiator UR Is , volume Map , token ) ; previous Step = result . get Step Id ( ) ; } } } new Steps . add ( previous Step ) ; return new Steps ; }
public static Matrix back Sub ( Matrix U , Matrix y ) { if ( y . rows ( ) != U . rows ( ) ) throw new Arithmetic Exception ( STR_ ) ; Matrix x = new Dense Matrix ( U . cols ( ) , y . cols ( ) ) ; double [ ] x col k = new double [ y . rows ( ) ] ; final int start = Math . min ( U . rows ( ) , U . cols ( ) ) - NUM_ ; for ( int k = NUM_ ; k < y . cols ( ) ; k ++ ) { for ( int i = start ; i >= NUM_ ; i -- ) { x col k [ i ] = y . get ( i , k ) ; for ( int j = i + NUM_ ; j <= start ; j ++ ) x col k [ i ] -= U . get ( i , j ) * x col k [ j ] ; x col k [ i ] /= U . get ( i , i ) ; } for ( int i = NUM_ ; i < x col k . length ; i ++ ) if ( Double . is Infinite ( x col k [ i ] ) ) x . set ( i , k , NUM_ ) ; else x . set ( i , k , x col k [ i ] ) ; } return x ; }
public synchronized OM Graphic List prepare ( ) { J Graphic List empty List = new J Graphic List ( ) ; if ( is Cancelled ( ) ) { dirtybits |= PREMATURE FINISH ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( get Name ( ) + STR_ ) ; } return empty List ; } if ( Debug . debugging ( STR_ ) ) { Debug . output ( get Name ( ) + STR_ ) ; } dirtybits = NUM_ ; set Accepting Events ( false ) ; Projection projection = get Projection ( ) ; U Graphic [ ] spec Graphics = get Spec Graphics ( projection ) ; if ( is Cancelled ( ) ) { dirtybits |= PREMATURE FINISH ; if ( Debug . debugging ( STR_ ) ) Debug . output ( get Name ( ) + STR_ + STR_ ) ; return empty List ; } if ( spec Graphics == null ) { return empty List ; } long start = System . current Time Millis ( ) ; J Graphic List graphics = create Graphics List ( spec Graphics , projection ) ; long stop = System . current Time Millis ( ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( get Name ( ) + STR_ + spec Graphics . length + STR_ + ( ( stop - start ) / NUM_ ) + STR_ ) ; } if ( is Cancelled ( ) ) { dirtybits |= PREMATURE FINISH ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( get Name ( ) + STR_ + STR_ ) ; } return empty List ; } if ( Debug . debugging ( STR_ ) ) { Debug . output ( get Name ( ) + STR_ + graphics . size ( ) + STR_ ) ; } set Accepting Events ( true ) ; return graphics ; }
public void update Object ( int column Index , Object x , SQL Type target Sql Type ) throws SQL Exception { throw new Not Updatable ( ) ; }
protected J Tree create Tree ( ) { J Tree tree = new J Tree ( model ) ; tree . set Name ( STR_ ) ; tree . set Font ( get Font ( ) ) ; tree . set Foreground ( get Foreground ( ) ) ; tree . set Background ( get Background ( ) ) ; tree . set Border ( null ) ; tree . set Focusable ( true ) ; tree . add Mouse Listener ( handler ) ; tree . add Key Listener ( handler ) ; tree . set Cell Renderer ( new Renderer ( ) ) ; return tree ; }
Unknown Action ( List < String > suggestions ) { Collections . sort ( suggestions ) ; this . suggestions = suggestions ; }
public void enable Input Methods ( boolean enable ) { if ( enable ) { if ( ( event Mask & AWT Event . INPUT METHODS ENABLED MASK ) != NUM_ ) return ; if ( is Focus Owner ( ) ) { Input Context input Context = get Input Context ( ) ; if ( input Context != null ) { Focus Event focus Gained Event = new Focus Event ( this , Focus Event . FOCUS GAINED ) ; input Context . dispatch Event ( focus Gained Event ) ; } } event Mask |= AWT Event . INPUT METHODS ENABLED MASK ; } else { if ( ( event Mask & AWT Event . INPUT METHODS ENABLED MASK ) != NUM_ ) { Input Context input Context = get Input Context ( ) ; if ( input Context != null ) { input Context . end Composition ( ) ; input Context . remove Notify ( this ) ; } } event Mask &= ~ AWT Event . INPUT METHODS ENABLED MASK ; } }
@ Override public Object create Statement ( Object proxy , Method method , Object [ ] args , Object statement , long time ) { try { String name = method . get Name ( ) ; Constructor < ? > constructor = null ; String sql = null ; if ( compare ( CREATE STATEMENT , name ) ) { constructor = get Constructor ( CREATE STATEMENT IDX , Statement . class ) ; } else if ( compare ( PREPARE STATEMENT , name ) ) { constructor = get Constructor ( PREPARE STATEMENT IDX , Prepared Statement . class ) ; sql = ( String ) args [ NUM_ ] ; } else if ( compare ( PREPARE CALL , name ) ) { constructor = get Constructor ( PREPARE CALL IDX , Callable Statement . class ) ; sql = ( String ) args [ NUM_ ] ; } else { return statement ; } return create Decorator ( proxy , method , args , statement , constructor , sql ) ; } catch ( Exception x ) { if ( x instanceof Invocation Target Exception ) { Throwable cause = x . get Cause ( ) ; if ( cause instanceof Thread Death ) { throw ( Thread Death ) cause ; } if ( cause instanceof Virtual Machine Error ) { throw ( Virtual Machine Error ) cause ; } } logger . warn ( STR_ , x ) ; } return statement ; }
public String global Info ( ) { return STR_ ; }
public void cleanup ( ) throws Interrupted Exception , Execution Exception , IO Exception { for ( String keyspace : get Non System Key Spaces ( ) ) { cleanup ( keyspace , Collections . empty List ( ) ) ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == null ) { return false ; } if ( get Class ( ) != obj . get Class ( ) ) { return false ; } final Name For Request other = ( Name For Request ) obj ; if ( ! Objects . equals ( this . name , other . name ) ) { return false ; } return true ; }
protected void draw Actor ( int x , int y , int w , int h , Color fill Color , Paint fill Paint , Color pen Color , boolean shadow ) { float width = w * NUM_ / NUM_ ; General Path path = new General Path ( ) ; path . move To ( x , y + h ) ; path . curve To ( x , y + NUM_ * h / NUM_ , x , y + NUM_ * h / NUM_ , x + w / NUM_ , y + NUM_ * h / NUM_ ) ; path . curve To ( x + w / NUM_ - width , y + NUM_ * h / NUM_ , x + w / NUM_ - width , y , x + w / NUM_ , y ) ; path . curve To ( x + w / NUM_ + width , y , x + w / NUM_ + width , y + NUM_ * h / NUM_ , x + w / NUM_ , y + NUM_ * h / NUM_ ) ; path . curve To ( x + w , y + NUM_ * h / NUM_ , x + w , y + NUM_ * h / NUM_ , x + w , y + h ) ; path . close Path ( ) ; draw Path ( path , fill Color , fill Paint , pen Color , shadow ) ; }
public void read ( Data Input dis ) throws IO Exception { int num Args = dis . read Int ( ) ; if ( num Args > NUM_ ) { read Args ( num Args , dis ) ; } }
public static < T > Expression < T > value Of ( String expression , Class < T > expected Type ) throws Expression Exception { return value Of ( expression , expected Type , bindings ( ) ) ; }
public void add Add Delete Buttons ( ) { J Button delete Button = new J Button ( STR_ ) ; delete Button . set Action ( Raster Plot Actions . get Remove Source Action ( this ) ) ; J Button add Button = new J Button ( STR_ ) ; add Button . set Action ( Raster Plot Actions . get Add Source Action ( this ) ) ; button Panel . add ( delete Button ) ; button Panel . add ( add Button ) ; }
public void write Data To File ( byte [ ] key Array , byte [ ] [ ] data Array , int entry Count , byte [ ] start Key , byte [ ] end Key ) throws Carbon Data Writer Exception { if ( this . is New File Creation Required ) { update Blocklet File Channel ( ) ; } int total Msr Array Size = NUM_ ; int current Msr Lenght = NUM_ ; int [ ] msr Length = new int [ this . measure Count ] ; for ( int i = NUM_ ; i < data Array . length ; i ++ ) { current Msr Lenght = data Array [ i ] . length ; total Msr Array Size += current Msr Lenght ; msr Length [ i ] = current Msr Lenght ; } byte [ ] writable Data Array = new byte [ total Msr Array Size ] ; int start Position = NUM_ ; for ( int i = NUM_ ; i < data Array . length ; i ++ ) { System . arraycopy ( data Array [ i ] , NUM_ , writable Data Array , start Position , data Array [ i ] . length ) ; start Position += msr Length [ i ] ; } write Data To File ( key Array , writable Data Array , msr Length , entry Count , start Key , end Key ) ; }
public void add Watcher ( Angular Object Watcher watcher ) { synchronized ( watchers ) { watchers . add ( watcher ) ; } }
public LDAP Url ( final boolean is Secured , final String host , final Integer port , final DN name , final Search Scope scope , final Filter filter , final String ... attributes ) { final String Builder url Buffer = new String Builder ( ) ; this . is Secured = is Secured ; if ( this . is Secured ) { url Buffer . append ( SSL URL SCHEME ) ; } else { url Buffer . append ( DEFAULT URL SCHEME ) ; } url Buffer . append ( STR_ ) ; if ( host == null ) { this . host = DEFAULT HOST ; } else { this . host = host ; url Buffer . append ( this . host ) ; } int listen Port = DEFAULT PORT ; if ( port == null ) { listen Port = is Secured ? DEFAULT SSL PORT : DEFAULT PORT ; } else { listen Port = port . int Value ( ) ; if ( listen Port < NUM_ || listen Port > NUM_ ) { final Localizable Message msg = ERR LDAPURL BAD PORT . get ( listen Port ) ; throw new Localized Illegal Argument Exception ( msg ) ; } url Buffer . append ( COLON CHAR ) ; url Buffer . append ( listen Port ) ; } this . port = listen Port ; url Buffer . append ( SLASH CHAR ) ; if ( name != null ) { this . name = name ; percent Encoder ( name . to String ( ) , url Buffer ) ; } else { this . name = DEFAULT DN ; } url Buffer . append ( QUESTION CHAR ) ; switch ( attributes . length ) { case NUM_ : this . attributes = Collections . empty List ( ) ; break ; case NUM_ : this . attributes = Collections . singleton List ( attributes [ NUM_ ] ) ; url Buffer . append ( attributes [ NUM_ ] ) ; break ; default : this . attributes = Collections . unmodifiable List ( Arrays . as List ( attributes ) ) ; url Buffer . append ( attributes [ NUM_ ] ) ; for ( int i = NUM_ ; i < attributes . length ; i ++ ) { url Buffer . append ( COMMA CHAR ) ; url Buffer . append ( attributes [ i ] ) ; } break ; } url Buffer . append ( QUESTION CHAR ) ; if ( scope != null ) { this . scope = scope ; url Buffer . append ( scope ) ; } else { this . scope = DEFAULT SCOPE ; } url Buffer . append ( QUESTION CHAR ) ; if ( filter != null ) { this . filter = filter ; url Buffer . append ( this . filter ) ; } else { this . filter = DEFAULT FILTER ; } url String = url Buffer . to String ( ) ; }
protected int wait For ( int counter ) { if ( counter > NUM_ ) -- counter ; else if ( counter > NUM_ ) { -- counter ; Thread . yield ( ) ; } else { Lock Support . park Nanos ( NUM_ ) ; } return counter ; }
private void build Lookup Table ( ) { final Set < Integer > seen child ids = new Hash Set < > ( ) ; Trie previous trie = null ; boolean first = true ; for ( final Trie trie : this . tries ) { if ( ! first ) { if ( ! have Same Source Side ( previous trie , trie ) || ! have Same Arity ( previous trie , trie ) ) { throw new Runtime Exception ( STR_ ) ; } } else { first = false ; } previous trie = trie ; if ( trie . has Rules ( ) ) { if ( trie With Rules != null ) { throw new Runtime Exception ( STR_ ) ; } trie With Rules = trie ; } final Hash Map < Integer , ? extends Trie > children = trie . get Children ( ) ; for ( int id : children . key Set ( ) ) { if ( seen child ids . contains ( id ) ) { throw new Runtime Exception ( STR_ ) ; } seen child ids . add ( id ) ; lookup . put ( id , children . get ( id ) ) ; } } }
public static byte [ ] patch Fast ( Input Stream old Input Stream , int oldsize , byte [ ] diff Bytes , int ext Len ) throws IO Exception { byte [ ] old Buf = new byte [ oldsize ] ; BS Util . read From Stream ( old Input Stream , old Buf , NUM_ , oldsize ) ; old Input Stream . close ( ) ; return BS Patch . patch Fast ( old Buf , oldsize , diff Bytes , diff Bytes . length , ext Len ) ; }
public static double similarity Number Vector ( Number Vector o 1 , Number Vector o 2 ) { final int d 1 = o 1 . get Dimensionality ( ) , d 2 = o 2 . get Dimensionality ( ) ; int intersection = NUM_ , union = NUM_ ; int d = NUM_ ; for ( ; d < d 1 && d < d 2 ; d ++ ) { double v 1 = o 1 . double Value ( d ) , v 2 = o 2 . double Value ( d ) ; if ( v 1 != v 1 || v 2 != v 2 ) { continue ; } if ( v 1 != NUM_ || v 2 != NUM_ ) { ++ union ; if ( v 1 == v 2 ) { ++ intersection ; } } } for ( ; d < d 1 ; d ++ ) { if ( o 1 . double Value ( d ) != NUM_ ) { ++ union ; } } for ( ; d < d 2 ; d ++ ) { if ( o 2 . double Value ( d ) != NUM_ ) { ++ union ; } } return intersection / ( double ) union ; }
public static void main ( String [ ] args ) { initialize Components ( ) ; Date Picker Settings settings = new Date Picker Settings ( ) ; Calendar Panel calendar Panel = new Calendar Panel ( settings ) ; calendar Panel . add Calendar Selection Listener ( new Sample Calendar Selection Listener ( ) ) ; container . add ( calendar Panel ) ; frame . set Visible ( true ) ; }
private int assign Threads ( int split Index , int split Count ) { if ( threads Per Split > NUM_ ) { return threads Per Split ; } if ( split Count == NUM_ ) { return thread Count ; } if ( split Count * min Threads > thread Count ) { return min Threads ; } if ( split Index % thread Count < thread Count % split Count ) { return thread Count / split Count + NUM_ ; } else { return thread Count / split Count ; } }
public final static int hash Lat Lon ( float lat , float lon ) { if ( lat == - NUM_ ) lat = NUM_ ; if ( lon == - NUM_ ) lon = NUM_ ; int tmp = Float . float To Int Bits ( lat ) ; int hash = ( tmp << NUM_ ) | ( tmp > > NUM_ ) ; return hash ^ Float . float To Int Bits ( lon ) ; }
protected Slice read Next ( File System WAL . File System WAL Reader reader ) { try { return reader . next ( ) ; } catch ( IO Exception ex ) { try { reader . close ( ) ; } catch ( IO Exception ioe ) { } return null ; } }
@ Override public Equipment Configuration Update update Config ( final Sub Equipment sub Equipment , final Properties properties ) throws Illegal Access Exception { if ( ( properties . get Property ( STR_ ) ) != null ) { throw new Configuration Exception ( Configuration Exception . INVALID PARAMETER VALUE , STR_ + STR_ ) ; } if ( ( properties . get Property ( STR_ ) ) != null ) { throw new Configuration Exception ( Configuration Exception . INVALID PARAMETER VALUE , STR_ + STR_ ) ; } super . update Config ( sub Equipment , properties ) ; return new Equipment Configuration Update ( ) ; }
void handle Swf Unloaded Event ( Swf Unloaded Event e ) { dump Swf Unloaded Line ( e ) ; }
public static void draw Round Rect Text ( Graphics 2 D g , Font font , Color text Color , String text , int x , int y ) { Graphics 2 D g 2 = ( Graphics 2 D ) g . create ( ) ; g 2 . set Font ( font ) ; Font Metrics fm = g 2 . get Font Metrics ( ) ; int padding = NUM_ ; Rectangle 2 D bounds = fm . get String Bounds ( text , g 2 ) ; double th = bounds . get Height ( ) + padding * NUM_ ; double tw = bounds . get Width ( ) + padding * NUM_ ; int radius = ( int ) ( Math . min ( th , tw ) / NUM_ ) ; g 2 . fill Round Rect ( ( int ) ( x - tw / NUM_ ) , ( int ) ( y - th / NUM_ ) , ( int ) tw , ( int ) th , radius , radius ) ; g 2 . set Color ( text Color ) ; g 2 . draw String ( text , ( int ) ( x - tw / NUM_ + padding ) , ( int ) ( y - th / NUM_ + fm . get Ascent ( ) ) ) ; if ( DEBUG ) { g 2 . set Color ( Color . RED ) ; g 2 . draw Line ( x - NUM_ , y , x + NUM_ , y ) ; g 2 . draw Line ( x , y - NUM_ , x , y + NUM_ ) ; } g 2 . dispose ( ) ; }
public Bean Descriptor ( Class < ? > bean Class , Class < ? > customizer Class ) { this . bean Class Ref = get Weak Reference ( bean Class ) ; this . customizer Class Ref = get Weak Reference ( customizer Class ) ; String name = bean Class . get Name ( ) ; while ( name . index Of ( STR_ ) >= NUM_ ) { name = name . substring ( name . index Of ( STR_ ) + NUM_ ) ; } set Name ( name ) ; }
private void validate ( String table Name , String column Name , Map < Column Meta Data , Object > validation Rules ) throws Exception { validation Rules . put ( Column Meta Data . TABLE NAME , table Name ) ; validation Rules . put ( Column Meta Data . COLUMN NAME , column Name ) ; check Validation Rules Complete ( validation Rules ) ; try ( Result Set columns = dbmd . get Columns ( null , null , table Name , column Name ) ) { assert True ( STR_ , columns . next ( ) ) ; validate Row Values ( columns , validation Rules ) ; assert False ( STR_ , columns . next ( ) ) ; } }
protected Object deserialize Unknown Header ( Data Input is , int head , Elsa Stack object Stack ) throws IO Exception { throw new IO Exception ( STR_ + head ) ; }
public boolean release Persistent Lock ( String lock Id ) throws Exception { Distributed Persistent Lock lock = coordinator . get Site Local Persistent Lock ( lock Id ) ; if ( lock != null ) { String lock Owner = lock . get Lock Owner ( ) ; if ( lock Owner == null ) { log . info ( STR_ ) ; return true ; } boolean result = lock . release Lock ( lock Owner ) ; if ( result ) { log . info ( STR_ , lock Id ) ; return true ; } else { log . info ( STR_ , lock Id ) ; } } return false ; }
private void add To List ( Vector < String > list , String line ) { list . add Element ( line ) ; }
static public String munge ( final String s ) { return s . replace All ( STR_ , STR_ ) ; }
protected void initialize ( ) { super . initialize ( ) ; m File Chooser = new J File Chooser ( ) ; m File Chooser . set Accept All File Filter Used ( true ) ; m File Chooser . set Multi Selection Enabled ( false ) ; m Undo = new Undo Manager ( ) ; m Args = new String [ NUM_ ] ; }
private float vector To Scalar Scroll ( float dx , float dy , float x , float y ) { float l = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; float cross X = - y ; float cross Y = x ; float dot = ( cross X * dx + cross Y * dy ) ; float sign = Math . signum ( dot ) ; return l * sign ; }
private void update Traffic Mask ( ) { int queue Size = traffic Controlling Sessions . size ( ) ; while ( queue Size > NUM_ ) { S session = traffic Controlling Sessions . poll ( ) ; if ( session == null ) { return ; } Session State state = get State ( session ) ; switch ( state ) { case OPENED : update Traffic Control ( session ) ; break ; case CLOSING : break ; case OPENING : traffic Controlling Sessions . add ( session ) ; break ; default : throw new Illegal State Exception ( String . value Of ( state ) ) ; } queue Size -- ; } }
private void save S Psoap Mni ( String mnisoap Location , String mniresp Loaction , List manage Name Id List , com . sun . identity . saml 2 . jaxb . metadata . Object Factory obj Fact ) throws JAXB Exception { if ( mnisoap Location != null && mnisoap Location . length ( ) > NUM_ ) { Manage Name ID Service Element sls Elem Soap = obj Fact . create Manage Name ID Service Element ( ) ; sls Elem Soap . set Binding ( soap Binding ) ; sls Elem Soap . set Location ( mnisoap Location ) ; sls Elem Soap . set Response Location ( mniresp Loaction ) ; manage Name Id List . add ( sls Elem Soap ) ; } }
public void check Font Saved ( final Object glyph , final String name , final Pdf Font current Font Data ) { page Objects . add Element ( glyph ) ; object Type . add Element ( Dynamic Vector Renderer . MARKER ) ; areas . add Element ( null ) ; current Item ++ ; if ( fonts Used . contains ( name ) || current Font Data . is Font Subsetted ( ) ) { fonts . put ( name , current Font Data . get Glyph Data ( ) ) ; fonts Used . add ( name ) ; } }
void STAR encoding diag 2 ( ) { int i , j , stripe , k ; char [ ] tmp ; tmp = new char [ p * block size ] ; for ( stripe = NUM_ ; stripe < block nbr + NUM_ ; stripe ++ ) { for ( i = NUM_ ; i < data disk nbr ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { k = ( stripe + i + p ) % p ; if ( k < block nbr ) tmp [ stripe * block size + j ] ^= check data [ i ] [ k * block size + j ] ; } } } for ( i = NUM_ ; i < block nbr ; i ++ ) { for ( j = NUM_ ; j < block size ; j ++ ) { tmp [ i * block size + j ] ^= tmp [ block nbr * block size + j ] ; } } System . arraycopy ( tmp , NUM_ , check data [ data disk nbr + NUM_ ] , NUM_ , stripe unit size ) ; }
private void on Main Content Scrolled ( int current Y , int delta Y ) { if ( delta Y > m Action Bar Auto Hide Sensivity ) { delta Y = m Action Bar Auto Hide Sensivity ; } else if ( delta Y < - m Action Bar Auto Hide Sensivity ) { delta Y = - m Action Bar Auto Hide Sensivity ; } if ( Math . signum ( delta Y ) * Math . signum ( m Action Bar Auto Hide Signal ) < NUM_ ) { m Action Bar Auto Hide Signal = delta Y ; } else { m Action Bar Auto Hide Signal += delta Y ; } boolean should Show = current Y < m Action Bar Auto Hide Min Y || ( m Action Bar Auto Hide Signal <= - m Action Bar Auto Hide Sensivity ) ; auto Show Or Hide Action Bar ( should Show ) ; }
public Modbus TCP Master ( String addr , int port , int timeout , boolean reconnect ) { super ( ) ; try { Inet Address slave Address = Inet Address . get By Name ( addr ) ; connection = new TCP Master Connection ( slave Address ) ; connection . set Port ( port ) ; connection . set Timeout ( timeout ) ; this . timeout = timeout ; set Reconnecting ( reconnect ) ; } catch ( Unknown Host Exception e ) { throw new Runtime Exception ( STR_ , e ) ; } }
public void apply ( View Property Animator animator , float curr Value , float end Value , float velocity ) { apply ( animator , curr Value , end Value , velocity , Math . abs ( end Value - curr Value ) ) ; }
public Search Action ( Search Information info , String message Key ) { this . info = info ; put Value ( Action . NAME , Message Format . format ( I 18 n . tr ( message Key ) , new Object [ ] { info . get Title ( ) } ) ) ; if ( Search Mediator . validate Info ( info ) != Search Mediator . QUERY VALID ) { throw new Illegal Argument Exception ( STR_ + info ) ; } }
@ Override public int hash Code ( ) { return hash ; }
@ Suppress Warnings ( STR_ ) static < T > void subscribe ( Subscriber < ? super T > s , Iterator < ? extends T > it ) { if ( it == null ) { Operators . error ( s , new Null Pointer Exception ( STR_ ) ) ; return ; } boolean b ; try { b = it . has Next ( ) ; } catch ( Throwable e ) { Operators . error ( s , Operators . on Operator Error ( e ) ) ; return ; } if ( ! b ) { Operators . complete ( s ) ; return ; } if ( s instanceof Conditional Subscriber ) { s . on Subscribe ( new Iterable Subscription Conditional < > ( ( Conditional Subscriber < ? super T > ) s , it ) ) ; } else { s . on Subscribe ( new Iterable Subscription < > ( s , it ) ) ; } }
public static String All Entries ( Locale locale ) { return Bundle . get Message ( locale , STR_ ) ; }
private void signal All ( ) { lock . lock ( ) ; try { is Done = true ; done . signal All ( ) ; } finally { lock . unlock ( ) ; } }
protected void ensure Capacity ( int min ) { if ( buf . length < min ) { int size = buf . length * NUM_ ; int max = Math . max ( min , size ) ; char [ ] temp = new char [ max ] ; System . arraycopy ( buf , NUM_ , temp , NUM_ , count ) ; buf = temp ; } }
private void paint Upper Thumb ( Graphics g ) { Rectangle knob Bounds = upper Thumb Rect ; int w = knob Bounds . width ; int h = knob Bounds . height ; Graphics 2 D g 2 d = ( Graphics 2 D ) g . create ( ) ; Shape thumb Shape = create Thumb Shape ( w - NUM_ , h - NUM_ , true ) ; g 2 d . set Rendering Hint ( Rendering Hints . KEY ANTIALIASING , Rendering Hints . VALUE ANTIALIAS ON ) ; g 2 d . translate ( knob Bounds . x , knob Bounds . y ) ; g 2 d . set Color ( Color . LIGHT GRAY ) ; g 2 d . fill ( thumb Shape ) ; g 2 d . set Color ( Color . GRAY ) ; g 2 d . draw ( thumb Shape ) ; g 2 d . dispose ( ) ; }
@ Suppress Warnings ( STR_ ) private static Array List < Path > collect Input Files ( String input , File System fs ) throws File Not Found Exception , IO Exception { Path path = new Path ( input ) ; Array List < Path > files = new Array List < Path > ( ) ; if ( fs . is Directory ( path ) ) { for ( File Status stat : fs . list Status ( path , CSV Reblock MR . hidden File Filter ) ) files . add ( stat . get Path ( ) ) ; Collections . sort ( files ) ; } else files . add ( path ) ; return files ; }
public Font Data ( final String cached File ) { try { font File = new Random Access File ( cached File , STR_ ) ; full Length = ( int ) font File . length ( ) ; } catch ( final Exception e ) { Log Writer . write Log ( STR_ + e . get Message ( ) ) ; } if ( full Length < max Size Allowed In Memory ) { block Size = max Size Allowed In Memory ; adjust For Cache ( NUM_ ) ; is In Memory = true ; } }
private static boolean eq ( Object o 1 , Object o 2 ) { return o 1 == null ? o 2 == null : o 1 . equals ( o 2 ) ; }
public void save Relations ( DB Transaction transaction , String charname , Player player ) throws SQL Exception { Multimap < String , String > old List = load Relations ( transaction , charname ) ; Set < String > buddies = player . get Buddies ( ) ; buddies . add ( charname ) ; sync Buddy List To DB ( transaction , charname , STR_ , old List . get ( STR_ ) , buddies ) ; sync Buddy List To DB ( transaction , charname , STR_ , old List . get ( STR_ ) , player . get Ignores ( ) ) ; }
@ Suppress Warnings ( STR_ ) public static String to URI ( final Class clazz ) throws Null Pointer Exception { return to URI ( clazz . get Name ( ) ) ; }
public Transit create New Transit ( String user Name ) { boolean found = false ; String test Name = STR_ ; Transit z ; while ( ! found ) { int next Auto Transit Ref = last Auto Transit Ref + NUM_ ; test Name = STR_ + next Auto Transit Ref ; z = get By System Name ( test Name ) ; if ( z == null ) { found = true ; } last Auto Transit Ref = next Auto Transit Ref ; } return create New Transit ( test Name , user Name ) ; }
private void process Class Meta ( Cache Type Metadata meta , Type Descriptor d , Cache Object Context co Ctx ) throws Ignite Checked Exception { Map < String , String > aliases = meta . get Aliases ( ) ; if ( aliases == null ) aliases = Collections . empty Map ( ) ; Class < ? > key Cls = d . key Class ( ) ; Class < ? > val Cls = d . value Class ( ) ; assert key Cls != null ; assert val Cls != null ; for ( Map . Entry < String , Class < ? > > entry : meta . get Ascending Fields ( ) . entry Set ( ) ) add To Index ( d , key Cls , val Cls , entry . get Key ( ) , entry . get Value ( ) , NUM_ , Index Type . ASC , null , aliases , co Ctx ) ; for ( Map . Entry < String , Class < ? > > entry : meta . get Descending Fields ( ) . entry Set ( ) ) add To Index ( d , key Cls , val Cls , entry . get Key ( ) , entry . get Value ( ) , NUM_ , Index Type . DESC , null , aliases , co Ctx ) ; for ( String txt Field : meta . get Text Fields ( ) ) add To Index ( d , key Cls , val Cls , txt Field , String . class , NUM_ , Index Type . TEXT , null , aliases , co Ctx ) ; Map < String , Linked Hash Map < String , Ignite Bi Tuple < Class < ? > , Boolean > > > grps = meta . get Groups ( ) ; if ( grps != null ) { for ( Map . Entry < String , Linked Hash Map < String , Ignite Bi Tuple < Class < ? > , Boolean > > > entry : grps . entry Set ( ) ) { String idx Name = entry . get Key ( ) ; Linked Hash Map < String , Ignite Bi Tuple < Class < ? > , Boolean > > idx Fields = entry . get Value ( ) ; int order = NUM_ ; for ( Map . Entry < String , Ignite Bi Tuple < Class < ? > , Boolean > > idx Field : idx Fields . entry Set ( ) ) { Boolean descending = idx Field . get Value ( ) . get 2 ( ) ; if ( descending == null ) descending = false ; add To Index ( d , key Cls , val Cls , idx Field . get Key ( ) , idx Field . get Value ( ) . get 1 ( ) , order , descending ? Index Type . DESC : Index Type . ASC , idx Name , aliases , co Ctx ) ; order ++ ; } } } for ( Map . Entry < String , Class < ? > > entry : meta . get Query Fields ( ) . entry Set ( ) ) { Class Property prop = build Class Property ( key Cls , val Cls , entry . get Key ( ) , entry . get Value ( ) , aliases , co Ctx ) ; d . add Property ( prop , false ) ; } }
public Change Notes create From Indexed Change ( Change change ) { return new Change Notes ( args , change ) ; }
private static String canonize Type String ( String str ) { String canon = str . trim ( ) ; canon = canon . replace All ( STR_ , STR_ ) ; canon = canon . replace All ( STR_ , STR_ ) ; canon = canon . replace All ( STR_ , STR_ ) ; canon = canon . replace All ( STR_ , STR_ ) ; canon = canon . replace All ( STR_ , STR_ ) ; canon = canon . replace All ( STR_ , STR_ ) ; return canon ; }
private List < Unit > collect Definitions ( Local l , Local Defs local Defs , Body body ) { List < Unit > defs = new Array List < Unit > ( ) ; for ( Unit u : body . get Units ( ) ) { List < Unit > defs Of = local Defs . get Defs Of At ( l , u ) ; if ( defs Of != null ) defs . add All ( defs Of ) ; } for ( Unit u : defs ) { Debug . print Dbg ( STR_ , u ) ; } return defs ; }
protected void check Bug Instance ( Bug Instance bug Instance ) { for ( Iterator < Bug Annotation > i = bug Instance . annotation Iterator ( ) ; i . has Next ( ) ; ) { Bug Annotation bug Annotation = i . next ( ) ; if ( bug Annotation instanceof Package Member Annotation ) { Package Member Annotation pkg Member = ( Package Member Annotation ) bug Annotation ; if ( pkg Member . get Source Lines ( ) == null ) { throw new Illegal State Exception ( STR_ + pkg Member + STR_ ) ; } } } }
protected static Tuple < String , String > create Tuple ( String one , boolean two ) { return Matsim Xml Writer . create Tuple ( one , Boolean . to String ( two ) ) ; }
private static String concat With Separator ( Collection < String > words , String separator ) { String Builder word List = new String Builder ( ) ; for ( String word : words ) { word List . append ( new String ( word ) + separator ) ; } return new String ( word List . delete Char At ( word List . length ( ) - NUM_ ) ) ; }
@ Override public void add Scanned Result ( List < List Based Result Wrapper > list Based Result ) { this . current Row Pointer = list Based Result ; total Number Of Records = list Based Result . size ( ) ; all Rows Result . add ( list Based Result ) ; }
public static String pad ( String string , int min Length ) { String result = string ; int pad = min Length - string . length ( ) ; if ( pad > NUM_ ) { result = string + pad ( min Length - string . length ( ) ) ; } else if ( pad < NUM_ ) { result = string . substring ( NUM_ , min Length ) ; } return result ; }
private Hash Map < Integer , Boolean > generate Expanded State Map ( List < Object > item List ) { Hash Map < Integer , Boolean > parent Object Hash Map = new Hash Map < > ( ) ; int child Count = NUM_ ; for ( int i = NUM_ ; i < item List . size ( ) ; i ++ ) { if ( item List . get ( i ) != null ) { Object helper Item = get Helper Item ( i ) ; if ( helper Item instanceof Parent Wrapper ) { Parent Wrapper parent Wrapper = ( Parent Wrapper ) helper Item ; parent Object Hash Map . put ( i - child Count , parent Wrapper . is Expanded ( ) ) ; } else { child Count ++ ; } } } return parent Object Hash Map ; }
public static Calendar updated ( Calendar self , Map < Object , Integer > updates ) { Calendar result = ( Calendar ) self . clone ( ) ; set ( result , updates ) ; return result ; }
public int update With On Conflict ( String table , Content Values values , String where Clause , String [ ] where Args , int conflict Algorithm ) { if ( values == null || values . size ( ) == NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } acquire Reference ( ) ; try { String Builder sql = new String Builder ( NUM_ ) ; sql . append ( STR_ ) ; sql . append ( CONFLICT VALUES [ conflict Algorithm ] ) ; sql . append ( table ) ; sql . append ( STR_ ) ; int set Values Size = values . size ( ) ; int bind Args Size = ( where Args == null ) ? set Values Size : ( set Values Size + where Args . length ) ; Object [ ] bind Args = new Object [ bind Args Size ] ; int i = NUM_ ; for ( String col Name : values . key Set ( ) ) { sql . append ( ( i > NUM_ ) ? STR_ : STR_ ) ; sql . append ( col Name ) ; bind Args [ i ++ ] = values . get ( col Name ) ; sql . append ( STR_ ) ; } if ( where Args != null ) { for ( i = set Values Size ; i < bind Args Size ; i ++ ) { bind Args [ i ] = where Args [ i - set Values Size ] ; } } if ( ! Text Utils . is Empty ( where Clause ) ) { sql . append ( STR_ ) ; sql . append ( where Clause ) ; } SQ Lite Statement statement = new SQ Lite Statement ( this , sql . to String ( ) , bind Args ) ; try { return statement . execute Update Delete ( ) ; } finally { statement . close ( ) ; } } finally { release Reference ( ) ; } }
protected boolean switch Profiles ( I Profile new Selection ) { if ( new Selection == null ) { return false ; } if ( m Current Profile == new Selection ) { return true ; } if ( m Alternative Profile Header Switching ) { int prev Selection = - NUM_ ; if ( m Profile First == new Selection ) { prev Selection = NUM_ ; } else if ( m Profile Second == new Selection ) { prev Selection = NUM_ ; } else if ( m Profile Third == new Selection ) { prev Selection = NUM_ ; } I Profile tmp = m Current Profile ; m Current Profile = new Selection ; if ( prev Selection == NUM_ ) { m Profile First = tmp ; } else if ( prev Selection == NUM_ ) { m Profile Second = tmp ; } else if ( prev Selection == NUM_ ) { m Profile Third = tmp ; } } else { if ( m Profiles != null ) { Array List < I Profile > previous Active Profiles = new Array List < > ( Arrays . as List ( m Current Profile , m Profile First , m Profile Second , m Profile Third ) ) ; if ( previous Active Profiles . contains ( new Selection ) ) { int position = - NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( previous Active Profiles . get ( i ) == new Selection ) { position = i ; break ; } } if ( position != - NUM_ ) { previous Active Profiles . remove ( position ) ; previous Active Profiles . add ( NUM_ , new Selection ) ; m Current Profile = previous Active Profiles . get ( NUM_ ) ; m Profile First = previous Active Profiles . get ( NUM_ ) ; m Profile Second = previous Active Profiles . get ( NUM_ ) ; m Profile Third = previous Active Profiles . get ( NUM_ ) ; } } else { m Profile Third = m Profile Second ; m Profile Second = m Profile First ; m Profile First = m Current Profile ; m Current Profile = new Selection ; } } } if ( m Only Small Profile Images Visible ) { m Profile Third = m Profile Second ; m Profile Second = m Profile First ; m Profile First = m Current Profile ; m Current Profile = m Profile Third ; } build Profiles ( ) ; return false ; }
public void reset ( ) throws IO Exception { m structure = null ; m JSON = null ; set Retrieval ( NONE ) ; if ( m File != null ) { set File ( new File ( m File ) ) ; } else if ( ( m URL != null ) && ! m URL . equals ( STR_ ) ) { set URL ( m URL ) ; } }
public String create Work Flowforobjects ( ) { LOGGER . info ( STR_ ) ; final List < Work Flow Matrix Details > matrix List = get Work Flow Matrix Details ( ) ; Collections . sort ( matrix List ) ; prepare Work Flow Matrix Details ( matrix List ) ; set Department Selected ( get Department ( ) ) ; set Additional Rule Selected ( get Additional Rule ( ) ) ; set Mode ( VIEW ) ; LOGGER . info ( STR_ ) ; return NEW ; }
private void process ( Field field , Annotation label , Annotation [ ] list ) { Contact contact = new Field Contact ( field , label , list ) ; Object key = new Field Key ( field ) ; if ( ! field . is Accessible ( ) ) { field . set Accessible ( true ) ; } insert ( key , contact ) ; }
private final Styled String append Parameter Signature ( Styled String buffer , char [ ] [ ] parameter Types , char [ ] [ ] parameter Names ) { if ( parameter Types != null ) { for ( int i = NUM_ ; i < parameter Types . length ; i ++ ) { if ( i > NUM_ ) { buffer . append ( STR_ ) ; buffer . append ( STR_ ) ; } buffer . append ( parameter Types [ i ] ) ; if ( parameter Names != null && parameter Names [ i ] != null ) { buffer . append ( STR_ ) ; buffer . append ( parameter Names [ i ] ) ; } } } return buffer ; }
public Enum read ( String value ) throws Exception { return Enum . value Of ( type , value ) ; }
public void clear ( ) { i Min Printed Digits = NUM_ ; i Print Zero Setting = PRINT ZERO RARELY LAST ; i Max Parsed Digits = NUM_ ; i Reject Signed Values = false ; i Prefix = null ; if ( i Element Pairs == null ) { i Element Pairs = new Array List < Object > ( ) ; } else { i Element Pairs . clear ( ) ; } i Not Printer = false ; i Not Parser = false ; i Field Formatters = new Field Formatter [ NUM_ ] ; }
private void populate Unity Access Profile For System ( Access Profile access Profile , Storage System storage Device ) { URI provider Uri = storage Device . get Active Provider URI ( ) ; if ( ! Null Column Value Getter . is Null URI ( provider Uri ) ) { Storage Provider provider = db Client . query Object ( Storage Provider . class , provider Uri ) ; access Profile . set System Type ( storage Device . get System Type ( ) ) ; access Profile . set Ip Address ( provider . get IP Address ( ) ) ; access Profile . set User Name ( provider . get User Name ( ) ) ; access Profile . set Password ( provider . get Password ( ) ) ; access Profile . setserial ID ( storage Device . get Serial Number ( ) ) ; access Profile . set Port Number ( provider . get Port Number ( ) ) ; access Profile . set Last Sample Time ( NUM_ ) ; } else { access Profile . set System Type ( storage Device . get System Type ( ) ) ; access Profile . set Ip Address ( storage Device . get Ip Address ( ) ) ; access Profile . set User Name ( storage Device . get Username ( ) ) ; access Profile . set Password ( storage Device . get Password ( ) ) ; access Profile . setserial ID ( storage Device . get Serial Number ( ) ) ; access Profile . set Port Number ( storage Device . get Port Number ( ) ) ; access Profile . set Last Sample Time ( NUM_ ) ; } }
@ Override public int hash Code ( Object x ) throws Hibernate Exception { return x . hash Code ( ) ; }
public static void patch Command Line For Virtualenv ( General Command Line command Line , String sdk Home , boolean pass Parent Environment ) { File virtual Env Root = get Virtual Env Root ( sdk Home ) ; if ( virtual Env Root != null ) { @ Non Nls final String PATH = STR_ ; File bin = new File ( virtual Env Root , STR_ ) ; if ( ! bin . exists ( ) ) { bin = new File ( virtual Env Root , STR_ ) ; } String virtualenv Bin = bin . get Path ( ) ; Map < String , String > env = command Line . get Environment ( ) ; String path Value ; if ( env . contains Key ( PATH ) ) { path Value = Python Env Util . append To Path Env Var ( env . get ( PATH ) , virtualenv Bin ) ; } else if ( pass Parent Environment ) { path Value = Python Env Util . append To Path Env Var ( System . getenv ( PATH ) , virtualenv Bin ) ; } else { path Value = virtualenv Bin ; } env . put ( PATH , path Value ) ; } }
public void path ( String path ) { Objects . require Non Null ( path ) ; path = path ; }
public void create Database Entities For Business Object Format Ddl Collection Testing ( ) { List < Schema Column > schema Columns = new Array List < > ( ) ; schema Columns . add ( new Schema Column ( Abstract Service Test . FIRST PARTITION COLUMN NAME , STR_ , Abstract Service Test . NO COLUMN SIZE , Abstract Service Test . COLUMN REQUIRED , Abstract Service Test . NO COLUMN DEFAULT VALUE , Abstract Service Test . NO COLUMN DESCRIPTION ) ) ; schema Columns . add ( new Schema Column ( Abstract Service Test . COLUMN NAME , STR_ , Abstract Service Test . COLUMN SIZE , Abstract Service Test . NO COLUMN REQUIRED , Abstract Service Test . COLUMN DEFAULT VALUE , Abstract Service Test . COLUMN DESCRIPTION ) ) ; List < Schema Column > partition Columns = schema Columns . sub List ( NUM_ , NUM_ ) ; business Object Format Dao Test Helper . create Business Object Format Entity ( Abstract Service Test . NAMESPACE , Abstract Service Test . BDEF NAME , Abstract Service Test . FORMAT USAGE CODE , File Type Entity . TXT FILE TYPE , Abstract Service Test . FORMAT VERSION , Abstract Service Test . FORMAT DESCRIPTION , Abstract Service Test . LATEST VERSION FLAG SET , Abstract Service Test . FIRST PARTITION COLUMN NAME , Abstract Service Test . NO PARTITION KEY GROUP , Abstract Service Test . NO ATTRIBUTES , Abstract Service Test . SCHEMA DELIMITER PIPE , Abstract Service Test . SCHEMA ESCAPE CHARACTER BACKSLASH , Abstract Service Test . SCHEMA NULL VALUE BACKSLASH N , schema Columns , partition Columns ) ; }
public void add Add Delete Buttons ( ) { J Button delete Button = new J Button ( STR_ ) ; delete Button . set Action ( Time Series Plot Actions . get Remove Source Action ( this ) ) ; J Button add Button = new J Button ( STR_ ) ; add Button . set Action ( Time Series Plot Actions . get Add Source Action ( this ) ) ; button Panel . add ( delete Button ) ; button Panel . add ( add Button ) ; }
protected int save New get ID ( ) { if ( get ID ( ) < NUM_ ) return get ID ( ) ; return NUM_ ; }
public void add Value ( int v ) { increment Value ( Long . value Of ( v ) , NUM_ ) ; }
private void replace Impl ( int start Index , int end Index , int remove Len , String insert Str , int insert Len ) { int new Size = size - remove Len + insert Len ; if ( insert Len != remove Len ) { ensure Capacity ( new Size ) ; System . arraycopy ( buffer , end Index , buffer , start Index + insert Len , size - end Index ) ; size = new Size ; } if ( insert Len > NUM_ ) { insert Str . get Chars ( NUM_ , insert Len , buffer , start Index ) ; } }
public void add Views ( T parent , List < View > views ) { for ( int i = NUM_ , size = views . size ( ) ; i < size ; i ++ ) { add View ( parent , views . get ( i ) , i ) ; } }
private void check Path Parameter Conditions ( Method method , Field Selector selector ) { Type Ref type = selector . get Type ( ) ; Well Known Type wkt = type . get Well Known Type ( ) ; if ( type . is Map ( ) ) { error ( method , STR_ , selector . to String ( ) , get Input Message Name ( method ) ) ; } else if ( type . is Repeated ( ) ) { error ( method , STR_ , selector , get Input Message Name ( method ) ) ; } else if ( type . is Message ( ) && ! wkt . allowed As Path Parameter ( ) ) { error ( method , STR_ , selector , get Input Message Name ( method ) ) ; } }
@ Override public void perform Backup ( Parcel File Descriptor old State , Backup Data Output data , Parcel File Descriptor new State ) { if ( VERBOSE ) Log . v ( TAG , STR_ ) ; Journal in = read Journal ( old State ) ; if ( ! launcher Is Ready ( ) ) { data Changed ( ) ; write Journal ( new State , in ) ; return ; } Log . v ( TAG , STR_ + in . t ) ; m Keys . clear ( ) ; apply Journal ( in ) ; long new Backup Time = System . current Time Millis ( ) ; m Backup Data Was Updated = false ; try { backup Favorites ( data ) ; backup Screens ( data ) ; backup Icons ( data ) ; backup Widgets ( data ) ; Hash Set < String > valid Keys = new Hash Set < String > ( ) ; for ( Key key : m Keys ) { valid Keys . add ( key To Backup Key ( key ) ) ; } m Existing Keys . remove All ( valid Keys ) ; for ( String deleted : m Existing Keys ) { if ( VERBOSE ) Log . v ( TAG , STR_ + deleted ) ; data . write Entity Header ( deleted , - NUM_ ) ; m Backup Data Was Updated = true ; } m Existing Keys . clear ( ) ; if ( ! m Backup Data Was Updated ) { m Backup Data Was Updated = false ; } if ( m Backup Data Was Updated ) { m Last Backup Restore Time = new Backup Time ; Journal state = get Current State Journal ( ) ; write Row To Backup ( JOURNAL KEY , state , data ) ; } else { if ( DEBUG ) Log . d ( TAG , STR_ ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STR_ , e ) ; } write New State Description ( new State ) ; }
public static Map < String , Object > find Content Parents ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > results = Fast Map . new Instance ( ) ; List < Object > parent List = Fast List . new Instance ( ) ; results . put ( STR_ , parent List ) ; Local Dispatcher dispatcher = dctx . get Dispatcher ( ) ; String content Id = ( String ) context . get ( STR_ ) ; String content Assoc Type Id = ( String ) context . get ( STR_ ) ; String direction = ( String ) context . get ( STR_ ) ; if ( Util Validate . is Empty ( direction ) ) { direction = STR_ ; } Map < String , Object > travers Map = Fast Map . new Instance ( ) ; travers Map . put ( STR_ , content Id ) ; travers Map . put ( STR_ , direction ) ; travers Map . put ( STR_ , content Assoc Type Id ) ; try { Map < String , Object > this Results = dispatcher . run Sync ( STR_ , travers Map ) ; String error Msg = Service Util . get Error Message ( this Results ) ; if ( Util Validate . is Not Empty ( error Msg ) ) { Debug . log Error ( STR_ + error Msg , module ) ; return Service Util . return Error ( error Msg ) ; } Map < String , Object > node Map = Util Generics . check Map ( this Results . get ( STR_ ) ) ; walk Parent Tree ( node Map , parent List ) ; } catch ( Generic Service Exception e ) { return Service Util . return Failure ( e . get Message ( ) ) ; } return results ; }
public static void start Query Have Locked Messages ( Async Query Handler handler , long thread Id , int token ) { Array List < Long > thread Ids = null ; if ( thread Id != - NUM_ ) { thread Ids = new Array List < Long > ( ) ; thread Ids . add ( thread Id ) ; } start Query Have Locked Messages ( handler , thread Ids , token ) ; }
protected Set < D > compute Call Flow Function ( Flow Function < D > call Flow Function , D d 1 , D d 2 ) { return call Flow Function . compute Targets ( d 2 ) ; }
protected String generate Drop Table SQL ( String table Name ) { return STR_ + table Name ; }
public static String generate Native Guid ( Hashtable < String , String > cim Indication ) throws IO Exception { String native Guid = cim Indication . get ( CIM Constants . SOURCE INSTANCE MODEL PATH COMPOSITE ID ) ; logger . debug ( STR_ , native Guid ) ; if ( native Guid != null && native Guid . index Of ( CIM Constants . CLARIION PREFIX ) != - NUM_ ) { native Guid = native Guid . replace ( CIM Constants . CLARIION PREFIX , CIM Constants . CLARIION PREFIX TO UPPER ) ; } if ( native Guid != null ) { native Guid = native Guid . replace ( STR_ , CIM Constants . VOLUME PREFIX ) ; } logger . debug ( STR_ , native Guid ) ; return native Guid ; }
private Eg Demand Details create Demand Details ( final Big Decimal amount , final Eg Demand Reason dmd Rsn , final Installment inst ) { LOGGER . debug ( STR_ + amount + STR_ + dmd Rsn + STR_ + inst ) ; final Eg Demand Details demand Detail = new Eg Demand Details ( ) ; demand Detail . set Amount ( amount ) ; demand Detail . set Amt Collected ( Big Decimal . ZERO ) ; demand Detail . set Amt Rebate ( Big Decimal . ZERO ) ; demand Detail . set Eg Demand Reason ( dmd Rsn ) ; demand Detail . set Create Date ( new Date ( ) ) ; demand Detail . set Modified Date ( new Date ( ) ) ; LOGGER . debug ( STR_ + demand Detail + STR_ ) ; return demand Detail ; }
public static double calculate Stack Total ( Table XY Dataset dataset , int item ) { double total = NUM_ ; int series Count = dataset . get Series Count ( ) ; for ( int s = NUM_ ; s < series Count ; s ++ ) { double value = dataset . get Y Value ( s , item ) ; if ( ! Double . is Na N ( value ) ) { total = total + value ; } } return total ; }
public static Boolean Glass Function serializable Instance ( ) { return new Boolean Glass Function ( Basic Lag Graph . serializable Instance ( ) ) ; }
protected final void fire Vetoable Change ( String property Name , Object old Value , Object new Value ) throws Property Veto Exception { Vetoable Change Support a Veto Support = this . veto Support ; if ( a Veto Support == null ) { return ; } a Veto Support . fire Vetoable Change ( property Name , old Value , new Value ) ; }
private void defer Runnable ( final Runnable runnable ) { deferred Runnables . add ( runnable ) ; }
public static void update Provider Key Info ( String realm , String entity ID , String cert Alias , boolean is IDP ) throws WS Federation Meta Exception { WS Federation Meta Manager meta Manager = new WS Federation Meta Manager ( ) ; Federation Config Element config = meta Manager . get Entity Config ( realm , entity ID ) ; if ( ! config . is Hosted ( ) ) { String [ ] args = { entity ID , realm } ; throw new WS Federation Meta Exception ( STR_ , args ) ; } Federation Element desp = meta Manager . get Entity Descriptor ( realm , entity ID ) ; if ( is IDP ) { IDPSSO Config Element idp Config = meta Manager . get IDPSSO Config ( realm , entity ID ) ; if ( ( idp Config == null ) || ( desp == null ) ) { String [ ] args = { entity ID , realm } ; throw new WS Federation Meta Exception ( STR_ , args ) ; } if ( ( cert Alias == null ) || ( cert Alias . length ( ) == NUM_ ) ) { remove Key Descriptor ( desp ) ; set Extended Attribute Value ( idp Config , SAML 2 Constants . SIGNING CERT ALIAS , null ) ; } else { Token Signing Key Info Element kde = get Key Descriptor ( cert Alias ) ; update Key Descriptor ( desp , kde ) ; Set value = new Hash Set ( ) ; value . add ( cert Alias ) ; set Extended Attribute Value ( idp Config , SAML 2 Constants . SIGNING CERT ALIAS , value ) ; } } else { SPSSO Config Element sp Config = meta Manager . get SPSSO Config ( realm , entity ID ) ; if ( ( sp Config == null ) || ( desp == null ) ) { String [ ] args = { entity ID , realm } ; throw new WS Federation Meta Exception ( STR_ , args ) ; } if ( ( cert Alias == null ) || ( cert Alias . length ( ) == NUM_ ) ) { remove Key Descriptor ( desp ) ; set Extended Attribute Value ( sp Config , SAML 2 Constants . SIGNING CERT ALIAS , null ) ; } else { Token Signing Key Info Element kde = get Key Descriptor ( cert Alias ) ; update Key Descriptor ( desp , kde ) ; Set value = new Hash Set ( ) ; value . add ( cert Alias ) ; set Extended Attribute Value ( sp Config , SAML 2 Constants . SIGNING CERT ALIAS , value ) ; } } meta Manager . set Federation ( realm , desp ) ; meta Manager . set Entity Config ( realm , config ) ; }
private boolean has Items ( Collection < ? extends Object > col ) { return col != null && ! col . is Empty ( ) ; }
public Resource to Resource ( final Supplier < Map < String , Relationship > > relationship Supplier , final Supplier < Map < String , Object > > attribute Supplier ) { final Resource resource = new Resource ( type , ( obj == null ) ? uuid . or Else Throw ( null ) : dictionary . get Id ( obj ) ) ; resource . set Relationships ( relationship Supplier . get ( ) ) ; resource . set Attributes ( attribute Supplier . get ( ) ) ; return resource ; }
public static String escape Java Script ( final String str ) { return String Escape Utils . escape Java Script ( str ) ; }
public < T extends Entry > void walk ( Entry start , Repository Visitor < T > visitor , Class < T > visited Type ) throws Repository Exception { boolean continue Children = true ; if ( visited Type . is Instance ( start ) ) { continue Children &= visitor . visit ( visited Type . cast ( start ) ) ; } if ( continue Children && start instanceof Folder ) { Folder folder = ( Folder ) start ; for ( Entry child : folder . get Data Entries ( ) ) { walk ( child , visitor , visited Type ) ; } for ( Folder child Folder : folder . get Subfolders ( ) ) { walk ( child Folder , visitor , visited Type ) ; } } }
private Collection Descriptor load Collection ( String collection Name ) throws Oracle Exception { if ( ! metadata Table Exists ) { return null ; } Oracle Callable Statement stmt = null ; String sqltext = STR_ + STR_ + STR_ + STR_ + STR_ ; Collection Descriptor desc = null ; try { metrics . start Timing ( ) ; stmt = ( Oracle Callable Statement ) conn . prepare Call ( sqltext ) ; stmt . set N String ( NUM_ , collection Name ) ; stmt . register Out Parameter ( NUM_ , Oracle Types . VARCHAR , DESC LENGTH ) ; stmt . execute ( ) ; String json Descriptor = stmt . get String ( NUM_ ) ; desc = get Descriptor From Caches ( collection Name ) ; if ( ( desc == null ) && ( json Descriptor != null ) ) { Builder builder = Collection Descriptor . json To Builder ( json Descriptor ) ; desc = put Descriptor Into Caches ( builder . build Descriptor ( collection Name ) ) ; } stmt . close ( ) ; stmt = null ; metrics . record Call ( ) ; } catch ( SQL Exception e ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( e . to String ( ) ) ; throw SODA Utils . make Exception With SQL Text ( e , sqltext ) ; } finally { for ( String message : SODA Utils . close Cursor ( stmt , null ) ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( message ) ; } } return ( desc ) ; }
public static byte [ ] pack Byte Buffer Into Single Byte Array ( Byte Buffer [ ] byte Buffer Arr ) { if ( null == byte Buffer Arr || byte Buffer Arr . length == NUM_ ) { return null ; } int no Of Col = byte Buffer Arr . length ; short offset Len = ( short ) ( no Of Col * NUM_ ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM_ ; index < byte Buffer Arr . length - NUM_ ; index ++ ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; int no Of Bytes = individual Col . capacity ( ) ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len += no Of Bytes ; individual Col . rewind ( ) ; } for ( int index = NUM_ ; index < byte Buffer Arr . length ; index ++ ) { Byte Buffer individual Col = byte Buffer Arr [ index ] ; buffer . put ( individual Col . array ( ) ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
private synchronized void start Sort ( ) { if ( kicker == null || ! kicker . is Alive ( ) ) { kicker = new Thread ( this ) ; kicker . start ( ) ; } }
static private String INT Min Minus ( ) { long temp Value = Integer . MIN VALUE - NUM_ ; return String . value Of ( temp Value ) ; }
@ Override public void run ( ) { am I Active = true ; String input Header = null ; String output Header = null ; Whitebox Raster image ; Whitebox Raster output ; int cols , rows ; int progress = NUM_ ; int col , row ; int i ; int num Sample Points = NUM_ ; if ( args . length <= NUM_ ) { show Feedback ( STR_ ) ; return ; } input Header = args [ NUM_ ] ; output Header = args [ NUM_ ] ; num Sample Points = Integer . parse Int ( args [ NUM_ ] ) ; if ( ( input Header == null ) || ( output Header == null ) ) { show Feedback ( STR_ ) ; return ; } try { image = new Whitebox Raster ( input Header , STR_ ) ; rows = image . get Number Rows ( ) ; cols = image . get Number Columns ( ) ; if ( rows * cols < num Sample Points ) { show Feedback ( STR_ ) ; return ; } output = new Whitebox Raster ( output Header , STR_ , input Header , Whitebox Raster . Data Type . FLOAT , NUM_ ) ; output . set Preferred Palette ( STR_ ) ; output . set Data Scale ( Whitebox Raster . Data Scale . CATEGORICAL ) ; image . close ( ) ; Non Duplicating Priority Queue queue = new Non Duplicating Priority Queue ( num Sample Points ) ; Random generator = new Random ( ) ; Grid Cell gc ; i = NUM_ ; do { row = generator . next Int ( rows ) ; col = generator . next Int ( cols ) ; gc = new Grid Cell ( row , col ) ; if ( queue . add ( gc ) ) { i ++ ; progress = ( int ) ( NUM_ * i / num Sample Points ) ; update Progress ( STR_ , progress ) ; } } while ( i < num Sample Points ) ; Iterator < Grid Cell > it = queue . iterator ( ) ; i = NUM_ ; do { gc = queue . poll ( ) ; output . set Value ( gc . row , gc . col , i ) ; i ++ ; progress = ( int ) ( NUM_ * i / num Sample Points ) ; update Progress ( STR_ , progress ) ; } while ( i < num Sample Points ) ; output . add Metadata Entry ( STR_ + get Descriptive Name ( ) + STR_ ) ; output . add Metadata Entry ( STR_ + new Date ( ) ) ; output . close ( ) ; return Data ( output Header ) ; } catch ( Out Of Memory Error oe ) { my Host . show Feedback ( STR_ ) ; } catch ( Exception e ) { my Host . show Feedback ( STR_ ) ; my Host . log Exception ( STR_ + get Descriptive Name ( ) , e ) ; } finally { update Progress ( STR_ , NUM_ ) ; am I Active = false ; my Host . plugin Complete ( ) ; } }
public void write External ( Object Output out ) throws IO Exception { ref . write ( out , false ) ; }
public String filter Text ( String text ) { return text ; }
public void update Surface Data ( Surface Data src Data , Surface Data dst Data , int w , int h ) { Surface Type src Type = src Data . get Surface Type ( ) ; Surface Type dst Type = dst Data . get Surface Type ( ) ; Blit blit = Blit . get From Cache ( src Type , Composite Type . Src No Ea , dst Type ) ; blit . Blit ( src Data , dst Data , Alpha Composite . Src , null , NUM_ , NUM_ , NUM_ , NUM_ , w , h ) ; dst Data . mark Dirty ( ) ; }
public static void assert Thread Id To Sequence Id Mapis Not Null But Empty ( ) { Map map = pool . get Thread Id To Sequence Id Map ( ) ; assert Not Null ( map ) ; assert True ( map . size ( ) == NUM_ ) ; }
private Data Store < DBI Ds > load Neighbors ( Database database , Relation < ? > relation ) { final Writable Data Store < DBI Ds > store = Data Store Util . make Storage ( relation . get DBI Ds ( ) , Data Store Factory . HINT HOT | Data Store Factory . HINT STATIC | Data Store Factory . HINT TEMP , DBI Ds . class ) ; if ( LOG . is Verbose ( ) ) { LOG . verbose ( STR_ ) ; } if ( LOG . is Debugging ( ) ) { LOG . verbose ( STR_ ) ; } Map < String , DBID > lblmap = new Hash Map < > ( relation . size ( ) << NUM_ ) ; { Relation < Label List > olq = database . get Relation ( Type Util . LABELLIST ) ; Relation < External ID > eidq = database . get Relation ( Type Util . EXTERNALID ) ; for ( DBID Iter iditer = relation . iter DBI Ds ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { if ( eidq != null ) { External ID eid = eidq . get ( iditer ) ; if ( eid != null ) { lblmap . put ( eid . to String ( ) , DBID Util . deref ( iditer ) ) ; } } if ( olq != null ) { Label List label = olq . get ( iditer ) ; if ( label != null ) { for ( int i = NUM_ ; i < label . size ( ) ; i ++ ) { lblmap . put ( label . get ( i ) , DBID Util . deref ( iditer ) ) ; } } } } } if ( LOG . is Debugging ( ) ) { LOG . verbose ( STR_ ) ; } try ( Input Stream in = File Util . try Gzip Input ( new File Input Stream ( file ) ) ; Buffered Reader br = new Buffered Reader ( new Input Stream Reader ( in ) ) ) { for ( String line ; ( line = br . read Line ( ) ) != null ; ) { Array Modifiable DBI Ds neighbours = DBID Util . new Array ( ) ; String [ ] entries = line . split ( STR_ ) ; DBID id = lblmap . get ( entries [ NUM_ ] ) ; if ( id != null ) { for ( int i = NUM_ ; i < entries . length ; i ++ ) { final DBID neigh = lblmap . get ( entries [ i ] ) ; if ( neigh != null ) { neighbours . add ( neigh ) ; } else { if ( LOG . is Debugging ( ) ) { LOG . debug ( STR_ + entries [ i ] ) ; } } } store . put ( id , neighbours ) ; } else { if ( LOG . is Debugging ( ) ) { LOG . warning ( STR_ + entries [ NUM_ ] ) ; } } } return store ; } catch ( IO Exception e ) { throw new Abort Exception ( STR_ , e ) ; } }
private void prepare Transfers ( ) throws Lib Usb Exception { if ( m Available Transfers == null ) { m Available Transfers = new Linked Transfer Queue < > ( ) ; for ( int x = NUM_ ; x < TRANSFER BUFFER POOL SIZE ; x ++ ) { Transfer transfer = Lib Usb . alloc Transfer ( ) ; if ( transfer == null ) { throw new Lib Usb Exception ( STR_ , Lib Usb . ERROR NO MEM ) ; } final Byte Buffer buffer = Byte Buffer . allocate Direct ( m Buffer Size ) ; Lib Usb . fill Bulk Transfer ( transfer , m Device Handle , USB ENDPOINT , buffer , Buffer Processor . this , STR_ , USB TIMEOUT MS ) ; m Available Transfers . add ( transfer ) ; } } }
public synchronized void sync All ( ) throws SOS Failure { final String method Name = STR_ ; log . trace ( method Name + STR_ ) ; file Cos Id List = null ; block Cos Id List = null ; block Cos Detail List = null ; file Cos Detail List = null ; log . trace ( method Name + STR_ ) ; }
protected static void append Short Type ( String Builder sb ) { sb . append ( STR_ ) ; }
Data Importer ( ) { this . handler Name = STR_ ; }
public void add Clear Graph Data Button ( ) { J Button clear Button = new J Button ( STR_ ) ; clear Button . set Action ( Time Series Plot Actions . get Clear Graph Action ( this ) ) ; button Panel . add ( clear Button ) ; }
public String to String Tree ( ) { String Builder b = new String Builder ( ) ; to String Tree ( b , STR_ ) ; return b . to String ( ) ; }
public static org . smpte ra . schemas . st 2067 2 2013 . User Text Type build CPL User Text Type 2013 ( String value , String language ) { org . smpte ra . schemas . st 2067 2 2013 . User Text Type user Text Type = new org . smpte ra . schemas . st 2067 2 2013 . User Text Type ( ) ; user Text Type . set Value ( value ) ; user Text Type . set Language ( language ) ; return user Text Type ; }
public double [ ] distribution For Instance ( Instance instance ) throws Exception { double trans Prob = NUM_ , temp = NUM_ ; double [ ] class Probability = new double [ m Num Classes ] ; double [ ] predicted Value = new double [ NUM_ ] ; for ( int i = NUM_ ; i < class Probability . length ; i ++ ) { class Probability [ i ] = NUM_ ; } predicted Value [ NUM_ ] = NUM_ ; if ( m Init Flag == ON ) { if ( m Blend Method == B ENTROPY ) { generate Random Class Colomns ( ) ; } m Cache = new K Star Cache [ m Num Attributes ] ; for ( int i = NUM_ ; i < m Num Attributes ; i ++ ) { m Cache [ i ] = new K Star Cache ( ) ; } m Init Flag = OFF ; } Instance train Instance ; Enumeration < Instance > enu = m Train . enumerate Instances ( ) ; while ( enu . has More Elements ( ) ) { train Instance = ( Instance ) enu . next Element ( ) ; trans Prob = instance Transformation Probability ( instance , train Instance ) ; switch ( m Class Type ) { case Attribute . NOMINAL : class Probability [ ( int ) train Instance . class Value ( ) ] += trans Prob ; break ; case Attribute . NUMERIC : predicted Value [ NUM_ ] += trans Prob * train Instance . class Value ( ) ; temp += trans Prob ; break ; } } if ( m Class Type == Attribute . NOMINAL ) { double sum = Utils . sum ( class Probability ) ; if ( sum <= NUM_ ) for ( int i = NUM_ ; i < class Probability . length ; i ++ ) class Probability [ i ] = ( double ) NUM_ / ( double ) m Num Classes ; else Utils . normalize ( class Probability , sum ) ; return class Probability ; } else { predicted Value [ NUM_ ] = ( temp != NUM_ ) ? predicted Value [ NUM_ ] / temp : NUM_ ; return predicted Value ; } }
protected Buffered Image reset Drawing Buffer ( Buffered Image current Image Buffer , Projection proj ) { try { int w = proj . get Width ( ) ; int h = proj . get Height ( ) ; if ( current Image Buffer != null ) { int cib Width = current Image Buffer . get Width ( ) ; int cib Height = current Image Buffer . get Height ( ) ; if ( cib Width == w && cib Height == h ) { Graphics 2 D graphics = ( Graphics 2 D ) current Image Buffer . get Graphics ( ) ; graphics . set Composite ( Alpha Composite . Clear ) ; graphics . fill Rect ( NUM_ , NUM_ , w , h ) ; graphics . set Composite ( Alpha Composite . Src Over ) ; return current Image Buffer ; } else { current Image Buffer . flush ( ) ; } } return new Buffered Image ( w , h , Buffered Image . TYPE INT ARGB ) ; } catch ( java . lang . Negative Array Size Exception nae ) { } catch ( java . lang . Illegal Argument Exception iae ) { } return new Buffered Image ( NUM_ , NUM_ , Buffered Image . TYPE INT ARGB ) ; }
LW Component Peer < ? , ? > find Peer At ( final int x , final int y ) { final Rectangle r = get Bounds ( ) ; final Region sh = get Region ( ) ; final boolean found = is Visible ( ) && sh . contains ( x - r . x , y - r . y ) ; return found ? this : null ; }
protected Chrome Animation < ? > create Update Discard Animator Set ( Stack Tab [ ] tabs , int spacing , float warp Size , float discard Range ) { Chrome Animation < Animatable < ? > > set = new Chrome Animation < Animatable < ? > > ( ) ; int dying Tabs Count = NUM_ ; float first Dying Tab Offset = NUM_ ; for ( int i = NUM_ ; i < tabs . length ; ++ i ) { Stack Tab tab = tabs [ i ] ; add Tilt Scroll Animation ( set , tab . get Layout Tab ( ) , NUM_ , UNDISCARD ANIMATION DURATION , NUM_ ) ; if ( tab . is Dying ( ) ) { dying Tabs Count ++ ; if ( dying Tabs Count == NUM_ ) { first Dying Tab Offset = get Screen Position In Scroll Direction ( tab ) ; } } } Interpolator interpolator = Baked Bezier Interpolator . FADE OUT CURVE ; int new Index = NUM_ ; for ( int i = NUM_ ; i < tabs . length ; ++ i ) { Stack Tab tab = tabs [ i ] ; long start Time = ( long ) Math . max ( NUM_ , TAB REORDER START SPAN / get Screen Size In Scroll Direction ( ) * ( get Screen Position In Scroll Direction ( tab ) - first Dying Tab Offset ) ) ; if ( tab . is Dying ( ) ) { float discard = tab . get Discard Amount ( ) ; if ( discard == NUM_ ) discard = is Default Discard Direction Positive ( ) ? NUM_ : - NUM_ ; float s = Math . copy Sign ( NUM_ , discard ) ; long duration = ( long ) ( DISCARD ANIMATION DURATION * ( NUM_ - Math . abs ( discard / discard Range ) ) ) ; add Animation ( set , tab , DISCARD AMOUNT , discard , discard Range * s , duration , start Time , false , interpolator ) ; } else { if ( tab . get Discard Amount ( ) != NUM_ ) { add Animation ( set , tab , DISCARD AMOUNT , tab . get Discard Amount ( ) , NUM_ , UNDISCARD ANIMATION DURATION , NUM_ ) ; } float new Scroll Offset = Stack Tab . screen To Scroll ( spacing * new Index , warp Size ) ; if ( tab . get Discard Amount ( ) >= discard Range ) { tab . set Scroll Offset ( new Scroll Offset ) ; tab . set Scale ( SCALE AMOUNT ) ; } else { float start = tab . get Scroll Offset ( ) ; if ( start != new Scroll Offset ) { add Animation ( set , tab , SCROLL OFFSET , start , new Scroll Offset , TAB REORDER DURATION , start Time ) ; } } new Index ++ ; } } return set ; }
public static String object String Non Recursive ( @ Unretained Object obj ) { String Builder sb = new String Builder ( ) ; object String Non Recursive ( obj , sb ) ; return sb . to String ( ) ; }
@ Override public boolean lock ( ) { try { if ( ! File Factory . is File Exist ( location , File Factory . get File Type ( tmp Path ) ) ) { File Factory . mkdirs ( location , File Factory . get File Type ( tmp Path ) ) ; } lock File Path = location + Carbon Common Constants . FILE SEPARATOR + lock File ; if ( ! File Factory . is File Exist ( lock File Path , File Factory . get File Type ( location ) ) ) { File Factory . create New Lock File ( lock File Path , File Factory . get File Type ( location ) ) ; } file Output Stream = new File Output Stream ( lock File Path ) ; channel = file Output Stream . get Channel ( ) ; try { file Lock = channel . try Lock ( ) ; } catch ( Overlapping File Lock Exception e ) { return false ; } if ( null != file Lock ) { return true ; } else { return false ; } } catch ( IO Exception e ) { return false ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Arrow Needle ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } Arrow Needle that = ( Arrow Needle ) obj ; if ( this . is Arrow At Top != that . is Arrow At Top ) { return false ; } return true ; }
private void secure Auth ( Buffer packet , int pack Length , String user , String password , String database , boolean write Client Params ) throws SQL Exception { if ( packet == null ) { packet = new Buffer ( pack Length ) ; } if ( write Client Params ) { if ( this . use 41 Extensions ) { if ( version Meets Minimum ( NUM_ , NUM_ , NUM_ ) ) { packet . write Long ( this . client Param ) ; packet . write Long ( this . max Three Bytes ) ; packet . write Byte ( ( byte ) NUM_ ) ; packet . write Bytes No Null ( new byte [ NUM_ ] ) ; } else { packet . write Long ( this . client Param ) ; packet . write Long ( this . max Three Bytes ) ; } } else { packet . write Int ( ( int ) this . client Param ) ; packet . write Long Int ( this . max Three Bytes ) ; } } packet . write String ( user , CODE PAGE 1252 , this . connection ) ; if ( password . length ( ) != NUM_ ) { packet . write String ( FALSE SCRAMBLE , CODE PAGE 1252 , this . connection ) ; } else { packet . write String ( STR_ , CODE PAGE 1252 , this . connection ) ; } if ( this . use Connect With Db ) { packet . write String ( database , CODE PAGE 1252 , this . connection ) ; } send ( packet , packet . get Position ( ) ) ; if ( password . length ( ) > NUM_ ) { Buffer b = read Packet ( ) ; b . set Position ( NUM_ ) ; byte [ ] reply As Bytes = b . get Byte Buffer ( ) ; if ( ( reply As Bytes . length == NUM_ ) && ( reply As Bytes [ NUM_ ] != NUM_ ) ) { if ( reply As Bytes [ NUM_ ] != STR_ ) { try { byte [ ] buff = Security . password Hash Stage 1 ( password ) ; byte [ ] password Hash = new byte [ buff . length ] ; System . arraycopy ( buff , NUM_ , password Hash , NUM_ , buff . length ) ; password Hash = Security . password Hash Stage 2 ( password Hash , reply As Bytes ) ; byte [ ] packet Data After Salt = new byte [ reply As Bytes . length - NUM_ ] ; System . arraycopy ( reply As Bytes , NUM_ , packet Data After Salt , NUM_ , reply As Bytes . length - NUM_ ) ; byte [ ] mysql Scramble Buff = new byte [ SEED LENGTH ] ; Security . xor String ( packet Data After Salt , mysql Scramble Buff , password Hash , SEED LENGTH ) ; Security . xor String ( mysql Scramble Buff , buff , buff , SEED LENGTH ) ; Buffer packet 2 = new Buffer ( NUM_ ) ; packet 2 . write Bytes No Null ( buff ) ; this . packet Sequence ++ ; send ( packet 2 , NUM_ ) ; } catch ( No Such Algorithm Exception nse ) { throw SQL Error . create SQL Exception ( Messages . get String ( STR_ ) + Messages . get String ( STR_ ) , SQL Error . SQL STATE GENERAL ERROR , get Exception Interceptor ( ) ) ; } } else { try { byte [ ] password Hash = Security . create Key From Old Password ( password ) ; byte [ ] net Read Pos 4 = new byte [ reply As Bytes . length - NUM_ ] ; System . arraycopy ( reply As Bytes , NUM_ , net Read Pos 4 , NUM_ , reply As Bytes . length - NUM_ ) ; byte [ ] mysql Scramble Buff = new byte [ SEED LENGTH ] ; Security . xor String ( net Read Pos 4 , mysql Scramble Buff , password Hash , SEED LENGTH ) ; String scrambled Password = Util . scramble ( String Utils . to String ( mysql Scramble Buff ) , password ) ; Buffer packet 2 = new Buffer ( pack Length ) ; packet 2 . write String ( scrambled Password , CODE PAGE 1252 , this . connection ) ; this . packet Sequence ++ ; send ( packet 2 , NUM_ ) ; } catch ( No Such Algorithm Exception nse ) { throw SQL Error . create SQL Exception ( Messages . get String ( STR_ ) + Messages . get String ( STR_ ) , SQL Error . SQL STATE GENERAL ERROR , get Exception Interceptor ( ) ) ; } } } } }
private Query Bundle < QUERY TYPE , META QUERY , QUEUE CONTEXT > dequeue Helper ( boolean block ) { Query Bundle < QUERY TYPE , META QUERY , QUEUE CONTEXT > qq = null ; boolean first = true ; if ( block ) { acquire ( ) ; } if ( current Node == null ) { current Node = query Queue . get Head ( ) ; read Current = false ; if ( current Node == null ) { return null ; } } else { if ( read Current ) { Queue List Node < Query Bundle < QUERY TYPE , META QUERY , QUEUE CONTEXT > > temp Node = current Node . get Next ( ) ; if ( temp Node != null ) { current Node = temp Node ; read Current = false ; } else { return null ; } } } while ( true ) { if ( block && ! first ) { acquire ( ) ; if ( current Node == null ) { current Node = query Queue . get Head ( ) ; read Current = false ; if ( current Node == null ) { return null ; } } else { if ( read Current ) { Queue List Node < Query Bundle < QUERY TYPE , META QUERY , QUEUE CONTEXT > > temp Node = current Node . get Next ( ) ; if ( temp Node != null ) { current Node = temp Node ; read Current = false ; } else { return null ; } } } } synchronized ( num Left ) { num Left . get And Decrement ( ) ; Query Bundle < QUERY TYPE , META QUERY , QUEUE CONTEXT > query Queueable = current Node . get Payload ( ) ; first = false ; Queue List Node < Query Bundle < QUERY TYPE , META QUERY , QUEUE CONTEXT > > next Node = current Node . get Next ( ) ; if ( remove Bundle ( query Queueable ) ) { query Queue . remove Node ( current Node ) ; removed Node ( current Node ) ; if ( block ) { if ( next Node == null ) { read Current = true ; } else { current Node = next Node ; read Current = false ; } } else { if ( next Node == null ) { read Current = true ; break ; } else { current Node = next Node ; } } } else { qq = current Node . get Payload ( ) ; if ( next Node == null ) { read Current = true ; } else { current Node = next Node ; read Current = false ; } break ; } } } if ( semaphore . available Permits ( ) > num Left . get ( ) ) { try { semaphore . acquire ( semaphore . available Permits ( ) - num Left . get ( ) ) ; } catch ( Interrupted Exception ex ) { throw new Runtime Exception ( ex ) ; } } return qq ; }
private void use Our U Is ( ) { for ( String ui Name : UI LIST ) { ui Name = ui Name + STR_ ; ui Defaults . put ( ui Name , UI PACKAGE PREFIX + ui Name ) ; } }
@ Override public Explanation explain ( Leaf Reader Context context , int doc ) throws IO Exception { boolean match = false ; float max = Float . NEGATIVE INFINITY , sum = NUM_ ; List < Explanation > subs = new Array List < > ( ) ; for ( Weight wt : weights ) { Explanation e = wt . explain ( context , doc ) ; if ( e . is Match ( ) ) { match = true ; subs . add ( e ) ; sum += e . get Value ( ) ; max = Math . max ( max , e . get Value ( ) ) ; } } if ( match ) { final float score = max + ( sum - max ) * tie Breaker Multiplier ; final String desc = tie Breaker Multiplier == NUM_ ? STR_ : STR_ + tie Breaker Multiplier + STR_ ; return Explanation . match ( score , desc , subs ) ; } else { return Explanation . no Match ( STR_ ) ; } }
@ Override public Ascii Array with Columns ( String [ ] ... columns ) { for ( String [ ] column : columns ) { add Column ( Arrays . as List ( column ) ) ; } return this ; }
public void flush Cache ( String renderer ID ) throws Empty Cache Exception { Log . d ( Map Tile Filesystem Provider . DEBUGTAG , STR_ + renderer ID ) ; final Cursor c = m Database . raw Query ( STR_ + T FSCACHE ZOOM LEVEL + STR_ + T FSCACHE TILE X + STR_ + T FSCACHE TILE Y + STR_ + T FSCACHE FILESIZE + STR_ + T FSCACHE + STR_ + T FSCACHE RENDERER ID + STR_ + renderer ID + STR_ + T FSCACHE TIMESTAMP + STR_ , null ) ; final Array List < Map Tile > delete From DB = new Array List < Map Tile > ( ) ; long size Gained = NUM_ ; if ( c != null ) { Map Tile tile To Be Deleted ; if ( c . move To First ( ) ) { do { final int size Item = c . get Int ( c . get Column Index Or Throw ( T FSCACHE FILESIZE ) ) ; size Gained += size Item ; tile To Be Deleted = new Map Tile ( renderer ID , c . get Int ( c . get Column Index Or Throw ( T FSCACHE ZOOM LEVEL ) ) , c . get Int ( c . get Column Index Or Throw ( T FSCACHE TILE X ) ) , c . get Int ( c . get Column Index Or Throw ( T FSCACHE TILE Y ) ) ) ; delete From DB . add ( tile To Be Deleted ) ; Log . d ( DEBUG TAG , STR_ + tile To Be Deleted . to String ( ) ) ; } while ( c . move To Next ( ) ) ; } else { c . close ( ) ; throw new Empty Cache Exception ( STR_ ) ; } c . close ( ) ; for ( Map Tile t : delete From DB ) { final String [ ] args = new String [ ] { STR_ + t . renderer ID , STR_ + t . zoom Level , STR_ + t . x , STR_ + t . y } ; m Database . delete ( T FSCACHE , T FSCACHE WHERE , args ) ; } } }
public int search ( Vector < Tree Node > vct , String target ) { if ( vct == null ) { return - NUM_ ; } for ( int i = NUM_ ; i < vct . size ( ) ; i ++ ) { if ( target . equals ( vct . element At ( i ) . value ) ) { return i ; } } return - NUM_ ; }
protected void layout Major Axis ( int target Span , int axis , int [ ] offsets , int [ ] spans ) { long preferred = NUM_ ; int n = get View Count ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { View v = get View ( i ) ; spans [ i ] = ( int ) v . get Preferred Span ( axis ) ; preferred += spans [ i ] ; } long desired Adjustment = target Span - preferred ; float adjustment Factor = NUM_ ; int [ ] diffs = null ; if ( desired Adjustment != NUM_ ) { long total Span = NUM_ ; diffs = new int [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { View v = get View ( i ) ; int tmp ; if ( desired Adjustment < NUM_ ) { tmp = ( int ) v . get Minimum Span ( axis ) ; diffs [ i ] = spans [ i ] - tmp ; } else { tmp = ( int ) v . get Maximum Span ( axis ) ; diffs [ i ] = tmp - spans [ i ] ; } total Span += tmp ; } float maximum Adjustment = Math . abs ( total Span - preferred ) ; adjustment Factor = desired Adjustment / maximum Adjustment ; adjustment Factor = Math . min ( adjustment Factor , NUM_ ) ; adjustment Factor = Math . max ( adjustment Factor , - NUM_ ) ; } int total Offset = NUM_ ; for ( int i = NUM_ ; i < n ; i ++ ) { offsets [ i ] = total Offset ; if ( desired Adjustment != NUM_ ) { float adj F = adjustment Factor * diffs [ i ] ; spans [ i ] += Math . round ( adj F ) ; } total Offset = ( int ) Math . min ( ( long ) total Offset + ( long ) spans [ i ] , Integer . MAX VALUE ) ; } }
@ Override public boolean input ( Instance instance ) { Instance new Instance ; double [ ] values ; if ( get Input Format ( ) == null ) { throw new Illegal State Exception ( STR_ ) ; } if ( m New Batch ) { reset Queue ( ) ; m New Batch = false ; } values = instance . to Double Array ( ) ; if ( ! instance . is Missing ( m Att Index . get Index ( ) ) ) { values [ m Att Index . get Index ( ) ] = m Sorted Indices [ ( int ) values [ m Att Index . get Index ( ) ] ] ; } new Instance = new Dense Instance ( instance . weight ( ) , values ) ; copy Values ( instance , false , instance . dataset ( ) , get Output Format ( ) ) ; push ( new Instance ) ; return true ; }
@ Override public final long encode Norm Value ( float f ) { return Float . float To Int Bits ( f ) ; }
private void validate ( Protos . Health Check health Check ) throws Health Check Validation Exception { if ( health Check . has Http ( ) ) { throw new Health Check Validation Exception ( STR_ + health Check ) ; } if ( ! health Check . has Command ( ) ) { throw new Health Check Validation Exception ( STR_ + health Check ) ; } Protos . Command Info command Info = health Check . get Command ( ) ; if ( ! Boolean . value Of ( command Info . get Shell ( ) ) ) { throw new Health Check Validation Exception ( STR_ + command Info ) ; } }
public void add Selection Listener ( Explorer Selection Listener listener ) { selection Listeners . add ( listener ) ; }
private void add ( String world , Permission Holder holder , String permission ) { try { if ( world != null && ! world . equals ( STR_ ) ) { holder . set Permission ( permission , true , server , world ) ; } else { holder . set Permission ( permission , true , server ) ; } } catch ( Object Already Has Exception ignored ) { } save ( holder ) ; }
public void update Hash For Group ( final String hash , final String group Name ) { not Null ( group Name ) ; this . current Hash = hash ; if ( is Changed Hash ( ) ) { LOG . debug ( STR_ , group Name ) ; groups . clear ( ) ; } }
public void write All ( ) { try { set Address ( NUM_ ) ; } catch ( Exception e ) { if ( log . is Debug Enabled ( ) ) { log . debug ( rb . get String ( STR_ ) + STR_ + e ) ; } read All Button . set Selected ( false ) ; write All Button . set Selected ( false ) ; status . set Text ( STR_ ) ; return ; } if ( response Timer == null ) { initialize Response Timer ( ) ; } if ( pacing Timer == null ) { initialize Pacing Timer ( ) ; } copy To Opsw ( ) ; read = false ; state = NUM_ ; only One Operation = false ; next Request ( ) ; }
public void increment Renewed Tokens ( String tenant ) { logger . trace ( STR_ , tenant ) ; try { Atomic Integer count ; synchronized ( this ) { if ( ( count = renewed Tokens Map . get ( tenant ) ) == null ) { renewed Tokens Map . put ( tenant , new Atomic Integer ( NUM_ ) ) ; } else { count . increment And Get ( ) ; } } logger . trace ( STR_ , tenant , renewed Tokens Map . get ( tenant ) ) ; increment Total Renewed ( ) ; } catch ( Exception e ) { logger . error ( STR_ , e ) ; } }
@ Nullable public static String file Md 5 ( @ Nullable File file , @ Nullable Ignite Logger log ) { String md 5 = null ; if ( file != null ) { if ( ! file . is File ( ) ) { U . warn ( log , STR_ + file ) ; return null ; } Input Stream in = null ; try { in = new Buffered Input Stream ( new File Input Stream ( file ) ) ; md 5 = Digest Utils . md 5 Hex ( in ) ; } catch ( IO Exception e ) { U . warn ( log , STR_ + e . get Message ( ) ) ; } finally { U . close Quiet ( in ) ; } } return md 5 ; }
@ Override public void refresh 0 ( int year , int month ) { if ( mode == Constant . MODE CALENDAR ) { selected Year = year ; selected Month = month ; selected Index = - NUM_ ; calendar . set ( Calendar . YEAR , selected Year ) ; calendar . set ( Calendar . MONTH , selected Month - NUM_ ) ; calendar . set ( Calendar . DAY OF MONTH , NUM_ ) ; initial ( ) ; invalidate ( ) ; if ( on Refresh Listener != null ) { on Refresh Listener . on Refresh ( ) ; } } }
public void create Connection Dialog ( ) { user Name Label = new J Label ( STR_ , J Label . RIGHT ) ; user Name Field = new J Text Field ( STR_ ) ; password Label = new J Label ( STR_ , J Label . RIGHT ) ; password Field = new J Text Field ( STR_ ) ; server Label = new J Label ( STR_ , J Label . RIGHT ) ; server Field = new J Text Field ( STR_ ) ; driver Label = new J Label ( STR_ , J Label . RIGHT ) ; driver Field = new J Text Field ( STR_ ) ; connection Panel = new J Panel ( false ) ; connection Panel . set Layout ( new Box Layout ( connection Panel , Box Layout . X AXIS ) ) ; J Panel name Panel = new J Panel ( false ) ; name Panel . set Layout ( new Grid Layout ( NUM_ , NUM_ ) ) ; name Panel . add ( user Name Label ) ; name Panel . add ( password Label ) ; name Panel . add ( server Label ) ; name Panel . add ( driver Label ) ; J Panel field Panel = new J Panel ( false ) ; field Panel . set Layout ( new Grid Layout ( NUM_ , NUM_ ) ) ; field Panel . add ( user Name Field ) ; field Panel . add ( password Field ) ; field Panel . add ( server Field ) ; field Panel . add ( driver Field ) ; connection Panel . add ( name Panel ) ; connection Panel . add ( field Panel ) ; }
@ Suppress Lint ( STR_ ) public void element Type ( String name , int model , int member Of , int flags ) { Element Type e = new Element Type ( name , model , member Of , flags , this ) ; the Element Types . put ( name . to Lower Case ( ) , e ) ; if ( member Of == M ROOT ) the Root = e ; }
public int index Of ( Abstract Option option ) { return options . index Of ( option ) ; }
protected double [ ] probs ( double [ ] Fs ) { double max F = - Double . MAX VALUE ; for ( double element : Fs ) { if ( element > max F ) { max F = element ; } } double sum = NUM_ ; double [ ] probs = new double [ Fs . length ] ; for ( int i = NUM_ ; i < Fs . length ; i ++ ) { probs [ i ] = Math . exp ( Fs [ i ] - max F ) ; sum += probs [ i ] ; } Utils . normalize ( probs , sum ) ; return probs ; }
private void handle Auto Numbers For Add ( Object [ ] row , Write Row State write Row State ) throws IO Exception { if ( auto Num Columns . is Empty ( ) ) { return ; } boolean enable Insert = is Allow Auto Number Insert ( ) ; write Row State . reset Auto Number ( ) ; for ( Column Impl col : auto Num Columns ) { Object in Row Value = get Input Auto Number Row Value ( enable Insert , col , row ) ; Column Impl . Auto Number Generator auto Num Gen = col . get Auto Number Generator ( ) ; Object row Value = ( ( in Row Value == null ) ? auto Num Gen . get Next ( write Row State ) : auto Num Gen . handle Insert ( write Row State , in Row Value ) ) ; col . set Row Value ( row , row Value ) ; } }
public static void unregister M Bean ( Class < ? > mbean Interface , String mbean Name ) { M Bean Server mbs = Management Factory . get Platform M Bean Server ( ) ; try { Object Name name = generate M Bean Object Name ( mbean Interface . get Name ( ) , mbean Name ) ; if ( mbs . is Registered ( name ) ) { logger . info ( STR_ + name . to String ( ) ) ; mbs . unregister M Bean ( name ) ; } else { logger . warn ( STR_ + name . to String ( ) ) ; } } catch ( Exception e ) { throw new Server Runtime Exception ( STR_ + mbean Interface + STR_ + mbean Name , e ) ; } }
public void add Marker ( ) { Cluster Order order = get Cluster Order ( ) ; DBID Selection sel Context = context . get Selection ( ) ; if ( sel Context != null ) { DBI Ds selection = DBID Util . ensure Set ( sel Context . get Selected Ids ( ) ) ; final double width = plotwidth / order . size ( ) ; int begin = - NUM_ , j = NUM_ ; for ( DBID Iter it = order . iter ( ) ; it . valid ( ) ; it . advance ( ) , j ++ ) { if ( selection . contains ( it ) ) { if ( begin == - NUM_ ) { begin = j ; } } else { if ( begin != - NUM_ ) { Element marker = add Marker Rect ( begin * width , ( j - begin ) * width ) ; SVG Util . add CSS Class ( marker , CSS MARKER ) ; mtag . append Child ( marker ) ; begin = - NUM_ ; } } } if ( begin != - NUM_ ) { Element marker = add Marker Rect ( begin * width , ( order . size ( ) - begin ) * width ) ; SVG Util . add CSS Class ( marker , CSS MARKER ) ; mtag . append Child ( marker ) ; } } }
public static double log 1 p ( final double value ) { if ( USE JDK MATH ) { return Math . log 1 p ( value ) ; } if ( value > - NUM_ ) { if ( value == Double . POSITIVE INFINITY ) { return Double . POSITIVE INFINITY ; } final double value Plus One = NUM_ + value ; if ( value Plus One == NUM_ ) { return value ; } else if ( Math . abs ( value ) < NUM_ ) { final double z = value / ( value + NUM_ ) ; final double z 2 = z * z ; return z * ( NUM_ + z 2 * ( NUM_ / NUM_ + z 2 * ( NUM_ / NUM_ + z 2 * ( NUM_ / NUM_ + z 2 * ( NUM_ / NUM_ + z 2 * ( NUM_ / NUM_ ) ) ) ) ) ) ; } final int value Plus One Bits Hi = ( int ) ( Double . double To Raw Long Bits ( value Plus One ) > > NUM_ ) & NUM_ ; final int value Plus One Exp = ( value Plus One Bits Hi > > NUM_ ) - MAX DOUBLE EXPONENT ; final int x Index = value Plus One Bits Hi << NUM_ > > > NUM_ - LOG BITS ; double z = value Plus One * two Pow Normal Or Subnormal ( - value Plus One Exp ) * My T Log . log X Inv Tab [ x Index ] - NUM_ ; z *= NUM_ - z * ( NUM_ / NUM_ - z * ( NUM_ / NUM_ ) ) ; return value Plus One Exp * LOG 2 + My T Log . log X Log Tab [ x Index ] + ( z + ( value - ( value Plus One - NUM_ ) ) / value Plus One ) ; } else if ( value == - NUM_ ) { return Double . NEGATIVE INFINITY ; } else { return Double . Na N ; } }
private void initialise Eigen ( ) { Eval = new double [ state Count ] ; Evec = new double [ state Count ] [ state Count ] ; Ievc = new double [ state Count ] [ state Count ] ; stored Eval = new double [ state Count ] ; stored Evec = new double [ state Count ] [ state Count ] ; stored Ievc = new double [ state Count ] [ state Count ] ; amat = new double [ state Count ] [ state Count ] ; q = new double [ state Count ] [ state Count ] ; ordr = new int [ state Count ] ; evali = new double [ state Count ] ; eigen Initialised = true ; update Matrix = true ; }
public String create Id ( Object cell ) { String id = String . value Of ( next Id ) ; next Id ++ ; return id ; }
private Foreign Key find Corresponding Foreign Key ( Table table , Foreign Key fk ) { for ( int fk Idx = NUM_ ; fk Idx < table . get Foreign Key Count ( ) ; fk Idx ++ ) { Foreign Key cur Fk = table . get Foreign Key ( fk Idx ) ; if ( ( case Sensitive && fk . equals ( cur Fk ) ) || ( ! case Sensitive && fk . equals Ignore Case ( cur Fk ) ) ) { return cur Fk ; } } return null ; }
private static String paragraph To Html ( Paragraph p ) { return content Element To Html ( p , STR_ , STR_ + p . get Type ( ) ) ; }
public void register Popout ( J Dialog popout ) { popouts . put ( popout , null ) ; add Hotkeys ( popout . get Root Pane ( ) ) ; }
public void force DB Requery ( Context context , Runnable callback ) { synchronized ( m TZ Callbacks ) { if ( m TZ Query In Progress ) { m TZ Callbacks . add ( callback ) ; return ; } m First TZ Request = true ; get Time Zone ( context , callback ) ; } }
private void emit Implicit Conversion ( Basic Type ptype , Class < ? > pclass , Object arg ) { assert ( basic Type ( pclass ) == ptype ) ; if ( pclass == ptype . basic Type Class ( ) && ptype != L TYPE ) return ; switch ( ptype ) { case L TYPE : if ( Verify Type . is Null Conversion ( Object . class , pclass , false ) ) { if ( PROFILE LEVEL > NUM_ ) emit Reference Cast ( Object . class , arg ) ; return ; } emit Reference Cast ( pclass , arg ) ; return ; case I TYPE : if ( ! Verify Type . is Null Conversion ( int . class , pclass , false ) ) emit Prim Cast ( ptype . basic Type Wrapper ( ) , Wrapper . for Primitive Type ( pclass ) ) ; return ; } throw new Internal Error ( STR_ + ptype + STR_ + pclass ) ; }
public < T extends Data Object > void purge ( URI id , Class < T > type ) throws Database Exception { T data Obj = db Client . query Object ( type , id ) ; if ( data Obj != null ) { if ( ! data Obj . get Inactive ( ) ) { data Obj . set Inactive ( true ) ; db Client . persist Object ( data Obj ) ; } Set < URI > cleared = new Hash Set < URI > ( ) ; purge ( data Obj , cleared ) ; log . info ( STR_ , type . to String ( ) , id ) ; } }
public static void main ( String [ ] args ) { final Approval Event DTO approval = create Test Approval Event ( ) ; hudson . model . Build Listener listener = new Stream Build Listener ( System . out , Charset . default Charset ( ) ) ; try { Object Mapper mapper = Json Utils . create Object Mapper ( ) ; String json = mapper . write Value As String ( approval ) ; boolean success = Elasticsearch Client . update Event ( STR_ , json , Elasticsearch Client . APPROVE , listener ) ; assert True ( success ) ; } catch ( Exception e ) { LOG . log ( Level . SEVERE , STR_ + approval , e ) ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( ! ( obj instanceof Custom XYURL Generator ) ) { return false ; } Custom XYURL Generator that = ( Custom XYURL Generator ) obj ; int list Count = get List Count ( ) ; if ( list Count != that . get List Count ( ) ) { return false ; } for ( int series = NUM_ ; series < list Count ; series ++ ) { int url Count = get URL Count ( series ) ; if ( url Count != that . get URL Count ( series ) ) { return false ; } for ( int item = NUM_ ; item < url Count ; item ++ ) { String u 1 = get URL ( series , item ) ; String u 2 = that . get URL ( series , item ) ; if ( u 1 != null ) { if ( ! u 1 . equals ( u 2 ) ) { return false ; } } else { if ( u 2 != null ) { return false ; } } } } return true ; }
public static Compute State provision Machine ( Verification Host host , URI peer URI , Compute State vm State , boolean is Mock , List < String > instances To Clean Up ) throws Throwable , Interrupted Exception , Timeout Exception { host . log ( STR_ ) ; Provision Compute Task State provision Task = new Provision Compute Task Service . Provision Compute Task State ( ) ; provision Task . compute Link = vm State . document Self Link ; provision Task . is Mock Request = is Mock ; provision Task . task Sub Stage = Provision Compute Task State . Sub Stage . CREATING HOST ; Provision Compute Task Service . Provision Compute Task State out Task = Test Utils . do Post ( host , provision Task , Provision Compute Task State . class , create Service URI ( host , peer URI , Provision Compute Task Service . FACTORY LINK ) ) ; host . wait For Finished Task ( Provision Compute Task State . class , out Task . document Self Link ) ; Compute State provision Compute = get Compute ( host , vm State . document Self Link ) ; assert Not Null ( provision Compute ) ; host . log ( STR_ , provision Compute . id ) ; instances To Clean Up . add ( provision Compute . id ) ; return provision Compute ; }
@ Override public List refresh Ticks ( Graphics 2 D g 2 , Axis State state , Rectangle 2 D data Area , Rectangle Edge edge ) { List ticks = null ; if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { ticks = refresh Ticks Horizontal ( g 2 , data Area , edge ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { ticks = refresh Ticks Vertical ( g 2 , data Area , edge ) ; } return ticks ; }
public static void allow Item For Recycling ( Object stack ) { recycling Allowed . add ( Api Utils . convert To Valid Recipe Input ( stack ) ) ; }
public static < C extends Configuration Client , S extends Configuration > Create Sub Command Handler < C , S > create ( Sub Command Argument Parser parser , Managed Object Path < ? , ? > p , Instantiable Relation Definition < C , S > r ) throws Argument Exception { return new Create Sub Command Handler < > ( parser , p , r , r . get Naming Property Definition ( ) , p . child ( r , STR_ ) ) ; }
public void execute ( ) throws Exception { execute ( true , true ) ; }
public void process Property ( CIM Property < ? > p ) { process Property ( STR_ , p ) ; }
final public void compute Time Limit ( Search Params s Par ) { min Time Limit = - NUM_ ; max Time Limit = - NUM_ ; max Depth = - NUM_ ; max Nodes = - NUM_ ; if ( s Par . infinite ) { min Time Limit = - NUM_ ; max Time Limit = - NUM_ ; max Depth = - NUM_ ; } else if ( s Par . depth > NUM_ ) { max Depth = s Par . depth ; } else if ( s Par . mate > NUM_ ) { max Depth = s Par . mate * NUM_ - NUM_ ; } else if ( s Par . move Time > NUM_ ) { min Time Limit = max Time Limit = s Par . move Time ; } else if ( s Par . nodes > NUM_ ) { max Nodes = s Par . nodes ; } else { int moves = s Par . moves To Go ; if ( moves == NUM_ ) { moves = NUM_ ; } moves = Math . min ( moves , NUM_ ) ; if ( ponder Mode ) { final double ponder Hit Rate = NUM_ ; moves = ( int ) Math . ceil ( moves * ( NUM_ - ponder Hit Rate ) ) ; } boolean white = pos . white Move ; int time = white ? s Par . w Time : s Par . b Time ; int inc = white ? s Par . w Inc : s Par . b Inc ; final int margin = Math . min ( NUM_ , time * NUM_ / NUM_ ) ; int time Limit = ( time + inc * ( moves - NUM_ ) - margin ) / moves ; min Time Limit = ( int ) ( time Limit * NUM_ ) ; max Time Limit = ( int ) ( min Time Limit * ( Math . max ( NUM_ , Math . min ( NUM_ , moves / NUM_ ) ) ) ) ; min Time Limit = clamp ( min Time Limit , NUM_ , time - margin ) ; max Time Limit = clamp ( max Time Limit , NUM_ , time - margin ) ; } }
public Tv Show Update Datasource Task 2 ( String datasource ) { super ( BUNDLE . get String ( STR_ ) + STR_ + datasource + STR_ ) ; tv Show List = Tv Show List . get Instance ( ) ; data Sources = new Array List < > ( NUM_ ) ; data Sources . add ( datasource ) ; }
void close Unclosed Nodes ( ) { if ( needs Debug Data ) { for ( Node node : unpopped Elements ) { Nodes . set File Position For ( node , File Position . span ( Nodes . get File Position For ( node ) , end Tok . pos ) ) ; } } unpopped Elements . clear ( ) ; }
void prime Fnc Name ( Session s , int line ) { prime All Fnc Names ( s ) ; }
protected void write Flot ( final Writer w , final I Event Reporting Service event Reporting Service ) throws IO Exception { write Resource ( w , STR_ ) ; write Events ( w , event Reporting Service ) ; write Resource ( w , STR_ ) ; }
public static double weighted Coefficient ( Number Vector x , Number Vector y , double [ ] weights ) { final int xdim = x . get Dimensionality ( ) ; final int ydim = y . get Dimensionality ( ) ; if ( xdim != ydim ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( xdim != weights . length ) { throw new Illegal Argument Exception ( STR_ ) ; } double sum XX = NUM_ , sum YY = NUM_ , sum XY = NUM_ , sum We = weights [ NUM_ ] ; double mean X = x . double Value ( NUM_ ) , mean Y = y . double Value ( NUM_ ) ; for ( int i = NUM_ ; i < xdim ; ++ i ) { final double xv = x . double Value ( i ) , yv = y . double Value ( i ) , w = weights [ i ] ; final double delta X = xv - mean X ; final double delta Y = yv - mean Y ; sum We += w ; mean X += delta X * w / sum We ; mean Y += delta Y * w / sum We ; final double nelta X = xv - mean X ; final double nelta Y = yv - mean Y ; sum XX += w * delta X * nelta X ; sum YY += w * delta Y * nelta Y ; sum XY += w * delta X * nelta Y ; } if ( ! ( sum XX > NUM_ && sum YY > NUM_ ) ) { return ( sum XX == sum YY ) ? NUM_ : NUM_ ; } return sum XY / Math . sqrt ( sum XX * sum YY ) ; }
private Pair < Float , Float > calculate Start End Angles ( Point point To , float radius , int left , int top , int right , int bottom ) { Rect circle Rect = new Rect ( ( point To . x - ( int ) radius ) , ( point To . y - ( int ) radius ) , ( point To . x + ( int ) radius ) , ( point To . y + ( int ) radius ) ) ; Rect screen Rect = new Rect ( left , top , right , bottom ) ; List < Quadrant > quadrants = find Containing Quadrants ( circle Rect , screen Rect ) ; float min Angle = Float . MAX VALUE , max Angle = Float . MIN VALUE ; if ( quadrants . contains ( Quadrant . IV ) && quadrants . contains ( Quadrant . I ) && quadrants . size ( ) == NUM_ ) { min Angle = ( float ) ( - Math . PI / NUM_ ) ; max Angle = ( float ) ( Math . PI / NUM_ ) ; } else { if ( quadrants . size ( ) < NUM_ ) { for ( Quadrant quadrant : quadrants ) { double angle 2 = ( quadrant . get Start Angle ( ) ) ; min Angle = ( float ) Math . min ( min Angle , angle 2 ) ; double angle 4 = ( quadrant . get End Angle ( ) ) ; max Angle = ( float ) Math . max ( max Angle , angle 4 ) ; } } else { min Angle = ( float ) Math . PI ; max Angle = ( float ) ( Math . PI * NUM_ ) ; } } return new Pair < > ( min Angle , max Angle ) ; }
protected void random Initialization ( double [ ] out , Random rnd ) { double l 2 = NUM_ ; while ( ! ( l 2 > NUM_ ) ) { for ( int d = NUM_ ; d < out . length ; d ++ ) { final double val = rnd . next Double ( ) ; out [ d ] = val ; l 2 += val * val ; } } if ( ! ( l 2 > NUM_ ) ) { random Initialization ( out , rnd ) ; return ; } final double s = NUM_ / Math . sqrt ( l 2 ) ; for ( int d = NUM_ ; d < out . length ; d ++ ) { out [ d ] *= s ; } }
void register Notification Listener ( Object Name source ) throws Instance Not Found Exception { m Bean Server . add Notification Listener ( source , this , null , source ) ; }
private void calculate Fitness ( T c ) { for ( Fitness Function < T > fitness Function : this . uncovered Goals ) { fitness Function . get Fitness ( c ) ; } notify Evaluation ( c ) ; }
protected static void append String Type ( String Builder sb ) { sb . append ( STR_ ) ; }
public void solve ( ) { if ( a == NUM_ && b == NUM_ ) values ( ) ; else if ( a == NUM_ && b != NUM_ ) values ( linear ( b , c ) ) ; else if ( a != NUM_ && c == NUM_ ) values ( NUM_ , linear ( a , b ) ) ; else { double d = b * b - NUM_ * a * c ; if ( d < NUM_ ) values ( ) ; else if ( d == NUM_ ) values ( - b / ( NUM_ * a ) ) ; else values ( ( - b + Math . sqrt ( d ) ) / ( NUM_ * a ) , ( - b - Math . sqrt ( d ) ) / ( NUM_ * a ) ) ; } }
protected boolean [ ] can Predict ( boolean nominal Predictor , boolean numeric Predictor , boolean string Predictor , boolean date Predictor , boolean relational Predictor , boolean multi Instance , int class Type ) { print ( STR_ ) ; print Attribute Summary ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type ) ; print ( STR_ ) ; Array List < String > accepts = new Array List < String > ( ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; accepts . add ( STR_ ) ; int num Train = get Num Instances ( ) , num Test = get Num Instances ( ) , num Classes = NUM_ , missing Level = NUM_ ; boolean predictor Missing = false , class Missing = false ; return run Basic Test ( nominal Predictor , numeric Predictor , string Predictor , date Predictor , relational Predictor , multi Instance , class Type , missing Level , predictor Missing , class Missing , num Train , num Test , num Classes , accepts ) ; }
public boolean is Volatile ( ) { return Modifier . is Volatile ( flags ) ; }
public Properties add Genome ( String genome , String sex ) { final Properties props = add Genome ( genome ) ; if ( sex != null ) { props . put ( SEX PROPERTY , sex ) ; } return props ; }
private void gen Table ( String table Name , String where Clause , boolean complete XML , Properties ctx , Web Info wi ) { String l sz Trx Name = null ; String Buffer tmp Code = new String Buffer ( ) ; String data Table Name = table Name ; String l where Clause = replace Session Elements ( wi , where Clause ) ; tmp Code . append ( STR_ + table Name + STR_ ) ; if ( where Clause . index Of ( STR_ ) > - NUM_ ) { data Table Name = STR_ ; } int [ ] l n I Ds = PO . get All I Ds ( data Table Name , l where Clause , l sz Trx Name ) ; int [ ] l n Table I Ds = M Table . get All I Ds ( STR_ , STR_ + data Table Name + STR_ , l sz Trx Name ) ; if ( l n Table I Ds . length > NUM_ ) { M Table table = M Table . get ( ctx , l n Table I Ds [ NUM_ ] ) ; PO l Object = null ; if ( complete XML ) { for ( int i = NUM_ ; i < l n I Ds . length ; i ++ ) { l Object = table . get PO ( l n I Ds [ i ] , l sz Trx Name ) ; l Object . get xml String ( tmp Code ) ; } } else { String sql = M Lookup Factory . get Lookup Table Dir Embed ( Language . get Language ( STR_ ) , data Table Name + STR_ , data Table Name ) ; sql = sql . concat ( STR_ + l where Clause ) ; Prepared Statement pstm = DB . prepare Statement ( sql , l sz Trx Name ) ; Result Set rs = null ; try { rs = pstm . execute Query ( ) ; } catch ( Exception e ) { } for ( int i = NUM_ ; i < l n I Ds . length ; i ++ ) { l Object = table . get PO ( l n I Ds [ i ] , l sz Trx Name ) ; tmp Code . append ( STR_ + data Table Name + STR_ + table . get ID ( ) + STR_ + l Object . get ID ( ) + STR_ ) ; tmp Code . append ( STR_ + data Table Name + STR_ ) ; tmp Code . append ( l Object . get ID ( ) ) ; tmp Code . append ( STR_ + data Table Name + STR_ ) ; if ( data Table Name . equals ( STR_ ) ) { tmp Code . append ( STR_ ) ; tmp Code . append ( STR_ + l Object . get Value ( STR_ ) + STR_ ) ; tmp Code . append ( STR_ ) ; } if ( data Table Name . equals ( STR_ ) || data Table Name . equals ( STR_ ) ) { tmp Code . append ( STR_ ) ; tmp Code . append ( l Object . get Value ( STR_ ) ) ; tmp Code . append ( STR_ ) ; } tmp Code . append ( STR_ ) ; try { if ( rs . next ( ) ) { tmp Code . append ( STR_ + rs . get String ( NUM_ ) + STR_ ) ; } } catch ( SQL Exception e ) { tmp Code . append ( STR_ + e . get Message ( ) + STR_ ) ; } tmp Code . append ( STR_ ) ; tmp Code . append ( STR_ + data Table Name + STR_ ) ; } try { rs . close ( ) ; pstm . close ( ) ; } catch ( Exception e ) { } } } tmp Code . append ( STR_ + table Name + STR_ ) ; xml Code . append ( tmp Code ) ; }
protected Map < Object , Object > create Attribute Map ( ) { return Collections . synchronized Map ( new Linked Hash Map < Object , Object > ( ) ) ; }
public void fill Default Values ( ) { tf Learning Rate . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT LEARNING RATE ) ) ; tf M . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT M ) ) ; tf Theta . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT THETA ) ) ; tf Lambda . set Text ( Double . to String ( Hebbian CPCA Rule . DEFAULT LAMBDA ) ) ; }
public void add Expansion Listener ( Explorer Expansion Listener listener ) { expansion Listeners . add ( listener ) ; }
public Worker Log Level Overrides add Override For Name ( String name , Level level ) { check Not Null ( name , STR_ ) ; check Not Null ( level , STR_ , Arrays . to String ( Level . values ( ) ) ) ; put ( name , level ) ; return this ; }
public void draw Highlight ( Graphics g , int w , int h ) { draw Node ( g , w , h ) ; g . set Color ( Color . yellow ) ; g . fill Oval ( ( int ) ( m x * w ) - NUM_ , ( int ) ( m y * h ) - NUM_ , NUM_ , NUM_ ) ; }
protected static double sparsity ( final int setsize , final int dbsize , final int k , final double phi ) { final double f = NUM_ / phi ; final double f K = Math Util . powi ( f , k ) ; final double s C = ( setsize - ( dbsize * f K ) ) / Math . sqrt ( dbsize * f K * ( NUM_ - f K ) ) ; return s C ; }
private boolean check Select For Swipe ( int action , Motion Event motion Event , int pointer Index ) { if ( m Selected != null || action != Motion Event . ACTION MOVE || m Action State == ACTION STATE DRAG || ! m Callback . is Item View Swipe Enabled ( ) ) { return false ; } if ( m Recycler View . get Scroll State ( ) == Recycler View . SCROLL STATE DRAGGING ) { return false ; } final View Holder vh = find Swiped View ( motion Event ) ; if ( vh == null ) { return false ; } final int movement Flags = m Callback . get Absolute Movement Flags ( m Recycler View , vh ) ; final int swipe Flags = ( movement Flags & ACTION MODE SWIPE MASK ) > > ( DIRECTION FLAG COUNT * ACTION STATE SWIPE ) ; if ( swipe Flags == NUM_ ) { return false ; } final float x = Motion Event Compat . get X ( motion Event , pointer Index ) ; final float y = Motion Event Compat . get Y ( motion Event , pointer Index ) ; final float dx = x - m Initial Touch X ; final float dy = y - m Initial Touch Y ; final float abs Dx = Math . abs ( dx ) ; final float abs Dy = Math . abs ( dy ) ; if ( abs Dx < m Slop && abs Dy < m Slop ) { return false ; } if ( abs Dx > abs Dy ) { if ( dx < NUM_ && ( swipe Flags & LEFT ) == NUM_ ) { return false ; } if ( dx > NUM_ && ( swipe Flags & RIGHT ) == NUM_ ) { return false ; } } else { if ( dy < NUM_ && ( swipe Flags & UP ) == NUM_ ) { return false ; } if ( dy > NUM_ && ( swipe Flags & DOWN ) == NUM_ ) { return false ; } } m Dx = m Dy = NUM_ ; m Active Pointer Id = Motion Event Compat . get Pointer Id ( motion Event , NUM_ ) ; select ( vh , ACTION STATE SWIPE ) ; if ( m Pre Opened != null && m Pre Opened != vh && vh != null ) { close Opened Pre Item ( ) ; } return true ; }
public boolean invalidate Token ( final String user Id ) { credentials Store Lock . lock ( ) ; try { return credentials Store . remove ( user Id ) != null ; } finally { credentials Store Lock . unlock ( ) ; } }
public static boolean nodes Equal ( Node this Node , Node other Node ) { if ( this Node == other Node ) { return true ; } if ( this Node . get Node Type ( ) != other Node . get Node Type ( ) ) { return false ; } return true ; }
protected Set < Named Related Resource Rep > convert ITL List To Related Resource Rest Reps ( List < ITL Rest Rep > exports ) { Set < Named Related Resource Rep > related Rest Reps = Sets . new Hash Set ( ) ; for ( ITL Rest Rep export : exports ) { related Rest Reps . add ( export . get Export ( ) ) ; } return related Rest Reps ; }
public int read Unsigned Byte LE ( ) throws IO Exception { return input Stream . read Unsigned Byte ( ) ; }
public void compute Layer ( ) { do Prepare ( ) ; }
public boolean rsp Outgoing ( ) { if ( logger . trace On ( ) ) { logger . trace ( STR_ , STR_ ) ; } synchronized ( lock ) { if ( -- current Jobs == NUM_ ) { timestamp = System . current Time Millis ( ) ; logtime ( STR_ , timestamp ) ; lock . notify ( ) ; } return terminated ; } }
public boolean snapshot Disable Image Access Single Step ( URI rp System Id , List < URI > snapshots , boolean is Rollback , String token ) throws Controller Exception { try { Workflow Step Completer . step Executing ( token ) ; boolean set Snapshot Sync Active = true ; disable Image For Snapshots ( rp System Id , snapshots , is Rollback , set Snapshot Sync Active , token ) ; Workflow Step Completer . step Succeded ( token ) ; } catch ( Exception e ) { log . error ( String . format ( STR_ , String . value Of ( rp System Id ) ) ) ; return step Failed ( token , e , STR_ ) ; } return true ; }
public static Iterable < Visor Igfs Configuration > list ( File System Configuration [ ] igfss ) { if ( igfss == null ) return Collections . empty List ( ) ; final Collection < Visor Igfs Configuration > cfgs = new Array List < > ( igfss . length ) ; for ( File System Configuration igfs : igfss ) cfgs . add ( from ( igfs ) ) ; return cfgs ; }
public void contract ( ) { final double [ ] temp Array = new double [ num Elements + NUM_ ] ; System . arraycopy ( internal Array , start Index , temp Array , NUM_ , num Elements ) ; internal Array = temp Array ; start Index = NUM_ ; }
private void create Context Menu ( ) { context Menu = new J Popup Menu ( ) ; context Menu . add ( action Manager . get New Network Action ( ) ) ; J Menu new Gauge Sub Menu = new J Menu ( STR_ ) ; for ( Action action : action Manager . get Plot Actions ( ) ) { new Gauge Sub Menu . add ( action ) ; } context Menu . add ( new Gauge Sub Menu ) ; J Menu new World Sub Menu = new J Menu ( STR_ ) ; for ( Action action : action Manager . get New World Actions ( ) ) { new World Sub Menu . add ( action ) ; } context Menu . add ( new World Sub Menu ) ; context Menu . add Separator ( ) ; context Menu . add ( action Manager . get New Doc Viewer Action ( ) ) ; context Menu . add ( action Manager . get New Console Action ( ) ) ; }
public static Workspace Component deserialize Workspace Component ( final Class < ? > clazz , final String name , final Input Stream input , final String format ) { try { Method method = clazz . get Method ( STR_ , Input Stream . class , String . class , String . class ) ; Workspace Component wc = ( Workspace Component ) method . invoke ( null , input , name , format ) ; wc . set Changed Since Last Save ( false ) ; return wc ; } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
public static String generate Separate Attributes Class ( final Class < ? > target Class , Package package Of Attributes Class ) { return generate Attributes For Class ( target Class , true , package Of Attributes Class . get Name ( ) ) ; }
public void add Suppress Annotation ( Class < ? extends Annotation > anno ) { suppress Annotations . add ( anno . get Name ( ) ) ; }
@ Suppress Warnings ( STR_ ) public Ignite Internal Future < ? > rebuild All Indexes ( ) { if ( ! busy Lock . enter Busy ( ) ) throw new Illegal State Exception ( STR_ ) ; try { Grid Compound Future < ? , ? > fut = new Grid Compound Future < Object , Object > ( ) ; for ( Map . Entry < Type Id , Type Descriptor > e : types . entry Set ( ) ) fut . add ( ( Ignite Internal Future ) rebuild Indexes ( e . get Key ( ) . space , e . get Value ( ) ) ) ; fut . mark Initialized ( ) ; return fut ; } finally { busy Lock . leave Busy ( ) ; } }
private String post RP Change Vpool Steps ( Workflow workflow , String wait For , List < Volume Descriptor > volume Descriptors , String task Id ) { List < Volume Descriptor > rp Volume Descriptors = Volume Descriptor . filter By Type ( volume Descriptors , new Volume Descriptor . Type [ ] { Volume Descriptor . Type . RP EXISTING SOURCE } , null ) ; if ( rp Volume Descriptors . is Empty ( ) ) { return wait For ; } List < Volume Descriptor > migrated Block Data Descriptors = new Array List < Volume Descriptor > ( ) ; List < URI > volumes With Migration = new Array List < URI > ( ) ; if ( volume Descriptors != null ) { List < Volume Descriptor > migrate Descriptors = Volume Descriptor . filter By Type ( volume Descriptors , new Volume Descriptor . Type [ ] { Volume Descriptor . Type . VPLEX MIGRATE VOLUME } , null ) ; if ( migrate Descriptors != null && ! migrate Descriptors . is Empty ( ) ) { s logger . info ( STR_ ) ; Iterator < Volume Descriptor > migration Iter = migrate Descriptors . iterator ( ) ; while ( migration Iter . has Next ( ) ) { Volume Descriptor migration Desc = migration Iter . next ( ) ; Migration migration = s db Client . query Object ( Migration . class , migration Desc . get Migration Id ( ) ) ; volumes With Migration . add ( migration . get Source ( ) ) ; Volume migrated Volume = s db Client . query Object ( Volume . class , migration . get Volume ( ) ) ; Volume Descriptor migrated Block Data Desc = new Volume Descriptor ( Volume Descriptor . Type . BLOCK DATA , migrated Volume . get Storage Controller ( ) , migrated Volume . get Id ( ) , null , migrated Volume . get Consistency Group ( ) , migration Desc . get Capabilities Values ( ) ) ; migrated Block Data Descriptors . add ( migrated Block Data Desc ) ; } } } List < Volume Descriptor > block Data Descriptors = new Array List < Volume Descriptor > ( ) ; for ( Volume Descriptor descr : rp Volume Descriptors ) { Volume rp Existing Source = s db Client . query Object ( Volume . class , descr . get Volume URI ( ) ) ; if ( RP Helper . is V Plex Volume ( rp Existing Source , s db Client ) ) { s logger . info ( String . format ( STR_ , rp Existing Source . get Label ( ) ) ) ; if ( null != rp Existing Source . get Associated Volumes ( ) ) { for ( String assoc Volume Id : rp Existing Source . get Associated Volumes ( ) ) { Volume assoc Volume = s db Client . query Object ( Volume . class , URI . create ( assoc Volume Id ) ) ; if ( volumes With Migration . contains ( assoc Volume . get Id ( ) ) ) { s logger . info ( String . format ( STR_ , assoc Volume . get Label ( ) ) ) ; continue ; } if ( Null Column Value Getter . is Not Null Value ( assoc Volume . get Replication Group Instance ( ) ) ) { Volume Descriptor block Data Desc = new Volume Descriptor ( Volume Descriptor . Type . BLOCK DATA , assoc Volume . get Storage Controller ( ) , assoc Volume . get Id ( ) , null , rp Existing Source . get Consistency Group ( ) , descr . get Capabilities Values ( ) ) ; block Data Descriptors . add ( block Data Desc ) ; assoc Volume . set Consistency Group ( rp Existing Source . get Consistency Group ( ) ) ; s db Client . update Object ( assoc Volume ) ; s logger . info ( String . format ( STR_ , assoc Volume . get Label ( ) , rp Existing Source . get Consistency Group ( ) , assoc Volume . get Storage Controller ( ) ) ) ; } } } } } if ( ! block Data Descriptors . is Empty ( ) ) { wait For = block Device Controller . add Steps For Create Consistency Group ( workflow , wait For , block Data Descriptors , STR_ ) ; wait For = block Device Controller . add Steps For Update Consistency Group ( workflow , wait For , block Data Descriptors , null ) ; } block Data Descriptors . add All ( migrated Block Data Descriptors ) ; s logger . info ( STR_ ) ; wait For = replica Device Controller . add Steps For Create Volumes ( workflow , wait For , block Data Descriptors , task Id ) ; return wait For ; }
public static svm model svm train ( svm problem prob , svm parameter param , Operator executing Operator ) throws Process Stopped Exception { svm model model = new svm model ( ) ; model . param = param ; if ( param . svm type == svm parameter . ONE CLASS || param . svm type == svm parameter . EPSILON SVR || param . svm type == svm parameter . NU SVR ) { model . nr class = NUM_ ; model . label = null ; model . n SV = null ; model . prob A = null ; model . prob B = null ; model . sv coef = new double [ NUM_ ] [ ] ; if ( param . probability == NUM_ && ( param . svm type == svm parameter . EPSILON SVR || param . svm type == svm parameter . NU SVR ) ) { model . prob A = new double [ NUM_ ] ; model . prob A [ NUM_ ] = svm svr probability ( prob , param ) ; if ( executing Operator != null ) { executing Operator . check For Stop ( ) ; } } decision function f = svm train one ( prob , param , NUM_ , NUM_ ) ; model . rho = new double [ NUM_ ] ; model . rho [ NUM_ ] = f . rho ; int n SV = NUM_ ; int i ; for ( i = NUM_ ; i < prob . l ; i ++ ) { if ( Math . abs ( f . alpha [ i ] ) > NUM_ ) { ++ n SV ; } } model . l = n SV ; model . SV = new svm node [ n SV ] [ ] ; model . sv coef [ NUM_ ] = new double [ n SV ] ; model . label Values = new double [ n SV ] ; int j = NUM_ ; for ( i = NUM_ ; i < prob . l ; i ++ ) { if ( Math . abs ( f . alpha [ i ] ) > NUM_ ) { model . SV [ j ] = prob . x [ i ] ; model . sv coef [ NUM_ ] [ j ] = f . alpha [ i ] ; model . label Values [ j ] = prob . y [ i ] ; ++ j ; } } } else { int l = prob . l ; int [ ] tmp nr class = new int [ NUM_ ] ; int [ ] [ ] tmp label = new int [ NUM_ ] [ ] ; int [ ] [ ] tmp start = new int [ NUM_ ] [ ] ; int [ ] [ ] tmp count = new int [ NUM_ ] [ ] ; int [ ] perm = new int [ l ] ; if ( executing Operator != null ) { executing Operator . check For Stop ( ) ; } svm group classes ( prob , tmp nr class , tmp label , tmp start , tmp count , perm ) ; if ( executing Operator != null ) { executing Operator . check For Stop ( ) ; } int nr class = tmp nr class [ NUM_ ] ; int [ ] label = tmp label [ NUM_ ] ; int [ ] start = tmp start [ NUM_ ] ; int [ ] count = tmp count [ NUM_ ] ; svm node [ ] [ ] x = new svm node [ l ] [ ] ; int i ; for ( i = NUM_ ; i < l ; i ++ ) { x [ i ] = prob . x [ perm [ i ] ] ; } double [ ] weighted C = new double [ nr class ] ; for ( i = NUM_ ; i < nr class ; i ++ ) { weighted C [ i ] = param . C ; } for ( i = NUM_ ; i < param . nr weight ; i ++ ) { int j ; for ( j = NUM_ ; j < nr class ; j ++ ) { if ( param . weight label [ i ] == label [ j ] ) { break ; } } if ( j != nr class ) { weighted C [ j ] *= param . weight [ i ] ; } } boolean [ ] nonzero = new boolean [ l ] ; for ( i = NUM_ ; i < l ; i ++ ) { nonzero [ i ] = false ; } decision function [ ] f = new decision function [ nr class * ( nr class - NUM_ ) / NUM_ ] ; double [ ] prob A = null , prob B = null ; if ( param . probability == NUM_ ) { prob A = new double [ nr class * ( nr class - NUM_ ) / NUM_ ] ; prob B = new double [ nr class * ( nr class - NUM_ ) / NUM_ ] ; } int p = NUM_ ; for ( i = NUM_ ; i < nr class ; i ++ ) { if ( executing Operator != null ) { executing Operator . check For Stop ( ) ; } for ( int j = i + NUM_ ; j < nr class ; j ++ ) { svm problem sub prob = new svm problem ( ) ; int si = start [ i ] , sj = start [ j ] ; int ci = count [ i ] , cj = count [ j ] ; sub prob . l = ci + cj ; sub prob . x = new svm node [ sub prob . l ] [ ] ; sub prob . y = new double [ sub prob . l ] ; int k ; for ( k = NUM_ ; k < ci ; k ++ ) { sub prob . x [ k ] = x [ si + k ] ; sub prob . y [ k ] = + NUM_ ; } for ( k = NUM_ ; k < cj ; k ++ ) { sub prob . x [ ci + k ] = x [ sj + k ] ; sub prob . y [ ci + k ] = - NUM_ ; } if ( param . probability == NUM_ ) { double [ ] prob AB = new double [ NUM_ ] ; svm binary svc probability ( sub prob , param , weighted C [ i ] , weighted C [ j ] , prob AB ) ; prob A [ p ] = prob AB [ NUM_ ] ; prob B [ p ] = prob AB [ NUM_ ] ; } if ( executing Operator != null ) { executing Operator . check For Stop ( ) ; } f [ p ] = svm train one ( sub prob , param , weighted C [ i ] , weighted C [ j ] , executing Operator ) ; if ( executing Operator != null ) { executing Operator . check For Stop ( ) ; } for ( k = NUM_ ; k < ci ; k ++ ) { if ( ! nonzero [ si + k ] && Math . abs ( f [ p ] . alpha [ k ] ) > NUM_ ) { nonzero [ si + k ] = true ; } } for ( k = NUM_ ; k < cj ; k ++ ) { if ( ! nonzero [ sj + k ] && Math . abs ( f [ p ] . alpha [ ci + k ] ) > NUM_ ) { nonzero [ sj + k ] = true ; } } ++ p ; } } model . nr class = nr class ; model . label = new int [ nr class ] ; for ( i = NUM_ ; i < nr class ; i ++ ) { model . label [ i ] = label [ i ] ; } model . rho = new double [ nr class * ( nr class - NUM_ ) / NUM_ ] ; for ( i = NUM_ ; i < nr class * ( nr class - NUM_ ) / NUM_ ; i ++ ) { model . rho [ i ] = f [ i ] . rho ; } if ( param . probability == NUM_ ) { model . prob A = new double [ nr class * ( nr class - NUM_ ) / NUM_ ] ; model . prob B = new double [ nr class * ( nr class - NUM_ ) / NUM_ ] ; for ( i = NUM_ ; i < nr class * ( nr class - NUM_ ) / NUM_ ; i ++ ) { model . prob A [ i ] = prob A [ i ] ; model . prob B [ i ] = prob B [ i ] ; } } else { model . prob A = null ; model . prob B = null ; } if ( executing Operator != null ) { executing Operator . check For Stop ( ) ; } int nnz = NUM_ ; int [ ] nz count = new int [ nr class ] ; model . n SV = new int [ nr class ] ; for ( i = NUM_ ; i < nr class ; i ++ ) { int n SV = NUM_ ; for ( int j = NUM_ ; j < count [ i ] ; j ++ ) { if ( nonzero [ start [ i ] + j ] ) { ++ n SV ; ++ nnz ; } } model . n SV [ i ] = n SV ; nz count [ i ] = n SV ; } model . l = nnz ; model . SV = new svm node [ nnz ] [ ] ; model . label Values = new double [ nnz ] ; p = NUM_ ; for ( i = NUM_ ; i < l ; i ++ ) { if ( nonzero [ i ] ) { model . SV [ p ] = x [ i ] ; model . label Values [ p ] = prob . y [ i ] ; p ++ ; } } int [ ] nz start = new int [ nr class ] ; nz start [ NUM_ ] = NUM_ ; for ( i = NUM_ ; i < nr class ; i ++ ) { nz start [ i ] = nz start [ i - NUM_ ] + nz count [ i - NUM_ ] ; } model . sv coef = new double [ nr class - NUM_ ] [ ] ; for ( i = NUM_ ; i < nr class - NUM_ ; i ++ ) { model . sv coef [ i ] = new double [ nnz ] ; } p = NUM_ ; for ( i = NUM_ ; i < nr class ; i ++ ) { if ( executing Operator != null ) { executing Operator . check For Stop ( ) ; } for ( int j = i + NUM_ ; j < nr class ; j ++ ) { int si = start [ i ] ; int sj = start [ j ] ; int ci = count [ i ] ; int cj = count [ j ] ; int q = nz start [ i ] ; int k ; for ( k = NUM_ ; k < ci ; k ++ ) { if ( nonzero [ si + k ] ) { model . sv coef [ j - NUM_ ] [ q ++ ] = f [ p ] . alpha [ k ] ; } } q = nz start [ j ] ; for ( k = NUM_ ; k < cj ; k ++ ) { if ( nonzero [ sj + k ] ) { model . sv coef [ i ] [ q ++ ] = f [ p ] . alpha [ ci + k ] ; } } ++ p ; } } } return model ; }
public static void load ( Input Stream stream , Object holder ) { handle ( Config Factory . parse Reader ( new Input Stream Reader ( stream ) ) , holder , STR_ ) ; }
public static void assert Chi Square Accept ( String [ ] value Labels , double [ ] expected , long [ ] observed , double alpha ) { if ( chi Square Test ( expected , observed ) <= alpha ) { String Builder msg Buffer = new String Builder ( ) ; Decimal Format df = new Decimal Format ( STR_ ) ; msg Buffer . append ( STR_ ) ; msg Buffer . append ( STR_ ) ; msg Buffer . append ( chi Square Test ( expected , observed ) ) ; msg Buffer . append ( STR_ ) ; msg Buffer . append ( chi Square ( expected , observed ) ) ; msg Buffer . append ( STR_ ) ; msg Buffer . append ( STR_ ) ; for ( int i = NUM_ ; i < expected . length ; i ++ ) { msg Buffer . append ( value Labels [ i ] ) ; msg Buffer . append ( STR_ ) ; msg Buffer . append ( df . format ( expected [ i ] ) ) ; msg Buffer . append ( STR_ ) ; msg Buffer . append ( observed [ i ] ) ; msg Buffer . append ( STR_ ) ; } msg Buffer . append ( STR_ ) ; msg Buffer . append ( alpha ) ; msg Buffer . append ( STR_ ) ; Assert . fail ( msg Buffer . to String ( ) ) ; } }
private Set < T > convert Results ( Collection < Token > tokens ) { Set < T > results = new Hash Set < T > ( ) ; for ( Token token : tokens ) { results . add ( adapter . from Token ( token ) ) ; } return results ; }
private List < Roster Entry > find Matching Entries ( Roster Comparator c ) { List < Roster Entry > l = new Array List < > ( ) ; for ( Roster Entry r : list ) { if ( c . check ( r ) ) { l . add ( r ) ; } } return l ; }
public static double [ ] rank ( Example Set e Set , Attribute att , Attribute mapping Att ) { return rank ( e Set , att , mapping Att , NUM_ ) ; }
void create Vao ( ) { vao = gl Gen Vertex Arrays ( ) ; int vbo = gl Gen Buffers ( ) ; gl Bind Vertex Array ( vao ) ; gl Bind Buffer ( GL ARRAY BUFFER , vbo ) ; Byte Buffer bb = Buffer Utils . create Byte Buffer ( boxes . length * NUM_ * ( NUM_ + NUM_ ) * NUM_ * NUM_ ) ; Float Buffer fv = bb . as Float Buffer ( ) ; for ( int i = NUM_ ; i < boxes . length ; i += NUM_ ) { Demo Utils . triangulate Box ( boxes [ i ] , boxes [ i + NUM_ ] , fv ) ; } gl Buffer Data ( GL ARRAY BUFFER , bb , GL STATIC DRAW ) ; gl Enable Vertex Attrib Array ( NUM_ ) ; gl Vertex Attrib Pointer ( NUM_ , NUM_ , GL FLOAT , false , NUM_ * ( NUM_ + NUM_ ) , NUM_ ) ; gl Enable Vertex Attrib Array ( NUM_ ) ; gl Vertex Attrib Pointer ( NUM_ , NUM_ , GL FLOAT , false , NUM_ * ( NUM_ + NUM_ ) , NUM_ * NUM_ ) ; gl Bind Buffer ( GL ARRAY BUFFER , NUM_ ) ; gl Bind Vertex Array ( NUM_ ) ; }
private void update Group Sources ( List < String > batch List , List < Group > current Groups ) throws SQL Exception , Ade Exception { Prepared Statement source List Statement = prepare Statement ( STR_ + SOURCES TABLE + STR_ + MANAGED SYSTEMS TABLE + STR_ + STR_ + MANAGED SYSTEMS TABLE + STR_ , Result Set . TYPE SCROLL INSENSITIVE , Result Set . CONCUR READ ONLY ) ; Result Set sources Result = source List Statement . execute Query ( ) ; update Group Sources ( current Groups , sources Result , batch List ) ; sources Result . close ( ) ; source List Statement . close ( ) ; }
private void draw Y Tick Marks ( Graphics g ) { Rectangle plot Rect = get Plot Rect ( ) ; int x Pos = plot Rect . x ; Number Format nf = Number Format . get Instance ( ) ; nf . set Minimum Fraction Digits ( NUM_ ) ; nf . set Maximum Fraction Digits ( NUM_ ) ; for ( double d = NUM_ ; d <= NUM_ ; d += NUM_ ) { int y Pos = get Y Pos ( d ) ; g . set Color ( boundary Color ) ; g . draw Line ( x Pos , y Pos , x Pos + NUM_ , y Pos ) ; String str = nf . format ( d ) ; int str Wid = fm . string Width ( str ) ; int str Hgt = fm . get Ascent ( ) ; g . draw String ( str , x Pos - str Wid - NUM_ , y Pos + str Hgt / NUM_ ) ; } }
private Map < Byte , Long List > pick Top Social Proofs ( Small Array Based Long To Double Map [ ] social Proofs , byte [ ] valid Social Proofs , int max Social Proof Size ) { Map < Byte , Long List > results = new Hash Map < Byte , Long List > ( ) ; int length = valid Social Proofs . length ; for ( int i = NUM_ ; i < length ; i ++ ) { Small Array Based Long To Double Map social Proof = social Proofs [ valid Social Proofs [ i ] ] ; if ( social Proof != null ) { if ( social Proof . size ( ) > NUM_ ) { social Proof . sort ( ) ; } social Proof . trim ( max Social Proof Size ) ; results . put ( ( byte ) i , new Long Array List ( social Proof . keys ( ) ) ) ; } } return results ; }
public synchronized void update Load ( Server Location location , Server Load new Load , List client Ids ) { String [ ] groups = ( String [ ] ) server Group Map . get ( location ) ; if ( groups == null ) { return ; } if ( client Ids != null ) { for ( Iterator itr = client Ids . iterator ( ) ; itr . has Next ( ) ; ) { cancel Client Estimate ( ( Client Proxy Membership ID ) itr . next ( ) , location ) ; } } update Map ( connection Load Map , location , new Load . get Connection Load ( ) , new Load . get Load Per Connection ( ) ) ; update Map ( queue Load Map , location , new Load . get Subscription Connection Load ( ) , new Load . get Load Per Subscription Connection ( ) ) ; }
public Element find Method ( String method Name , Type Mirror receiver Type , Tree Path path , java . util . List < Type Mirror > argument Types ) { Log . Diagnostic Handler discard Diagnostic Handler = new Log . Discard Diagnostic Handler ( log ) ; try { Javac Scope scope = ( Javac Scope ) trees . get Scope ( path ) ; Env < Attr Context > env = scope . get Env ( ) ; Type site = ( Type ) receiver Type ; Name name = names . from String ( method Name ) ; List < Type > argtypes = List . nil ( ) ; for ( Type Mirror a : argument Types ) { argtypes = argtypes . append ( ( Type ) a ) ; } List < Type > typeargtypes = List . nil ( ) ; boolean allow Boxing = true ; boolean use Varargs = false ; boolean operator = true ; try { Object method Context = build Method Context ( ) ; Object old Context = get Field ( resolve , STR_ ) ; set Field ( resolve , STR_ , method Context ) ; Element result = wrap Invocation On Resolve Instance ( FIND METHOD , env , site , name , argtypes , typeargtypes , allow Boxing , use Varargs , operator ) ; set Field ( resolve , STR_ , old Context ) ; return result ; } catch ( Throwable t ) { Error err = new Assertion Error ( STR_ ) ; err . init Cause ( t ) ; throw err ; } } finally { log . pop Diagnostic Handler ( discard Diagnostic Handler ) ; } }
public void cancel Request ( int sender What , Handler target , int target What ) { synchronized ( this ) { Registration start = m Reg ; Registration r = start ; if ( r == null ) { return ; } do { if ( r . sender What >= sender What ) { break ; } r = r . next ; } while ( r != start ) ; if ( r . sender What == sender What ) { Handler [ ] targets = r . targets ; int [ ] whats = r . target Whats ; int old Len = targets . length ; for ( int i = NUM_ ; i < old Len ; i ++ ) { if ( targets [ i ] == target && whats [ i ] == target What ) { r . targets = new Handler [ old Len - NUM_ ] ; r . target Whats = new int [ old Len - NUM_ ] ; if ( i > NUM_ ) { System . arraycopy ( targets , NUM_ , r . targets , NUM_ , i ) ; System . arraycopy ( whats , NUM_ , r . target Whats , NUM_ , i ) ; } int remaining Len = old Len - i - NUM_ ; if ( remaining Len != NUM_ ) { System . arraycopy ( targets , i + NUM_ , r . targets , i , remaining Len ) ; System . arraycopy ( whats , i + NUM_ , r . target Whats , i , remaining Len ) ; } break ; } } } } }
public void render World ( I Block Access block Access ) { render ( Optional . of ( block Access ) , Optional . empty ( ) ) ; }
private void place Volume To Mask With Least Number Of Volumes ( URI volume URI , Map < URI , Export Mask > placed Masks ) { log . info ( STR_ , placed Masks . key Set ( ) ) ; int least Number Of Volumes = Integer . MAX VALUE ; Set < URI > export Mask With More Volumes = new Hash Set < > ( ) ; Export Mask curr Mask With Least Volumes = null ; for ( Export Mask mask : placed Masks . values ( ) ) { int total Volume Count = mask . return Total Volume Count ( ) ; if ( total Volume Count < least Number Of Volumes ) { if ( curr Mask With Least Volumes != null ) { export Mask With More Volumes . add ( curr Mask With Least Volumes . get Id ( ) ) ; } least Number Of Volumes = total Volume Count ; curr Mask With Least Volumes = mask ; } else { export Mask With More Volumes . add ( mask . get Id ( ) ) ; } } if ( curr Mask With Least Volumes != null ) { log . info ( String . format ( STR_ , curr Mask With Least Volumes . get Id ( ) , volume URI , curr Mask With Least Volumes . return Total Volume Count ( ) ) ) ; } log . info ( STR_ , volume URI , export Mask With More Volumes ) ; log . info ( STR_ , placement Descriptor . to String ( ) ) ; for ( URI export Mask URI : export Mask With More Volumes ) { placement Descriptor . unplace Volume From Mask ( volume URI , export Mask URI ) ; } log . info ( STR_ , placement Descriptor . to String ( ) ) ; }
private void load Next ( Schedule Item schedule Item , Car car ) { if ( schedule Item == null ) { log . debug ( STR_ , get Schedule Id ( ) ) ; return ; } car . set Next Load Name ( schedule Item . get Ship Load Name ( ) ) ; car . set Final Destination ( schedule Item . get Destination ( ) ) ; car . set Final Destination Track ( schedule Item . get Destination Track ( ) ) ; car . set Next Pickup Schedule Id ( schedule Item . get Pickup Train Schedule Id ( ) ) ; car . set Next Wait ( schedule Item . get Wait ( ) ) ; schedule Item . set Hits ( schedule Item . get Hits ( ) + NUM_ ) ; log . debug ( STR_ , car . to String ( ) , car . get Type Name ( ) , car . get Next Load Name ( ) , car . get Final Destination Name ( ) , car . get Final Destination Track Name ( ) , car . get Next Wait ( ) ) ; car . update Kernel ( ) ; }
protected OM Graphic create OM Graphic From Buffered Image ( Buffered Image bi , int x , int y , int zoom Level , Projection proj ) throws Interrupted Exception { OM Graphic raster = null ; if ( bi != null ) { Buffered Image raster Image = preprocess Image ( bi , bi . get Width ( ) , bi . get Height ( ) ) ; if ( proj instanceof Mercator ) { raster = get Tile Matching Projection Type ( raster Image , x , y , zoom Level ) ; } else { raster = get Tile Not Matching Projection Type ( raster Image , x , y , zoom Level ) ; } if ( map Tile Logger . is Loggable ( Level . FINE ) ) { raster . put Attribute ( OM Graphic . LABEL , new OM Text Labeler ( STR_ + zoom Level + STR_ + x + STR_ + y , OM Text . JUSTIFY CENTER ) ) ; raster . set Selected ( true ) ; } } return raster ; }
private static synchronized String generate Transaction Id ( ) { return Long . to Hex String ( m Random . next Long ( ) ) ; }
private void init Share Via Link Listener ( View share View ) { m On Share Via Link Switch Checked Change Listener = new On Share Via Link Listener ( ) ; Switch Compat share Via Link Switch = ( Switch Compat ) share View . find View By Id ( R . id . share Via Link Section Switch ) ; share Via Link Switch . set On Checked Change Listener ( m On Share Via Link Switch Checked Change Listener ) ; }
public boolean await ( long timeout , Time Unit time Unit ) throws Interrupted Exception { return synchronizer . await ( timeout , time Unit ) ; }
protected void store Image Replaced Element ( Element e , Replaced Element cc , String uri , final int css Width , final int css Height ) { if ( image Components == null ) { image Components = new Hash Map ( ) ; } Cache Key key = new Cache Key ( e , uri , css Width , css Height ) ; image Components . put ( key , cc ) ; }
private boolean has Def Clear Path ( Def Use target DU , Bytecode Instruction current Vertex , Set < String > handle ) { if ( ! graph . contains Vertex ( current Vertex ) ) throw new Illegal Argument Exception ( STR_ ) ; handle . add ( method Name ) ; String target Variable = target DU . get Variable Name ( ) ; if ( current Vertex . is Definition For Variable ( target Variable ) ) return false ; Set < Control Flow Edge > outgoing Edges = graph . outgoing Edges Of ( current Vertex ) ; if ( outgoing Edges . size ( ) == NUM_ ) return true ; for ( Control Flow Edge e : outgoing Edges ) { Bytecode Instruction edge Target = graph . get Edge Target ( e ) ; if ( can Be Overwriting Method ( target DU , edge Target ) && ! handle . contains ( edge Target . get Called Method ( ) ) && can Overwrite DU ( target DU , edge Target , handle ) ) continue ; if ( has Def Clear Path ( target DU , edge Target , handle ) ) return true ; } return false ; }
private void populate Map ( Map < String , State Info > map , State Info state Info ) { String server Id = state Info . id ; map . put ( server Id , state Info ) ; if ( ! state Info . is Up ) { down . add ( server Id ) ; } server Selection List [ get Next Selected ( ) ] = state Info ; }
public static boolean validate Quality Format Flags ( C Flags flags , String format ) { if ( format . equals ( FASTQ FORMAT ) ) { if ( ! flags . is Set ( Common Flags . QUALITY FLAG ) ) { flags . set Parse Message ( STR_ + Common Flags . QUALITY FLAG + STR_ ) ; return false ; } } else { if ( flags . is Set ( Common Flags . QUALITY FLAG ) ) { flags . set Parse Message ( STR_ + Common Flags . QUALITY FLAG + STR_ ) ; return false ; } } return true ; }
public void add Cert Chain Listener ( Cert Chain Listener listener ) { cert Chain Listeners . add ( listener ) ; }
public static Data Input Stream new Data Input Stream ( Path self ) throws IO Exception { return new Data Input Stream ( Files . new Input Stream ( self ) ) ; }
private C Module create Module ( final I Navi Raw Module raw Module ) throws Couldnt Load Data Exception , Couldnt Save Data Exception { final C Module new Module = m provider . create Module ( raw Module ) ; m modules . add ( new Module ) ; return new Module ; }
protected Rule parse Rule Result ( Result Set rule List Result Set ) throws SQL Exception { int uid = rule List Result Set . get Int ( STR_ ) ; String name = rule List Result Set . get String ( STR_ ) ; String description = rule List Result Set . get String ( STR_ ) ; String rule = rule List Result Set . get String ( STR_ ) ; return new Rule ( uid , name , rule , description ) ; }
public List < Zone > show Zones ( Collection < String > zone Names , boolean exclude Aliases ) { List < Zone > zones = new Array List < Zone > ( ) ; Zone zone = null ; if ( zone Names != null && ! zone Names . is Empty ( ) ) { Map < String , String > alias Database = show Device Alias Database ( ) ; for ( String zone Name : zone Names ) { if ( zone Name . starts With ( IVR ZONENAME PREFIX ) ) { zone = show Ivr Zone ( zone Name . substring ( IVR ZONENAME PREFIX . length ( ) ) ) ; } else { zone = show Zone ( zone Name , alias Database , exclude Aliases ) ; } zones . add ( zone ) ; } } return zones ; }
public static Map < String , Object > create Electronic Text ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Map < String , Object > result = create Electronic Text Method ( dctx , context ) ; return result ; }
private void assign Children ( Graph Node root , int level ) { if ( allready Done . contains ( root ) ) { return ; } allready Done . add ( root ) ; int next Level = level + NUM_ ; int child Left = get Curr Offset ( next Level ) ; for ( Graph Node node : order Children ( root ) ) { assign Children ( node , next Level ) ; } int child Right = get Curr Offset ( next Level ) ; if ( child Left != child Right ) { assign Node ( root , level , ( child Left + child Right ) / NUM_ ) ; } else { assign Node ( root , level , get Curr Offset ( level ) ) ; incr Curr Offset ( level ) ; } }
protected J Popup Menu create Popup Menu ( boolean properties , boolean save , boolean print , boolean zoom ) { return create Popup Menu ( properties , false , save , print , zoom ) ; }
public void add Ping Url ( String url ) { ping Urls . add ( url ) ; }
private void write Metadata Same Size ( Byte Buffer raw Ilst Data , long old Ilst Size , long start Ist Within File , File Channel file Read Channel , File Channel file Write Channel , Mp 4 Box Header tags Header ) throws Cannot Write Exception , IO Exception { file Read Channel . position ( NUM_ ) ; file Write Channel . transfer From ( file Read Channel , NUM_ , start Ist Within File ) ; file Write Channel . position ( start Ist Within File ) ; file Write Channel . write ( raw Ilst Data ) ; file Read Channel . position ( start Ist Within File + old Ilst Size ) ; write Data After Ilst ( file Read Channel , file Write Channel , tags Header ) ; }
@ Suppress Warnings ( STR_ ) protected boolean add Telegram Listener ( Telegram Listener new Listener ) { return ( Telegram Listeners . add ( new Listener ) ) ; }
public static Tetrad Matrix construct Gram Matrix ( List < Kernel > kernels , Data Set dataset , List < Node > nodes ) { int m = dataset . get Num Rows ( ) ; Tetrad Matrix gram = new Tetrad Matrix ( m , m ) ; for ( int k = NUM_ ; k < nodes . size ( ) ; k ++ ) { Node node = nodes . get ( k ) ; int col = dataset . get Column ( node ) ; Kernel kernel = kernels . get ( k ) ; for ( int i = NUM_ ; i < m ; i ++ ) { for ( int j = i ; j < m ; j ++ ) { double keval = kernel . eval ( dataset . get Double ( i , col ) , dataset . get Double ( j , col ) ) ; if ( k == NUM_ ) { gram . set ( i , j , keval ) ; } else { keval *= gram . get ( i , j ) ; gram . set ( i , j , keval ) ; } } } } return gram ; }
public Content Proposal Adapter ( Control control , I Control Content Adapter control Content Adapter , I Content Proposal Provider proposal Provider , Key Stroke key Stroke , char [ ] auto Activation Characters ) { super ( ) ; Assert . is Not Null ( control ) ; Assert . is Not Null ( control Content Adapter ) ; this . control = control ; this . control Content Adapter = control Content Adapter ; this . proposal Provider = proposal Provider ; this . trigger Key Stroke = key Stroke ; if ( auto Activation Characters != null ) { this . auto Activate String = new String ( auto Activation Characters ) ; } add Control Listener ( control ) ; }
public static Grid Cache Attributes [ ] cache Attributes ( Cluster Node n ) { return n . attribute ( ATTR CACHE ) ; }
public Polygon ( Polygon Point p 1 , Polygon Point p 2 , Polygon Point p 3 ) { p 1 . next = p 2 ; p 2 . next = p 3 ; p 3 . next = p 1 ; p 1 . previous = p 3 ; p 2 . previous = p 1 ; p 3 . previous = p 2 ; points . add ( p 1 ) ; points . add ( p 2 ) ; points . add ( p 3 ) ; }
public static Token Queue < Html Token Type > make Token Queue ( Input Source is , Reader in , boolean as Xml , boolean wants Comments ) throws IO Exception { return make Token Queue ( File Position . start Of File ( is ) , in , as Xml , wants Comments ) ; }
private boolean validate Folder ( File default Fingerprint Folder ) { return default Fingerprint Folder . exists ( ) && default Fingerprint Folder . can Read ( ) && default Fingerprint Folder . can Write ( ) ; }
public void remove Property Change Listener ( final String property Name , final Property Change Listener listener ) { property Change Support . remove Property Change Listener ( property Name , listener ) ; }
protected void strat Step ( int num Folds ) { Array List < Instance > new Vec = new Array List < Instance > ( m Instances . size ( ) ) ; int start = NUM_ , j ; while ( new Vec . size ( ) < num Instances ( ) ) { j = start ; while ( j < num Instances ( ) ) { new Vec . add ( instance ( j ) ) ; j = j + num Folds ; } start ++ ; } m Instances = new Vec ; }
public boolean seek ( Byte Buffer byte Buffer ) { byte [ ] buffer = new byte [ FIELD TAGID LENGTH ] ; byte Buffer . get ( buffer , NUM_ , FIELD TAGID LENGTH ) ; if ( ! ( Arrays . equals ( buffer , TAG ID ) ) ) { return false ; } byte Buffer . position ( FIELD TRACK INDICATOR POS ) ; if ( byte Buffer . get ( ) != END OF FIELD ) { return false ; } return byte Buffer . get ( ) != END OF FIELD ; }
protected void calc Formats ( ) { int bonus = NUM_ ; if ( ! m Rounded Y Legend ) bonus ++ ; if ( m Y Legend Digits To Use == - NUM_ ) { if ( m Y Legend . length < NUM_ ) { m Y Legend Format Digits = Utils . get Legend Format Digits ( NUM_ , bonus ) ; } else { m Y Legend Format Digits = Utils . get Legend Format Digits ( m Y Legend [ NUM_ ] - m Y Legend [ NUM_ ] , bonus ) ; } } else m Y Legend Format Digits = m Y Legend Digits To Use ; if ( m Value Digits To Use == - NUM_ ) m Value Format Digits = Utils . get Format Digits ( m Delta Y ) ; else m Value Format Digits = m Value Digits To Use ; String Buffer a = new String Buffer ( ) ; for ( int i = NUM_ ; i < m Y Legend Format Digits ; i ++ ) { if ( i == NUM_ ) a . append ( STR_ ) ; a . append ( STR_ ) ; } m Format Average = new Decimal Format ( STR_ ) ; m Format Y Legend = new Decimal Format ( STR_ + a . to String ( ) ) ; String Buffer b = new String Buffer ( ) ; for ( int i = NUM_ ; i < m Value Format Digits ; i ++ ) { if ( i == NUM_ ) b . append ( STR_ ) ; b . append ( STR_ ) ; } m Format Value = new Decimal Format ( STR_ + b . to String ( ) ) ; }
private Dop find Expanded Opcode For Insn ( Dalv Insn insn ) { Dop result = find Opcode For Insn ( insn . get Low Reg Version ( ) , insn . get Opcode ( ) ) ; if ( result == null ) { throw new Dex Exception ( STR_ + insn ) ; } return result ; }
private static void use Cache Or Online Repository ( ) { if ( REP MIRROR == null ) { establish Mirror ( ) ; } if ( CACHE URL != null ) { PACKAGE MANAGER . set Package Repository URL ( CACHE URL ) ; } else if ( REP URL != null ) { PACKAGE MANAGER . set Package Repository URL ( REP URL ) ; } }
public static String format Percent ( double done , int digits ) { Decimal Format percent Format = new Decimal Format ( STR_ ) ; double scale = Math . pow ( NUM_ , digits + NUM_ ) ; double rounded = Math . floor ( done * scale ) ; percent Format . set Decimal Separator Always Shown ( false ) ; percent Format . set Minimum Fraction Digits ( digits ) ; percent Format . set Maximum Fraction Digits ( digits ) ; return percent Format . format ( rounded / scale ) ; }
public static Uri add Placeholder ( Bitmap placeholder ) { Uri uri = generate Unique Placeholder Uri ( ) ; replace Placeholder ( uri , placeholder ) ; return uri ; }
private final long logarithmic Distribution ( long mean , long max ) { final double x = local Random . next Double ( ) ; if ( x == NUM_ ) { return max ; } return Math . min ( ( long ) ( mean * - Math . log ( x ) ) , max ) ; }
private String create Workflow Step For Restore Native Snapshot Session ( Workflow workflow , Storage System parent System , URI snap Session URI , String wait For , Workflow . Method rollback Method ) { URI parent System URI = parent System . get Id ( ) ; Workflow . Method restore Method = new Workflow . Method ( RESTORE SNAP SESSION METHOD NAME , parent System URI , snap Session URI , Boolean . FALSE ) ; workflow . create Step ( RESTORE SNAP SESSION STEP , String . format ( STR_ , snap Session URI ) , wait For , parent System URI , parent System . get System Type ( ) , Block Device Controller . class , restore Method , rollback Method , null ) ; log . info ( STR_ , snap Session URI ) ; return RESTORE SNAP SESSION STEP ; }
@ Override public String generate Device Specific Add Volume Work Flow ( Workflow workflow , String previous Step , Storage System storage , Export Group export Group , Export Mask mask , Map < URI , Integer > volumes To Add , List < URI > volume UR Is , List < URI > initiator UR Is ) throws Exception { List < Export Mask > masks = new Array List < Export Mask > ( ) ; masks . add ( mask ) ; String masking Step Id = generate Export Mask Add Volumes Workflow ( workflow , previous Step , storage , export Group , mask , volumes To Add , initiator UR Is ) ; generate Zoning Add Volumes Workflow ( workflow , masking Step Id , export Group , masks , volume UR Is ) ; return masking Step Id ; }
public Standard Pie Section Label Generator ( String label Format , Locale locale ) { this ( label Format , Number Format . get Number Instance ( locale ) , Number Format . get Percent Instance ( locale ) ) ; }
protected void add Bean Connection Relation ( Meta Bean meta , String connection ) { Vector < String > relations ; Object key ; relations = get Bean Connection Relation ( meta ) ; relations . add ( connection ) ; if ( meta == null ) { key = REGULAR CONNECTION ; } else { key = meta ; } m Bean Connection Relation . put ( key , relations ) ; }
public static long read Long ( final JSON Object json Object , final String key , final boolean required , final boolean not Null ) throws JSON Exception { if ( required ) { return json Object . get Long ( key ) ; } if ( not Null && json Object . is Null ( key ) ) { throw new JSON Exception ( String . format ( Locale . US , NULL VALUE FORMAT OBJECT , key ) ) ; } long value = NUM_ ; if ( ! json Object . is Null ( key ) ) { value = json Object . get Long ( key ) ; } return value ; }
private void run Scenario ( int library Index , int source Index , boolean use Drawee ) throws Exception { disable Animated Images ( ) ; set Use Drawee ( use Drawee ) ; select Framework ( library Index ) ; select Source ( source Index ) ; Touch Utils . tap View ( this , m Image List ) ; wait For Images ( ) ; scroll Multiple Times ( SCROLLS ) ; Thread . sleep ( WAIT BEFORE TEST END MS ) ; }
private List < VNX File System > discover All File Systems ( Storage System system ) throws VNX File Collection Exception , VNX Exception { List < VNX File System > file Systems = new Array List < VNX File System > ( ) ; logger . info ( STR_ , system . get Id ( ) ) ; try { List < VNX File System > vnx File Systems = get All File System ( system ) ; logger . info ( STR_ , vnx File Systems . size ( ) ) ; if ( vnx File Systems != null ) { for ( VNX File System vnxfs : vnx File Systems ) { File Share fs = null ; URI Query Result List results = new URI Query Result List ( ) ; String fs Native Guid = Native GUID Generator . generate Native Guid ( system , vnxfs . get Fs Id ( ) + STR_ , Native GUID Generator . FILESYSTEM ) ; if ( check Storage File System Exists In DB ( fs Native Guid ) ) { continue ; } vnxfs . set Fs Native Guid ( fs Native Guid ) ; file Systems . add ( vnxfs ) ; } } logger . info ( STR_ , file Systems . size ( ) ) ; } catch ( IO Exception e ) { logger . error ( STR_ , system . get Id ( ) , e . get Message ( ) ) ; VNX File Collection Exception vnxe = new VNX File Collection Exception ( STR_ + system . get Id ( ) ) ; vnxe . init Cause ( e ) ; throw vnxe ; } logger . info ( STR_ , system . get Id ( ) ) ; return file Systems ; }
private void verify Access Rights ( Operation Group create Group , Operation Group update Group , Operation Group delete Group ) { log Step ( STR_ ) ; for ( Entity entity : create Group . get Entities ( ) ) { verify Create Right ( entity ) ; } for ( Entity entity : update Group . get Entities ( ) ) { verify Update Right ( entity ) ; } for ( Entity entity : delete Group . get Entities ( ) ) { verify Delete Right ( entity ) ; } }
private void configure ( ) throws Null Location Exception , Formatter Init Exception { String buffer Size = lmanager . get Property ( Log Constants . BUFFER SIZE ) ; if ( buffer Size != null && buffer Size . length ( ) > NUM_ ) { try { rec Count Limit = Integer . parse Int ( buffer Size ) ; } catch ( Number Format Exception nfe ) { Debug . warning ( file Name + STR_ , nfe ) ; if ( Debug . message Enabled ( ) ) { Debug . message ( file Name + STR_ ) ; } rec Count Limit = NUM_ ; } } else { Debug . warning ( file Name + STR_ + buffer Size ) ; if ( Debug . message Enabled ( ) ) { Debug . message ( file Name + STR_ ) ; } rec Count Limit = NUM_ ; } String status = lmanager . get Property ( Log Constants . TIME BUFFERING STATUS ) ; if ( status != null && status . equals Ignore Case ( STR_ ) ) { time Buffering Enabled = true ; } String str Count = lmanager . get Property ( Log Constants . NUM HISTORY FILES ) ; if ( ( str Count == null ) || ( str Count . length ( ) == NUM_ ) ) { count = NUM_ ; } else { count = Integer . parse Int ( str Count ) ; } String str Max File Size = lmanager . get Property ( Log Constants . MAX FILE SIZE ) ; if ( ( str Max File Size == null ) || ( str Max File Size . length ( ) == NUM_ ) ) { max File Size = NUM_ ; } else { max File Size = Long . parse Long ( str Max File Size ) ; } location = lmanager . get Property ( Log Constants . LOG LOCATION ) ; if ( ( location == null ) || ( location . length ( ) == NUM_ ) ) { throw new Null Location Exception ( STR_ ) ; } if ( ! location . ends With ( File . separator ) ) { location += File . separator ; } String str Formatter = lmanager . get Property ( Log Constants . ELF FORMATTER ) ; try { Class clz = Class . for Name ( str Formatter ) ; formatter = ( Formatter ) clz . new Instance ( ) ; } catch ( Exception e ) { throw new Formatter Init Exception ( STR_ + e ) ; } String str Rotate Enabled = lmanager . get Property ( Log Constants . ENABLE ROTATION ) ; if ( str Rotate Enabled != null && ! str Rotate Enabled . is Empty ( ) ) { rotate Enabled = Boolean . parse Boolean ( str Rotate Enabled ) ; } if ( rotate Enabled ) { String rotation = lmanager . get Property ( Log Constants . LOGFILE ROTATION ) ; try { if ( rotation != null ) { rotation Interval = Integer . parse Int ( rotation ) ; } } catch ( Number Format Exception nfe ) { rotation Interval = - NUM_ ; } if ( rotation Interval > NUM_ ) { last Rotation = current Time Millis ( ) ; rotating By Size = false ; } } }
public void add Operand Comment ( int pos , String comment ) { List < String > list = comments . get ( pos ) ; if ( list == null ) { list = new Array List < > ( NUM_ ) ; comments . put ( pos , list ) ; } list . add ( encode String ( comment ) ) ; }
protected void paint Image ( Graphics 2 D g , int x , int y , int w , int h ) { Buffered Image image = get Image ( ) ; if ( image != null ) g . draw Image ( image , x , y , w , h , this ) ; else { Color c = g . get Color ( ) ; g . set Color ( Color . WHITE ) ; g . fill Rect ( x , y , w , h ) ; g . set Color ( c ) ; } }
public static boolean is Date ( String s ) { pp . set Index ( NUM_ ) ; return df . parse ( s , pp ) != null ; }
protected void rename Dwca To Include Version ( Resource resource , Big Decimal version ) { Preconditions . check Not Null ( resource ) ; Preconditions . check Not Null ( version ) ; File unversioned Dwca = data Dir . resource Dwca File ( resource . get Shortname ( ) ) ; File versioned Dwca = data Dir . resource Dwca File ( resource . get Shortname ( ) , version ) ; if ( unversioned Dwca . exists ( ) && ! versioned Dwca . exists ( ) ) { try { Files . move ( unversioned Dwca , versioned Dwca ) ; log . debug ( STR_ + versioned Dwca . get Name ( ) ) ; } catch ( IO Exception e ) { log . error ( STR_ + resource . get Shortname ( ) , e ) ; throw new Invalid Config Exception ( TYPE . CONFIG WRITE , STR_ + resource . get Shortname ( ) + STR_ + e . get Message ( ) ) ; } } }
public static String prep NA Strings ( String na ) { return na + Data Expression . DELIM NA STRING SEP + STR_ ; }
@ Override public boolean is Valid Row ( Map < String , Object > row ) { if ( ! row . contains Key ( column ) ) { return false ; } Matcher match = pattern . matcher ( ( Char Sequence ) row . get ( column ) ) ; return match . find ( ) ; }
public long number Of Key Schema Changes ( ) { return key Schemas . size ( ) ; }
public final void remove All Helper Text Colors ( ) { helper Text Colors . clear ( ) ; }
public static byte [ ] pack Byte Buffer Into Single Byte Array ( byte [ ] [ ] byte Buffer Arr ) { if ( null == byte Buffer Arr || byte Buffer Arr . length == NUM_ ) { return null ; } int no Of Col = byte Buffer Arr . length ; short to Determine Length Of Byte Arr = NUM_ ; short offset Len = ( short ) ( no Of Col * NUM_ + to Determine Length Of Byte Arr ) ; int total Bytes = calculate Total Bytes ( byte Buffer Arr ) + offset Len ; Byte Buffer buffer = Byte Buffer . allocate ( total Bytes ) ; buffer . put Short ( ( short ) ( total Bytes - to Determine Length Of Byte Arr ) ) ; buffer . put Short ( offset Len ) ; for ( int index = NUM_ ; index < byte Buffer Arr . length - NUM_ ; index ++ ) { int no Of Bytes = byte Buffer Arr [ index ] . length ; buffer . put Short ( ( short ) ( offset Len + no Of Bytes ) ) ; offset Len += no Of Bytes ; } for ( int index = NUM_ ; index < byte Buffer Arr . length ; index ++ ) { buffer . put ( byte Buffer Arr [ index ] ) ; } buffer . rewind ( ) ; return buffer . array ( ) ; }
private String generate Unique Future Id ( ) { return String . value Of ( m Id Counter . get And Increment ( ) ) ; }
private void initialize ( Context context , String app Identifier , String channel Id , boolean ignore Default Handler ) { if ( context != null ) { this . m Identifier = Util . sanitize App Identifier ( app Identifier ) ; this . m Channel Id = channel Id ; Constants . load From Context ( context ) ; if ( m Identifier == null ) { this . m Identifier = Constants . APP PACKAGE ; } Weak Reference < Context > weak Context = new Weak Reference < Context > ( context ) ; register Handler ( weak Context , ignore Default Handler ) ; make Session ( ) ; } }
public List < Source Record > ddl Records For Database ( String db Name ) { return ddl Records By Db Name . get ( db Name ) ; }
private boolean parse Source ( Http Message message , Source source , int depth , String base URL ) { log . debug ( STR_ ) ; boolean resourcesfound = false ; List < Element > elements = source . get All Elements ( HTML Element Name . A ) ; for ( Element el : elements ) { resourcesfound |= process Attribute Element ( message , depth , base URL , el , STR_ ) ; } elements = source . get All Elements ( HTML Element Name . AREA ) ; for ( Element el : elements ) { resourcesfound |= process Attribute Element ( message , depth , base URL , el , STR_ ) ; } elements = source . get All Elements ( HTML Element Name . FRAME ) ; for ( Element el : elements ) { resourcesfound |= process Attribute Element ( message , depth , base URL , el , STR_ ) ; } elements = source . get All Elements ( HTML Element Name . IFRAME ) ; for ( Element el : elements ) { resourcesfound |= process Attribute Element ( message , depth , base URL , el , STR_ ) ; } elements = source . get All Elements ( HTML Element Name . LINK ) ; for ( Element el : elements ) { resourcesfound |= process Attribute Element ( message , depth , base URL , el , STR_ ) ; } elements = source . get All Elements ( HTML Element Name . SCRIPT ) ; for ( Element el : elements ) { resourcesfound |= process Attribute Element ( message , depth , base URL , el , STR_ ) ; } elements = source . get All Elements ( HTML Element Name . IMG ) ; for ( Element el : elements ) { resourcesfound |= process Attribute Element ( message , depth , base URL , el , STR_ ) ; } elements = source . get All Elements ( HTML Element Name . META ) ; for ( Element el : elements ) { String equiv = el . get Attribute Value ( STR_ ) ; String content = el . get Attribute Value ( STR_ ) ; if ( equiv != null && content != null ) { if ( equiv . equals Ignore Case ( STR_ ) || equiv . equals Ignore Case ( STR_ ) ) { Matcher matcher = url Pattern . matcher ( content ) ; if ( matcher . find ( ) ) { String url = matcher . group ( NUM_ ) ; process URL ( message , depth , url , base URL ) ; resourcesfound = true ; } } } } return resourcesfound ; }
static void generate Plain Return Code ( String return Type , Code Visitor cv ) { if ( return Type . equals ( STR_ ) ) cv . visit Insn ( RETURN ) ; else if ( is Primitive ( return Type ) ) { int opcode = IRETURN ; if ( return Type . equals ( STR_ ) ) opcode = DRETURN ; else if ( return Type . equals ( STR_ ) ) opcode = FRETURN ; else if ( return Type . equals ( STR_ ) ) opcode = LRETURN ; cv . visit Insn ( opcode ) ; } else { cv . visit Type Insn ( CHECKCAST , descriptor To Class Name ( return Type ) ) ; cv . visit Insn ( ARETURN ) ; } }
public void roll In ( Operator operator ) { map . put ( operator , new Interpolated Value ( false , get Value ( operator ) ) ) ; if ( ! timer . is Running ( ) ) { timer . start ( ) ; } }
private void reuse Existing Export Mask ( Map < URI , Integer > block Object Map , Storage System vplex System , Export Group export Group , URI varray Uri , List < Export Mask > export Masks To Update On Device , Map < URI , List < URI > > export Masks To Update On Device With Storage Ports , List < Initiator > inits , boolean all Ports From Mask Match For Varray , Export Mask vipr Export Mask , String op Id ) { export Masks To Update On Device . add ( vipr Export Mask ) ; export Group . add Export Mask ( vipr Export Mask . get Id ( ) ) ; db Client . update Object ( export Group ) ; Export Path Params path Params = block Scheduler . calculate Export Path Param For Volumes ( block Object Map . key Set ( ) , export Group . get Num Paths ( ) , vplex System . get Id ( ) , export Group . get Id ( ) ) ; if ( export Group . get Type ( ) != null ) { path Params . set Export Group Type ( export Group . get Type ( ) ) ; } if ( ! all Ports From Mask Match For Varray ) { Map < URI , List < URI > > assignments = block Scheduler . assign Storage Ports ( vplex System , export Group , inits , vipr Export Mask . get Zoning Map ( ) , path Params , null , network Device Controller , varray Uri , op Id ) ; if ( assignments != null && ! assignments . is Empty ( ) ) { vipr Export Mask = Export Utils . update Zoning Map ( db Client , vipr Export Mask , assignments , export Masks To Update On Device With Storage Ports ) ; } } }
private void read Object ( java . io . Object Input Stream s ) throws java . io . IO Exception , Class Not Found Exception { s . default Read Object ( ) ; int n = s . read Int ( ) ; attrs = ( n >= NUM_ ) ? new Hashtable < String , Attribute > ( n * NUM_ ) : new Hashtable < String , Attribute > ( NUM_ ) ; while ( -- n >= NUM_ ) { put ( ( Attribute ) s . read Object ( ) ) ; } }
void populate Region Sub Regions ( Region Sub Region Snapshot parent Snap Shot , Set regions , Gem Fire Cache Impl cache ) { if ( cancelled ) return ; Region sub Region = null ; Region Sub Region Snapshot sub Region Snap Shot = null ; for ( Iterator iter = regions . iterator ( ) ; iter . has Next ( ) ; ) { sub Region = ( Region ) iter . next ( ) ; try { sub Region Snap Shot = new Region Sub Region Snapshot ( sub Region ) ; parent Snap Shot . add Sub Region ( sub Region Snap Shot ) ; Set sub Regions = sub Region . subregions ( false ) ; populate Region Sub Regions ( sub Region Snap Shot , sub Regions , cache ) ; } catch ( Exception e ) { logger . debug ( STR_ , sub Region . get Full Path ( ) , e ) ; } } }
public void check Jvm Memory GC Call ( Enum Jvm Memory GC Call x ) throws Snmp Status Exception { if ( x . int Value ( ) != Jvm Memory GC Call Start . int Value ( ) ) throw new Snmp Status Exception ( Snmp Definitions . snmp Rsp Wrong Value ) ; }
private Replace Tokens create Jvm Config Tokens ( ) { Replace Tokens . Token token Java Home = create Java Home Token ( ) ; Replace Tokens . Token token Class Path = create Class Path Token ( ) ; Replace Tokens . Token token Vm Args = create Vm Args Token ( ) ; Replace Tokens replace Config = new Replace Tokens ( ) ; replace Config . add Configured Token ( token Java Home ) ; replace Config . add Configured Token ( token Class Path ) ; replace Config . add Configured Token ( token Vm Args ) ; return replace Config ; }
protected Field find Property Set Field ( String property Value , Class property Set Class ) throws Exception { Field [ ] fields = property Set Class . get Fields ( ) ; for ( Field field : fields ) { String value = ( String ) field . get ( null ) ; if ( value . equals ( property Value ) ) { return field ; } } return null ; }
private static void create Output Map ( Map < String , List < Distributable > > output Map , int blocks Per Node , Set < Distributable > unique Blocks , Map < String , List < Distributable > > node And Block Mapping , List < String > active Nodes ) { Array List < Node Multi Block Relation > multi Block Relations = new Array List < > ( node And Block Mapping . size ( ) ) ; for ( Map . Entry < String , List < Distributable > > entry : node And Block Mapping . entry Set ( ) ) { multi Block Relations . add ( new Node Multi Block Relation ( entry . get Key ( ) , entry . get Value ( ) ) ) ; } Collections . sort ( multi Block Relations ) ; for ( Node Multi Block Relation node Multi Block Relation : multi Block Relations ) { String node Name = node Multi Block Relation . get Node ( ) ; String active Executor = node Name ; if ( null != active Nodes ) { active Executor = get Active Executor ( active Nodes , node Name ) ; if ( null == active Executor ) { continue ; } } int node Capacity = NUM_ ; for ( Distributable block : node Multi Block Relation . get Blocks ( ) ) { if ( unique Blocks . contains ( block ) ) { if ( null == output Map . get ( active Executor ) ) { List < Distributable > list = new Array List < Distributable > ( Carbon Common Constants . DEFAULT COLLECTION SIZE ) ; output Map . put ( active Executor , list ) ; } if ( node Capacity < blocks Per Node ) { List < Distributable > infos = output Map . get ( active Executor ) ; infos . add ( block ) ; node Capacity ++ ; unique Blocks . remove ( block ) ; } else { break ; } } } } }
public static boolean equals ( double [ ] [ ] ma , double [ ] [ ] mb ) { if ( ma . length != mb . length ) return false ; for ( int i = NUM_ ; i < ma . length ; i ++ ) { double [ ] ma = ma [ i ] ; double [ ] mb = mb [ i ] ; if ( ! Arrays . equals ( ma , mb ) ) return false ; } return true ; }
public void add Cluster ( String cluster Id ) { if ( ! clusters . contains ( cluster Id ) ) { clusters . add ( cluster Id ) ; } }
public void remove Listener ( Env Loader Listener listener ) { super . remove Listener ( listener ) ; Array List < Env Loader Listener > listeners = listeners ; if ( listeners == null ) return ; synchronized ( listeners ) { for ( int i = listeners . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Env Loader Listener old Listener = listeners . get ( i ) ; if ( listener == old Listener ) { listeners . remove ( i ) ; return ; } else if ( old Listener == null ) { listeners . remove ( i ) ; } } } }
@ Override public boolean execute ( String action , JSON Array inputs , Callback Context callback Context ) throws JSON Exception { Plugin Result result = null ; if ( ACTION SET OPTIONS . equals ( action ) ) { JSON Object options = inputs . opt JSON Object ( NUM_ ) ; result = execute Set Options ( options , callback Context ) ; } else if ( ACTION CREATE BANNER VIEW . equals ( action ) ) { JSON Object options = inputs . opt JSON Object ( NUM_ ) ; result = execute Create Banner View ( options , callback Context ) ; } else if ( ACTION CREATE INTERSTITIAL VIEW . equals ( action ) ) { JSON Object options = inputs . opt JSON Object ( NUM_ ) ; result = execute Create Interstitial View ( options , callback Context ) ; } else if ( ACTION DESTROY BANNER VIEW . equals ( action ) ) { result = execute Destroy Banner View ( callback Context ) ; } else if ( ACTION REQUEST INTERSTITIAL AD . equals ( action ) ) { JSON Object options = inputs . opt JSON Object ( NUM_ ) ; result = execute Request Interstitial Ad ( options , callback Context ) ; } else if ( ACTION REQUEST AD . equals ( action ) ) { JSON Object options = inputs . opt JSON Object ( NUM_ ) ; result = execute Request Ad ( options , callback Context ) ; } else if ( ACTION SHOW AD . equals ( action ) ) { boolean show = inputs . opt Boolean ( NUM_ ) ; result = execute Show Ad ( show , callback Context ) ; } else if ( ACTION SHOW INTERSTITIAL AD . equals ( action ) ) { boolean show = inputs . opt Boolean ( NUM_ ) ; result = execute Show Interstitial Ad ( show , callback Context ) ; } else { Log . d ( LOGTAG , String . format ( STR_ , action ) ) ; result = new Plugin Result ( Status . INVALID ACTION ) ; } if ( result != null ) { callback Context . send Plugin Result ( result ) ; } return true ; }
private void validate Expression ( Label label ) throws Exception { Expression location = label . get Expression ( ) ; if ( expression != null ) { String path = expression . get Path ( ) ; String expect = location . get Path ( ) ; if ( ! path . equals ( expect ) ) { throw new Path Exception ( STR_ , path , expect , detail ) ; } } else { expression = location ; } }
protected static void init ( ) { String notificationfactory Class Name = null ; try { notificationfactory Class Name = System . get Property ( NOTIFICATION FACTORY NAME ) ; } catch ( Security Exception e ) { throw new Runtime Exception ( e ) ; } if ( notificationfactory Class Name != null ) { Class < ? > nfc ; try { nfc = Class . for Name ( notificationfactory Class Name ) ; factory = ( I Notification Manager Factory ) nfc . new Instance ( ) ; } catch ( Class Not Found Exception | Instantiation Exception | Illegal Access Exception e ) { throw new Runtime Exception ( e ) ; } } else { factory = new Syslog Notification Factory ( ) ; } }
public static String generate Token ( String cookie , String url , String method , long current Time Secs ) { String data = url + STR_ + method + STR_ + current Time Secs ; byte [ ] hmac ; try { hmac = compute SHA 1 H Mac ( data , cookie ) ; } catch ( General Security Exception e ) { throw new Runtime Exception ( STR_ + e . get Message ( ) ) ; } return Base 64 . encode Web Safe ( hmac , true ) ; }
public synchronized T acquire Modify ( T new Data ) throws Cache Exception { if ( LOG . is Trace Enabled ( ) ) LOG . trace ( STR_ + get Var Name ( ) ) ; long t 0 = DML Script . STATISTICS ? System . nano Time ( ) : NUM_ ; if ( ! is Available To Modify ( ) ) throw new Cache Exception ( STR_ ) ; clear Data ( ) ; acquire ( true , false ) ; set Dirty ( true ) ; is Acquire From Empty = false ; if ( new Data == null ) throw new Cache Exception ( STR_ ) ; data = new Data ; update Status Pinned ( true ) ; if ( DML Script . STATISTICS ) { long t 1 = System . nano Time ( ) ; Cache Statistics . increment Acquire M Time ( t 1 - t 0 ) ; } return data ; }
public static org . smpte ra . schemas . st 2067 2 2016 . User Text Type build CPL User Text Type 2016 ( String value , String language ) { org . smpte ra . schemas . st 2067 2 2016 . User Text Type user Text Type = new org . smpte ra . schemas . st 2067 2 2016 . User Text Type ( ) ; user Text Type . set Value ( value ) ; user Text Type . set Language ( language ) ; return user Text Type ; }
public Canvas Component Builder listen ( Canvas Interact Listener listener ) { listeners . add ( listener ) ; return this ; }
public static Simple Date Format make Output Formatter ( ) { Simple Date Format fmt = new Simple Date Format ( DEFAULT OFORMAT ) ; fmt . set Time Zone ( GMT ZONE ) ; return ( fmt ) ; }
public static void main ( String [ ] args ) { mxmlc ( args ) ; System . exit ( Thread Local Toolkit . error Count ( ) ) ; }
public void shutdown ( long timeout , Time Unit unit ) throws Interrupted Exception { executor . shutdown ( ) ; executor . await Termination ( timeout , unit ) ; }
public void save Request Properties ( String handle Id , Properties properties ) throws IO Exception { String file = file Handler . append ( get Configuration Directory ( handle Id ) , STR_ ) ; properties . store ( file Handler . get Output Stream ( file ) , null ) ; }
protected boolean verify Limit ( Collection result , int limit , Execution Context context ) { if ( limit > NUM_ ) { return result . size ( ) == limit ; } return false ; }
public static Connection Factory new Failover Connection Factory ( Set < LDAPURL > servers , String username , char [ ] password , int heart Beat Interval , String heart Beat Time Unit , Options ldap Options ) { List < Connection Factory > factories = new Array List < Connection Factory > ( servers . size ( ) ) ; for ( LDAPURL ldapurl : servers ) { factories . add ( new Connection Factory ( ldapurl , username , password , heart Beat Interval , heart Beat Time Unit , ldap Options ) ) ; } return load Balance Factories ( factories ) ; }
private void add Fillet ( Coordinate p , Coordinate p 0 , Coordinate p 1 , int direction , double radius ) { double dx 0 = p 0 . x - p . x ; double dy 0 = p 0 . y - p . y ; double start Angle = Math . atan 2 ( dy 0 , dx 0 ) ; double dx 1 = p 1 . x - p . x ; double dy 1 = p 1 . y - p . y ; double end Angle = Math . atan 2 ( dy 1 , dx 1 ) ; if ( direction == CG Algorithms . CLOCKWISE ) { if ( start Angle <= end Angle ) start Angle += NUM_ * Math . PI ; } else { if ( start Angle >= end Angle ) start Angle -= NUM_ * Math . PI ; } seg List . add Pt ( p 0 ) ; add Fillet ( p , start Angle , end Angle , direction , radius ) ; seg List . add Pt ( p 1 ) ; }
protected void parse DOM Element ( Element element ) throws SAML 2 Exception { Assertion Factory assertion Factory = Assertion Factory . get Instance ( ) ; Protocol Factory proto Factory = Protocol Factory . get Instance ( ) ; request Id = element . get Attribute ( SAML 2 Constants . ID ) ; validate ID ( request Id ) ; version = element . get Attribute ( SAML 2 Constants . VERSION ) ; validate Version ( version ) ; String issue Instant Str = element . get Attribute ( SAML 2 Constants . ISSUE INSTANT ) ; validate Issue Instant ( issue Instant Str ) ; destination URI = element . get Attribute ( SAML 2 Constants . DESTINATION ) ; consent = element . get Attribute ( SAML 2 Constants . CONSENT ) ; Node List n List = element . get Child Nodes ( ) ; if ( ( n List != null ) && ( n List . get Length ( ) > NUM_ ) ) { for ( int i = NUM_ ; i < n List . get Length ( ) ; i ++ ) { Node child Node = n List . item ( i ) ; String c Name = child Node . get Local Name ( ) ; if ( c Name != null ) { if ( c Name . equals ( SAML 2 Constants . ISSUER ) ) { validate Issuer ( ) ; name ID = assertion Factory . create Issuer ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . SIGNATURE ) ) { validate Signature ( ) ; signature String = XML Utils . print ( ( Element ) child Node ) ; is Signed = true ; } else if ( c Name . equals ( SAML 2 Constants . EXTENSIONS ) ) { validate Extensions ( ) ; extensions = proto Factory . create Extensions ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . SUBJECT ) ) { validate Subject ( ) ; subject = assertion Factory . create Subject ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . NAMEIDPOLICY ) ) { validate Name ID Policy ( ) ; name ID Policy = proto Factory . create Name ID Policy ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . CONDITIONS ) ) { validate Conditions ( ) ; conditions = assertion Factory . create Conditions ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . REQ AUTHN CONTEXT ) ) { validate Req Authn Context ( ) ; req Authn Context = proto Factory . create Requested Authn Context ( ( Element ) child Node ) ; } else if ( c Name . equals ( SAML 2 Constants . SCOPING ) ) { validate Scoping ( ) ; scoping = proto Factory . create Scoping ( ( Element ) child Node ) ; } } } } String force Authn Attr = element . get Attribute ( SAML 2 Constants . FORCEAUTHN ) ; if ( ( force Authn Attr != null ) && ( force Authn Attr . length ( ) > NUM_ ) ) { force Authn = SAML 2 SDK Utils . boolean Value Of ( force Authn Attr ) ; } String is Passive Attr = element . get Attribute ( SAML 2 Constants . ISPASSIVE ) ; if ( ( is Passive Attr != null ) && ( is Passive Attr . length ( ) > NUM_ ) ) { is Passive = SAML 2 SDK Utils . boolean Value Of ( is Passive Attr ) ; } protocol Binding = element . get Attribute ( SAML 2 Constants . PROTOBINDING ) ; String index = element . get Attribute ( SAML 2 Constants . ASSERTION CONSUMER SVC INDEX ) ; if ( ( index != null ) && ( index . length ( ) > NUM_ ) ) { assertion Consumer Svc Index = new Integer ( index ) ; validate Assertion Consumer Service Index ( assertion Consumer Svc Index ) ; } assertion Consumer Service URL = XML Utils . unescape Special Characters ( element . get Attribute ( SAML 2 Constants . ASSERTION CONSUMER SVC URL ) ) ; index = element . get Attribute ( SAML 2 Constants . ATTR CONSUMING SVC INDEX ) ; if ( ( index != null ) && ( index . length ( ) > NUM_ ) ) { attr Consuming Svc Index = new Integer ( index ) ; validate Attribute Consuming Service Index ( attr Consuming Svc Index ) ; } provider Name = element . get Attribute ( SAML 2 Constants . PROVIDER NAME ) ; }
final int batch For ( long b ) { long n ; if ( b == Long . MAX VALUE || ( n = sum Count ( ) ) <= NUM_ || n < b ) return NUM_ ; int sp = Fork Join Pool . get Common Pool Parallelism ( ) << NUM_ ; return ( b <= NUM_ || ( n /= b ) >= sp ) ? sp : ( int ) n ; }
private J Panel create QQ Plot Dialog ( Node selected ) { String dialog Title = STR_ ; J Panel panel = new J Panel ( ) ; panel . set Layout ( new Border Layout ( ) ) ; Data Set data Set = ( Data Set ) data Editor . get Selected Data Model ( ) ; QQ Plot qq Plot = new QQ Plot ( data Set , selected ) ; QQ Plot Editor Panel editor Panel = new QQ Plot Editor Panel ( qq Plot , data Set ) ; QQ Plot Display Panel display = new QQ Plot Display Panel ( qq Plot ) ; editor Panel . add Property Change Listener ( new QQ Plot Listener ( display ) ) ; J Menu Bar bar = new J Menu Bar ( ) ; J Menu menu = new J Menu ( STR_ ) ; menu . add ( new J Menu Item ( new Save Component Image ( display , STR_ ) ) ) ; bar . add ( menu ) ; Box box = Box . create Horizontal Box ( ) ; box . add ( display ) ; box . add ( Box . create Horizontal Strut ( NUM_ ) ) ; box . add ( editor Panel ) ; box . add ( Box . create Horizontal Strut ( NUM_ ) ) ; box . add ( Box . create Horizontal Glue ( ) ) ; Box v Box = Box . create Vertical Box ( ) ; v Box . add ( Box . create Vertical Strut ( NUM_ ) ) ; v Box . add ( box ) ; v Box . add ( Box . create Vertical Strut ( NUM_ ) ) ; panel . add ( bar , Border Layout . NORTH ) ; panel . add ( v Box , Border Layout . CENTER ) ; return panel ; }
public static File create Directory ( final String dir Name ) { File tmp Dir = new File ( dir Name ) ; if ( ! tmp Dir . mkdir ( ) && ! tmp Dir . exists ( ) ) { throw new Runtime Exception ( STR_ + dir Name + STR_ ) ; } return tmp Dir ; }
public Month Date Format ( ) { this ( Time Zone . get Default ( ) ) ; }
public void add Mouse Listener ( Mouse Listener m ) { bheader . add Mouse Listener ( m ) ; }
protected boolean update For Buffer Dimensions ( Projection proj ) { int current Rot Buffer Width = rot Buffer Width ; int current Rot Buffer Height = rot Buffer Height ; Point 2 D center = proj . get Center ( ) ; Point 2 D ul = proj . get Upper Left ( ) ; Point 2 D lr = proj . get Lower Right ( ) ; Geo center Geo = new Geo ( center . get Y ( ) , center . get X ( ) ) ; Geo ul Geo = new Geo ( ul . get Y ( ) , ul . get X ( ) ) ; Geo lr Geo = new Geo ( lr . get Y ( ) , lr . get X ( ) ) ; double dist = Math . max ( center Geo . distance ( ul Geo ) , center Geo . distance ( lr Geo ) ) ; Geo N = Geo . offset ( center Geo , dist , NUM_ ) ; Geo S = Geo . offset ( center Geo , dist , Math . PI ) ; Geo E = Geo . offset ( center Geo , dist , Math . PI / NUM_ ) ; Geo W = Geo . offset ( center Geo , dist , - Math . PI / NUM_ ) ; Point 2 D new UL = new Point 2 D . Double ( W . get Longitude ( ) , N . get Latitude ( ) ) ; Point 2 D new LR = new Point 2 D . Double ( E . get Longitude ( ) , S . get Latitude ( ) ) ; Point 2 D new UL Pix = proj . forward ( new UL ) ; Point 2 D new LR Pix = proj . forward ( new LR ) ; int req Rot Buffer Height = ( int ) Math . abs ( new LR Pix . get Y ( ) - new UL Pix . get Y ( ) ) ; int req Rot Buffer Width = ( int ) Math . abs ( new LR Pix . get X ( ) - new UL Pix . get X ( ) ) ; boolean need New Height Image = req Rot Buffer Height > current Rot Buffer Height || req Rot Buffer Height < NUM_ * current Rot Buffer Height ; boolean need New Width Image = req Rot Buffer Width > current Rot Buffer Width || current Rot Buffer Width < NUM_ * current Rot Buffer Width ; boolean buffer Image Resized = false ; if ( need New Height Image || need New Width Image ) { this . rot Image = new Buffered Image ( req Rot Buffer Width , req Rot Buffer Height , Buffered Image . TYPE INT ARGB ) ; rot Buffer Width = req Rot Buffer Width ; rot Buffer Height = req Rot Buffer Height ; buffer Image Resized = true ; } rot Projection = projection Factory . make Projection ( proj . get Class ( ) , center , proj . get Scale ( ) , rot Buffer Width , rot Buffer Height ) ; this . rot Center = rot Projection . forward ( center ) ; this . rot X Offset = ( rot Projection . get Width ( ) - proj . get Width ( ) ) / NUM_ ; this . rot Y Offset = ( rot Projection . get Height ( ) - proj . get Height ( ) ) / NUM_ ; return buffer Image Resized ; }
public void close ( ) throws Database Exception { try { connection . close ( ) ; } catch ( SQL Exception e ) { throw ( new Database Exception ( e ) ) ; } }
private void write Long Value Header ( Byte Buffer lval Page ) { lval Page . put ( Page Types . DATA ) ; lval Page . put ( ( byte ) NUM_ ) ; lval Page . put Short ( ( short ) get Format ( ) . DATA PAGE INITIAL FREE SPACE ) ; lval Page . put ( ( byte ) STR_ ) ; lval Page . put ( ( byte ) STR_ ) ; lval Page . put ( ( byte ) STR_ ) ; lval Page . put ( ( byte ) STR_ ) ; lval Page . put Int ( NUM_ ) ; lval Page . put Short ( ( short ) NUM_ ) ; }
public Byte read ( String value ) { return Byte . value Of ( value ) ; }
private void update Statistics ( ) { long current Time = System . current Time Millis ( ) ; double diff Time = current Time - last Time ; double diff Seed = current Seed - last Seed ; double diff NFE = current NFE - last NFE ; double percent Change = ( diff Seed + ( diff NFE / max NFE ) ) / total Seeds ; if ( ( diff Time > NUM_ ) && ( percent Change > NUM_ ) ) { statistics . add Value ( diff Time / percent Change ) ; last Time = current Time ; last Seed = current Seed ; last NFE = current NFE ; } }
public Key Store History ( Key Store key Store , File file , Password password ) { this . file = file ; this . name = file . get Name ( ) ; initial State = new Key Store State ( this , key Store , password ) ; current State = initial State ; saved State = initial State ; }
public void add If Not Present ( Annotation ann ) { if ( annotations == null || ! annotations . contains Key ( ann . annotation Type ( ) ) ) { add ( ann ) ; } }
public boolean compare ( Lexicon Impl other ) { return compare ( addenda , other . addenda ) && compare ( compiled , other . compiled ) ; }
@ Override protected void include Properties ( Set < Property > all Properties ) { super . include Properties ( all Properties ) ; nodes . for Each ( null ) ; }
private static int [ ] [ ] incidence Matrix ( Graph graph ) throws Illegal Argument Exception { List < Node > nodes = graph . get Nodes ( ) ; int [ ] [ ] m = new int [ nodes . size ( ) ] [ nodes . size ( ) ] ; for ( Edge edge : graph . get Edges ( ) ) { if ( ! Edges . is Directed Edge ( edge ) ) { throw new Illegal Argument Exception ( STR_ ) ; } } for ( int i = NUM_ ; i < nodes . size ( ) ; i ++ ) { for ( int j = NUM_ ; j < nodes . size ( ) ; j ++ ) { Node x 1 = nodes . get ( i ) ; Node x 2 = nodes . get ( j ) ; Edge edge = graph . get Edge ( x 1 , x 2 ) ; if ( edge == null ) { m [ i ] [ j ] = NUM_ ; } else if ( edge . get Proximal Endpoint ( x 1 ) == Endpoint . ARROW ) { m [ i ] [ j ] = NUM_ ; } else if ( edge . get Proximal Endpoint ( x 1 ) == Endpoint . TAIL ) { m [ i ] [ j ] = - NUM_ ; } } } return m ; }
private Template Value template Value ( String value ) { Template Value template Val = new Template File . Template Value ( null ) ; template Val . append ( value ) ; return template Val ; }
public void stop Trace ( ) { trace Enabled = false ; if ( mqtt != null ) { ; J Option Pane . show Message Dialog ( frame , STR_ , STR_ , J Option Pane . INFORMATION MESSAGE ) ; } }
protected < T extends Managed Entity > List < T > search Managed Entities ( Managed Entity parent , Class < T > type , boolean recurse ) throws VM Ware Exception { String type Name = type . get Simple Name ( ) ; List < T > results = Lists . new Array List ( ) ; for ( Managed Entity entity : search Managed Entities ( parent , type Name , recurse ) ) { results . add ( ( T ) entity ) ; } return results ; }
private void build Dom Tree ( ) { int sz Nodes = nodes . size ( ) ; for ( int i = NUM_ ; i < sz Nodes ; i ++ ) { Dom Info info = dom Infos [ i ] ; if ( info . idom == - NUM_ ) continue ; Ssa Basic Block dom Parent = nodes . get ( info . idom ) ; dom Parent . add Dom Child ( nodes . get ( i ) ) ; } }
public static List < Ip Permission > build Rules ( List < Allow > allow Rules ) { Array List < Ip Permission > aws Rules = new Array List < > ( ) ; for ( Allow rule : allow Rules ) { for ( String port : rule . ports ) { int from Port ; int to Port ; if ( port . contains ( STR_ ) ) { String [ ] ports = port . split ( STR_ ) ; from Port = Integer . parse Int ( ports [ NUM_ ] ) ; to Port = Integer . parse Int ( ports [ NUM_ ] ) ; } else { from Port = Integer . parse Int ( port ) ; to Port = from Port ; } aws Rules . add ( create Rule ( from Port , to Port , rule . ip Range , rule . protocol ) ) ; } } return aws Rules ; }
private String print X Format ( String sx ) { int n Leading Zeros = NUM_ ; int n Blanks = NUM_ ; if ( sx . equals ( STR_ ) && precision Set && precision == NUM_ ) sx = STR_ ; if ( precision Set ) n Leading Zeros = precision - sx . length ( ) ; if ( n Leading Zeros < NUM_ ) n Leading Zeros = NUM_ ; if ( field Width Set ) { n Blanks = field Width - n Leading Zeros - sx . length ( ) ; if ( alternate Form ) n Blanks = n Blanks - NUM_ ; } if ( n Blanks < NUM_ ) n Blanks = NUM_ ; int n = NUM_ ; if ( alternate Form ) n += NUM_ ; n += n Leading Zeros ; n += sx . length ( ) ; n += n Blanks ; char [ ] ca = new char [ n ] ; int i = NUM_ ; if ( left Justify ) { if ( alternate Form ) { ca [ i ++ ] = STR_ ; ca [ i ++ ] = STR_ ; } for ( int j = NUM_ ; j < n Leading Zeros ; j ++ , i ++ ) ca [ i ] = STR_ ; char [ ] csx = sx . to Char Array ( ) ; for ( int j = NUM_ ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; for ( int j = NUM_ ; j < n Blanks ; j ++ , i ++ ) ca [ i ] = STR_ ; } else { if ( ! leading Zeros ) for ( int j = NUM_ ; j < n Blanks ; j ++ , i ++ ) ca [ i ] = STR_ ; if ( alternate Form ) { ca [ i ++ ] = STR_ ; ca [ i ++ ] = STR_ ; } if ( leading Zeros ) for ( int j = NUM_ ; j < n Blanks ; j ++ , i ++ ) ca [ i ] = STR_ ; for ( int j = NUM_ ; j < n Leading Zeros ; j ++ , i ++ ) ca [ i ] = STR_ ; char [ ] csx = sx . to Char Array ( ) ; for ( int j = NUM_ ; j < csx . length ; j ++ , i ++ ) ca [ i ] = csx [ j ] ; } String ca Return = new String ( ca ) ; if ( conversion Character == STR_ ) ca Return = ca Return . to Upper Case ( ) ; return ca Return ; }
private void generate Java File ( ) throws IO Exception { Custom Logger . log ( STR_ + java File Name ) ; File main Activity File = new File ( java Folder , java File Name ) ; Buffered Writer main Activity BW = create It ( main Activity File ) ; Custom Logger . log ( STR_ + main Activity File . get Absolute Path ( ) ) ; main Activity BW . write ( java Code ) ; main Activity BW . flush ( ) ; main Activity BW . close ( ) ; Custom Logger . log ( STR_ + main Layout Name ) ; File main Layout File = new File ( java Folder , main Layout Name ) ; Buffered Writer main Layout BW = create It ( main Layout File ) ; Custom Logger . log ( STR_ + main Layout File . get Absolute Path ( ) ) ; main Layout BW . write ( layout Content ) ; main Layout BW . flush ( ) ; main Layout BW . close ( ) ; }
public String reverse Vowels ( String s ) { if ( s == null || s . is Empty ( ) ) return s ; String Builder sb = new String Builder ( s ) ; String vowels = STR_ ; int i = NUM_ ; int j = s . length ( ) - NUM_ ; while ( i < j ) { while ( i < j && vowels . index Of ( s . char At ( i ) ) == - NUM_ ) { i ++ ; } while ( i < j && vowels . index Of ( s . char At ( j ) ) == - NUM_ ) { j -- ; } char c = sb . char At ( i ) ; sb . set Char At ( i , sb . char At ( j ) ) ; sb . set Char At ( j , c ) ; i ++ ; j -- ; } return sb . to String ( ) ; }
public void p 2 director ( Action < Director App > director Modifier ) { this . director Modifier = Objects . require Non Null ( director Modifier ) ; }
private static void load Files Path ( Context context ) { if ( context != null ) { try { File file = context . get Files Dir ( ) ; if ( file != null ) { Crash Constants . FILES PATH = file . get Absolute Path ( ) ; } } catch ( Exception e ) { L . e ( STR_ ) ; e . print Stack Trace ( ) ; } } }
public synchronized int assign New Local Id ( ) { local Id = local Event Id . increment And Get ( ) ; return local Id ; }
public static Configuration Directory download Configuration ( final String path , final String source Anchor ) throws Exception { Process Builder pb = new Process Builder ( Conf Proxy Properties . get Download Script Path ( ) , source Anchor , path ) ; pb . redirect Error Stream ( true ) ; pb . redirect Output ( Process Builder . Redirect . INHERIT ) ; log . debug ( STR_ , Conf Proxy Properties . get Download Script Path ( ) , source Anchor , path ) ; run Conf Client ( pb ) ; return new Configuration Directory ( path ) ; }
@ Rpc Method public void power Vm Op ( String vm Id , Power Vm Op op , Async Method Callback < Host . Async Client . power vm op call > handler ) throws Rpc Exception { ensure Client ( ) ; Power Vm Op Request power Vm Op Request = new Power Vm Op Request ( vm Id , op ) ; client Proxy . set Timeout ( POWER VM OP TIMEOUT MS ) ; logger . info ( STR_ , vm Id , get Host Ip ( ) , power Vm Op Request ) ; try { client Proxy . power vm op ( power Vm Op Request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public double local Score ( int i , int parent ) { double sum = NUM_ ; int count = NUM_ ; for ( Sem Bic Score score : sem Bic Scores ) { double score = score . local Score ( i , parent ) ; if ( ! Double . is Na N ( score ) ) { sum += score ; count ++ ; } } return sum / count ; }
public D Sign Csr ( J Frame parent , Spkac spkac Csr , File csr File , Private Key sign Private Key , Key Pair Type sign Key Pair Type , X 509 Certificate verification Certificate , Provider provider ) throws Crypto Exception { super ( parent , Dialog . Modality Type . DOCUMENT MODAL ) ; this . spkac Csr = spkac Csr ; this . csr File = csr File ; this . sign Private Key = sign Private Key ; this . sign Key Pair Type = sign Key Pair Type ; this . verification Certificate = verification Certificate ; this . provider = provider ; set Title ( res . get String ( STR_ ) ) ; init Components ( ) ; }
public void update Drawing Limits ( Rectangle 2 D drawing ) { int xmin = ( int ) ( drawing . get X ( ) - ( drawing . get Width ( ) / NUM_ ) ) ; int xmax = xmin + ( int ) ( drawing . get Width ( ) * NUM_ ) ; xpos Input . set Limits ( xmin , xmax ) ; int ymin = ( int ) ( drawing . get Y ( ) - ( drawing . get Height ( ) / NUM_ ) ) ; int ymax = ymin + ( int ) ( drawing . get Height ( ) * NUM_ ) ; ypos Input . set Limits ( ymin , ymax ) ; }
public void remove ( Chip chip ) { m Chip List . remove ( chip ) ; notify Update ( ) ; }
private void print LIR ( Abstract Block Base < ? > block ) { if ( lir == null ) { return ; } List < LIR Instruction > lir Instructions = lir . get LI Rfor Block ( block ) ; if ( lir Instructions == null ) { return ; } begin ( STR_ ) ; out . println ( STR_ ) ; for ( int i = NUM_ ; i < lir Instructions . size ( ) ; i ++ ) { LIR Instruction inst = lir Instructions . get ( i ) ; print LIR Instruction ( inst ) ; } end ( STR_ ) ; }
private List < Node > create Node List From Data Items ( List < ? > data Items , Node parent ) { List < Node > result = new Array List < > ( ) ; if ( data Items != null ) { for ( Object data Item : data Items ) { boolean is Expandable = is Expandable ( data Item ) ; Node node = new Node ( data Item , parent ) ; node . set Expandable ( is Expandable ) ; if ( m View . is Always Expanded ( ) && is Expandable ) { node . set Sub Nodes ( create Node List From Data Items ( get Sub Objects ( node . get Object ( ) ) , node ) ) ; } result . add ( node ) ; } } return result ; }
public void put Type Description ( String extension , String type Description ) { type Descriptions . put ( extension , type Description ) ; }
private static String convert Token ( final String token , final String arg 1 ) { if ( ! String Utils . is Number ( arg 1 ) ) { return STR_ ; } final double value = Double . parse Double ( arg 1 ) ; int decimal Points = - NUM_ , min Width = NUM_ ; char decimal = STR_ ; boolean padd = false , float Decimal = false ; final String Builder s Value = new String Builder ( ) ; final String Builder return String = new String Builder ( ) ; final char [ ] tok Array = token . to Char Array ( ) ; if ( tok Array [ NUM_ ] == STR_ ) { int i = NUM_ ; final int size = tok Array . length ; loop : while ( i < size ) { switch ( tok Array [ i ] ) { case STR_ : switch ( tok Array [ ++ i ] ) { case STR_ : decimal = STR_ ; break ; case STR_ : decimal = STR_ ; break ; case STR_ : decimal = STR_ ; break ; case STR_ : decimal = STR_ ; break ; } break ; case STR_ : if ( value > NUM_ ) { return String . append ( STR_ ) ; } else { return String . append ( STR_ ) ; } break ; case STR_ : if ( value > NUM_ ) { return String . append ( STR_ ) ; } else { return String . append ( STR_ ) ; } break ; case STR_ : padd = true ; break ; case STR_ : float Decimal = true ; break ; case STR_ : decimal Points = Integer . parse Int ( String . value Of ( tok Array [ ++ i ] ) ) ; break ; case STR_ : s Value . append ( ( int ) value ) ; if ( padd ) { final int stringlen = return String . length ( ) + s Value . length ( ) ; if ( stringlen < min Width ) { for ( int p = NUM_ ; p < min Width - stringlen ; p ++ ) { return String . append ( STR_ ) ; } } } return String . append ( s Value ) ; break loop ; case STR_ : if ( decimal Points != - NUM_ ) { if ( decimal Points == NUM_ ) { s Value . append ( ( int ) value ) ; } else { final Number Format nf = Number Format . get Instance ( ) ; nf . set Minimum Fraction Digits ( decimal Points ) ; nf . set Maximum Fraction Digits ( decimal Points ) ; s Value . append ( nf . format ( value ) ) ; } } else { s Value . append ( ( float ) value ) ; } if ( float Decimal && s Value . index Of ( STR_ ) != - NUM_ ) { s Value . append ( STR_ ) ; } if ( padd ) { final int stringlen = return String . length ( ) + s Value . length ( ) ; if ( stringlen < min Width ) { for ( int p = NUM_ ; p < min Width - stringlen ; p ++ ) { return String . append ( STR_ ) ; } } } String ss Val = s Value . to String ( ) ; ss Val = ss Val . replace ( STR_ , decimal ) ; return String . append ( ss Val ) ; break loop ; case STR_ : s Value . append ( value ) ; if ( padd ) { final int stringlen = return String . length ( ) + s Value . length ( ) ; if ( stringlen < min Width ) { for ( int p = NUM_ ; p < min Width - stringlen ; p ++ ) { return String . append ( STR_ ) ; } } } return String . append ( s Value ) ; break loop ; case STR_ : final int val I = ( int ) ( value ) ; final String ret Val S = Integer . to Hex String ( val I ) ; s Value . append ( ret Val S ) ; if ( padd ) { final int stringlen = return String . length ( ) + s Value . length ( ) ; if ( stringlen < min Width ) { for ( int p = NUM_ ; p < min Width - stringlen ; p ++ ) { return String . append ( STR_ ) ; } } } return String . append ( s Value ) ; break loop ; default : min Width = Number Utils . parse Int ( NUM_ , NUM_ , new byte [ ] { ( byte ) tok Array [ i ] } ) ; break ; } i ++ ; } } return return String . to String ( ) ; }
@ Suppress Warnings ( STR_ ) private boolean scan Version Line ( String line ) { if ( line != null ) { Matcher matcher = s Adb Version . matcher ( line ) ; if ( matcher . matches ( ) ) { int major Version = Integer . parse Int ( matcher . group ( NUM_ ) ) ; int minor Version = Integer . parse Int ( matcher . group ( NUM_ ) ) ; int micro Version = Integer . parse Int ( matcher . group ( NUM_ ) ) ; if ( micro Version < ADB VERSION MICRO MIN ) { String message = String . format ( STR_ + STR_ , major Version , minor Version , ADB VERSION MICRO MIN , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else if ( ADB VERSION MICRO MAX != - NUM_ && micro Version > ADB VERSION MICRO MAX ) { String message = String . format ( STR_ + STR_ , major Version , minor Version , ADB VERSION MICRO MAX , micro Version ) ; Log . log And Display ( Log Level . ERROR , ADB , message ) ; } else { m Version Check = true ; } return true ; } } return false ; }
public Capabilities ( Capabilities Handler owner ) { super ( ) ; set Owner ( owner ) ; m Capabilities = new Hash Set < Capability > ( ) ; m Dependencies = new Hash Set < Capability > ( ) ; if ( do Not Check Capabilities ( ) ) { return ; } if ( PROPERTIES == null ) { try { PROPERTIES = Utils . read Properties ( PROPERTIES FILE ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; PROPERTIES = new Properties ( ) ; } } m Test = Boolean . parse Boolean ( PROPERTIES . get Property ( STR_ , STR_ ) ) ; m Instances Test = Boolean . parse Boolean ( PROPERTIES . get Property ( STR_ , STR_ ) ) && m Test ; m Attribute Test = Boolean . parse Boolean ( PROPERTIES . get Property ( STR_ , STR_ ) ) && m Test ; m Missing Values Test = Boolean . parse Boolean ( PROPERTIES . get Property ( STR_ , STR_ ) ) && m Test ; m Missing Class Values Test = Boolean . parse Boolean ( PROPERTIES . get Property ( STR_ , STR_ ) ) && m Test ; m Minimum Number Instances Test = Boolean . parse Boolean ( PROPERTIES . get Property ( STR_ , STR_ ) ) && m Test ; if ( owner instanceof weka . classifiers . Updateable Classifier || owner instanceof weka . clusterers . Updateable Clusterer ) { set Minimum Number Instances ( NUM_ ) ; } }
public static void wait ( Object obj ) { synchronized ( obj ) { try { obj . wait ( ) ; } catch ( Interrupted Exception inex ) { } } }
public static int calculate In Sample Size ( int src Width , int src Height , int req Width , int req Height ) { if ( ( req Height > NUM_ ) && ( req Width > NUM_ ) && ( src Height > req Height ) && ( src Width > req Width ) ) { return Math . min ( src Width / req Width , src Height / req Height ) ; } else { return NUM_ ; } }
public N node ( Object key , Collection < N > inc ) { return node ( key , inc , null ) ; }
public void on Save Instance State ( Bundle out State ) { out State . put Int ( EXTRA TAG COUNT , m Tag Count ) ; out State . put Int ( EXTRA SELECTED TAB INDEX , m Selected Tab Index ) ; if ( m Current Frag != null ) { out State . put String ( EXTRA CURRENT FRAGMENT , m Current Frag . get Tag ( ) ) ; } try { final JSON Array stack Arrays = new JSON Array ( ) ; for ( Stack < Fragment > stack : m Fragment Stacks ) { final JSON Array stack Array = new JSON Array ( ) ; for ( Fragment fragment : stack ) { stack Array . put ( fragment . get Tag ( ) ) ; } stack Arrays . put ( stack Array ) ; } out State . put String ( EXTRA FRAGMENT STACK , stack Arrays . to String ( ) ) ; } catch ( Throwable t ) { } }
private void onget Token Btn Clicked ( final Action Event ignored ) { token Field . set Disable ( false ) ; Browser . open Url ( Google User Credential Provider . LOGIN URL ) ; }
protected char check Zone ( char zone ) { zone = Character . to Upper Case ( zone ) ; if ( zone <= STR_ || zone == STR_ || zone == STR_ || zone >= STR_ || zone == STR_ || zone == STR_ ) { throw new Number Format Exception ( STR_ + zone ) ; } return zone ; }
public void run Finalization ( ) { return ; }
protected void init View ( ) { m Month Title Paint = new Paint ( ) ; m Month Title Paint . set Fake Bold Text ( true ) ; m Month Title Paint . set Anti Alias ( true ) ; m Month Title Paint . set Text Size ( MONTH LABEL TEXT SIZE ) ; m Month Title Paint . set Typeface ( Typeface . create ( m Month Title Typeface , Typeface . BOLD ) ) ; m Month Title Paint . set Color ( m Day Text Color ) ; m Month Title Paint . set Text Align ( Align . CENTER ) ; m Month Title Paint . set Style ( Style . FILL ) ; m Month Title BG Paint = new Paint ( ) ; m Month Title BG Paint . set Fake Bold Text ( true ) ; m Month Title BG Paint . set Anti Alias ( true ) ; m Month Title BG Paint . set Color ( m Month Title BG Color ) ; m Month Title BG Paint . set Text Align ( Align . CENTER ) ; m Month Title BG Paint . set Style ( Style . FILL ) ; m Selected Circle Paint = new Paint ( ) ; m Selected Circle Paint . set Fake Bold Text ( true ) ; m Selected Circle Paint . set Anti Alias ( true ) ; m Selected Circle Paint . set Color ( m Today Number Color ) ; m Selected Circle Paint . set Text Align ( Align . CENTER ) ; m Selected Circle Paint . set Style ( Style . FILL ) ; m Selected Circle Paint . set Alpha ( SELECTED CIRCLE ALPHA ) ; m Month Day Label Paint = new Paint ( ) ; m Month Day Label Paint . set Anti Alias ( true ) ; m Month Day Label Paint . set Text Size ( MONTH DAY LABEL TEXT SIZE ) ; m Month Day Label Paint . set Color ( m Day Text Color ) ; m Month Day Label Paint . set Typeface ( Typeface . create ( m Day Of Week Typeface , Typeface . NORMAL ) ) ; m Month Day Label Paint . set Style ( Style . FILL ) ; m Month Day Label Paint . set Text Align ( Align . CENTER ) ; m Month Day Label Paint . set Fake Bold Text ( true ) ; m Month Num Paint = new Paint ( ) ; m Month Num Paint . set Anti Alias ( true ) ; m Month Num Paint . set Text Size ( MINI DAY NUMBER TEXT SIZE ) ; m Month Num Paint . set Style ( Style . FILL ) ; m Month Num Paint . set Text Align ( Align . CENTER ) ; m Month Num Paint . set Fake Bold Text ( false ) ; }
private void post Init View Pager ( ) { try { Class < ? > viewpager = View Pager . class ; Field scroller = viewpager . get Declared Field ( STR_ ) ; scroller . set Accessible ( true ) ; Field interpolator = viewpager . get Declared Field ( STR_ ) ; interpolator . set Accessible ( true ) ; m Scroller = new Carousel View Pager Scroller ( get Context ( ) , ( Interpolator ) interpolator . get ( null ) ) ; scroller . set ( this , m Scroller ) ; } catch ( Exception e ) { } }
public void write External ( Object Output out ) throws IO Exception { Remote Ref local Ref = ref ; out . write Object ( id ) ; if ( local Ref == null ) { out . write UTF ( STR_ ) ; } else { out . write UTF ( local Ref . get Ref Class ( out ) ) ; local Ref . write External ( out ) ; } }
private void initialize ( ) { Hash Map < Object , GV Congruence Class > label Map = new Hash Map < Object , GV Congruence Class > ( NUM_ ) ; for ( Enumeration < Graph Node > e = value Graph . enumerate Vertices ( ) ; e . has More Elements ( ) ; ) { Value Graph Vertex v = ( Value Graph Vertex ) e . next Element ( ) ; Object label = v . get Label ( ) ; GV Congruence Class c = find Or Create Congruence Class ( label , label Map ) ; c . add Vertex ( v ) ; v . set Value Number ( c . get Value Number ( ) ) ; } }
public Index Shard Routing Table ( Shard Id shard Id , Shard Routing shard ) { List < Shard Routing > singleton = Collections . singleton List ( shard ) ; this . shard Id = shard Id ; this . shards = singleton ; this . all Shards Started = shard . started ( ) ; this . primary = shard ; this . primary As List = singleton ; this . replicas = EMPTY LIST ; this . active Shards = ( shard . active ( ) ) ? singleton : EMPTY LIST ; this . all Initializing Shards = ( shard . initializing ( ) ) ? singleton : EMPTY LIST ; this . assigned Shards = ( shard . assigned To Node ( ) ) ? singleton : EMPTY LIST ; this . shuffler = DUMMY SHARD SHUFFLER ; }
private void request Streams Info 2 ( Set < String > streams , boolean special ) { Set < String > streams For Request = new Hash Set < > ( ) ; Set < Stream Info > stream Infos For Request = new Hash Set < > ( ) ; for ( String stream : streams ) { Stream Info cached = get Stream Info ( stream ) ; if ( ! cached . is Requested ( ) && ( ! special || cached . recheck Offline ( ) ) ) { streams For Request . add ( stream ) ; stream Infos For Request . add ( cached ) ; cached . set Requested ( ) ; } } if ( special ) { special Check Last Done = System . current Time Millis ( ) ; } if ( ! streams For Request . is Empty ( ) ) { if ( ! special ) { streams Info Last Requested = System . current Time Millis ( ) ; } String url = api . request Streams Info ( streams For Request ) ; pending Requests . put ( url , stream Infos For Request ) ; } }
public static double binomial Standard Error ( double p , int n ) { if ( n == NUM_ ) { return NUM_ ; } return Math . sqrt ( ( p * ( NUM_ - p ) ) / n ) ; }
public double calculate Weight ( int trooper ) { double weight = NUM_ ; weight += get Weight Structure ( ) ; weight += get Weight Armor ( ) ; weight += get Weight Misc Equip ( trooper ) ; weight += get Weight Weapon ( trooper ) ; weight += get Weight Ammo ( trooper ) ; return Math . round ( weight * NUM_ ) / NUM_ ; }
@ POST @ Consumes ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Produces ( { Media Type . APPLICATION XML , Media Type . APPLICATION JSON } ) @ Path ( STR_ ) @ Check Permission ( roles = { Role . TENANT ADMIN } ) public Task List discover Array Affinity For Hosts ( Array Affinity Host Param param ) { List < URI > host Ids = param . get Hosts ( ) ; Arg Validator . check Field Not Empty ( host Ids , STR_ ) ; for ( URI host Id : host Ids ) { Arg Validator . check Field Uri Type ( host Id , Host . class , STR_ ) ; query Object ( Host . class , host Id , true ) ; } return create Host Array Affinity Tasks ( host Ids ) ; }
public Rect update Fast Scroller Bounds ( int last Touch Y ) { m Invalidate Rect . set ( m Bg Bounds ) ; if ( is Visible ( ) ) { int edge Padding = m Rv . get Max Scrollbar Width ( ) ; int bg Padding = ( m Bg Original Size - m Text Bounds . height ( ) ) / NUM_ ; int bg Height = m Bg Original Size ; int bg Width = Math . max ( m Bg Original Size , m Text Bounds . width ( ) + ( NUM_ * bg Padding ) ) ; if ( Utilities . is Rtl ( m Res ) ) { m Bg Bounds . left = m Rv . get Background Padding ( ) . left + ( NUM_ * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . right = m Bg Bounds . left + bg Width ; } else { m Bg Bounds . right = m Rv . get Width ( ) - m Rv . get Background Padding ( ) . right - ( NUM_ * m Rv . get Max Scrollbar Width ( ) ) ; m Bg Bounds . left = m Bg Bounds . right - bg Width ; } m Bg Bounds . top = last Touch Y - ( int ) ( FAST SCROLL OVERLAY Y OFFSET FACTOR * bg Height ) ; m Bg Bounds . top = Math . max ( edge Padding , Math . min ( m Bg Bounds . top , m Rv . get Height ( ) - edge Padding - bg Height ) ) ; m Bg Bounds . bottom = m Bg Bounds . top + bg Height ; } else { m Bg Bounds . set Empty ( ) ; } m Invalidate Rect . union ( m Bg Bounds ) ; return m Invalidate Rect ; }
public String title String ( ) { return title String ( get Model ( ) , get Family ( ) ) ; }
public static String extract Addr Spec ( String address ) { Matcher match = NAME ADDR EMAIL PATTERN . matcher ( address ) ; if ( match . matches ( ) ) { return match . group ( NUM_ ) ; } return address ; }
boolean user OK ( String entry ) { String [ ] titles = { STR_ , STR_ } ; return ( J Option Pane . YES OPTION == J Option Pane . show Option Dialog ( who , STR_ + entry + STR_ , STR_ + entry + STR_ , J Option Pane . YES NO OPTION , J Option Pane . QUESTION MESSAGE , null , titles , null ) ) ; }
public static String make Link ( File Descriptor fd , boolean new Window , boolean attachment ) { String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; sb . append ( make Url ( fd , attachment ) ) ; sb . append ( STR_ ) ; if ( new Window ) sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( fd . get Name ( ) ) ; sb . append ( STR_ ) ; return sb . to String ( ) ; }
public void do Initiator Alias Set ( Storage System storage , Initiator initiator , String initiator Alias ) throws Exception { try { check If Provider Supports Alias Operations ( storage ) ; CIM Object Path hw Management ID Svc Path = cim Path . get Storage Hardware ID Management Service ( storage ) ; CIM Object Path shid Path = get SHID Path For Alias Operation ( storage , hw Management ID Svc Path , initiator ) ; CIM Argument [ ] in Args = helper . get EMC Initiator Alias Set Args ( shid Path , initiator Alias ) ; CIM Argument [ ] out Args = new CIM Argument [ NUM_ ] ; helper . invoke Method ( storage , hw Management ID Svc Path , Smis Constants . INITIATOR ALIAS SET , in Args , out Args ) ; } catch ( WBEM Exception e ) { log . error ( STR_ , e ) ; throw e ; } catch ( Exception e ) { log . error ( STR_ , e ) ; throw e ; } }
public static void collect Application Servlet Stats ( Context context , Application app ) { int svlt Count = NUM_ ; int req Count = NUM_ ; int err Count = NUM_ ; long proc Time = NUM_ ; long min Time = Long . MAX VALUE ; long max Time = NUM_ ; for ( Container container : context . find Children ( ) ) { if ( container instanceof Standard Wrapper ) { Standard Wrapper sw = ( Standard Wrapper ) container ; svlt Count ++ ; req Count += sw . get Request Count ( ) ; err Count += sw . get Error Count ( ) ; proc Time += sw . get Processing Time ( ) ; if ( sw . get Request Count ( ) > NUM_ ) { min Time = Math . min ( min Time , sw . get Min Time ( ) ) ; } max Time = Math . max ( max Time , sw . get Max Time ( ) ) ; } } app . set Servlet Count ( svlt Count ) ; app . set Request Count ( req Count ) ; app . set Error Count ( err Count ) ; app . set Processing Time ( proc Time ) ; app . set Min Time ( min Time == Long . MAX VALUE ? NUM_ : min Time ) ; app . set Max Time ( max Time ) ; }
private byte [ ] generate Nonce ( ) { byte [ ] nonce = new byte [ NUM_ ] ; Secure Random secure Random = new Secure Random ( ) ; secure Random . next Bytes ( nonce ) ; return nonce ; }
private Replace Tokens . Token create Rmi Port Token ( ) { if ( get Property Value ( General Property Set . RMI PORT ) == null ) { configuration . set Property ( General Property Set . RMI PORT , STR_ ) ; } String rmi Port = get Property Value ( General Property Set . RMI PORT ) ; Replace Tokens . Token token Rmi Port = new Replace Tokens . Token ( ) ; token Rmi Port . set Key ( General Property Set . RMI PORT ) ; token Rmi Port . set Value ( rmi Port ) ; return token Rmi Port ; }
public static Script create P 2 SH Output Script ( Script redeem Script ) { byte [ ] hash = Utils . sha 256 hash 160 ( redeem Script . get Program ( ) ) ; return Script Builder . create P 2 SH Output Script ( hash ) ; }
public static void close ( ) throws Illegal State Exception { Realm realm = realm Cache . get ( ) ; if ( realm == null ) { throw new Illegal State Exception ( STR_ ) ; } realm . close ( ) ; realm Cache . set ( null ) ; }
private boolean can Change Announcement ( Legion Member legion Member , String announcement ) { return legion Member . has Rights ( Legion Permissions Mask . EDIT ) && ( announcement . is Empty ( ) || is Valid Announcement ( announcement ) ) ; }
public void join ( Pla Point Float p point ) { lx = Math . min ( p point . v x , lx ) ; ly = Math . min ( p point . v y , ly ) ; rx = Math . max ( rx , p point . v x ) ; uy = Math . max ( uy , p point . v y ) ; double tmp = p point . v x - p point . v y ; ulx = Math . min ( ulx , tmp ) ; lrx = Math . max ( lrx , tmp ) ; tmp = p point . v x + p point . v y ; llx = Math . min ( llx , tmp ) ; urx = Math . max ( urx , tmp ) ; }
public void destroy Scene ( ) { clear Animations ( ) ; clear Cameras ( ) ; clear Lights ( ) ; clear Plugins ( ) ; clear Children ( ) ; clear Frame Callbacks ( ) ; }
public void swap Directory ( OC File directory , File Data Storage Manager updated Storage Manager , boolean only On Device ) { if ( updated Storage Manager != null && updated Storage Manager != m Storage Manager ) { m Storage Manager = updated Storage Manager ; m Account = Account Utils . get Current Own Cloud Account ( m Context ) ; } if ( m Storage Manager != null ) { m Files = m Storage Manager . get Folder Content ( directory , only On Device ) ; if ( m Just Folders ) { m Files = get Folders ( m Files ) ; } if ( ! m Show Hidden Files ) { m Files = filter Hidden Files ( m Files ) ; } } else { m Files = null ; } m Files = File Storage Utils . sort Oc Folder ( m Files ) ; m Files All . clear ( ) ; m Files All . add All ( m Files ) ; notify Data Set Changed ( ) ; }
@ Override public synchronized void flush ( ) throws IO Exception { check Not Closed ( ) ; flush Internal ( ) ; out . flush ( ) ; }
private void hide Object ( ) { float [ ] rotation Matrix = new float [ NUM_ ] ; float [ ] pos Vec = new float [ NUM_ ] ; float angle XZ = ( float ) Math . random ( ) * NUM_ + NUM_ ; Matrix . set Rotate M ( rotation Matrix , NUM_ , angle XZ , NUM_ , NUM_ , NUM_ ) ; float old Object Distance = object Distance ; object Distance = ( float ) Math . random ( ) * ( MAX MODEL DISTANCE - MIN MODEL DISTANCE ) + MIN MODEL DISTANCE ; float object Scaling Factor = object Distance / old Object Distance ; Matrix . scale M ( rotation Matrix , NUM_ , object Scaling Factor , object Scaling Factor , object Scaling Factor ) ; Matrix . multiply MV ( pos Vec , NUM_ , rotation Matrix , NUM_ , model Cube , NUM_ ) ; float angle Y = ( float ) Math . random ( ) * NUM_ - NUM_ ; angle Y = ( float ) Math . to Radians ( angle Y ) ; float new Y = ( float ) Math . tan ( angle Y ) * object Distance ; model Position [ NUM_ ] = pos Vec [ NUM_ ] ; model Position [ NUM_ ] = new Y ; model Position [ NUM_ ] = pos Vec [ NUM_ ] ; update Model Position ( ) ; }
public static Telegram Bot login ( String auth Token ) { try { Http Request With Body request = Unirest . post ( API URL + STR_ + auth Token + STR_ ) ; Http Response < String > response = request . as String ( ) ; JSON Object json Response = Utils . process Response ( response ) ; if ( json Response != null && Utils . check Response Status ( json Response ) ) { JSON Object result = json Response . get JSON Object ( STR_ ) ; return new Telegram Bot ( auth Token , result . get Int ( STR_ ) , result . get String ( STR_ ) , result . get String ( STR_ ) ) ; } } catch ( Unirest Exception e ) { e . print Stack Trace ( ) ; } return null ; }
private void check Basic Constraints ( X 509 Certificate curr Cert ) throws Cert Path Validator Exception { String msg = STR_ ; if ( debug != null ) { debug . println ( STR_ + msg + STR_ ) ; debug . println ( STR_ + i + STR_ + max Path Length ) ; } if ( i < cert Path Length ) { int path Len Constraint = - NUM_ ; if ( curr Cert . get Version ( ) < NUM_ ) { if ( i == NUM_ ) { if ( X 509 Cert Impl . is Self Issued ( curr Cert ) ) { path Len Constraint = Integer . MAX VALUE ; } } } else { path Len Constraint = curr Cert . get Basic Constraints ( ) ; } if ( path Len Constraint == - NUM_ ) { throw new Cert Path Validator Exception ( msg + STR_ , null , null , - NUM_ , PKIX Reason . NOT CA CERT ) ; } if ( ! X 509 Cert Impl . is Self Issued ( curr Cert ) ) { if ( max Path Length <= NUM_ ) { throw new Cert Path Validator Exception ( msg + STR_ + STR_ + STR_ , null , null , - NUM_ , PKIX Reason . PATH TOO LONG ) ; } max Path Length -- ; } if ( path Len Constraint < max Path Length ) max Path Length = path Len Constraint ; } if ( debug != null ) { debug . println ( STR_ + max Path Length ) ; debug . println ( msg + STR_ ) ; } }
Rules ( Workspace workspace ) { this . root = workspace . get Root ( ) ; this . team Hook = workspace . get Team Hook ( ) ; workspace . add Lifecycle Listener ( this ) ; }
public Pla Line Int plaline ( int index ) { return lines list . get ( index ) ; }
@ Override public void init Params ( final Http Servlet Request request , final I Configuration configuration , final Object ... params ) throws Connector Exception { super . init Params ( request , configuration , params ) ; this . ck Finder Func Num = request . get Parameter ( STR_ ) ; this . ck Editor Func Num = request . get Parameter ( STR_ ) ; this . response Type = request . get Parameter ( STR_ ) ; this . lang Code = request . get Parameter ( STR_ ) ; if ( this . error Code == Constants . Errors . CKFINDER CONNECTOR ERROR NONE ) { this . uploaded = upload File ( request ) ; } }
private Long calculate Reserved Capacity ( ) { Long reserved Capacity = NUM_ ; if ( reserved Capacity Map != null ) { Collection < String > capacity Collection = reserved Capacity Map . values ( ) ; for ( String capacity : capacity Collection ) { reserved Capacity = reserved Capacity + Long . value Of ( capacity ) ; } } Long reserved Capacity KB = ( reserved Capacity % KB == NUM_ ) ? reserved Capacity / KB : reserved Capacity / KB + NUM_ ; return reserved Capacity KB ; }
public void add Content Child ( FXG Node child ) { if ( child instanceof Paragraph Node || child instanceof BR Node || child instanceof Span Node || child instanceof CDATA Node ) { if ( content == null ) { content = new Array List < Text Node > ( ) ; contiguous = true ; } if ( ! contiguous ) { throw new FXG Exception ( child . get Start Line ( ) , child . get Start Column ( ) , STR_ ) ; } content . add ( ( Text Node ) child ) ; } }
private static int uarimin Ge ( double value , double [ ] bv , int [ ] bvi , Binary Operator b Op ) throws DML Runtime Exception { int ix Min = NUM_ ; if ( value <= bv [ NUM_ ] || value > bv [ bv . length - NUM_ ] ) return ix Min ; int ix = Arrays . binary Search ( bv , value ) ; if ( ix < NUM_ ) ix = Math . abs ( ix ) - NUM_ ; ix Min = bvi [ ix - NUM_ ] + NUM_ ; return ix Min ; }
void adjust Selection ( J Editor Pane pane , HTML Document doc , int start Offset , int old Length ) { int new Length = doc . get Length ( ) ; if ( new Length != old Length && start Offset < new Length ) { if ( start Offset > NUM_ ) { String text ; try { text = doc . get Text ( start Offset - NUM_ , NUM_ ) ; } catch ( Bad Location Exception ble ) { text = null ; } if ( text != null && text . length ( ) > NUM_ && text . char At ( NUM_ ) == STR_ ) { pane . select ( start Offset , start Offset ) ; } else { pane . select ( start Offset + NUM_ , start Offset + NUM_ ) ; } } else { pane . select ( NUM_ , NUM_ ) ; } } }
private boolean key Match ( String key , Lazy Node token ) { if ( token . type == Lazy Node . EFIELD ) { String field = token . get String Value ( cbuf ) ; return field . equals ( key ) ; } else { int length = key . length ( ) ; if ( token . end Index - token . start Index != length ) { return false ; } for ( int i = NUM_ ; i < length ; i ++ ) { char c = key . char At ( i ) ; if ( c != cbuf [ token . start Index + i ] ) { return false ; } } return true ; } }
protected Polygon make Hull ( double [ ] [ ] pc ) { Graham Scan Convex Hull 2 D hull = new Graham Scan Convex Hull 2 D ( ) ; double [ ] diag = new double [ ] { NUM_ , NUM_ } ; for ( int j = NUM_ ; j < pc . length ; j ++ ) { hull . add ( pc [ j ] ) ; hull . add ( times ( pc [ j ] , - NUM_ ) ) ; for ( int k = j + NUM_ ; k < pc . length ; k ++ ) { double [ ] q = pc [ k ] ; double [ ] ppq = times Equals ( plus ( pc [ j ] , q ) , Math Util . SQRTHALF ) ; double [ ] pmq = times Equals ( minus ( pc [ j ] , q ) , Math Util . SQRTHALF ) ; hull . add ( ppq ) ; hull . add ( times ( ppq , - NUM_ ) ) ; hull . add ( pmq ) ; hull . add ( times ( pmq , - NUM_ ) ) ; } plus Equals ( diag , pc [ j ] ) ; } times Equals ( diag , NUM_ / Math . sqrt ( pc . length ) ) ; hull . add ( diag ) ; hull . add ( times ( diag , - NUM_ ) ) ; return hull . get Hull ( ) ; }
public String add Highlight ( String channel , String comment ) { if ( channel == null || channel . is Empty ( ) || ! Helper . is Regular Channel ( channel ) ) { return STR_ ; } Stream Info stream Info = api . get Stream Info ( Helper . to Stream ( channel ) , null ) ; String stream Time = STR_ ; if ( stream Info . is Valid ( ) && stream Info . get Online ( ) ) { stream Time = Date Time . ago ( stream Info . get Time Started ( ) ) ; } if ( comment == null ) { comment = STR_ ; } String line = String . format ( STR_ , Date Time . full Date Time ( ) , channel , stream Time , comment ) ; synchronized ( this ) { if ( stream Info . get Time Started ( ) != last Stream Start Written ) { add To File ( STR_ ) ; } boolean success = add To File ( line ) ; if ( success ) { last Stream Start Written = stream Info . get Time Started ( ) ; String short Comment = STR_ ; if ( ! comment . is Empty ( ) ) { short Comment = STR_ + String Util . shorten To ( comment , NUM_ ) + STR_ ; } return STR_ + channel + STR_ + stream Time + STR_ + short Comment ; } return STR_ ; } }
public static void init For Current Thread ( ) { LOG . trace ( STR_ ) ; if ( instance == null ) { init Instance ( ) ; } THREAD LOCAL . set ( instance ) ; }
protected static Long convert Double To Long ( Double in Double Value ) { if ( in Double Value == null ) { return null ; } if ( in Double Value > Long . MAX VALUE ) { return Long . MAX VALUE ; } if ( in Double Value < Long . MIN VALUE ) { return Long . MIN VALUE ; } Long out Long Value = Math . round ( in Double Value ) ; return out Long Value ; }
public boolean replace ( int key , E old Value , E new Value ) { if ( old Value == null || new Value == null ) { return false ; } synchronized ( this ) { Object [ ] arr = array ; if ( arr . length <= key ) { return false ; } Object prev = arr [ key ] ; if ( prev . equals ( old Value ) ) { arr [ key ] = new Value ; array = arr ; size ++ ; return true ; } } return false ; }
public static Usericon create Twitch Icon ( Usericon . Type type , String channel , String url String , String title ) { return create Icon From Url ( type , channel , url String , SOURCE TWITCH , null , title ) ; }
public void initialize ( Callbacks callbacks ) { synchronized ( m Lock ) { m Callbacks = new Weak Reference < Callbacks > ( callbacks ) ; } }
public static byte [ ] serialize Object ( final Object obj ) throws IO Exception { final Byte Array Output Stream out = new Byte Array Output Stream ( ) ; Object Output Stream obj Out = null ; try { obj Out = new Object Output Stream ( out ) ; obj Out . write Object ( obj ) ; obj Out . flush ( ) ; return out . to Byte Array ( ) ; } finally { close ( obj Out ) ; } }
public static void wait ( Object obj , long timeout ) { synchronized ( obj ) { try { obj . wait ( timeout ) ; } catch ( Interrupted Exception inex ) { } } }
protected Polygon make Hull Complex ( double [ ] [ ] pc ) { Graham Scan Convex Hull 2 D hull = new Graham Scan Convex Hull 2 D ( ) ; double [ ] diag = new double [ ] { NUM_ , NUM_ } ; for ( int j = NUM_ ; j < pc . length ; j ++ ) { hull . add ( pc [ j ] ) ; hull . add ( times ( pc [ j ] , - NUM_ ) ) ; for ( int k = j + NUM_ ; k < pc . length ; k ++ ) { double [ ] q = pc [ k ] ; double [ ] ppq = times Equals ( plus ( pc [ j ] , q ) , Math Util . SQRTHALF ) ; double [ ] pmq = times Equals ( minus ( pc [ j ] , q ) , Math Util . SQRTHALF ) ; hull . add ( ppq ) ; hull . add ( times ( ppq , - NUM_ ) ) ; hull . add ( pmq ) ; hull . add ( times ( pmq , - NUM_ ) ) ; for ( int l = k + NUM_ ; l < pc . length ; l ++ ) { double [ ] r = pc [ k ] ; double [ ] ppqpr = times Equals ( plus ( ppq , r ) , Math . sqrt ( NUM_ / NUM_ ) ) ; double [ ] pmqpr = times Equals ( plus ( pmq , r ) , Math . sqrt ( NUM_ / NUM_ ) ) ; double [ ] ppqmr = times Equals ( minus ( ppq , r ) , Math . sqrt ( NUM_ / NUM_ ) ) ; double [ ] pmqmr = times Equals ( minus ( pmq , r ) , Math . sqrt ( NUM_ / NUM_ ) ) ; hull . add ( ppqpr ) ; hull . add ( times ( ppqpr , - NUM_ ) ) ; hull . add ( pmqpr ) ; hull . add ( times ( pmqpr , - NUM_ ) ) ; hull . add ( ppqmr ) ; hull . add ( times ( ppqmr , - NUM_ ) ) ; hull . add ( pmqmr ) ; hull . add ( times ( pmqmr , - NUM_ ) ) ; } } plus Equals ( diag , pc [ j ] ) ; } times Equals ( diag , NUM_ / Math . sqrt ( pc . length ) ) ; hull . add ( diag ) ; hull . add ( times ( diag , - NUM_ ) ) ; return hull . get Hull ( ) ; }
public void constrain ( int x , int y , int w , int h , Region region ) { if ( ( x | y ) != NUM_ ) { translate ( x , y ) ; } if ( transform State > TRANSFORM TRANSLATESCALE ) { clip Rect ( NUM_ , NUM_ , w , h ) ; return ; } final double scale X = transform . get Scale X ( ) ; final double scale Y = transform . get Scale Y ( ) ; x = constrain X = ( int ) transform . get Translate X ( ) ; y = constrain Y = ( int ) transform . get Translate Y ( ) ; w = Region . dim Add ( x , Region . clip Scale ( w , scale X ) ) ; h = Region . dim Add ( y , Region . clip Scale ( h , scale Y ) ) ; Region c = constrain Clip ; if ( c == null ) { c = Region . get Instance XYXY ( x , y , w , h ) ; } else { c = c . get Intersection XYXY ( x , y , w , h ) ; } if ( region != null ) { region = region . get Scaled Region ( scale X , scale Y ) ; region = region . get Translated Region ( x , y ) ; c = c . get Intersection ( region ) ; } if ( c == constrain Clip ) { return ; } constrain Clip = c ; if ( ! dev Clip . is Inside Quick Check ( c ) ) { dev Clip = dev Clip . get Intersection ( c ) ; validate Comp Clip ( ) ; } }
public static void init For Current Thread ( ) { log . trace ( STR_ ) ; if ( instance == null ) { log . trace ( STR_ ) ; instance = new Global Conf Impl ( false ) ; } reload If Changed ( ) ; THREAD LOCAL . set ( instance ) ; }
static boolean is Set ( ) { Policy Info pi = policy . get ( ) ; return pi . policy != null && pi . initialized == true ; }
public static byte [ ] read Upload Data ( final Upload Storage Type storage Type , final byte [ ] body , final Random Access File upload File , final int upload Temp File Size , final int chunk Size ) throws IO Exception { byte [ ] data ; if ( storage Type == Upload Storage Type . RAM STORAGE ) { data = Arrays . copy Of Range ( body , upload Temp File Size , upload Temp File Size + chunk Size ) ; } else { data = new byte [ chunk Size ] ; upload File . seek ( upload Temp File Size ) ; upload File . read ( data ) ; } return data ; }
public static String gensalt ( int log rounds , Secure Random random ) { String Builder rs = new String Builder ( ) ; byte rnd [ ] = new byte [ BCRYPT SALT LEN ] ; random . next Bytes ( rnd ) ; rs . append ( STR_ ) ; if ( log rounds < NUM_ ) rs . append ( STR_ ) ; if ( log rounds > NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } rs . append ( Integer . to String ( log rounds ) ) ; rs . append ( STR_ ) ; rs . append ( encode base 64 ( rnd , rnd . length ) ) ; return rs . to String ( ) ; }
public double calculate Replica Usable Capacity ( int vmthinsizeparentvm , int poolsnapshotcount , int desktoppoolcount , int datastorecount , int storageoverhead , String storagetiering ) { boolean b = false ; if ( storagetiering . equals Ignore Case ( STR_ ) ) { b = true ; } else { b = false ; } double d = NUM_ ; if ( b ) { d = ( vmthinsizeparentvm * desktoppoolcount * poolsnapshotcount ) / NUM_ ; } else { d = ( vmthinsizeparentvm * poolsnapshotcount * desktoppoolcount * datastorecount ) / NUM_ ; } d *= ( NUM_ + ( storageoverhead / NUM_ ) ) ; d = ( double ) Math . round ( d * NUM_ ) / NUM_ ; return d ; }
public final < T > T make ( Class < T > shield Class , H r Hub , Class < H > r Hub Class ) { Constructor < T > constructor = get Shield Impl ( shield Class , r Hub Class ) ; if ( constructor == null ) { throw new Runtime Exception ( STR_ + shield Class ) ; } try { return constructor . new Instance ( r Hub ) ; } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( STR_ + constructor , e ) ; } catch ( Instantiation Exception e ) { throw new Runtime Exception ( STR_ + constructor , e ) ; } catch ( Invocation Target Exception e ) { Throwable cause = e . get Cause ( ) ; if ( cause instanceof Runtime Exception ) { throw ( Runtime Exception ) cause ; } if ( cause instanceof Error ) { throw ( Error ) cause ; } throw new Runtime Exception ( STR_ , cause ) ; } }
private void weigh Items ( List < ? extends Plaid Item > items ) { if ( items == null || items . is Empty ( ) ) return ; Plaid Item Sorting . Plaid Item Group Weigher weigher = null ; switch ( items . get ( NUM_ ) . data Source ) { case Source Manager . SOURCE DRIBBBLE USER SHOTS : case Source Manager . SOURCE DRIBBBLE USER LIKES : case Source Manager . SOURCE PRODUCT HUNT : case Player Shots Data Manager . SOURCE PLAYER SHOTS : case Player Shots Data Manager . SOURCE TEAM SHOTS : if ( natural Order Weigher == null ) { natural Order Weigher = new Plaid Item Sorting . Natural Order Weigher ( ) ; } weigher = natural Order Weigher ; break ; default : if ( items . get ( NUM_ ) instanceof Shot ) { if ( shot Weigher == null ) shot Weigher = new Shot Weigher ( ) ; weigher = shot Weigher ; } else if ( items . get ( NUM_ ) instanceof Story ) { if ( story Weigher == null ) story Weigher = new Story Weigher ( ) ; weigher = story Weigher ; } else if ( items . get ( NUM_ ) instanceof Post ) { if ( post Weigher == null ) post Weigher = new Post Weigher ( ) ; weigher = post Weigher ; } } weigher . weigh ( items ) ; }
public static byte direct Protocol Version ( Grid Kernal Context ctx , UUID node Id ) throws Ignite Checked Exception { assert node Id != null ; Cluster Node node = ctx . discovery ( ) . node ( node Id ) ; if ( node == null ) throw new Ignite Checked Exception ( STR_ + STR_ + node Id ) ; assert ! node . is Local ( ) ; Byte attr = node . attribute ( Grid Io Manager . DIRECT PROTO VER ATTR ) ; byte rmt Proto Ver = attr != null ? attr : NUM_ ; if ( rmt Proto Ver < Grid Io Manager . DIRECT PROTO VER ) return rmt Proto Ver ; else return Grid Io Manager . DIRECT PROTO VER ; }
public void configure Debug Log ( ) { Logger Context context = ( Logger Context ) Logger Factory . get I Logger Factory ( ) ; try { Joran Configurator configurator = new Joran Configurator ( ) ; configurator . set Context ( context ) ; context . reset ( ) ; configurator . do Configure ( apac Home + File . separator + STR_ ) ; } catch ( Joran Exception je ) { } Status Printer . print In Case Of Errors Or Warnings ( context ) ; }
public String create File Name ( ) { String pref = get Prefix ( ) ; String suff = get Suffix ( ) ; String file Name = System . current Time Millis ( ) + STR_ ; if ( pref != null ) file Name = pref + PREFIX DIVIDER + file Name ; if ( suff != null ) file Name = file Name + suff ; return file Name ; }
public Patch Set Attribute as Patch Set Attribute ( Rev Walk rev Walk , Change change , Patch Set patch Set ) { try ( Review Db db = schema . open ( ) ) { return as Patch Set Attribute ( db , rev Walk , change , patch Set ) ; } catch ( Orm Exception e ) { log . error ( STR_ , e ) ; return new Patch Set Attribute ( ) ; } }
public void add ( Throwable cause ) { causes . add ( cause ) ; }
private static void analyze New String Set Contains Old String Set Values ( String Set a , String Set b , String name , Hash Map < String , Change > changes ) { if ( a != null ) { Iterator < String > iter = a . iterator ( ) ; while ( iter . has Next ( ) ) { String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; } String key = name + STR_ + val ; Change change = new Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } else if ( a == null && b != null ) { String key = name ; Change change = new Change ( key , null , NOT NULL , name ) ; changes . put ( key , change ) ; } }
public void write Padding ( int length , int pad Byte ) throws IO Exception { final byte [ ] padding ; if ( pad Byte == SPACE BYTE && length <= TEXT PAD . length ) { padding = TEXT PAD ; } else if ( pad Byte == NULL BYTE && length <= ZERO PADDING . length ) { padding = ZERO PADDING ; } else { padding = new byte [ length ] ; if ( pad Byte != NULL BYTE ) { Arrays . fill ( padding , ( byte ) pad Byte ) ; } } out . write ( padding , NUM_ , length ) ; }
public void message Item Details ( String str Class , String item , String description , String [ ] msg Option , int [ ] msg Number , int default Option ) { Hash Map < Integer , String > options = new Hash Map < Integer , String > ( msg Option . length ) ; for ( int i = NUM_ ; i < msg Option . length ; i ++ ) { options . put ( msg Number [ i ] , msg Option [ i ] ) ; } message Item Details ( str Class , description , item , options , default Option ) ; }
public double local Score ( int i , int parent ) { double sum = NUM_ ; for ( B Deu Score score : scores ) { sum += score . local Score ( i , parent ) ; } return sum / scores . size ( ) ; }
public static String find Local Root Path ( final Class < ? > klazz ) { final String compiled File Name = klazz . get Simple Name ( ) + STR_ ; final URL class Url = klazz . get Resource ( compiled File Name ) ; Preconditions . check Not Null ( class Url , STR_ + klazz . get Canonical Name ( ) ) ; final String class Url Proto = class Url . get Protocol ( ) ; final String class Url Path = class Url . get Path ( ) ; final String result ; final int start Idx = System Helpers . is Running Windows ( ) ? NUM_ : NUM_ ; if ( class Url Proto . equals ( STR_ ) ) { final Package class Package = klazz . get Package ( ) ; if ( class Package != null ) { final String class Package Path = class Package != null ? class Package . get Name ( ) . replace ( STR_ , STR_ ) : STR_ ; result = class Url Path . substring ( start Idx , class Url Path . last Index Of ( class Package Path ) ) ; } else { result = class Url Path . substring ( start Idx , class Url Path . last Index Of ( STR_ ) ) ; } } else { if ( ! class Url Proto . equals ( STR_ ) ) { throw new Runtime Exception ( STR_ ) ; } if ( ! class Url Path . starts With ( STR_ ) ) { throw new Illegal Argument Exception ( STR_ + klazz . get Canonical Name ( ) ) ; } final String jar Path = class Url Path . substring ( NUM_ , class Url Path . last Index Of ( STR_ ) ) ; result = jar Path . substring ( start Idx , jar Path . last Index Of ( STR_ ) ) ; } try { return URL Decoder . decode ( result . replace ( STR_ , File . separator Char ) , System . get Property ( STR_ ) ) ; } catch ( final Unsupported Encoding Exception e ) { assert false : STR_ ; throw new Runtime Exception ( e ) ; } }
protected double compute Factor ( double omega , double sigma ) { double root = Math . sqrt ( Math . pow ( NUM_ , NUM_ / omega ) - NUM_ ) ; return NUM_ * root / sigma ; }
public synchronized void search ( String search String , boolean regexp ) { int i ; Search Parameters params ; m Reg Exp Search = regexp ; m Search String = search String ; params = new Search Parameters ( m Search String , m Reg Exp Search ) ; if ( m Search String == null ) { m Display Indices = null ; } else { m Display Indices = new T Int Array List ( ) ; for ( i = NUM_ ; i < get Actual Row Count ( ) ; i ++ ) { if ( is Search Match ( params , m Sorted Indices [ i ] ) ) m Display Indices . add ( i ) ; } } fire Table Data Changed ( ) ; }
protected static void clean Domain Map ( String canon Org DN ) { synchronized ( canonical Domain Map ) { canonical Domain Map . remove ( canon Org DN ) ; } synchronized ( domain Map ) { domain Map . remove ( canon Org DN ) ; } }
public static void notify ( Object obj ) { synchronized ( obj ) { obj . notify ( ) ; } }
static void reset ( ) { loaded = false ; }
protected Transferable create Transferable ( J Component c ) { if ( c instanceof J Tree ) { tree = ( J Tree ) c ; Tree Path [ ] paths = tree . get Selection Paths ( ) ; if ( paths == null || paths . length == NUM_ ) { return null ; } String Buffer plain Buf = new String Buffer ( ) ; String Buffer html Buf = new String Buffer ( ) ; html Buf . append ( STR_ ) ; Tree Model model = tree . get Model ( ) ; Tree Path last Path = null ; Tree Path [ ] display Paths = get Display Order Paths ( paths ) ; for ( Tree Path path : display Paths ) { Object node = path . get Last Path Component ( ) ; boolean leaf = model . is Leaf ( node ) ; String label = get Display String ( path , true , leaf ) ; plain Buf . append ( label + STR_ ) ; html Buf . append ( STR_ + label + STR_ ) ; } plain Buf . delete Char At ( plain Buf . length ( ) - NUM_ ) ; html Buf . append ( STR_ ) ; tree = null ; return new Basic Transferable ( plain Buf . to String ( ) , html Buf . to String ( ) ) ; } return null ; }
public void add Time Event Listener ( Time Event Listener tel ) { if ( ! time Event Listeners . contains ( tel ) ) { time Event Listeners . add ( tel ) ; } }
static private double calc Log Prob At Mu ( double mu ) { final double sigma = calc Sigma From Mu ( mu ) ; return ( - s log Sqrt Two Pi - Math . log ( sigma ) ) ; }
public void append Change Report ( final Change Report change Report ) { change Reports . add ( change Report ) ; }
private void wait For All Nodes To Become ( String state , boolean is Versioned , String svc Name ) { final String prefix = STR_ + state ; long start = System . current Time Millis ( ) ; log . info ( prefix ) ; while ( System . current Time Millis ( ) - start < MAX WAIT TIME IN MIN * NUM_ * NUM_ ) { try { if ( is Cluster State Done ( state , is Versioned , svc Name ) ) { log . info ( STR_ , prefix ) ; return ; } Thread . sleep ( WAIT INTERVAL IN SEC * NUM_ ) ; } catch ( Interrupted Exception ex ) { log . warn ( STR_ , ex ) ; } catch ( Fatal Coordinator Exception ex ) { log . error ( STR_ , ex ) ; throw ex ; } catch ( Exception ex ) { log . error ( STR_ , ex ) ; } } log . info ( STR_ , prefix ) ; throw new Illegal State Exception ( String . format ( STR_ , prefix ) ) ; }
protected static Buffered Image create Image ( J Component component , Rectangle region ) throws IO Exception { boolean opaque Value = component . is Opaque ( ) ; component . set Opaque ( true ) ; Buffered Image image = new Buffered Image ( region . width , region . height , Buffered Image . TYPE INT RGB ) ; Graphics 2 D g 2 d = image . create Graphics ( ) ; g 2 d . translate ( - region . get X ( ) , - region . get Y ( ) ) ; component . paint ( g 2 d ) ; g 2 d . dispose ( ) ; component . set Opaque ( opaque Value ) ; return image ; }
public void prefer Locale Fonts ( ) { Font Manager fm = Font Manager Factory . get Instance ( ) ; fm . prefer Locale Fonts ( ) ; }
private void log Transfer Progress ( Transfer Progress transfer Progress ) { if ( LOGGER . is Info Enabled ( ) && transfer Progress . get Total Bytes To Transfer ( ) > NUM_ ) { Number Format formatter = new Decimal Format ( STR_ ) ; LOGGER . info ( STR_ , transfer Progress . get Bytes Transferred ( ) , transfer Progress . get Total Bytes To Transfer ( ) , formatter . format ( transfer Progress . get Percent Transferred ( ) ) ) ; } }
protected Classifier Split Model local Model ( ) { return m local Model ; }
private Node new Slice ( int [ ] buf , int count , boolean has Supplementary ) { int [ ] tmp = new int [ count ] ; if ( has ( CASE INSENSITIVE ) ) { if ( has ( UNICODE CASE ) ) { for ( int i = NUM_ ; i < count ; i ++ ) { tmp [ i ] = Character . to Lower Case ( Character . to Upper Case ( buf [ i ] ) ) ; } return has Supplementary ? new Slice US ( tmp ) : new Slice U ( tmp ) ; } for ( int i = NUM_ ; i < count ; i ++ ) { tmp [ i ] = ASCII . to Lower ( buf [ i ] ) ; } return has Supplementary ? new Slice IS ( tmp ) : new Slice I ( tmp ) ; } for ( int i = NUM_ ; i < count ; i ++ ) { tmp [ i ] = buf [ i ] ; } return has Supplementary ? new Slice S ( tmp ) : new Slice ( tmp ) ; }
@ Rpc Method public void start Image Sweep ( String data Store , List < Inactive Image Descriptor > images , Long sweep Rate , Long timeout , Async Method Callback < Host . Async Client . start image sweep call > handler ) throws Rpc Exception { ensure Client ( ) ; Start Image Sweep Request request = new Start Image Sweep Request ( data Store , images ) ; if ( null != sweep Rate ) { request . set Sweep rate ( sweep Rate ) ; } if ( null != timeout ) { request . set Timeout ( timeout ) ; } try { logger . info ( STR_ , get Host Ip ( ) , request ) ; client Proxy . set Timeout ( START IMAGE SWEEP TIMEOUT MS ) ; client Proxy . start image sweep ( request , handler ) ; } catch ( T Exception e ) { throw new Rpc Exception ( e . get Message ( ) ) ; } }
public static < T extends Object & java . lang . Comparable < ? super T > > T min ( Collection < ? extends T > collection ) { Iterator < ? extends T > it = collection . iterator ( ) ; T min = it . next ( ) ; if ( Number Comparator . is Number ( min ) ) { return ( T ) max ( collection , Number Comparator . create Comparator ( min . get Class ( ) ) ) ; } while ( it . has Next ( ) ) { T next = it . next ( ) ; if ( min . compare To ( next ) > NUM_ ) { min = next ; } } return min ; }
public void register Settings Listener ( String name , String option , I Settings Listener listener ) { remove Settings Listener ( name , option ) ; Settings Listener Info info = new Settings Listener Info ( name , option , listener ) ; all Listeners . add ( info ) ; List < I Settings Listener > listeners For Key = listeners By Key . get ( option ) ; if ( listeners For Key == null ) { listeners For Key = new Linked List < I Settings Listener > ( ) ; listeners By Key . put ( option , listeners For Key ) ; } listeners For Key . add ( listener ) ; String value = get Property ( option ) ; if ( value != null ) { listener . settings Value Changed ( option , value ) ; } }
private void generate Tag Handler Destroy ( ) { if ( ! is Pooling Enabled || tag Handler Pool Names . is Empty ( ) ) { return ; } out . printil ( STR_ ) ; out . push Indent ( ) ; for ( String tag Handler Pool Name : tag Handler Pool Names ) { out . printin ( tag Handler Pool Name ) ; out . println ( STR_ ) ; } out . pop Indent ( ) ; out . printil ( STR_ ) ; out . println ( ) ; }
public synchronized void un Register Client Url ( String client Url ) { registered Clients . remove ( client Url ) ; }
public void update Edge Matcher ( Edge Matcher < String > edge Matcher ) { forward Matchers . clear ( ) ; reverse Matchers . clear ( ) ; for ( Relation relation : content . get Objects ( ) ) { if ( edge Matcher . relation Forward ( relation ) ) { forward Matchers . add ( relation ) ; } if ( edge Matcher . relation Reverse ( relation ) ) { reverse Matchers . add ( relation ) ; } viewer . update ( relation , BOTH MATCHERS ) ; } }
public static String map Unsupported Encoding ( String encoding ) { if ( encoding . equals Ignore Case ( STR_ ) ) { return STR_ ; } return encoding ; }
void reset Wait Timer ( ) { wait Timer = System . current Time Millis ( ) ; }
public static void create Collection Level Snapshot ( Solr Zk Client zk Client , String collection Name , Collection Snapshot Meta Data meta ) throws Keeper Exception , Interrupted Exception { String zk Path = get Snapshot Meta Data Zk Path ( collection Name , Optional . of ( meta . get Name ( ) ) ) ; zk Client . make Path ( zk Path , Utils . to JSON ( meta ) , Create Mode . PERSISTENT , true ) ; }
public Abstract MR Message create Out Packet ( ) { int cmdlen = NUM_ ; byte cmdcode = NUM_ ; byte addrhi = NUM_ ; byte addrlo = NUM_ ; byte settinghi = NUM_ ; byte settinglo = NUM_ ; boolean bulk message = true ; int c = NUM_ ; while ( c < outputbits Per Card ) { if ( ( output Type [ c ] != Acela Node . ONOFF ) || ( output Special [ c ] != NUM_ ) ) { bulk message = false ; } c ++ ; } if ( ! bulk message ) { c = NUM_ ; boolean foundfirst = false ; boolean foundanother = false ; while ( c < outputbits Per Card ) { if ( output Need To Send [ c ] && foundfirst ) { foundanother = true ; } if ( output Need To Send [ c ] && ! foundfirst ) { foundfirst = true ; } c ++ ; } if ( foundanother ) { set Must Send ( ) ; } } Integer tempint = Integer . value Of ( starting Output Address ) ; addrlo = tempint . byte Value ( ) ; if ( bulk message ) { if ( node Type == TB ) { cmdlen = NUM_ ; cmdcode = NUM_ ; int tempsettings = ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ ; settinglo = ( byte ) ( tempsettings ) ; } if ( node Type == D 8 ) { cmdlen = NUM_ ; cmdcode = NUM_ ; int tempsettings = ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ ; tempsettings = ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + tempsettings ; settinglo = ( byte ) ( tempsettings ) ; } if ( ( node Type == WM ) || ( node Type == SY ) ) { cmdlen = NUM_ ; cmdcode = NUM_ ; } if ( node Type == SC ) { cmdlen = NUM_ ; cmdcode = NUM_ ; } if ( ( node Type == SM ) || ( node Type == SW ) || ( node Type == YM ) ) { cmdlen = NUM_ ; cmdcode = NUM_ ; int tempsettings = ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ ; tempsettings = ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + tempsettings ; settinglo = ( byte ) ( tempsettings ) ; int tempsettings 2 = ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ ; tempsettings 2 = ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + ( output Array [ NUM_ ] ^ output Wired [ NUM_ ] ) * NUM_ + tempsettings 2 ; settinghi = ( byte ) ( tempsettings 2 ) ; } } else { c = NUM_ ; boolean foundsomething = false ; while ( ( c < outputbits Per Card ) && ! foundsomething ) { if ( output Need To Send [ c ] ) { Integer tempaddr = Integer . value Of ( c + addrlo ) ; addrlo = tempaddr . byte Value ( ) ; output Need To Send [ c ] = false ; foundsomething = true ; if ( output Special [ c ] == NUM_ ) { if ( output Type [ c ] == Acela Node . ONOFF ) { int tempcommand = ( output Array [ c ] ^ output Wired [ c ] ) ; if ( tempcommand == NUM_ ) { tempcommand = NUM_ ; } cmdcode = ( byte ) ( tempcommand ) ; cmdlen = NUM_ ; } if ( output Type [ c ] == Acela Node . BLINK ) { int tempcommand = output Array [ c ] ; if ( ( tempcommand == NUM_ ) && ( output Wired [ c ] == NUM_ ) ) { tempcommand = NUM_ ; } if ( ( tempcommand == NUM_ ) && ( output Wired [ c ] == NUM_ ) ) { tempcommand = NUM_ ; } if ( tempcommand == NUM_ ) { tempcommand = NUM_ ; } cmdcode = ( byte ) ( tempcommand ) ; if ( cmdcode == NUM_ ) { cmdlen = NUM_ ; } else { cmdlen = NUM_ ; settinglo = ( byte ) output Length [ c ] ; } } if ( output Type [ c ] == Acela Node . PULSE ) { int tempcommand = output Array [ c ] ; if ( ( tempcommand == NUM_ ) && ( output Wired [ c ] == NUM_ ) ) { tempcommand = NUM_ ; } if ( ( tempcommand == NUM_ ) && ( output Wired [ c ] == NUM_ ) ) { tempcommand = NUM_ ; } if ( tempcommand == NUM_ ) { tempcommand = NUM_ ; } cmdcode = ( byte ) ( tempcommand ) ; if ( cmdcode == NUM_ ) { cmdlen = NUM_ ; } else { cmdlen = NUM_ ; settinglo = ( byte ) output Length [ c ] ; } } } else { switch ( output Signal Head Type [ c ] ) { case DOUBLE : { switch ( output Special [ c ] ) { case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; default : cmdcode = NUM_ ; settinglo = NUM_ ; break ; } break ; } case TRIPLE : { switch ( output Special [ c ] ) { case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; default : cmdcode = NUM_ ; settinglo = NUM_ ; break ; } break ; } case BPOLAR : { switch ( output Special [ c ] ) { case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; default : cmdcode = NUM_ ; settinglo = NUM_ ; break ; } break ; } case WIGWAG : { switch ( output Special [ c ] ) { case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; default : cmdcode = NUM_ ; settinglo = NUM_ ; break ; } break ; } default : { switch ( output Special [ c ] ) { case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; case NUM_ : cmdcode = NUM_ ; settinglo = NUM_ ; break ; default : cmdcode = NUM_ ; settinglo = NUM_ ; break ; } } } cmdlen = NUM_ ; } } c ++ ; } } Acela Message m = new Acela Message ( cmdlen ) ; m . set Element ( NUM_ , cmdcode ) ; m . set Element ( NUM_ , addrhi ) ; m . set Element ( NUM_ , addrlo ) ; if ( cmdlen > NUM_ ) { if ( cmdlen > NUM_ ) { m . set Element ( NUM_ , settinghi ) ; } else { m . set Element ( NUM_ , settinglo ) ; } } if ( cmdlen > NUM_ ) { m . set Element ( NUM_ , settinglo ) ; } m . set Binary ( true ) ; return m ; }
public void write ( Comment comment ) throws SAX Exception { if ( lexical Handler != null ) { String text = comment . get Text ( ) ; char [ ] chars = text . to Char Array ( ) ; lexical Handler . comment ( chars , NUM_ , chars . length ) ; } }
private static boolean has Specialized Handler Intents ( Context context , Intent intent ) { try { Package Manager pm = context . get Package Manager ( ) ; List < Resolve Info > handlers = pm . query Intent Activities ( intent , Package Manager . GET RESOLVED FILTER ) ; if ( handlers == null || handlers . is Empty ( ) ) { return false ; } for ( Resolve Info resolve Info : handlers ) { Intent Filter filter = resolve Info . filter ; if ( filter == null ) continue ; if ( filter . count Data Authorities ( ) == NUM_ || filter . count Data Paths ( ) == NUM_ ) continue ; if ( resolve Info . activity Info == null ) continue ; return true ; } } catch ( Runtime Exception e ) { Log . e ( TAG , STR_ ) ; } return false ; }
public static String format Current Date ( ) { Simple Date Format sdf = new Simple Date Format ( STR_ ) ; Calendar c = Calendar . get Instance ( ) ; return sdf . format ( c . get Time ( ) ) ; }
public static boolean below Than ( int a , int b ) { return Integer . compare Unsigned ( a , b ) < NUM_ ; }
public void compute Labelling ( Geometry Graph [ ] geom ) { super . compute Labelling ( geom ) ; label = new Label ( Location . NONE ) ; for ( Iterator it = iterator ( ) ; it . has Next ( ) ; ) { Edge End ee = ( Edge End ) it . next ( ) ; Edge e = ee . get Edge ( ) ; Label e Label = e . get Label ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { int e Loc = e Label . get Location ( i ) ; if ( e Loc == Location . INTERIOR || e Loc == Location . BOUNDARY ) label . set Location ( i , Location . INTERIOR ) ; } } }
public Transfer Handler Annotation Plaintext ( final J Editor Pane editor ) { if ( editor == null ) { throw new Illegal Argument Exception ( STR_ ) ; } this . editor = editor ; this . original = editor . get Transfer Handler ( ) ; }
private void append Colour Class ( final String Builder result , final String entry Type , final Map < String , Integer > entry Colour Map , final String entry Accession ) { final Integer colour Code = entry Colour Map . get ( entry Accession ) ; if ( entry Type != null && colour Code != null ) { result . append ( STR_ ) ; result . append ( STR_ + colour Code + STR_ + entry Type ) ; result . append ( STR_ ) ; } }
@ Suppress Warnings ( STR_ ) public boolean wait For Completion ( Application Id app Id , App Status Callback callback , long timeout Millis ) throws Yarn Exception , IO Exception { long start Millis = System . current Time Millis ( ) ; while ( true ) { try { Thread . sleep ( NUM_ ) ; } catch ( Interrupted Exception e ) { LOG . debug ( STR_ ) ; } Application Report report = client RM . get Application Report ( app Id ) ; if ( callback . exit Loop ( report ) == true ) { return true ; } Yarn Application State state = report . get Yarn Application State ( ) ; Final Application Status ds Status = report . get Final Application Status ( ) ; if ( Yarn Application State . FINISHED == state ) { if ( Final Application Status . SUCCEEDED == ds Status ) { LOG . info ( STR_ ) ; return true ; } else { LOG . info ( STR_ + STR_ + state . to String ( ) + STR_ + ds Status . to String ( ) + STR_ ) ; return false ; } } else if ( Yarn Application State . KILLED == state || Yarn Application State . FAILED == state ) { LOG . info ( STR_ + STR_ + state . to String ( ) + STR_ + ds Status . to String ( ) + STR_ ) ; return false ; } if ( System . current Time Millis ( ) - start Millis > timeout Millis ) { LOG . info ( STR_ ) ; client RM . kill Application ( app Id ) ; return false ; } } }
private double calculate Max Membership Change ( final double [ ] [ ] matrix ) { double max Membership = NUM_ ; for ( int i = NUM_ ; i < points . size ( ) ; i ++ ) { for ( int j = NUM_ ; j < clusters . size ( ) ; j ++ ) { double v = Fast Math . abs ( membership Matrix [ i ] [ j ] - matrix [ i ] [ j ] ) ; max Membership = Fast Math . max ( v , max Membership ) ; } } return max Membership ; }
public void update Dirty ( ) { memory . update Dirty ( ) ; reg . update Dirty ( ) ; }
public static void remove ( ) { DATA . remove ( ) ; clear Log Listener ( ) ; }
Heap Array Of Doubles Quick Select Sketch ( final int nom Entries , final int lg Resize Factor , final float sampling Probability , final int num Values , final long seed ) { super ( num Values , seed ) ; nom Entries = ceiling Power Of 2 ( nom Entries ) ; lg Resize Factor = lg Resize Factor ; sampling Probability = sampling Probability ; theta = ( long ) ( Long . MAX VALUE * ( double ) sampling Probability ) ; final int starting Capacity = NUM_ << starting Sub Multiple ( Integer . number Of Trailing Zeros ( ceiling Power Of 2 ( nom Entries ) * NUM_ ) , Resize Factor . get RF ( lg Resize Factor ) , MIN LG ARR LONGS ) ; keys = new long [ starting Capacity ] ; values = new double [ starting Capacity * num Values ] ; lg Current Capacity = Integer . number Of Trailing Zeros ( starting Capacity ) ; set Rebuild Threshold ( ) ; }
public Tomcat Manager ( URL url , String username , String password , String charset ) { this . url = url ; this . username = username ; this . password = password ; this . charset = charset ; try { md 5 = Message Digest . get Instance ( STR_ ) ; } catch ( No Such Algorithm Exception e ) { throw new Cargo Exception ( STR_ , e ) ; } }
public void copy Result ( Value to Copy , String callee Sig , int new Arg Num , Value Box new VB ) { hotspots . add ( new VB ) ; regex Map . put ( new VB . get Value ( ) , regex Map . get ( to Copy ) ) ; nonterminals . put ( new VB . get Value ( ) , nonterminals . get ( to Copy ) ) ; List < Value Box > vbs = new Linked List < Value Box > ( ) ; vbs . add ( new VB ) ; add Signature To Hotspot Map ( callee Sig , new Hotspot ( callee Sig , new Arg Num , hotspots ) ) ; }
private void dump ASCII ( Utterance utterance ) { if ( wave Dump File != null ) { LPC Result lpc Result = ( LPC Result ) utterance . get Object ( STR_ ) ; try { if ( wave Dump File . equals ( STR_ ) ) { lpc Result . dump ASCII ( ) ; } else { lpc Result . dump ASCII ( wave Dump File ) ; } } catch ( IO Exception ioe ) { error ( STR_ + wave Dump File + STR_ + ioe ) ; } } }
private boolean process Key Up ( int key Code ) { if ( key Code == Key Event . KEYCODE ESCAPE || key Code == Key Event . KEYCODE BACK ) { if ( is Cancelable ( ) ) dismiss ( ) ; return true ; } else if ( key Code == Key Event . KEYCODE TAB ) { if ( m In Kb Mode ) { if ( is Typed Time Fully Legal ( ) ) { finish Kb Mode ( true ) ; } return true ; } } else if ( key Code == Key Event . KEYCODE ENTER ) { if ( m In Kb Mode ) { if ( ! is Typed Time Fully Legal ( ) ) { return true ; } finish Kb Mode ( false ) ; } if ( m Callback != null ) { m Callback . on Time Set ( m Time Picker , m Time Picker . get Hours ( ) , m Time Picker . get Minutes ( ) , m Time Picker End . get Hours ( ) , m Time Picker End . get Minutes ( ) ) ; } dismiss ( ) ; return true ; } else if ( key Code == Key Event . KEYCODE DEL ) { if ( m In Kb Mode ) { if ( ! m Typed Times . is Empty ( ) ) { int deleted = delete Last Typed Key ( ) ; String deleted Key Str ; if ( deleted == get Am Or Pm Key Code ( AM ) ) { deleted Key Str = m Am Text ; } else if ( deleted == get Am Or Pm Key Code ( PM ) ) { deleted Key Str = m Pm Text ; } else { deleted Key Str = String . format ( STR_ , get Val From Key Code ( deleted ) ) ; } if ( tab Host . get Current Tab ( ) == NUM_ ) { Utils . try Accessibility Announce ( m Time Picker , String . format ( m Deleted Key Format , deleted Key Str ) ) ; } else { Utils . try Accessibility Announce ( m Time Picker End , String . format ( m Deleted Key Format , deleted Key Str ) ) ; } update Display ( true ) ; } } } else if ( key Code == Key Event . KEYCODE 0 || key Code == Key Event . KEYCODE 1 || key Code == Key Event . KEYCODE 2 || key Code == Key Event . KEYCODE 3 || key Code == Key Event . KEYCODE 4 || key Code == Key Event . KEYCODE 5 || key Code == Key Event . KEYCODE 6 || key Code == Key Event . KEYCODE 7 || key Code == Key Event . KEYCODE 8 || key Code == Key Event . KEYCODE 9 || ( ! m Is 24 Hour Mode && ( key Code == get Am Or Pm Key Code ( AM ) || key Code == get Am Or Pm Key Code ( PM ) ) ) ) { if ( ! m In Kb Mode ) { if ( m Time Picker == null ) { Log . e ( TAG , STR_ ) ; return true ; } m Typed Times . clear ( ) ; try Starting Kb Mode ( key Code ) ; return true ; } if ( add Key If Legal ( key Code ) ) { update Display ( false ) ; } return true ; } return false ; }
public void fires ( double [ ] input , Array List < Simple Rule > rule Collection ) { if ( m predicate . evaluate ( input ) == Tree Model . Predicate . Eval . TRUE ) { rule Collection . add ( this ) ; } }
public M Bean Dumper ( M Bean Server Connection server ) throws IO Exception { set M Bean Server Connection ( server ) ; try { objname = new Object Name ( Management Factory . THREAD MXBEAN NAME ) ; } catch ( Malformed Object Name Exception e ) { Internal Error ie = new Internal Error ( e . get Message ( ) ) ; ie . init Cause ( e ) ; throw ie ; } parse M Bean Info ( ) ; }
public void edit ( File file ) throws IO Exception { check AWT Permission ( ) ; check Exec ( ) ; check Action Support ( Action . EDIT ) ; file . can Write ( ) ; check File Validation ( file ) ; peer . edit ( file ) ; }
public void defer Free ( final int rwaddr , final int sze ) { m allocation Write Lock . lock ( ) ; try { if ( sze > ( this . m max Fixed Alloc - NUM_ ) ) { m deferred Free Out . write Int ( - rwaddr ) ; m deferred Free Out . write Int ( sze ) ; log . debug ( STR_ ) ; } else { m deferred Free Out . write Int ( rwaddr ) ; } } catch ( IO Exception e ) { throw new Runtime Exception ( STR_ + rwaddr + STR_ + sze , e ) ; } finally { m allocation Write Lock . unlock ( ) ; } }
public void scan Class ( Input Stream bits ) throws IO Exception { Data Input Stream dstream = new Data Input Stream ( new Buffered Input Stream ( bits ) ) ; Class File cf = null ; try { cf = new Class File ( dstream ) ; class Index . put ( cf . get Name ( ) , new Hash Set < String > ( ) ) ; scan Class ( cf ) ; if ( scan Method Annotations || scan Parameter Annotations ) { scan Methods ( cf ) ; } if ( scan Field Annotations ) { scan Fields ( cf ) ; } if ( cf . get Interfaces ( ) != null ) { Set < String > intfs = new Hash Set < String > ( ) ; for ( String intf : cf . get Interfaces ( ) ) { intfs . add ( intf ) ; } implements Index . put ( cf . get Name ( ) , intfs ) ; } } finally { dstream . close ( ) ; bits . close ( ) ; } }
public boolean write ( Type type , Object value , Node Map node , Map map ) { Class actual = value . get Class ( ) ; Class expect = type . get Type ( ) ; Class real = actual ; if ( actual . is Array ( ) ) { real = write Array ( expect , value , node ) ; } if ( actual != expect ) { node . put ( label , real . get Name ( ) ) ; } return false ; }
public static void check Explanations ( Query query , String default Field Name , Index Searcher searcher ) throws IO Exception { check Explanations ( query , default Field Name , searcher , false ) ; }
public static int [ ] convert 2 rgba ( I Image Line Array line , Png Chunk PLTE pal , Png Chunk TRNS trns , int [ ] buf ) { Image Info imi = line . get Image Info ( ) ; int nsamples = imi . cols * NUM_ ; if ( buf == null || buf . length < nsamples ) buf = new int [ nsamples ] ; int maxval = imi . bit Depth == NUM_ ? ( NUM_ << NUM_ ) - NUM_ : NUM_ ; Arrays . fill ( buf , maxval ) ; if ( imi . indexed ) { int tlen = trns != null ? trns . get Pallette Alpha ( ) . length : NUM_ ; for ( int s = NUM_ ; s < imi . cols ; s ++ ) { int index = line . get Elem ( s ) ; pal . get Entry Rgb ( index , buf , s * NUM_ ) ; if ( index < tlen ) { buf [ s * NUM_ + NUM_ ] = trns . get Pallette Alpha ( ) [ index ] ; } } } else if ( imi . greyscale ) { int [ ] unpack = null ; if ( imi . bit Depth < NUM_ ) unpack = Image Line Helper . DEPTH UNPACK [ imi . bit Depth ] ; for ( int s = NUM_ , i = NUM_ , p = NUM_ ; p < imi . cols ; p ++ ) { buf [ s ++ ] = unpack != null ? unpack [ line . get Elem ( i ++ ) ] : line . get Elem ( i ++ ) ; buf [ s ] = buf [ s - NUM_ ] ; s ++ ; buf [ s ] = buf [ s - NUM_ ] ; s ++ ; if ( imi . channels == NUM_ ) buf [ s ++ ] = unpack != null ? unpack [ line . get Elem ( i ++ ) ] : line . get Elem ( i ++ ) ; else buf [ s ++ ] = maxval ; } } else { for ( int s = NUM_ , i = NUM_ , p = NUM_ ; p < imi . cols ; p ++ ) { buf [ s ++ ] = line . get Elem ( i ++ ) ; buf [ s ++ ] = line . get Elem ( i ++ ) ; buf [ s ++ ] = line . get Elem ( i ++ ) ; buf [ s ++ ] = imi . alpha ? line . get Elem ( i ++ ) : maxval ; } } return buf ; }
private Named List r Query ( int expected Doc Count , String query , Solr Client client ) throws Exception { int time Slept = NUM_ ; Named List res = query ( query , client ) ; while ( expected Doc Count != num Found ( res ) && time Slept < NUM_ ) { log . info ( STR_ + expected Doc Count + STR_ ) ; time Slept += NUM_ ; Thread . sleep ( NUM_ ) ; res = query ( query , client ) ; } log . info ( STR_ , time Slept , num Found ( res ) ) ; return res ; }
public static Run Stats delegate Get Bucket For Long ( int buckets ) throws Exception { Long start Time = System . current Time Millis ( ) ; Primary Index Bucket Generator Impl ibg = new Primary Index Bucket Generator Impl ( Field Data Type . LONG , buckets ) ; Primary Index Bucket Locator Impl locator = new Primary Index Bucket Locator Impl ( null , null , null , null , null , null , null , ibg . generate Buckets ( ) , null ) ; logger . debug ( STR_ ) ; Hash Map < Long , List < Object > > hm = new Hash Map < > ( ) ; Summary Statistics stats = new Summary Statistics ( ) ; Random r = new Random ( ) ; for ( int i = - NUM_ ; i < NUM_ ; i ++ ) { Long random Long = Long . MIN VALUE + r . next Long ( ) * Long . MAX VALUE ; Long bucket Id = locator . get Bucket ( random Long , Field Data Type . LONG ) ; Test Utils . calculate ( hm , stats , bucket Id , random Long ) ; } Long run Time = System . current Time Millis ( ) - start Time ; Run Stats run Stats = new Run Stats ( STR_ , Field Data Type . LONG , run Time , stats , hm ) ; logger . debug ( run Stats . to String ( ) ) ; return run Stats ; }
@ Override public void count Example ( Example example ) { double plabel ; double label = example . get Value ( label Attribute ) ; if ( ! predicted Attribute . is Nominal ( ) ) { plabel = example . get Value ( predicted Attribute ) ; } else { String label S = example . get Nominal Value ( label Attribute ) ; plabel = example . get Confidence ( label S ) ; label = NUM_ ; } double weight = NUM_ ; if ( weight Attribute != null ) { weight = example . get Value ( weight Attribute ) ; } double diff = Math . abs ( label - plabel ) ; deviation Sum += diff * diff * weight * weight ; double rel Diff = Math . abs ( label - ( true Label Sum / example Counter ) ) ; relative Sum += rel Diff * rel Diff * weight * weight ; }
static void pause Thread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { log . warn ( STR_ , e ) ; } }
public boolean is Final ( ) { return Modifier . is Final ( flags ) ; }
public Aligner Trainer ( ) { this ( false , false ) ; }
public static void generate Return Code ( String return Type , Code Visitor cv ) { if ( return Type . equals ( STR_ ) ) { cv . visit Insn ( POP ) ; cv . visit Insn ( RETURN ) ; } else if ( is Primitive ( return Type ) ) { int opcode = IRETURN ; String type ; String meth ; if ( return Type . equals ( STR_ ) ) { type = STR_ ; meth = STR_ ; } else if ( return Type . equals ( STR_ ) ) { type = STR_ ; meth = STR_ ; } else if ( return Type . equals ( STR_ ) ) { type = STR_ ; meth = STR_ ; } else if ( return Type . equals ( STR_ ) ) { opcode = DRETURN ; type = STR_ ; meth = STR_ ; } else if ( return Type . equals ( STR_ ) ) { opcode = FRETURN ; type = STR_ ; meth = STR_ ; } else if ( return Type . equals ( STR_ ) ) { opcode = LRETURN ; type = STR_ ; meth = STR_ ; } else if ( return Type . equals ( STR_ ) ) { type = STR_ ; meth = STR_ ; } else { type = STR_ ; meth = STR_ ; } String desc = return Type ; cv . visit Type Insn ( CHECKCAST , type ) ; cv . visit Method Insn ( INVOKEVIRTUAL , type , meth , STR_ + desc ) ; cv . visit Insn ( opcode ) ; } else { cv . visit Type Insn ( CHECKCAST , descriptor To Class Name ( return Type ) ) ; cv . visit Insn ( ARETURN ) ; } }
private void heapify Down ( Comparable < Object > cur ) { final int stop = size > > > NUM_ ; int twopos = NUM_ ; while ( twopos < stop ) { int bestchild = ( twopos << NUM_ ) + NUM_ ; Comparable < Object > best = twoheap [ bestchild ] ; final int right = bestchild + NUM_ ; if ( right < size && best . compare To ( twoheap [ right ] ) < NUM_ ) { bestchild = right ; best = twoheap [ right ] ; } if ( cur . compare To ( best ) >= NUM_ ) { break ; } twoheap [ twopos ] = best ; twopos = bestchild ; } twoheap [ twopos ] = cur ; }
public static TLC Variable Value parse Value ( String input ) { Assert . is Not Null ( input , STR_ ) ; input . trim ( ) ; TLC Variable Value result ; try { Input Pair pair = new Input Pair ( input , NUM_ ) ; result = inner Parse ( pair ) ; if ( pair . offset != input . length ( ) ) { throw new Variable Value Parse Exception ( ) ; } } catch ( Variable Value Parse Exception e ) { result = new TLC Simple Variable Value ( input ) ; } return result ; }
public int delete Rows ( String table Name ) throws Naming Exception , SQL Exception { Context ctx = cache . get JNDI Context ( ) ; Data Source da = ( Data Source ) ctx . lookup ( STR_ ) ; Connection conn = da . get Connection ( ) ; Statement stmt = conn . create Statement ( ) ; int rows Deleted = NUM_ ; String sql = STR_ ; sql = STR_ + table Name ; Result Set rs = stmt . execute Query ( sql ) ; if ( rs . next ( ) ) { sql = STR_ + table Name ; rows Deleted = stmt . execute Update ( sql ) ; } rs . close ( ) ; stmt . close ( ) ; conn . close ( ) ; return rows Deleted ; }
private Object find Offset Info ( Local Date Time dt , Zone Offset Transition trans ) { Local Date Time local Transition = trans . get Date Time Before ( ) ; if ( trans . is Gap ( ) ) { if ( dt . is Before ( local Transition ) ) { return trans . get Offset Before ( ) ; } if ( dt . is Before ( trans . get Date Time After ( ) ) ) { return trans ; } else { return trans . get Offset After ( ) ; } } else { if ( dt . is Before ( local Transition ) == false ) { return trans . get Offset After ( ) ; } if ( dt . is Before ( trans . get Date Time After ( ) ) ) { return trans . get Offset Before ( ) ; } else { return trans ; } } }
public Graph search ( ) { long start Time = System . current Time Millis ( ) ; learn Edges ( NUM_ ) ; elapsed Time = System . current Time Millis ( ) - start Time ; return graph From MGM ( ) ; }
public static boolean equals ( Collection < ? > actual , Object ... reference ) { final Collection < Object > collection = new Hash Set < > ( ) ; Collections . add All ( collection , reference ) ; if ( actual == collection ) { return true ; } if ( actual == null ) { return false ; } if ( actual . size ( ) != collection . size ( ) ) { log . warn ( STR_ + actual . size ( ) + STR_ + collection . size ( ) ) ; return false ; } for ( Object object : actual ) { if ( ! collection . contains ( object ) ) { log . warn ( STR_ + object ) ; return false ; } } for ( Object object : collection ) { if ( ! actual . contains ( object ) ) { log . warn ( STR_ + object ) ; return false ; } } return true ; }
private int compute Scale ( Bitmap Factory . Options options , int view Width , int view Height ) { int in Sample Size = NUM_ ; if ( view Width == NUM_ || view Width == NUM_ ) { return in Sample Size ; } int bitmap Width = options . out Width ; int bitmap Height = options . out Height ; if ( bitmap Width > view Width || bitmap Height > view Width ) { int width Scale = Math . round ( ( float ) bitmap Width / ( float ) view Width ) ; int height Scale = Math . round ( ( float ) bitmap Height / ( float ) view Width ) ; in Sample Size = width Scale < height Scale ? width Scale : height Scale ; } return in Sample Size ; }
@ Override public void debug Print ( Print Stream out ) throws Ade Exception { super . debug Print ( out ) ; out . println ( STR_ + m trained ) ; out . println ( STR_ + m total Interval Count ) ; out . println ( STR_ + m min Lambda ) ; for ( Entry < String , Msg Data > msg : m msg Data . entry Set ( ) ) { final Msg Data value = msg . get Value ( ) ; out . println ( msg . get Key ( ) + STR_ + value ) ; } }
public static void print ( Print Stream out , Treebank Node node ) { out . println ( print ( node , NUM_ ) ) ; }
private void stop Drag ( Motion Event ev ) { m Touch Mode = TOUCH MODE IDLE ; final boolean commit Change = ev . get Action ( ) == Motion Event . ACTION UP && is Enabled ( ) ; final boolean old State = is Checked ( ) ; final boolean new State ; if ( commit Change ) { m Velocity Tracker . compute Current Velocity ( NUM_ ) ; final float xvel = m Velocity Tracker . get X Velocity ( ) ; if ( Math . abs ( xvel ) > m Min Fling Velocity ) { new State = View Utils . is Layout Rtl ( this ) ? ( xvel < NUM_ ) : ( xvel > NUM_ ) ; } else { new State = get Target Checked State ( ) ; } } else { new State = old State ; } if ( new State != old State ) { play Sound Effect ( Sound Effect Constants . CLICK ) ; } set Checked ( new State ) ; cancel Super Touch ( ev ) ; }
public double SVM Output ( int index , Instance inst ) throws Exception { double result = NUM_ ; if ( m Kernel Is Linear ) { if ( m sparse Weights == null ) { int n 1 = inst . num Values ( ) ; for ( int p = NUM_ ; p < n 1 ; p ++ ) { if ( inst . index ( p ) != m class Index ) { result += m weights [ inst . index ( p ) ] * inst . value Sparse ( p ) ; } } } else { int n 1 = inst . num Values ( ) ; int n 2 = m sparse Weights . length ; for ( int p 1 = NUM_ , p 2 = NUM_ ; p 1 < n 1 && p 2 < n 2 ; ) { int ind 1 = inst . index ( p 1 ) ; int ind 2 = m sparse Indices [ p 2 ] ; if ( ind 1 == ind 2 ) { if ( ind 1 != m class Index ) { result += inst . value Sparse ( p 1 ) * m sparse Weights [ p 2 ] ; } p 1 ++ ; p 2 ++ ; } else if ( ind 1 > ind 2 ) { p 2 ++ ; } else { p 1 ++ ; } } } } else { for ( int i = m support Vectors . get Next ( - NUM_ ) ; i != - NUM_ ; i = m support Vectors . get Next ( i ) ) { result += m class [ i ] * m alpha [ i ] * m kernel . eval ( index , i , inst ) ; } } result -= m b ; return result ; }
private void delete Impl ( int start Index , int end Index , int len ) { System . arraycopy ( buffer , end Index , buffer , start Index , size - end Index ) ; size -= len ; }
public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! ( obj instanceof DNS Name ) ) return false ; DNS Name other = ( DNS Name ) obj ; return name . equals Ignore Case ( other . name ) ; }
private void build Err Msg ( String Buffer err Msg Builder , Exception re , String msg ) { if ( err Msg Builder . length ( ) != NUM_ ) { err Msg Builder . append ( STR_ ) ; } err Msg Builder . append ( msg ) ; err Msg Builder . append ( STR_ ) ; err Msg Builder . append ( re . get Message ( ) ) ; log . error ( msg , re ) ; }
public double rhumb Azimuth ( Location location ) { if ( location == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STR_ , STR_ , STR_ ) ) ; } double lat 1 = Math . to Radians ( this . latitude ) ; double lon 1 = Math . to Radians ( this . longitude ) ; double lat 2 = Math . to Radians ( location . latitude ) ; double lon 2 = Math . to Radians ( location . longitude ) ; if ( lat 1 == lat 2 && lon 1 == lon 2 ) { return NUM_ ; } double d Lon = lon 2 - lon 1 ; double d Phi = Math . log ( Math . tan ( lat 2 / NUM_ + Math . PI / NUM_ ) / Math . tan ( lat 1 / NUM_ + Math . PI / NUM_ ) ) ; if ( Math . abs ( d Lon ) > Math . PI ) { d Lon = d Lon > NUM_ ? - ( NUM_ * Math . PI - d Lon ) : ( NUM_ * Math . PI + d Lon ) ; } double azimuth Radians = Math . atan 2 ( d Lon , d Phi ) ; return Double . is Na N ( azimuth Radians ) ? NUM_ : Math . to Degrees ( azimuth Radians ) ; }
protected void add Non Match ( String Builder sb , String text ) { sb . append ( text ) ; }
protected void cleanup Suspend State ( D Lock Request Message request ) { post Release Lock ( request . get Remote Thread ( ) , request . get Object Name ( ) ) ; }
