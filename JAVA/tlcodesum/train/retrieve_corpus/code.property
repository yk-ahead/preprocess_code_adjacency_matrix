public static boolean memory Is Low ( ) { return available Memory ( ) * NUM_ < RUNTIME . total Memory ( ) * NUM_ ; }
public String describe Attributes ( ) { String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; boolean first = true ; for ( Object key : attributes . key Set ( ) ) { if ( first ) { first = false ; } else { sb . append ( STR_ ) ; } sb . append ( key ) ; sb . append ( STR_ ) ; sb . append ( attributes . get ( key ) ) ; } sb . append ( STR_ ) ; return sb . to String ( ) ; }
public Object [ ] to Array ( ) { Object [ ] result = new Object [ size ] ; System . arraycopy ( element Data , NUM_ , result , NUM_ , size ) ; return result ; }
public String lookahead ( ) { if ( buf != null ) { return new String ( buf , buf Pos , buf . length - buf Pos ) ; } else { return text . substring ( pos . get Index ( ) ) ; } }
public int index Of Key ( Object key ) { return key == null ? index Of Null ( ) : index Of ( key , key . hash Code ( ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public boolean is Prune ( ) { return prune ; }
boolean need To Check Exclude ( ) { return false ; }
private byte next TC ( ) throws IO Exception { if ( has Pushback TC ) { has Pushback TC = false ; } else { pushback TC = input . read Byte ( ) ; } return pushback TC ; }
public int size ( ) { return seq . size ( ) ; }
public String write Data File ( ) throws Data File Exception { Byte Array Output Stream bos = new Byte Array Output Stream ( ) ; write Data File ( bos ) ; String out String = bos . to String ( ) ; try { if ( bos != null ) bos . close ( ) ; } catch ( IO Exception e ) { Debug . log Warning ( e , module ) ; } return out String ; }
public Shape triangle up ( float x , float y , float height ) { m path . reset ( ) ; m path . move To ( x , y + height ) ; m path . line To ( x + height / NUM_ , y ) ; m path . line To ( x + height , ( y + height ) ) ; m path . close Path ( ) ; return m path ; }
@ Override public int clamp View Position Vertical ( View child , int top , int dy ) { int top Bound = NUM_ ; int bottom Bound = NUM_ ; switch ( dragger View . get Drag Position ( ) ) { case TOP : if ( top > NUM_ ) { top Bound = dragger View . get Padding Top ( ) ; bottom Bound = ( int ) dragger Listener . drag Vertical Drag Range ( ) ; } break ; case BOTTOM : if ( top < NUM_ ) { top Bound = ( int ) - dragger Listener . drag Vertical Drag Range ( ) ; bottom Bound = dragger View . get Padding Top ( ) ; } break ; default : break ; } return Math . min ( Math . max ( top , top Bound ) , bottom Bound ) ; }
public long next ( long from Time ) { if ( get Current Count ( ) == NUM_ || from Time == NUM_ || from Time == start Date . get Time ( ) ) { return first ( ) ; } if ( Debug . verbose On ( ) ) { Debug . log Verbose ( STR_ + ( r Date List == null ? NUM_ : r Date List . size ( ) ) , module ) ; Debug . log Verbose ( STR_ + ( r Rules List == null ? NUM_ : r Rules List . size ( ) ) , module ) ; } if ( r Date List == null && r Rules List == null ) { return NUM_ ; } long next Rule Time = from Time ; boolean has Next = true ; Iterator < Recurrence Rule > rules Iterator = get Recurrence Rule Iterator ( ) ; while ( rules Iterator . has Next ( ) ) { Recurrence Rule rule = rules Iterator . next ( ) ; while ( has Next ) { next Rule Time = get Next Time ( rule , next Rule Time ) ; if ( next Rule Time == NUM_ || is Valid ( next Rule Time ) ) { has Next = false ; } } } return next Rule Time ; }
@ Override public Object [ ] to Array ( ) { return new Array ( new Object [ size ( ) ] ) ; }
private boolean has Next Postponed ( ) { return ! postponed Routes . is Empty ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public static boolean is Numeric Or Punctuation Or Symbols ( String token ) { int len = token . length ( ) ; for ( int i = NUM_ ; i < len ; ++ i ) { char c = token . char At ( i ) ; if ( ! ( Character . is Digit ( c ) || Characters . is Punctuation ( c ) || Characters . is Symbol ( c ) ) ) { return false ; } } return true ; }
public Dimension maximum Layout Size ( Container target ) { Dimension size ; synchronized ( this ) { check Container ( target ) ; check Requests ( ) ; size = new Dimension ( x Total . maximum , y Total . maximum ) ; } Insets insets = target . get Insets ( ) ; size . width = ( int ) Math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right , Integer . MAX VALUE ) ; size . height = ( int ) Math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom , Integer . MAX VALUE ) ; return size ; }
public static boolean is Right Turn ( Point p 1 , Point p 2 , Point p 3 ) { if ( p 1 . equals ( p 2 ) || p 2 . equals ( p 3 ) ) { return false ; } double val = ( p 2 . x * p 3 . y + p 1 . x * p 2 . y + p 3 . x * p 1 . y ) - ( p 2 . x * p 1 . y + p 3 . x * p 2 . y + p 1 . x * p 3 . y ) ; return val > NUM_ ; }
private boolean is Nanpa Number With National Prefix ( ) { return ( current Metadata . get Country Code ( ) == NUM_ ) && ( national Number . char At ( NUM_ ) == STR_ ) && ( national Number . char At ( NUM_ ) != STR_ ) && ( national Number . char At ( NUM_ ) != STR_ ) ; }
private boolean air App Terminated ( Process Listener pl ) { if ( pl != null ) { if ( pl . is AIR App ( ) ) { if ( pl . is Process Dead ( ) ) { return true ; } } } return false ; }
private URL create Search URL ( URL url ) throws Malformed URL Exception { if ( url == null ) { return url ; } String protocol = url . get Protocol ( ) ; if ( is Directory ( url ) || protocol . equals ( STR_ ) ) { return url ; } if ( factory == null ) { return new URL ( STR_ , STR_ , - NUM_ , url . to String ( ) + STR_ ) ; } return new URL ( STR_ , STR_ , - NUM_ , url . to String ( ) + STR_ , factory . create URL Stream Handler ( STR_ ) ) ; }
private static String encode Metric Filters ( String metric String , Map < String , String > mapper ) { String final String = metric String ; int counter = NUM_ ; int start Index = NUM_ ; int end Index = NUM_ ; for ( int i = NUM_ ; i < metric String . length ( ) ; i ++ ) { char current Char = metric String . char At ( i ) ; start Index = ( current Char == STR_ && counter == NUM_ ) ? i : start Index ; counter = ( current Char == STR_ ) ? counter + NUM_ : counter ; if ( current Char == STR_ ) { end Index = i ; counter = counter - NUM_ ; } if ( counter == NUM_ && start Index != NUM_ ) { String filter String = metric String . substring ( start Index , end Index + NUM_ ) ; final String = final String . replace ( filter String , STR_ + start Index ) ; mapper . put ( STR_ + start Index , filter String ) ; start Index = NUM_ ; } } return final String ; }
static Repaint Manager current Manager ( App Context app Context ) { Repaint Manager rm = ( Repaint Manager ) app Context . get ( repaint Manager Key ) ; if ( rm == null ) { rm = new Repaint Manager ( BUFFER STRATEGY TYPE ) ; app Context . put ( repaint Manager Key , rm ) ; } return rm ; }
public static < M extends Message > String write Json Stream ( Immutable List < M > messages ) { Byte Array Output Stream result Stream = new Byte Array Output Stream ( ) ; Message Writer < M > writer = Message Writer . create ( Output . for Stream ( new Print Stream ( result Stream ) ) ) ; writer . write All ( messages ) ; return result Stream . to String ( ) ; }
public List < Local Variable > visible Variables ( ) throws Absent Information Exception { validate Stack Frame ( ) ; create Visible Variables ( ) ; List < Local Variable > map As List = new Array List < Local Variable > ( visible Variables . values ( ) ) ; Collections . sort ( map As List ) ; return map As List ; }
private static List < Object > create Equality Key ( Node node ) { List < Object > values = new Array List < Object > ( ) ; values . add ( node . get Node Type ( ) ) ; values . add ( node . get Node Name ( ) ) ; values . add ( node . get Local Name ( ) ) ; values . add ( node . get Namespace URI ( ) ) ; values . add ( node . get Prefix ( ) ) ; values . add ( node . get Node Value ( ) ) ; for ( Node child = node . get First Child ( ) ; child != null ; child = child . get Next Sibling ( ) ) { values . add ( child ) ; } switch ( node . get Node Type ( ) ) { case DOCUMENT TYPE NODE : Document Type Impl doctype = ( Document Type Impl ) node ; values . add ( doctype . get Public Id ( ) ) ; values . add ( doctype . get System Id ( ) ) ; values . add ( doctype . get Internal Subset ( ) ) ; values . add ( doctype . get Entities ( ) ) ; values . add ( doctype . get Notations ( ) ) ; break ; case ELEMENT NODE : Element element = ( Element ) node ; values . add ( element . get Attributes ( ) ) ; break ; } return values ; }
Template Entry next Entry ( ) { if ( ! has Next ( ) ) { throw new No Such Element Exception ( ) ; } final Template Entry entry = next Entry ; next Entry = null ; return entry ; }
@ Override public boolean connection Allowed ( Event Set Descriptor esd ) { return connection Allowed ( esd . get Name ( ) ) ; }
public final char next Char ( Char Sequence csq ) { return csq . char At ( index ++ ) ; }
private long drag Started Ago ( ) { if ( drag Started == NUM_ ) { return - NUM_ ; } return System . current Time Millis ( ) - drag Started ; }
protected static double regularized Inc Beta CF ( double alpha , double beta , double x ) { final double FPMIN = Double . MIN VALUE / NUM PRECISION ; double qab = alpha + beta ; double qap = alpha + NUM_ ; double qam = alpha - NUM_ ; double c = NUM_ ; double d = NUM_ - qab * x / qap ; if ( Math . abs ( d ) < FPMIN ) { d = FPMIN ; } d = NUM_ / d ; double h = d ; for ( int m = NUM_ ; m < NUM_ ; m ++ ) { int m 2 = NUM_ * m ; double aa = m * ( beta - m ) * x / ( ( qam + m 2 ) * ( alpha + m 2 ) ) ; d = NUM_ + aa * d ; if ( Math . abs ( d ) < FPMIN ) { d = FPMIN ; } c = NUM_ + aa / c ; if ( Math . abs ( c ) < FPMIN ) { c = FPMIN ; } d = NUM_ / d ; h *= d * c ; aa = - ( alpha + m ) * ( qab + m ) * x / ( ( alpha + m 2 ) * ( qap + m 2 ) ) ; d = NUM_ + aa * d ; if ( Math . abs ( d ) < FPMIN ) { d = FPMIN ; } c = NUM_ + aa / c ; if ( Math . abs ( c ) < FPMIN ) { c = FPMIN ; } d = NUM_ / d ; double del = d * c ; h *= del ; if ( Math . abs ( del - NUM_ ) <= NUM PRECISION ) { break ; } } return h ; }
private boolean is Null Setting ( boolean make Dest , Mapping Type mtd , Mapping Type mts , String Builder result ) { if ( make Dest && ( mtd == ALL FIELDS || mtd == ONLY VALUED FIELDS ) && mts == ONLY NULL FIELDS ) { result . append ( STR_ + string Of Set Destination + STR_ + new Line ) ; return true ; } return false ; }
public byte [ ] encode ( ) { char type = get Attribute Type ( ) ; byte bin Value [ ] = new byte [ HEADER LENGTH + get Data Length ( ) + ( NUM_ - get Data Length ( ) % NUM_ ) % NUM_ ] ; bin Value [ NUM_ ] = ( byte ) ( type > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( type & NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) & NUM_ ) ; System . arraycopy ( username , NUM_ , bin Value , NUM_ , get Data Length ( ) ) ; return bin Value ; }
public int version Point Number ( ) { return Integer . value Of ( properties . get Property ( STR_ ) ) ; }
static boolean advance To First Font ( Attributed Character Iterator aci ) { for ( char ch = aci . first ( ) ; ch != Character Iterator . DONE ; ch = aci . set Index ( aci . get Run Limit ( ) ) ) { if ( aci . get Attribute ( Text Attribute . CHAR REPLACEMENT ) == null ) { return true ; } } return false ; }
public Enumeration enumurate Queue ( ) { Vector elements = new Vector ( ) ; synchronized ( LOCK ) { Enumeration e = pending . elements ( ) ; while ( e . has More Elements ( ) ) { elements . add Element ( e . next Element ( ) ) ; } } return elements . elements ( ) ; }
protected int select Operator ( ) { last Update ++ ; if ( ( last Update >= UPDATE WINDOW ) || ( probabilities == null ) ) { last Update = NUM_ ; probabilities = get Operator Probabilities ( ) ; } double rand = PRNG . next Double ( ) ; double sum = NUM_ ; for ( int i = NUM_ ; i < operators . size ( ) ; i ++ ) { sum += probabilities [ i ] ; if ( sum > rand ) { return i ; } } throw new Illegal State Exception ( ) ; }
public static String cutpoints To String ( double [ ] cut Points , boolean [ ] cut And Left ) { String Buffer text = new String Buffer ( STR_ ) ; if ( cut Points == null ) { text . append ( STR_ ) ; } else { text . append ( STR_ + cut Points . length + STR_ ) ; for ( int i = NUM_ ; i < cut Points . length ; i ++ ) { text . append ( STR_ + cut Points [ i ] + STR_ ) ; text . append ( STR_ + cut And Left [ i ] + STR_ ) ; } text . append ( STR_ ) ; } return text . to String ( ) ; }
private static int capacity ( int expected Max Size ) { return ( expected Max Size > MAXIMUM CAPACITY / NUM_ ) ? MAXIMUM CAPACITY : ( expected Max Size <= NUM_ * MINIMUM CAPACITY / NUM_ ) ? MINIMUM CAPACITY : Integer . highest One Bit ( expected Max Size + ( expected Max Size << NUM_ ) ) ; }
public static boolean is Valid Bed Graph Line ( String line ) { String [ ] bdg = line . split ( STR_ ) ; if ( bdg . length < NUM_ ) { return false ; } try { Integer . parse Int ( bdg [ NUM_ ] ) ; Integer . parse Int ( bdg [ NUM_ ] ) ; } catch ( Number Format Exception e ) { return false ; } return true ; }
public E peek Forward ( ) { int next Pos = ( pos + NUM_ ) % size ; if ( next Pos >= data . size ( ) || pos == end ) { return null ; } return data . get ( next Pos ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( NUM_ ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private List Resource Bundle load Resource Bundle ( String resource Bundle ) throws Missing Resource Exception { m resource Bundle Name = resource Bundle ; Locale locale = get Locale ( ) ; List Resource Bundle lrb ; try { Resource Bundle rb = Resource Bundle . get Bundle ( m resource Bundle Name , locale ) ; lrb = ( List Resource Bundle ) rb ; } catch ( Missing Resource Exception e ) { try { lrb = ( List Resource Bundle ) Resource Bundle . get Bundle ( m resource Bundle Name , new Locale ( STR_ , STR_ ) ) ; } catch ( Missing Resource Exception e 2 ) { throw new Missing Resource Exception ( STR_ + m resource Bundle Name , m resource Bundle Name , STR_ ) ; } } m resource Bundle = lrb ; return lrb ; }
private List < int [ ] > prepare Expected Data ( ) { List < int [ ] > index List = new Array List < > ( NUM_ ) ; int [ ] sort Index = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; int [ ] sort Index Inverted = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; index List . add ( NUM_ , sort Index ) ; index List . add ( NUM_ , sort Index Inverted ) ; return index List ; }
public static int ping ( String url ) throws Exception { URL u = new URL ( url ) ; Http URL Connection c = ( Http URL Connection ) u . open Connection ( ) ; c . connect ( ) ; int code = c . get Response Code ( ) ; log . debug ( STR_ + url + STR_ + code ) ; c . disconnect ( ) ; return code ; }
private void await Operations Available ( ) throws Interrupted Exception { flush Lock . lock ( ) ; try { do { if ( write Cache . sizex ( ) <= cache Max Size || cache Max Size == NUM_ ) { if ( cache Flush Freq > NUM_ ) can Flush . await ( cache Flush Freq , Time Unit . MILLISECONDS ) ; else can Flush . await ( ) ; } } while ( write Cache . sizex ( ) == NUM_ && ! stopping . get ( ) ) ; } finally { flush Lock . unlock ( ) ; } }
static boolean is Fulfilling ( int m ) { return ( m & FULFILLING ) != NUM_ ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( get Class ( ) != obj . get Class ( ) ) return false ; Ifd Structure other = ( Ifd Structure ) obj ; if ( count != other . count ) return false ; if ( offset Value != other . offset Value ) return false ; if ( tag != other . tag ) return false ; if ( type != other . type ) return false ; return true ; }
public boolean is Ancestor Of ( I Java Element e ) { I Java Element parent Element = e . get Parent ( ) ; while ( parent Element != null && ! parent Element . equals ( this ) ) { parent Element = parent Element . get Parent ( ) ; } return parent Element != null ; }
public static Q Name value Of ( Char Sequence name ) { Q Name q Name = ( Q Name ) FULL NAME TO QNAME . get ( name ) ; return ( q Name != null ) ? q Name : Q Name . create No Namespace ( name . to String ( ) ) ; }
@ Transactional ( read Only = true ) @ Cacheable ( value = STR_ , key = STR_ ) public int count Downloads By User Since ( final User user , final Long period ) { Objects . require Non Null ( user , STR_ ) ; Objects . require Non Null ( period , STR_ ) ; long current timestamp = System . current Time Millis ( ) ; if ( period < NUM_ || period > current timestamp ) { throw new Illegal Argument Exception ( STR_ ) ; } Date date = new Date ( current timestamp - period ) ; return network Usage Dao . count Download By User Since ( user , date ) ; }
static String expand Environment Variables ( String value ) { if ( null == value ) { return null ; } Matcher m = ENV VAR PATTERN . matcher ( value ) ; String Buffer sb = new String Buffer ( ) ; while ( m . find ( ) ) { String env Var Value = null ; String env Var Name = null == m . group ( NUM_ ) ? m . group ( NUM_ ) : m . group ( NUM_ ) ; if ( env Var Name . starts With ( ( STR_ ) ) ) { env Var Value = System . getenv ( env Var Name . substring ( NUM_ ) ) ; } else { env Var Value = System . get Property ( env Var Name ) ; } m . append Replacement ( sb , null == env Var Value ? STR_ : Matcher . quote Replacement ( env Var Value ) ) ; } m . append Tail ( sb ) ; return sb . to String ( ) ; }
public Enumeration content ( ) { return table . elements ( ) ; }
@ Override @ Suppress Warnings ( STR_ ) public synchronized < T > T [ ] to Array ( T [ ] contents ) { if ( element Count > contents . length ) { return null ; } System . arraycopy ( element Data , NUM_ , contents , NUM_ , element Count ) ; if ( element Count < contents . length ) { contents [ element Count ] = null ; } return contents ; }
public String pull Requests Url ( String account , String collection , String repo Id ) { Objects . require Non Null ( repo Id , STR_ ) ; return get Team Base Url ( account , collection ) + format ( PULL REQUESTS , repo Id ) + get Api Version ( ) ; }
public synchronized void return Buf ( byte [ ] buf ) { if ( buf == null || buf . length > m Size Limit ) { return ; } m Buffers By Last Use . add ( buf ) ; int pos = Collections . binary Search ( m Buffers By Size , buf , BUF COMPARATOR ) ; if ( pos < NUM_ ) { pos = - pos - NUM_ ; } m Buffers By Size . add ( pos , buf ) ; m Current Size += buf . length ; trim ( ) ; }
public static String slurp File ( File file ) throws IO Exception { Reader r = new File Reader ( file ) ; return slurp Reader ( r ) ; }
public String KNN Tip Text ( ) { return STR_ + STR_ ; }
private List < File > find Duplicate Files ( List < File > files ) { Hash Set < File > source File Set = new Hash Set < > ( ) ; List < File > duplicate Files = new Array List < > ( ) ; for ( File file : files ) { if ( ! source File Set . contains ( file ) ) { source File Set . add ( file ) ; } else { duplicate Files . add ( file ) ; } } return duplicate Files ; }
public Class < ? > load Class ( String name ) throws Class Not Found Exception { return init Class Loader . load Class ( name ) ; }
public int output Sequence Count ( ) { return out Regression Seqs . size ( ) + out Error Seqs . size ( ) ; }
static String internal To Binary Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STR_ , STR_ ) ; } }
public T Base < T Base < ? , ? > , T Field Id Enum > new Args ( List < Object > args ) { require Non Null ( args , STR_ ) ; final T Base < T Base < ? , ? > , T Field Id Enum > new Args = new Args ( ) ; final int size = args . size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { new Args . set Field Value ( arg Fields [ i ] , args . get ( i ) ) ; } return new Args ; }
public static String join ( List < ? > things , String delim ) { String Builder builder = new String Builder ( ) ; boolean first = true ; for ( Object thing : things ) { if ( first ) { first = false ; } else { builder . append ( delim ) ; } builder . append ( thing . to String ( ) ) ; } return builder . to String ( ) ; }
@ Suppress Warnings ( STR_ ) @ Override public boolean contains ( final Object obj ) { if ( null != obj ) { Iterator < E > it = new Array Deque Iterator < E > ( ) ; while ( it . has Next ( ) ) { if ( obj . equals ( ( E ) it . next ( ) ) ) { return true ; } } } return false ; }
static char random Char ( ) { return ( char ) Test Util . next Int ( random ( ) , STR_ , STR_ ) ; }
public static boolean is Empty ( Char Sequence str ) { if ( str == null || str . length ( ) == NUM_ ) return true ; else return false ; }
private int distance 2 ( Point p 0 , Point p 1 ) { int d 0 = Math . abs ( p 0 . x - p 1 . x ) ; int d 1 = Math . abs ( p 0 . y - p 1 . y ) ; return d 0 * d 0 + d 1 * d 1 ; }
public double double Value ( ) { if ( val instanceof Long || val instanceof Integer ) { return ( double ) ( val . long Value ( ) ) ; } return val . double Value ( ) ; }
public static boolean is Default Use Internal Browser ( ) { return Browser Util . can Use Internal Web Browser ( ) ; }
public NS Object [ ] objects At Indexes ( int ... indexes ) { NS Object [ ] result = new NS Object [ indexes . length ] ; Arrays . sort ( indexes ) ; for ( int i = NUM_ ; i < indexes . length ; i ++ ) result [ i ] = array [ indexes [ i ] ] ; return result ; }
private static Entry [ ] concat ( Entry [ ] attrs 1 , Entry [ ] attrs 2 ) { Entry [ ] nattrs = new Entry [ attrs 1 . length + attrs 2 . length ] ; System . arraycopy ( attrs 1 , NUM_ , nattrs , NUM_ , attrs 1 . length ) ; System . arraycopy ( attrs 2 , NUM_ , nattrs , attrs 1 . length , attrs 2 . length ) ; return nattrs ; }
static int mid Pt ( final int a , final int b ) { return a + ( b - a ) / NUM_ ; }
public static boolean is Dangerous ( double d ) { return Double . is Infinite ( d ) || Double . is Na N ( d ) || d == NUM_ ; }
@ Override public Set < Statement > gather ( final IGAS State < Set < Statement > , Set < Statement > , Set < Statement > > state , final Value u , final Statement e ) { return Collections . singleton ( e ) ; }
private boolean has colinear ( Pla Point Int a point ) { int count = point alist . size ( ) ; if ( count < NUM_ ) return false ; for ( int index = NUM_ ; index < count - NUM_ ; index ++ ) { Pla Point Int start = point alist . get ( index ) ; Pla Point Int end = point alist . get ( index + NUM_ ) ; if ( a point . side of ( start , end ) != Pla Side . COLLINEAR ) continue ; double d start p = start . distance square ( a point ) ; double d p end = a point . distance square ( end ) ; double d start end = start . distance square ( end ) ; if ( d start end >= d start p ) { if ( d start end >= d p end ) { return true ; } else { point alist . set ( index , a point ) ; return true ; } } else { if ( d start end >= d p end ) { point alist . set ( index + NUM_ , a point ) ; return true ; } else { point alist . set ( index , a point ) ; return true ; } } } return false ; }
public String resolve Path ( String path Info ) { if ( ( path Info == null ) || ( path Info . index Of ( STR_ ) != - NUM_ ) ) { return null ; } int lib Start = path Info . index Of ( STR_ ) + NUM_ ; int lib End = path Info . index Of ( STR_ , lib Start ) ; if ( lib End == - NUM_ ) { lib End = path Info . length ( ) ; } String libname = path Info . substring ( lib Start , lib End ) ; String subpath = path Info . substring ( lib End ) ; String lib home = get Path ( libname ) ; if ( lib home == null ) { return null ; } return lib home + STR_ + subpath ; }
@ Override public boolean equals ( Object that ) { try { if ( that == null ) { return false ; } Rule Based Break Iterator other = ( Rule Based Break Iterator ) that ; if ( checksum != other . checksum ) { return false ; } if ( text == null ) { return other . text == null ; } else { return text . equals ( other . text ) ; } } catch ( Class Cast Exception e ) { return false ; } }
public static String join ( String separator , double ... elements ) { if ( elements == null || elements . length == NUM_ ) { return STR_ ; } List < Number > list = new Array List < Number > ( elements . length ) ; for ( Double elem : elements ) { list . add ( elem ) ; } return join ( separator , list ) ; }
private boolean link Last ( Node < E > node ) { if ( count >= capacity ) return false ; Node < E > l = last ; node . prev = l ; last = node ; if ( first == null ) first = node ; else l . next = node ; ++ count ; not Empty . signal ( ) ; return true ; }
public static Number ceil ( Number a ) { if ( is Floating Point ( a ) ) { return Math . ceil ( a . double Value ( ) ) ; } else { return a . long Value ( ) ; } }
public boolean is Expired ( ) { return this . ttl < System . current Time Millis ( ) ; }
public boolean is Blinking ( ) { return modifiers . contains ( SGR . BLINK ) ; }
public double cdf ( double x ) { if ( x <= NUM_ ) return NUM_ ; return NUM_ - Math . exp ( - x * lambda ) ; }
public static String report ( ) { String Builder sb = new String Builder ( ) ; for ( Tap tap : dispatches Copy ( ) ) { int length = sb . length ( ) ; tap . append Report ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( NEW LINE ) ; } } String result = sb . to String ( ) ; LOG . debug ( STR_ + NEW LINE + NEW LINE + result + NEW LINE ) ; return result ; }
private void wait Until Readable ( ) throws IO Exception { read Timeout . enter ( ) ; try { while ( read Buffer . size ( ) == NUM_ && ! finished && ! closed && error Code == null ) { wait For Io ( ) ; } } finally { read Timeout . exit And Throw If Timed Out ( ) ; } }
public static int next Smaller Prime ( int n ) { if ( n <= NUM_ ) { return NUM_ ; } if ( n == NUM_ ) { return NUM_ ; } if ( ( n & NUM_ ) == NUM_ ) { n -- ; } else { n -= NUM_ ; } while ( n > NUM_ & ! is Prime ( n ) ) { n -= NUM_ ; } return n ; }
@ Override public int hash Code ( ) { int result ; long temp ; temp = Double . double To Long Bits ( this . x 1 ) ; result = ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . x 2 ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . y 1 ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . y 2 ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; return result ; }
public static List < ? extends Element > child Element List ( Element element , String child Element Name ) { if ( element == null ) return null ; List < Element > elements = new Linked List < Element > ( ) ; Node node = element . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE && ( child Element Name == null || child Element Name . equals ( node . get Node Name ( ) ) ) ) { Element child Element = ( Element ) node ; elements . add ( child Element ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return elements ; }
private String next Host ( ) { current Host ++ ; if ( current Host == hosts Array . length ) { current Host = NUM_ ; } return hosts Array [ current Host ] ; }
public int time Passed ( ) { final long time = Animation Utils . current Animation Time Millis ( ) ; final long start Time = Math . min ( m Scroller X . m Start Time , m Scroller Y . m Start Time ) ; return ( int ) ( time - start Time ) ; }
@ Override public Iterator < Shopping Cart Item > iterator ( ) { return cart Lines . iterator ( ) ; }
public static String [ ] string Array From String ( String string , char delimiter ) { List < String > result = new Array List < String > ( NUM_ ) ; if ( String Utils . is Not Blank ( string ) ) { Raptor String Tokenizer tok = new Raptor String Tokenizer ( string , String . value Of ( delimiter ) , false ) ; while ( tok . has More Tokens ( ) ) { String token = tok . next Token ( ) ; result . add ( token ) ; } } return result . to Array ( new String [ NUM_ ] ) ; }
public float text Width ( String str ) { if ( text Font == null ) { default Font Or Death ( STR_ ) ; } int length = str . length ( ) ; if ( length > text Width Buffer . length ) { text Width Buffer = new char [ length + NUM_ ] ; } str . get Chars ( NUM_ , length , text Width Buffer , NUM_ ) ; float wide = NUM_ ; int index = NUM_ ; int start = NUM_ ; while ( index < length ) { if ( text Width Buffer [ index ] == STR_ ) { wide = Math . max ( wide , text Width Impl ( text Width Buffer , start , index ) ) ; start = index + NUM_ ; } index ++ ; } if ( start < length ) { wide = Math . max ( wide , text Width Impl ( text Width Buffer , start , index ) ) ; } return wide ; }
private Property Descriptor [ ] property Descriptors ( Class c ) throws SQL Exception { Bean Info bean Info ; try { bean Info = Introspector . get Bean Info ( c ) ; } catch ( Introspection Exception e ) { throw new SQL Exception ( STR_ + e . get Message ( ) ) ; } return bean Info . get Property Descriptors ( ) ; }
public String build Jvm Vendor ( ) { return properties . get Property ( STR_ ) ; }
@ Override public int hash Code ( ) { return oid . hash Code ( ) ; }
@ Override public boolean is Busy ( ) { return false ; }
private static int string To Hash ( String s ) { int len = s . length ( ) ; int hash = len ; hash <<= NUM_ ; hash += s . char At ( NUM_ ) - NUM_ ; int j = len ; for ( int i = NUM_ ; i < NUM_ && j > NUM_ ; i ++ ) { j -- ; hash <<= NUM_ ; hash += s . char At ( j ) - NUM_ ; } return hash ; }
public double [ ] [ ] predict Intervals ( Instance instance , double confidence Level ) throws Exception { Univariate Interval Estimator e = ( Univariate Interval Estimator ) get Density Estimator ( instance , false ) ; return e . predict Intervals ( confidence Level ) ; }
public static long parse Long ( String text ) { try { return Long . parse Long ( text ) ; } catch ( Number Format Exception e ) { return NUM_ ; } }
public Immutable List < Message Type > filter Documenting Messages ( Proto Container Element element ) { Immutable List . Builder < Message Type > builder = Immutable List . builder ( ) ; for ( Message Type msg : element . get Messages ( ) ) { if ( ! msg . is Map Entry ( ) ) { builder . add ( msg ) ; } } return builder . build ( ) ; }
public boolean has More ( ) { return num Left . compare To ( Big Integer . ZERO ) == NUM_ ; }
public static boolean is Column Hidden ( Class < ? > controller Class , String column Name ) { return hidden Columns Cache . contains ( get Column Hash ( controller Class , column Name ) ) ; }
public boolean visible From ( Ct Class clazz ) { int mod = get Modifiers ( ) ; if ( Modifier . is Public ( mod ) ) return true ; else if ( Modifier . is Private ( mod ) ) return clazz == declaring Class ; else { String decl Name = declaring Class . get Package Name ( ) ; String from Name = clazz . get Package Name ( ) ; boolean visible ; if ( decl Name == null ) visible = from Name == null ; else visible = decl Name . equals ( from Name ) ; if ( ! visible && Modifier . is Protected ( mod ) ) return clazz . subclass Of ( declaring Class ) ; return visible ; } }
static Work Queue common Submitter Queue ( ) { Fork Join Pool p ; Work Queue [ ] ws ; int m ; Submitter z ; return ( ( z = submitters . get ( ) ) != null && ( p = common Pool ) != null && ( ws = p . work Queues ) != null && ( m = ws . length - NUM_ ) >= NUM_ ) ? ws [ m & z . seed & SQMASK ] : null ; }
public Info create Info ( String value ) { Information Field info Impl = new Information Field ( ) ; try { info Impl . set Value ( value ) ; } catch ( Sdp Exception s ) { s . print Stack Trace ( ) ; } return info Impl ; }
public static double log 2 ( double a ) { return Math . log ( a ) / log 2 ; }
public static Injector Impl current ( Class Loader loader ) { if ( loader instanceof Dynamic Class Loader ) { return local Manager . get Level ( loader ) ; } else { Soft Reference < Injector Impl > inject Ref = loader Manager Map . get ( loader ) ; if ( inject Ref != null ) { return inject Ref . get ( ) ; } else { return null ; } } }
@ Override public double diffusion Discretization ( final Stochastic Process 1 D sp , final double t 0 , final double x 0 , final double dt ) { return sp . diffusion ( t 0 , x 0 ) * Math . sqrt ( dt ) ; }
private void assert Constructor Throws Exception ( Soap Binding binding , Security Token Service Config config ) { boolean exception Thrown = false ; try { new Security Token Service Impl ( binding , config ) ; } catch ( Illegal Argument Exception e ) { exception Thrown = true ; } finally { assert True ( exception Thrown ) ; } }
public static Date Format to Date Format ( String date Format , Time Zone tz , Locale locale ) { Date Format df = null ; if ( Util Validate . is Empty ( date Format ) ) { df = Date Format . get Date Instance ( Date Format . SHORT , locale ) ; } else { df = new Simple Date Format ( date Format , locale == null ? Locale . get Default ( ) : locale ) ; } df . set Time Zone ( tz ) ; return df ; }
String source Form For Initializer ( Annotation Value annotation Value , Processing Environment processing Env , String member Name , Element context ) { Source Form Visitor visitor = new Initializer Source Form Visitor ( processing Env , member Name , context ) ; String Builder sb = new String Builder ( ) ; visitor . visit ( annotation Value , sb ) ; return sb . to String ( ) ; }
public boolean is Empty ( ) { return ext Ordering . is Empty ( ) ; }
public String output File Tip Text ( ) { return STR_ ; }
public Byte String snapshot ( ) { if ( size > Integer . MAX VALUE ) { throw new Illegal Argument Exception ( STR_ + size ) ; } return snapshot ( ( int ) size ) ; }
public boolean remove Middle Of Last Three ( ) { if ( ! has Three ( ) ) return false ; int pos = points . size ( ) ; points . remove ( pos - NUM_ ) ; return true ; }
public static boolean is Valid IANA Encoding ( String iana Encoding ) { if ( iana Encoding != null ) { int length = iana Encoding . length ( ) ; if ( length > NUM_ ) { char c = iana Encoding . char At ( NUM_ ) ; if ( ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) ) { for ( int i = NUM_ ; i < length ; i ++ ) { c = iana Encoding . char At ( i ) ; if ( ( c < STR_ || c > STR_ ) && ( c < STR_ || c > STR_ ) && ( c < STR_ || c > STR_ ) && c != STR_ && c != STR_ && c != STR_ ) { return false ; } } return true ; } } } return false ; }
public static boolean is Valid Import String ( String s ) { if ( s . equals ( STR_ ) ) return true ; boolean valid = true ; String t = s ; int index = t . index Of ( STR_ ) ; if ( index != - NUM_ ) { if ( index == t . length ( ) - NUM_ ) { if ( index - NUM_ >= NUM_ ) { valid = t . char At ( index - NUM_ ) == STR_ ; t = t . substring ( NUM_ , t . length ( ) - NUM_ ) ; } } else return false ; } if ( valid ) { String [ ] java Ids = t . split ( STR_ , t . length ( ) + NUM_ ) ; for ( String java Id : java Ids ) valid &= Source Version . is Identifier ( java Id ) ; } return valid ; }
public static Range iterate To Find Z Bounds ( XYZ Dataset dataset , List visible Series Keys , Range x Range , boolean include Interval ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; Param Checks . null Not Permitted ( visible Series Keys , STR_ ) ; Param Checks . null Not Permitted ( x Range , STR_ ) ; double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM_ ; item < item Count ; item ++ ) { double x = dataset . get X Value ( series , item ) ; double z = dataset . get Z Value ( series , item ) ; if ( x Range . contains ( x ) ) { if ( ! Double . is Na N ( z ) ) { minimum = Math . min ( minimum , z ) ; maximum = Math . max ( maximum , z ) ; } } } } if ( minimum == Double . POSITIVE INFINITY ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
public Resource Bundle new Bundle ( String base Name , Locale locale , String format , Class Loader loader , boolean reload ) throws Illegal Access Exception , Instantiation Exception , IO Exception { if ( format == null ) { throw new Null Pointer Exception ( STR_ ) ; } else if ( loader == null ) { throw new Null Pointer Exception ( STR_ ) ; } final String bundle Name = to Bundle Name ( base Name , locale ) ; final Class Loader clsloader = loader ; Resource Bundle ret ; if ( format . equals ( JAVACLASS ) ) { Class < ? > cls = null ; try { cls = clsloader . load Class ( bundle Name ) ; } catch ( Exception e ) { } catch ( No Class Def Found Error e ) { } if ( cls == null ) { return null ; } try { Resource Bundle bundle = ( Resource Bundle ) cls . new Instance ( ) ; bundle . set Locale ( locale ) ; return bundle ; } catch ( Null Pointer Exception e ) { return null ; } } if ( format . equals ( JAVAPROPERTIES ) ) { Input Stream streams = null ; final String resource Name = to Resource Name ( bundle Name , STR_ ) ; if ( reload ) { URL url = null ; try { url = loader . get Resource ( resource Name ) ; } catch ( Null Pointer Exception e ) { } if ( url != null ) { throw new Runtime Exception ( STR_ ) ; } } else { try { streams = clsloader . get Resource As Stream ( resource Name ) ; } catch ( Null Pointer Exception e ) { } } if ( streams != null ) { try { ret = new Property Resource Bundle ( new Input Stream Reader ( streams ) ) ; ret . set Locale ( locale ) ; streams . close ( ) ; } catch ( IO Exception e ) { return null ; } return ret ; } return null ; } throw new Illegal Argument Exception ( ) ; }
public static long size Of Relocating Shards ( Routing Node node , Cluster Info cluster Info , boolean subtract Shards Moving Away , String data Path ) { long total Size = NUM_ ; for ( Shard Routing routing : node . shards With State ( Shard Routing State . RELOCATING , Shard Routing State . INITIALIZING ) ) { String actual Path = cluster Info . get Data Path ( routing ) ; if ( data Path . equals ( actual Path ) ) { if ( routing . initializing ( ) && routing . relocating Node Id ( ) != null ) { total Size += get Shard Size ( routing , cluster Info ) ; } else if ( subtract Shards Moving Away && routing . relocating ( ) ) { total Size -= get Shard Size ( routing , cluster Info ) ; } } } return total Size ; }
private boolean replace Principals ( List < Policy Parser . Principal Entry > principals , Key Store keystore ) { if ( principals == null || principals . is Empty ( ) || keystore == null ) return true ; for ( Policy Parser . Principal Entry pppe : principals ) { if ( pppe . is Replace Name ( ) ) { String name ; if ( ( name = get DN ( pppe . principal Name , keystore ) ) == null ) { return false ; } if ( debug != null ) { debug . println ( STR_ + pppe . principal Name + STR_ + X 500 PRINCIPAL + STR_ + name + STR_ ) ; } pppe . principal Class = X 500 PRINCIPAL ; pppe . principal Name = name ; } } return true ; }
public static boolean is Valid Ifd ( int ifd Id ) { return ifd Id == Ifd Id . TYPE IFD 0 || ifd Id == Ifd Id . TYPE IFD 1 || ifd Id == Ifd Id . TYPE IFD EXIF || ifd Id == Ifd Id . TYPE IFD INTEROPERABILITY || ifd Id == Ifd Id . TYPE IFD GPS ; }
@ Suppress Lint ( STR_ ) public static Map < Integer , String > TECHNOLOGY MAP ( ) { Map < Integer , String > result = new Hash Map < > ( ) ; result . put ( Telephony Manager . NETWORK TYPE UNKNOWN , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE GPRS , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE EDGE , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE UMTS , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE CDMA , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE EVDO 0 , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE EVDO A , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE 1 x RTT , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE HSDPA , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE HSUPA , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE HSPA , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE IDEN , STR_ ) ; if ( Build . VERSION . SDK INT >= Build . VERSION CODES . GINGERBREAD ) { result . put ( Telephony Manager . NETWORK TYPE EVDO B , STR_ ) ; } if ( Build . VERSION . SDK INT >= Build . VERSION CODES . HONEYCOMB ) { result . put ( Telephony Manager . NETWORK TYPE LTE , STR_ ) ; result . put ( Telephony Manager . NETWORK TYPE EHRPD , STR_ ) ; } if ( Build . VERSION . SDK INT >= Build . VERSION CODES . HONEYCOMB MR 2 ) { result . put ( Telephony Manager . NETWORK TYPE HSPAP , STR_ ) ; } return Collections . unmodifiable Map ( result ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public static Calendar create Calendar Instance ( Date date ) { Calendar calendar = new Gregorian Calendar ( ) ; calendar . set Time ( date ) ; clear Time Of Day ( calendar ) ; return calendar ; }
public synchronized Optional < Audit Log Entry > next ( ) throws SQL Exception , Audit Log Entry Exception { if ( audit Log Entries . size ( ) > NUM_ ) { return Optional . of ( audit Log Entries . remove ( ) ) ; } LOG . debug ( STR_ ) ; fetch More Entries ( ) ; if ( audit Log Entries . size ( ) > NUM_ ) { return Optional . of ( audit Log Entries . remove ( ) ) ; } else { return Optional . empty ( ) ; } }
@ Override @ Pure public boolean equals ( @ Nullable Object obj ) { if ( this == obj ) return true ; if ( ! ( obj instanceof Locale ) ) return false ; Base Locale other Base = ( ( Locale ) obj ) . base Locale ; if ( ! base Locale . equals ( other Base ) ) { return false ; } if ( locale Extensions == null ) { return ( ( Locale ) obj ) . locale Extensions == null ; } return locale Extensions . equals ( ( ( Locale ) obj ) . locale Extensions ) ; }
public static Text value Of ( char [ ] chars , int offset , int length ) { if ( ( offset < NUM_ ) || ( length < NUM_ ) || ( ( offset + length ) > chars . length ) ) throw new Index Out Of Bounds Exception ( ) ; if ( length <= BLOCK SIZE ) { Text text = Text . new Primitive ( length ) ; System . arraycopy ( chars , offset , text . data , NUM_ , length ) ; return text ; } else { int half = ( ( length + BLOCK SIZE ) > > NUM_ ) & BLOCK MASK ; return Text . new Composite ( Text . value Of ( chars , offset , half ) , Text . value Of ( chars , offset + half , length - half ) ) ; } }
public String lookup Relative Native Path ( Path Impl path ) { String this Native = get Native Path ( ) ; String path Native = path . get Native Path ( ) ; if ( path Native . starts With ( this Native ) ) { int i = this Native . length ( ) ; while ( i < path Native . length ( ) ) { if ( path Native . char At ( i ) != get File Separator Char ( ) ) break ; i ++ ; } return i == path Native . length ( ) ? STR_ : path Native . substring ( i ) ; } else return path Native ; }
private E unlink Last ( ) { Node < E > l = last ; if ( l == null ) return null ; Node < E > p = l . prev ; E item = l . item ; l . item = null ; l . prev = l ; last = p ; if ( p == null ) first = null ; else p . next = null ; -- count ; not Full . signal ( ) ; return item ; }
private static boolean accepts ( final String accept Header , final String to Accept ) { final String [ ] accept Values = accept Header . split ( STR_ ) ; Arrays . sort ( accept Values ) ; return Arrays . binary Search ( accept Values , to Accept ) > - NUM_ || Arrays . binary Search ( accept Values , to Accept . replace All ( STR_ , STR_ ) ) > - NUM_ || Arrays . binary Search ( accept Values , STR_ ) > - NUM_ ; }
public static String timestamp ( ) { Calendar calendar = Calendar . get Instance ( ) ; return STR_ + calendar . get ( Calendar . YEAR ) + calendar . get ( Calendar . MONTH ) + calendar . get ( Calendar . DAY OF MONTH ) + calendar . get ( Calendar . HOUR ) + calendar . get ( Calendar . MINUTE ) + calendar . get ( Calendar . SECOND ) ; }
private static void check ( Method Desc prev , Method Desc desc ) { if ( prev . types == null || Arrays . equals ( prev . types , desc . types ) ) { String Buffer buf = new String Buffer ( ) ; prev . to String ( buf , false ) ; buf . append ( STR_ ) ; desc . to String ( buf , false ) ; throw new Illegal Argument Exception ( buf . to String ( ) ) ; } }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public Shape create Arrow Left ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . move To ( x + w , y ) ; path . line To ( x , y + h / NUM_ ) ; path . line To ( x + w , y + h ) ; path . close Path ( ) ; return path ; }
public File create File Object ( String path ) { if ( path . length ( ) >= NUM_ && path . char At ( NUM_ ) == STR_ && Character . is Letter ( path . char At ( NUM_ ) ) ) { if ( path . length ( ) == NUM_ ) { path += STR_ ; } else if ( path . char At ( NUM_ ) != STR_ ) { path = path . substring ( NUM_ , NUM_ ) + STR_ + path . substring ( NUM_ ) ; } } return super . create File Object ( path ) ; }
public static double [ ] empirical State Frequencies PAUP ( Pattern List pattern List ) { int i , j , k ; double total , sum , x , w , difference ; Data Type data Type = pattern List . get Data Type ( ) ; int state Count = pattern List . get State Count ( ) ; int pattern Length = pattern List . get Pattern Length ( ) ; int pattern Count = pattern List . get Pattern Count ( ) ; double [ ] freqs = equal State Frequencies ( pattern List ) ; double [ ] temp Freq = new double [ state Count ] ; int [ ] pattern ; boolean [ ] state ; int count = NUM_ ; do { for ( i = NUM_ ; i < state Count ; i ++ ) temp Freq [ i ] = NUM_ ; total = NUM_ ; for ( i = NUM_ ; i < pattern Count ; i ++ ) { pattern = pattern List . get Pattern ( i ) ; w = pattern List . get Pattern Weight ( i ) ; for ( k = NUM_ ; k < pattern Length ; k ++ ) { state = data Type . get State Set ( pattern [ k ] ) ; sum = NUM_ ; for ( j = NUM_ ; j < state Count ; j ++ ) if ( state [ j ] ) sum += freqs [ j ] ; for ( j = NUM_ ; j < state Count ; j ++ ) { if ( state [ j ] ) { x = ( freqs [ j ] * w ) / sum ; temp Freq [ j ] += x ; total += x ; } } } } difference = NUM_ ; for ( i = NUM_ ; i < state Count ; i ++ ) { difference += Math . abs ( ( temp Freq [ i ] / total ) - freqs [ i ] ) ; freqs [ i ] = temp Freq [ i ] / total ; } count ++ ; } while ( difference > NUM_ && count < NUM_ ) ; return freqs ; }
public static double girard Area ( S 2 Point a , S 2 Point b , S 2 Point c ) { S 2 Point ab = S 2 Point . cross Prod ( a , b ) ; S 2 Point bc = S 2 Point . cross Prod ( b , c ) ; S 2 Point ac = S 2 Point . cross Prod ( a , c ) ; return Math . max ( NUM_ , ab . angle ( ac ) - ab . angle ( bc ) + bc . angle ( ac ) ) ; }
@ Override public boolean is Valid ( ) { return valid ; }
public static Document jsoup 2 DOM ( org . jsoup . nodes . Document jsoup Document ) { Document document = null ; try { Document Builder Factory doc Builder Factory = Document Builder Factory . new Instance ( ) ; Document Builder doc Builder = doc Builder Factory . new Document Builder ( ) ; document = doc Builder . new Document ( ) ; Map < String , String > ns Map = new Hash Map < String , String > ( ) ; create DOM ( jsoup Document , document , document , ns Map ) ; } catch ( Parser Configuration Exception pce ) { throw new Runtime Exception ( pce ) ; } return document ; }
@ Override public final boolean is Open ( ) { return is Open . get ( ) ; }
public static Set < String > put Set Into Map ( String key , Map < String , Set < String > > map , String value ) { Set < String > set = new Hash Set < String > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }
public static Select Manager Jni create ( ) { try { if ( ! is Enabled ( ) ) { return null ; } Select Manager Jni poll Manager = jni Select Manager . get ( ) ; if ( poll Manager == null ) { poll Manager = new Select Manager Jni ( ) ; if ( poll Manager . start ( ) ) { jni Select Manager . set ( poll Manager ) ; } } return jni Select Manager . get ( ) ; } catch ( Config Exception e ) { log . finer ( e . to String ( ) ) ; } catch ( Throwable e ) { log . log ( Level . FINER , e . to String ( ) , e ) ; } return null ; }
public int size ( ) { return count . get ( ) ; }
Thread new Started Thread ( Runnable runnable ) { Thread t = new Thread ( runnable ) ; t . set Daemon ( true ) ; t . start ( ) ; return t ; }
public static Symbol Get Built In Symbol ( String str , boolean pcal Mode ) { Symbol sym ; if ( pcal Mode ) { sym = ( Symbol ) pcal Built In Hash Table . get ( str ) ; } else { sym = ( Symbol ) built In Hash Table . get ( str ) ; } if ( sym == null || ( sym . pcal && ! pcal Mode ) ) { return null ; } return sym ; }
public static boolean contains Modified Message ( Tls Context tls Context ) { return ( get Modified Message Position ( tls Context ) != - NUM_ ) ; }
public static int prefix Coded To Int ( final Bytes Ref val ) { int sortable Bits = NUM_ ; for ( int i = val . offset + NUM_ , limit = val . offset + val . length ; i < limit ; i ++ ) { sortable Bits <<= NUM_ ; final byte b = val . bytes [ i ] ; if ( b < NUM_ ) { throw new Number Format Exception ( STR_ + Integer . to Hex String ( b & NUM_ ) + STR_ + ( i - val . offset ) + STR_ ) ; } sortable Bits |= b ; } return ( sortable Bits << get Prefix Coded Int Shift ( val ) ) ^ NUM_ ; }
public static Byte String value Of Utf 8 ( final Char Sequence s ) { if ( s . length ( ) == NUM_ ) { return EMPTY ; } return wrap ( Static Utils . get Bytes ( s ) ) ; }
static public Automaton intersection ( Automaton a 1 , Automaton a 2 ) { if ( a 1 == a 2 ) { return a 1 ; } if ( a 1 . get Num States ( ) == NUM_ ) { return a 1 ; } if ( a 2 . get Num States ( ) == NUM_ ) { return a 2 ; } Transition [ ] [ ] transitions 1 = a 1 . get Sorted Transitions ( ) ; Transition [ ] [ ] transitions 2 = a 2 . get Sorted Transitions ( ) ; Automaton c = new Automaton ( ) ; c . create State ( ) ; Linked List < State Pair > worklist = new Linked List < > ( ) ; Hash Map < State Pair , State Pair > newstates = new Hash Map < > ( ) ; State Pair p = new State Pair ( NUM_ , NUM_ , NUM_ ) ; worklist . add ( p ) ; newstates . put ( p , p ) ; while ( worklist . size ( ) > NUM_ ) { p = worklist . remove First ( ) ; c . set Accept ( p . s , a 1 . is Accept ( p . s 1 ) && a 2 . is Accept ( p . s 2 ) ) ; Transition [ ] t 1 = transitions 1 [ p . s 1 ] ; Transition [ ] t 2 = transitions 2 [ p . s 2 ] ; for ( int n 1 = NUM_ , b 2 = NUM_ ; n 1 < t 1 . length ; n 1 ++ ) { while ( b 2 < t 2 . length && t 2 [ b 2 ] . max < t 1 [ n 1 ] . min ) b 2 ++ ; for ( int n 2 = b 2 ; n 2 < t 2 . length && t 1 [ n 1 ] . max >= t 2 [ n 2 ] . min ; n 2 ++ ) if ( t 2 [ n 2 ] . max >= t 1 [ n 1 ] . min ) { State Pair q = new State Pair ( t 1 [ n 1 ] . dest , t 2 [ n 2 ] . dest ) ; State Pair r = newstates . get ( q ) ; if ( r == null ) { q . s = c . create State ( ) ; worklist . add ( q ) ; newstates . put ( q , q ) ; r = q ; } int min = t 1 [ n 1 ] . min > t 2 [ n 2 ] . min ? t 1 [ n 1 ] . min : t 2 [ n 2 ] . min ; int max = t 1 [ n 1 ] . max < t 2 [ n 2 ] . max ? t 1 [ n 1 ] . max : t 2 [ n 2 ] . max ; c . add Transition ( p . s , r . s , min , max ) ; } } } c . finish State ( ) ; return remove Dead States ( c ) ; }
static protected String domain From Host ( String host ) { debug Out ( STR_ + host + STR_ ) ; String domain = null ; Matcher mat ; mat = ip Cap Pattern . matcher ( host ) ; if ( mat . find ( ) ) { domain = mat . group ( NUM_ ) + STR_ + mat . group ( NUM_ ) + STR_ + mat . group ( NUM_ ) + STR_ + mat . group ( NUM_ ) ; debug Out ( STR_ + domain + STR_ ) ; return domain ; } mat = tld 3 Cap Pattern . matcher ( host ) ; if ( mat . find ( ) ) { String tld = mat . group ( NUM_ ) ; if ( TLD Lookup . is Three Part TLD ( tld ) ) { domain = mat . group ( NUM_ ) ; debug Out ( STR_ + domain + STR_ + tld + STR_ ) ; return domain ; } } mat = tld 2 Cap Pattern . matcher ( host ) ; if ( mat . find ( ) ) { String tld = mat . group ( NUM_ ) ; if ( TLD Lookup . is Two Part TLD ( tld ) ) { domain = mat . group ( NUM_ ) ; debug Out ( STR_ + domain + STR_ + tld + STR_ ) ; return domain ; } } mat = tld Cap Pattern . matcher ( host ) ; if ( mat . find ( ) ) { String tld = mat . group ( NUM_ ) ; domain = mat . group ( NUM_ ) ; debug Out ( STR_ + domain + STR_ + tld + STR_ ) ; return domain ; } return domain ; }
public static boolean is Stdio ( String filename ) { return STDIO NAME . equals ( filename ) ; }
public String encrypt Password ( ) { String nonce = get Nonce ( ) ; String timestamp = get UTC Time ( ) ; String before Encryption = nonce + timestamp + password ; byte [ ] encrypted Raw ; try { encrypted Raw = sha 1 ( before Encryption ) ; } catch ( No Such Algorithm Exception e ) { e . print Stack Trace ( ) ; return null ; } String encoded = Base 64 . encode Base 64 String ( encrypted Raw ) ; return encoded ; }
public String [ ] list ( ) throws Remote Exception { if ( ! is Running ( ) ) { throw new Illegal State Exception ( STR_ ) ; } return registry . list ( ) ; }
public static String hash MD 5 ( String str ) { return hash MD 5 ( str . get Bytes ( ) ) ; }
private synchronized int activity Count ( ) { return m activities . size ( ) ; }
double [ ] create Real Data ( final int n ) { final Random random = new Random ( SEED ) ; final double [ ] data = new double [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { data [ i ] = NUM_ * random . next Double ( ) - NUM_ ; } return data ; }
public Bitmap pop ( long timeout , Time Unit unit ) throws Interrupted Exception { check Not Main Thread ( ) ; ensure Scheduled ( ) ; return finished . poll ( timeout , unit ) ; }
public String check Key And Get Database Name ( String db ) { if ( key == null ) { return db ; } if ( key . equals ( db ) ) { return key Database ; } throw Db Exception . get ( Error Code . WRONG USER OR PASSWORD ) ; }
@ Override public int hash Code ( ) { int code = super . hash Code ( ) ; if ( e Conditions != null ) { for ( Entitlement Condition e Condition : e Conditions ) { code = NUM_ * code + e Condition . hash Code ( ) ; } } if ( p Condition Name != null ) { code = NUM_ * code + p Condition Name . hash Code ( ) ; } return code ; }
public static Map < String , Set < String > > parse ( final URI uri , final String encoding ) { Map < String , Set < String > > result = Collections . empty Map ( ) ; final String query = uri . get Raw Query ( ) ; if ( query != null && query . length ( ) > NUM_ ) { result = new Hash Map < > ( ) ; parse ( result , new Scanner ( query ) , encoding , true ) ; } return result ; }
public List < JSON Value > values ( ) { return Collections . unmodifiable List ( values ) ; }
public boolean is Hidden File ( File f ) { return f . is Hidden ( ) ; }
public Repl DBMS Event poll ( ) throws Interrupted Exception { return queue . poll ( ) ; }
static public boolean is Equal ( float a , float b , float tolerance ) { return Math . abs ( a - b ) <= tolerance ; }
public String clusterer Tip Text ( ) { return STR_ ; }
public Workflow . Method zone Rollback Method ( URI export Group URI , String context Key ) { return new Workflow . Method ( STR_ , export Group URI , context Key ) ; }
protected boolean track Message ( Function Streaming Reply Message m ) { this . msgs Processed ++ ; if ( m . is Last Message ( ) ) { this . num Msgs = m . get Message Number ( ) + NUM_ ; } return this . msgs Processed == this . num Msgs ; }
public Shape create Slider Thumb Discrete ( final int x , final int y , final int w , final int h , final Corner Size size ) { final double top Arc = size . get Radius ( w , h ) ; final double bottom Arc H = size == Corner Size . INTERIOR ? NUM_ : NUM_ ; final double bottom Arc W = NUM_ ; path . reset ( ) ; path . move To ( x , y + top Arc ) ; path . quad To ( x , y , x + top Arc , y ) ; path . line To ( x + w - top Arc , y ) ; path . quad To ( x + w , y , x + w , y + top Arc ) ; path . line To ( x + w , y + h / NUM_ ) ; path . quad To ( x + w - bottom Arc W , y + h - bottom Arc H , x + w / NUM_ , y + h ) ; path . quad To ( x + bottom Arc W , y + h - bottom Arc H , x , y + h / NUM_ ) ; path . close Path ( ) ; return path ; }
@ Override public Inet Address address Remote ( ) { Socket Channel s = channel ; if ( s != null ) { try { Inet Socket Address addr = ( Inet Socket Address ) s . get Remote Address ( ) ; return addr . get Address ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } } else { return null ; } }
public static < T > Collection < T > intersection ( Collection < T > c 1 , Collection < T > c 2 ) { Set < T > set 1 = new Hash Set < > ( c 1 ) ; set 1 . retain All ( new Hash Set < > ( c 2 ) ) ; return set 1 ; }
public boolean is Pannable ( ) { return pannable ; }
public int rank ( ) { double eps = Math . pow ( NUM_ , - NUM_ ) ; double tol = Math . max ( m , n ) * s [ NUM_ ] * eps ; int r = NUM_ ; for ( int i = NUM_ ; i < s . length ; i ++ ) { if ( s [ i ] > tol ) { r ++ ; } } return r ; }
protected boolean synthesized Element ( Element elem ) { if ( match Name Attribute ( elem . get Attributes ( ) , HTML . Tag . IMPLIED ) ) { return true ; } return false ; }
public Object new Non Movable Array ( Class < ? > component Type , int length ) { return Array . new Instance ( component Type , length ) ; }
public Set < String > sub Entries ( SSO Token token , String obj Name , String filter , int num Of Entries , boolean sort Results , boolean ascending Order ) throws SMS Exception , SSO Exception { if ( ( obj Name == null ) || ( obj Name . length ( ) == NUM_ ) || ( filter == null ) || ( filter . length ( ) == NUM_ ) || ( num Of Entries < NUM_ ) ) { throw new Illegal Argument Exception ( STR_ + STR_ + STR_ + obj Name == null ? STR_ : obj Name + STR_ + filter == null ? STR_ : filter + STR_ ) ; } Set < String > subentries = null ; try { subentries = get Sub Entries ( obj Name , filter , null , num Of Entries , sort Results , ascending Order ) ; } catch ( Service Not Found Exception e ) { subentries = new Case Insensitive Hash Set ( ) ; } if ( m Debug . message Enabled ( ) ) { m Debug . message ( STR_ + STR_ + filter + STR_ + obj Name + STR_ + subentries . size ( ) + STR_ ) ; } return subentries ; }
final public boolean ends With Ignore Case ( final String suffix ) { final int l = suffix . length ( ) ; int length = length ( ) ; if ( l > length ) return false ; int i = l ; final char [ ] a = array ; char c , d ; while ( i -- != NUM_ ) { c = Character . to Lower Case ( Character . to Upper Case ( suffix . char At ( i ) ) ) ; d = Character . to Lower Case ( Character . to Upper Case ( a [ -- length ] ) ) ; if ( c != d ) return false ; } return true ; }
public String pickup Engine ( Engine engine ) { String Builder builder = new String Builder ( ) ; for ( String attribute : Setup . get Pickup Engine Message Format ( ) ) { builder . append ( get Engine Attribute ( engine , attribute , PICKUP ) ) ; } return builder . to String ( ) ; }
public int dns Domain Levels ( String host ) { int count = NUM_ ; int start Pos = NUM_ ; while ( ( start Pos = host . index Of ( STR_ , start Pos + NUM_ ) ) > - NUM_ ) { count ++ ; } return count ; }
private List < Pair < Scene View , Scene View > > images With Common Features ( double n , List < Scene View > img List ) { List < Pair < Scene View , Scene View > > images = new Array List < > ( ) ; for ( int i = NUM_ ; i < img List . size ( ) ; i ++ ) { Scene View img I = img List . get ( i ) ; for ( int j = NUM_ ; j < img List . size ( ) ; j ++ ) { if ( j > i ) { Scene View img J = img List . get ( j ) ; Collection < Feature > f = img J . get Common Features ( img I ) ; if ( f . size ( ) >= n ) { images . add ( new Pair < > ( img I , img J ) ) ; } } } } return images ; }
public final double squared Distance ( final int x , final int y ) { final double other Middle X = x + NUM_ ; final double other Middle Y = y + NUM_ ; final Rectangle 2 D this Area = get Area ( ) ; final double this Middle X = this Area . get Center X ( ) ; final double this Middle Y = this Area . get Center Y ( ) ; double x Distance = Math . abs ( other Middle X - this Middle X ) - ( area . get Width ( ) + NUM_ ) / NUM_ ; double y Distance = Math . abs ( other Middle Y - this Middle Y ) - ( area . get Height ( ) + NUM_ ) / NUM_ ; if ( x Distance < NUM_ ) { x Distance = NUM_ ; } if ( y Distance < NUM_ ) { y Distance = NUM_ ; } return x Distance * x Distance + y Distance * y Distance ; }
@ Override public DOM Implementation item ( int index ) { final int length = get Length ( ) ; if ( index >= NUM_ && index < length ) { return ( DOM Implementation ) f Implementations . get ( index ) ; } return null ; }
private static int index Of ( Object [ ] array , Object elt ) { return index Of ( array , array . length , elt ) ; }
public static int max Fill ( final int n , final float f ) { return Math . min ( ( int ) Math . ceil ( n * f ) , n - NUM_ ) ; }
@ Override public List < Alarm Model Descriptor > alarm Models ( ) { List < Alarm Model Descriptor > descriptors = new Array List < Alarm Model Descriptor > ( ) ; for ( Service Reference < Alarm Model > model : models ) { descriptors . add ( model . meta Info ( Alarm Model Descriptor . class ) ) ; } return descriptors ; }
public Variable [ ] find Arrays In Current Scope ( ) { List < Variable > arrays = new Array List < Variable > ( ) ; for ( List Iterator < Variable > iterator = f Local Variables . list Iterator ( f Local Variables . size ( ) ) ; iterator . has Previous ( ) ; ) { Variable local Variable = iterator . previous ( ) ; if ( local Variable . is Array ( ) ) arrays . add ( local Variable ) ; } for ( List Iterator < Variable > iterator = f Fields . list Iterator ( f Fields . size ( ) ) ; iterator . has Previous ( ) ; ) { Variable field = iterator . previous ( ) ; if ( field . is Array ( ) ) arrays . add ( field ) ; } return arrays . to Array ( new Variable [ arrays . size ( ) ] ) ; }
private JAXB Element < Error Response > create XML Parsing Error Response ( Input Stream is , Object Factory obj Factory , Batch Response batch Response , String parser Error Message ) { Error Response error Response = obj Factory . create Error Response ( ) ; DSML Content Handler content Handler = new DSML Content Handler ( ) ; try { final XML Reader xml Reader = create Safe XML Reader ( ) ; xml Reader . set Content Handler ( content Handler ) ; is . reset ( ) ; xml Reader . parse ( new Input Source ( is ) ) ; } catch ( Parser Configuration Exception | SAX Exception | IO Exception e ) { } if ( parser Error Message != null ) { error Response . set Message ( parser Error Message ) ; } batch Response . set Request ID ( content Handler . request ID ) ; error Response . set Type ( MALFORMED REQUEST ) ; return obj Factory . create Batch Response Error Response ( error Response ) ; }
public String type ( ) { return type ; }
private boolean less Than Or Equal ( byte [ ] a , byte [ ] b ) { int len = Math . min ( a . length , b . length ) ; for ( int i = NUM_ ; i != len ; ++ i ) { if ( a [ i ] != b [ i ] ) { return ( a [ i ] & NUM_ ) < ( b [ i ] & NUM_ ) ; } } return len == a . length ; }
private double angle To ( Point 2 D that ) { double dx = that . x - this . x ; double dy = that . y - this . y ; return Math . atan 2 ( dy , dx ) ; }
public static < K , V > Map < K , V > of ( K k 1 , V v 1 ) { Map map = of ( ) ; map . put ( k 1 , v 1 ) ; return map ; }
@ Override public void fill Assigned Keys ( Set < String > keys ) { Tree Set < String > sub Keys = new Tree Set < > ( ) ; for ( Expr Kraken expr : exprs ) { sub Keys . clear ( ) ; expr . fill Assigned Keys ( sub Keys ) ; keys . add All ( sub Keys ) ; } }
protected boolean is Inline Alert Message Set ( ) { CC Alert Inline alert = ( CC Alert Inline ) get Child ( IALERT COMMON ) ; String detail = alert . get Detail ( ) ; return ( detail != null ) && ( detail . length ( ) > NUM_ ) ; }
private static Char Handler parse Simple Codes ( String [ ] code Strings ) { if ( code Strings . length != NUM_ ) { throw new Illegal State Exception ( STR_ + Arrays . as List ( code Strings ) ) ; } return new Simple Char Handler ( codes To Bytes ( code Strings [ NUM_ ] , true ) ) ; }
public boolean is Alter Drop ( ) { return columns To Drop . size ( ) > NUM_ ; }
protected boolean is Index Selected ( I Structured Selection selection , int index ) { if ( selection . is Empty ( ) ) { return false ; } Iterator < ? > entries = selection . iterator ( ) ; List < I Runtime Classpath Entry > list = get Custom Entries As List ( ) ; while ( entries . has Next ( ) ) { Object next = entries . next ( ) ; if ( list . index Of ( next ) == index ) { return true ; } } return false ; }
@ Override public Void call ( ) throws Exception { while ( ! processing Complete || blocklet Processing Count . get ( ) > NUM_ ) { Node Holder node Holder = null ; try { node Holder = blocklet Data Holder . get ( ) ; if ( null != node Holder ) { data Writer . write Blocklet Data ( node Holder ) ; } blocklet Processing Count . decrement And Get ( ) ; } catch ( Throwable throwable ) { if ( ! processing Complete || blocklet Processing Count . get ( ) > NUM_ ) { producer Executor Service . shutdown Now ( ) ; reset Blocklet Processing Count ( ) ; throw new Carbon Data Writer Exception ( throwable . get Message ( ) ) ; } } finally { semaphore . release ( ) ; } } return null ; }
private static boolean intersects Lat Edge ( S 2 Point a , S 2 Point b , double lat , S 1 Interval lng ) { S 2 Point z = S 2 Point . normalize ( S 2 . robust Cross Prod ( a , b ) ) ; if ( z . z < NUM_ ) { z = S 2 Point . neg ( z ) ; } S 2 Point y = S 2 Point . normalize ( S 2 . robust Cross Prod ( z , new S 2 Point ( NUM_ , NUM_ , NUM_ ) ) ) ; S 2 Point x = S 2 Point . cross Prod ( y , z ) ; double sin Lat = Math . sin ( lat ) ; if ( Math . abs ( sin Lat ) >= x . z ) { return false ; } double cos Theta = sin Lat / x . z ; double sin Theta = Math . sqrt ( NUM_ - cos Theta * cos Theta ) ; double theta = Math . atan 2 ( sin Theta , cos Theta ) ; S 1 Interval ab Theta = S 1 Interval . from Point Pair ( Math . atan 2 ( a . dot Prod ( y ) , a . dot Prod ( x ) ) , Math . atan 2 ( b . dot Prod ( y ) , b . dot Prod ( x ) ) ) ; if ( ab Theta . contains ( theta ) ) { S 2 Point isect = S 2 Point . add ( S 2 Point . mul ( x , cos Theta ) , S 2 Point . mul ( y , sin Theta ) ) ; if ( lng . contains ( Math . atan 2 ( isect . y , isect . x ) ) ) { return true ; } } if ( ab Theta . contains ( - theta ) ) { S 2 Point intersection = S 2 Point . sub ( S 2 Point . mul ( x , cos Theta ) , S 2 Point . mul ( y , sin Theta ) ) ; if ( lng . contains ( Math . atan 2 ( intersection . y , intersection . x ) ) ) { return true ; } } return false ; }
private List < String > missing Fish ( final Player player , final boolean hash ) { final List < String > result = new Linked List < String > ( ) ; String done Text = player . get Quest ( QUEST SLOT ) ; if ( done Text == null ) { done Text = STR_ ; } final List < String > done = Arrays . as List ( done Text . split ( STR_ ) ) ; for ( final String fish : needed Fish ) { if ( ! done . contains ( fish ) ) { if ( hash ) { result . add ( STR_ + fish ) ; } else { result . add ( fish ) ; } } } return result ; }
protected String drain Inbound Message Buffer ( String Builder builder ) { return drain Inbound Message Buffer ( builder , builder . length ( ) ) ; }
public static boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { log . warn ( system Name + STR_ ) ; return false ; } Serial Node node = get Node From System Name ( system Name ) ; if ( node == null ) { log . warn ( system Name + STR_ ) ; return false ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STR_ ) || ( type == STR_ ) ) { if ( ( bit <= NUM_ ) || ( bit > Serial Node . output Bits [ node . node Type ] ) ) { log . warn ( system Name + STR_ ) ; return false ; } } else if ( type == STR_ ) { if ( ( bit <= NUM_ ) || ( bit > Serial Node . input Bits [ node . node Type ] ) ) { log . warn ( system Name + STR_ ) ; return false ; } } else { log . error ( STR_ ) ; return false ; } return true ; }
private static boolean usable ( Method m , Class c , Class base ) { int mods = m . get Modifiers ( ) ; return ( m . get Return Type ( ) == Proxy Trust Iterator . class && m . get Exception Types ( ) . length == NUM_ && ( mods & Modifier . STATIC ) == NUM_ && ( ( mods & ( Modifier . PUBLIC | Modifier . PROTECTED ) ) != NUM_ || ( ( mods & Modifier . PRIVATE ) != NUM_ ? c == base : same Package ( c , base ) ) ) ) ; }
public boolean match ( URI uri ) { return match Normalized ( uri . normalize ( ) ) ; }
public Object pop ( ) { return stack . pop ( ) ; }
public boolean connection Allowed ( Event Set Descriptor esd ) { return connection Allowed ( esd . get Name ( ) ) ; }
@ Suppress Warnings ( STR_ ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM_ ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
private boolean has Remaining Comments ( ) { return last Comment Index < comments . size ( ) - NUM_ ; }
public boolean more ( ) { return pos < in . length ( ) ; }
public Real Matrix create ( ) { Real Matrix rotation = new Identity Matrix ( ) ; for ( Plane plane : planes ) { double theta = plane . get Theta ( ) ; if ( Double . is Na N ( theta ) ) { continue ; } rotation = rotation . multiply ( new Rotation Matrix ( plane . get First Axis ( ) , plane . get Second Axis ( ) , theta ) ) ; } return rotation ; }
private static int type ( final Class Writer cw , final String desc ) { String t ; int index = desc . char At ( NUM_ ) == STR_ ? desc . index Of ( STR_ ) + NUM_ : NUM_ ; switch ( desc . char At ( index ) ) { case STR_ : return NUM_ ; case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : return INTEGER ; case STR_ : return FLOAT ; case STR_ : return LONG ; case STR_ : return DOUBLE ; case STR_ : t = desc . substring ( index + NUM_ , desc . length ( ) - NUM_ ) ; return OBJECT | cw . add Type ( t ) ; default : int data ; int dims = index + NUM_ ; while ( desc . char At ( dims ) == STR_ ) { ++ dims ; } switch ( desc . char At ( dims ) ) { case STR_ : data = BOOLEAN ; break ; case STR_ : data = CHAR ; break ; case STR_ : data = BYTE ; break ; case STR_ : data = SHORT ; break ; case STR_ : data = INTEGER ; break ; case STR_ : data = FLOAT ; break ; case STR_ : data = LONG ; break ; case STR_ : data = DOUBLE ; break ; default : t = desc . substring ( dims + NUM_ , desc . length ( ) - NUM_ ) ; data = OBJECT | cw . add Type ( t ) ; } return ( dims - index ) << NUM_ | data ; } }
@ Deprecated public URL to URL ( ) throws java . net . Malformed URL Exception { String name = get Absolute Name ( ) ; if ( ! name . starts With ( STR_ ) ) { return new URL ( STR_ , STR_ , - NUM_ , STR_ + name , null ) ; } else if ( name . starts With ( STR_ ) ) { return new URL ( STR_ + name ) ; } return new URL ( STR_ , STR_ , - NUM_ , name , null ) ; }
public boolean is Data Flavor Supported ( Data Flavor flavor ) { for ( Data Flavor flavor 2 : flavors ) { if ( flavor 2 . equals ( flavor ) ) { return true ; } } return false ; }
public static String [ ] split String ( String source , char delimeter ) { String [ ] result Array = null ; int delimeter Index = source . index Of ( delimeter ) ; if ( delimeter Index < NUM_ ) { result Array = new String [ NUM_ ] ; result Array [ NUM_ ] = source ; } else { String first Str = source . substring ( NUM_ , delimeter Index ) ; String second Str = source . substring ( delimeter Index + NUM_ ) ; result Array = new String [ NUM_ ] ; result Array [ NUM_ ] = first Str ; result Array [ NUM_ ] = second Str ; } return result Array ; }
public static < A > List < A > filter ( List < A > l , A elem ) { Assert . check Non Null ( elem ) ; List < A > res = List . nil ( ) ; for ( A a : l ) { if ( a != null && ! a . equals ( elem ) ) { res = res . prepend ( a ) ; } } return res . reverse ( ) ; }
public static String create Hash ( String password ) throws No Such Algorithm Exception , Invalid Key Spec Exception { return create Hash ( password . to Char Array ( ) ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
protected Date previous Standard Date ( Date date , Date Tick Unit unit ) { int milliseconds ; int seconds ; int minutes ; int hours ; int days ; int months ; int years ; Calendar calendar = Calendar . get Instance ( this . time Zone , this . locale ) ; calendar . set Time ( date ) ; int count = unit . get Multiple ( ) ; int current = calendar . get ( unit . get Calendar Field ( ) ) ; int value = count * ( current / count ) ; switch ( unit . get Unit ( ) ) { case Date Tick Unit . MILLISECOND : years = calendar . get ( Calendar . YEAR ) ; months = calendar . get ( Calendar . MONTH ) ; days = calendar . get ( Calendar . DATE ) ; hours = calendar . get ( Calendar . HOUR OF DAY ) ; minutes = calendar . get ( Calendar . MINUTE ) ; seconds = calendar . get ( Calendar . SECOND ) ; calendar . set ( years , months , days , hours , minutes , seconds ) ; calendar . set ( Calendar . MILLISECOND , value ) ; Date mm = calendar . get Time ( ) ; if ( mm . get Time ( ) >= date . get Time ( ) ) { calendar . set ( Calendar . MILLISECOND , value - count ) ; mm = calendar . get Time ( ) ; } return mm ; case Date Tick Unit . SECOND : years = calendar . get ( Calendar . YEAR ) ; months = calendar . get ( Calendar . MONTH ) ; days = calendar . get ( Calendar . DATE ) ; hours = calendar . get ( Calendar . HOUR OF DAY ) ; minutes = calendar . get ( Calendar . MINUTE ) ; if ( this . tick Mark Position == Date Tick Mark Position . START ) { milliseconds = NUM_ ; } else if ( this . tick Mark Position == Date Tick Mark Position . MIDDLE ) { milliseconds = NUM_ ; } else { milliseconds = NUM_ ; } calendar . set ( Calendar . MILLISECOND , milliseconds ) ; calendar . set ( years , months , days , hours , minutes , value ) ; Date dd = calendar . get Time ( ) ; if ( dd . get Time ( ) >= date . get Time ( ) ) { calendar . set ( Calendar . SECOND , value - count ) ; dd = calendar . get Time ( ) ; } return dd ; case Date Tick Unit . MINUTE : years = calendar . get ( Calendar . YEAR ) ; months = calendar . get ( Calendar . MONTH ) ; days = calendar . get ( Calendar . DATE ) ; hours = calendar . get ( Calendar . HOUR OF DAY ) ; if ( this . tick Mark Position == Date Tick Mark Position . START ) { seconds = NUM_ ; } else if ( this . tick Mark Position == Date Tick Mark Position . MIDDLE ) { seconds = NUM_ ; } else { seconds = NUM_ ; } calendar . clear ( Calendar . MILLISECOND ) ; calendar . set ( years , months , days , hours , value , seconds ) ; Date d 0 = calendar . get Time ( ) ; if ( d 0 . get Time ( ) >= date . get Time ( ) ) { calendar . set ( Calendar . MINUTE , value - count ) ; d 0 = calendar . get Time ( ) ; } return d 0 ; case Date Tick Unit . HOUR : years = calendar . get ( Calendar . YEAR ) ; months = calendar . get ( Calendar . MONTH ) ; days = calendar . get ( Calendar . DATE ) ; if ( this . tick Mark Position == Date Tick Mark Position . START ) { minutes = NUM_ ; seconds = NUM_ ; } else if ( this . tick Mark Position == Date Tick Mark Position . MIDDLE ) { minutes = NUM_ ; seconds = NUM_ ; } else { minutes = NUM_ ; seconds = NUM_ ; } calendar . clear ( Calendar . MILLISECOND ) ; calendar . set ( years , months , days , value , minutes , seconds ) ; Date d 1 = calendar . get Time ( ) ; if ( d 1 . get Time ( ) >= date . get Time ( ) ) { calendar . set ( Calendar . HOUR OF DAY , value - count ) ; d 1 = calendar . get Time ( ) ; } return d 1 ; case Date Tick Unit . DAY : years = calendar . get ( Calendar . YEAR ) ; months = calendar . get ( Calendar . MONTH ) ; if ( this . tick Mark Position == Date Tick Mark Position . START ) { hours = NUM_ ; } else if ( this . tick Mark Position == Date Tick Mark Position . MIDDLE ) { hours = NUM_ ; } else { hours = NUM_ ; } calendar . clear ( Calendar . MILLISECOND ) ; calendar . set ( years , months , value , hours , NUM_ , NUM_ ) ; Date d 2 = calendar . get Time ( ) ; if ( d 2 . get Time ( ) >= date . get Time ( ) ) { calendar . set ( Calendar . DATE , value - count ) ; d 2 = calendar . get Time ( ) ; } return d 2 ; case Date Tick Unit . MONTH : value = count * ( ( current + NUM_ ) / count ) - NUM_ ; years = calendar . get ( Calendar . YEAR ) ; calendar . clear ( Calendar . MILLISECOND ) ; calendar . set ( years , value , NUM_ , NUM_ , NUM_ , NUM_ ) ; Month month = new Month ( calendar . get Time ( ) , this . time Zone , this . locale ) ; Date standard Date = calculate Date For Position ( month , this . tick Mark Position ) ; long millis = standard Date . get Time ( ) ; if ( millis >= date . get Time ( ) ) { for ( int i = NUM_ ; i < count ; i ++ ) { month = ( Month ) month . previous ( ) ; } month . peg ( Calendar . get Instance ( this . time Zone ) ) ; standard Date = calculate Date For Position ( month , this . tick Mark Position ) ; } return standard Date ; case Date Tick Unit . YEAR : if ( this . tick Mark Position == Date Tick Mark Position . START ) { months = NUM_ ; days = NUM_ ; } else if ( this . tick Mark Position == Date Tick Mark Position . MIDDLE ) { months = NUM_ ; days = NUM_ ; } else { months = NUM_ ; days = NUM_ ; } calendar . clear ( Calendar . MILLISECOND ) ; calendar . set ( value , months , days , NUM_ , NUM_ , NUM_ ) ; Date d 3 = calendar . get Time ( ) ; if ( d 3 . get Time ( ) >= date . get Time ( ) ) { calendar . set ( Calendar . YEAR , value - count ) ; d 3 = calendar . get Time ( ) ; } return d 3 ; default : return null ; } }
public boolean is Locked ( ) { return ! queue . is Empty ( ) ; }
public boolean has Badge ( @ Id Res final int item Id ) { return map . contains ( item Id ) ; }
private static Pair < byte [ ] , byte [ ] > create Names For Reverse Prefix Scan ( @ Nonnull byte [ ] name ) { Preconditions . check Not Null ( name , STR_ ) ; Preconditions . check Argument ( name . length <= Cell . MAX NAME LENGTH , STR_ ) ; if ( name . length == NUM_ ) { return Pair . create ( name , name ) ; } byte [ ] start Name = new byte [ Cell . MAX NAME LENGTH ] ; System . arraycopy ( name , NUM_ , start Name , NUM_ , name . length ) ; for ( int i = name . length ; i < start Name . length ; i ++ ) { start Name [ i ] = ( byte ) NUM_ ; } byte [ ] end Name = Range Requests . previous Lexicographic Name ( name ) ; return Pair . create ( start Name , end Name ) ; }
public static String comparable Qualifier ( String qualifier ) { int i = QUALIFIERS . index Of ( qualifier ) ; return i == - NUM_ ? ( QUALIFIERS . size ( ) + STR_ + qualifier ) : String . value Of ( i ) ; }
public char next ( ) { return pos < in . length ( ) ? in . char At ( pos ++ ) : STR_ ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public static List < ? > clone List ( List < ? > source ) { Param Checks . null Not Permitted ( source , STR_ ) ; List result = new Array List ( ) ; for ( Object obj : source ) { if ( obj != null ) { try { result . add ( Object Utilities . clone ( obj ) ) ; } catch ( Clone Not Supported Exception ex ) { throw new Runtime Exception ( ex ) ; } } else { result . add ( null ) ; } } return result ; }
< T > T optional ( Object obj , Class < T > clazz , String part ) throws Parse Exception { if ( obj == null ) { return null ; } return expect ( obj , clazz , part ) ; }
public long size ( ) { return is Null ( ) ? NUM_ : this . end - this . start + NUM_ ; }
static int exclusive Count ( int c ) { return c & EXCLUSIVE MASK ; }
static Automaton reverse ( Automaton a , Set < Integer > initial States ) { if ( Operations . is Empty ( a ) ) { return new Automaton ( ) ; } int num States = a . get Num States ( ) ; Automaton . Builder builder = new Automaton . Builder ( ) ; builder . create State ( ) ; for ( int s = NUM_ ; s < num States ; s ++ ) { builder . create State ( ) ; } builder . set Accept ( NUM_ , true ) ; Transition t = new Transition ( ) ; for ( int s = NUM_ ; s < num States ; s ++ ) { int num Transitions = a . get Num Transitions ( s ) ; a . init Transition ( s , t ) ; for ( int i = NUM_ ; i < num Transitions ; i ++ ) { a . get Next Transition ( t ) ; builder . add Transition ( t . dest + NUM_ , s + NUM_ , t . min , t . max ) ; } } Automaton result = builder . finish ( ) ; int s = NUM_ ; Bit Set accept States = a . get Accept States ( ) ; while ( s < num States && ( s = accept States . next Set Bit ( s ) ) != - NUM_ ) { result . add Epsilon ( NUM_ , s + NUM_ ) ; if ( initial States != null ) { initial States . add ( s + NUM_ ) ; } s ++ ; } result . finish State ( ) ; return result ; }
public static boolean is Digit ( char c ) { return Character . is Digit ( c ) ; }
public static boolean is Very Dangerous ( double d ) { return Double . is Infinite ( d ) || Double . is Na N ( d ) ; }
public boolean is Right ( ) { return ! is Left ; }
@ Suppress Warnings ( STR_ ) public static < K extends Throwable > void rewrap And Throw If Instance ( String new Message , Throwable t , Class < K > clazz ) throws K { if ( ( t != null ) && clazz . is Assignable From ( t . get Class ( ) ) ) { K kt = ( K ) t ; K wrapped = Throwables . rewrap ( new Message , kt ) ; throw wrapped ; } }
private final boolean related Moves ( Move m 1 , Move m 2 ) { if ( ( m 1 . from == m 1 . to ) || ( m 2 . from == m 2 . to ) ) return false ; if ( ( m 1 . to == m 2 . from ) || ( m 1 . from == m 2 . to ) || ( ( Bit Board . squares Between [ m 2 . from ] [ m 2 . to ] & ( NUM_ << m 1 . from ) ) != NUM_ ) ) return true ; return false ; }
public static Array List < Coords > intervening ( Coords src , Coords dest , boolean split ) { Ideal Hex i Src = Ideal Hex . get ( src ) ; Ideal Hex i Dest = Ideal Hex . get ( dest ) ; int [ ] directions = new int [ NUM_ ] ; int center Direction = src . direction ( dest ) ; if ( split ) { center Direction = ( int ) Math . round ( src . radian ( dest ) + NUM_ / HEXSIDE ) % NUM_ ; } directions [ NUM_ ] = center Direction ; directions [ NUM_ ] = ( center Direction + NUM_ ) % NUM_ ; directions [ NUM_ ] = ( center Direction + NUM_ ) % NUM_ ; Array List < Coords > hexes = new Array List < > ( ) ; Coords current = src ; hexes . add ( current ) ; while ( ! dest . equals ( current ) ) { current = Coords . next Hex ( current , i Src , i Dest , directions ) ; hexes . add ( current ) ; } return hexes ; }
public String remainder ( ) { String Builder accum = new String Builder ( ) ; while ( ! is Empty ( ) ) { accum . append ( consume ( ) ) ; } return accum . to String ( ) ; }
private long cache Response Age ( ) { long apparent Received Age = served Date != null ? Math . max ( NUM_ , received Response Millis - served Date . get Time ( ) ) : NUM_ ; long received Age = age Seconds != - NUM_ ? Math . max ( apparent Received Age , SECONDS . to Millis ( age Seconds ) ) : apparent Received Age ; long response Duration = received Response Millis - sent Request Millis ; long resident Duration = now Millis - received Response Millis ; return received Age + response Duration + resident Duration ; }
private Shape create Thumb Shape ( int width , int height , boolean upper ) { Path 2 D path = new Path 2 D . Float ( ) ; if ( slider . get Orientation ( ) == J Slider . HORIZONTAL ) { float d = NUM_ * width ; path . move To ( d , NUM_ ) ; path . line To ( ( upper ? width : NUM_ ) , d ) ; path . line To ( ( upper ? width : NUM_ ) , height ) ; path . line To ( NUM_ * width , height ) ; } else { float d = NUM_ * height ; path . move To ( NUM_ , d ) ; path . line To ( d , ( upper ? height : NUM_ ) ) ; path . line To ( width , ( upper ? height : NUM_ ) ) ; path . line To ( height , NUM_ * height ) ; } path . close Path ( ) ; return path ; }
@ Override public double drift Discretization ( final Stochastic Process 1 D sp , final double t 0 , final double x 0 , final double dt ) { return sp . drift ( t 0 , x 0 ) * dt ; }
public static Generalized Time current Time ( ) { return value Of ( Calendar . get Instance ( ) ) ; }
public long to Minutes ( ) { return time Unit . to Minutes ( length ) ; }
public String distance Function Tip Text ( ) { return STR_ + STR_ ; }
public boolean is Filled ( ) { return filled ; }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; }
public long scheduled Execution Time ( ) { if ( expired ) { return - NUM_ ; } else { return time . get Time ( ) ; } }
private static Class Node create Usable Class Node From Generics Type ( final Generics Type generics Type ) { Class Node value = generics Type . get Type ( ) ; if ( generics Type . is Placeholder ( ) ) { value = OBJECT TYPE ; } Class Node lower Bound = generics Type . get Lower Bound ( ) ; if ( lower Bound != null ) { value = lower Bound ; } else { Class Node [ ] upper Bounds = generics Type . get Upper Bounds ( ) ; if ( upper Bounds != null ) { value = Widening Categories . lowest Upper Bound ( Arrays . as List ( upper Bounds ) ) ; } } return value ; }
public static Integer zpvc ( Number ... values ) { if ( values == null || values . length == NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } int count = NUM_ ; for ( Number value : values ) { if ( value != null && value . double Value ( ) >= NUM_ ) { count ++ ; } } return count ; }
public static String read Ascii Line ( Input Stream in ) throws IO Exception { String Builder result = new String Builder ( NUM_ ) ; while ( true ) { int c = in . read ( ) ; if ( c == - NUM_ ) { throw new EOF Exception ( ) ; } else if ( c == STR_ ) { break ; } result . append ( ( char ) c ) ; } int length = result . length ( ) ; if ( length > NUM_ && result . char At ( length - NUM_ ) == STR_ ) { result . set Length ( length - NUM_ ) ; } return result . to String ( ) ; }
public static String read File Contents ( File file ) { String Builder script Text = new String Builder ( ) ; String new Line = System . get Property ( STR_ ) ; Scanner scanner = null ; try { scanner = new Scanner ( new File Input Stream ( file ) ) ; while ( scanner . has Next Line ( ) ) { script Text . append ( scanner . next Line ( ) + new Line ) ; } } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } finally { scanner . close ( ) ; } return script Text . to String ( ) ; }
private static double distance ( double [ ] p 1 , double [ ] p 2 ) { double sum = NUM_ ; for ( int i = NUM_ ; i < p 1 . length ; i ++ ) { sum += Math . pow ( p 2 [ i ] - p 1 [ i ] , NUM_ ) ; } return Math . sqrt ( sum ) ; }
public int hash Code ( ) { return Arrays . hash Code ( chars ) ; }
public static byte [ ] reverse Dword Bytes ( byte [ ] bytes , int trim Length ) { check Argument ( bytes . length % NUM_ == NUM_ ) ; check Argument ( trim Length < NUM_ || trim Length % NUM_ == NUM_ ) ; byte [ ] rev = new byte [ trim Length >= NUM_ && bytes . length > trim Length ? trim Length : bytes . length ] ; for ( int i = NUM_ ; i < rev . length ; i += NUM_ ) { System . arraycopy ( bytes , i , rev , i , NUM_ ) ; for ( int j = NUM_ ; j < NUM_ ; j ++ ) { rev [ i + j ] = bytes [ i + NUM_ - j ] ; } } return rev ; }
public static boolean use Name Suggestions ( Set < String > used Keys ) { return ! ( used Keys . contains ( Tags . KEY HIGHWAY ) || used Keys . contains ( Tags . KEY WATERWAY ) || used Keys . contains ( Tags . KEY LANDUSE ) || used Keys . contains ( Tags . KEY NATURAL ) || used Keys . contains ( Tags . KEY RAILWAY ) ) ; }
public static boolean should Highlight Methd ( String soot Method Signature ) { return methods To Highlight . contains ( soot Method Signature ) ; }
public synchronized int length ( ) { return value . size ( ) ; }
public static List < List < File > > find Java Files Per Directory ( File parent , String ... dir Names ) { List < List < File > > files Per Directory = new Array List < > ( ) ; for ( String dir Name : dir Names ) { File dir = new File ( parent , dir Name ) ; if ( dir . is Directory ( ) ) { files Per Directory . add All ( find Java Test Files In Directory ( dir ) ) ; } } return files Per Directory ; }
public static long pop xor ( long [ ] arr 1 , long [ ] arr 2 , int word Offset , int num Words ) { long pop Count = NUM_ ; for ( int i = word Offset , end = word Offset + num Words ; i < end ; ++ i ) { pop Count += Long . bit Count ( arr 1 [ i ] ^ arr 2 [ i ] ) ; } return pop Count ; }
static public Serial Sensor Manager instance ( ) { if ( instance == null ) { instance = new Serial Sensor Manager ( ) ; } return instance ; }
public List to List ( ) { Object [ ] copied Elements = new Object [ num Elements ] ; System . arraycopy ( elements , NUM_ , copied Elements , NUM_ , num Elements ) ; return Arrays . as List ( copied Elements ) ; }
public static Flickr Photo match URL ( String url , String text ) { Matcher m = GROUPING PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return new Flickr Photo ( m . group ( NUM_ ) , null , m . group ( NUM_ ) , m . group ( NUM_ ) , text ) ; } m = URL PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return new Flickr Photo ( m . group ( NUM_ ) , m . group ( NUM_ ) , null , null , text ) ; } else { return null ; } }
@ Override public int port Local ( ) { Socket s = get Socket ( ) ; if ( s != null ) { return s . get Local Port ( ) ; } else { return - NUM_ ; } }
public long count ( ) { return count . get ( ) ; }
public static List < Episode > return New Episodes ( Context context , Channel channel , List < Episode > new Episode List ) { List < Episode > new Episodes = new Array List < > ( ) ; List < Episode > existing Episode List = get Episodes By Channel ( context , channel ) ; Map < String , Episode > existing Episode Map = new Array Map < > ( existing Episode List . size ( ) ) ; for ( int i = NUM_ ; i < existing Episode List . size ( ) ; i ++ ) { Episode episode = existing Episode List . get ( i ) ; existing Episode Map . put ( episode . get Generated Id ( ) , episode ) ; } for ( int i = NUM_ ; i < new Episode List . size ( ) ; i ++ ) { Episode episode = new Episode List . get ( i ) ; if ( ! existing Episode Map . contains Key ( episode . get Generated Id ( ) ) ) { new Episodes . add ( episode ) ; } } return new Episodes ; }
Sorted Set < String > types To Import ( ) { Sorted Set < String > types To Import = new Tree Set < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entry Set ( ) ) { if ( entry . get Value ( ) . import It ) { types To Import . add ( entry . get Key ( ) ) ; } } return types To Import ; }
public boolean read Message ( Input Stream is ) throws IO Exception { Thread thread = Thread . current Thread ( ) ; Class Loader loader = thread . get Context Class Loader ( ) ; try ( Outbox Amp outbox = Outbox Amp . current Or Create ( get Manager ( ) ) ) { return read Message ( is , outbox ) ; } catch ( Throwable e ) { log . log ( Level . WARNING , e . to String ( ) , e ) ; throw e ; } finally { thread . set Context Class Loader ( loader ) ; } }
public static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( NUM_ + r * r ) ; } else if ( b != NUM_ ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( NUM_ + r * r ) ; } else { r = NUM_ ; } return r ; }
public static int utf 8 Length ( String string ) { Character Iterator iter = new String Character Iterator ( string ) ; char ch = iter . first ( ) ; int size = NUM_ ; while ( ch != Character Iterator . DONE ) { if ( ( ch >= NUM_ ) && ( ch < NUM_ ) ) { char trail = iter . next ( ) ; if ( ( trail > NUM_ ) && ( trail < NUM_ ) ) { size += NUM_ ; } else { size += NUM_ ; iter . previous ( ) ; } } else if ( ch < NUM_ ) { size ++ ; } else if ( ch < NUM_ ) { size += NUM_ ; } else { size += NUM_ ; } ch = iter . next ( ) ; } return size ; }
public List < I Resource > choose Resources ( ) { if ( open ( ) == Window . OK ) { List < I Resource > resources = new Array List < I Resource > ( ) ; for ( Object obj : get Result ( ) ) { resources . add ( ( I Resource ) obj ) ; } return resources ; } return null ; }
protected boolean is Stopped ( ) { return this . is Stopped ; }
public String scm Revision ( ) { return properties . get Property ( STR_ ) ; }
public static < T extends Generic Entity > List < T > filter By Or ( List < T > values , List < ? extends Entity Condition > exprs ) { if ( values == null ) return null ; if ( Util Validate . is Empty ( exprs ) ) { return values ; } List < T > result = new Linked List < T > ( ) ; for ( T value : values ) { boolean include = false ; for ( Entity Condition condition : exprs ) { include = condition . entity Matches ( value ) ; if ( include ) break ; } if ( include ) { result . add ( value ) ; } } return result ; }
static boolean less Than Unsigned ( long x 1 , long x 2 ) { return ( x 1 + Long . MIN VALUE ) < ( x 2 + Long . MIN VALUE ) ; }
public String to Verbose String ( ) { String Buffer result = new String Buffer ( ) ; result . append ( STR_ ) ; result . append ( get Name ( ) ) ; result . append ( STR_ ) ; result . append ( get Java Name ( ) ) ; result . append ( STR_ ) ; result . append ( get Mapped Type ( ) ) ; result . append ( STR_ ) ; result . append ( get Mapped Type Code ( ) ) ; result . append ( STR_ ) ; result . append ( get Size ( ) ) ; result . append ( STR_ ) ; result . append ( is Required ( ) ) ; result . append ( STR_ ) ; result . append ( is Primary Key ( ) ) ; result . append ( STR_ ) ; result . append ( is Auto Increment ( ) ) ; result . append ( STR_ ) ; result . append ( get Default Value ( ) ) ; result . append ( STR_ ) ; result . append ( get Precision Radix ( ) ) ; result . append ( STR_ ) ; result . append ( get Scale ( ) ) ; result . append ( STR_ ) ; return result . to String ( ) ; }
public static double distance ( Lat Lng point A , Lat Lng point B ) { double lat = Math . to Radians ( point A . latitude ) ; double lat 2 = Math . to Radians ( point B . latitude ) ; double dif Lat = Math . to Radians ( point B . latitude - point A . latitude ) ; double dif Long = Math . to Radians ( point B . longitude - point A . longitude ) ; double a = ( Math . pow ( Math . sin ( dif Lat / NUM_ ) , NUM_ ) ) + ( Math . cos ( lat ) * Math . cos ( lat 2 ) * Math . pow ( Math . sin ( dif Long / NUM_ ) , NUM_ ) ) ; double c = NUM_ * Math . atan 2 ( Math . sqrt ( a ) , Math . sqrt ( NUM_ - a ) ) ; return EARTH * c ; }
public static String signature Class ( String sig ) { int pos = sig . index Of ( STR_ ) ; return sig . substring ( NUM_ , pos ) ; }
private void return Buffer ( Byte Buffer buf ) { if ( buf != null ) { buf . clear ( ) ; buffer Pool . add ( buf ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new Option ( STR_ + default Num Examples ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public static boolean is Absolute URI ( String system Id ) { if ( is Windows Absolute Path ( system Id ) ) { return false ; } final int fragment Index = system Id . index Of ( STR_ ) ; final int query Index = system Id . index Of ( STR_ ) ; final int slash Index = system Id . index Of ( STR_ ) ; final int colon Index = system Id . index Of ( STR_ ) ; int index = system Id . length ( ) - NUM_ ; if ( fragment Index > NUM_ ) index = fragment Index ; if ( ( query Index > NUM_ ) && ( query Index < index ) ) index = query Index ; if ( ( slash Index > NUM_ ) && ( slash Index < index ) ) index = slash Index ; return ( ( colon Index > NUM_ ) && ( colon Index < index ) ) ; }
public static String create Html Document ( Map < String , Object > style , String text , double scale ) { String Buffer css = new String Buffer ( ) ; css . append ( STR_ + get String ( style , mx Constants . STYLE FONTFAMILY , mx Constants . DEFAULT FONTFAMILIES ) + STR_ ) ; css . append ( STR_ + ( int ) ( get Int ( style , mx Constants . STYLE FONTSIZE , mx Constants . DEFAULT FONTSIZE ) * scale ) + STR_ ) ; String color = mx Utils . get String ( style , mx Constants . STYLE FONTCOLOR ) ; if ( color != null ) { css . append ( STR_ + color + STR_ ) ; } int font Style = mx Utils . get Int ( style , mx Constants . STYLE FONTSTYLE ) ; if ( ( font Style & mx Constants . FONT BOLD ) == mx Constants . FONT BOLD ) { css . append ( STR_ ) ; } if ( ( font Style & mx Constants . FONT ITALIC ) == mx Constants . FONT ITALIC ) { css . append ( STR_ ) ; } if ( ( font Style & mx Constants . FONT UNDERLINE ) == mx Constants . FONT UNDERLINE ) { css . append ( STR_ ) ; } String align = get String ( style , mx Constants . STYLE ALIGN , mx Constants . ALIGN LEFT ) ; if ( align . equals ( mx Constants . ALIGN CENTER ) ) { css . append ( STR_ ) ; } else if ( align . equals ( mx Constants . ALIGN RIGHT ) ) { css . append ( STR_ ) ; } return STR_ + css . to String ( ) + STR_ + text + STR_ ; }
public static String encode ( String source ) { String Buffer dest = new String Buffer ( ) ; int source Len = source . length ( ) ; for ( int i = NUM_ ; i < source Len ; i ++ ) { int run Length = NUM_ ; final char current Char = source . char At ( i ) ; while ( i + NUM_ < source Len && current Char == source . char At ( i + NUM_ ) ) { run Length ++ ; i ++ ; } dest . append ( run Length ) ; dest . append ( current Char ) ; } return dest . to String ( ) ; }
public double pdf ( double x ) { double diff = x - mean ; return SQRT INV * Math . exp ( - ( diff * diff ) / ( NUM_ * variance ) ) ; }
public boolean has trace exit restrictions ( ) { for ( int index = first layer ( ) ; index <= last layer ( ) ; ++ index ) { Collection < Brd Trace Exit Restriction > curr exit restrictions = get trace exit restrictions ( index ) ; if ( curr exit restrictions . size ( ) > NUM_ ) return true ; } return false ; }
public String statement To Code String ( int i ) { String Builder one Statement = new String Builder ( ) ; sequence . append Code ( one Statement , i ) ; return one Statement . to String ( ) ; }
public static String read Fully ( Reader reader ) throws IO Exception { try { String Writer writer = new String Writer ( ) ; char [ ] buffer = new char [ NUM_ ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM_ ) { writer . write ( buffer , NUM_ , count ) ; } return writer . to String ( ) ; } finally { reader . close ( ) ; } }
public static String create Name Identifier ( ) { String handle = null ; try { byte [ ] handle Bytes = new byte [ NUM_ ] ; random Generator . next Bytes ( handle Bytes ) ; handle = Base 64 . encode ( handle Bytes ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + handle ) ; } } catch ( Exception e ) { debug . message ( STR_ + STR_ + e . get Message ( ) ) ; } return handle ; }
public Coder Result unmappable Result ( ) { assert ( error == null ) ; return Coder Result . unmappable For Length ( is Pair ? NUM_ : NUM_ ) ; }
public String build Activiti Id String ( String namespace Cd , String job Name ) { Map < String , String > path To Token Value Map = new Hash Map < > ( ) ; path To Token Value Map . put ( get Namespace Token ( ) , namespace Cd ) ; path To Token Value Map . put ( get Job Name Token ( ) , job Name ) ; String activiti Id = get Activiti Job Definition Template ( ) ; for ( Map . Entry < String , String > map Entry : path To Token Value Map . entry Set ( ) ) { activiti Id = activiti Id . replace All ( map Entry . get Key ( ) , map Entry . get Value ( ) ) ; } return activiti Id ; }
public String ruby Type Name ( Type Ref type Ref ) { switch ( type Ref . get Kind ( ) ) { case TYPE MESSAGE : return ruby Type Name For Proto Element ( type Ref . get Message Type ( ) ) ; case TYPE ENUM : return ruby Type Name For Proto Element ( type Ref . get Enum Type ( ) ) ; default : { String name = PRIMITIVE TYPE NAMES . get ( type Ref . get Kind ( ) ) ; if ( ! Strings . is Null Or Empty ( name ) ) { return name ; } throw new Illegal Argument Exception ( STR_ + type Ref . get Kind ( ) ) ; } } }
public Publisher Merge < T > merge Additional Source ( Publisher < ? extends T > source , Int Function < Supplier < ? extends Queue < T > > > new Queue Supplier ) { int n = sources . length ; @ Suppress Warnings ( STR_ ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM_ ] ; System . arraycopy ( sources , NUM_ , new Array , NUM_ , n ) ; new Array [ n ] = source ; Supplier < ? extends Queue < T > > new Main Queue ; int mc = max Concurrency ; if ( mc != Integer . MAX VALUE ) { mc ++ ; new Main Queue = new Queue Supplier . apply ( mc ) ; } else { new Main Queue = main Queue Supplier ; } return new Publisher Merge < > ( new Array , delay Error , mc , new Main Queue , prefetch , inner Queue Supplier ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Safe Varargs public static < T > Set < T > as Set ( final T ... array ) { Set < T > array Set = new Hash Set < T > ( array . length ) ; Collections . add All ( array Set , array ) ; return array Set ; }
private static URL file To URL ( File file ) { String name ; try { name = file . get Canonical Path ( ) ; } catch ( IO Exception e ) { name = file . get Absolute Path ( ) ; } name = name . replace ( File . separator Char , STR_ ) ; if ( ! name . starts With ( STR_ ) ) { name = STR_ + name ; } if ( ! file . is File ( ) ) { name = name + STR_ ; } try { return new URL ( STR_ , STR_ , name ) ; } catch ( Malformed URL Exception e ) { throw new Illegal Argument Exception ( STR_ ) ; } }
public String to Dot ( ) { String Builder b = new String Builder ( ) ; b . append ( STR_ ) ; b . append ( STR_ ) ; final int num States = get Num States ( ) ; if ( num States > NUM_ ) { b . append ( STR_ ) ; b . append ( STR_ ) ; } Transition t = new Transition ( ) ; for ( int state = NUM_ ; state < num States ; state ++ ) { b . append ( STR_ ) ; b . append ( state ) ; if ( is Accept ( state ) ) { b . append ( STR_ + state + STR_ ) ; } else { b . append ( STR_ + state + STR_ ) ; } int num Transitions = init Transition ( state , t ) ; for ( int i = NUM_ ; i < num Transitions ; i ++ ) { get Next Transition ( t ) ; assert t . max >= t . min ; b . append ( STR_ ) ; b . append ( state ) ; b . append ( STR_ ) ; b . append ( t . dest ) ; b . append ( STR_ ) ; append Char String ( t . min , b ) ; if ( t . max != t . min ) { b . append ( STR_ ) ; append Char String ( t . max , b ) ; } b . append ( STR_ ) ; } } b . append ( STR_ ) ; return b . to String ( ) ; }
private static float spacing ( Motion Event event ) { float x = event . get X ( NUM_ ) - event . get X ( NUM_ ) ; float y = event . get Y ( NUM_ ) - event . get Y ( NUM_ ) ; return ( float ) Math . sqrt ( x * x + y * y ) ; }
public String next Token ( ) { String result = null ; synchronized ( this ) { if ( is Empty ( ) ) { return null ; } else { if ( is Eating Blocks Of Delimiters ) { trim Starting Delimiters ( ) ; } int nearest Delimeter = - NUM_ ; for ( int i = NUM_ ; i < delimiters . length ( ) ; i ++ ) { int delimiter = source . index Of ( delimiters . char At ( i ) , current Index ) ; if ( nearest Delimeter == - NUM_ || delimiter != - NUM_ && delimiter < nearest Delimeter ) { nearest Delimeter = delimiter ; } } if ( nearest Delimeter == - NUM_ ) { result = source . substring ( current Index ) ; current Index = source . length ( ) ; } else { result = source . substring ( current Index , nearest Delimeter ) ; current Index = nearest Delimeter + NUM_ ; if ( is Eating Blocks Of Delimiters ) { trim Starting Delimiters ( ) ; } } } } return result ; }
public boolean contains One Category ( List categories ) { for ( Iterator iter = categories . iterator ( ) ; iter . has Next ( ) ; ) { Group Category category = ( Group Category ) iter . next ( ) ; if ( contains ( category ) ) return true ; } return false ; }
public boolean find ( int start ) { if ( start < NUM_ || start > input . length ( ) ) { throw new Index Out Of Bounds Exception ( STR_ + start + STR_ + input . length ( ) ) ; } synchronized ( this ) { match Found = find Impl ( address , input , start , match Offsets ) ; } return match Found ; }
public static String tick To String ( String Builder clslbls , long timestamp , long location , long elevation , Object value ) { try { String Builder sb = new String Builder ( ) ; sb . append ( timestamp ) ; sb . append ( STR_ ) ; if ( Geo Time Serie . NO LOCATION != location ) { double [ ] latlon = Geo XP Lib . from Geo XP Point ( location ) ; sb . append ( latlon [ NUM_ ] ) ; sb . append ( STR_ ) ; sb . append ( latlon [ NUM_ ] ) ; } sb . append ( STR_ ) ; if ( Geo Time Serie . NO ELEVATION != elevation ) { sb . append ( elevation ) ; } sb . append ( STR_ ) ; if ( null != clslbls && clslbls . length ( ) > NUM_ ) { sb . append ( clslbls ) ; sb . append ( STR_ ) ; } encode Value ( sb , value ) ; return sb . to String ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return null ; }
public static double log 2 ( double arg ) { return Math . log ( arg ) / Math . log ( NUM_ ) ; }
private static boolean validate String ( String string ) { return ! string . contains ( STR_ ) ; }
synchronized String seg String ( Iterable < Segment Commit Info > infos ) { final String Builder buffer = new String Builder ( ) ; for ( final Segment Commit Info info : infos ) { if ( buffer . length ( ) > NUM_ ) { buffer . append ( STR_ ) ; } buffer . append ( seg String ( info ) ) ; } return buffer . to String ( ) ; }
@ Deprecated public Iterator < Pdf Object > direct Iterator ( ) { return new Pdf Array Direct Iterator ( list . iterator ( ) ) ; }
public Version create Version ( int value ) { Proto Version Field proto Version Field = new Proto Version Field ( ) ; try { proto Version Field . set Version ( value ) ; } catch ( Sdp Exception s ) { s . print Stack Trace ( ) ; return null ; } return proto Version Field ; }
public static boolean is Logout Success ( Http Servlet Request request ) { String status = request . get Parameter ( IFS Constants . LOGOUT STATUS ) ; if ( status == null || status . equals Ignore Case ( IFS Constants . LOGOUT SUCCESS ) ) { return true ; } else { return false ; } }
default Configuration with System Properties ( Function < String , String > property Name Converter ) { Properties props = as Properties ( ) ; Properties system Properties = System . get Properties ( ) ; for ( String key : system Properties . string Property Names ( ) ) { String prop Name = property Name Converter . apply ( key ) ; if ( prop Name != null && prop Name . length ( ) > NUM_ ) { String value = system Properties . get Property ( key ) ; props . set Property ( prop Name , value ) ; } } return from ( props ) ; }
public int hash Code ( ) { return numerator . hash Code ( ) + denominator . hash Code ( ) ; }
public int num Processors ( ) { return m processors ; }
public String to Hex String ( ) { return m value . to String ( NUM_ ) ; }
public int hash Code ( ) { return name . hash Code ( ) ^ ( value == null ? NUM_ : value . hash Code ( ) ) ; }
public static boolean has Next Key Typed ( ) { synchronized ( key Lock ) { return ! keys Typed . is Empty ( ) ; } }
public static boolean is Note Valid ( String value ) { return value == null || value . length ( ) < NUM_ * NUM_ ; }
public static List < String > read File ( final File arg File ) throws IO Exception { final Buffered Reader br = new Buffered Reader ( new File Reader ( arg File ) ) ; String line ; List < String > lines = new Array List < String > ( ) ; while ( ( line = br . read Line ( ) ) != null ) { lines . add ( line ) ; } br . close ( ) ; return lines ; }
@ Override public int hash Code ( ) { return string . hash Code ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public int hash Code ( ) { return value . hash Code ( ) ^ locale . hash Code ( ) ; }
public static Internet Address parse Email ( Object value ) { String str = Caster . to String ( value , STR_ ) ; if ( str . index Of ( STR_ ) > - NUM_ ) { try { Internet Address addr = new Internet Address ( str ) ; fix IDN ( addr ) ; return addr ; } catch ( Address Exception ex ) { } } return null ; }
@ Override public double [ ] cluster Priors ( ) { double [ ] n = new double [ m priors . length ] ; System . arraycopy ( m priors , NUM_ , n , NUM_ , n . length ) ; return n ; }
@ Override public boolean contains Key ( Object key ) { if ( key == null ) { return false ; } K [ ] keys = keys ; for ( int i = size - NUM_ ; i >= NUM_ ; i -- ) { K test Key = keys [ i ] ; if ( key . equals ( test Key ) ) { return true ; } } return false ; }
private boolean point In Current Polygon ( final Point p ) { if ( m current == null ) { return false ; } for ( final Polygon item : m current ) { if ( item . contains ( p ) ) { return true ; } } return false ; }
public Object clone ( ) { try { return super . clone ( ) ; } catch ( Clone Not Supported Exception e ) { throw new Runtime Exception ( e . get Message ( ) ) ; } }
public void throw If Necessary ( ) { if ( ! failure List . is Empty ( ) ) { Runtime Exception ex = null ; for ( AIS Validation Failure f : failure List ) { LOG . debug ( String . format ( STR_ , f . error Code ( ) , f . message ( ) ) ) ; ex = Multiple Cause Exception . combine ( ex , f . get Exception ( ) ) ; } throw ex ; } }
public boolean contains Any ( Taxon List taxon List ) { for ( int i = NUM_ ; i < taxon List . get Taxon Count ( ) ; i ++ ) { Taxon taxon = taxon List . get Taxon ( i ) ; if ( taxa . contains ( taxon ) ) { return true ; } } return false ; }
private static String dir Name ( String node Name ) { for ( int i = NUM_ , n = node Name . length ( ) ; i < n ; i ++ ) if ( ! is Dir Char ( node Name . char At ( i ) ) ) return STR_ + Base 64 . byte Array To Alt Base 64 ( byte Array ( node Name ) ) ; return node Name ; }
public Boolean is Automatic Log Display Enabled ( ) { return false ; }
public final Char Sequence head ( Char Sequence csq ) { return csq . sub Sequence ( NUM_ , index ) ; }
public static boolean is Null Or Empty ( @ Nullable Map map ) { return is Null ( map ) || map . is Empty ( ) ; }
public boolean contains Primary Key ( ) { return contains Primary Key ( false ) ; }
public String element ( int i ) { return elements . get ( i ) ; }
public Media Description create Media Description ( String media , int port , int num Ports , String transport , String [ ] formats ) { Media Description Impl media Description Impl = new Media Description Impl ( ) ; try { Media Field media Impl = new Media Field ( ) ; media Impl . set Media Type ( media ) ; media Impl . set Media Port ( port ) ; media Impl . set Port Count ( num Ports ) ; media Impl . set Protocol ( transport ) ; Vector formats V = new Vector ( formats . length ) ; for ( int i = NUM_ ; i < formats . length ; i ++ ) formats V . add ( formats [ i ] ) ; media Impl . set Media Formats ( formats V ) ; media Description Impl . set Media ( media Impl ) ; } catch ( Sdp Exception s ) { s . print Stack Trace ( ) ; } return media Description Impl ; }
private boolean check Valid Workspace ( final Shell shell , final URL url ) { if ( url == null ) { return false ; } if ( WORKSPACE CHECK REFERENCE BUNDLE VERSION == null ) { return true ; } final Version version = read Workspace Version ( url ) ; if ( version == null ) { return true ; } final Version ide version = to Major Minor Version ( WORKSPACE CHECK REFERENCE BUNDLE VERSION ) ; final Version workspace version = to Major Minor Version ( version ) ; final int version Compare Result = workspace version . compare To ( ide version ) ; if ( version Compare Result == NUM_ ) { return true ; } int severity ; String title ; String message ; if ( version Compare Result < NUM_ ) { severity = INFORMATION ; title = IDE Application version Title older Workspace ; message = NLS . bind ( IDE Application version Message older Workspace , url . get File ( ) ) ; } else { severity = WARNING ; title = IDE Application version Title newer Workspace ; message = NLS . bind ( IDE Application version Message newer Workspace , url . get File ( ) ) ; } final Message Dialog dialog = new Message Dialog ( shell , title , null , message , severity , new String [ ] { I Dialog Constants . OK LABEL , I Dialog Constants . CANCEL LABEL } , NUM_ ) ; return dialog . open ( ) == Window . OK ; }
public Period minus Years ( int years ) { return plus Years ( - years ) ; }
protected Column add Column ( Result Set rs , String column Name ) throws SQL Exception { return new Column ( column Name , rs . get Int ( STR_ ) ) ; }
@ Override public int hash Code ( ) { return Objects . hash Code ( this . value ) ; }
public char to Char Array ( ) [ ] { return Arrays . copy Of ( buf , count ) ; }
private int color Wheel Location To RGB ( int x , int y , double rad ) { double angle = Math . acos ( ( double ) x / rad ) ; int rgb ; if ( angle < PI 3 ) { if ( y < NUM_ ) { rgb = NUM_ | Math . min ( NUM_ , ( int ) ( NUM_ * angle / PI 3 ) ) << NUM_ ; } else { rgb = NUM_ | Math . min ( NUM_ , ( int ) ( NUM_ * angle / PI 3 ) ) ; } } else if ( angle < NUM_ * PI 3 ) { angle -= PI 3 ; if ( y < NUM_ ) { rgb = NUM_ | Math . max ( NUM_ , NUM_ - ( int ) ( NUM_ * angle / PI 3 ) ) << NUM_ ; } else { rgb = NUM_ | Math . max ( NUM_ , NUM_ - ( int ) ( NUM_ * angle / PI 3 ) ) << NUM_ ; } } else { angle -= NUM_ * PI 3 ; if ( y < NUM_ ) { rgb = NUM_ | Math . min ( NUM_ , ( int ) ( NUM_ * angle / PI 3 ) ) ; } else { rgb = NUM_ | Math . min ( NUM_ , ( int ) ( NUM_ * angle / PI 3 ) ) << NUM_ ; } } return rgb ; }
public < T extends Page Object > void wait Until ( T entity , Predicate < T > wait Until , String error Message ) { Preconditions . check Not Null ( entity ) ; Preconditions . check Not Null ( wait Until ) ; Preconditions . check Argument ( ! Strings . is Null Or Empty ( error Message ) ) ; wait Until After ( entity , wait Until , error Message , wait In Seconds ) ; }
private static String stack Trace To String ( Throwable t ) { final String Builder sb = new String Builder ( ) ; final String indent = STR_ ; for ( Stack Trace Element frame : t . get Stack Trace ( ) ) { sb . append ( indent ) ; sb . append ( frame . to String ( ) ) ; sb . append ( STR_ ) ; } return sb . to String ( ) ; }
private void check ( ) { if ( descs . length == NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } for ( int i = NUM_ ; i < descs . length ; i ++ ) { Method Desc desc = descs [ i ] ; String dname = desc . name ; if ( dname == null ) { if ( i < descs . length - NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } } else if ( dname . char At ( NUM_ ) == STR_ ) { int dlen = dname . length ( ) + NUM_ ; for ( int j = NUM_ ; j < i ; j ++ ) { Method Desc prev = descs [ j ] ; String pname = prev . name ; if ( pname . char At ( NUM_ ) == STR_ && pname . region Matches ( NUM_ , dname , dlen - pname . length ( ) , pname . length ( ) - NUM_ ) ) { check ( prev , desc ) ; } } } else if ( dname . char At ( dname . length ( ) - NUM_ ) == STR_ ) { for ( int j = NUM_ ; j < i ; j ++ ) { Method Desc prev = descs [ j ] ; String pname = prev . name ; int plen = pname . length ( ) - NUM_ ; if ( pname . char At ( plen ) == STR_ && pname . region Matches ( NUM_ , dname , NUM_ , plen ) ) { check ( prev , desc ) ; } } } else { for ( int j = NUM_ ; j < i ; j ++ ) { Method Desc prev = descs [ j ] ; String pname = prev . name ; int plen = pname . length ( ) - NUM_ ; if ( pname . char At ( NUM_ ) == STR_ ) { if ( dname . region Matches ( dname . length ( ) - plen , pname , NUM_ , plen ) ) { check ( prev , desc ) ; } } else if ( pname . char At ( plen ) == STR_ ) { if ( dname . region Matches ( NUM_ , pname , NUM_ , plen ) ) { check ( prev , desc ) ; } } else { if ( pname . equals ( dname ) ) { check ( prev , desc ) ; } } } } } }
private int send Type ( Heap Data Output Stream buf ) throws IO Exception { if ( struct Type != null ) { buf . write Byte ( TYPE CHUNK ) ; Data Serializer . write Object ( struct Type , buf ) ; return send Bufferred Data ( buf , false ) ; } else { return NUM_ ; } }
public int size ( ) { return collections . size ( ) ; }
public int stack depth ( ) { return max stack level ; }
@ Override boolean is Paint Valid ( Sun Graphics 2 D sg 2 d ) { Texture Paint paint = ( Texture Paint ) sg 2 d . paint ; OGL Surface Data dst Data = ( OGL Surface Data ) sg 2 d . surface Data ; Buffered Image bi = paint . get Image ( ) ; if ( ! dst Data . is Tex Non Pow 2 Available ( ) ) { int imgw = bi . get Width ( ) ; int imgh = bi . get Height ( ) ; if ( ( imgw & ( imgw - NUM_ ) ) != NUM_ || ( imgh & ( imgh - NUM_ ) ) != NUM_ ) { return false ; } } Surface Data src Data = dst Data . get Source Surface Data ( bi , Sun Graphics 2 D . TRANSFORM ISIDENT , Composite Type . Src Over , null ) ; if ( ! ( src Data instanceof OGL Surface Data ) ) { src Data = dst Data . get Source Surface Data ( bi , Sun Graphics 2 D . TRANSFORM ISIDENT , Composite Type . Src Over , null ) ; if ( ! ( src Data instanceof OGL Surface Data ) ) { return false ; } } OGL Surface Data ogl Data = ( OGL Surface Data ) src Data ; if ( ogl Data . get Type ( ) != OGL Surface Data . TEXTURE ) { return false ; } return true ; }
public static Date next Date ( ) { return next Date ( new Date ( ) , true ) ; }
public String app source path ( String app class ) { String filename = app class . replace ( STR_ , STR_ ) ; filename = filename . replace First ( STR_ , STR_ ) ; if ( filename . index Of ( STR_ ) > NUM_ ) { filename = filename . substring ( NUM_ , filename . index Of ( STR_ ) ) ; } return STR_ + filename + STR_ ; }
public Match Result match ( ) { if ( ! match Successful ) { throw new Illegal State Exception ( ) ; } return matcher . to Match Result ( ) ; }
public static double exp ( double lambda ) { return - Math . log ( NUM_ - Math . random ( ) ) / lambda ; }
public static boolean equal ( Object a , Object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }
public List < Resource Node > ls ( String session ID , String path , boolean do Recurse ) throws Directory Not Found Exception { Resource Node start Node = null ; start Node = get Start Node ( session ID , path ) ; List < Resource Node > entries = new Linked List < Resource Node > ( ) ; if ( ! start Node . is Container ( ) ) { entries . add ( start Node ) ; return entries ; } get Entries ( start Node , entries , do Recurse ) ; return entries ; }
public boolean is Content Setting Enabled ( int content Settings Type ) { return native Is Content Setting Enabled ( content Settings Type ) ; }
public int count Tokens ( ) { int count = NUM_ ; boolean in Token = false ; for ( int i = position , length = string . length ( ) ; i < length ; i ++ ) { if ( delimiters . index Of ( string . char At ( i ) , NUM_ ) >= NUM_ ) { if ( return Delimiters ) count ++ ; if ( in Token ) { count ++ ; in Token = false ; } } else { in Token = true ; } } if ( in Token ) count ++ ; return count ; }
public List < String > message Comments ( Message Type msg , Python Import Handler import Handler ) { String Builder param Types Builder = new String Builder ( ) ; param Types Builder . append ( STR_ ) ; for ( Field field : msg . get Fields ( ) ) { param Types Builder . append ( field Comment ( field . get Simple Name ( ) , field , import Handler , null ) ) ; } String param Types = param Types Builder . to String ( ) ; String Builder content Builder = new String Builder ( ) ; if ( msg . has Attribute ( Element Documentation Attribute . KEY ) ) { content Builder . append ( get Sphinxified Scoped Description ( msg ) ) ; if ( ! Strings . is Null Or Empty ( param Types ) ) { content Builder . append ( STR_ ) ; } } content Builder . append ( param Types ) ; return python Common . convert To Commented Block ( content Builder . to String ( ) ) ; }
public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; if ( m Stats != null ) { new Vector . add All ( Collections . list ( m Stats . enumerate Measures ( ) ) ) ; } return new Vector . elements ( ) ; }
public static float hue ( int color ) { int r = ( color > > NUM_ ) & NUM_ ; int g = ( color > > NUM_ ) & NUM_ ; int b = color & NUM_ ; int V = Math . max ( b , Math . max ( r , g ) ) ; int temp = Math . min ( b , Math . min ( r , g ) ) ; float H ; if ( V == temp ) { H = NUM_ ; } else { final float vtemp = V - temp ; final float cr = ( V - r ) / vtemp ; final float cg = ( V - g ) / vtemp ; final float cb = ( V - b ) / vtemp ; if ( r == V ) { H = cb - cg ; } else if ( g == V ) { H = NUM_ + cr - cb ; } else { H = NUM_ + cg - cr ; } H /= NUM_ ; if ( H < NUM_ ) { H ++ ; } } return H ; }
private static DOM Implementation jaxp DOM Implementation ( ) { Document Builder Factory factory = Document Builder Factory . new Instance ( ) ; factory . set Namespace Aware ( true ) ; Document Builder builder ; try { builder = factory . new Document Builder ( ) ; } catch ( Parser Configuration Exception e ) { throw new Runtime Exception ( e ) ; } return builder . get DOM Implementation ( ) ; }
public static boolean is Windows Key Store ( String storetype ) { return storetype . equals Ignore Case ( STR_ ) || storetype . equals Ignore Case ( STR_ ) ; }
public int hash Code ( ) { int result = NUM_ ; if ( is Destroyed ( ) ) { return result ; } result = result * NUM_ + Arrays . hash Code ( get Encoded ( ) ) ; result = result * NUM_ + end Time . hash Code ( ) ; result = result * NUM_ + client . hash Code ( ) ; result = result * NUM_ + server . hash Code ( ) ; result = result * NUM_ + session Key . hash Code ( ) ; if ( auth Time != null ) { result = result * NUM_ + auth Time . hash Code ( ) ; } if ( start Time != null ) { result = result * NUM_ + start Time . hash Code ( ) ; } if ( renew Till != null ) { result = result * NUM_ + renew Till . hash Code ( ) ; } result = result * NUM_ + Arrays . hash Code ( client Addresses ) ; return result * NUM_ + Arrays . hash Code ( flags ) ; }
public String build Emr Cluster Name ( String namespace Cd , String emr Definition Name , String cluster Name ) { String token Delimiter = configuration Helper . get Property ( Configuration Value . TEMPLATE TOKEN DELIMITER ) ; String namespace Token = token Delimiter + STR_ + token Delimiter ; String emr Definition Token = token Delimiter + STR_ + token Delimiter ; String cluster Name Token = token Delimiter + STR_ + token Delimiter ; Map < String , String > path To Token Value Map = new Hash Map < > ( ) ; path To Token Value Map . put ( namespace Token , namespace Cd ) ; path To Token Value Map . put ( emr Definition Token , emr Definition Name ) ; path To Token Value Map . put ( cluster Name Token , cluster Name ) ; String default Cluster Name Template = namespace Token + STR_ + emr Definition Token + STR_ + cluster Name Token ; String emr Cluster Name = configuration Helper . get Property ( Configuration Value . EMR CLUSTER NAME TEMPLATE ) ; if ( emr Cluster Name == null ) { emr Cluster Name = default Cluster Name Template ; } for ( Map . Entry < String , String > map Entry : path To Token Value Map . entry Set ( ) ) { emr Cluster Name = emr Cluster Name . replace All ( map Entry . get Key ( ) , map Entry . get Value ( ) ) ; } return emr Cluster Name ; }
public static Date minus ( Date self , int days ) { return plus ( self , - days ) ; }
public static String null Format ( final Object obj ) { return obj == null ? STR_ : obj . to String ( ) ; }
boolean contains ( Binary Search Tree Node < E > node ) { if ( node == null ) return false ; if ( this . root == null ) return false ; if ( node == this . root ) return true ; Binary Search Tree Node < E > curr = this . root ; while ( curr != null ) { if ( curr == node ) return true ; int diff = node . compare To ( curr ) ; if ( diff == NUM_ ) { return curr == node ; } else if ( diff < NUM_ ) { curr = curr . left ; } else { curr = curr . right ; } } return false ; }
@ Override public Object clone ( ) throws Clone Not Supported Exception { return super . clone ( ) ; }
public int selected Link Size ( ) { return selected Link List . size ( ) ; }
public String business Object Definition Key To String ( Business Object Definition Key business Object Definition Key ) { return String . format ( STR_ , business Object Definition Key . get Namespace ( ) , business Object Definition Key . get Business Object Definition Name ( ) ) ; }
boolean is Resorting ( ) { return is Resorting ; }
public static Placeholder Fragment new Instance ( int section Number ) { Placeholder Fragment fragment = new Placeholder Fragment ( ) ; Bundle args = new Bundle ( ) ; args . put Int ( ARG SECTION NUMBER , section Number ) ; fragment . set Arguments ( args ) ; return fragment ; }
protected boolean raycast ( Vector 2 start , double length , double inv Dx , double inv Dy , AABB aabb ) { double tx 1 = ( aabb . get Min X ( ) - start . x ) * inv Dx ; double tx 2 = ( aabb . get Max X ( ) - start . x ) * inv Dx ; double tmin = Math . min ( tx 1 , tx 2 ) ; double tmax = Math . max ( tx 1 , tx 2 ) ; double ty 1 = ( aabb . get Min Y ( ) - start . y ) * inv Dy ; double ty 2 = ( aabb . get Max Y ( ) - start . y ) * inv Dy ; tmin = Math . max ( tmin , Math . min ( ty 1 , ty 2 ) ) ; tmax = Math . min ( tmax , Math . max ( ty 1 , ty 2 ) ) ; if ( tmax < NUM_ ) return false ; if ( tmin > length ) return false ; return tmax >= tmin ; }
public boolean is Na N ( ) { return Double . is Na N ( x . get Real ( ) ) || Double . is Na N ( y . get Real ( ) ) || Double . is Na N ( z . get Real ( ) ) ; }
public int hash Code ( ) { return op . hash Code ( ) ; }
public static boolean is Percentage ( String value ) { if ( ! is Integer ( value ) ) { return false ; } Integer integer = Integer . value Of ( value ) ; return integer >= NUM_ && integer <= NUM_ ; }
public static < T > boolean all Match ( final Collection < T > collection , final Match < T > a Match ) { if ( collection . is Empty ( ) ) { return false ; } for ( final T current : collection ) { if ( ! a Match . match ( current ) ) { return false ; } } return true ; }
public static Iterator search ( SSO Token token , String dn , String filter , int num Of Entries , int time Limit , boolean sort Results , boolean ascending Order , Set exclude ) throws SMS Exception { try { return sms Object . search ( token , dn , filter , num Of Entries , time Limit , sort Results , ascending Order , exclude ) ; } catch ( SSO Exception ssoe ) { debug . error ( STR_ + filter , ssoe ) ; throw new SMS Exception ( bundle . get String ( STR_ ) , ssoe , STR_ ) ; } }
@ Override public String read Line ( ) throws IO Exception { if ( this . pointer >= this . length - NUM_ ) { return null ; } else { final String Builder buf = new String Builder ( ) ; int c ; while ( ( c = read ( ) ) >= NUM_ ) { if ( ( c == NUM_ ) || ( c == NUM_ ) ) { if ( ( ( peek ( ) == NUM_ ) || ( peek ( ) == NUM_ ) ) && ( peek ( ) != c ) ) { read ( ) ; } break ; } buf . append ( ( char ) c ) ; } return buf . to String ( ) ; } }
private boolean read Equals Sign ( ) { skip Whitespace ( ) ; if ( pos < input . length ( ) && input . char At ( pos ) == STR_ ) { pos ++ ; return true ; } return false ; }
public boolean is Empty ( ) { return current Batch . is Empty ( ) ; }
public boolean show Dialog ( ) { set Visible ( true ) ; return continue Queue ; }
private int [ ] create Equal Partition ( double [ ] ratio , int size , Attribute label ) { List < Example Index > examples = new Array List < Example Index > ( size ) ; Iterator < Example > reader = example Set . iterator ( ) ; int index = NUM_ ; while ( reader . has Next ( ) ) { Example example = reader . next ( ) ; examples . add ( new Example Index ( index ++ , example . get Nominal Value ( label ) ) ) ; } Collections . shuffle ( examples , random ) ; Collections . sort ( examples ) ; List < Example Index > new Examples = new Array List < Example Index > ( size ) ; int start = NUM_ ; int number Of Partitions = ratio . length ; while ( new Examples . size ( ) < size ) { for ( int i = start ; i < examples . size ( ) ; i += number Of Partitions ) { new Examples . add ( examples . get ( i ) ) ; } start ++ ; } int [ ] start New P = new int [ ratio . length + NUM_ ] ; start New P [ NUM_ ] = NUM_ ; double ratio Sum = NUM_ ; for ( int i = NUM_ ; i < start New P . length ; i ++ ) { ratio Sum += ratio [ i - NUM_ ] ; start New P [ i ] = ( int ) Math . round ( new Examples . size ( ) * ratio Sum ) ; } int [ ] part = new int [ new Examples . size ( ) ] ; int p = NUM_ ; int counter = NUM_ ; Iterator < Example Index > n = new Examples . iterator ( ) ; while ( n . has Next ( ) ) { if ( counter >= start New P [ p + NUM_ ] ) { p ++ ; } Example Index example Index = n . next ( ) ; part [ example Index . example Index ] = p ; counter ++ ; } return part ; }
@ Override public int graph Type ( ) { return Drawable . Bayes Net ; }
private static long free Space Calculation ( String path ) { Stat Fs stat = new Stat Fs ( path ) ; long block Size = stat . get Block Size ( ) ; long available Blocks = stat . get Available Blocks ( ) ; return available Blocks * block Size / NUM_ ; }
protected int default Num Attributes ( ) { return NUM_ ; }
public boolean is Paused ( ) { return paused . get ( ) ; }
public static String pad Left ( String s , int length ) { if ( s . length ( ) > length ) { throw new Runtime Exception ( s + STR_ + length + STR_ ) ; } String t = STR_ ; for ( int i = NUM_ ; i < length - s . length ( ) ; i ++ ) { t += STR_ ; } return t + s ; }
public int hash Code ( ) { return ( id != null ) ? id . hash Code ( ) : NUM_ ; }
public Object clone ( ) { Syntax Scheme shcs = null ; try { shcs = ( Syntax Scheme ) super . clone ( ) ; } catch ( Clone Not Supported Exception cnse ) { cnse . print Stack Trace ( ) ; return null ; } shcs . styles = new Style [ Token . NUM TOKEN TYPES ] ; for ( int i = NUM_ ; i < Token . NUM TOKEN TYPES ; i ++ ) { Style s = styles [ i ] ; if ( s != null ) { shcs . styles [ i ] = ( Style ) s . clone ( ) ; } } return shcs ; }
public int int X ( ) { return ( int ) Math . floor ( this . x ) ; }
public Map Node next Stop ( ) { Map Node next = stops . get ( index ) ; if ( coming Back ) { index -- ; } else { index ++ ; } if ( index < NUM_ ) { coming Back = false ; index = NUM_ ; } if ( index >= stops . size ( ) ) { if ( type == PINGPONG ) { coming Back = true ; index = stops . size ( ) - NUM_ ; } else { index = NUM_ ; } } return next ; }
protected static void succeed ( ) { System . exit ( NUM_ ) ; }
public int size ( ) { return inputs . size ( ) ; }
private boolean is Battery Level Characteristic ( final Bluetooth Gatt Characteristic characteristic ) { if ( characteristic == null ) return false ; return BATTERY LEVEL CHARACTERISTIC . equals ( characteristic . get Uuid ( ) ) ; }
T take Next Connection ( ) throws Interrupted Exception { while ( true ) { T next = get Next Connection ( ) ; if ( next != null ) { return next ; } } }
final public boolean starts With Ignore Case ( final String prefix ) { final int l = prefix . length ( ) ; if ( l > length ( ) ) return false ; int i = l ; final char [ ] a = array ; char c , d ; while ( i -- != NUM_ ) { c = Character . to Lower Case ( Character . to Upper Case ( a [ i ] ) ) ; d = Character . to Lower Case ( Character . to Upper Case ( prefix . char At ( i ) ) ) ; if ( c != d ) return false ; } return true ; }
public String to Hex String ( final int start , final int length ) { final int rounded Start = ( start / LOG BYTES PER ROW ) * LOG BYTES PER ROW ; final String Builder sb = new String Builder ( STR_ ) ; int index = rounded Start ; for ( int n Logged = NUM_ ; n Logged < length ; n Logged += LOG BYTES PER ROW ) { sb . append ( String . format ( STR_ , index , index + LOG BYTES PER ROW - NUM_ ) ) ; for ( int i = NUM_ ; i < LOG BYTES PER ROW ; ++ i ) { try { final byte b = get Byte ( index ++ ) ; sb . append ( String . format ( STR_ , b ) ) ; } catch ( Index Out Of Bounds Exception ioob ) { sb . append ( STR_ ) ; } } sb . append ( STR_ ) ; } return sb . to String ( ) ; }
public final Iterator < Authority Entry > authorities Iterator ( ) { return m Data Authorities != null ? m Data Authorities . iterator ( ) : null ; }
public static String join ( String separator , double [ ] elements ) { if ( elements == null || elements . length == NUM_ ) { return STR_ ; } List < Double > list = new Array List < Double > ( elements . length ) ; for ( Double element : elements ) { list . add ( element ) ; } return join ( separator , list ) ; }
public boolean has Unsupported Critical Extension ( ) { Set extns = get Critical Extension OI Ds ( ) ; return extns != null && ! extns . is Empty ( ) ; }
public Shape inverse Transform ( Shape shape ) { float [ ] coords = new float [ NUM_ ] ; General Path path = new General Path ( General Path . WIND EVEN ODD ) ; Path Iterator pi = shape . get Path Iterator ( get Inverse Rotation Transform ( ) ) ; while ( ! pi . is Done ( ) ) { int type = pi . current Segment ( coords ) ; if ( type == Path Iterator . SEG MOVETO ) { path . move To ( coords [ NUM_ ] , coords [ NUM_ ] ) ; } else if ( type == Path Iterator . SEG LINETO ) { path . line To ( coords [ NUM_ ] , coords [ NUM_ ] ) ; } else if ( type == Path Iterator . SEG CLOSE ) { path . close Path ( ) ; } else { if ( type == Path Iterator . SEG QUADTO ) { path . quad To ( coords [ NUM_ ] , coords [ NUM_ ] , coords [ NUM_ ] , coords [ NUM_ ] ) ; } else if ( type == Path Iterator . SEG CUBICTO ) { path . curve To ( coords [ NUM_ ] , coords [ NUM_ ] , coords [ NUM_ ] , coords [ NUM_ ] , coords [ NUM_ ] , coords [ NUM_ ] ) ; } } pi . next ( ) ; } return path ; }
public Object clone ( ) throws Clone Not Supported Exception { My XY Block Renderer clone = ( My XY Block Renderer ) super . clone ( ) ; if ( this . paint Scale instanceof Public Cloneable ) { Public Cloneable pc = ( Public Cloneable ) this . paint Scale ; clone . paint Scale = ( Paint Scale ) pc . clone ( ) ; } return clone ; }
private boolean is Remove All Volumes ( Export Mask export Mask , List < URI > volumes To Remove ) { List < URI > volumes In Mask = Export Mask Utils . get Volume UR Is ( export Mask ) ; return volumes In Mask . is Empty ( ) || ( volumes In Mask . contains All ( volumes To Remove ) && ( volumes In Mask . size ( ) == volumes To Remove . size ( ) ) ) ; }
private boolean link First ( Node < E > node ) { if ( count >= capacity ) return false ; Node < E > f = first ; node . next = f ; first = node ; if ( last == null ) last = node ; else f . prev = node ; ++ count ; not Empty . signal ( ) ; return true ; }
public static boolean is Gwt Version Known And At Least 25 ( String directory Name ) { if ( ! directory Name . starts With ( STR_ ) ) { return false ; } return Sdk Utils . compare Version Strings ( directory Name . substring ( NUM_ ) , STR_ ) >= NUM_ ; }
public double min width ( ) { if ( min width != null ) return min width . double Value ( ) ; min width = Double . value Of ( NUM_ ) ; return min width . double Value ( ) ; }
private static boolean is Windows Absolute Path ( String system Id ) { if ( ! is Absolute Path ( system Id ) ) return false ; if ( system Id . length ( ) > NUM_ && system Id . char At ( NUM_ ) == STR_ && Character . is Letter ( system Id . char At ( NUM_ ) ) && ( system Id . char At ( NUM_ ) == STR_ || system Id . char At ( NUM_ ) == STR_ ) ) return true ; else return false ; }
public static boolean is Supplemental ( int c ) { return ( c >= NUM_ && c <= NUM_ ) ; }
public static Workflow . Method rollback Create Volumes Method ( URI system URI , List < URI > volume UR Is ) { return new Workflow . Method ( STR_ , system URI , volume UR Is ) ; }
static int find Best Sample Size ( int actual Width , int actual Height , int desired Width , int desired Height ) { double wr = ( double ) actual Width / desired Width ; double hr = ( double ) actual Height / desired Height ; double ratio = Math . min ( wr , hr ) ; float n = NUM_ ; while ( ( n * NUM_ ) <= ratio ) { n *= NUM_ ; } return ( int ) n ; }
public boolean hide Card ( String tag ) { final Card card = m Visible Cards . get ( tag ) ; if ( card != null ) { m Visible Cards . remove ( tag ) ; m Dismissible Cards . remove ( tag ) ; m Hidden Cards . put ( tag , card ) ; m Layout . remove View ( card . get View ( ) ) ; return true ; } return m Hidden Cards . contains Value ( tag ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; String string 00 = STR_ + STR_ + STR_ ; String string 0 = STR_ + STR_ + STR_ ; String string 1 = STR_ + m num Rules To Find + STR_ ; String string 2 = STR_ + STR_ + m metric Threshold + STR_ ; String string 3 = STR_ + STR_ ; String string 4 = STR_ + STR_ + m lower Bound Min Support + STR_ ; String string 5 = STR_ + STR_ ; String string 6 = STR_ + STR_ + m delta + STR_ ; String string 7 = STR_ + STR_ + STR_ + STR_ ; String string 8 = STR_ ; String string 9 = STR_ ; String string 10 = STR_ + STR_ ; new Vector . add ( new Option ( string 00 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 0 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 1 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 3 , STR_ , NUM_ , STR_ + STR_ ) ) ; new Vector . add ( new Option ( string 2 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 5 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 4 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 6 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 7 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 8 , STR_ , NUM_ , STR_ + STR_ ) ) ; new Vector . add ( new Option ( string 9 , STR_ , NUM_ , STR_ + STR_ ) ) ; new Vector . add ( new Option ( string 10 , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
protected int hmdu ( int N , int M , int n , Random Engine random Generator ) { int I , K ; double p , nu , c , d , U ; if ( N != N last || M != M last || n != n last ) { N last = N ; M last = M ; n last = n ; Mp = ( double ) ( M + NUM_ ) ; np = ( double ) ( n + NUM_ ) ; N Mn = N - M - n ; p = Mp / ( N + NUM_ ) ; nu = np * p ; if ( ( m = ( int ) nu ) == nu && p == NUM_ ) { mp = m -- ; } else { mp = m + NUM_ ; } fm = Math . exp ( Arithmetic . log Factorial ( N - M ) - Arithmetic . log Factorial ( N Mn + m ) - Arithmetic . log Factorial ( n - m ) + Arithmetic . log Factorial ( M ) - Arithmetic . log Factorial ( M - m ) - Arithmetic . log Factorial ( m ) - Arithmetic . log Factorial ( N ) + Arithmetic . log Factorial ( N - n ) + Arithmetic . log Factorial ( n ) ) ; b = ( int ) ( nu + NUM_ * Math . sqrt ( nu * ( NUM_ - p ) * ( NUM_ - n / ( double ) N ) + NUM_ ) ) ; if ( b > n ) b = n ; } for ( ; ; ) { if ( ( U = random Generator . raw ( ) - fm ) <= NUM_ ) return ( m ) ; c = d = fm ; for ( I = NUM_ ; I <= m ; I ++ ) { K = mp - I ; c *= ( double ) K / ( np - K ) * ( ( double ) ( N Mn + K ) / ( Mp - K ) ) ; if ( ( U -= c ) <= NUM_ ) return ( K - NUM_ ) ; K = m + I ; d *= ( np - K ) / ( double ) K * ( ( Mp - K ) / ( double ) ( N Mn + K ) ) ; if ( ( U -= d ) <= NUM_ ) return ( K ) ; } for ( K = mp + m ; K <= b ; K ++ ) { d *= ( np - K ) / ( double ) K * ( ( Mp - K ) / ( double ) ( N Mn + K ) ) ; if ( ( U -= d ) <= NUM_ ) return ( K ) ; } } }
public Http Response try Many ( Http Request http Request ) throws Http Request Exception { int num Tries = NUM_ ; long start Time = System . current Time Millis ( ) ; Http Response res = null ; while ( num Tries < max Retries ) { try { set Connection Timeout ( get Next Timeout ( num Tries ) ) ; if ( request Logger . is Logging Enabled ( ) ) { request Logger . log ( ( num Tries + NUM_ ) + STR_ + max Retries + STR_ + http Request . get Path ( ) ) ; } start Time = System . current Time Millis ( ) ; res = do Http Method ( http Request . get Path ( ) , http Request . get Http Method ( ) , http Request . get Content Type ( ) , http Request . get Content ( ) ) ; if ( res != null ) { return res ; } } catch ( Http Request Exception e ) { if ( is Timeout Exception ( e , start Time ) && num Tries < ( max Retries - NUM_ ) ) { } else { boolean is Recoverable = request Handler . on Error ( e ) ; if ( is Recoverable && num Tries < ( max Retries - NUM_ ) ) { try { Thread . sleep ( connection Timeout ) ; } catch ( Interrupted Exception ie ) { throw e ; } } else { throw e ; } } } num Tries ++ ; } return null ; }
public boolean event Generatable ( Event Set Descriptor esd ) { String event Name = esd . get Name ( ) ; return event Generatable ( event Name ) ; }
public static boolean was Notification Recently Clicked ( ) { if ( s Instance == null ) return false ; long now = System . current Time Millis ( ) ; return now - s Instance . m Last Notification Click Ms < NUM_ * NUM_ ; }
public static byte parse Byte ( java . lang . String s , int radix ) throws java . lang . Number Format Exception { int int Value = Integer . parse Int ( s , radix ) ; byte result = ( byte ) int Value ; if ( result == int Value ) { return result ; } throw new Number Format Exception ( STR_ + s + STR_ ) ; }
private boolean allowed As Http Request Response ( Well Known Type wkt ) { return wkt . allowed As Http Request Response ( ) ; }
public boolean is terminal ( Method Or Method Context mc ) { Stack < Soot Method > sys stack = new Stack < Soot Method > ( ) ; boolean result ; if ( ! is system ( mc . method ( ) ) ) result = false ; else { if ( ! process callbacks ) result = true ; else { if ( ( stack . size ( ) > NUM_ ) && is system ( stack . peek ( ) ) ) result = ! calls app method ( mc , sys stack ) ; else { if ( can have callbacks ( mc . method ( ) ) ) result = ! calls app method ( mc , sys stack ) ; else result = true ; } } } logger . info ( STR_ , mc . method ( ) , result ) ; return result ; }
private void determine Hosts As Property ( ) { if ( hosts . starts With ( STR_ ) && hosts . ends With ( STR_ ) ) { String hosts Property = hosts . substring ( NUM_ , hosts . length ( ) - NUM_ ) ; hosts = Property Util . get Property ( hosts Property ) ; if ( hosts == null ) { throw new Illegal Argument Exception ( STR_ + hosts Property + STR_ ) ; } } }
public int hash Code ( ) { return Arrays . hash Code ( apdu ) ; }
public int value For X Position ( int x Pos ) { int value ; int min Value = slider . get Minimum ( ) ; int max Value = slider . get Maximum ( ) ; int track Left = track Rect . x + thumb Rect . width / NUM_ + track Border ; int track Right = track Rect . x + track Rect . width - thumb Rect . width / NUM_ - track Border ; int track Length = track Right - track Left ; if ( x Pos <= track Left ) { value = draw Inverted ( ) ? max Value : min Value ; } else if ( x Pos >= track Right ) { value = draw Inverted ( ) ? min Value : max Value ; } else { int distance From Track Left = x Pos - track Left ; double value Range = ( double ) max Value - ( double ) min Value ; double value Per Pixel = value Range / ( double ) track Length ; int value From Track Left = ( int ) Math . round ( distance From Track Left * value Per Pixel ) ; value = draw Inverted ( ) ? max Value - value From Track Left : min Value + value From Track Left ; } return value ; }
private Text Impl next Text Node ( ) { Node next Sibling = get Next Sibling ( ) ; if ( next Sibling == null ) { return null ; } short node Type = next Sibling . get Node Type ( ) ; return node Type == Node . TEXT NODE || node Type == Node . CDATA SECTION NODE ? ( Text Impl ) next Sibling : null ; }
private boolean has Key Attributes ( ) { Boolean b = has Key Attributes ; if ( b == null ) { synchronized ( this ) { String s ; s = get Attribute ( STR_ ) ; if ( s != null ) { supported Formats = s . split ( STR_ ) ; } s = get Attribute ( STR_ ) ; if ( s != null ) { String [ ] class Names = s . split ( STR_ ) ; List < Class < ? > > class List = new Array List < > ( class Names . length ) ; for ( String class Name : class Names ) { Class < ? > clazz = get Key Class ( class Name ) ; if ( clazz != null ) { class List . add ( clazz ) ; } } supported Classes = class List . to Array ( CLASS 0 ) ; } boolean bool = ( supported Formats != null ) || ( supported Classes != null ) ; b = Boolean . value Of ( bool ) ; has Key Attributes = b ; } } return b . boolean Value ( ) ; }
public boolean contains Accession ( String method Accession ) { return method Accession To Entry . contains Key ( method Accession ) ; }
protected double [ ] [ ] means With Treshhold ( List < ? extends Modifiable Double DBID List > clusters , double [ ] [ ] means , Relation < V > database , Double tresh ) { double [ ] [ ] new Means = new double [ k ] [ ] ; for ( int i = NUM_ ; i < k ; i ++ ) { Double DBID List list = clusters . get ( i ) ; double [ ] raw = null ; int count = NUM_ ; for ( Double DBID List Iter iter = list . iter ( ) ; iter . valid ( ) ; iter . advance ( ) ) { if ( iter . double Value ( ) >= tresh ) { continue ; } Number Vector vec = database . get ( iter ) ; if ( raw == null ) { raw = vec . to Array ( ) ; } for ( int j = NUM_ ; j < raw . length ; j ++ ) { raw [ j ] += vec . double Value ( j ) ; } count ++ ; } new Means [ i ] = ( raw != null ) ? V Math . times Equals ( raw , NUM_ / count ) : means [ i ] ; } return new Means ; }
protected int position For Mouse Event ( Mouse Event e ) { int new X = ( e . get Source ( ) == Basic Split Pane Divider . this ) ? ( e . get X ( ) + get Location ( ) . x ) : e . get X ( ) ; new X = Math . min ( max X , Math . max ( min X , new X - offset ) ) ; return new X ; }
public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] arr = new Object [ size ] ; int i = NUM_ ; for ( Tenant Queue q : qs . values ( ) ) { Object [ ] qarr = q . to Array ( ) ; System . arraycopy ( qarr , NUM_ , arr , i , qarr . length ) ; i += qarr . length ; } return arr ; } finally { lock . unlock ( ) ; } }
@ Not Null private static General Command Line add Install Parameters ( @ Not Null General Command Line cl , int memory Size ) { cl . add Parameters ( STR_ , String . value Of ( memory Size ) ) ; return cl ; }
private static String matchable Path ( String path ) { if ( path == null ) { return STR_ ; } else if ( path . ends With ( STR_ ) ) { return path ; } else { return path + STR_ ; } }
@ Override public JSON Object to JSON Object ( ) throws JSON Exception { JSON Object jo = super . to JSON Object ( ) ; if ( policy Name != null ) { jo . put ( STR_ , policy Name ) ; } return jo ; }
public float next Float ( ) { return ( next ( NUM_ ) / NUM_ ) ; }
static public final float random ( ) { return random . next Float ( ) ; }
public final Iterator < String > actions Iterator ( ) { return m Actions != null ? m Actions . iterator ( ) : null ; }
public boolean add ( Long value ) { if ( heap . contains ( value ) ) { return true ; } else if ( heap . size ( ) < sample Size ) { heap . add ( value ) ; return true ; } else if ( value > heap . element ( ) ) { heap . remove ( ) ; heap . add ( value ) ; return true ; } else { return false ; } }
public static Big Fraction parse Edit Rate ( List < Long > edit Rate ) { if ( edit Rate . size ( ) != NUM_ ) { throw new Conversion Helper Exception ( STR_ ) ; } return new Big Fraction ( edit Rate . get ( NUM_ ) , edit Rate . get ( NUM_ ) ) ; }
private static boolean is Local Loader ( Class Loader loader ) { return ( loader == null || local Loaders . contains Key ( loader ) ) ; }
private static int [ ] Windows Reg Create Key Ex 1 ( int h Key , byte [ ] sub Key ) { int [ ] result = Windows Reg Create Key Ex ( h Key , sub Key ) ; if ( result [ ERROR CODE ] == ERROR SUCCESS ) { return result ; } else { long sleep Time = INIT SLEEP TIME ; for ( int i = NUM_ ; i < MAX ATTEMPTS ; i ++ ) { try { Thread . sleep ( sleep Time ) ; } catch ( Interrupted Exception e ) { return result ; } sleep Time *= NUM_ ; result = Windows Reg Create Key Ex ( h Key , sub Key ) ; if ( result [ ERROR CODE ] == ERROR SUCCESS ) { return result ; } } } return result ; }
public boolean ends With ( String string ) { if ( string == null ) return false ; int strlen = string . length ( ) ; if ( length < strlen ) return false ; char [ ] buffer = buffer ; int offset = offset + length - strlen ; while ( -- strlen >= NUM_ ) { if ( buffer [ offset + strlen ] != string . char At ( strlen ) ) return false ; } return true ; }
public static String matrix To String ( double [ ] [ ] matrix ) { String Buffer result = new String Buffer ( ) ; int last = matrix . length - NUM_ ; for ( int i = NUM_ ; i <= last ; i ++ ) { for ( int j = NUM_ ; j <= last ; j ++ ) { result . append ( Utils . double To String ( matrix [ i ] [ j ] , NUM_ , NUM_ ) + STR_ ) ; if ( j == last ) { result . append ( STR_ ) ; } } } return result . to String ( ) ; }
public Charset charset ( ) { return charset != null ? Charset . for Name ( charset ) : null ; }
public String to Comma Separated String ( ) { String result = STR_ ; for ( int i = NUM_ ; i < contents . size ( ) ; i ++ ) { if ( result . equals ( STR_ ) ) { result = contents . element At ( i ) ; } else { result = result + STR_ + contents . element At ( i ) ; } } return result ; }
public static boolean ensure Inlinability ( Soot Method target , Stmt to Inline , Soot Method container , String modifier Options ) { if ( ! Inliner Safety Manager . can Safely Inline Into ( target , to Inline , container ) ) { return false ; } if ( ! Access Manager . ensure Access ( container , target , modifier Options ) ) { return false ; } if ( ! check Special Inline Restrictions ( container , target , modifier Options ) ) { return false ; } if ( ! check Access Restrictions ( container , target , modifier Options ) ) { return false ; } return true ; }
public static double uniform ( ) { return random . next Double ( ) ; }
@ Suppress Warnings ( STR_ ) private static Heap Operand < Object > [ ] extend H Array ( Heap Operand < Object > [ ] H ) { Heap Operand < Object > [ ] res ; if ( H == null ) { res = new Heap Operand [ NUM_ ] ; } else { res = new Heap Operand [ H . length + NUM_ ] ; for ( int i = NUM_ ; i < H . length ; ++ i ) { res [ i + NUM_ ] = H [ i ] ; } } return res ; }
private static boolean delete Rows Impl ( Iterator < Row > iter ) throws IO Exception { boolean removed = false ; while ( iter . has Next ( ) ) { iter . next ( ) ; iter . remove ( ) ; removed = true ; } return removed ; }
public int size ( String key ) { List < Serializable > entries = data . get ( key ) ; if ( entries == null ) { throw new Illegal Argument Exception ( Message Format . format ( INVALID KEY , key ) ) ; } else { return entries . size ( ) ; } }
public Boolean Condition Builder not ( Condition Builder < ? , ? > ... builders ) { not . add All ( Arrays . as List ( builders ) ) ; return this ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public int size ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { return count ; } finally { lock . unlock ( ) ; } }
public boolean is Class Subclass Of Including ( Soot Class child , Soot Class possible Parent ) { child . check Level ( Soot Class . HIERARCHY ) ; possible Parent . check Level ( Soot Class . HIERARCHY ) ; List < Soot Class > parent Classes = get Superclasses Of Including ( child ) ; if ( parent Classes . contains ( possible Parent ) ) return true ; for ( Soot Class sc : parent Classes ) if ( sc . is Phantom ( ) ) return true ; return false ; }
private E await Match ( Node s , Node pred , E e , boolean timed , long nanos ) { final long deadline = timed ? System . nano Time ( ) + nanos : NUM_ ; Thread w = Thread . current Thread ( ) ; int spins = - NUM_ ; Thread Local Random random Yields = null ; for ( ; ; ) { Object item = s . item ; if ( item != e ) { s . forget Contents ( ) ; return Linked Transfer Queue . < E > cast ( item ) ; } if ( ( w . is Interrupted ( ) || ( timed && nanos <= NUM_ ) ) && s . cas Item ( e , s ) ) { unsplice ( pred , s ) ; return e ; } if ( spins < NUM_ ) { if ( ( spins = spins For ( pred , s . is Data ) ) > NUM_ ) random Yields = Thread Local Random . current ( ) ; } else if ( spins > NUM_ ) { -- spins ; if ( random Yields . next Int ( CHAINED SPINS ) == NUM_ ) Thread . yield ( ) ; } else if ( s . waiter == null ) { s . waiter = w ; } else if ( timed ) { nanos = deadline - System . nano Time ( ) ; if ( nanos > NUM_ ) Lock Support . park Nanos ( this , nanos ) ; } else { Lock Support . park ( this ) ; } } }
public int unpad ( byte [ ] in , int off , int len ) { if ( ( in == null ) || ( len == NUM_ ) ) { return NUM_ ; } byte last Byte = in [ off + len - NUM_ ] ; int pad Value = ( int ) last Byte & NUM_ ; if ( ( pad Value < NUM_ ) || ( pad Value > block Size ) ) { return - NUM_ ; } int start = off + len - ( ( int ) last Byte & NUM_ ) ; if ( start < off ) { return - NUM_ ; } return start ; }
public int size ( ) { return objects . size ( ) ; }
public String to ASCII String ( ) { String Builder result = new String Builder ( ) ; ASCII ONLY . append Encoded ( result , to String ( ) ) ; return result . to String ( ) ; }
@ Override public int length ( ) { return subeffects . size ( ) ; }
public boolean is Attribute Name Specified ( ) { if ( user Defined Attribute Name == null ) { return false ; } return ! user Defined Attribute Name . equals ( original Attribute Name ) ; }
public static String dictionary To String ( Dictionary < Object , Object > dict ) { Enumeration < Object > keys = dict . keys ( ) ; Object key , value ; String Buffer result = new String Buffer ( ) ; while ( keys . has More Elements ( ) ) { key = keys . next Element ( ) ; value = dict . get ( key ) ; result . append ( key . to String ( ) ) ; result . append ( STR_ ) ; result . append ( value . to String ( ) ) ; result . append ( STR_ ) ; } return result . to String ( ) ; }
public String basic Type Name Boxed ( Field field ) { return java Common . boxed Type Name ( basic Type Name ( field ) ) ; }
public long long Value ( ) { if ( val instanceof Long || val instanceof Integer ) { return val . long Value ( ) ; } return ( long ) ( val . double Value ( ) ) ; }
private String read String ( boolean unshared ) throws IO Exception { String str ; byte tc = bin . read Byte ( ) ; switch ( tc ) { case TC STRING : str = bin . read UTF ( ) ; break ; case TC LONGSTRING : str = bin . read Long UTF ( ) ; break ; default : throw new Stream Corrupted Exception ( String . format ( STR_ , tc ) ) ; } pass Handle = handles . assign ( unshared ? unshared Marker : str ) ; handles . finish ( pass Handle ) ; return str ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; return new Vector . elements ( ) ; }
public boolean is Empty ( ) { return indexed Events . is Empty ( ) ; }
private Array List < A Star Node > find Neighbours ( A Star Node node ) { Array List < A Star Node > r = new Array List < A Star Node > ( ) ; int x = node . x ; int y = node . y ; int z = node . z ; int dist = node . get G ( ) ; if ( node . parent != null ) { int px = node . parent . x ; int py = node . parent . y ; int pz = node . parent . z ; boolean stairs = py != y ; int n Y ; int dx = ( x - px ) / Math . max ( Math . abs ( x - px ) , NUM_ ) ; int dz = ( z - pz ) / Math . max ( Math . abs ( z - pz ) , NUM_ ) ; if ( dx != NUM_ && dz != NUM_ ) { if ( stairs ) { return get All Neighbors Without Parent ( x , y , z , dx , dz , node ) ; } int left Y = NUM_ ; int right Y = NUM_ ; n Y = get Ground Node Height ( x , y , z + dz ) ; if ( n Y > NUM_ ) { left Y = n Y ; r . add ( new A Star Node ( x , n Y , z + dz , dist + NUM_ , node ) ) ; } n Y = get Ground Node Height ( x + dx , y , z ) ; if ( n Y > NUM_ ) { right Y = n Y ; r . add ( new A Star Node ( x + dx , n Y , z , dist + NUM_ , node ) ) ; } if ( left Y != NUM_ || right Y != NUM_ ) { r . add ( new A Star Node ( x + dx , Math . max ( left Y , right Y ) , z + dz , dist + NUM_ , node ) ) ; } if ( left Y != NUM_ ) { if ( get Ground Node Height ( x - dx , py , z ) == NUM_ ) { r . add ( new A Star Node ( x - dx , left Y , z + dz , dist + NUM_ , node ) ) ; } } if ( right Y != NUM_ ) { if ( get Ground Node Height ( x , py , z - dz ) == NUM_ ) { r . add ( new A Star Node ( x + dx , right Y , z - dz , dist + NUM_ , node ) ) ; } } } else { if ( dx == NUM_ ) { n Y = get Ground Node Height ( x , y , z + dz ) ; if ( n Y > NUM_ ) { r . add ( new A Star Node ( x , n Y , z + dz , dist + NUM_ , node ) ) ; if ( stairs ) { r . add ( new A Star Node ( x + NUM_ , n Y , z + dz , dist + NUM_ , node ) ) ; r . add ( new A Star Node ( x - NUM_ , n Y , z + dz , dist + NUM_ , node ) ) ; } else { int nn Y = get Ground Node Height ( x + NUM_ , n Y , z ) ; if ( nn Y == NUM_ ) { r . add ( new A Star Node ( x + NUM_ , n Y , z + dz , dist + NUM_ , node ) ) ; } nn Y = get Ground Node Height ( x - NUM_ , n Y , z ) ; if ( nn Y == NUM_ ) { r . add ( new A Star Node ( x - NUM_ , n Y , z + dz , dist + NUM_ , node ) ) ; } } } } else { n Y = get Ground Node Height ( x + dx , y , z ) ; if ( n Y > NUM_ ) { r . add ( new A Star Node ( x + dx , n Y , z , dist + NUM_ , node ) ) ; if ( stairs ) { r . add ( new A Star Node ( x + dx , n Y , z + NUM_ , dist + NUM_ , node ) ) ; r . add ( new A Star Node ( x + dx , n Y , z - NUM_ , dist + NUM_ , node ) ) ; } else { int nn Y = get Ground Node Height ( x , n Y , z + NUM_ ) ; if ( nn Y == NUM_ ) { r . add ( new A Star Node ( x + dx , n Y , z + NUM_ , dist + NUM_ , node ) ) ; } nn Y = get Ground Node Height ( x , n Y , z - NUM_ ) ; if ( nn Y == NUM_ ) { r . add ( new A Star Node ( x + dx , n Y , z - NUM_ , dist + NUM_ , node ) ) ; } } } } } } else { for ( int [ ] offset : neighbour Offsets ) { int n Y = get Ground Node Height ( x + offset [ NUM_ ] , y , z + offset [ NUM_ ] ) ; if ( n Y > NUM_ ) { r . add ( new A Star Node ( x + offset [ NUM_ ] , n Y , z + offset [ NUM_ ] , n Y , node ) ) ; } } } return r ; }
public static int hash ( Object object ) { return object == null ? NUM_ : object . hash Code ( ) ; }
public int read ( Input Stream in , int offset , Message overflow ) throws IO Exception { if ( ref Count . get ( ) == NUM_ ) { throw new Illegal State Exception ( STR_ ) ; } int msg Size = offset < NUM_ ? NUM_ : byte Buffer . get Short ( NUM_ ) ; while ( offset < msg Size ) { int max = overflow == null ? Math . max ( NUM_ , msg Size - offset ) : buffer . length - offset ; int n = in . read ( buffer , offset , max ) ; if ( n < NUM_ ) { return - NUM_ ; } offset += n ; if ( offset >= msg Size ) { msg Size = byte Buffer . get Short ( NUM_ ) ; } } int overflow Size = offset - msg Size ; if ( overflow Size > NUM_ ) { System . arraycopy ( buffer , msg Size , overflow . buffer , NUM_ , overflow Size ) ; } parse ( ) ; return overflow Size ; }
public static byte [ ] as Unsigned Byte Array ( int length , Big Integer value ) { byte [ ] bytes = value . to Byte Array ( ) ; if ( bytes . length == length ) { return bytes ; } int start = bytes [ NUM_ ] == NUM_ ? NUM_ : NUM_ ; int count = bytes . length - start ; if ( count > length ) { throw new Illegal Argument Exception ( STR_ ) ; } byte [ ] tmp = new byte [ length ] ; System . arraycopy ( bytes , start , tmp , tmp . length - count , count ) ; return tmp ; }
public static String ptb 2 Text ( String ptb Text ) { String Buffer sb = new String Buffer ( ptb Text . length ( ) ) ; PTB 2 Text Lexer lexer = new PTB 2 Text Lexer ( new String Reader ( ptb Text ) ) ; String token ; try { while ( ( token = lexer . next ( ) ) != null ) sb . append ( token ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return ( sb . to String ( ) ) ; }
public static boolean is Blank ( List < Object > list ) { return list == null || list . is Empty ( ) ; }
public double next Double ( double alpha , double beta ) { double a = alpha ; double b = beta ; if ( ( a setup != a ) || ( b setup != b ) ) { double mpa , mmb , mode ; double amb ; double a , b , a 1 , b 1 , pl ; double help 1 , help 2 ; amb = a * a - b * b ; samb = Math . sqrt ( amb ) ; mode = b / samb ; help 1 = a * Math . sqrt ( NUM_ * samb + NUM_ ) ; help 2 = b * ( samb + NUM_ ) ; mpa = ( help 2 + help 1 ) / amb ; mmb = ( help 2 - help 1 ) / amb ; a = mpa - mode ; b = - mmb + mode ; hr = - NUM_ / ( - a * mpa / Math . sqrt ( NUM_ + mpa * mpa ) + b ) ; hl = NUM_ / ( - a * mmb / Math . sqrt ( NUM_ + mmb * mmb ) + b ) ; a 1 = a - hr ; b 1 = b - hl ; mmb 1 = mode - b 1 ; mpa 1 = mode + a 1 ; s = ( a + b ) ; pm = ( a 1 + b 1 ) / s ; pr = hr / s ; pmr = pm + pr ; a setup = a ; b setup = b ; } for ( ; ; ) { u = random Generator . raw ( ) ; v = random Generator . raw ( ) ; if ( u <= pm ) { x = mmb 1 + u * s ; if ( Math . log ( v ) <= ( - a * Math . sqrt ( NUM_ + x * x ) + b * x + samb ) ) break ; } else { if ( u <= pmr ) { e = - Math . log ( ( u - pm ) / pr ) ; x = mpa 1 + hr * e ; if ( ( Math . log ( v ) - e ) <= ( - a * Math . sqrt ( NUM_ + x * x ) + b * x + samb ) ) break ; } else { e = Math . log ( ( u - pmr ) / ( NUM_ - pmr ) ) ; x = mmb 1 + hl * e ; if ( ( Math . log ( v ) + e ) <= ( - a * Math . sqrt ( NUM_ + x * x ) + b * x + samb ) ) break ; } } } return ( x ) ; }
@ Override public boolean is Busy ( ) { return ( m evaluate Thread != null ) ; }
public static String node Value ( Node node ) { if ( node == null ) return null ; String Builder value Buffer = new String Builder ( ) ; do { if ( node . get Node Type ( ) == Node . CDATA SECTION NODE || node . get Node Type ( ) == Node . TEXT NODE || node . get Node Type ( ) == Node . COMMENT NODE ) { value Buffer . append ( node . get Node Value ( ) ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; return value Buffer . to String ( ) ; }
@ Override public Inet Address address Local ( ) { Socket Channel s = channel ; if ( s != null ) { try { Inet Socket Address addr = ( Inet Socket Address ) s . get Local Address ( ) ; return addr . get Address ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } } else { return null ; } }
public int max value ( int p i , int p layer ) { int i = Math . max ( p i , NUM_ ) ; i = Math . min ( i , class count - NUM_ ) ; int layer = Math . max ( p layer , NUM_ ) ; layer = Math . min ( layer , layer structure . size ( ) - NUM_ ) ; return clearance rows [ i ] . max value [ layer ] ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private Iterable < String > distinct Names ( Iterable < Inet Socket Address > addresses ) { Set < String > result = new Hash Set < > ( ) ; for ( Inet Socket Address address : addresses ) { result . add ( name ( address ) ) ; } return result ; }
public Input Source resolve Entity ( String public Id , String system Id ) throws SAX Exception , IO Exception { has DTD = false ; String dtd = Util Properties . get Split Property Value ( Util URL . from Resource ( STR_ ) , public Id ) ; if ( Util Validate . is Not Empty ( dtd ) ) { if ( Debug . verbose On ( ) ) Debug . log Verbose ( STR_ + public Id + STR_ + system Id + STR_ + dtd + STR_ , module ) ; try { URL dtd URL = Util URL . from Resource ( dtd ) ; if ( dtd URL == null ) { throw new General Exception ( STR_ + dtd ) ; } Input Stream dtd Stream = dtd URL . open Stream ( ) ; Input Source input Source = new Input Source ( dtd Stream ) ; input Source . set Public Id ( public Id ) ; has DTD = true ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STR_ + public Id + STR_ + dtd + STR_ , module ) ; return input Source ; } catch ( Exception e ) { Debug . log Warning ( e , module ) ; } } else { int last Slash = system Id . last Index Of ( STR_ ) ; String filename = null ; if ( last Slash == - NUM_ ) { filename = system Id ; } else { filename = system Id . substring ( last Slash + NUM_ ) ; } URL resource Url = Util URL . from Resource ( filename ) ; if ( resource Url != null ) { Input Stream res Stream = resource Url . open Stream ( ) ; Input Source input Source = new Input Source ( res Stream ) ; if ( Util Validate . is Not Empty ( public Id ) ) { input Source . set Public Id ( public Id ) ; } has DTD = true ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STR_ + public Id + STR_ + filename + STR_ , module ) ; return input Source ; } else { Debug . log Warning ( STR_ + public Id + STR_ + filename + STR_ , module ) ; return null ; } } return default Resolver . resolve Entity ( public Id , system Id ) ; }
private String format Boolean ( boolean b ) { return b ? new String ( new byte [ ] { NUM_ } ) : STR_ ; }
public boolean is First ( ) { return first ; }
public boolean is Unidirectional ( ) { return unidirectional ; }
@ Override public synchronized Object [ ] to Array ( ) { Object [ ] result = new Object [ element Count ] ; System . arraycopy ( element Data , NUM_ , result , NUM_ , element Count ) ; return result ; }
public static String lrs ( String text ) { int n = text . length ( ) ; Suffix Array sa = new Suffix Array ( text ) ; String lrs = STR_ ; for ( int i = NUM_ ; i < n ; i ++ ) { int length = sa . lcp ( i ) ; if ( length > lrs . length ( ) ) { lrs = text . substring ( sa . index ( i ) , sa . index ( i ) + length ) ; } } return lrs ; }
public static byte [ ] decrypt ( byte [ ] key , byte [ ] data , Optional < byte [ ] > optional ) { try { Byte Buffer buffer = Byte Buffer . wrap ( data ) ; buffer . order ( Byte Order . BIG ENDIAN ) ; int version = Byte . to Unsigned Int ( buffer . get ( ) ) ; logger . debug ( STR_ , version ) ; buffer . rewind ( ) ; switch ( version ) { case NUM_ : return do Decrypt ( buffer , key , NUM_ , NUM_ , NUM_ , optional ) ; case NUM_ : return do Decrypt ( buffer , key , NUM_ , NUM_ , NUM_ , optional ) ; case NUM_ : return do Decrypt ( buffer , key , NUM_ , NUM_ , NUM_ , optional ) ; case NUM_ : if ( buffer . limit ( ) < NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } int header Length = NUM_ + Byte . to Unsigned Int ( buffer . get ( NUM_ ) ) ; return do Decrypt ( buffer , key , header Length , NUM_ , NUM_ , optional ) ; default : throw new Illegal Argument Exception ( STR_ + version ) ; } } catch ( Buffer Underflow Exception ex ) { throw new Illegal Argument Exception ( STR_ , ex ) ; } }
@ Override public String global Info ( ) { return STR_ + STR_ + STR_ ; }
public int version Build Number ( ) { return Integer . value Of ( properties . get Property ( STR_ ) ) ; }
public static boolean is Content Type Id ( IDOM Node node , String content Type Id ) { if ( content Type Id == null ) { return false ; } String node Content Type Id = get Content Type Id ( node ) ; return content Type Id . equals ( node Content Type Id ) ; }
public static final boolean sq Attacked ( Position pos , int sq ) { int x = Position . get X ( sq ) ; int y = Position . get Y ( sq ) ; boolean is White Move = pos . white Move ; final int o Queen = is White Move ? Piece . BQUEEN : Piece . WQUEEN ; final int o Rook = is White Move ? Piece . BROOK : Piece . WROOK ; final int o Bish = is White Move ? Piece . BBISHOP : Piece . WBISHOP ; final int o Knight = is White Move ? Piece . BKNIGHT : Piece . WKNIGHT ; int p ; if ( y > NUM_ ) { p = check Direction ( pos , sq , y , - NUM_ ) ; if ( ( p == o Queen ) || ( p == o Rook ) ) return true ; p = check Direction ( pos , sq , Math . min ( x , y ) , - NUM_ ) ; if ( ( p == o Queen ) || ( p == o Bish ) ) return true ; p = check Direction ( pos , sq , Math . min ( NUM_ - x , y ) , - NUM_ ) ; if ( ( p == o Queen ) || ( p == o Bish ) ) return true ; if ( x > NUM_ ) { p = check Direction ( pos , sq , NUM_ , - NUM_ ) ; if ( p == o Knight ) return true ; } if ( x > NUM_ && y > NUM_ ) { p = check Direction ( pos , sq , NUM_ , - NUM_ ) ; if ( p == o Knight ) return true ; } if ( x < NUM_ && y > NUM_ ) { p = check Direction ( pos , sq , NUM_ , - NUM_ ) ; if ( p == o Knight ) return true ; } if ( x < NUM_ ) { p = check Direction ( pos , sq , NUM_ , - NUM_ ) ; if ( p == o Knight ) return true ; } if ( ! is White Move ) { if ( x < NUM_ && y > NUM_ ) { p = check Direction ( pos , sq , NUM_ , - NUM_ ) ; if ( p == Piece . WPAWN ) return true ; } if ( x > NUM_ && y > NUM_ ) { p = check Direction ( pos , sq , NUM_ , - NUM_ ) ; if ( p == Piece . WPAWN ) return true ; } } } if ( y < NUM_ ) { p = check Direction ( pos , sq , NUM_ - y , NUM_ ) ; if ( ( p == o Queen ) || ( p == o Rook ) ) return true ; p = check Direction ( pos , sq , Math . min ( NUM_ - x , NUM_ - y ) , NUM_ ) ; if ( ( p == o Queen ) || ( p == o Bish ) ) return true ; p = check Direction ( pos , sq , Math . min ( x , NUM_ - y ) , NUM_ ) ; if ( ( p == o Queen ) || ( p == o Bish ) ) return true ; if ( x < NUM_ ) { p = check Direction ( pos , sq , NUM_ , NUM_ ) ; if ( p == o Knight ) return true ; } if ( x < NUM_ && y < NUM_ ) { p = check Direction ( pos , sq , NUM_ , NUM_ ) ; if ( p == o Knight ) return true ; } if ( x > NUM_ && y < NUM_ ) { p = check Direction ( pos , sq , NUM_ , NUM_ ) ; if ( p == o Knight ) return true ; } if ( x > NUM_ ) { p = check Direction ( pos , sq , NUM_ , NUM_ ) ; if ( p == o Knight ) return true ; } if ( is White Move ) { if ( x < NUM_ && y < NUM_ ) { p = check Direction ( pos , sq , NUM_ , NUM_ ) ; if ( p == Piece . BPAWN ) return true ; } if ( x > NUM_ && y < NUM_ ) { p = check Direction ( pos , sq , NUM_ , NUM_ ) ; if ( p == Piece . BPAWN ) return true ; } } } p = check Direction ( pos , sq , NUM_ - x , NUM_ ) ; if ( ( p == o Queen ) || ( p == o Rook ) ) return true ; p = check Direction ( pos , sq , x , - NUM_ ) ; if ( ( p == o Queen ) || ( p == o Rook ) ) return true ; int o King Sq = pos . get King Sq ( ! is White Move ) ; if ( o King Sq >= NUM_ ) { int ox = Position . get X ( o King Sq ) ; int oy = Position . get Y ( o King Sq ) ; if ( ( Math . abs ( x - ox ) <= NUM_ ) && ( Math . abs ( y - oy ) <= NUM_ ) ) return true ; } return false ; }
public static Date min ( Date date 1 , Date date 2 ) { if ( date 1 == null ) { return date 2 ; } return date 2 != null ? ( date 1 . before ( date 2 ) ? date 1 : date 2 ) : date 1 ; }
public static int hash ( double [ ] value ) { return Arrays . hash Code ( value ) ; }
public final static int log Base 2 ( double number ) { int log = NUM_ ; while ( number > NUM_ ) { number = Math . floor ( number / NUM_ ) ; ++ log ; } return log ; }
private boolean parse Selectors ( ) throws IO Exception { int next Token ; if ( token Buffer Length > NUM_ ) { callback . handle Selector ( new String ( token Buffer , NUM_ , token Buffer Length ) ) ; } unit Buffer . set Length ( NUM_ ) ; for ( ; ; ) { while ( ( next Token = next Token ( ( char ) NUM_ ) ) == IDENTIFIER ) { if ( token Buffer Length > NUM_ ) { callback . handle Selector ( new String ( token Buffer , NUM_ , token Buffer Length ) ) ; } } switch ( next Token ) { case BRACE OPEN : return true ; case BRACKET OPEN : case PAREN OPEN : parse Till Closed ( next Token ) ; unit Buffer . set Length ( NUM_ ) ; break ; case BRACKET CLOSE : case BRACE CLOSE : case PAREN CLOSE : throw new Runtime Exception ( STR_ ) ; case END : return false ; } } }
public byte [ ] to Byte Array ( ) { byte [ ] b = output . to Byte Array ( ) ; Byte Array . write 16 bit ( num Of Entries , b , NUM_ ) ; return b ; }
public Certificate engine Get Certificate ( String alias ) { if ( alias == null ) { throw new Illegal Argument Exception ( STR_ ) ; } Certificate c = ( Certificate ) certs . get ( alias ) ; if ( c == null ) { String id = ( String ) local Ids . get ( alias ) ; if ( id != null ) { c = ( Certificate ) key Certs . get ( id ) ; } else { c = ( Certificate ) key Certs . get ( alias ) ; } } return c ; }
public String to Summary String ( String title ) { String Buffer result ; result = new String Buffer ( title ) ; if ( title . length ( ) != NUM_ ) { result . append ( STR_ ) ; } result . append ( m Result ) ; return result . to String ( ) ; }
public static String dump Properties ( Properties props , String name ) { String Buffer prop Str = new String Buffer ( ) ; Enumeration props E = props . property Names ( ) ; prop Str . append ( line Sep + separator + STR_ + name + STR_ + separator + line Sep ) ; while ( props E . has More Elements ( ) ) { String key = ( String ) props E . next Element ( ) ; prop Str . append ( left ( key , NUM_ , STR_ ) + STR_ + props . get ( key ) + line Sep ) ; } prop Str . append ( separator + separator + separator + line Sep ) ; return prop Str . to String ( ) ; }
private int strip Multipart Headers ( byte [ ] b , int offset ) { int i = NUM_ ; for ( i = offset ; i < b . length ; i ++ ) { if ( b [ i ] == STR_ && b [ ++ i ] == STR_ && b [ ++ i ] == STR_ && b [ ++ i ] == STR_ ) break ; } return i + NUM_ ; }
public boolean is Policy Mapping Inhibited ( ) { return policy Mapping Inhibited ; }
private boolean is Cache Valid ( ) { long now = Current Time . current Time ( ) ; if ( ( now - last Time < NUM_ ) && ! Current Time . is Test ( ) ) return true ; long old Last Modified = last Modified ; long old Length = length ; long new Last Modified = backing . get Last Modified ( ) ; long new Length = backing . length ( ) ; last Time = now ; if ( new Last Modified == old Last Modified && new Length == old Length ) { last Time = now ; return true ; } else { change Sequence . increment And Get ( ) ; clear Cache ( ) ; depend = null ; is Signed = null ; zip Entry Cache . clear ( ) ; last Modified = new Last Modified ; length = new Length ; last Time = now ; return false ; } }
public Iterable < Field Accessor > owned Or Mixed In ( ) { if ( getter != null ) { if ( setter != null ) { return Arrays . as List ( getter , setter ) ; } else { return singleton List ( getter ) ; } } else if ( setter != null ) { return singleton List ( setter ) ; } return empty List ( ) ; }
public static int find Highest Major Version ( Collection < Throwable > list ) { int result = NUM_ ; for ( Throwable t : list ) { if ( t instanceof Inconvertible Class Error ) { Inconvertible Class Error error = ( Inconvertible Class Error ) t ; result = Math . max ( result , error . get Major ( ) ) ; } } return result ; }
public String send ( String command , boolean retry ) throws Exception { Channel Result result = null ; while ( true ) { try { if ( socket == null || wr == null ) { connect ( ) ; } wr . write ( command + STR_ ) ; wr . flush ( ) ; String response = rd . read Line ( ) ; if ( response == null ) { throw new EOF Exception ( command ) ; } result = new Channel Result ( response ) ; break ; } catch ( EOF Exception e ) { throw e ; } catch ( Exception e ) { close ( ) ; if ( ! retry ) { return null ; } try { Thread . sleep ( NUM_ ) ; } catch ( Exception e 2 ) { logger . error ( e 2 . get Message ( ) , e 2 ) ; } } } if ( ! result . success ) { throw new Exception ( String . format ( STR_ , host , port , command , result . message ) ) ; } return result . message ; }
private boolean verify Sorted Coordinates Properties File ( File coordinate Properties File ) { log ( STR_ + coordinate Properties File , verbose Level ) ; boolean success = true ; String line = null ; String current Key = null ; String previous Key = null ; try ( Input Stream stream = new File Input Stream ( coordinate Properties File ) ; Reader reader = new Input Stream Reader ( stream , Standard Charsets . ISO 8859 1 ) ; Buffered Reader buffered Reader = new Buffered Reader ( reader ) ) { while ( null != ( line = read Logical Properties Line ( buffered Reader ) ) ) { final Matcher key Matcher = COORDINATE KEY PATTERN . matcher ( line ) ; if ( ! key Matcher . looking At ( ) ) { continue ; } current Key = key Matcher . group ( NUM_ ) ; if ( null != previous Key ) { int comparison = current Key . compare To ( previous Key ) ; if ( NUM_ == comparison ) { log ( STR_ + current Key + STR_ + coordinate Properties File . get Name ( ) , Project . MSG ERR ) ; success = false ; } else if ( comparison < NUM_ ) { log ( STR_ + current Key + STR_ + coordinate Properties File . get Name ( ) , Project . MSG ERR ) ; success = false ; } } previous Key = current Key ; } } catch ( IO Exception e ) { throw new Build Exception ( STR_ + coordinate Properties File . get Path ( ) + STR_ + e . to String ( ) , e ) ; } return success ; }
public static int array Base Offset ( Class cls ) { return UNSAFE . array Base Offset ( cls ) ; }
public static Locale ensure Locale ( Object locale Object ) { if ( locale Object instanceof String ) { return parse Locale ( ( String ) locale Object ) ; } else if ( locale Object instanceof Locale ) { return ( Locale ) locale Object ; } return Locale . get Default ( ) ; }
static public double j 1 ( double x ) throws Arithmetic Exception { double ax ; double y ; double ans 1 , ans 2 ; if ( ( ax = Math . abs ( x ) ) < NUM_ ) { y = x * x ; ans 1 = x * ( NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ ) ) ) ) ) ) ; ans 2 = NUM_ + y * ( NUM_ + y * ( NUM_ + y * ( NUM_ + y * ( NUM_ + y * NUM_ ) ) ) ) ; return ans 1 / ans 2 ; } else { double z = NUM_ / ax ; double xx = ax - NUM_ ; y = z * z ; ans 1 = NUM_ + y * ( NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ ) ) ) ) ; ans 2 = NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * NUM_ ) ) ) ; double ans = Math . sqrt ( NUM_ / ax ) * ( Math . cos ( xx ) * ans 1 - z * Math . sin ( xx ) * ans 2 ) ; if ( x < NUM_ ) ans = - ans ; return ans ; } }
public final boolean is Removed ( ) { return is Removed ; }
public boolean has Extensions ( ) { return extensions != null ; }
public String classifier Tip Text ( ) { return STR_ ; }
public double next Double ( double a ) { double u , v , p , q ; int k ; if ( a != a prev ) { a prev = a ; if ( a < NUM_ ) t = - a / Math . log ( NUM_ - a ) ; else h = Math . log ( NUM_ - a ) ; } u = random Generator . raw ( ) ; if ( a < NUM_ ) { k = NUM_ ; p = t ; while ( u > p ) { u -= p ; k ++ ; p *= a * ( k - NUM_ ) / ( double ) k ; } return k ; } if ( u > a ) return NUM_ ; u = random Generator . raw ( ) ; v = u ; q = NUM_ - Math . exp ( v * h ) ; if ( u <= q * q ) { k = ( int ) ( NUM_ + Math . log ( u ) / Math . log ( q ) ) ; return k ; } if ( u > q ) return NUM_ ; return NUM_ ; }
public boolean contains Neuron ( final Neuron n ) { return neuron List . contains ( n ) ; }
public static byte [ ] clone ( byte [ ] array ) { if ( array == null ) { return null ; } byte [ ] result = new byte [ array . length ] ; System . arraycopy ( array , NUM_ , result , NUM_ , array . length ) ; return result ; }
I Change [ ] changes ( E Object element , I Xtext Document doc ) throws Bad Location Exception { Array List < I Change > changes = new Array List < > ( ) ; if ( element instanceof Type Defining Element ) { changes . add ( semantic Change Provider . set Access Modifier ( doc , ( Type Defining Element ) element , this . modifier , this . export ) ) ; } else if ( element instanceof Exported Variable Statement ) { changes . add ( semantic Change Provider . set Access Modifiers ( doc , ( Modifiable Element ) element , this . modifier ) ) ; } else { return changes . to Array ( new I Change [ changes . size ( ) ] ) ; } if ( element instanceof Annotable Element ) { if ( this . internal ) { changes . add ( semantic Change Provider . add Annotation ( doc , ( Annotable Element ) element , INTERNAL ANNOTATION ) ) ; } else { changes . add ( semantic Change Provider . remove Annotation ( doc , ( Annotable Element ) element , INTERNAL ANNOTATION ) ) ; } return changes . to Array ( new I Change [ changes . size ( ) ] ) ; } return new I Change [ ] { } ; }
public static I Remote Space find Jini Space ( Space URL url , Properties custom Properties , long timeout , Lookup Type lookup Type ) throws Finder Exception { return ( I Remote Space ) find Jini Space ( url , custom Properties , timeout , lookup Type , false ) ; }
public static Workflow . Method resync Clone Method ( URI storage , List < URI > clone , Boolean update Op Status , boolean is CG ) { return new Workflow . Method ( STR_ , storage , clone , update Op Status , is CG ) ; }
protected org . eclipse . core . filebuffers . I Document Factory do Get Document Factory ( I Content Type [ ] content Types ) { Set set = null ; int i = NUM_ ; while ( i < content Types . length && set == null ) { set = ( Set ) f Factory Descriptors . get ( new Content Type Adapter ( content Types [ i ++ ] ) ) ; } if ( set != null ) { I Configuration Element entry = select Configuration Element ( set ) ; return ( org . eclipse . core . filebuffers . I Document Factory ) get Extension ( entry , f Factories , org . eclipse . core . filebuffers . I Document Factory . class ) ; } return null ; }
public boolean is Same Hash ( Method Hash other ) { return Arrays . equals ( this . hash , other . hash ) ; }
public static int last Index Of Whitespace ( String src , int start Index , int end Index ) { int total = src . length ( ) - NUM_ ; if ( total < NUM_ ) { return - NUM_ ; } if ( start Index >= total ) { start Index = total ; } if ( end Index < NUM_ ) { end Index = NUM_ ; } for ( int i = start Index ; i >= end Index ; i -- ) { if ( Character . is Whitespace ( src . char At ( i ) ) ) { return i ; } } return - NUM_ ; }
@ Override public int next Int ( ) { return ( int ) next Long ( items ) ; }
public static boolean after Or Equal ( final Date date , final Date date To Compare ) { return date . after ( date To Compare ) || date . equals ( date To Compare ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result ; result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + get Default Mean Prec ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + get Default Std Dev Prec ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + get Default Col Name Width ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + get Default Row Name Width ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + get Default Mean Width ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + get Default Std Dev Width ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + get Default Significance Width ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + get Default Count Width ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public Header Iterator iterator ( ) { return new Save List Header Iterator ( this . headers , null ) ; }
public double kurtosis ( ) { double mu = mean ( ) ; double devsum = NUM_ ; double wsum = NUM_ ; int size = values . size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { double dev = values . get ( i ) - mu ; devsum += Math . pow ( dev , NUM_ ) * weights . get ( i ) ; wsum += weights . get ( i ) ; } double mu 4 = devsum / wsum ; double s 4 = Math . pow ( variance ( ) , NUM_ / NUM_ ) ; return mu 4 / s 4 ; }
public Enum Set < Metadata > metadata ( ) { return parameter Metadata . clone ( ) ; }
public boolean is In Memory Db ( ) { return path . equals Ignore Case ( MEMORY DB PATH ) ; }
public static List < String > file List ( String directory Path , boolean include Full Path ) { List < String > file List = new Array List < String > ( ) ; String dir = directory Path . substring ( NUM_ , directory Path . last Index Of ( File . separator ) ) ; String pattern = String Utils . substring After Last ( directory Path , File . separator ) ; File directory = new File ( dir ) ; if ( directory . is Directory ( ) ) { File [ ] files = directory . list Files ( ) ; for ( int i = NUM_ ; i < files . length ; i ++ ) { File f = files [ i ] ; if ( f . is File ( ) ) { String file Name = f . get Name ( ) ; String full Path = dir + File . separator + file Name ; if ( file Name . matches ( convert Glob To Reg Ex ( pattern ) ) ) { if ( include Full Path ) { file List . add ( full Path ) ; } else { file List . add ( file Name ) ; } } } } } return file List ; }
public static Aggregator from String ( String name ) { if ( name != null && ! name . is Empty ( ) ) { for ( Aggregator aggregator : Aggregator . values ( ) ) { if ( name . equals Ignore Case ( aggregator . name ( ) ) ) { return aggregator ; } } } return null ; }
static void throw If Argument To Long ( String tag , String arg , int limit ) { if ( arg != null && arg . length ( ) > limit ) { throw new Illegal Argument Exception ( String . format ( STR_ , tag , limit ) ) ; } }
public static double remainder ( final double dividend , final double divisor ) { if ( Double . is Infinite ( divisor ) ) { if ( Double . is Infinite ( dividend ) ) { return Double . Na N ; } else { return dividend ; } } final double value = dividend % divisor ; if ( Math . abs ( value + value ) > Math . abs ( divisor ) ) { return value + ( value > NUM_ ? - Math . abs ( divisor ) : Math . abs ( divisor ) ) ; } else { return value ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + Arff Loader . FILE EXTENSION COMPRESSED + STR_ + Arff Loader . FILE EXTENSION + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private Array List < Segment 10 > table Segments ( Table Entry 10 table ) { Array List < Segment 10 > table Segments = new Array List < > ( ) ; for ( Segment 10 segment : segments ) { if ( Arrays . equals ( segment . key ( ) , table . key ( ) ) ) { table Segments . add ( segment ) ; } } Collections . sort ( table Segments , null ) ; return table Segments ; }
public boolean is Temp Blob Name ( String blob Name ) { return blob Name . starts With ( Checksum Blob Store Format . TEMP FILE PREFIX ) ; }
private Date date Changed ( Base Openmrs Metadata d ) { Date date Changed = d . get Date Changed ( ) ; if ( date Changed != null ) return date Changed ; return d . get Date Created ( ) ; }
public static String slurp GBURL No Exceptions ( URL u ) { try { return slurp GBURL ( u ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public double pdf ( double x ) { if ( x < NUM_ ) throw new Illegal Argument Exception ( ) ; if ( x == NUM_ ) { if ( alpha == NUM_ ) return NUM_ / lambda ; else return NUM_ ; } if ( alpha == NUM_ ) return Math . exp ( - x / lambda ) / lambda ; return Math . exp ( ( alpha - NUM_ ) * Math . log ( x / lambda ) - x / lambda - Fun . log Gamma ( alpha ) ) / lambda ; }
@ Override public String stem ( String word ) { String result ; Object [ ] args ; if ( m Stemmer == null ) { result = new String ( word ) ; } else { if ( m Set Current Method == null ) { set Stemmer ( get Stemmer ( ) ) ; } try { args = new Object [ NUM_ ] ; args [ NUM_ ] = word ; m Set Current Method . invoke ( m Stemmer , args ) ; args = new Object [ NUM_ ] ; m Stem Method . invoke ( m Stemmer , args ) ; args = new Object [ NUM_ ] ; result = ( String ) m Get Current Method . invoke ( m Stemmer , args ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; result = word ; } } return result ; }
public static < E > List < E > as List ( Iterable < E > iterable ) { if ( iterable instanceof List ) { return ( List < E > ) iterable ; } List < E > result = new Array List < E > ( ) ; for ( E e : iterable ) { result . add ( e ) ; } return result ; }
Object await Fulfill ( Q Node s , E e , boolean timed , long nanos ) { final long deadline = timed ? System . nano Time ( ) + nanos : NUM_ ; Thread w = Thread . current Thread ( ) ; int spins = ( ( head . next == s ) ? ( timed ? max Timed Spins : max Untimed Spins ) : NUM_ ) ; for ( ; ; ) { if ( w . is Interrupted ( ) ) s . try Cancel ( e ) ; Object x = s . item ; if ( x != e ) return x ; if ( timed ) { nanos = deadline - System . nano Time ( ) ; if ( nanos <= NUM_ ) { s . try Cancel ( e ) ; continue ; } } if ( spins > NUM_ ) -- spins ; else if ( s . waiter == null ) s . waiter = w ; else if ( ! timed ) Lock Support . park ( this ) ; else if ( nanos > spin For Timeout Threshold ) Lock Support . park Nanos ( this , nanos ) ; } }
private boolean method Throws Exception ( Method method , Class < ? extends Exception > exception Type ) { for ( Class < ? > thrown Type : method . get Exception Types ( ) ) { if ( exception Type . is Assignable From ( thrown Type ) ) return true ; } return false ; }
private static String add Quotes ( String s ) { int n = s . length ( ) ; int i ; char c ; String Buffer result = new String Buffer ( n + NUM_ ) ; result . append ( STR_ ) ; for ( i = NUM_ ; i < n ; ++ i ) { c = s . char At ( i ) ; if ( c == STR_ ) { result . append ( STR_ ) ; } result . append ( c ) ; } result . append ( STR_ ) ; return result . to String ( ) ; }
public byte [ ] read EEPROM ( Device Handle handle , short offset , int length ) throws Illegal Argument Exception { if ( offset + length > NUM_ ) { throw new Illegal Argument Exception ( STR_ + STR_ + ( offset + length ) + STR_ ) ; } byte [ ] data = new byte [ length ] ; Byte Buffer buffer = Byte Buffer . allocate Direct ( NUM_ ) ; try { write Register ( handle , Block . I 2 C , EEPROM ADDRESS , ( byte ) offset , NUM_ ) ; } catch ( Lib Usb Exception e ) { m Log . error ( STR_ + STR_ + STR_ , e ) ; } for ( int x = NUM_ ; x < length ; x ++ ) { try { read ( handle , EEPROM ADDRESS , Block . I 2 C , buffer ) ; data [ x ] = buffer . get ( ) ; buffer . rewind ( ) ; } catch ( Exception e ) { m Log . error ( STR_ + x + STR_ + length + STR_ + STR_ , e ) ; x = length ; } } return data ; }
public static Type Mirror substitute Method Return Type ( Type Mirror method Type , Type Mirror substituted Receiver Type ) { if ( method Type . get Kind ( ) != Type Kind . TYPEVAR ) { return method Type ; } String t = method Type . to String ( ) ; Type final Receiver Type = ( Type ) substituted Receiver Type ; int i = NUM_ ; for ( Type Symbol type Param : final Receiver Type . tsym . get Type Parameters ( ) ) { if ( t . equals ( type Param . to String ( ) ) ) { return final Receiver Type . get Type Arguments ( ) . get ( i ) ; } i ++ ; } assert false ; return null ; }
public static final XSLT Error Resources load Resource Bundle ( String class Name ) throws Missing Resource Exception { Locale locale = Locale . get Default ( ) ; String suffix = get Resource Suffix ( locale ) ; try { return ( XSLT Error Resources ) Resource Bundle . get Bundle ( class Name + suffix , locale ) ; } catch ( Missing Resource Exception e ) { try { return ( XSLT Error Resources ) Resource Bundle . get Bundle ( class Name , new Locale ( STR_ , STR_ ) ) ; } catch ( Missing Resource Exception e 2 ) { throw new Missing Resource Exception ( STR_ , class Name , STR_ ) ; } } }
public static boolean contains Ra Group Name ( String Set grp Names , String label ) { for ( String name : grp Names ) { if ( name . equals Ignore Case ( label ) ) { return true ; } } return false ; }
public static boolean is File Upload Available ( ) { return is File Upload Available ( false ) ; }
private static boolean is String Property ( String property Name ) { return ( PROPERTY PACKAGE NAME . equals ( property Name ) || PROPERTY CLASS NAME . equals ( property Name ) || PROPERTY CLASS NAME STRICT . equals ( property Name ) || PROPERTY TEXT . equals ( property Name ) || PROPERTY BEFORE TEXT . equals ( property Name ) || PROPERTY CONTENT DESCRIPTION . equals ( property Name ) || PROPERTY CONTENT DESCRIPTION OR TEXT . equals ( property Name ) || PROPERTY NODE DESCRIPTION OR FALLBACK . equals ( property Name ) || PROPERTY VERSION NAME . equals ( property Name ) || PROPERTY PLATFORM RELEASE . equals ( property Name ) ) ; }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; }
public static boolean is Multi Dex ( File archive File ) { Content Reader content Reader = new Content Reader ( archive File ) ; content Reader . load ( ) ; List < String > all Class Names = content Reader . get All Class Names ( ) ; int num Dexes = NUM_ ; for ( String class Entry : all Class Names ) { if ( class Entry . ends With ( STR_ ) ) { num Dexes ++ ; if ( num Dexes == NUM_ ) { return true ; } } } return false ; }
protected boolean labels Have Same Baselines ( ) { if ( ! checked Label Baselines ) { checked Label Baselines = true ; Dictionary dictionary = slider . get Label Table ( ) ; if ( dictionary != null ) { same Label Baselines = true ; Enumeration elements = dictionary . elements ( ) ; int baseline = - NUM_ ; while ( elements . has More Elements ( ) ) { J Component label = ( J Component ) elements . next Element ( ) ; Dimension pref = label . get Preferred Size ( ) ; int label Baseline = label . get Baseline ( pref . width , pref . height ) ; if ( label Baseline >= NUM_ ) { if ( baseline == - NUM_ ) { baseline = label Baseline ; } else if ( baseline != label Baseline ) { same Label Baselines = false ; break ; } } else { same Label Baselines = false ; break ; } } } else { same Label Baselines = false ; } } return same Label Baselines ; }
public Shape Tile Box bounding box ( int p from corner no , int p to corner no ) { int from corner no = Math . max ( p from corner no , NUM_ ) ; int to corner no = Math . min ( p to corner no , plaline len ( - NUM_ ) ) ; double llx = Integer . MAX VALUE ; double lly = llx ; double urx = Integer . MIN VALUE ; double ury = urx ; for ( int i = from corner no ; i <= to corner no ; ++ i ) { Pla Point Float curr corner = corner approx ( i ) ; llx = Math . min ( llx , curr corner . v x ) ; lly = Math . min ( lly , curr corner . v y ) ; urx = Math . max ( urx , curr corner . v x ) ; ury = Math . max ( ury , curr corner . v y ) ; } Pla Point Int lower left = new Pla Point Int ( Math . floor ( llx ) , Math . floor ( lly ) ) ; Pla Point Int upper right = new Pla Point Int ( Math . ceil ( urx ) , Math . ceil ( ury ) ) ; return new Shape Tile Box ( lower left , upper right ) ; }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( true ) ; if ( Build Config . DEBUG ) { Log . d ( TAG , STR_ + data ) ; } } else { return false ; } } return true ; }
public static boolean verify File Md 5 ( File file , String md 5 ) { if ( md 5 == null ) { return false ; } String file Md 5 = get MD 5 ( file ) ; if ( file Md 5 == null ) { return false ; } return md 5 . equals ( file Md 5 ) ; }
public static int floor Log 2 ( double d ) { if ( d <= NUM_ ) throw new Arithmetic Exception ( STR_ ) ; long bits = Double . double To Long Bits ( d ) ; int exp = ( ( int ) ( bits > > NUM_ ) ) & NUM_ ; if ( exp == NUM_ ) throw new Arithmetic Exception ( STR_ ) ; if ( exp == NUM_ ) return floor Log 2 ( d * NUM_ ) - NUM_ ; return exp - NUM_ ; }
private boolean is Remove All Initiators ( Export Mask export Mask , List < Initiator > initiators ) { String Set initiators In Mask = export Mask . get Initiators ( ) ; String Set initiators To Remove = String Set Util . obj Collection To String Set ( initiators ) ; return initiators In Mask == null || ( initiators In Mask . contains All ( initiators To Remove ) && ( initiators In Mask . size ( ) == initiators To Remove . size ( ) ) ) ; }
public void wait For Rollover ( ) { final int count = rollover Completions . get ( ) ; while ( rollover Completions . get ( ) == count ) { try { Thread . sleep ( NUM_ ) ; } catch ( final Interrupted Exception e ) { } } }
protected void build ( Byte Buffer raw ) { this . data Bytes = new byte [ data Size ] ; for ( int i = NUM_ ; i < data Bytes . length ; i ++ ) { this . data Bytes [ i ] = raw . get ( ) ; } }
public Vec sorted Copy ( ) { double [ ] array Copy = array Copy ( ) ; Arrays . sort ( array Copy ) ; return new Dense Vector ( array Copy ) ; }
public static void close Quietly ( Auto Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( Runtime Exception rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
@ Override public Output Distribution copy ( ) { Output Distribution copy = new Output Distribution ( base Var + primes ) ; for ( Anchored Rule rule : input Rules ) { copy . add Anchored Rule ( rule ) ; } return copy ; }
private int strip Multipart Headers ( Byte Buffer b , int offset ) { int i ; for ( i = offset ; i < b . limit ( ) ; i ++ ) { if ( b . get ( i ) == STR_ && b . get ( ++ i ) == STR_ && b . get ( ++ i ) == STR_ && b . get ( ++ i ) == STR_ ) { break ; } } return i + NUM_ ; }
public long current ( ) { return sequence . get ( ) ; }
private Array DBI Ds greedy ( Distance Query < V > dist Func , DBI Ds sample Set , int m , Random random ) { Array Modifiable DBI Ds medoids = DBID Util . new Array ( m ) ; Array Modifiable DBI Ds s = DBID Util . new Array ( sample Set ) ; DBID Array Iter iter = s . iter ( ) ; DBID Var m i = DBID Util . new Var ( ) ; int size = s . size ( ) ; s . swap ( random . next Int ( size ) , -- size ) ; medoids . add ( s . pop ( m i ) ) ; if ( LOG . is Debugging ( ) ) { LOG . debug Finer ( STR_ + medoids . to String ( ) ) ; } int worst = - NUM_ ; double worstd = Double . NEGATIVE INFINITY ; Writable Double Data Store distances = Data Store Util . make Double Storage ( s , Data Store Factory . HINT HOT | Data Store Factory . HINT TEMP ) ; for ( iter . seek ( NUM_ ) ; iter . get Offset ( ) < size ; iter . advance ( ) ) { final double dist = dist Func . distance ( iter , m i ) ; distances . put Double ( iter , dist ) ; if ( dist > worstd ) { worstd = dist ; worst = iter . get Offset ( ) ; } } for ( int i = NUM_ ; i < m ; i ++ ) { s . swap ( worst , -- size ) ; medoids . add ( s . pop ( m i ) ) ; worst = - NUM_ ; worstd = Double . NEGATIVE INFINITY ; for ( iter . seek ( NUM_ ) ; iter . get Offset ( ) < size ; iter . advance ( ) ) { double dist new = dist Func . distance ( iter , m i ) ; double dist old = distances . double Value ( iter ) ; double dist = ( dist new < dist old ) ? dist new : dist old ; distances . put Double ( iter , dist ) ; if ( dist > worstd ) { worstd = dist ; worst = iter . get Offset ( ) ; } } if ( LOG . is Debugging ( ) ) { LOG . debug Finer ( STR_ + medoids . to String ( ) ) ; } } return medoids ; }
public Set < String > search Referral Privilege Names ( Set < Search Filter > filters , boolean bool And , int num Of Entries , boolean sort Results , boolean ascending Order ) throws Entitlement Exception { return search Referral Privilege Names ( filters , get Admin Subject ( ) , get Realm ( ) , bool And , num Of Entries , sort Results , ascending Order ) ; }
public T Double Double Hash Map absolute Distribution Log 10 ( double descretization ) { T Double Double Hash Map freq = new T Double Double Hash Map ( ) ; int size = values . size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { double bin idx = Math . ceil ( Math . log 10 ( values . get ( i ) / descretization ) ) ; bin idx = Math . max ( bin idx , NUM_ ) ; double bin Width = Math . pow ( NUM_ , bin idx ) - Math . pow ( NUM_ , bin idx - NUM_ ) ; bin Width = Math . max ( NUM_ , bin Width ) ; freq . adjust Or Put Value ( Math . pow ( NUM_ , bin idx ) * descretization , weights . get ( i ) / bin Width , weights . get ( i ) / bin Width ) ; } return freq ; }
public int available ( ) throws IO Exception { int bytes Available = in . available ( ) ; if ( bytes Available > bytes Left ) bytes Available = bytes Left ; return bytes Available ; }
Workflow . Method remove Vplex Volumes From SRDF Target CG Method ( URI vplex URI , List < URI > vplex Volume UR Is ) { return new Workflow . Method ( STR_ , vplex URI , vplex Volume UR Is ) ; }
public String to Safe String ( ) { String scheme = get Scheme ( ) ; String ssp = get Scheme Specific Part ( ) ; if ( scheme != null ) { if ( scheme . equals Ignore Case ( STR_ ) || scheme . equals Ignore Case ( STR_ ) || scheme . equals Ignore Case ( STR_ ) || scheme . equals Ignore Case ( STR_ ) || scheme . equals Ignore Case ( STR_ ) ) { String Builder builder = new String Builder ( NUM_ ) ; builder . append ( scheme ) ; builder . append ( STR_ ) ; if ( ssp != null ) { for ( int i = NUM_ ; i < ssp . length ( ) ; i ++ ) { char c = ssp . char At ( i ) ; if ( c == STR_ || c == STR_ || c == STR_ ) { builder . append ( c ) ; } else { builder . append ( STR_ ) ; } } } return builder . to String ( ) ; } else if ( scheme . equals Ignore Case ( STR_ ) || scheme . equals Ignore Case ( STR_ ) || scheme . equals Ignore Case ( STR_ ) ) { ssp = STR_ + ( ( get Host ( ) != null ) ? get Host ( ) : STR_ ) + ( ( get Port ( ) != - NUM_ ) ? ( STR_ + get Port ( ) ) : STR_ ) + STR_ ; } } String Builder builder = new String Builder ( NUM_ ) ; if ( scheme != null ) { builder . append ( scheme ) ; builder . append ( STR_ ) ; } if ( ssp != null ) { builder . append ( ssp ) ; } return builder . to String ( ) ; }
public Object next ( ) throws IO Exception { if ( prev Pos <= NUM_ ) return null ; long end Of This Record = prev Pos ; int this Length = next Length ; long record Start = prev Pos - this Length ; prev Pos = record Start - NUM_ ; if ( prev Pos <= NUM_ ) return null ; long buffer Pos = fis . get Buffer Pos ( ) ; if ( prev Pos >= buffer Pos ) { } else { long seek Pos = end Of This Record - fis . get Buffer Size ( ) ; seek Pos = Math . min ( seek Pos , prev Pos ) ; seek Pos = Math . max ( seek Pos , NUM_ ) ; fis . seek ( seek Pos ) ; fis . peek ( ) ; } fis . seek ( prev Pos ) ; next Length = fis . read Int ( ) ; Object o = codec . read Val ( fis ) ; return o ; }
boolean contain Key ( String handler ) { if ( ( handler == null ) || ( handler . length ( ) == NUM_ ) ) { return false ; } if ( relay State Map . contains Key ( handler ) ) { return true ; } else { return false ; } }
public Object Get Instance ( ) { if ( Option Instance ) { return Plug In Object ; } return null ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + num Execution Slots Tip Text ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public static String mask Right ( String s , int len , char mask ch ) { if ( len <= NUM_ ) { return s ; } len = Math . min ( len , s . length ( ) ) ; String Builder sb = new String Builder ( ) ; sb . append ( s . substring ( NUM_ , s . length ( ) - len ) ) ; for ( int i = NUM_ ; i < len ; i ++ ) { sb . append ( mask ch ) ; } return sb . to String ( ) ; }
public final Alg Vector add ( Alg Vector other ) { Alg Vector b = null ; if ( m Elements != null ) { int n = m Elements . length ; try { b = ( Alg Vector ) clone ( ) ; } catch ( Clone Not Supported Exception ex ) { b = new Alg Vector ( n ) ; } for ( int i = NUM_ ; i < n ; i ++ ) { b . m Elements [ i ] = m Elements [ i ] + other . m Elements [ i ] ; } } return b ; }
public static boolean starts With ( char s [ ] , int len , String prefix ) { final int prefix Len = prefix . length ( ) ; if ( prefix Len > len ) return false ; for ( int i = NUM_ ; i < prefix Len ; i ++ ) if ( s [ i ] != prefix . char At ( i ) ) return false ; return true ; }
public List < T > lru Values ( ) { Array List < T > lru Values = new Array List < T > ( pmap . size ( ) ) ; Cache Node < T > next = lru First ; while ( next != null ) { lru Values . add ( next . get ( ) ) ; next = next . get After ( ) ; } return lru Values ; }
public long elapsed ( ) { return MILLISECONDS . convert ( System . nano Time ( ) - start Time Nanos , NANOSECONDS ) ; }
@ Override public Enumeration < String > enumerate Requests ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; if ( m filter Thread != null ) { new Vector . add Element ( STR_ ) ; } return new Vector . elements ( ) ; }
public static int last Index Of ( final String value , final String needle ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; return last Index Of ( value , needle , value . length ( ) , true ) ; }
public String read N ( int n ) { String s = data . substring ( pos , pos + n ) ; pos += n ; return s ; }
protected boolean errors Occurred ( ) { for ( Iterator iter = errors . iterator ( ) ; iter . has Next ( ) ; ) { I Status status = ( I Status ) iter . next ( ) ; if ( status . get Severity ( ) == I Status . ERROR ) return true ; } return false ; }
public static String truncate ( int n , int smallest Digit , int biggest Digit ) { int num Digits = biggest Digit - smallest Digit + NUM_ ; char [ ] result = new char [ num Digits ] ; for ( int j = NUM_ ; j < smallest Digit ; j ++ ) { n = n / NUM_ ; } for ( int j = num Digits - NUM_ ; j >= NUM_ ; j -- ) { result [ j ] = Character . for Digit ( n % NUM_ , NUM_ ) ; n = n / NUM_ ; } return new String ( result ) ; }
public long last Modified ( ) { return file != null ? file . last Modified ( ) : zip Entry . get Time ( ) ; }
public static boolean is Supported ( Class < ? > type ) { return SUPPORTED PRIMITIVE TYPES . contains ( type ) ; }
public String transform To String ( int value ) { return String . value Of ( value ) ; }
public Coded Exception with Prefix ( String ... prefixes ) { String prefix = String Utils . join ( prefixes , STR_ ) ; if ( ! fault Code . starts With ( prefix ) ) { fault Code = prefix + STR_ + fault Code ; } return this ; }
public List < T > to List ( ) { return Arrays . as List ( Arrays . copy Of ( elements , num Elements ) ) ; }
public Object [ ] to Array ( ) { Array List < E > al = new Array List < E > ( ) ; for ( Node < E > p = first ( ) ; p != null ; p = succ ( p ) ) { E item = p . item ; if ( item != null ) al . add ( item ) ; } return al . to Array ( ) ; }
public boolean is Private User Group ( ) { return is Private User Group ( this . type , this . auto Delete , this . name ) ; }
@ Non Null public Parcelable on Save Instance State ( ) { Bundle bundle = new Bundle ( ) ; bundle . put Int ( SAVEDINSTANCESTATE FIRSTANIMATEDPOSITION , m First Animated Position ) ; bundle . put Int ( SAVEDINSTANCESTATE LASTANIMATEDPOSITION , m Last Animated Position ) ; bundle . put Boolean ( SAVEDINSTANCESTATE SHOULDANIMATE , m Should Animate ) ; return bundle ; }
public String generate Instance Id ( ) throws Scheduler Exception { String property = System . get Property ( get System Property Name ( ) ) ; if ( property == null ) { throw new Scheduler Exception ( STR_ + SYSTEM PROPERTY + STR_ ) ; } if ( get Prepend ( ) != null ) property = get Prepend ( ) + property ; if ( get Postpend ( ) != null ) property = property + get Postpend ( ) ; return property ; }
public Generic Principal authenticate ( String username , String password ) { Generic Principal principal = m user Principal . get ( username ) ; if ( principal != null ) { if ( ! password . equals ( principal . get Password ( ) ) ) throw new Space Security Exception ( STR_ + username ) ; } else throw new Space Security Exception ( STR_ + username ) ; return principal ; }
public boolean separates ( int a , int b ) { return A . get ( a ) && B . get ( b ) || A . get ( b ) && B . get ( a ) ; }
static < T > Items Sketch < T > copy ( final Items Sketch < T > sketch ) { final Items Sketch < T > qs Copy = Items Sketch . get Instance ( sketch . k , sketch . comparator ) ; qs Copy . n = sketch . n ; qs Copy . min Value = sketch . get Min Value ( ) ; qs Copy . max Value = sketch . get Max Value ( ) ; qs Copy . combined Buffer Item Capacity = sketch . get Combined Buffer Allocated Count ( ) ; qs Copy . base Buffer Count = sketch . get Base Buffer Count ( ) ; qs Copy . bit Pattern = sketch . get Bit Pattern ( ) ; Object [ ] comb Buf = sketch . get Combined Buffer ( ) ; qs Copy . combined Buffer = Arrays . copy Of ( comb Buf , comb Buf . length ) ; return qs Copy ; }
@ Suppress Warnings ( STR_ ) public List < V > values ( ) { int found = NUM_ ; Array List < V > result = new Array List < V > ( m size ) ; for ( Osm Element v : m data ) { if ( v != FREE KEY && v != removed Key ) { result . add ( ( V ) v ) ; found ++ ; if ( found >= m size ) { break ; } } } return result ; }
public boolean is Managing Component ( Component c ) { return scr Constr Map . contains Key ( c ) ; }
public Iterator < Sim Event > iterator ( ) { return sorted Set . iterator ( ) ; }
public static Point to Swt Point ( final java . awt . geom . Point 2 D p ) { return new Point ( ( int ) Math . round ( p . get X ( ) ) , ( int ) Math . round ( p . get Y ( ) ) ) ; }
public static Calendar to Calendar ( Date date , Time Zone time Zone , Locale locale ) { Calendar cal = get Calendar Instance ( time Zone , locale ) ; if ( date != null ) { cal . set Time ( date ) ; } return cal ; }
public char abbreviation ( ) { return name . char At ( NUM_ ) ; }
@ Deprecated public static String percentage With Two Characters ( final double decimal Number ) { final int percentage = ( int ) Math . round ( decimal Number * PERCENTAGE FACTOR ) ; return ( percentage < PERCENTAGE FACTOR ) ? String Utils . left Pad ( String . value Of ( percentage ) , NUM_ , STR_ ) : STR_ ; }
public int hash Code ( ) { int hash = mask ; if ( range Set != null ) { hash &= CONTEXTUAL MASK ; hash ^= range Set . hash Code ( ) ; } return hash ; }
public Mention Token next Mention ( ) { if ( ! has Next Mention ( ) ) throw new Illegal State Exception ( STR_ ) ; Token t = next Regex ( any Mention Pattern ) ; final int less Than = t . get Start Index ( ) ; final int greater Than = t . get End Index ( ) ; final String matched = t . get Content ( ) ; final char type = matched . char At ( NUM_ ) ; if ( type == STR_ ) { if ( matched . char At ( NUM_ ) == STR_ ) { return new Role Mention Token ( this , less Than , greater Than ) ; } return new User Mention Token ( this , less Than , greater Than ) ; } else if ( type == STR_ ) { return new Channel Mention Token ( this , less Than , greater Than ) ; } throw new Illegal State Exception ( STR_ ) ; }
public String longest Match ( String input ) { Trie Node node = root ; String result = null ; for ( int i = NUM_ ; i < input . length ( ) ; i ++ ) { node = node . get Child ( input . char At ( i ) ) ; if ( node == null ) break ; if ( node . is Terminal ( ) ) result = input . substring ( NUM_ , i + NUM_ ) ; } return result ; }
public int [ ] num Vertices Sampled ( Set < ? extends Sampled Vertex > vertices ) { int it = - NUM_ ; T Int Int Hash Map map = new T Int Int Hash Map ( ) ; for ( Sampled Vertex v : vertices ) { if ( v . is Sampled ( ) ) { map . adjust Or Put Value ( v . get Iteration Sampled ( ) , NUM_ , NUM_ ) ; it = Math . max ( it , v . get Iteration Sampled ( ) ) ; } } int [ ] list = new int [ it + NUM_ ] ; for ( int i = NUM_ ; i <= it ; i ++ ) { list [ i ] = map . get ( i ) ; } return list ; }
@ Override protected boolean log Multiple Exceptions ( ) { return false ; }
public static String max Common Prefix ( String one , String two ) { final int min Length = Math . min ( one . length ( ) , two . length ( ) ) ; final String Builder sb = new String Builder ( min Length ) ; for ( int pos = NUM_ ; pos < min Length ; pos ++ ) { final char current Char = one . char At ( pos ) ; if ( current Char != two . char At ( pos ) ) { break ; } sb . append ( current Char ) ; } return sb . to String ( ) ; }
public boolean is Show Library Functions ( ) { return m library Function Checkbox . is Selected ( ) ; }
public static Function from String ( String name ) { if ( name != null ) { for ( Function func : Function . values ( ) ) { if ( name . equals Ignore Case ( func . get Name ( ) ) ) { return func ; } } } throw new Illegal Argument Exception ( name ) ; }
public static boolean is Blank ( String s ) { return ( ( null == s ) || ( EMPTY STRING . equals ( s . trim ( ) ) ) ) ; }
protected void wait For Messages To Be Delivered ( ) { long max Wait Time = NUM_ ; long wait Time = max Wait Time ; long start = ( max Wait Time <= NUM_ ) ? NUM_ : System . current Time Millis ( ) ; synchronized ( lock ) { while ( messages . size ( ) < data . length && wait Time >= NUM_ ) { try { lock . wait ( NUM_ ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } wait Time = max Wait Time - ( System . current Time Millis ( ) - start ) ; } } }
public static double ln Factorial ( double x ) { return Statistics . ln Gamma ( x + NUM_ ) ; }
private Array List < Coords > all Board Hexes ( ) { I Board board = game . get Board ( ) ; if ( board == null ) return null ; Array List < Coords > Coord List = new Array List < Coords > ( ) ; for ( int i = NUM_ ; i < board . get Width ( ) ; i ++ ) { for ( int j = NUM_ ; j < board . get Height ( ) ; j ++ ) { I Hex hex = board . get Hex ( i , j ) ; if ( hex != null ) { Coord List . add ( new Coords ( i , j ) ) ; } } } return Coord List ; }
static Type [ ] map Key And Value Types ( Type context , Class < ? > context Raw Type ) { if ( context == Properties . class ) return new Type [ ] { String . class , String . class } ; Type map Type = get Supertype ( context , context Raw Type , Map . class ) ; if ( map Type instanceof Parameterized Type ) { Parameterized Type map Parameterized Type = ( Parameterized Type ) map Type ; return map Parameterized Type . get Actual Type Arguments ( ) ; } return new Type [ ] { Object . class , Object . class } ; }
public static int octant ( double dx , double dy ) { if ( dx == NUM_ && dy == NUM_ ) throw new Illegal Argument Exception ( STR_ + dx + STR_ + dy + STR_ ) ; double adx = Math . abs ( dx ) ; double ady = Math . abs ( dy ) ; if ( dx >= NUM_ ) { if ( dy >= NUM_ ) { if ( adx >= ady ) return NUM_ ; else return NUM_ ; } else { if ( adx >= ady ) return NUM_ ; else return NUM_ ; } } else { if ( dy >= NUM_ ) { if ( adx >= ady ) return NUM_ ; else return NUM_ ; } else { if ( adx >= ady ) return NUM_ ; else return NUM_ ; } } }
public static View Property Animator animate ( View view ) { View Property Animator animator = ANIMATORS . get ( view ) ; if ( animator == null ) { final int version = Integer . value Of ( Build . VERSION . SDK ) ; if ( version >= Build . VERSION CODES . ICE CREAM SANDWICH ) { animator = new View Property Animator ICS ( view ) ; } else if ( version >= Build . VERSION CODES . HONEYCOMB ) { animator = new View Property Animator HC ( view ) ; } else { animator = new View Property Animator Pre HC ( view ) ; } ANIMATORS . put ( view , animator ) ; } return animator ; }
protected static String read Stream ( Input Stream stream ) throws One Drive API Exception { if ( stream == null ) { return null ; } Input Stream Reader reader = new Input Stream Reader ( stream , Standard Charsets . UTF 8 ) ; String Builder builder = new String Builder ( ) ; char [ ] buffer = new char [ BUFFER SIZE ] ; try { int read ; while ( ( read = reader . read ( buffer , NUM_ , BUFFER SIZE ) ) != - NUM_ ) { builder . append ( buffer , NUM_ , read ) ; } stream . close ( ) ; } catch ( IO Exception e ) { throw new One Drive API Exception ( STR_ , e ) ; } return builder . to String ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( NUM_ ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private static Immutable Pair < Integer , String > check Sample Changed ( Connection conn , Fingerprint fingerprint ) throws SQL Exception { if ( fingerprint . get Sample Set ID ( ) == null ) { return new Immutable Pair < Integer , String > ( null , null ) ; } String query = STR_ + STR_ + STR_ + ( fingerprint . get User agent ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Accept headers ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Platform ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Platform Flash ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Plugin Details ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Time Zone ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Screen Details ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Screen Details Flash ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Screen Details CSS ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Language Flash ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Fonts ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Fonts JS CSS ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Fonts CSS ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Char Sizes ( ) == null ? STR_ : STR_ ) + STR_ + STR_ + ( fingerprint . get Super Cookie Local Storage ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Super Cookie Session Storage ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Super Cookie User Data ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Hsts Enabled ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Indexed DB Enabled ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Do Not Track ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Clock Difference ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Date Time ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Math Tan ( ) == null ? STR_ : STR_ ) + STR_ + STR_ + ( fingerprint . get Tbb Version ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Ads Blocked Google ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Ads Blocked Banner ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Ads Blocked Script ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Like Share Facebook ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Like Share Twitter ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Like Share Reddit ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Canvas ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Web GL Vendor ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Web GL Renderer ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Touch Points ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Touch Event ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Touch Start ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Audio Fingerprint PXI ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Audio Fingerprint PXI Full Buffer ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Audio Fingerprint Nt Vc ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Audio Fingerprint CC ( ) == null ? STR_ : STR_ ) + STR_ + ( fingerprint . get Audio Fingerprint Hybrid ( ) == null ? STR_ : STR_ ) + STR_ ; Prepared Statement check Exists = conn . prepare Statement ( query ) ; int index = NUM_ ; check Exists . set String ( index , fingerprint . get Sample Set ID ( ) ) ; ++ index ; if ( fingerprint . get Contrast Level ( ) != null ) { check Exists . set Int ( index , fingerprint . get Contrast Level ( ) ) ; ++ index ; } if ( fingerprint . get User agent ( ) != null ) { check Exists . set String ( index , fingerprint . get User agent ( ) ) ; ++ index ; } if ( fingerprint . get Accept headers ( ) != null ) { check Exists . set String ( index , fingerprint . get Accept headers ( ) ) ; ++ index ; } if ( fingerprint . get Platform ( ) != null ) { check Exists . set String ( index , fingerprint . get Platform ( ) ) ; ++ index ; } if ( fingerprint . get Platform Flash ( ) != null ) { check Exists . set String ( index , fingerprint . get Platform Flash ( ) ) ; ++ index ; } if ( fingerprint . get Plugin Details ( ) != null ) { check Exists . set String ( index , fingerprint . get Plugin Details ( ) ) ; ++ index ; } if ( fingerprint . get Time Zone ( ) != null ) { check Exists . set String ( index , fingerprint . get Time Zone ( ) ) ; ++ index ; } if ( fingerprint . get Screen Details ( ) != null ) { check Exists . set String ( index , fingerprint . get Screen Details ( ) ) ; ++ index ; } if ( fingerprint . get Screen Details Flash ( ) != null ) { check Exists . set String ( index , fingerprint . get Screen Details Flash ( ) ) ; ++ index ; } if ( fingerprint . get Screen Details CSS ( ) != null ) { check Exists . set String ( index , fingerprint . get Screen Details CSS ( ) ) ; ++ index ; } if ( fingerprint . get Language Flash ( ) != null ) { check Exists . set String ( index , fingerprint . get Language Flash ( ) ) ; ++ index ; } if ( fingerprint . get Fonts ( ) != null ) { check Exists . set String ( index , fingerprint . get Fonts ( ) ) ; ++ index ; } if ( fingerprint . get Fonts JS CSS ( ) != null ) { check Exists . set String ( index , fingerprint . get Fonts JS CSS ( ) ) ; ++ index ; } if ( fingerprint . get Fonts CSS ( ) != null ) { check Exists . set String ( index , fingerprint . get Fonts CSS ( ) ) ; ++ index ; } if ( fingerprint . get Char Sizes ( ) != null ) { check Exists . set String ( index , fingerprint . get Char Sizes ( ) ) ; ++ index ; } check Exists . set Boolean ( index , fingerprint . is Cookies Enabled ( ) ) ; ++ index ; if ( fingerprint . get Super Cookie Local Storage ( ) != null ) { check Exists . set Boolean ( index , fingerprint . get Super Cookie Local Storage ( ) ) ; ++ index ; } if ( fingerprint . get Super Cookie Session Storage ( ) != null ) { check Exists . set Boolean ( index , fingerprint . get Super Cookie Session Storage ( ) ) ; ++ index ; } if ( fingerprint . get Super Cookie User Data ( ) != null ) { check Exists . set Boolean ( index , fingerprint . get Super Cookie User Data ( ) ) ; ++ index ; } if ( fingerprint . get Hsts Enabled ( ) != null ) { check Exists . set Boolean ( index , fingerprint . get Hsts Enabled ( ) ) ; ++ index ; } if ( fingerprint . get Indexed DB Enabled ( ) != null ) { check Exists . set Boolean ( index , fingerprint . get Indexed DB Enabled ( ) ) ; ++ index ; } if ( fingerprint . get Do Not Track ( ) != null ) { check Exists . set String ( index , fingerprint . get Do Not Track ( ) ) ; ++ index ; } if ( fingerprint . get Clock Difference ( ) != null ) { check Exists . set Long ( index , fingerprint . get Clock Difference ( ) ) ; ++ index ; } if ( fingerprint . get Date Time ( ) != null ) { check Exists . set String ( index , fingerprint . get Date Time ( ) ) ; ++ index ; } if ( fingerprint . get Math Tan ( ) != null ) { check Exists . set String ( index , fingerprint . get Math Tan ( ) ) ; ++ index ; } check Exists . set Boolean ( index , fingerprint . is Using Tor ( ) ) ; ++ index ; if ( fingerprint . get Tbb Version ( ) != null ) { check Exists . set String ( index , fingerprint . get Tbb Version ( ) ) ; ++ index ; } if ( fingerprint . get Ads Blocked Google ( ) != null ) { check Exists . set Boolean ( index , fingerprint . get Ads Blocked Google ( ) ) ; ++ index ; } if ( fingerprint . get Ads Blocked Banner ( ) != null ) { check Exists . set Boolean ( index , fingerprint . get Ads Blocked Banner ( ) ) ; ++ index ; } if ( fingerprint . get Ads Blocked Script ( ) != null ) { check Exists . set Boolean ( index , fingerprint . get Ads Blocked Script ( ) ) ; ++ index ; } if ( fingerprint . get Like Share Facebook ( ) != null ) { check Exists . set Int ( index , fingerprint . get Like Share Facebook ( ) ) ; ++ index ; } if ( fingerprint . get Like Share Twitter ( ) != null ) { check Exists . set Int ( index , fingerprint . get Like Share Twitter ( ) ) ; ++ index ; } if ( fingerprint . get Like Share Reddit ( ) != null ) { check Exists . set Int ( index , fingerprint . get Like Share Reddit ( ) ) ; ++ index ; } if ( fingerprint . get Canvas ( ) != null ) { check Exists . set String ( index , fingerprint . get Canvas ( ) ) ; ++ index ; } if ( fingerprint . get Web GL Vendor ( ) != null ) { check Exists . set String ( index , fingerprint . get Web GL Vendor ( ) ) ; ++ index ; } if ( fingerprint . get Web GL Renderer ( ) != null ) { check Exists . set String ( index , fingerprint . get Web GL Renderer ( ) ) ; ++ index ; } if ( fingerprint . get Touch Points ( ) != null ) { check Exists . set Int ( index , fingerprint . get Touch Points ( ) ) ; ++ index ; } if ( fingerprint . get Touch Event ( ) != null ) { check Exists . set Boolean ( index , fingerprint . get Touch Event ( ) ) ; ++ index ; } if ( fingerprint . get Touch Start ( ) != null ) { check Exists . set Boolean ( index , fingerprint . get Touch Start ( ) ) ; ++ index ; } if ( fingerprint . get Audio Fingerprint PXI ( ) != null ) { check Exists . set String ( index , fingerprint . get Audio Fingerprint PXI ( ) ) ; ++ index ; } if ( fingerprint . get Audio Fingerprint PXI Full Buffer ( ) != null ) { check Exists . set String ( index , fingerprint . get Audio Fingerprint PXI Full Buffer ( ) ) ; ++ index ; } if ( fingerprint . get Audio Fingerprint Nt Vc ( ) != null ) { check Exists . set String ( index , fingerprint . get Audio Fingerprint Nt Vc ( ) ) ; ++ index ; } if ( fingerprint . get Audio Fingerprint CC ( ) != null ) { check Exists . set String ( index , fingerprint . get Audio Fingerprint CC ( ) ) ; ++ index ; } if ( fingerprint . get Audio Fingerprint Hybrid ( ) != null ) { check Exists . set String ( index , fingerprint . get Audio Fingerprint Hybrid ( ) ) ; ++ index ; } Result Set rs = check Exists . execute Query ( ) ; Integer sample ID = null ; String sample UUID = null ; if ( rs . next ( ) ) { sample ID = rs . get Int ( NUM_ ) ; sample UUID = rs . get String ( NUM_ ) ; } rs . close ( ) ; check Exists . close ( ) ; return new Immutable Pair < Integer , String > ( sample ID , sample UUID ) ; }
public void go Back ( ) { ensure Wizard Is Running ( ) ; if ( my Prev Steps . empty ( ) ) { throw new Illegal State Exception ( STR_ ) ; } Model Wizard Step curr Step = my Steps . get ( my Curr Index ) ; if ( ! curr Step . can Go Back ( ) ) { throw new Illegal State Exception ( STR_ ) ; } my Curr Index = my Steps . index Of ( my Prev Steps . pop ( ) ) ; update Navigation Properties ( ) ; show Current Step ( ) ; }
private String construct Tcp Info ( Inet Address host ) { String domain = host . get Canonical Host Name ( ) ; String address = host . get Host Address ( ) ; if ( domain . equals ( address ) ) return STR_ + address + STR_ ; else return domain + STR_ + address + STR_ ; }
private void validate Header ( boolean validate Record Size ) throws IO Exception { int readmagic = file . read Int ( ) ; if ( readmagic != this . magic ) { file . close ( ) ; throw new IO Exception ( STR_ + readmagic + STR_ + this . magic ) ; } if ( file . read Int ( ) != this . headersize ) { file . close ( ) ; throw new IO Exception ( STR_ ) ; } if ( validate Record Size ) { if ( file . read Int ( ) != this . recordsize ) { file . close ( ) ; throw new IO Exception ( STR_ ) ; } } else { this . recordsize = file . read Int ( ) ; } if ( file . get File Pointer ( ) != HEADER POS SIZE ) { throw new IO Exception ( STR_ ) ; } this . numrecs = file . read Int ( ) ; if ( numrecs < NUM_ || file . length ( ) != index To Fileposition ( numrecs ) ) { throw new IO Exception ( STR_ ) ; } if ( file . get File Pointer ( ) != INTERNAL HEADER SIZE ) { throw new IO Exception ( STR_ ) ; } }
public double adjusted Log 10 ( double val ) { boolean neg Flag = ( val < NUM_ ) ; if ( neg Flag ) { val = - val ; } if ( val < NUM_ ) { val += ( NUM_ - val ) / NUM_ ; } double res = Math . log ( val ) / LOG 10 VALUE ; return neg Flag ? ( - res ) : res ; }
public int count ( ) { return padstack list . size ( ) ; }
public static boolean is Blank ( String value ) { return value == null || value . is Empty ( ) ; }
public static String indent ( int level ) { return ( level <= NUM_ ) ? STR_ : String . format ( STR_ + level * NUM_ + STR_ , STR_ ) ; }
static Label Node [ ] clone ( final List < Label Node > labels , final Map < Label Node , Label Node > map ) { Label Node [ ] clones = new Label Node [ labels . size ( ) ] ; for ( int i = NUM_ ; i < clones . length ; ++ i ) { clones [ i ] = map . get ( labels . get ( i ) ) ; } return clones ; }
public static boolean all Instances Of ( Class < ? > clazz , Object [ ] objs ) { for ( Object obj : objs ) { if ( ! clazz . is Instance ( obj ) ) return false ; } return true ; }
public String to String Matrix ( ) { String Buffer result ; String [ ] [ ] cells ; int i ; int n ; result = new String Buffer ( ) ; cells = to Array ( ) ; for ( i = NUM_ ; i < cells . length ; i ++ ) { for ( n = NUM_ ; n < cells [ i ] . length ; n ++ ) { if ( n > NUM_ ) result . append ( STR_ ) ; result . append ( Utils . quote ( cells [ i ] [ n ] ) ) ; } result . append ( STR_ ) ; } return result . to String ( ) ; }
public final boolean between ( int i Num , int i Min , int i Max ) { return ( i Num >= i Min ) && ( i Num <= i Max ) ; }
static private String construct Class ( String device name , String target os , String os version , String class Name , File exclude File , int run id ) { int i = NUM_ ; String ret = STR_ ; ret += STR_ ; ret += STR_ ; if ( target os . compare To Ignore Case ( Mobile Util . IOS ) == NUM_ || target os . compare To Ignore Case ( Mobile Util . QNX ) == NUM_ ) { ret += STR_ ; } ret += STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ + class Name + STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ + device name + STR_ ; ret += STR_ + target os + STR_ ; ret += STR_ + target os + STR_ ; ret += STR_ + os version + STR_ ; if ( ( target os . compare To Ignore Case ( Mobile Util . MAC ) == NUM_ ) || ( target os . compare To Ignore Case ( Mobile Util . WIN ) == NUM_ ) ) { if ( adl extras Xscreen DPI == - NUM_ ) { ret += STR_ ; } else { ret += STR_ ; } } else if ( ( target os . compare To Ignore Case ( Mobile Util . ANDROID ) == NUM_ ) || ( target os . compare To Ignore Case ( Mobile Util . IOS ) == NUM_ ) ) { if ( ( device name . compare To Ignore Case ( Mobile Util . MAC ) == NUM_ ) || ( device name . compare To Ignore Case ( Mobile Util . WIN ) == NUM_ ) ) { if ( adl extras Xscreen DPI == - NUM_ ) { ret += STR_ ; } else { ret += STR_ ; } } else { ret += STR_ + Integer . to String ( Mobile Util . get Device Density ( device name ) ) + STR_ ; } } else { ret += STR_ + Integer . to String ( Mobile Util . get Device Density ( device name ) ) + STR_ ; } ret += STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ ; ret += STR_ + run id + STR_ ; ret += STR_ + exclude File . get Name ( ) + STR_ ; for ( i = NUM_ ; i < Array . get Length ( Mobile Util . DEVICES USING SDCARD ) ; ++ i ) { if ( device name . compare To Ignore Case ( Mobile Util . DEVICES USING SDCARD [ i ] ) == NUM_ ) { ret += STR_ + Mobile Util . SDCARD DIR + STR_ ; ret += STR_ ; } } if ( target os . compare To Ignore Case ( Mobile Util . IOS ) == NUM_ ) { ret += STR_ ; ret += STR_ ; } if ( target os . compare To Ignore Case ( Mobile Util . QNX ) == NUM_ ) { ret += STR_ ; ret += STR_ ; } ret += STR_ ; ret += STR_ ; ret += STR_ ; return ret ; }
public Attrib Key on Any Element ( ) { return on Element ( El Key . wildcard ( ns ) ) ; }
public static double dchisq ( double x ) { if ( x == NUM_ ) return Double . POSITIVE INFINITY ; double xh = Math . sqrt ( x ) ; return dnorm ( xh ) / xh ; }
private int measure Child Collapse Margins ( View child , int parent Width Measure Spec , int width Used , int parent Height Measure Spec , int height Used , int [ ] collapsing Margins ) { final Margin Layout Params lp = ( Margin Layout Params ) child . get Layout Params ( ) ; final int left Diff = lp . left Margin - collapsing Margins [ NUM_ ] ; final int right Diff = lp . right Margin - collapsing Margins [ NUM_ ] ; final int left Margin = Math . max ( NUM_ , left Diff ) ; final int right Margin = Math . max ( NUM_ , right Diff ) ; final int h Margins = left Margin + right Margin ; collapsing Margins [ NUM_ ] = Math . max ( NUM_ , - left Diff ) ; collapsing Margins [ NUM_ ] = Math . max ( NUM_ , - right Diff ) ; final int child Width Measure Spec = get Child Measure Spec ( parent Width Measure Spec , get Padding Left ( ) + get Padding Right ( ) + h Margins + width Used , lp . width ) ; final int child Height Measure Spec = get Child Measure Spec ( parent Height Measure Spec , get Padding Top ( ) + get Padding Bottom ( ) + lp . top Margin + lp . bottom Margin + height Used , lp . height ) ; child . measure ( child Width Measure Spec , child Height Measure Spec ) ; return child . get Measured Width ( ) + h Margins ; }
public synchronized boolean is Empty ( ) { return index . is Empty ( ) ; }
private void oops ( String what , int lineno , int override , Throwable t ) throws Configuration Exception { Error Descriptor error = new Error Descriptor ( lineno , override , what , location , t ) ; throw Configuration Exception ( new Configuration Exception ( error . to String ( ) , t ) , Collections . singleton List ( error ) ) ; throw new Assertion Error ( STR_ + STR_ ) ; }
private static byte expected Norm ( final Classic Similarity sim , final int length , final float boost ) { return ( byte ) sim . encode Norm Value ( boost / ( ( float ) Math . sqrt ( length ) ) ) ; }
public static Class Delegate class Delegate ( ) { return database Class Delegate . get ( ) ; }
public Value predecessor ( ) { return predecessor . get ( ) ; }
public Period plus Days ( long days To Add ) { if ( days To Add == NUM_ ) { return this ; } return create ( years , months , Math . to Int Exact ( Math . add Exact ( days , days To Add ) ) ) ; }
public void shutdown And Wait Until Done ( ) { shutdown ( ) ; while ( true ) { synchronized ( end Signal ) { try { if ( ( combined State . get ( ) & NUM_ ) == NUM_ ) break ; end Signal . wait ( NUM_ ) ; } catch ( Interrupted Exception e ) { } } } }
@ Suppress Warnings ( STR_ ) public static < T > T class For Name ( final String preferred Class Name , final Class < ? extends T > default Class , final Class < T > shared Class Or Interface , final Class Loader class Loader ) { final Class Path Util Request Config request Config = new Class Path Util Request Config ( preferred Class Name , default Class , shared Class Or Interface , class Loader ) ; try { if ( cache . contains Key ( request Config ) ) { final Class < ? > cls = cache . get ( request Config ) ; return cls == null ? null : ( T ) cls . new Instance ( ) ; } if ( default Class != null && ! shared Class Or Interface . is Assignable From ( default Class ) ) { throw new Illegal Argument Exception ( ) ; } final boolean initialize = false ; final Class < ? > cls = Class . for Name ( preferred Class Name , initialize , class Loader ) ; if ( shared Class Or Interface . is Assignable From ( cls ) ) { if ( log . is Info Enabled ( ) ) { log . info ( STR_ + cls . get Canonical Name ( ) ) ; } cache . put ( request Config , cls ) ; return ( T ) cls . new Instance ( ) ; } log . warn ( cls . get Canonical Name ( ) + STR_ + shared Class Or Interface . get Canonical Name ( ) ) ; } catch ( Class Not Found Exception | Instantiation Exception | Illegal Access Exception e ) { if ( DEBUG ) { log . debug ( STR_ + preferred Class Name ) ; } } if ( default Class == null ) { cache . put ( request Config , null ) ; return null ; } try { if ( DEBUG ) { log . debug ( STR_ + default Class . get Canonical Name ( ) ) ; } cache . put ( request Config , default Class ) ; return ( T ) default Class . new Instance ( ) ; } catch ( Instantiation Exception | Illegal Access Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Parameterized . Parameters public static Collection < Object [ ] > configs ( ) { return Arrays . as List ( new Object [ ] [ ] { { STR_ , STR_ , STR_ , true } , { STR_ , STR_ , STR_ , true } , { STR_ , STR_ , STR_ , true } } ) ; }
public static boolean is Private ( int mod ) { return Modifier . is Private ( mod ) ; }
public Collection engine Generate CR Ls ( Input Stream in Stream ) throws CRL Exception { CRL crl ; List crls = new Array List ( ) ; while ( ( crl = engine Generate CRL ( in Stream ) ) != null ) { crls . add ( crl ) ; } return crls ; }
public static String join ( Char Sequence delimiter , Object [ ] tokens ) { String Builder sb = new String Builder ( ) ; boolean first Time = true ; for ( Object token : tokens ) { if ( first Time ) { first Time = false ; } else { sb . append ( delimiter ) ; } sb . append ( token ) ; } return sb . to String ( ) ; }
private String read Attribute Name ( boolean return Lower Case ) { skip Whitespace ( ) ; int c = find ( ATTRIBUTE NAME TERMINATORS ) ; String for Substring = return Lower Case ? input Lower Case : input ; String result = pos < c ? for Substring . substring ( pos , c ) : null ; pos = c ; return result ; }
public static < E > List < E > of ( E e 1 , E e 2 ) { List < E > list = new Array List < > ( ) ; list . add ( e 1 ) ; list . add ( e 2 ) ; return list ; }
@ Override public Trie optimize ( Trie orig ) { List < Char Sequence > cmds = orig . cmds ; List < Row > rows = new Array List < > ( ) ; List < Row > orows = orig . rows ; int remap [ ] = new int [ orows . size ( ) ] ; Arrays . fill ( remap , NUM_ ) ; for ( int j = orows . size ( ) - NUM_ ; j >= NUM_ ; j -- ) { if ( eat ( orows . get ( j ) , remap ) ) { remap [ j ] = NUM_ ; } } Arrays . fill ( remap , - NUM_ ) ; rows = remove Gaps ( orig . root , orows , new Array List < Row > ( ) , remap ) ; return new Trie ( orig . forward , remap [ orig . root ] , cmds , rows ) ; }
public Catcher [ ] catchers ( ) { Array List catchers = new Array List ( ) ; Basic Block . Catch c = to Catch ; while ( c != null ) { catchers . add ( new Catcher ( c ) ) ; c = c . next ; } return ( Catcher [ ] ) catchers . to Array ( new Catcher [ catchers . size ( ) ] ) ; }
public Token next Word ( ) { if ( ! has Next Word ( ) ) throw new Illegal State Exception ( STR_ ) ; int index Of Space = Math . min ( remaining . index Of ( STR_ ) , remaining . index Of ( STR_ ) ) ; if ( index Of Space == - NUM_ ) { index Of Space = content . length ( ) - current Position ; } Token token = new Token ( this , current Position , current Position + index Of Space ) ; step Forward ( index Of Space + NUM_ ) ; return token ; }
public static int define Tag ( int ifd Id , short tag Id ) { return ( tag Id & NUM_ ) | ( ifd Id << NUM_ ) ; }
public < T > List < T > list Scalar Items ( Section Key < T , Scalar Section < T > > key ) { List < T > result = Lists . new Array List ( ) ; for ( Scalar Section < T > section : get Sections ( key ) ) { result . add ( section . get Value ( ) ) ; } return result ; }
public String next Token ( ) throws No Such Element Exception { if ( pos < len && delim . index Of ( str . char At ( pos ) ) >= NUM_ ) { if ( ret Delims ) return str . substring ( pos , ++ pos ) ; while ( ++ pos < len && delim . index Of ( str . char At ( pos ) ) >= NUM_ ) ; } if ( pos < len ) { int start = pos ; while ( ++ pos < len && delim . index Of ( str . char At ( pos ) ) < NUM_ ) ; return str . substring ( start , pos ) ; } throw new No Such Element Exception ( ) ; }
public Accessible State [ ] to Array ( ) { if ( states == null ) { return new Accessible State [ NUM_ ] ; } else { Accessible State [ ] state Array = new Accessible State [ states . size ( ) ] ; for ( int i = NUM_ ; i < state Array . length ; i ++ ) { state Array [ i ] = ( Accessible State ) states . element At ( i ) ; } return state Array ; } }
public boolean is Same Hash ( Class Hash other ) { return Arrays . equals ( class Hash , other . class Hash ) ; }
@ Override public Iterator iterator ( ) { return new Struct Bag Iterator ( field Values Iterator ( ) ) ; }
protected byte [ ] engine Get Encoded ( ) { Algorithm Identifier hash Algorithm = new Algorithm Identifier ( Digest Factory . get OID ( current Spec . get Digest Algorithm ( ) ) , DER Null . INSTANCE ) ; MGF 1 Parameter Spec mgf Spec = ( MGF 1 Parameter Spec ) current Spec . get MGF Parameters ( ) ; Algorithm Identifier mask Gen Algorithm = new Algorithm Identifier ( PKCS Object Identifiers . id mgf 1 , new Algorithm Identifier ( Digest Factory . get OID ( mgf Spec . get Digest Algorithm ( ) ) , DER Null . INSTANCE ) ) ; P Source . P Specified p Source = ( P Source . P Specified ) current Spec . get P Source ( ) ; Algorithm Identifier p Source Algorithm = new Algorithm Identifier ( PKCS Object Identifiers . id p Specified , new DER Octet String ( p Source . get Value ( ) ) ) ; RSAESOAE Pparams oaep P = new RSAESOAE Pparams ( hash Algorithm , mask Gen Algorithm , p Source Algorithm ) ; try { return oaep P . get Encoded ( ASN 1 Encoding . DER ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( STR_ ) ; } }
public Set < Type > introduced Types ( ) { return Collections . empty Set ( ) ; }
public static final int parse Int ( char [ ] array , int start , int length ) throws Number Format Exception { if ( length == NUM_ ) { int result = array [ start ] - STR_ ; if ( result < NUM_ || result > NUM_ ) { throw new Number Format Exception ( STR_ ) ; } return result ; } else { return Integer . parse Int ( new String ( array , start , length ) ) ; } }
public static Structured Translation from Empty Output ( final Sentence source Sentence ) { return new Structured Translation ( source Sentence , STR_ , empty List ( ) , NUM_ , empty List ( ) , empty Map ( ) , NUM_ ) ; }
public String left Str ( String str , int length ) { return str . substring ( NUM_ , Math . min ( str . length ( ) , length ) ) ; }
private static List < String > lines To Write ( String path , Global global , List < Attribute > attributes , Class < ? > a Class ) throws No Such Field Exception , IO Exception { String [ ] class Identifier = new String [ ] { STR_ , STR_ , a Class . get Simple Name ( ) } ; boolean class Found = false ; verify Attributes ( a Class , attributes ) ; Hash Map < String , String > attribute Types = get Types ( a Class , attributes ) ; List < String > lines To Write = new Array List < String > ( ) ; List < String > lines = read File ( new File ( path ) ) ; if ( ! is Empty ( attributes ) ) { lines = add Import ( lines , a Class , J Map . class ) ; lines = add Target Classes Import ( lines , attributes , a Class ) ; } if ( ! is Null ( global ) ) lines = add Import ( lines , a Class , J Global Map . class ) ; if ( containts Accessors ( global , attributes ) ) { lines = add Import ( lines , a Class , J Map Accessor . class ) ; lines = add Import ( lines , a Class , J Map Accessors . class ) ; } for ( String line : lines ) { if ( contains All ( line , class Identifier ) ) { if ( global != null ) lines To Write . add ( to Annotation ( global ) ) ; class Found = true ; } if ( class Found && ! is Empty ( attributes ) ) { Attribute remove = null ; for ( Attribute attribute : attributes ) { String name = attribute . get Name ( ) ; String type = attribute Types . get ( name ) ; if ( contains All ( line , name , type ) && ! line . contains ( STR_ ) ) { lines To Write . add ( to Annotation ( attribute ) ) ; remove = attribute ; } } if ( remove != null ) attributes . remove ( remove ) ; } lines To Write . add ( line ) ; } return lines To Write ; }
protected List < Message > create Concurrent List ( ) { return Collections . synchronized List ( new Array List < Message > ( ) ) ; }
public Set key Set ( ) { return new Tree Set ( lib pathmap . key Set ( ) ) ; }
public synchronized Visual Item find Item ( Point p ) { Point 2 D p 2 = ( m itransform == null ? p : m itransform . transform ( p , m tmp Point ) ) ; if ( ! m queue . psorted ) { m queue . sort Picking Queue ( ) ; } for ( int i = m queue . psize ; -- i >= NUM_ ; ) { Visual Item vi = m queue . pitems [ i ] ; if ( ! vi . is Valid ( ) ) { continue ; } Renderer r = vi . get Renderer ( ) ; if ( r != null && vi . is Interactive ( ) && r . locate Point ( p 2 , vi ) ) { return vi ; } } return null ; }
public static Collection < Query Language > values ( ) { return Collections . unmodifiable List ( QUERY LANGUAGES ) ; }
public static java . sql . Timestamp now Timestamp ( ) { return get Timestamp ( System . current Time Millis ( ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
private boolean has Trigger Misfired ( Trigger trigger ) { long now = System . current Time Millis ( ) ; Date next Fire Time = trigger . get Next Fire Time ( ) ; if ( next Fire Time . get Time ( ) <= ( now - misfire Threshold ) ) { return true ; } return false ; }
private String next To Internal ( String excluded ) { int start = pos ; for ( ; pos < in . length ( ) ; pos ++ ) { char c = in . char At ( pos ) ; if ( c == STR_ || c == STR_ || excluded . index Of ( c ) != - NUM_ ) { return in . substring ( start , pos ) ; } } return in . substring ( start ) ; }
public static Complex [ ] convolve ( Complex [ ] x , Complex [ ] y ) { Complex [ ] a = new Complex [ NUM_ * x . length ] ; for ( int i = NUM_ ; i < x . length ; i ++ ) a [ i ] = x [ i ] ; for ( int i = x . length ; i < NUM_ * x . length ; i ++ ) a [ i ] = ZERO ; Complex [ ] b = new Complex [ NUM_ * y . length ] ; for ( int i = NUM_ ; i < y . length ; i ++ ) b [ i ] = y [ i ] ; for ( int i = y . length ; i < NUM_ * y . length ; i ++ ) b [ i ] = ZERO ; return cconvolve ( a , b ) ; }
private static String time Approx ( int hour , int min ) { int mm ; mm = min % NUM_ ; if ( ( mm == NUM_ ) || ( mm == NUM_ ) ) { return STR_ ; } else if ( mm == NUM_ ) { return STR_ ; } else if ( mm == NUM_ ) { return STR_ ; } else { return STR_ ; } }
public boolean is Abstract ( ) { return Modifier . is Abstract ( class . get Modifiers ( ) ) ; }
public boolean is Consistent ( ) { final Taxon Node root = get Root ( ) ; if ( root == null ) { m Reason = STR_ ; return false ; } for ( final Taxon Node node : m Nodes . values ( ) ) { if ( node . get Name ( ) == null ) { m Reason = STR_ + node . get Id ( ) + STR_ ; return false ; } if ( node . get Rank ( ) == null ) { m Reason = STR_ + node . get Id ( ) + STR_ ; return false ; } Taxon Node x = node ; final Hash Set < Taxon Node > seen = new Hash Set < > ( ) ; while ( x != null && x != root && ! seen . contains ( x ) ) { seen . add ( x ) ; x = x . get Parent ( ) ; } if ( x != root ) { m Reason = STR_ + node . get Id ( ) + STR_ ; return false ; } } return true ; }
@ Suppress Warnings ( STR_ ) private static < T extends Throwable > Runtime Exception throw Unchecked ( Throwable t ) throws T { throw ( T ) t ; }
public static java . lang . Class for Name ( java . lang . String class Name ) throws java . lang . Class Not Found Exception { class Name = class Name . replace ( STR_ , STR_ ) ; Class c = for Name Impl ( class Name ) ; if ( c == null ) { throw new Class Not Found Exception ( class Name ) ; } return c ; }
public static String read Fully ( final Reader reader ) throws IO Exception { try { final String Writer writer = new String Writer ( ) ; final char [ ] buffer = new char [ NUM_ ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - NUM_ ) { writer . write ( buffer , NUM_ , count ) ; } return writer . to String ( ) ; } finally { reader . close ( ) ; } }
public static String pad Right ( String s , int length ) { if ( s . length ( ) > length ) { throw new Runtime Exception ( s + STR_ + length + STR_ ) ; } String t = new String ( s ) ; for ( int i = NUM_ ; i < length - s . length ( ) ; i ++ ) { t += STR_ ; } return t ; }
public int size ( ) { return values . size ( ) ; }
public static Vector 3 max ( Vector 3 o 1 , Vector 3 o 2 ) { return new Vector 3 ( Math . max ( o 1 . x , o 2 . x ) , Math . max ( o 1 . y , o 2 . y ) , Math . max ( o 1 . z , o 2 . z ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
static File create Libs Directory ( Context context ) { File libs Directory = get Libs Directory ( context ) ; if ( ! libs Directory . is Directory ( ) && ! libs Directory . mkdirs ( ) ) { throw new Runtime Exception ( STR_ ) ; } return libs Directory ; }
public I Multi Point next ( ) { if ( stack . empty ( ) ) { throw new java . util . No Such Element Exception ( STR_ ) ; } Moment m = stack . peek ( ) ; advance ( ) ; return m . node . point ; }
public String format ( final double w ) { final String Builder sb = new String Builder ( ) ; format ( sb , w ) ; return sb . to String ( ) ; }
public static double dchisq Log ( double x , double ncp ) { if ( ncp == NUM_ ) return dchisq Log ( x ) ; double xh = Math . sqrt ( x ) ; double mean = Math . sqrt ( ncp ) ; return Math . log ( dnorm ( xh - mean ) + dnorm ( - xh - mean ) ) - Math . log ( NUM_ * xh ) ; }
public boolean are On Equivalent Host ( Internal Distributed Member member 1 , Internal Distributed Member member 2 ) { Set < Inet Address > equivalents 1 = get Equivalents ( member 1 . get Inet Address ( ) ) ; return equivalents 1 . contains ( member 2 . get Inet Address ( ) ) ; }
public Bitmap create Drag Bitmap ( View v , Atomic Integer expected Padding ) { Bitmap b ; int padding = expected Padding . get ( ) ; if ( v instanceof Text View ) { Drawable d = get Text View Icon ( ( Text View ) v ) ; Rect bounds = get Drawable Bounds ( d ) ; b = Bitmap . create Bitmap ( bounds . width ( ) + padding , bounds . height ( ) + padding , Bitmap . Config . ARGB 8888 ) ; expected Padding . set ( padding - bounds . left - bounds . top ) ; } else { b = Bitmap . create Bitmap ( v . get Width ( ) + padding , v . get Height ( ) + padding , Bitmap . Config . ARGB 8888 ) ; } m Canvas . set Bitmap ( b ) ; draw Drag View ( v , m Canvas , padding ) ; m Canvas . set Bitmap ( null ) ; return b ; }
private static final int table Size For ( int c ) { if ( c <= NUM_ ) return NUM_ ; int n = Integer . highest One Bit ( c - NUM_ ) << NUM_ ; return ( n >= MAXIMUM CAPACITY ) ? MAXIMUM CAPACITY : n ; }
public int size ( ) { return sentences . size ( ) ; }
private String give Text In Best Language ( String element Name ) { if ( m Element Map . contains Key ( element Name + m Requested Language ) ) { return m Element Map . get ( element Name + m Requested Language ) ; } else if ( m Element Map . contains Key ( element Name + DEFAULT LANGUAGE ) ) { return m Element Map . get ( element Name + DEFAULT LANGUAGE ) ; } else if ( m Element Map . contains Key ( element Name + m First Language ) ) { return m Element Map . get ( element Name + m First Language ) ; } else { return m Element Map . get ( element Name ) ; } }
public String prototype ( cp info constant pool [ ] ) { CONSTANT Utf 8 info cm , dm ; String s ; cm = ( CONSTANT Utf 8 info ) ( constant pool [ name index ] ) ; dm = ( CONSTANT Utf 8 info ) ( constant pool [ descriptor index ] ) ; s = Class File . access string ( access flags , STR_ ) ; if ( s . compare To ( STR_ ) != NUM_ ) s = s + STR_ ; return s + Class File . parse Desc ( dm . convert ( ) , STR_ ) + STR_ + cm . convert ( ) ; }
@ Override public boolean contains ( Object value ) { if ( value == null ) { return false ; } final Iterator it = new Step Iterator ( this , step Size ) ; while ( it . has Next ( ) ) { if ( compare Equal ( value , it . next ( ) ) ) { return true ; } } return false ; }
public String drop Car ( Car car , boolean is Manifest , boolean is Two Column Track ) { String Buffer buf = new String Buffer ( ) ; String [ ] format ; if ( is Manifest && ! is Two Column Track ) { format = Setup . get Drop Manifest Message Format ( ) ; } else if ( ! is Manifest && ! is Two Column Track ) { format = Setup . get Drop Switch List Message Format ( ) ; } else if ( is Manifest && is Two Column Track ) { format = Setup . get Drop Two Column By Track Manifest Message Format ( ) ; } else { format = Setup . get Drop Two Column By Track Switch List Message Format ( ) ; } boolean local = false ; if ( car . get Track ( ) == null ) { local = true ; } for ( String attribute : format ) { String s = get Car Attribute ( car , attribute , ! PICKUP , local ) ; buf . append ( s ) ; } return buf . to String ( ) ; }
private Proxy next Proxy ( ) { if ( user Specified Proxy != null ) { has Next Proxy = false ; return user Specified Proxy ; } if ( proxy Selector Proxies != null ) { while ( proxy Selector Proxies . has Next ( ) ) { Proxy candidate = proxy Selector Proxies . next ( ) ; if ( candidate . type ( ) != Proxy . Type . DIRECT ) { return candidate ; } } } has Next Proxy = false ; return Proxy . NO PROXY ; }
public static String rel Path ( String parent , String child ) { return rel Path ( Paths . get ( parent ) , Paths . get ( child ) ) ; }
public static String Set uri List To String Set ( List < URI > uris ) { String Set set = new String Set ( ) ; if ( uris != null && ! uris . is Empty ( ) ) { for ( URI uri : uris ) { set . add ( uri . to String ( ) ) ; } } return set ; }
public static String pad ( int padding ) { if ( padding > NUM_ ) { String Buffer sb = new String Buffer ( padding ) ; for ( int i = NUM_ ; i < padding ; i ++ ) { sb . append ( STR_ ) ; } return sb . to String ( ) ; } else { return STR_ ; } }
private static boolean clearance equals ( freert . rules . Clearance Matrix p cl matrix , int p layer 1 , int p layer 2 ) { if ( p layer 1 == p layer 2 ) { return true ; } for ( int i = NUM_ ; i < p cl matrix . get class count ( ) ; ++ i ) { for ( int j = i ; j < p cl matrix . get class count ( ) ; ++ j ) { if ( p cl matrix . value at ( i , j , p layer 1 ) != p cl matrix . value at ( i , j , p layer 2 ) ) { return false ; } } } return true ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( get Class ( ) != obj . get Class ( ) ) return false ; Ndef Message other = ( Ndef Message ) obj ; return Arrays . equals ( m Records , other . m Records ) ; }
protected static boolean has Encoded Tag Value ( Object obj , int tag Value ) { return ( obj instanceof byte [ ] ) && ( ( byte [ ] ) obj ) [ NUM_ ] == tag Value ; }
private Scope peek ( ) throws JSON Exception { if ( stack . is Empty ( ) ) { throw new JSON Exception ( STR_ ) ; } return stack . get ( stack . size ( ) - NUM_ ) ; }
public void terminate ( ) throws IO Exception { try { try { synchronized ( m Jobs ) { while ( m Busy || ! m Jobs . is Empty ( ) ) { m Jobs . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { Program State . set Abort ( ) ; } finally { shutdown ( ) ; } rethrow ( ) ; } finally { Program State . clear Abort ( ) ; try { synchronized ( m Queue Thread ) { while ( ! m Queue Done ) { m Queue Thread . wait ( NOT DONE SLEEP TIME ) ; } } } catch ( final Interrupted Exception e ) { } } }
public static boolean is Whitespace Nonline ( char c ) { return ! Reg Exp Utils . reset And Test ( regexp Not Whitespace Excluding Newline And Carriage Return , String . value Of ( c ) ) ; }
public static String to Comma Delimited String ( Collection c ) { if ( c . is Empty ( ) ) { throw new Illegal Argument Exception ( ) ; } String Buffer result = new String Buffer ( ) ; for ( Iterator i = c . iterator ( ) ; i . has Next ( ) ; ) { Object o = i . next ( ) ; result . append ( STR_ + o . to String ( ) ) ; } return result . substring ( NUM_ ) ; }
public static boolean is Console Present ( ) { return System . console ( ) != null ; }
public static java . lang . Integer value Of ( java . lang . String s , int radix ) throws java . lang . Number Format Exception { return new Integer ( parse Int ( s , radix ) ) ; }
public final int degree ( Coords d ) { return ( int ) Math . round ( ( NUM_ / Math . PI ) * radian ( d ) ) ; }
public boolean is Owner ( ) { return id != null && owner Id != null && id . equals ( owner Id ) ; }
public boolean has Thumbnails ( ) { return thumbnails != null && thumbnails . size ( ) > NUM_ ; }
@ Override public Column column ( int column Index ) { return column List . get ( column Index ) ; }
private static Charset to Charset ( String csn ) throws Unsupported Encoding Exception { require Non Null ( csn , STR_ ) ; try { return Charset . for Name ( csn ) ; } catch ( Illegal Charset Name Exception | Unsupported Charset Exception unused ) { throw new Unsupported Encoding Exception ( csn ) ; } }
private static Big Integer value Of ( int val [ ] ) { return ( val [ NUM_ ] > NUM_ ? new Big Integer ( val , NUM_ ) : new Big Integer ( val ) ) ; }
protected double compute Log Ceil ( double upper ) { double log Ceil ; if ( this . allow Negatives Flag ) { if ( upper > NUM_ ) { log Ceil = Math . log ( upper ) / LOG 10 VALUE ; log Ceil = Math . ceil ( log Ceil ) ; log Ceil = Math . pow ( NUM_ , log Ceil ) ; } else if ( upper < - NUM_ ) { log Ceil = Math . log ( - upper ) / LOG 10 VALUE ; log Ceil = Math . ceil ( - log Ceil ) ; log Ceil = - Math . pow ( NUM_ , - log Ceil ) ; } else { log Ceil = Math . ceil ( upper ) ; } } else { if ( upper > NUM_ ) { log Ceil = Math . log ( upper ) / LOG 10 VALUE ; log Ceil = Math . ceil ( log Ceil ) ; log Ceil = Math . pow ( NUM_ , log Ceil ) ; } else { log Ceil = Math . ceil ( upper ) ; } } return log Ceil ; }
@ Nullable public static Network Parameters from Pmt Protocol ID ( String pmt Protocol Id ) { if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID MAINNET ) ) { return Main Net Params . get ( ) ; } else if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID TESTNET ) ) { return Test Net 3 Params . get ( ) ; } else { return null ; } }
private E unlink First ( ) { Node < E > f = first ; if ( f == null ) return null ; Node < E > n = f . next ; E item = f . item ; f . item = null ; f . next = f ; first = n ; if ( n == null ) last = null ; else n . prev = null ; -- count ; not Full . signal ( ) ; return item ; }
public boolean contains ( final Local Time VALUE ) { return VALUE . is After ( get Start ( ) ) && VALUE . is Before ( get Stop ( ) ) ; }
private static Big Decimal days Plus Seconds ( Big Integer days , Big Decimal seconds ) { return seconds . add ( new Big Decimal ( days . multiply ( Big Integer . value Of ( NUM_ * NUM_ * NUM_ ) ) ) ) ; }
public boolean is Erased Type Arguments ( ) { return false ; }
protected < T extends Key Spec > T engine Get Key Spec ( Key key , Class < T > key Spec ) throws Invalid Key Spec Exception { DSA Params params ; try { if ( key instanceof java . security . interfaces . DSA Public Key ) { Class < ? > dsa Pub Key Spec = Class . for Name ( STR_ ) ; Class < ? > x 509 Key Spec = Class . for Name ( STR_ ) ; if ( dsa Pub Key Spec . is Assignable From ( key Spec ) ) { java . security . interfaces . DSA Public Key dsa Pub Key = ( java . security . interfaces . DSA Public Key ) key ; params = dsa Pub Key . get Params ( ) ; return key Spec . cast ( new DSA Public Key Spec ( dsa Pub Key . get Y ( ) , params . get P ( ) , params . get Q ( ) , params . get G ( ) ) ) ; } else if ( x 509 Key Spec . is Assignable From ( key Spec ) ) { return key Spec . cast ( new X 509 Encoded Key Spec ( key . get Encoded ( ) ) ) ; } else { throw new Invalid Key Spec Exception ( STR_ ) ; } } else if ( key instanceof java . security . interfaces . DSA Private Key ) { Class < ? > dsa Priv Key Spec = Class . for Name ( STR_ ) ; Class < ? > pkcs 8 Key Spec = Class . for Name ( STR_ ) ; if ( dsa Priv Key Spec . is Assignable From ( key Spec ) ) { java . security . interfaces . DSA Private Key dsa Priv Key = ( java . security . interfaces . DSA Private Key ) key ; params = dsa Priv Key . get Params ( ) ; return key Spec . cast ( new DSA Private Key Spec ( dsa Priv Key . get X ( ) , params . get P ( ) , params . get Q ( ) , params . get G ( ) ) ) ; } else if ( pkcs 8 Key Spec . is Assignable From ( key Spec ) ) { return key Spec . cast ( new PKCS 8 Encoded Key Spec ( key . get Encoded ( ) ) ) ; } else { throw new Invalid Key Spec Exception ( STR_ ) ; } } else { throw new Invalid Key Spec Exception ( STR_ ) ; } } catch ( Class Not Found Exception e ) { throw new Invalid Key Spec Exception ( STR_ + e . get Message ( ) ) ; } }
static String access string ( int af , String separator ) { boolean hasone = false ; String s = STR_ ; if ( ( af & ACC PUBLIC ) != NUM_ ) { s = STR_ ; hasone = true ; } if ( ( af & ACC PRIVATE ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC PROTECTED ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC STATIC ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC FINAL ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC SUPER ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC VOLATILE ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC TRANSIENT ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC INTERFACE ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC ABSTRACT ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC STRICT ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC ANNOTATION ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC ENUM ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } if ( ( af & ACC UNKNOWN ) != NUM_ ) { if ( hasone ) s = s + separator ; else hasone = true ; s = s + STR_ ; } return s ; }
private boolean is Period ( String period ) { return period . contains ( RANGE SEP ) ; }
public Collection make Confirmed Full Collection ( ) { Collection set = make Confirmed Collection ( ) ; set . add All ( Arrays . as List ( get Full Elements ( ) ) ) ; return set ; }
@ Target Api ( Build . VERSION CODES . ICE CREAM SANDWICH MR 1 ) private boolean needs Fallback Locale ( ) { if ( ! PACKAGE GOOGLE TTS . equals ( m Tts Engine ) || ( m Default Locale != null ) ) { return false ; } if ( m Tts == null ) { return false ; } final Set < String > features = m Tts . get Features ( m System Locale ) ; return ! ( ( ( features != null ) && features . contains ( Engine . KEY FEATURE EMBEDDED SYNTHESIS ) ) || ! is Not Available Status ( m Tts . is Language Available ( m System Locale ) ) ) ; }
@ Override public int count All ( ) { Long count = ( Long ) finder Cache . get Result ( FINDER PATH COUNT ALL , FINDER ARGS EMPTY , this ) ; if ( count == null ) { Session session = null ; try { session = open Session ( ) ; Query q = session . create Query ( SQL COUNT FOO ) ; count = ( Long ) q . unique Result ( ) ; finder Cache . put Result ( FINDER PATH COUNT ALL , FINDER ARGS EMPTY , count ) ; } catch ( Exception e ) { finder Cache . remove Result ( FINDER PATH COUNT ALL , FINDER ARGS EMPTY ) ; throw process Exception ( e ) ; } finally { close Session ( session ) ; } } return count . int Value ( ) ; }
public boolean is Sequential ( ) { return category . equals Ignore Case ( STR_ ) ; }
static public String format Bytes ( long bytes ) { double val = NUM_ ; String units = STR_ ; if ( bytes < NUM_ ) { val = bytes ; units = STR_ ; } else if ( bytes < NUM_ ) { val = ( bytes / NUM_ ) ; units = STR_ ; } else if ( bytes < NUM_ ) { val = ( bytes / NUM_ ) ; units = STR_ ; } else { val = ( bytes / NUM_ ) ; units = STR_ ; } Decimal Format df = new Decimal Format ( STR_ ) ; return df . format ( val ) + STR_ + units ; }
private void block ( ) { Thread t = Thread . current Thread ( ) ; int i = NUM_ ; synchronized ( this ) { if ( waiting Threads == null ) { if ( waiting Thread == null ) { waiting Thread = t ; } else { waiting Threads = new Array List < > ( ) ; waiting Threads . add ( waiting Thread ) ; waiting Threads . add ( t ) ; i = NUM_ ; waiting Thread = null ; } } else { i = waiting Threads . size ( ) ; waiting Threads . add ( t ) ; } } while ( ! finished ) { try { t . wait ( NUM_ ) ; } catch ( Exception e ) { Thread . yield ( ) ; } } synchronized ( this ) { Thread . interrupted ( ) ; if ( waiting Thread == t ) { waiting Thread = null ; } if ( waiting Threads != null ) { waiting Threads . remove ( i ) ; } } }
@ Nullable private static File find Manifest Directory ( @ Not Null Source Provider source Provider ) { File manifest File = source Provider . get Manifest File ( ) ; File manifest Dir = manifest File . get Parent File ( ) ; if ( manifest Dir != null ) { return manifest Dir ; } return null ; }
public Token match ( int tok ) throws Parse Exception { if ( Debug . parser Debug ) { Debug . println ( STR_ + tok ) ; } if ( tok > START && tok < END ) { if ( tok == ID ) { if ( ! starts Id ( ) ) throw new Parse Exception ( buffer + STR_ , ptr ) ; String id = get Next Id ( ) ; this . current Match = new Token ( ) ; this . current Match . token Value = id ; this . current Match . token Type = ID ; } else if ( tok == SAFE ) { if ( ! starts Safe Token ( ) ) throw new Parse Exception ( buffer + STR_ , ptr ) ; String id = ttoken Safe ( ) ; this . current Match = new Token ( ) ; this . current Match . token Value = id ; this . current Match . token Type = SAFE ; } else if ( tok == ID NO WHITESPACE ) { if ( ! starts Id No White Space ( ) ) throw new Parse Exception ( buffer + STR_ , ptr ) ; String id = get Next Id No White Space ( ) ; this . current Match = new Token ( ) ; this . current Match . token Value = id ; this . current Match . token Type = ID NO WHITESPACE ; } else { String nexttok = get Next Id ( ) ; Integer cur = current Lexer . get ( Utils . to Upper Case ( nexttok ) ) ; if ( cur == null || cur . int Value ( ) != tok ) throw new Parse Exception ( buffer + STR_ + nexttok , ptr ) ; this . current Match = new Token ( ) ; this . current Match . token Value = nexttok ; this . current Match . token Type = tok ; } } else if ( tok > END ) { char next = look Ahead ( NUM_ ) ; if ( tok == DIGIT ) { if ( ! is Digit ( next ) ) throw new Parse Exception ( buffer + STR_ , ptr ) ; this . current Match = new Token ( ) ; this . current Match . token Value = String . value Of ( next ) ; this . current Match . token Type = tok ; consume ( NUM_ ) ; } else if ( tok == ALPHA ) { if ( ! is Alpha ( next ) ) throw new Parse Exception ( buffer + STR_ , ptr ) ; this . current Match = new Token ( ) ; this . current Match . token Value = String . value Of ( next ) ; this . current Match . token Type = tok ; consume ( NUM_ ) ; } } else { char ch = ( char ) tok ; char next = look Ahead ( NUM_ ) ; if ( next == ch ) { consume ( NUM_ ) ; } else throw new Parse Exception ( buffer + STR_ + ch + STR_ + next + STR_ , ptr ) ; } return this . current Match ; }
private static boolean trusted ( Set set , Trust Verifier . Context ctx ) throws Remote Exception { return trusted ( set . iterator ( ) , ctx ) ; }
static public final float random ( float range ) { return random . next Float ( ) * range ; }
public E sample ( final Random rand ) { final double total = total Count ( ) ; if ( total <= NUM_ ) { throw new Runtime Exception ( String . format ( STR_ , total ) ) ; } double sum = NUM_ ; final double r = rand . next Double ( ) ; for ( final Map . Entry < E , Double > entry : entries . entry Set ( ) ) { final double count = entry . get Value ( ) ; final double frac = count / total ; sum += frac ; if ( r < sum ) { return entry . get Key ( ) ; } } throw new Illegal State Exception ( STR_ ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public String to String By Value ( ) { Int Array List the Keys = new Int Array List ( ) ; keys Sorted By Value ( the Keys ) ; String Buffer buf = new String Buffer ( ) ; buf . append ( STR_ ) ; int max Index = the Keys . size ( ) - NUM_ ; for ( int i = NUM_ ; i <= max Index ; i ++ ) { int key = the Keys . get ( i ) ; buf . append ( String . value Of ( key ) ) ; buf . append ( STR_ ) ; buf . append ( String . value Of ( get ( key ) ) ) ; if ( i < max Index ) buf . append ( STR_ ) ; } buf . append ( STR_ ) ; return buf . to String ( ) ; }
public int [ ] shuffle ( ) { int [ ] ans = Arrays . copy Of ( nums , nums . length ) ; for ( int i = NUM_ ; i < nums . length ; i ++ ) { swap ( ans , i , random . next Int ( i + NUM_ ) ) ; } return ans ; }
public static User Agent value Of ( String name ) { if ( name == null ) throw new Null Pointer Exception ( STR_ ) ; String [ ] elements = name . split ( STR_ ) ; if ( elements . length == NUM_ ) { Operating System operating System = Operating System . value Of ( elements [ NUM_ ] ) ; Browser browser = Browser . value Of ( elements [ NUM_ ] ) ; return new User Agent ( operating System , browser ) ; } throw new Illegal Argument Exception ( STR_ + name ) ; }
private String normalize ( String path , boolean discard Relative Prefix ) { path = Url Utils . canonicalize Path ( path , discard Relative Prefix ) ; int colon = path . index Of ( STR_ ) ; if ( colon != - NUM_ ) { int slash = path . index Of ( STR_ ) ; if ( slash == - NUM_ || colon < slash ) { path = STR_ + path ; } } return path ; }
public static byte [ ] as Unsigned Byte Array ( Big Integer value ) { byte [ ] bytes = value . to Byte Array ( ) ; if ( bytes [ NUM_ ] == NUM_ ) { byte [ ] tmp = new byte [ bytes . length - NUM_ ] ; System . arraycopy ( bytes , NUM_ , tmp , NUM_ , tmp . length ) ; return tmp ; } return bytes ; }
static public javax . swing . Combo Box Model < String > j Combo Box Model From List ( List < Decoder File > l ) { javax . swing . Default Combo Box Model < String > b = new javax . swing . Default Combo Box Model < String > ( ) ; for ( int i = NUM_ ; i < l . size ( ) ; i ++ ) { Decoder File r = l . get ( i ) ; b . add Element ( r . title String ( ) ) ; } return b ; }
public Optional < String > string Value ( ) { return Optional . empty ( ) ; }
public static URI append Query ( final URI uri , final Form query ) { Reject . if Null ( uri ) ; if ( query == null || query . is Empty ( ) ) { return uri ; } if ( uri . get Raw Query ( ) != null ) { query . from Query String ( uri . get Raw Query ( ) ) ; } try { return create ( uri . get Scheme ( ) , uri . get Raw User Info ( ) , uri . get Host ( ) , uri . get Port ( ) , uri . get Raw Path ( ) , query . to Query String ( ) , uri . get Raw Fragment ( ) ) ; } catch ( final URI Syntax Exception e ) { throw new Illegal State Exception ( e ) ; } }
public int direction ( Coords d ) { return ( int ) Math . round ( radian ( d ) / HEXSIDE ) % NUM_ ; }
private boolean needs Repaint After Blit ( ) { Component heavy Parent = get Parent ( ) ; while ( heavy Parent != null && heavy Parent . is Lightweight ( ) ) { heavy Parent = heavy Parent . get Parent ( ) ; } if ( heavy Parent != null ) { Component Peer peer = heavy Parent . get Peer ( ) ; if ( peer != null && peer . can Determine Obscurity ( ) && ! peer . is Obscured ( ) ) { return false ; } } return true ; }
public long time ( int i ) { long offset = NUM_ ; for ( int j = indices . length - NUM_ ; j >= NUM_ ; j -- ) { if ( i >= indices [ j ] ) { offset = offsets [ j ] ; break ; } } return offset + rtimes [ i ] ; }
private boolean is Abandoned ( ) { return instance Load Id != active Load Id . get ( ) ; }
private void syntax ( String what ) throws Configuration Exception { oops ( STR_ + what + STR_ + describe Current Token ( ) ) ; }
@ Override public String rest ( ) { return document . substring ( cursor ) ; }
public int size ( ) { return names . size ( ) ; }
public boolean is Expired ( final Date date ) { if ( date == null ) { throw new Illegal Argument Exception ( STR_ ) ; } return ( cookie Expiry Date != null && cookie Expiry Date . get Time ( ) <= date . get Time ( ) ) ; }
@ Override public final String to String Max Decimal Digits ( int after Decimal Point ) { String Buffer text = new String Buffer ( to String No Weight ( after Decimal Point ) ) ; if ( m Weight != NUM_ ) { text . append ( STR_ + Utils . double To String ( m Weight , after Decimal Point ) + STR_ ) ; } return text . to String ( ) ; }
private int find Marker Segment Position ( Class cls , boolean first ) { if ( first ) { List Iterator iter = marker Sequence . list Iterator ( ) ; for ( int i = NUM_ ; iter . has Next ( ) ; i ++ ) { Marker Segment seg = ( Marker Segment ) iter . next ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } else { List Iterator iter = marker Sequence . list Iterator ( marker Sequence . size ( ) ) ; for ( int i = marker Sequence . size ( ) - NUM_ ; iter . has Previous ( ) ; i -- ) { Marker Segment seg = ( Marker Segment ) iter . previous ( ) ; if ( cls . is Instance ( seg ) ) { return i ; } } } return - NUM_ ; }
protected String build Unique Key Constraint Name ( String table Name , int serial Number , int maximum Name Length ) { String unique Key Name = STR_ + table Name + STR_ + serial Number ; if ( unique Key Name . length ( ) > maximum Name Length ) { unique Key Name = table Name + serial Number ; if ( unique Key Name . length ( ) > maximum Name Length ) { unique Key Name = Helper . remove All But Alpha Numeric To Fit ( table Name + serial Number , maximum Name Length ) ; if ( unique Key Name . length ( ) > maximum Name Length ) { String only Alpha Numeric Table Name = Helper . remove All But Alpha Numeric To Fit ( table Name , NUM_ ) ; String serial Name = String . value Of ( serial Number ) ; unique Key Name = Helper . shorten Strings By Removing Vowels To Fit ( only Alpha Numeric Table Name , serial Name , maximum Name Length ) ; if ( unique Key Name . length ( ) > maximum Name Length ) { String shortened Table Name = Helper . remove Vowels ( only Alpha Numeric Table Name ) ; unique Key Name = Helper . truncate ( shortened Table Name , maximum Name Length - serial Name . length ( ) ) + serial Name ; } } } } return unique Key Name ; }
protected Object eval ( String xpath , Q Name type ) { Object result ; try { result = m X Path . evaluate ( xpath , m Document , type ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; result = null ; } return result ; }
public static boolean is Empty ( Automaton a ) { if ( a . get Num States ( ) == NUM_ ) { return true ; } if ( a . is Accept ( NUM_ ) == false && a . get Num Transitions ( NUM_ ) == NUM_ ) { return true ; } if ( a . is Accept ( NUM_ ) == true ) { return false ; } Linked List < Integer > work List = new Linked List < > ( ) ; Bit Set seen = new Bit Set ( a . get Num States ( ) ) ; work List . add ( NUM_ ) ; seen . set ( NUM_ ) ; Transition t = new Transition ( ) ; while ( work List . is Empty ( ) == false ) { int state = work List . remove First ( ) ; if ( a . is Accept ( state ) ) { return false ; } int count = a . init Transition ( state , t ) ; for ( int i = NUM_ ; i < count ; i ++ ) { a . get Next Transition ( t ) ; if ( seen . get ( t . dest ) == false ) { work List . add ( t . dest ) ; seen . set ( t . dest ) ; } } } return true ; }
public static Number tanh ( Number a ) { return Math . tanh ( a . double Value ( ) ) ; }
public boolean is Autosome ( String ref Name ) { return m Autosomes . contains ( ref Name ) ; }
public static boolean has Token File ( File token File ) throws IO Exception { return has Token ( token File . get Parent File ( ) , token File . get Name ( ) ) ; }
private Char Property new Single ( final int ch ) { if ( has ( CASE INSENSITIVE ) ) { int lower , upper ; if ( has ( UNICODE CASE ) ) { upper = Character . to Upper Case ( ch ) ; lower = Character . to Lower Case ( upper ) ; if ( upper != lower ) return new Single U ( lower ) ; } else if ( ASCII . is Ascii ( ch ) ) { lower = ASCII . to Lower ( ch ) ; upper = ASCII . to Upper ( ch ) ; if ( lower != upper ) return new Single I ( lower , upper ) ; } } if ( is Supplementary ( ch ) ) return new Single S ( ch ) ; return new Single ( ch ) ; }
public Shape triangle right ( float x , float y , float height ) { m path . reset ( ) ; m path . move To ( x , y + height ) ; m path . line To ( x + height , y + height / NUM_ ) ; m path . line To ( x , y ) ; m path . close Path ( ) ; return m path ; }
public static boolean is Date In Range ( final Date date To Check , final Date start Date , final Date end Date ) { return ! ( ( start Date != null && date To Check . before ( start Date ) ) || ( end Date != null && date To Check . after ( end Date ) ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public Boolean check If Provider Supports Compression Operations ( Storage System storage System ) { String version Substring = null ; if ( storage System . check If Vmax 3 ( ) && storage System . get Using Smis 80 ( ) ) { try { Storage Provider storage Provider = db Client . query Object ( Storage Provider . class , storage System . get Active Provider URI ( ) ) ; String provider Version = storage Provider . get Version String ( ) ; version Substring = provider Version . split ( STR_ ) [ NUM_ ] ; } catch ( Exception e ) { log . error ( STR_ , storage System . get Label ( ) , storage System . get Id ( ) ) ; return false ; } } if ( Null Column Value Getter . is Null Value ( version Substring ) || ! ( Integer . parse Int ( version Substring ) > NUM_ ) ) { String err Msg = String . format ( STR_ , storage System . get Serial Number ( ) ) ; log . error ( err Msg ) ; return false ; } return true ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
private Pair < long [ ] , Array Modifiable DBI Ds > find Parent ( Relation < V > relation , Pair < long [ ] , Array Modifiable DBI Ds > child , T Custom Hash Map < long [ ] , List < Array Modifiable DBI Ds > > clusters Map ) { Number Vector child centroid = Projected Centroid . make ( child . first , relation , child . second ) ; Pair < long [ ] , Array Modifiable DBI Ds > result = null ; int result Cardinality = - NUM_ ; long [ ] child PV = child . first ; int child Cardinality = Bits Util . cardinality ( child PV ) ; for ( long [ ] parent PV : clusters Map . key Set ( ) ) { int parent Cardinality = Bits Util . cardinality ( parent PV ) ; if ( parent Cardinality >= child Cardinality ) { continue ; } if ( result Cardinality != - NUM_ && parent Cardinality <= result Cardinality ) { continue ; } long [ ] pv = Bits Util . and C Min ( child PV , parent PV ) ; if ( pv . equals ( parent PV ) ) { List < Array Modifiable DBI Ds > parent List = clusters Map . get ( parent PV ) ; for ( Array Modifiable DBI Ds parent : parent List ) { Number Vector parent centroid = Projected Centroid . make ( parent PV , relation , parent ) ; double d = weighted Distance ( child centroid , parent centroid , parent PV ) ; if ( d <= NUM_ * epsilon ) { result = new Pair < > ( parent PV , parent ) ; result Cardinality = parent Cardinality ; break ; } } } } return result ; }
private boolean check Updated ( FC Endpoint existing , FC Endpoint current ) { boolean updated = false ; if ( existing . get Inactive ( ) == true ) { existing . set Inactive ( false ) ; updated = true ; } if ( check Attribute Changed ( existing . get Remote Port Name ( ) , current . get Remote Port Name ( ) ) ) { existing . set Remote Port Name ( current . get Remote Port Name ( ) ) ; updated = true ; } if ( check Attribute Changed ( existing . get Remote Node Name ( ) , current . get Remote Node Name ( ) ) ) { existing . set Remote Node Name ( current . get Remote Node Name ( ) ) ; updated = true ; } if ( check Attribute Changed ( existing . get Remote Port Alias ( ) , current . get Remote Port Alias ( ) ) ) { existing . set Remote Port Alias ( current . get Remote Port Alias ( ) == null ? STR_ : current . get Remote Port Alias ( ) ) ; updated = true ; } if ( check Attribute Changed ( existing . get Fabric Id ( ) , current . get Fabric Id ( ) ) ) { existing . set Fabric Id ( current . get Fabric Id ( ) ) ; updated = true ; } if ( check Attribute Changed ( existing . get Fcid ( ) , current . get Fcid ( ) ) ) { existing . set Fcid ( current . get Fcid ( ) ) ; updated = true ; } if ( check Attribute Changed ( existing . get Switch Interface ( ) , current . get Switch Interface ( ) ) ) { existing . set Switch Interface ( current . get Switch Interface ( ) ) ; updated = true ; } if ( check Attribute Changed ( existing . get Switch Name ( ) , current . get Switch Name ( ) ) ) { existing . set Switch Name ( current . get Switch Name ( ) ) ; updated = true ; } if ( check Attribute Changed ( existing . get Switch Port Name ( ) , current . get Switch Port Name ( ) ) ) { existing . set Switch Port Name ( current . get Switch Port Name ( ) ) ; updated = true ; } if ( check Attribute Changed ( existing . get Fabric Wwn ( ) , current . get Fabric Wwn ( ) ) ) { existing . set Fabric Wwn ( current . get Fabric Wwn ( ) ) ; updated = true ; } return updated ; }
private static Set < String > parse Delimited Parameters ( Set < String > parameters To Parse ) { Set < String > parsed Parameters = new Linked Hash Set < > ( ) ; if ( parameters To Parse != null && ! parameters To Parse . is Empty ( ) ) { for ( String parameter To Parse : parameters To Parse ) { parsed Parameters . add All ( Arrays . as List ( parameter To Parse . split ( JSON API PARAM DELIMITER ) ) ) ; } } return parsed Parameters ; }
public Flux First Emitting < T > amb Additional Source ( Publisher < ? extends T > source ) { if ( array != null ) { int n = array . length ; @ Suppress Warnings ( STR_ ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM_ ] ; System . arraycopy ( array , NUM_ , new Array , NUM_ , n ) ; new Array [ n ] = source ; return new Flux First Emitting < > ( new Array ) ; } return null ; }
public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { return Arrays . copy Of ( queue , size ) ; } finally { lock . unlock ( ) ; } }
public static Map < String , Set < String > > parse ( final URI uri , boolean decode Query Param ) { Map < String , Set < String > > result = Collections . empty Map ( ) ; final String query = uri . get Raw Query ( ) ; if ( query != null && query . length ( ) > NUM_ ) { result = new Hash Map < > ( ) ; parse ( result , new Scanner ( query ) , null , decode Query Param ) ; } return result ; }
public int size ( ) { return messages . size ( ) ; }
public Instance instance ( int index ) { return m Instances . get ( index ) ; }
private static boolean instance Of Any ( Object o , Collection < Class > classes ) { for ( Class c : classes ) { if ( c . is Instance ( o ) ) return true ; } return false ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! ( obj instanceof Locale ) ) return false ; Base Locale other Base = ( ( Locale ) obj ) . base Locale ; if ( ! base Locale . equals ( other Base ) ) { return false ; } if ( locale Extensions == null ) { return ( ( Locale ) obj ) . locale Extensions == null ; } return locale Extensions . equals ( ( ( Locale ) obj ) . locale Extensions ) ; }
public int read ( Byte Buffer dst ) throws IO Exception { if ( ! dst . has Remaining ( ) ) return NUM_ ; if ( ! is Hand Shake Complete ( ) ) { if ( is Blocking ( ) ) { while ( ! is Hand Shake Complete ( ) ) { process Handshake ( ) ; } } else { process Handshake ( ) ; if ( ! is Hand Shake Complete ( ) ) { return NUM_ ; } } } int purged = read Remaining ( dst ) ; if ( purged != NUM_ ) return purged ; assert ( in Data . position ( ) == NUM_ ) ; in Data . clear ( ) ; if ( ! in Crypt . has Remaining ( ) ) in Crypt . clear ( ) ; else in Crypt . compact ( ) ; if ( is Blocking ( ) || read Engine Result . get Status ( ) == Status . BUFFER UNDERFLOW ) if ( socket Channel . read ( in Crypt ) == - NUM_ ) { return - NUM_ ; } in Crypt . flip ( ) ; unwrap ( ) ; int transfered = transfere To ( in Data , dst ) ; if ( transfered == NUM_ && is Blocking ( ) ) { return read ( dst ) ; } return transfered ; }
protected boolean is Executable Valid ( @ Not Null String executable ) { try { General Command Line command Line = new General Command Line ( ) ; command Line . set Exe Path ( executable ) ; Capturing Process Handler handler = new Capturing Process Handler ( command Line . create Process ( ) , Charset Toolkit . get Default System Charset ( ) ) ; Process Output result = handler . run Process ( NUM_ * NUM_ ) ; boolean timeout = result . is Timeout ( ) ; int exit Code = result . get Exit Code ( ) ; String stderr = result . get Stderr ( ) ; if ( timeout ) { LOG . warn ( STR_ + executable + STR_ ) ; } if ( exit Code != NUM_ ) { LOG . warn ( STR_ + executable + STR_ + exit Code ) ; } if ( ! stderr . is Empty ( ) ) { LOG . warn ( STR_ + executable + STR_ + stderr ) ; } return ! timeout && exit Code == NUM_ && stderr . is Empty ( ) ; } catch ( Throwable t ) { LOG . warn ( t ) ; return false ; } }
private static double expected Relative Error ( final int log 2 m ) { final long m = NUM_ << log 2 m ; return NUM_ / Math . sqrt ( m ) ; }
public static byte [ ] to Byte Array ( Object obj ) { int len = ( int ) size Of ( obj ) ; byte [ ] bytes = new byte [ len ] ; unsafe . copy Memory ( obj , NUM_ , bytes , Unsafe . ARRAY BYTE BASE OFFSET , bytes . length ) ; return bytes ; }
protected boolean is Sticky Drag ( ) { return false ; }
boolean approx Equals ( S 2 Cap other , double max Error ) { return ( axis . aequal ( other . axis , max Error ) && Math . abs ( height - other . height ) <= max Error ) || ( is Empty ( ) && other . height <= max Error ) || ( other . is Empty ( ) && height <= max Error ) || ( is Full ( ) && other . height >= NUM_ - max Error ) || ( other . is Full ( ) && height >= NUM_ - max Error ) ; }
List < Declaration > declarations ( ) { return Collections . unmodifiable List ( stack Map ) ; }
public static List < Date > parse Date List ( List < String > date List ) { List < Date > new List = new Array List < Date > ( ) ; if ( date List == null ) return new List ; for ( String value : date List ) new List . add ( parse Date ( value ) ) ; return new List ; }
private boolean close Internal ( Error Code error Code ) { assert ( ! Thread . holds Lock ( this ) ) ; synchronized ( this ) { if ( this . error Code != null ) { return false ; } if ( in . finished && out . finished ) { return false ; } this . error Code = error Code ; notify All ( ) ; } connection . remove Stream ( id ) ; return true ; }
public boolean is Static ( ) { return Modifier . is Static ( field . get Modifiers ( ) ) ; }
public boolean implies ( Permission p ) { return false ; }
private static String node Name ( String dir Name ) { if ( dir Name . char At ( NUM_ ) != STR_ ) return dir Name ; byte a [ ] = Base 64 . alt Base 64 To Byte Array ( dir Name . substring ( NUM_ ) ) ; String Buffer result = new String Buffer ( a . length / NUM_ ) ; for ( int i = NUM_ ; i < a . length ; ) { int high Byte = a [ i ++ ] & NUM_ ; int low Byte = a [ i ++ ] & NUM_ ; result . append ( ( char ) ( ( high Byte << NUM_ ) | low Byte ) ) ; } return result . to String ( ) ; }
private int num Digits ( int n ) { return ( int ) Math . log 10 ( n ) + NUM_ ; }
public static Class to Return Type ( Q Name result Type , Class optional Cast To Type ) { if ( optional Cast To Type != null ) { return optional Cast To Type ; } if ( result Type . equals ( X Path Constants . NODESET ) ) return Node List . class ; if ( result Type . equals ( X Path Constants . NODE ) ) return Node . class ; if ( result Type . equals ( X Path Constants . BOOLEAN ) ) return Boolean . class ; if ( result Type . equals ( X Path Constants . NUMBER ) ) return Double . class ; if ( result Type . equals ( X Path Constants . STRING ) ) return String . class ; return String . class ; }
private static int parse Int ( String str , int default Value ) { if ( str == null ) return default Value ; return Integer . parse Int ( str ) ; }
public boolean is Show Flowgraph Views ( ) { return m flowgraph Views Checkbox . is Selected ( ) ; }
protected boolean is Valid Identifier ( String identifier ) { if ( identifier . is Empty ( ) ) return false ; for ( int i = NUM_ ; i < identifier . length ( ) ; i ++ ) { if ( ! Character . is Digit ( identifier . char At ( i ) ) ) return false ; } return true ; }
private static Token Spec find Maximal Id Char Seq ( String line , int pos ) { int left = pos ; int rt = pos ; left = pos ; while ( Character . is Letter Or Digit ( line . char At ( left - NUM_ ) ) || line . char At ( left - NUM_ ) == STR_ ) { left -- ; } while ( Character . is Letter Or Digit ( line . char At ( rt ) ) || line . char At ( rt ) == STR_ ) { rt ++ ; } if ( left == rt ) { return null ; } else { return new Token Spec ( line . substring ( left , rt ) , left , rt ) ; } }
public Double Factor copy ( ) { return new Double Factor ( this ) ; }
public int search ( byte [ ] text , int start ) { int M = pattern . length ; int N = text . length ; int skip ; for ( int i = start ; i <= N - M ; i += skip ) { skip = NUM_ ; for ( int j = M - NUM_ ; j >= NUM_ ; j -- ) { if ( pattern [ j ] != text [ i + j ] ) { skip = Math . max ( NUM_ , j - right [ text [ i + j ] ] ) ; break ; } } if ( skip == NUM_ ) return i ; } return N ; }
static public Timestamp add Days ( Timestamp day , int offset ) { if ( offset == NUM_ ) { return day ; } if ( day == null ) { day = new Timestamp ( System . current Time Millis ( ) ) ; } Gregorian Calendar cal = new Gregorian Calendar ( ) ; cal . set Time ( day ) ; cal . set ( Calendar . HOUR OF DAY , NUM_ ) ; cal . set ( Calendar . MINUTE , NUM_ ) ; cal . set ( Calendar . SECOND , NUM_ ) ; cal . set ( Calendar . MILLISECOND , NUM_ ) ; if ( offset == NUM_ ) return new Timestamp ( cal . get Time In Millis ( ) ) ; cal . add ( Calendar . DAY OF YEAR , offset ) ; return new Timestamp ( cal . get Time In Millis ( ) ) ; }
public static final long crc 64 Long ( String in ) { if ( in == null || in . length ( ) == NUM_ ) { return NUM_ ; } return crc 64 Long ( get Bytes ( in ) ) ; }
public static String encode Param ( String param ) { try { return URL Encoder . encode ( param , STR_ ) ; } catch ( Unsupported Encoding Exception e ) { e . print Stack Trace ( ) ; return STR_ ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public Key min ( ) { if ( is Empty ( ) ) throw new No Such Element Exception ( STR_ ) ; return set . first ( ) ; }
@ Override public java . sql . Driver create Driver ( Properties properties ) throws SQL Exception { if ( properties != null && ! properties . is Empty ( ) ) { throw new SQL Exception ( ) ; } return driver ; }
public static String to Realm Qualified Authn Data ( String realm , String data ) { String realm Qualifed Data = data ; if ( realm != null && realm . length ( ) != NUM_ ) { realm Qualifed Data = realm . trim ( ) + IS Auth Constants . COLON + data . trim ( ) ; } return realm Qualifed Data ; }
static public boolean is Zero ( float value , float tolerance ) { return Math . abs ( value ) <= tolerance ; }
public static boolean is Template ( Page Context pc , Page Source ps , boolean default Value ) { try { return ! ( ps . load Page ( pc , false ) instanceof CI Page ) ; } catch ( Page Exception e ) { e . print Stack Trace ( ) ; return default Value ; } }
private boolean to Retransmit Final Response ( int T 2 ) { if ( -- retransmission Ticks Left == NUM_ ) { if ( NUM_ * prev Retransmission Ticks <= T 2 ) this . retransmission Ticks Left = NUM_ * prev Retransmission Ticks ; else this . retransmission Ticks Left = prev Retransmission Ticks ; this . prev Retransmission Ticks = retransmission Ticks Left ; return true ; } else return false ; }
public boolean is Subspace ( Subspace subspace ) { if ( this . dimensionality > subspace . dimensionality ) { return false ; } for ( int d = Bits Util . next Set Bit ( dimensions , NUM_ ) ; d >= NUM_ ; d = Bits Util . next Set Bit ( dimensions , d + NUM_ ) ) { if ( ! Bits Util . get ( subspace . dimensions , d ) ) { return false ; } } return true ; }
public static String guess Mime Type From Extension ( String extension ) { if ( extension == null || extension . is Empty ( ) ) { return null ; } return extension To Mime Type Map . get ( extension ) ; }
default Optional < Column Entity > single Result ( Column Query query ) throws Non Unique Result Exception , Null Pointer Exception { List < Column Entity > entities = find ( query ) ; if ( entities . is Empty ( ) ) { return Optional . empty ( ) ; } if ( entities . size ( ) == NUM_ ) { return Optional . of ( entities . get ( NUM_ ) ) ; } throw new Non Unique Result Exception ( STR_ + query ) ; }
public boolean is Done ( ) { return is Done . get ( ) ; }
public Dimension preferred Layout Size ( Container target ) { Dimension size ; synchronized ( this ) { check Container ( target ) ; check Requests ( ) ; size = new Dimension ( x Total . preferred , y Total . preferred ) ; } Insets insets = target . get Insets ( ) ; size . width = ( int ) Math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right , Integer . MAX VALUE ) ; size . height = ( int ) Math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom , Integer . MAX VALUE ) ; return size ; }
protected boolean veto Logging ( String user Name ) { return user Name != null && ( user Name . equals Ignore Case ( STR_ ) || user Name . equals Ignore Case ( STR_ ) || user Name . equals Ignore Case ( STR_ ) || user Name . equals Ignore Case ( STR_ ) ) ; }
public boolean has Content ( ) { return message Content != null || message Content Bytes != null ; }
public I Remote Tx State 0 status Tx ( final long tx Id ) throws Remote Transaction Not Found Exception { final Connect Options opts = new Connect Options ( mgr . get Base Service URL ( ) + STR_ + Long . to String ( tx Id ) ) ; opts . method = STR_ ; opts . add Request Param ( STR_ ) ; Jetty Response Listener response = null ; try { Remote Repository . check Response Code ( response = mgr . do Connect ( opts ) ) ; return single Tx Response ( response ) ; } catch ( Http Exception ex ) { switch ( ex . get Status Code ( ) ) { case NUM_ : throw new Remote Transaction Not Found Exception ( tx Id , mgr . get Base Service URL ( ) ) ; default : throw new Runtime Exception ( ex ) ; } } catch ( Exception t ) { throw new Runtime Exception ( t ) ; } finally { if ( response != null ) response . abort ( ) ; } }
public static void check Value Is Null ( Object value , Object name ) { if ( value != null ) { throw new Runtime Exception ( STR_ + name + STR_ ) ; } }
protected static String nonce Count To Hex ( int count ) { String str = Integer . to Hex String ( count ) ; String Buffer pad = new String Buffer ( ) ; if ( str . length ( ) < NUM_ ) { for ( int i = NUM_ ; i < NUM_ - str . length ( ) ; i ++ ) { pad . append ( STR_ ) ; } } return pad . to String ( ) + str ; }
public Map < String , Set < String > > evaluate ( Subject admin Subject , String realm , Subject subject , String resource Name , Map < String , Set < String > > environment ) throws Entitlement Exception { Subject Attributes Manager sac = Subject Attributes Manager . get Instance ( admin Subject , realm ) ; Set < String > names = new Hash Set < String > ( ) ; if ( ( property Values == null ) || property Values . is Empty ( ) ) { names . add ( property Name ) ; } else { names . add All ( property Values ) ; } Map < String , Set < String > > values = sac . get User Attributes ( subject , names ) ; Set < String > tmp = new Hash Set < String > ( ) ; if ( ( values != null ) && ! values . is Empty ( ) ) { for ( String k : values . key Set ( ) ) { tmp . add All ( values . get ( k ) ) ; } } Map < String , Set < String > > results = new Hash Map < String , Set < String > > ( ) ; results . put ( property Name , tmp ) ; return results ; }
private static int resize Stamp ( int n ) { return Integer . number Of Leading Zeros ( n ) | ( NUM_ << ( RESIZE STAMP BITS - NUM_ ) ) ; }
public static Vector 3 az El To Point ( double az , double el , Vector 3 result ) { if ( result == null ) { result = new Vector 3 ( ) ; } Matrix 3 mat = Matrix 3 . fetch Temp Instance ( ) ; mat . from Angle Axis ( az , Vector 3 . NEG UNIT Z ) ; Matrix 3 mat 2 = Matrix 3 . fetch Temp Instance ( ) ; mat 2 . from Angle Axis ( el , Vector 3 . UNIT X ) ; mat . multiply Local ( mat 2 ) ; result . set ( Vector 3 . UNIT Y ) ; mat . apply Post ( result , result ) ; Matrix 3 . release Temp Instance ( mat ) ; Matrix 3 . release Temp Instance ( mat 2 ) ; return ( result ) ; }
public Department depertment For Employee ( final Employee emp ) { Department dept = null ; final Date curr Date = new Date ( ) ; try { final Assignment emp Assignment = eis Common Service . get Latest Assignment For Employee By To Date ( emp . get Id ( ) , curr Date ) ; dept = emp Assignment . get Department ( ) ; return dept ; } catch ( final Null Pointer Exception ne ) { throw new Application Runtime Exception ( ne . get Message ( ) ) ; } catch ( final Exception e ) { throw new Application Runtime Exception ( STR_ + emp . get Name ( ) ) ; } }
@ Override public int hash Code ( ) { return super . hash Code ( ) ; }
public static String canonicalize Path ( String path , boolean discard Relative Prefix ) { int segment Start = NUM_ ; int deletable Segments = NUM_ ; for ( int i = NUM_ ; i <= path . length ( ) ; ) { int next Segment Start ; if ( i == path . length ( ) ) { next Segment Start = i ; } else if ( path . char At ( i ) == STR_ ) { next Segment Start = i + NUM_ ; } else { i ++ ; continue ; } if ( i == segment Start + NUM_ && path . region Matches ( segment Start , STR_ , NUM_ , NUM_ ) ) { path = path . substring ( NUM_ , segment Start ) + path . substring ( next Segment Start ) ; i = segment Start ; } else if ( i == segment Start + NUM_ && path . region Matches ( segment Start , STR_ , NUM_ , NUM_ ) ) { if ( deletable Segments > NUM_ || discard Relative Prefix ) { deletable Segments -- ; int prev Segment Start = path . last Index Of ( STR_ , segment Start - NUM_ ) + NUM_ ; path = path . substring ( NUM_ , prev Segment Start ) + path . substring ( next Segment Start ) ; i = segment Start = prev Segment Start ; } else { i ++ ; segment Start = i ; } } else { if ( i > NUM_ ) { deletable Segments ++ ; } i ++ ; segment Start = i ; } } return path ; }
@ Override public int port Remote ( ) { if ( s != null ) return s . get Port ( ) ; else return NUM_ ; }
protected boolean is Valid Fragment ( String fragment ) { if ( fragment == null ) { return true ; } return is Off ( NO FRAGMENTS ) ; }
public static String parse Signed Message ( Http Servlet Request request ) throws Illegal Argument Exception { String query String = request . get Query String ( ) ; String saml Request = HTTP Transport Utils . get Raw Query String Parameter ( query String , Saml Utils . SAML REQUEST PARAMETER ) ; String saml Response = HTTP Transport Utils . get Raw Query String Parameter ( query String , Saml Utils . SAML RESPONSE PARAMETER ) ; Validate . is True ( saml Request != null || saml Response != null ) ; String signature = HTTP Transport Utils . get Raw Query String Parameter ( query String , Saml Utils . SIGNATURE PARAMETER ) ; String sig Algo = HTTP Transport Utils . get Raw Query String Parameter ( query String , Saml Utils . SIGNATURE ALGORITHM PARAMETER ) ; String relay State = HTTP Transport Utils . get Raw Query String Parameter ( query String , Saml Utils . RELAY STATE PARAMETER ) ; if ( signature == null || sig Algo == null ) { return null ; } String Builder builder = new String Builder ( ) ; if ( saml Request != null ) { builder . append ( saml Request ) ; } else { builder . append ( saml Response ) ; } if ( relay State != null ) { builder . append ( STR_ ) ; builder . append ( relay State ) ; } builder . append ( STR_ ) ; builder . append ( sig Algo ) ; String signed Message = builder . to String ( ) ; log . debug ( STR_ , signed Message ) ; return signed Message ; }
public static String to Pem ( Object object ) throws Exception { String Writer sw = new String Writer ( ) ; PEM Writer pw = new PEM Writer ( sw ) ; pw . write Object ( object ) ; pw . flush ( ) ; return sw . to String ( ) ; }
private int min ( int a , int b ) { if ( a < b ) return a ; return b ; }
default long hash 64 ( String value ) { return hash 64 ( value . get Bytes ( ) ) ; }
public static boolean has Extension ( String extension ) { if ( extension == null || extension . is Empty ( ) ) { return false ; } return extension To Mime Type Map . contains Key ( extension ) ; }
public static String milli Sec To String ( long m S ) { long rem m S = ( long ) ( m S % NUM_ ) ; long rem sec = ( long ) ( ( m S / NUM_ ) % NUM_ ) ; long rem min = ( long ) ( ( m S / NUM_ ) % NUM_ ) ; long hr = ( long ) ( m S / NUM_ ) ; String m Sstr = zero Pad ( Long . to String ( rem m S ) , NUM_ ) ; String sec Str = zero Pad ( Long . to String ( rem sec ) , NUM_ ) ; String min Str = zero Pad ( Long . to String ( rem min ) , NUM_ ) ; return String . format ( STR_ , hr , min Str , sec Str , m Sstr ) ; }
public boolean can Create Rule ( Policy policy , String realm Name ) { get Svc Type Name To Actions Map ( policy , realm Name ) ; return ! required Resource Name Service . is Empty ( ) || ! not Required Resource Name Service . is Empty ( ) ; }
public static String jsdocify ( String comment ) { comment = jsdocify Proto Markdown Links ( comment ) ; comment = jsdocify Cloud Markdown Links ( comment ) ; return comment . trim ( ) ; }
public boolean is Final ( ) { return Modifier . is Final ( get Access Flags ( ) ) ; }
public boolean has Members ( ) { return members . size ( ) > NUM_ ; }
public static int prefix Length ( char [ ] s 1 , char [ ] s 2 ) { int len = NUM_ ; int max = Math . min ( s 1 . length , s 2 . length ) ; for ( int i = NUM_ ; i < max && s 1 [ i ] == s 2 [ i ] ; ++ i ) ++ len ; return len ; }
public static boolean is Mime Type Audio ( String mime Type ) { if ( mime Type . equals ( Const . Content Types . AUDIO MP 3 ) ) { return true ; } else if ( mime Type . equals ( Const . Content Types . AUDIO WAV ) ) { return true ; } return false ; }
private static final synchronized int next Pool Id ( ) { return ++ pool Number Sequence ; }
public static String [ ] read Font Names ( final Font Data font Data , final int mode ) { final Font File 2 current Font File = new Font File 2 ( font Data ) ; final int font Count = current Font File . get Font Count ( ) ; final String [ ] font Names = new String [ font Count ] ; for ( int i = NUM_ ; i < font Count ; i ++ ) { current Font File . set Selected Font Index ( i ) ; final Name current Name = new Name ( current Font File ) ; final String name ; switch ( mode ) { case Pdf Decoder Int . SUBSTITUTE FONT USING POSTSCRIPT NAME : name = current Name . get String ( Name . POSTSCRIPT NAME ) ; break ; case Pdf Decoder Int . SUBSTITUTE FONT USING FAMILY NAME : name = current Name . get String ( Name . FONT FAMILY NAME ) ; break ; case Pdf Decoder Int . SUBSTITUTE FONT USING FULL FONT NAME : name = current Name . get String ( Name . FULL FONT NAME ) ; break ; default : throw new Runtime Exception ( STR_ + mode + STR_ ) ; } if ( name == null ) { font Names [ i ] = null ; } else { font Names [ i ] = name . to Lower Case ( ) ; } } if ( font Data != null ) { font Data . close ( ) ; } return font Names ; }
public static String java Script Unescape ( String s ) { String Builder sb = new String Builder ( s . length ( ) ) ; for ( int i = NUM_ ; i < s . length ( ) ; ) { char c = s . char At ( i ) ; if ( c == STR_ ) { i = java Script Unescape Helper ( s , i + NUM_ , sb ) ; } else { sb . append ( c ) ; i ++ ; } } return sb . to String ( ) ; }
public boolean was URL Visited ( String url ) { return visited UR Ls != null && visited UR Ls . contains ( url ) ; }
private String Builder encode Product ( String Builder tokens ) { List Iterator it = product Tokens . list Iterator ( ) ; while ( it . has Next ( ) ) { tokens . append ( ( String ) it . next ( ) ) ; } return tokens ; }
public int flags ( ) { return pattern . flags ( ) ; }
protected int random Int Between Divisible ( int start , int end , int divisible ) { int divis Start = ( int ) Math . ceil ( ( start + NUM_ ) / ( double ) divisible ) ; int divis End = ( int ) Math . floor ( ( end - NUM_ ) / ( double ) divisible ) ; int divis Range = Math . max ( NUM_ , divis End - divis Start + NUM_ ) ; int r = random Int ( NUM_ + divis Range ) ; if ( r == NUM_ ) return start ; if ( r == NUM_ ) return end ; return ( r - NUM_ + divis Start ) * divisible ; }
public final Iterator < String > categories Iterator ( ) { return m Categories != null ? m Categories . iterator ( ) : null ; }
public synchronized Iterator < Abstract Setting > iterator ( ) { return settings . iterator ( ) ; }
public void purge Queue ( ) { f Dirty Regions . clear ( ) ; }
public boolean exists ( String path ) { try { Zip Entry entry = get Zip Entry ( path ) ; return entry != null ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } return false ; }
public boolean contains Base Type Only ( ) { return members . is Empty ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public static boolean is Valid Method Signature ( String sig ) { int len = sig . length ( ) ; if ( len == NUM_ ) return false ; int i = NUM_ ; char c = sig . char At ( i ++ ) ; if ( c != STR_ ) return false ; if ( i >= len ) return false ; while ( sig . char At ( i ) != STR_ ) { i = check Type Signature ( sig , i , len , false ) ; if ( i == - NUM_ ) return false ; if ( i >= len ) return false ; } ++ i ; i = check Type Signature ( sig , i , len , true ) ; return i == len ; }
public boolean accepts URL ( String url ) throws SQL Exception { if ( url == null ) { throw new SQL Exception ( STR_ ) ; } for ( String protocol : GDS Factory . get Supported Protocols ( ) ) { if ( url . starts With ( protocol ) ) return true ; } return false ; }
public int length ( ) { return regex . length ( ) ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( m listenees . contains Key ( event Name ) ) { return false ; } if ( m listenees . contains Key ( STR_ ) && ( event Name . compare To ( STR_ ) == NUM_ || event Name . compare To ( STR_ ) == NUM_ || event Name . compare To ( STR_ ) == NUM_ ) ) { return false ; } if ( ( m listenees . contains Key ( STR_ ) || m listenees . contains Key ( STR_ ) ) && ( event Name . compare To ( STR_ ) == NUM_ || event Name . compare To ( STR_ ) == NUM_ ) ) { return false ; } if ( m listenees . contains Key ( STR_ ) && ( event Name . compare To ( STR_ ) == NUM_ || event Name . compare To ( STR_ ) == NUM_ || event Name . compare To ( STR_ ) == NUM_ ) ) { return false ; } if ( event Name . compare To ( STR_ ) == NUM_ && ! ( m Filter instanceof Streamable Filter ) ) { return false ; } return true ; }
@ Suppress Warnings ( STR_ ) public static boolean supports ( Class cls ) { return get Mapper ( cls ) != null ; }
public static Metrics is Boring ( Layout Context layout Context , Char Sequence text , Text Paint paint , Text Direction Heuristic text Dir , Metrics metrics ) { char [ ] temp = Text Utils . obtain ( NUM_ ) ; int length = text . length ( ) ; boolean boring = true ; outer : for ( int i = NUM_ ; i < length ; i += NUM_ ) { int j = i + NUM_ ; if ( j > length ) j = length ; Text Utils . get Chars ( text , i , j , temp , NUM_ ) ; int n = j - i ; for ( int a = NUM_ ; a < n ; a ++ ) { char c = temp [ a ] ; if ( c == STR_ || c == STR_ || c >= FIRST RIGHT TO LEFT ) { boring = false ; break outer ; } } if ( text Dir != null && text Dir . is Rtl ( temp , NUM_ , n ) ) { boring = false ; break outer ; } } Text Utils . recycle ( temp ) ; if ( boring && text instanceof Spanned ) { Spanned sp = ( Spanned ) text ; Object [ ] styles = sp . get Spans ( NUM_ , length , Paragraph Style . class ) ; if ( styles . length > NUM_ ) { boring = false ; } } if ( boring ) { Metrics fm = metrics ; if ( fm == null ) { fm = new Metrics ( ) ; } Text Line line = Text Line . obtain ( ) ; line . set ( layout Context , paint , text , NUM_ , length , DIR LEFT TO RIGHT , DIRS ALL LEFT TO RIGHT , false , null ) ; fm . width = ( int ) Math . ceil ( line . metrics ( fm ) ) ; Text Line . recycle ( line ) ; return fm ; } else { return null ; } }
public double r ( ) { return Math . sqrt ( x * x + y * y ) ; }
public static void no Space ( String string ) throws JSON Exception { int i , length = string . length ( ) ; if ( length == NUM_ ) { throw new JSON Exception ( STR_ ) ; } for ( i = NUM_ ; i < length ; i += NUM_ ) { if ( Character . is Whitespace ( string . char At ( i ) ) ) { throw new JSON Exception ( STR_ + string + STR_ ) ; } } }
public Attribute create Attribute ( String name , String value ) { Attribute Field attribute Impl = new Attribute Field ( ) ; try { attribute Impl . set Name ( name ) ; attribute Impl . set Value Allow Null ( value ) ; } catch ( Sdp Exception s ) { s . print Stack Trace ( ) ; } return attribute Impl ; }
public static double magnitude ( double [ ] u ) { return Math . sqrt ( dot ( u , u ) ) ; }
public static boolean is Equal ( Color Space a , Color Space b ) { if ( ( a instanceof ICC Color Space ) && ( b instanceof ICC Color Space ) ) { ICC Color Space aicc = ( ICC Color Space ) a ; ICC Color Space bicc = ( ICC Color Space ) b ; ICC Profile ap = aicc . get Profile ( ) ; ICC Profile bp = bicc . get Profile ( ) ; return ap . equals ( bp ) ; } else { return a . equals ( b ) ; } }
public double distance ( I Multi Point imp ) { if ( imp . dimensionality ( ) != NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } double ox = imp . get Coordinate ( NUM_ ) ; double oy = imp . get Coordinate ( NUM_ ) ; return Math . sqrt ( ( ox - x ) * ( ox - x ) + ( oy - y ) * ( oy - y ) ) ; }
public static boolean is Auth N Assertion ( Assertion assertion ) { if ( assertion == null ) { return false ; } if ( ( ! assertion . is Time Valid ( ) ) || ( ! assertion . is Signature Valid ( ) ) ) { return false ; } Set statements = assertion . get Statement ( ) ; Statement statement = null ; Iterator iterator = statements . iterator ( ) ; while ( iterator . has Next ( ) ) { statement = ( Statement ) iterator . next ( ) ; if ( statement . get Statement Type ( ) == Statement . AUTHENTICATION STATEMENT ) { return true ; } } return false ; }
public int size ( ) { return set . size ( ) ; }
public static Charset to Charset ( Charset charset ) { return charset == null ? Charset . default Charset ( ) : charset ; }
public Object key ( ) { int dr = + NUM_ ; int dc = + NUM_ ; int off RL = + NUM_ ; int off RH = + NUM_ ; int off CL = + NUM_ ; int off CH = + NUM_ ; boolean r First = true ; int d = board [ NUM_ ] [ NUM_ ] ; if ( board [ NUM_ ] [ Max C ] < d ) { dr = + NUM_ ; dc = - NUM_ ; off CL = NUM_ ; off CH = NUM_ ; d = board [ NUM_ ] [ Max C ] ; r First = false ; } if ( board [ Max R ] [ Max C ] < d ) { dr = - NUM_ ; dc = - NUM_ ; off CL = NUM_ ; off CH = NUM_ ; off RL = NUM_ ; off RH = NUM_ ; d = board [ Max R ] [ Max C ] ; r First = true ; } if ( board [ Max R ] [ NUM_ ] < d ) { dr = - NUM_ ; dc = + NUM_ ; off RL = NUM_ ; off RH = NUM_ ; d = board [ Max R ] [ NUM_ ] ; r First = false ; } String Builder sb = new String Builder ( NUM_ ) ; if ( r First ) { for ( int r = - dr + off RL ; dr * r <= dr + off RH ; r += dr ) { for ( int c = - dc + off CL ; dc * c <= dc + off CH ; c += dc ) { sb . append ( board [ r ] [ c ] ) ; } } } else { for ( int c = - dc + off CL ; dc * c <= dc + off CH ; c += dc ) { for ( int r = - dr + off RL ; dr * r <= dr + off RH ; r += dr ) { sb . append ( board [ r ] [ c ] ) ; } } } return sb . to String ( ) ; }
public static Date Format to Date Time Format ( String date Time Format , Time Zone tz , Locale locale ) { Date Format df = null ; if ( Util Validate . is Empty ( date Time Format ) ) { df = Date Format . get Date Time Instance ( Date Format . SHORT , Date Format . MEDIUM , locale ) ; } else { df = new Simple Date Format ( date Time Format , locale == null ? Locale . get Default ( ) : locale ) ; } df . set Time Zone ( tz ) ; return df ; }
public static < K , V > Map < K , V > of ( K k 1 , V v 1 , K k 2 , V v 2 ) { Map map = of ( ) ; map . put ( k 1 , v 1 ) ; map . put ( k 2 , v 2 ) ; return map ; }
protected int extend ( final int required ) { final int capacity = Math . max ( required , capacity ( ) * NUM_ ) ; if ( log . is Info Enabled ( ) ) log . info ( STR_ + capacity + STR_ ) ; return capacity ; }
private static boolean too Many Digits Used ( double source , int scale ) { double dec Exp = Math . log 10 ( source ) ; return scale >= NUM_ || dec Exp + scale >= NUM_ ; }
public synchronized boolean read Request Immediate ( ) { if ( current Writers == NUM_ && writer Locks . size ( ) == NUM_ ) { ++ current Readers ; return true ; } return false ; }
public static Result Code value Of ( final int int Value ) { Result Code result = ELEMENTS . get ( int Value ) ; if ( result == null ) { result = new Result Code ( int Value , Localizable Message . raw ( STR_ + int Value + STR_ ) , true , Enum . UNKNOWN ) ; } return result ; }
public int hash Code ( ) { return uri . hash Code ( ) ; }
public List < Long > extract Ordered List ( ) { Long [ ] array = new Long [ heap . size ( ) ] ; for ( int i = heap . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { array [ i ] = heap . remove ( ) ; } return Arrays . as List ( array ) ; }
public void notify Value ( X Scrollbar obj , int type , int v , boolean is Adjusting ) { if ( log . is Loggable ( Platform Logger . Level . FINE ) ) { log . fine ( STR_ + obj + STR_ + v ) ; } int value = obj . get Value ( ) ; if ( obj == vsb ) { scroll Vertical ( v - value ) ; int old Sel = event Index ; int new Sel = event Index + v - value ; if ( mouse Dragged Out Vertically && ! is Selected ( new Sel ) ) { select Item ( new Sel ) ; event Index = new Sel ; repaint ( old Sel , event Index , PAINT ITEMS ) ; set Focus Index ( new Sel ) ; repaint ( PAINT FOCUS ) ; } } else if ( ( X Horizontal Scrollbar ) obj == hsb ) { scroll Horizontal ( v - value ) ; } }
public static String nano Sec To String ( long n S ) { long rem n S = ( long ) ( n S % NUM_ ) ; long rem u S = ( long ) ( ( n S / NUM_ ) % NUM_ ) ; long rem m S = ( long ) ( ( n S / NUM_ ) % NUM_ ) ; long sec = ( long ) ( n S / NUM_ ) ; String n Sstr = zero Pad ( Long . to String ( rem n S ) , NUM_ ) ; String u Sstr = zero Pad ( Long . to String ( rem u S ) , NUM_ ) ; String m Sstr = zero Pad ( Long . to String ( rem m S ) , NUM_ ) ; return String . format ( STR_ , sec , m Sstr , u Sstr , n Sstr ) ; }
@ Override public Range find Domain Bounds ( XY Dataset dataset ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; int series Count = dataset . get Series Count ( ) ; double lvalue ; double uvalue ; if ( dataset instanceof Vector XY Dataset ) { Vector XY Dataset vdataset = ( Vector XY Dataset ) dataset ; for ( int series = NUM_ ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM_ ; item < item Count ; item ++ ) { double delta = vdataset . get Vector X Value ( series , item ) ; if ( delta < NUM_ ) { uvalue = vdataset . get X Value ( series , item ) ; lvalue = uvalue + delta ; } else { lvalue = vdataset . get X Value ( series , item ) ; uvalue = lvalue + delta ; } minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } else { for ( int series = NUM_ ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM_ ; item < item Count ; item ++ ) { lvalue = dataset . get X Value ( series , item ) ; uvalue = lvalue ; minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } if ( minimum > maximum ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
private Parse Operation Set current Operations ( ) { synchronized ( mutex ) { return operation Set Queue . get Last ( ) ; } }
protected long next Long ( long n ) { Check . non Negative ( n ) ; if ( n <= Integer . MAX VALUE ) { return random . next Int ( ( int ) n ) ; } else { long bits ; long val ; do { bits = random . next Long ( ) & Long . MAX VALUE ; val = bits % n ; } while ( bits - val + ( n - NUM_ ) < NUM_ ) ; return val ; } }
public double next Double ( double alpha , double beta ) { double a = alpha ; double b = beta ; if ( a > NUM_ ) { if ( b > NUM_ ) return ( b 1 prs ( a , b , random Generator ) ) ; if ( b < NUM_ ) return ( NUM_ - b 01 ( b , a , random Generator ) ) ; if ( b == NUM_ ) { return ( Math . exp ( Math . log ( random Generator . raw ( ) ) / a ) ) ; } } if ( a < NUM_ ) { if ( b > NUM_ ) return ( b 01 ( a , b , random Generator ) ) ; if ( b < NUM_ ) return ( b 00 ( a , b , random Generator ) ) ; if ( b == NUM_ ) { return ( Math . exp ( Math . log ( random Generator . raw ( ) ) / a ) ) ; } } if ( a == NUM_ ) { if ( b != NUM_ ) return ( NUM_ - Math . exp ( Math . log ( random Generator . raw ( ) ) / b ) ) ; if ( b == NUM_ ) return ( random Generator . raw ( ) ) ; } return NUM_ ; }
public boolean only Letters Or Digits ( final @ Non Null Char Sequence input , final int num Chars To Check , final int start ) { if ( start < NUM_ || start > input . length ( ) ) { return false ; } for ( int i = NUM_ ; i < num Chars To Check ; i ++ ) { int position To Check = start + i ; if ( position To Check >= input . length ( ) ) { return false ; } char char To Check = input . char At ( position To Check ) ; if ( ! Character . is Letter Or Digit ( char To Check ) ) { return false ; } } return true ; }
public void request Seconds Until Password Expiration ( ) { operations . add ( Password Policy State Operation Type . GET SECONDS UNTIL PASSWORD EXPIRATION ) ; }
public List < Object > ids By DFS Finish Time ( boolean increasing ) { if ( ! initialized ) { throw new Illegal Argument Exception ( ) ; } int len = vertex List . size ( ) ; Object [ ] r = new Object [ len ] ; for ( Iterator < Vertex > all V = vertex List . iterator ( ) ; all V . has Next ( ) ; ) { Vertex vertex = all V . next ( ) ; int f = vertex . finish Time ; if ( increasing ) { r [ f - NUM_ ] = vertex . id ; } else { r [ len - f ] = vertex . id ; } } return Arrays . as List ( r ) ; }
private boolean is Valid File ( File file ) { return ( file != null && file . is Directory ( ) && file . can Read ( ) && file . can Write ( ) ) ; }
public static String diag Prefix For Lint ( String aspect Name , String rule Name ) { return String . format ( STR_ , aspect Name , rule Name ) ; }
public static String nice Store Type Name ( String storetype ) { if ( storetype . equals Ignore Case ( STR_ ) ) { return STR_ ; } else if ( storetype . equals Ignore Case ( STR_ ) ) { return STR_ ; } else { return storetype . to Upper Case ( Locale . ENGLISH ) ; } }
public Table sort On ( String ... column Names ) { Sort key = null ; Order order ; List < String > names = new Array List < > ( ) ; for ( String name : column Names ( ) ) { names . add ( name . to Upper Case ( ) ) ; } for ( String column Name : column Names ) { if ( names . contains ( column Name . to Upper Case ( ) ) ) { order = Order . ASCEND ; } else { String prefix = column Name . substring ( NUM_ , NUM_ ) ; column Name = column Name . substring ( NUM_ , column Name . length ( ) ) ; switch ( prefix ) { case STR_ : order = Order . ASCEND ; break ; case STR_ : order = Order . DESCEND ; break ; default : throw new Illegal State Exception ( STR_ + prefix + STR_ ) ; } } if ( key == null ) { key = first ( column Name , order ) ; } else { key . next ( column Name , order ) ; } } return sort On ( key ) ; }
public String to HTML ( ) { String Buffer buff = new String Buffer ( ) ; boolean passed = passed ( ) ; String title Tag = ( passed ) ? STR_ : STR_ ; String count Tag = ( passed ) ? STR_ : STR_ ; String url Name = name + STR_ ; Object [ ] args = { url Name , name } ; String href Name = Message Format . format ( HTML Constants . HREF , args ) ; Object [ ] params = { title Tag , href Name } ; buff . append ( STR_ ) ; buff . append ( Message Format . format ( HTML Constants . TBL ENTRY , params ) ) ; params [ NUM_ ] = count Tag ; params [ NUM_ ] = Integer . to String ( get Number Of Passes ( ) ) ; buff . append ( Message Format . format ( HTML Constants . TBL ENTRY , params ) ) ; params [ NUM_ ] = Integer . to String ( get Number Of Failed ( ) ) ; buff . append ( Message Format . format ( HTML Constants . TBL ENTRY , params ) ) ; params [ NUM_ ] = Integer . to String ( get Number Of Skipped ( ) ) ; buff . append ( Message Format . format ( HTML Constants . TBL ENTRY , params ) ) ; buff . append ( STR_ ) ; return buff . to String ( ) ; }
@ Override public final boolean equals ( Object p ob ) { if ( ! ( p ob instanceof Pla Point Rational ) ) return false ; Pla Point Rational other = ( Pla Point Rational ) p ob ; Big Integer det = Math Aux . determinant ( rp x , other . rp x , rp z , other . rp z ) ; if ( det . signum ( ) != NUM_ ) return false ; det = Math Aux . determinant ( rp y , other . rp y , rp z , other . rp z ) ; return ( det . signum ( ) == NUM_ ) ; }
public void validate Output ( ) throws Xml Parsing Exception , File Not Found Exception { Xml Parser . parse ( output File , new String [ ] { TTML SCHEMA } , TTML PACKAGES , Tt Eltype . class ) ; }
@ Override public Text Annotation next ( ) { if ( stack . is Empty ( ) && file Index >= file List . size ( ) ) throw new No Such Element Exception ( ) ; if ( stack Index >= stack . size ( ) ) { stack Index = NUM_ ; do { try { stack = get Text Annotations From File ( file List . get ( file Index ++ ) ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new No Such Element Exception ( e . get Message ( ) ) ; } } while ( stack . is Empty ( ) && file Index < file List . size ( ) ) ; } Text Annotation return Ta = stack . get ( stack Index ++ ) ; return return Ta ; }
public static byte [ ] read Fully ( Input Stream in ) throws IO Exception { try { return read Fully No Close ( in ) ; } finally { in . close ( ) ; } }
public static Mime Type from File Name ( final String file Name ) { final String in Lower Case Name = file Name . to Lower Case ( ) ; final String file Extension = get File Extension ( in Lower Case Name ) ; final Mime Type mime Type = file Extensions . get ( file Extension ) ; if ( mime Type != null ) { return mime Type ; } return BINARY ; }
public static boolean is Floating ( Type Mirror type ) { switch ( type . get Kind ( ) ) { case DOUBLE : case FLOAT : return true ; default : return false ; } }
private static Local Date Time add ( Local Date Time t , int val , String unit ) { Chrono Unit uu = CALENDAR UNITS . get ( unit ) ; if ( null == uu ) { throw new Illegal Argument Exception ( STR_ + unit ) ; } return t . plus ( val , uu ) ; }
public boolean does Not Distribute ( ) { return false ; }
public I Resource [ ] members ( final I Resource resource ) { Check . not Null ( resource , STR_ ) ; final List < I Resource > members = member Map . get ( resource ) ; if ( members == null ) { return new I Resource [ NUM_ ] ; } return members . to Array ( new I Resource [ members . size ( ) ] ) ; }
public int next Int ( int n , double p ) { if ( n * Math . min ( p , NUM_ - p ) <= NUM_ ) throw new Illegal Argument Exception ( ) ; return generate Binomial ( n , p ) ; }
public java . lang . String intern ( ) { int off = str . index Of ( this ) ; if ( off > - NUM_ ) { return str . get ( off ) ; } str . add ( this ) ; return this ; }
public boolean is Shutdown ( ) { return shutdown . get ( ) ; }
private boolean backtrack For Monotone With Previous ( Featurizable < I String , String > f ) { int index Left Current Phrase = f Start ( f ) - NUM_ ; if ( index Left Current Phrase < NUM_ ) { return ( f . prior == null ) ; } else if ( f . prior == null ) { return false ; } if ( f Start ( f ) < f Start ( f . prior ) ) return false ; int index Right Previous Phrase = f End ( f . prior ) + NUM_ ; if ( index Right Previous Phrase - NUM_ == index Left Current Phrase ) return true ; Coverage Set f Coverage = f . derivation . source Coverage ; for ( int i = index Right Previous Phrase ; i <= index Left Current Phrase ; ++ i ) { if ( ! f Coverage . get ( i ) ) return false ; } if ( f Coverage . next Clear Bit ( NUM_ ) > index Left Current Phrase && f Coverage . next Set Bit ( f End ( f ) + NUM_ ) < NUM_ ) return true ; Featurizable < I String , String > tmp f = f . prior ; tmp Coverage . clear ( ) ; boolean found Adj Phrase = false ; while ( true ) { if ( f End ( tmp f ) == index Left Current Phrase ) found Adj Phrase = true ; int f Start = f Start ( tmp f ) ; int f End = f End ( tmp f ) ; tmp Coverage . set ( f Start , f End + NUM_ ) ; if ( found Adj Phrase && contiguous ( tmp Coverage ) ) break ; if ( f Start > index Left Current Phrase ) return false ; tmp f = tmp f . prior ; if ( tmp f == null ) return false ; } return true ; }
public static boolean is Synchronized ( int mod ) { return Modifier . is Synchronized ( mod ) ; }
@ Suppress Warnings ( STR_ ) @ Override public List < T > read All ( ) { return find ( STR_ + entity Class . get Name ( ) ) ; }
public Char Char Map clone ( ) { char [ ] k = new char [ key . length ] , v = new char [ value . length ] ; System . arraycopy ( key , NUM_ , k , NUM_ , key . length ) ; System . arraycopy ( value , NUM_ , v , NUM_ , value . length ) ; return new Char Char Map ( k , v , f ) ; }
public int hash Code ( ) { return uid . hash Code ( ) ; }
public Server Socket create Server Socket ( int nport , int backlog , Inet Address bind Addr ) throws IO Exception { return create Server Socket ( nport , backlog , bind Addr , - NUM_ , ssl Config . is Enabled ( ) ) ; }
int last Item Displayed ( ) { int n = items In Window ( ) ; return ( Math . min ( items . size ( ) - NUM_ , ( vsb . get Value ( ) + n ) - NUM_ ) ) ; }
public static double incomplete Gamma ( double a , double x ) { double ans , ax , c , r ; if ( x <= NUM_ || a <= NUM_ ) return NUM_ ; if ( x > NUM_ && x > a ) return NUM_ - incomplete Gamma Complement ( a , x ) ; ax = a * Math . log ( x ) - x - ln Gamma ( a ) ; if ( ax < - MAXLOG ) return ( NUM_ ) ; ax = Math . exp ( ax ) ; r = a ; c = NUM_ ; ans = NUM_ ; do { r += NUM_ ; c *= x / r ; ans += c ; } while ( c / ans > MACHEP ) ; return ( ans * ax / a ) ; }
public Set < String > post Processing Fields ( ) { Set < String > fields = new Linked Hash Set < > ( ) ; query . for Each ( null ) ; sort . for Each ( null ) ; return fields ; }
public Object [ ] to Array ( ) { Object [ ] rv = new Object [ delegate . size ( ) ] ; delegate . copy Into ( rv ) ; return rv ; }
@ Override public Action execute ( Percept percept ) { kb . make Percept Sentence ( ( Agent Percept ) percept , t ) ; kb . tell Temporal Physics Sentences ( t ) ; Agent Position current = kb . ask Current Position ( t ) ; Set < Room > safe = kb . ask Safe Rooms ( t ) ; if ( kb . ask Glitter ( t ) ) { Set < Room > goals = new Linked Hash Set < Room > ( ) ; goals . add ( new Room ( NUM_ , NUM_ ) ) ; plan . add ( new Grab ( ) ) ; plan . add All ( plan Route ( current , goals , safe ) ) ; plan . add ( new Climb ( ) ) ; } Set < Room > unvisited = kb . ask Unvisited Rooms ( t ) ; if ( plan . is Empty ( ) ) { plan . add All ( plan Route ( current , Set Ops . intersection ( unvisited , safe ) , safe ) ) ; } if ( plan . is Empty ( ) && kb . ask Have Arrow ( t ) ) { Set < Room > possible Wumpus = kb . ask Possible Wumpus Rooms ( t ) ; plan . add All ( plan Shot ( current , possible Wumpus , safe ) ) ; } if ( plan . is Empty ( ) ) { Set < Room > not Unsafe = kb . ask Not Unsafe Rooms ( t ) ; plan . add All ( plan Route ( current , Set Ops . intersection ( unvisited , not Unsafe ) , safe ) ) ; } if ( plan . is Empty ( ) ) { Set < Room > start = new Linked Hash Set < Room > ( ) ; start . add ( new Room ( NUM_ , NUM_ ) ) ; plan . add All ( plan Route ( current , start , safe ) ) ; plan . add ( new Climb ( ) ) ; } Action action = plan . remove ( ) ; kb . make Action Sentence ( action , t ) ; t = t + NUM_ ; return action ; }
public String read Entire File Or Resource From Path ( String path ) { String ret = read Entire File From Path ( path ) ; if ( ret . is Empty ( ) ) { ret = read Entire Resource From Path ( path ) ; } return ret ; }
public static double next Pow Law ( double alpha , double cut , Random Engine random Generator ) { return cut * Math . pow ( random Generator . raw ( ) , NUM_ / ( alpha + NUM_ ) ) ; }
public String run Train ( Warrant w ) { String msg = null ; if ( w . get Run Mode ( ) != Warrant . MODE NONE ) { msg = w . get Run Mode Message ( ) ; set Status Text ( msg , Color . red , false ) ; return msg ; } msg = w . set Route ( NUM_ , null ) ; set Status Text ( msg , Warrant Table Model . my Gold , false ) ; if ( msg != null ) { set Status Text ( msg , Color . red , false ) ; return msg ; } msg = w . set Run Mode ( Warrant . MODE RUN , null , null , null , w . get Run Blind ( ) ) ; if ( msg != null ) { set Status Text ( msg , Color . red , false ) ; return msg ; } msg = w . check Start Block ( Warrant . MODE RUN ) ; set Status Text ( msg , Warrant Table Model . my Gold , false ) ; msg = w . check Route ( ) ; if ( msg != null ) { set Status Text ( msg , Warrant Table Model . my Green , false ) ; } return null ; }
public final double sample Sigma ( int n ) { synchronized ( lock ) { long count = count . get ( ) ; long last Count = last Std Count ; last Std Count = count ; double sum = sum . get ( ) ; double last Sum = last Std Sum ; last Std Sum = sum ; double sum Square = sum Square ; sum Square = NUM_ ; if ( count == last Count ) return NUM_ ; double avg = ( sum - last Sum ) / ( count - last Count ) ; double part = ( count - last Count ) * sum Square - sum * sum ; if ( part < NUM_ ) part = NUM_ ; double std = Math . sqrt ( part ) / ( count - last Count ) ; return scale * ( avg + n * std ) ; } }
private boolean has Primary ( ) { synchronized ( this ) { return this . primary State == OTHER PRIMARY NOT HOSTING || this . primary State == OTHER PRIMARY HOSTING || this . primary State == IS PRIMARY HOSTING ; } }
public boolean is ( int type , String lexeme ) { return this . type == type && text Count == lexeme . length ( ) && lexeme . equals ( get Lexeme ( ) ) ; }
public boolean base Is Left To Right ( ) { return bidi Base . base Is Left To Right ( ) ; }
private boolean compute Any Visible ( Viewer viewer , Object [ ] elements ) { boolean element Found = false ; for ( int i = NUM_ ; i < elements . length && ! element Found ; i ++ ) { Object element = elements [ i ] ; element Found = is Element Visible ( viewer , element ) ; } return element Found ; }
public List < String > on Tab Complete ( Luck Perms Plugin plugin , Sender sender , List < String > args ) { return Collections . empty List ( ) ; }
@ Override public int hash Code ( ) { return subeffects . hash Code ( ) ; }
private static String next Graph File Name ( Body b , String base Name ) throws java . io . IO Exception { File dir = make Directory If Missing ( b ) ; final String prefix = dir . to String ( ) + File . separator Char + base Name ; File file = null ; int file Number = NUM_ ; do { file = new File ( prefix + file Number + Dot Graph . DOT EXTENSION ) ; file Number ++ ; } while ( file . exists ( ) ) ; return file . to String ( ) ; }
private void block If Necessary Until Cleaned ( ) throws Space Cleaned Exception , Interrupted Exception { if ( is Cleaned ) { if ( Thread . holds Lock ( cleaned Lock ) ) return ; synchronized ( cleaned Lock ) { long CLEAN TIMEOUT = NUM_ * NUM_ ; while ( is Cleaned ) { cleaned Lock . wait ( CLEAN TIMEOUT ) ; if ( is Cleaned ) throw new Space Cleaned Exception ( get Service Name ( ) , STR_ + CLEAN TIMEOUT + STR_ + get Service Name ( ) ) ; } } } }
public boolean is Allow Create ( ) { if ( allow Create == null ) { return false ; } return allow Create . boolean Value ( ) ; }
@ Override public Inet Address address Local ( ) { if ( local Addr == null ) { try { local Addr = Inet Address . get By Name ( get Local Host ( ) ) ; } catch ( Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } } return local Addr ; }
public Float Column log N ( ) { Float Column new Column = Float Column . create ( name ( ) + STR_ , size ( ) ) ; for ( float value : this ) { new Column . add ( ( float ) Math . log ( value ) ) ; } return new Column ; }
public double angle approx ( Pla Vector Int p other ) { double result = Math . acos ( cos angle ( p other ) ) ; if ( side of ( p other ) == Pla Side . ON THE LEFT ) { result = - result ; } return result ; }
public long time Millis ( ) { return ( ( perf . high Res Counter ( ) * TO MILLISECONDS ) / TICKS PER SECOND ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + m Seed Default + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override public Range find Range Bounds ( XY Dataset dataset ) { if ( dataset == null ) { return null ; } double min = Double . POSITIVE INFINITY ; double max = Double . NEGATIVE INFINITY ; Table XY Dataset d = ( Table XY Dataset ) dataset ; int item Count = d . get Item Count ( ) ; for ( int i = NUM_ ; i < item Count ; i ++ ) { double [ ] stack Values = get Stack Values ( ( Table XY Dataset ) dataset , d . get Series Count ( ) , i ) ; min = Math . min ( min , stack Values [ NUM_ ] ) ; max = Math . max ( max , stack Values [ NUM_ ] ) ; } if ( min == Double . POSITIVE INFINITY ) { return null ; } return new Range ( min , max ) ; }
public static boolean is Protected ( int mod ) { return Modifier . is Protected ( mod ) ; }
private static int length Of Path ( Path 2 D . Float path ) { Flattening Path Iterator f = new Flattening Path Iterator ( path . get Path Iterator ( null ) , NUM_ ) ; double sum = NUM_ ; float x 1 , x 2 , y 1 , y 2 ; float [ ] coords = new float [ NUM_ ] ; f . current Segment ( coords ) ; x 1 = coords [ NUM_ ] ; y 1 = coords [ NUM_ ] ; f . next ( ) ; do { f . current Segment ( coords ) ; f . next ( ) ; x 2 = coords [ NUM_ ] ; y 2 = coords [ NUM_ ] ; sum += Math . hypot ( x 2 - x 1 , y 2 - y 1 ) ; x 1 = x 2 ; y 1 = y 2 ; } while ( ! f . is Done ( ) ) ; return ( int ) sum ; }
public static boolean starts With Http Or Https ( String uri ) { if ( uri == null ) { return false ; } String lowercase Uri = uri . to Lower Case ( Locale . US ) ; return lowercase Uri . starts With ( STR_ ) || lowercase Uri . starts With ( STR_ ) ; }
public boolean is Connected ( ) { return m Connection != null ; }
public static String slurp Reader ( Reader reader ) { Buffered Reader r = new Buffered Reader ( reader ) ; String Buffer buff = new String Buffer ( ) ; try { char [ ] chars = new char [ SLURPBUFFSIZE ] ; while ( true ) { int amount Read = r . read ( chars , NUM_ , SLURPBUFFSIZE ) ; if ( amount Read < NUM_ ) { break ; } buff . append ( chars , NUM_ , amount Read ) ; } r . close ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( ) ; } return buff . to String ( ) ; }
private int match Next Header ( int i , String key ) { int size = header Size ; int length = key . length ( ) ; char [ ] key Buf = header Buffer ; char [ ] to Lower Ascii = to Lower Ascii ; for ( ; i < size ; i ++ ) { Char Segment header = header Keys [ i ] ; if ( header . length ( ) != length ) continue ; int offset = header . offset ( ) ; int j ; for ( j = NUM_ ; j < length ; j ++ ) { char a = key . char At ( j ) ; char b = key Buf [ offset + j ] ; if ( a == b ) { continue ; } else if ( to Lower Ascii [ a ] != to Lower Ascii [ b ] ) { break ; } } if ( j == length ) { return i ; } } return - NUM_ ; }
public static final byte [ ] inflate ( byte [ ] in ) throws IO Exception { Byte Array Output Stream out Stream = new Byte Array Output Stream ( EXPECTED COMPRESSION RATIO * in . length ) ; Inflater Input Stream in Stream = new Inflater Input Stream ( new Byte Array Input Stream ( in ) ) ; byte [ ] buf = new byte [ BUF SIZE ] ; while ( true ) { int size = in Stream . read ( buf ) ; if ( size <= NUM_ ) break ; out Stream . write ( buf , NUM_ , size ) ; } out Stream . close ( ) ; return out Stream . to Byte Array ( ) ; }
public static Number sinh ( Number a ) { return Math . sinh ( a . double Value ( ) ) ; }
protected static String resolve Snapshot Name ( Snapshot snapshot ) { String persisted Name = resolve Name ( snapshot , null ) ; if ( persisted Name != null ) return persisted Name ; File file = snapshot . get File ( ) ; if ( file == null ) return snapshot . to String ( ) ; String file Name = file . get Name ( ) ; Snapshot Category category = snapshot . get Category ( ) ; String name = STR_ + category . get Prefix ( ) + STR_ + file Name ; if ( category . is Snapshot ( file ) ) { String time Stamp = category . get Time Stamp ( file Name ) ; if ( time Stamp != null ) name = STR_ + category . get Prefix ( ) + STR_ + time Stamp ; } return name ; }
byte dir Type Forward ( ) { last Char = text . char At ( char Index ) ; if ( Character . is High Surrogate ( last Char ) ) { int code Point = Character . code Point At ( text , char Index ) ; char Index += Character . char Count ( code Point ) ; return Character . get Directionality ( code Point ) ; } char Index ++ ; byte dir Type = get Cached Directionality ( last Char ) ; if ( is Html ) { if ( last Char == STR_ ) { dir Type = skip Tag Forward ( ) ; } else if ( last Char == STR_ ) { dir Type = skip Entity Forward ( ) ; } } return dir Type ; }
private boolean is Valid ( Char Sequence text ) { for ( int i = NUM_ ; i < text . length ( ) ; i ++ ) { char c = text . char At ( i ) ; boolean valid = c == NUM_ || c == NUM_ || c == NUM_ || ( c >= NUM_ && c <= NUM_ ) || ( c >= NUM_ && c <= NUM_ ) ; if ( ! valid ) { return false ; } } return true ; }
public static long static Field Offset ( Field field ) { return UNSAFE . static Field Offset ( field ) ; }
private void invalid Byte ( int position , int count , int c ) throws Malformed Byte Sequence Exception { throw new Malformed Byte Sequence Exception ( f Formatter , f Locale , XML Message Formatter . XML DOMAIN , STR_ , new Object [ ] { Integer . to String ( position ) , Integer . to String ( count ) } ) ; }
@ Override public String model Name ( ) { return STR_ ; }
public boolean is Rollover ( ) { Boolean rollover = ( Boolean ) get Client Property ( STR_ ) ; if ( rollover != null ) { return rollover . boolean Value ( ) ; } return false ; }
public static boolean has Mime Type ( String mime Type ) { if ( mime Type == null || mime Type . is Empty ( ) ) { return false ; } return mime Type To Extension Map . contains Key ( mime Type ) ; }
public static Date parse Date ( String date Str ) { String format String = STR_ ; if ( date Str . length ( ) == NUM_ ) date Str = date Str . substring ( NUM_ , NUM_ ) ; if ( date Str . length ( ) == NUM_ ) format String = STR_ ; if ( date Str . length ( ) == NUM_ ) format String = STR_ ; Simple Date Format formatter = new Simple Date Format ( format String ) ; Parse Position pos = new Parse Position ( NUM_ ) ; return formatter . parse ( date Str , pos ) ; }
public void process ( List < Object > appear Attrs , long occur Time ) { if ( expired ) { throw new Illegal State Exception ( STR_ ) ; } switch ( status ) { case not sure : if ( occur Time < window . start Time ) { break ; } else if ( occur Time >= window . start Time && occur Time <= window . end Time ) { if ( expect Attrs . equals ( appear Attrs ) ) { status = Occur Status . occured ; } break ; } else { status = Occur Status . absent ; break ; } case occured : if ( occur Time > window . end Time ) { expired = true ; } break ; default : break ; } if ( status == Occur Status . absent ) { expired = true ; } }
public static String pad Right ( String s , int len , char pad ch ) { if ( s . length ( ) >= len ) { return s ; } else { String Builder sb = new String Builder ( ) ; int n = len - s . length ( ) ; sb . append ( s ) ; for ( int i = NUM_ ; i < n ; i ++ ) { sb . append ( pad ch ) ; } return sb . to String ( ) ; } }
private String read Value ( char delimiter , boolean resolve Entities , boolean throw On Resolve Failure , Value Context value Context ) throws IO Exception , Xml Pull Parser Exception { int start = position ; String Builder result = null ; if ( value Context == Value Context . TEXT && text != null ) { result = new String Builder ( ) ; result . append ( text ) ; } while ( true ) { if ( position >= limit ) { if ( start < position ) { if ( result == null ) { result = new String Builder ( ) ; } result . append ( buffer , start , position - start ) ; } if ( ! fill Buffer ( NUM_ ) ) { return result != null ? result . to String ( ) : STR_ ; } start = position ; } char c = buffer [ position ] ; if ( c == delimiter || ( delimiter == STR_ && ( c <= STR_ || c == STR_ ) ) || c == STR_ && ! resolve Entities ) { break ; } if ( c != STR_ && ( c != STR_ || value Context != Value Context . ATTRIBUTE ) && c != STR_ && c != STR_ && ( c != STR_ || value Context != Value Context . TEXT ) && ( c != STR_ || value Context != Value Context . ENTITY DECLARATION ) ) { is Whitespace &= ( c <= STR_ ) ; position ++ ; continue ; } if ( result == null ) { result = new String Builder ( ) ; } result . append ( buffer , start , position - start ) ; if ( c == STR_ ) { if ( ( position + NUM_ < limit || fill Buffer ( NUM_ ) ) && buffer [ position + NUM_ ] == STR_ ) { position ++ ; } c = ( value Context == Value Context . ATTRIBUTE ) ? STR_ : STR_ ; } else if ( c == STR_ ) { c = STR_ ; } else if ( c == STR_ ) { is Whitespace = false ; read Entity ( result , false , throw On Resolve Failure , value Context ) ; start = position ; continue ; } else if ( c == STR_ ) { if ( value Context == Value Context . ATTRIBUTE ) { check Relaxed ( STR_ ) ; } is Whitespace = false ; } else if ( c == STR_ ) { if ( ( position + NUM_ < limit || fill Buffer ( NUM_ ) ) && buffer [ position + NUM_ ] == STR_ && buffer [ position + NUM_ ] == STR_ ) { check Relaxed ( STR_ ) ; } is Whitespace = false ; } else if ( c == STR_ ) { throw new Xml Pull Parser Exception ( STR_ , this , null ) ; } else { throw new Assertion Error ( ) ; } position ++ ; result . append ( c ) ; start = position ; } if ( result == null ) { return string Pool . get ( buffer , start , position - start ) ; } else { result . append ( buffer , start , position - start ) ; return result . to String ( ) ; } }
private static String descriptor For Field Signature ( String signature ) { return signature . replace ( STR_ , STR_ ) ; }
public int check prefix ( final byte [ ] key , int depth ) { int max cmp = Math . min ( Math . min ( partial len , Node . MAX PREFIX LEN ) , key . length - depth ) ; int idx ; for ( idx = NUM_ ; idx < max cmp ; idx ++ ) { if ( partial [ idx ] != key [ depth + idx ] ) return idx ; } return idx ; }
public boolean has Routed Networks ( URI network Uri ) { return routed Networks != null && ! disable Routing && routed Networks . contains ( network Uri . to String ( ) ) ; }
public static Date parse Date ( String d ) throws Parse Exception { return parse Date ( d , DEFAULT DATE FORMATS ) ; }
protected boolean release ( Internal Distributed Member grantor , String service Name , boolean lock Batch , int lock Id ) { DM dm = get Distribution Manager ( ) ; D Lock Release Message msg = new D Lock Release Message ( ) ; msg . processor Id = get Processor Id ( ) ; msg . service Name = service Name ; msg . object Name = this . object Name ; msg . lock Batch = lock Batch ; msg . lock Id = lock Id ; msg . set Recipient ( grantor ) ; if ( grantor . equals ( dm . get Id ( ) ) ) { msg . set Sender ( grantor ) ; msg . process Locally ( dm ) ; } else { dm . put Outgoing ( msg ) ; } try { wait For Replies Uninterruptibly ( ) ; } catch ( Reply Exception e ) { e . handle As Unexpected ( ) ; } if ( this . reply == null ) return false ; return this . reply . reply Code == D Lock Release Reply Message . OK ; }
public double pdf ( double x ) { return this . TERM * Math . pow ( ( NUM_ + x * x / freedom ) , - ( freedom + NUM_ ) * NUM_ ) ; }
public T peek ( ) { if ( heap . size ( ) > NUM_ ) return heap . element At ( TOP ) ; else return null ; }
public static char [ ] utf 2 chars ( byte [ ] src , int sindex , int len ) { char [ ] dst = new char [ len ] ; int len 1 = utf 2 chars ( src , sindex , dst , NUM_ , len ) ; char [ ] result = new char [ len 1 ] ; System . arraycopy ( dst , NUM_ , result , NUM_ , len 1 ) ; return result ; }
public boolean is Highlight Enabled ( ) { for ( int i = NUM_ , size = m Data Sets . size ( ) ; i < size ; i ++ ) { T set = m Data Sets . get ( i ) ; if ( ! set . is Highlight Enabled ( ) ) { return false ; } } return true ; }
@ Override public Enumeration < Option > list Options ( ) { String string = STR_ ; Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( string , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public Enumeration oids ( ) { return ordering . elements ( ) ; }
public Value Number for Number ( int number ) { if ( number >= get Num Values Allocated ( ) ) { throw new Illegal Argument Exception ( STR_ + number + STR_ ) ; } return allocated Value List . get ( number ) ; }
public Map < Integer , Set < String > > show Topology ( ) throws Network Device Controller Exception { Map < Integer , Set < String > > peer Devices Map = new Hash Map < Integer , Set < String > > ( ) ; SSH Prompt [ ] prompts = { SSH Prompt . POUND , SSH Prompt . GREATER THAN } ; String Builder buf = new String Builder ( ) ; send Wait For ( MDS Dialog Properties . get String ( STR_ ) , NUM_ , prompts , buf ) ; String [ ] lines = get Lines ( buf ) ; Integer vsan Id = null ; String [ ] regex = { MDS Dialog Properties . get String ( STR_ ) , MDS Dialog Properties . get String ( STR_ ) } ; String [ ] groups = new String [ NUM_ ] ; for ( String line : lines ) { int index = match ( line , regex , groups ) ; switch ( index ) { case NUM_ : vsan Id = new Integer ( groups [ NUM_ ] ) ; break ; case NUM_ : Set < String > peer Devices Ip Addr = peer Devices Map . get ( vsan Id ) ; if ( peer Devices Ip Addr == null ) { peer Devices Ip Addr = Sets . new Hash Set ( ) ; peer Devices Map . put ( vsan Id , peer Devices Ip Addr ) ; } String peer Device = groups [ NUM_ ] + groups [ NUM_ ] ; peer Devices Ip Addr . add ( peer Device ) ; break ; } } return peer Devices Map ; }
protected Collection < String > excluded Extensions From Byte Counts ( ) { return new Hash Set < String > ( Arrays . as List ( new String [ ] { STR_ , STR_ } ) ) ; }
public static boolean is URI ( String tag Name , String attr Name ) { return ( attr Name . equals Ignore Case ( STR_ ) || attr Name . equals Ignore Case ( STR_ ) ) ; }
public static void close Quietly ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( Runtime Exception rethrown ) { throw rethrown ; } catch ( Exception ignored ) { } } }
@ Override public int hash Code ( ) { int hash = NUM_ ; hash = NUM_ * hash + super . hash Code ( ) ; hash = NUM_ * hash + ( type != null ? type . hash Code ( ) : NUM_ ) ; hash = NUM_ * hash + ( timestamp != null ? timestamp . hash Code ( ) : NUM_ ) ; hash = NUM_ * hash + ( source != null ? source . hash Code ( ) : NUM_ ) ; hash = NUM_ * hash + ( id != null ? id . hash Code ( ) : NUM_ ) ; return hash ; }
private String open File ( String file ) { Buffered Reader br = null ; try { br = new Buffered Reader ( new File Reader ( file ) ) ; String Buffer sb = new String Buffer ( NUM_ ) ; String temp ; while ( ( temp = br . read Line ( ) ) != null ) { sb . append ( temp ) ; } return sb . to String ( ) ; } catch ( File Not Found Exception fnf ) { debug . error ( STR_ + file + STR_ + component Name , fnf ) ; return null ; } catch ( IO Exception ioe ) { debug . error ( STR_ + file + STR_ + component Name , ioe ) ; return null ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( IO Exception ioe ) { } } } }
protected static void fail ( ) { System . exit ( NUM_ ) ; }
public static final Circle scale ( Circle circle , double scale ) { if ( circle == null ) throw new Null Pointer Exception ( Messages . get String ( STR_ ) ) ; if ( scale <= NUM_ ) throw new Illegal Argument Exception ( Messages . get String ( STR_ ) ) ; return new Circle ( circle . radius * scale ) ; }
public static boolean is Simple Name Fully Qualfied ( String simple Class Name , String fully Qualified Classname ) { if ( ( fully Qualified Classname . ends With ( STR_ + simple Class Name ) ) || ( fully Qualified Classname . equals ( simple Class Name ) ) ) { return true ; } return false ; }
public boolean is Compatible With ( String desired Version ) throws Number Format Exception { if ( jar != null ) { init ( ) ; } if ( spec Version == null || spec Version . length ( ) == NUM_ ) { throw new Number Format Exception ( STR_ ) ; } if ( ! spec Version . matches ( STR_ ) ) { throw new Number Format Exception ( STR_ + spec Version ) ; } if ( desired Version == null || desired Version . length ( ) == NUM_ ) { throw new Number Format Exception ( STR_ ) ; } if ( ! desired Version . matches ( STR_ ) ) { throw new Number Format Exception ( STR_ + desired Version ) ; } String Tokenizer spec Version Tokens = new String Tokenizer ( spec Version , STR_ ) ; String Tokenizer desired Version Tokens = new String Tokenizer ( desired Version , STR_ ) ; try { while ( spec Version Tokens . has More Elements ( ) ) { int desired Ver = Integer . parse Int ( desired Version Tokens . next Token ( ) ) ; int spec Ver = Integer . parse Int ( spec Version Tokens . next Token ( ) ) ; if ( spec Ver != desired Ver ) { return spec Ver > desired Ver ; } } } catch ( No Such Element Exception e ) { } while ( desired Version Tokens . has More Tokens ( ) ) { if ( NUM_ != Integer . parse Int ( desired Version Tokens . next Token ( ) ) ) { return false ; } } return true ; }
public Record Iterator iterate All ( ) { return new Range Iterator ( null , null , null , null ) ; }
public static Object resolve Ident As Enum Const ( String constant , Engine Import Service engine Import Service , boolean is Annotation ) throws Expr Validation Exception { int last Dot Index = constant . last Index Of ( STR_ ) ; if ( last Dot Index == - NUM_ ) { return null ; } String class Name = constant . substring ( NUM_ , last Dot Index ) ; String const Name = constant . substring ( last Dot Index + NUM_ ) ; class Name = unescape ( class Name ) ; const Name = unescape ( const Name ) ; Class clazz ; try { clazz = engine Import Service . resolve Class ( class Name , is Annotation ) ; } catch ( Engine Import Exception e ) { return null ; } Field field ; try { field = clazz . get Field ( const Name ) ; } catch ( No Such Field Exception e ) { return null ; } int modifiers = field . get Modifiers ( ) ; if ( Modifier . is Public ( modifiers ) && Modifier . is Static ( modifiers ) ) { try { return field . get ( null ) ; } catch ( Illegal Access Exception e ) { throw new Expr Validation Exception ( STR_ + field . get Name ( ) + STR_ + e . get Message ( ) , e ) ; } } return null ; }
public String quoted Name Of ( String s ) { if ( reserved Names . contains ( s ) ) return STR_ + s + STR_ ; else return s ; }
public boolean is First Window ( Accessibility Window Info base Window , int window Type ) { int index = get Window Index ( base Window ) ; if ( index <= NUM_ ) { return true ; } for ( int i = index - NUM_ ; i > NUM_ ; i -- ) { Accessibility Window Info window = m Windows . get ( i ) ; if ( window != null && window . get Type ( ) == window Type ) { return false ; } } return true ; }
public String pull Request Url ( String account , String collection , String repo Id , String pull Request ) { Objects . require Non Null ( repo Id , STR_ ) ; Objects . require Non Null ( pull Request , STR_ ) ; return get Team Base Url ( account , collection ) + format ( PULL REQUEST , repo Id , pull Request ) + get Api Version ( ) ; }
@ Not Null public String compute Preferred Theme ( @ Not Null Configuration configuration ) { Merged Manifest manifest = Merged Manifest . get ( my Module ) ; String activity = configuration . get Activity ( ) ; if ( activity != null ) { String activity Fqcn = activity ; if ( activity . starts With ( STR_ ) ) { String pkg = String Util . not Nullize ( manifest . get Package ( ) ) ; activity Fqcn = pkg + activity ; } Activity Attributes attributes = manifest . get Activity Attributes ( activity Fqcn ) ; if ( attributes != null ) { String theme = attributes . get Theme ( ) ; if ( theme != null && theme . starts With ( Sdk Constants . PREFIX RESOURCE REF ) ) { return theme ; } } attributes = manifest . get Activity Attributes ( activity ) ; if ( attributes != null ) { String theme = attributes . get Theme ( ) ; if ( theme != null && theme . starts With ( Sdk Constants . PREFIX RESOURCE REF ) ) { return theme ; } } } return manifest . get Default Theme ( configuration . get Target ( ) , configuration . get Screen Size ( ) , configuration . get Device ( ) ) ; }
public static Automaton make Decimal Interval ( int min , int max , int digits ) throws Illegal Argument Exception { String x = Integer . to String ( min ) ; String y = Integer . to String ( max ) ; if ( min > max || ( digits > NUM_ && y . length ( ) > digits ) ) { throw new Illegal Argument Exception ( ) ; } int d ; if ( digits > NUM_ ) d = digits ; else d = y . length ( ) ; String Builder bx = new String Builder ( ) ; for ( int i = x . length ( ) ; i < d ; i ++ ) { bx . append ( STR_ ) ; } bx . append ( x ) ; x = bx . to String ( ) ; String Builder by = new String Builder ( ) ; for ( int i = y . length ( ) ; i < d ; i ++ ) { by . append ( STR_ ) ; } by . append ( y ) ; y = by . to String ( ) ; Automaton . Builder builder = new Automaton . Builder ( ) ; if ( digits <= NUM_ ) { builder . create State ( ) ; } Collection < Integer > initials = new Array List < > ( ) ; between ( builder , x , y , NUM_ , initials , digits <= NUM_ ) ; Automaton a 1 = builder . finish ( ) ; if ( digits <= NUM_ ) { a 1 . add Transition ( NUM_ , NUM_ , STR_ ) ; for ( int p : initials ) { a 1 . add Epsilon ( NUM_ , p ) ; } a 1 . finish State ( ) ; } return a 1 ; }
public String attribute Index Tip Text ( ) { return STR_ + STR_ ; }
public boolean is Scanning ( ) { return is Scanning ; }
public static boolean is Running In Single Seq Mode ( ) { if ( mode . equals ( STR_ ) ) { return true ; } return false ; }
public boolean equal Array Value ( Object other Value ) { if ( value instanceof Object [ ] && other Value instanceof Object [ ] ) { return Arrays . equals ( ( Object [ ] ) value , ( Object [ ] ) other Value ) ; } Class type = value . get Class ( ) ; if ( type != other Value . get Class ( ) ) { return false ; } if ( type == int [ ] . class ) { return Arrays . equals ( ( int [ ] ) value , ( int [ ] ) other Value ) ; } else if ( type == byte [ ] . class ) { return Arrays . equals ( ( byte [ ] ) value , ( byte [ ] ) other Value ) ; } else if ( type == short [ ] . class ) { return Arrays . equals ( ( short [ ] ) value , ( short [ ] ) other Value ) ; } else if ( type == long [ ] . class ) { return Arrays . equals ( ( long [ ] ) value , ( long [ ] ) other Value ) ; } else if ( type == char [ ] . class ) { return Arrays . equals ( ( char [ ] ) value , ( char [ ] ) other Value ) ; } else if ( type == boolean [ ] . class ) { return Arrays . equals ( ( boolean [ ] ) value , ( boolean [ ] ) other Value ) ; } else if ( type == float [ ] . class ) { return Arrays . equals ( ( float [ ] ) value , ( float [ ] ) other Value ) ; } else if ( type == double [ ] . class ) { return Arrays . equals ( ( double [ ] ) value , ( double [ ] ) other Value ) ; } return false ; }
public final double info Gain ( ) { return m info Gain ; }
public long length Between ( int start , int end ) { final int file Start = m File No Lookup . lookup ( start ) ; final int file End = m File No Lookup . lookup ( end ) ; final int start Index = start - m File No Lookup . start Seq ( file Start ) ; final int end Index = end - m File No Lookup . start Seq ( file End ) ; long ret Length = - m Pointers [ file Start ] [ start Index ] ; for ( int i = file Start ; i < file End ; i ++ ) { ret Length += m Pointers [ i ] [ m Pointers [ i ] . length - NUM_ ] ; } ret Length += m Pointers [ file End ] [ end Index ] ; return ret Length ; }
public static < T > int binary Search Floor ( List < ? extends Comparable < ? super T > > list , T key , boolean inclusive , boolean stay In Bounds ) { int index = Collections . binary Search ( list , key ) ; index = index < NUM_ ? - ( index + NUM_ ) : ( inclusive ? index : ( index - NUM_ ) ) ; return stay In Bounds ? Math . max ( NUM_ , index ) : index ; }
public static int key Binding Description To Key Modifier ( String key Binding Description ) { if ( String Utils . is Blank ( key Binding Description ) ) { return NUM_ ; } else if ( key Binding Description . starts With ( STR_ ) ) { return SWT . ALT ; } else if ( key Binding Description . starts With ( STR_ ) ) { return SWT . CTRL ; } else if ( key Binding Description . starts With ( STR_ ) ) { return SWT . COMMAND ; } else { return NUM_ ; } }
protected void throw If Contains Unmapped Local Path ( final String [ ] path Free Arguments ) throws Cannot Find Workspace Exception , CLC Exception { if ( path Free Arguments != null ) { for ( final String path : path Free Arguments ) { if ( ! Server Path . is Server Path ( path ) ) { if ( find Cached Workspace For Path ( path ) == null ) { final String message Format = Messages . get String ( STR_ ) ; throw new CLC Exception ( Message Format . format ( message Format , path ) ) ; } } } } }
public char char At ( int index ) { if ( index < NUM_ || index >= next Fence Post ) return NUM_ ; return s . char At ( index ) ; }
public int size ( ) { return data . size ( ) ; }
public static boolean is Notebook Title Valid ( String value ) { return value == null || value . length ( ) < NUM_ ; }
@ Override public byte [ ] wrap ( final byte [ ] outgoing , final int offset , final int len ) throws Ldap Exception { final byte [ ] copy = new byte [ len ] ; System . arraycopy ( outgoing , offset , copy , NUM_ , len ) ; return copy ; }
public boolean is Show Callgraph Views ( ) { return m callgraph Views Checkbox . is Selected ( ) ; }
private static int system depth ( Stack < Soot Method > stack ) { for ( int ii = stack . size ( ) - NUM_ ; ii > NUM_ ; ii -- ) { Soot Method m = stack . get ( ii ) ; if ( ! is system ( m ) ) return stack . size ( ) - ii ; } return stack . size ( ) ; }
public Format Result apply Mask ( String mask , String value , String old Value , Integer cursor Index ) { if ( mask == null || value == null ) { return null ; } if ( old Value . length ( ) > value . length ( ) ) { return new Format Result ( value , null ) ; } value = ( String ) get Mask Or Get Cursor Index ( mask , value , cursor Index , true ) ; cursor Index = ( Integer ) get Mask Or Get Cursor Index ( mask , value , cursor Index , false ) ; return new Format Result ( value , cursor Index ) ; }
public static int count ( String orig , String find ) { int ret Val = NUM_ ; int pos = NUM_ ; while ( orig . index Of ( find , pos ) > NUM_ ) { pos = orig . index Of ( find , pos ) + NUM_ ; ret Val ++ ; } return ret Val ; }
Tree Set < String > fetch Zk Children ( Watcher watcher ) throws Interrupted Exception , Keeper Exception { while ( true ) { try { Tree Set < String > ordered Children = new Tree Set < > ( ) ; List < String > child Names = zookeeper . get Children ( dir , watcher , true ) ; stats . set Queue Length ( child Names . size ( ) ) ; for ( String child Name : child Names ) { if ( ! child Name . region Matches ( NUM_ , PREFIX , NUM_ , PREFIX . length ( ) ) ) { LOG . debug ( STR_ + child Name ) ; continue ; } ordered Children . add ( child Name ) ; } return ordered Children ; } catch ( Keeper Exception . No Node Exception e ) { zookeeper . make Path ( dir , false , true ) ; } } }
public final Char Sequence yytext ( ) { return zz Buffer . sub Sequence ( zz Start Read , zz Marked Pos ) ; }
public boolean matches Ignore Case ( String sa ) { if ( length != sa . length ( ) ) return false ; char [ ] buffer = buffer ; int offset = offset ; for ( int i = length - NUM_ ; i >= NUM_ ; i -- ) { char ca = buffer [ offset + i ] ; char cb = sa . char At ( i ) ; if ( ca != cb && Character . to Lower Case ( ca ) != Character . to Lower Case ( cb ) ) return false ; } return true ; }
protected String parse Unrecognized Sym Code ( String sym Code ) { String scheme = sym Code . substring ( NUM_ , NUM_ ) ; return Logging . get Message ( STR_ , scheme , sym Code ) ; }
public boolean has Block Chain ( ) { return ( local Services & NODE NETWORK ) == NODE NETWORK ; }
public int compute String Width ( Synth Context ss , Font font , Font Metrics metrics , String text ) { return Swing Utilities 2 . string Width ( ss . get Component ( ) , metrics , text ) ; }
public double reduce ( String numeric Column Name , Numeric Reduce Function function ) { Column column = column ( numeric Column Name ) ; return function . reduce ( column . to Double Array ( ) ) ; }
protected int count Token ( String token , String target ) { int token Index = NUM_ ; int count = NUM_ ; while ( token Index != - NUM_ ) { token Index = target . index Of ( token , token Index ) ; if ( token Index > - NUM_ ) { token Index ++ ; count ++ ; } } return count ; }
static public Array List < String > generate Array List ( String [ ] array ) { Argument Checking . not Null ( array , STR_ ) ; Array List < String > list = new Array List < String > ( array . length ) ; for ( int i = NUM_ ; i < array . length ; ++ i ) { list . add ( i , array [ i ] ) ; } return list ; }
public boolean has Header ( String header Name ) { return name Table . contains Key ( SIP Header Names Cache . to Lower Case ( header Name ) ) ; }
public boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { log . warn ( system Name + STR_ ) ; return false ; } return true ; }
private String safe Name ( String str ) { return str . replace All ( STR_ , STR_ ) ; }
@ Override public boolean has Next ( ) throws XML Stream Exception { log . log ( Level . FINE , STR_ , event != END DOCUMENT ) ; return event != END DOCUMENT ; }
@ Override public boolean is Modified Impl ( ) { if ( is Digest Modified || depend . is Modified ( ) ) { change Sequence . increment And Get ( ) ; return true ; } else return false ; }
public String to Summary String ( ) { return to Summary String ( STR_ ) ; }
public String global Info ( ) { return STR_ + STR_ ; }
public Set < String > values ( ) { Set < String > values = new Hash Set < String > ( ) ; for ( String key : codes . key Set ( ) ) { values . add ( codes . get String ( key ) ) ; } return values ; }
public static Attribute Name name By String ( String qname ) { int hash = Attribute Name . string To Hash ( qname ) ; int index = Arrays . binary Search ( Attribute Name . ATTRIBUTE HASHES , hash ) ; if ( index < NUM_ ) { return Attribute Name . create Attribute Name ( qname . intern ( ) , false ) ; } else { Attribute Name rv = Attribute Name . ATTRIBUTE NAMES [ index ] ; @ Local String name = rv . get Local ( Attribute Name . HTML ) ; if ( ! name . equals ( qname ) ) { return Attribute Name . create Attribute Name ( qname . intern ( ) , false ) ; } return rv ; } }
public static Locale Provider Adapter for Type ( Type type ) { switch ( type ) { case JRE : return jre Locale Provider Adapter ; case CLDR : return cldr Locale Provider Adapter ; case SPI : return spi Locale Provider Adapter ; case HOST : return host Locale Provider Adapter ; case FALLBACK : return fallback Locale Provider Adapter ; default : throw new Internal Error ( STR_ ) ; } }
public boolean is Initialized ( ) { return initiailized ; }
protected void ensure Unsigned Properties ( ) throws DSS Exception { final Node List qualifying Properties Node List = current Signature Dom . get Elements By Tag Name NS ( X Ad ES Namespaces . X Ad ES , STR_ ) ; if ( qualifying Properties Node List . get Length ( ) != NUM_ ) { throw new DSS Exception ( STR_ ) ; } qualifying Properties Dom = ( Element ) qualifying Properties Node List . item ( NUM_ ) ; final Node List unsigned Properties Node List = current Signature Dom . get Elements By Tag Name NS ( X Ad ES Namespaces . X Ad ES , STR_ ) ; final int length = unsigned Properties Node List . get Length ( ) ; if ( length == NUM_ ) { unsigned Properties Dom = ( Element ) qualifying Properties Node List . item ( NUM_ ) ; } else if ( length == NUM_ ) { unsigned Properties Dom = DSSXML Utils . add Element ( document Dom , qualifying Properties Dom , X Ad ES Namespaces . X Ad ES , STR_ ) ; } else { throw new DSS Exception ( STR_ ) ; } }
public String content To Text ( ) { String Buffer buf = new String Buffer ( ) ; Indicator Tree Element Content Provider content Provider = ( Indicator Tree Element Content Provider ) f Content Provider ; for ( Object root Element : content Provider . get Sorted Root Elements ( ) ) { content To Text ( root Element , NUM_ , buf ) ; } return buf . to String ( ) ; }
public boolean has Header ( String header Name ) { return header Table . contains Key ( SIP Header Names Cache . to Lower Case ( header Name ) ) ; }
public boolean is Bold ( ) { return modifiers . contains ( SGR . BOLD ) ; }
public boolean does Override ( ) { return overrides . size ( ) > NUM_ ; }
@ Override public boolean is Top ( Bit Set fact ) { return fact . get ( top Bit ) ; }
public double intercept Std Err ( ) { return Math . sqrt ( svar 0 ) ; }
static Not Compliant M Bean Exception throw Exception ( Class < ? > not Compliant , Throwable cause ) throws Not Compliant M Bean Exception , Security Exception { if ( cause instanceof Security Exception ) throw ( Security Exception ) cause ; if ( cause instanceof Not Compliant M Bean Exception ) throw ( Not Compliant M Bean Exception ) cause ; final String classname = ( not Compliant == null ) ? STR_ : not Compliant . get Name ( ) ; final String reason = ( cause == null ) ? STR_ : cause . get Message ( ) ; final Not Compliant M Bean Exception res = new Not Compliant M Bean Exception ( classname + STR_ + reason ) ; res . init Cause ( cause ) ; throw res ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
@ Nullable public static String unbox If Possible ( final String type ) { if ( type == null ) return null ; final String s = our Unboxed Types . get ( type ) ; return s == null ? type : s ; }
boolean process Event ( long address ) { short source = unsafe . get Short ( address + OFFSETOF SOURCE ) ; long object = unsafe . get Address ( address + OFFSETOF OBJECT ) ; int events = unsafe . get Int ( address + OFFSETOF EVENTS ) ; if ( source != PORT SOURCE FILE ) { if ( source == PORT SOURCE USER ) { boolean shutdown = process Requests ( ) ; if ( shutdown ) return true ; } return false ; } Node node = object 2 Node . get ( object ) ; if ( node == null ) { return false ; } boolean reregister = true ; boolean is Directory = ( node instanceof Solaris Watch Key ) ; if ( is Directory ) { process Directory Events ( ( Solaris Watch Key ) node , events ) ; } else { boolean ignore = process Entry Events ( ( Entry Node ) node , events ) ; if ( ignore ) reregister = false ; } if ( reregister ) { try { events = FILE MODIFIED | FILE ATTRIB ; if ( ! is Directory ) events |= FILE NOFOLLOW ; port Associate ( port , PORT SOURCE FILE , object , events ) ; } catch ( Unix Exception x ) { reregister = false ; } } if ( ! reregister ) { object 2 Node . remove ( object ) ; release Object ( object , false ) ; if ( is Directory ) { Solaris Watch Key key = ( Solaris Watch Key ) node ; file Key 2 Watch Key . remove ( key . get File Key ( ) ) ; key . invalidate ( ) ; key . signal ( ) ; } else { Entry Node entry = ( Entry Node ) node ; Solaris Watch Key key = ( Solaris Watch Key ) entry . parent ( ) ; key . remove Child ( entry . name ( ) ) ; } } return false ; }
public boolean contains ( Playlist p ) { return m Playlists . contains ( p ) ; }
public String version Qualifier ( ) { return properties . get Property ( STR_ ) ; }
public static < T > List < T > sub List ( List < T > list , int start , int max ) { if ( list == null ) { return null ; } int end = start + max ; return list . sub List ( Math . max ( NUM_ , start ) , Math . min ( list . size ( ) , end ) ) ; }
@ Not Null public Collection < String > find Modules With Model ( @ Not Null Class model Clazz ) { List < String > modules = new Array List < String > ( ) ; for ( Map . Entry < String , Object > set : projects By Path . entry Set ( ) ) { if ( model Clazz . is Instance ( set . get Value ( ) ) ) { modules . add ( extract Module Path ( model Clazz , set . get Key ( ) ) ) ; } } return modules ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; new Vector . add Element ( STR_ ) ; return new Vector . elements ( ) ; }
protected Color Get Color From String ( String token ) { String tokstring = ( String ) token ; Color result = Color . black ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + tokstring + STR_ ) ; } if ( tokstring . equals ( STR_ ) ) result = Color . black ; else if ( tokstring . equals ( STR_ ) ) result = Color . blue ; else if ( tokstring . equals ( STR_ ) ) result = Color . cyan ; else if ( tokstring . equals ( STR_ ) ) result = Color . dark Gray ; else if ( tokstring . equals ( STR_ ) ) result = Color . gray ; else if ( tokstring . equals ( STR_ ) ) result = Color . green ; else if ( tokstring . equals ( STR_ ) ) result = Color . light Gray ; else if ( tokstring . equals ( STR_ ) ) result = Color . magenta ; else if ( tokstring . equals ( STR_ ) ) result = Color . orange ; else if ( tokstring . equals ( STR_ ) ) result = Color . pink ; else if ( tokstring . equals ( STR_ ) ) result = Color . red ; else if ( tokstring . equals ( STR_ ) ) result = Color . white ; else if ( tokstring . equals ( STR_ ) ) result = Color . yellow ; else result = Color . decode ( tokstring ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + result + STR_ ) ; } return result ; }
public int find Row Index ( String value , String column Name ) { return find Row Index ( value , get Column Index ( column Name ) ) ; }
@ Override public boolean fire ( final Player player , final Sentence sentence , final Entity npc ) { final String temp = player . get Quest ( quest Slot , quest Index ) ; if ( temp == null ) { return false ; } final List < String > tokens = Arrays . as List ( temp . split ( STR_ ) ) ; if ( ( tokens . size ( ) % NUM_ ) != NUM_ ) { logger . error ( STR_ + player . get Name ( ) + STR_ + quest Slot + STR_ + quest Index + STR_ + player . get Quest ( quest Slot ) + STR_ ) ; return false ; } int sum = NUM_ ; for ( int i = NUM_ ; i < tokens . size ( ) / NUM_ ; i ++ ) { final String creature Name = tokens . get ( i * NUM_ ) ; int killed Solo ; int killed Shared ; try { killed Solo = Integer . parse Int ( tokens . get ( i * NUM_ + NUM_ ) ) ; killed Shared = Integer . parse Int ( tokens . get ( i * NUM_ + NUM_ ) ) ; } catch ( Number Format Exception npe ) { logger . error ( STR_ + quest Slot + STR_ + player . get Name ( ) + STR_ + i * NUM_ ) ; return false ; } final int diff Solo = player . get Solo Kill ( creature Name ) - killed Solo ; final int diff Shared = player . get Shared Kill ( creature Name ) - killed Shared ; sum = sum + diff Solo + diff Shared ; } if ( sum < kills Sum ) { return false ; } return true ; }
private boolean has Port ( List < Service Port > ports , Service Port port ) { for ( Service Port a Port : ports ) { if ( Objects . equals ( port . get Port ( ) , a Port . get Port ( ) ) ) { return true ; } } return false ; }
public Object [ ] to Array ( ) { fully Lock ( ) ; try { int size = count . get ( ) ; Object [ ] a = new Object [ size ] ; int k = NUM_ ; for ( Node < E > p = head . next ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { fully Unlock ( ) ; } }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ ; }
public boolean exists ( ) { return file != null ? file . exists ( ) : true ; }
public boolean is Canceled ( ) { if ( pane == null ) return false ; Object v = pane . get Value ( ) ; return ( ( v != null ) && ( cancel Option . length == NUM_ ) && ( v . equals ( cancel Option [ NUM_ ] ) ) ) ; }
public double min ( ) { if ( is Sparse ( ) && nnz ( ) < length ( ) ) { double min = NUM_ ; for ( Index Value iv : this ) min = Math . min ( min , iv . get Value ( ) ) ; return min ; } else { double min = get ( NUM_ ) ; for ( int i = NUM_ ; i < length ( ) ; i ++ ) min = Math . min ( min , get ( i ) ) ; return min ; } }
public boolean check Date Validity ( long some Time ) { if ( not Before == null ) { if ( not On Or After == null ) { return true ; } else { if ( some Time < not On Or After . get Time ( ) ) { return true ; } } } else if ( not On Or After == null ) { if ( some Time >= not Before . get Time ( ) ) { return true ; } } else if ( ( some Time >= not Before . get Time ( ) ) && ( some Time < not On Or After . get Time ( ) ) ) { return true ; } return false ; }
public int size ( ) { return cart Lines . size ( ) ; }
int parse Int Option ( String key , String value ) throws URI Syntax Exception { try { return Integer . parse Int ( value ) ; } catch ( Number Format Exception nfe ) { throw new URI Syntax Exception ( value , STR_ + key + STR_ + value ) ; } }
public static void check Not Empty ( Char Sequence str , String message ) { if ( str == null || str . length ( ) == NUM_ ) { throw new Illegal Argument Exception ( message ) ; } }
public int determine Max Y Value ( Hash Map < Comparable Label , Integer > data Points , Set < Comparable Label > date Key Set ) { Integer max Value = Integer . MIN VALUE ; Integer min Value = Integer . MAX VALUE ; for ( Comparable Label date : date Key Set ) { int temp Int = data Points . get ( date ) ; if ( temp Int < min Value ) { min Value = temp Int ; } if ( temp Int > max Value ) { max Value = temp Int ; } } return max Value ; }
public final double error Rate ( ) { if ( ! m Class Is Nominal ) { return Math . sqrt ( m Sum Sqr Err / ( m With Class - m Unclassified ) ) ; } if ( m Cost Matrix == null ) { return m Incorrect / m With Class ; } else { return avg Cost ( ) ; } }
public boolean contains Header Out ( String name ) { Array List < String > header Keys = header Keys Out ; int size = header Keys . size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { String old Key = header Keys . get ( i ) ; if ( old Key . equals Ignore Case ( name ) ) { return true ; } } if ( name . equals Ignore Case ( STR_ ) ) { return content Type Out != null ; } if ( name . equals Ignore Case ( STR_ ) ) { return content Length Out >= NUM_ ; } return false ; }
public String extract classname ( String fullname ) { return fullname . replace First ( STR_ , STR_ ) ; }
public int size ( ) { return m List . size ( ) ; }
public static String to Byte Array ( byte [ ] buf , int ofs , int len ) { String Buffer sb = new String Buffer ( ) ; for ( int i = ofs ; ( i < len ) && ( i < buf . length ) ; i ++ ) { sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( hexchars [ ( buf [ i ] & NUM_ ) > > NUM_ ] ) ; sb . append ( hexchars [ buf [ i ] & NUM_ ] ) ; if ( ( ( i + NUM_ ) < len ) && ( ( i + NUM_ ) < buf . length ) ) { sb . append ( STR_ ) ; } } return sb . to String ( ) ; }
private Node < K , V > find Predecessor ( Comparable < ? super K > key ) { if ( key == null ) throw new Null Pointer Exception ( ) ; for ( ; ; ) { Index < K , V > q = head ; Index < K , V > r = q . right ; for ( ; ; ) { if ( r != null ) { Node < K , V > n = r . node ; K k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( key . compare To ( k ) > NUM_ ) { q = r ; r = r . right ; continue ; } } Index < K , V > d = q . down ; if ( d != null ) { q = d ; r = d . right ; } else return q . node ; } } }
public static float next After ( final float start , final double direction ) { if ( direction < start ) { if ( start == NUM_ ) { return - Float . MIN VALUE ; } final int bits = Float . float To Raw Int Bits ( start ) ; return Float . int Bits To Float ( bits + ( bits > NUM_ ? - NUM_ : NUM_ ) ) ; } else if ( direction > start ) { final int bits = Float . float To Raw Int Bits ( start + NUM_ ) ; return Float . int Bits To Float ( bits + ( bits >= NUM_ ? NUM_ : - NUM_ ) ) ; } else if ( start == direction ) { return ( float ) direction ; } else { return start + ( float ) direction ; } }
private String user Agent ( ) { return m User Agent ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private String new Sentence ( Random r , int max Sentence Length ) { String Builder sb = new String Builder ( ) ; int num Elements = Test Util . next Int ( r , NUM_ , max Sentence Length ) ; for ( int i = NUM_ ; i < num Elements ; i ++ ) { if ( sb . length ( ) > NUM_ ) { sb . append ( STR_ ) ; sb . append ( ( char ) Test Util . next Int ( r , STR_ , STR_ ) ) ; } else { sb . append ( ( char ) Test Util . next Int ( r , STR_ , STR_ ) ) ; } } sb . append ( STR_ ) ; return sb . to String ( ) ; }
public final double correlation Coefficient ( ) throws Exception { if ( m Class Is Nominal ) { throw new Exception ( STR_ + STR_ ) ; } double correlation = NUM_ ; double var Actual = m Sum Sqr Class - m Sum Class * m Sum Class / ( m With Class - m Unclassified ) ; double var Predicted = m Sum Sqr Predicted - m Sum Predicted * m Sum Predicted / ( m With Class - m Unclassified ) ; double var Prod = m Sum Class Predicted - m Sum Class * m Sum Predicted / ( m With Class - m Unclassified ) ; if ( var Actual * var Predicted <= NUM_ ) { correlation = NUM_ ; } else { correlation = var Prod / Math . sqrt ( var Actual * var Predicted ) ; } return correlation ; }
public boolean is Running ( ) { return running ; }
public static String field Name ( Class < ? > a Class , String regex ) { if ( is Nested Mapping ( regex ) ) return regex ; String result = null ; for ( Class < ? > clazz : get Allsuper Classes ( a Class ) ) if ( ! is Null ( result = get Field Name ( clazz , regex ) ) ) return result ; return result ; }
public int next Int ( int min , int max ) { if ( min >= max ) { throw new Illegal Argument Exception ( String . format ( STR_ , min , max ) ) ; } int range = max - min ; int ret = next Int ( ) ; ret = Math . abs ( ret ) % range ; return ret + min ; }
public boolean is Match ( String address ) { try { return is Match ( Inet Address . get By Name ( address ) ) ; } catch ( Exception e ) { log . log ( Level . FINER , e . to String ( ) , e ) ; return false ; } }
public float distance To Center ( float x , float y ) { Point F c = get Center Offsets ( ) ; float dist = NUM_ ; float x Dist = NUM_ ; float y Dist = NUM_ ; if ( x > c . x ) { x Dist = x - c . x ; } else { x Dist = c . x - x ; } if ( y > c . y ) { y Dist = y - c . y ; } else { y Dist = c . y - y ; } dist = ( float ) Math . sqrt ( Math . pow ( x Dist , NUM_ ) + Math . pow ( y Dist , NUM_ ) ) ; return dist ; }
@ Override public int hash Code ( ) { int code = NUM_ ; if ( e Subject != null ) { code += e Subject . hash Code ( ) ; } if ( p Subject Name != null ) { code += p Subject Name . hash Code ( ) ; } return code ; }
public static Histogram product Histogram ( Histogram hist 1 , Histogram hist 2 ) { Set < String > prod Flds = new Hash Set < String > ( hist 1 . fields ( ) ) ; prod Flds . add All ( hist 2 . fields ( ) ) ; Histogram prod Hist = new Histogram ( prod Flds ) ; double num Rec 1 = hist 1 . records Output ( ) ; double num Rec 2 = hist 2 . records Output ( ) ; if ( Double . compare ( num Rec 1 , NUM_ ) < NUM_ || Double . compare ( num Rec 2 , NUM_ ) < NUM_ ) return prod Hist ; for ( String fld : hist 1 . fields ( ) ) for ( Bucket bkt : hist 1 . buckets ( fld ) ) prod Hist . add Bucket ( fld , new Bucket ( bkt . value Range ( ) , bkt . frequency ( ) * num Rec 2 , bkt . distinct Values ( ) , bkt . value Percentiles ( ) ) ) ; for ( String fld : hist 2 . fields ( ) ) for ( Bucket bkt : hist 2 . buckets ( fld ) ) prod Hist . add Bucket ( fld , new Bucket ( bkt . value Range ( ) , bkt . frequency ( ) * num Rec 1 , bkt . distinct Values ( ) , bkt . value Percentiles ( ) ) ) ; return prod Hist ; }
public double to Date Double ( Object value ) { long time = to Date Long ( value ) ; time += get To Local Time Zone Offset ( time ) ; return to Local Date Double ( time ) ; }
static Set search ( String filter ) throws SMS Exception { try { return ( sms Object . search ( null , base DN , filter , NUM_ , NUM_ , false , false ) ) ; } catch ( SSO Exception ssoe ) { debug . error ( STR_ + filter , ssoe ) ; throw new SMS Exception ( bundle . get String ( STR_ ) , ssoe , STR_ ) ; } }
public static int Next Non Id Char ( String str , int col ) { int cur Col = col ; char c = str . char At ( col ) ; while ( ( cur Col < str . length ( ) ) && ( Character . is Letter ( c ) || Character . is Digit ( c ) || ( c == STR_ ) ) ) { cur Col ++ ; if ( cur Col < str . length ( ) ) { c = str . char At ( cur Col ) ; } } return cur Col ; }
public boolean is Instance Of Followed By Branch ( ) { return instance Of Followed By Branch ; }
public void free Entry ( Basic Pool Entry entry ) { if ( num Entries < NUM_ ) { throw new Illegal State Exception ( STR_ + route ) ; } if ( num Entries <= free Entries . size ( ) ) { throw new Illegal State Exception ( STR_ + route ) ; } free Entries . add ( entry ) ; }
public boolean is All Space ( ) { boolean is All Space = true ; for ( int i = NUM_ ; i < text . length ( ) ; i ++ ) { if ( ! Character . is Whitespace ( text . char At ( i ) ) ) { is All Space = false ; break ; } } return is All Space ; }
public static < S , K , V , M extends Map < K , V > > Collector < S , ? , M > to Map ( Function < ? super S , ? extends K > key Mapper , Function < ? super S , ? extends V > value Mapper , Supplier < M > map Supplier ) { return Collectors . to Map ( key Mapper , value Mapper , Stream Utils . throwing Merger ( ) , map Supplier ) ; }
private < T > T [ ] concat ( T [ ] first , T [ ] second , Class < ? > cls ) { Collection < T > res = new Array List < > ( ) ; res . add All ( Arrays . as List ( first ) ) ; res . add All ( Arrays . as List ( second ) ) ; return res . to Array ( ( T [ ] ) Array . new Instance ( cls , res . size ( ) ) ) ; }
public String evaluator Tip Text ( ) { return STR_ ; }
public boolean is Role In Region Membership ( Role role ) { check Readiness ( ) ; return basic Is Role In Region Membership ( role ) ; }
public final int count Data Types ( ) { return m Data Types != null ? m Data Types . size ( ) : NUM_ ; }
private int index Of ( String full Path ) { for ( int i = NUM_ , length = this . relative Paths . length ; i < length ; i ++ ) { String current Relative Path = this . relative Paths [ i ] ; if ( current Relative Path == null ) continue ; String current Container Path = this . container Paths [ i ] ; String current Full Path = current Relative Path . length ( ) == NUM_ ? current Container Path : ( current Container Path + STR_ + current Relative Path ) ; if ( encloses ( current Full Path , full Path , i ) ) return i ; } return - NUM_ ; }
public void throw Runtime ( String reason , Throwable t ) { throw Runtime ( reason , Optional . of ( t ) ) ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( get Class ( ) != obj . get Class ( ) ) return false ; Ndef Record other = ( Ndef Record ) obj ; if ( ! Arrays . equals ( m Id , other . m Id ) ) return false ; if ( ! Arrays . equals ( m Payload , other . m Payload ) ) return false ; if ( m Tnf != other . m Tnf ) return false ; return Arrays . equals ( m Type , other . m Type ) ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( ! event Name . equals ( STR_ ) && ! event Name . equals ( STR_ ) && ! event Name . equals ( STR_ ) && ! event Name . equals ( STR_ ) ) { return false ; } if ( m listenee Types . size ( ) == NUM_ ) { return true ; } if ( m listenee Types . contains ( STR_ ) && ! event Name . equals ( STR_ ) ) { return false ; } if ( ! m listenee Types . contains ( STR_ ) && event Name . equals ( STR_ ) ) { return false ; } return true ; }
public ISPO [ ] next Chunk ( ) { if ( ! has Next ( ) ) { throw new No Such Element Exception ( ) ; } final ISPO [ ] ret ; if ( i == NUM_ && num Stmts == stmts . length ) { ret = stmts ; } else { final int remaining = num Stmts - i ; ret = new ISPO [ remaining ] ; System . arraycopy ( stmts , i , ret , NUM_ , remaining ) ; } i = num Stmts ; return ret ; }
private long next Long ( long n ) { long bits ; long val ; do { bits = ( rnd . next Long ( ) << NUM_ ) > > > NUM_ ; val = bits % n ; } while ( bits - val + ( n - NUM_ ) < NUM_ ) ; return val ; }
public E element ( ) { E o = peek ( ) ; if ( null == o ) { throw new No Such Element Exception ( ) ; } return o ; }
public static int pointer Size Bytes ( ) { return Sm Helper . pointer Size Bytes ( ) ; }
public URL Connection open Connection ( ) throws IO Exception { return stream Handler . open Connection ( this ) ; }
private Pair < String , String > class Path Of ( I Java Project project ) throws Java Model Exception { Pair < List < String > , List < String > > paths = class Path Entries ( project ) ; return new Pair < String , String > ( Plugin Util . join ( File . path Separator , paths . fst ) , Plugin Util . join ( File . path Separator , paths . snd ) ) ; }
private Text Impl first Text Node In Current Run ( ) { Text Impl first Text In Current Run = this ; for ( Node p = get Previous Sibling ( ) ; p != null ; p = p . get Previous Sibling ( ) ) { short node Type = p . get Node Type ( ) ; if ( node Type == Node . TEXT NODE || node Type == Node . CDATA SECTION NODE ) { first Text In Current Run = ( Text Impl ) p ; } else { break ; } } return first Text In Current Run ; }
@ Override public Enumeration < String > enumerate Requests ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; new Vector . add Element ( STR_ ) ; return new Vector . elements ( ) ; }
@ Override public String execute ( ) { return INPUT ; }
private Json Scope peek ( ) { return stack . get ( stack . size ( ) - NUM_ ) ; }
public static String decode Endpoint URI ( String endpoint ) { int ind = endpoint . index Of ( STR_ ) ; if ( ind == NUM_ ) { return null ; } else if ( ind != - NUM_ ) { return endpoint . substring ( NUM_ , ind ) ; } return endpoint ; }
private IHA Notify Release Time Response do Run With Barrier Lock ( ) throws Exception { final IHA Notify Release Time Request req 2 = new HA Notify Release Time Request ( service Id , req . get New Commit Counter ( ) , req . get New Commit Time ( ) ) ; did Notify Leader = true ; final IHA Notify Release Time Response consensus Release Time = leader . notify Earliest Commit Time ( req 2 ) ; lock . lock ( ) ; try { if ( log . is Info Enabled ( ) ) log . info ( STR_ + consensus Release Time ) ; final Tx State tx State = get Earliest Active Tx ( ) ; final long t 2 = consensus Release Time . get Commit Time ( ) ; if ( tx State != null && tx State . get Reads On Commit Time ( ) < t 2 ) { throw new Assertion Error ( STR_ + STR_ + consensus Release Time + STR_ + tx State ) ; } final long new Release Time = Math . max ( NUM_ , consensus Release Time . get Commit Time ( ) - NUM_ ) ; if ( log . is Info Enabled ( ) ) log . info ( STR_ + new Release Time ) ; set Release Time ( new Release Time ) ; } finally { lock . unlock ( ) ; } return consensus Release Time ; }
public static Range find Stacked Range Bounds ( Category Dataset dataset , Key To Group Map map ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; boolean has Valid Data = false ; Range result = null ; int [ ] group Index = new int [ dataset . get Row Count ( ) ] ; for ( int i = NUM_ ; i < dataset . get Row Count ( ) ; i ++ ) { group Index [ i ] = map . get Group Index ( map . get Group ( dataset . get Row Key ( i ) ) ) ; } int group Count = map . get Group Count ( ) ; double [ ] minimum = new double [ group Count ] ; double [ ] maximum = new double [ group Count ] ; int category Count = dataset . get Column Count ( ) ; for ( int item = NUM_ ; item < category Count ; item ++ ) { double [ ] positive = new double [ group Count ] ; double [ ] negative = new double [ group Count ] ; int series Count = dataset . get Row Count ( ) ; for ( int series = NUM_ ; series < series Count ; series ++ ) { Number number = dataset . get Value ( series , item ) ; if ( number != null ) { has Valid Data = true ; double value = number . double Value ( ) ; if ( value > NUM_ ) { positive [ group Index [ series ] ] = positive [ group Index [ series ] ] + value ; } if ( value < NUM_ ) { negative [ group Index [ series ] ] = negative [ group Index [ series ] ] + value ; } } } for ( int g = NUM_ ; g < group Count ; g ++ ) { minimum [ g ] = Math . min ( minimum [ g ] , negative [ g ] ) ; maximum [ g ] = Math . max ( maximum [ g ] , positive [ g ] ) ; } } if ( has Valid Data ) { for ( int j = NUM_ ; j < group Count ; j ++ ) { result = Range . combine ( result , new Range ( minimum [ j ] , maximum [ j ] ) ) ; } } return result ; }
@ Layoutlib Delegate static long elapsed Realtime Nanos ( ) { return System . nano Time ( ) - s Boot Time Nano ; }
public Set < String > names ( ) { Tree Set < String > result = new Tree Set < > ( String . CASE INSENSITIVE ORDER ) ; for ( int i = NUM_ , size = size ( ) ; i < size ; i ++ ) { result . add ( name ( i ) ) ; } return Collections . unmodifiable Set ( result ) ; }
public static String random Skewed Date ( ) { return String . format ( Locale . ROOT , STR_ , Test Util . next Int ( random ( ) , NUM_ , NUM_ ) ) ; }
protected boolean match ( String expected , String actual ) { return Pattern . matches ( expected , actual ) ; }
public static boolean is Blank Value ( String s ) { if ( null == s ) return true ; String s = s . trim ( ) ; return ( ( EMPTY STRING . equals ( s ) ) || ( STRING ZERO . equals ( s ) ) ) ; }
public static int len ( String list , char delimiter , boolean ignore Empty ) { int len = String Util . length ( list ) ; if ( len == NUM_ ) return NUM_ ; int count = NUM_ ; int last = NUM_ ; for ( int i = NUM_ ; i < len ; i ++ ) { if ( list . char At ( i ) == delimiter ) { if ( ! ignore Empty || last < i ) count ++ ; last = i + NUM_ ; } } if ( ! ignore Empty || last < len ) count ++ ; return count ; }
private static Immutable List < String > update Urls ( boolean beta Channel ) { String flavor = Build Config . FLAVOR ; List < String > urls = new Array List < > ( ) ; if ( beta Channel ) { urls . add ( STR_ + flavor + STR_ ) ; urls . add ( STR_ + flavor + STR_ ) ; } else { urls . add ( STR_ + flavor + STR_ ) ; urls . add ( STR_ + flavor + STR_ ) ; } return Immutable List . copy Of ( urls ) ; }
public static boolean search In Array ( int [ ] data , int key ) { for ( int i = NUM_ ; i < data . length ; i ++ ) { if ( key == data [ i ] ) { return true ; } } return false ; }
private List < String > to List ( String [ ] array ) { List < String > ret = new Array List < String > ( ) ; if ( array != null && array . length > NUM_ ) { ret . add All ( Arrays . as List ( array ) ) ; } return ret ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public static int index Of Last Separator ( String filename ) { if ( filename == null ) { return - NUM_ ; } int last Unix Pos = filename . last Index Of ( UNIX SEPARATOR ) ; int last Windows Pos = filename . last Index Of ( WINDOWS SEPARATOR ) ; return Math . max ( last Unix Pos , last Windows Pos ) ; }
public boolean has Freq ( ) { return has Freq ; }
public List < Space > S ( ) throws Scope Exception { Array List < Space > spaces = new Array List < Space > ( ) ; for ( Domain domain : get Domains ( ) ) { spaces . add ( S ( domain ) ) ; } return spaces ; }
@ Nullable private static Boolean find Path ( Instruction cur , int destination , Linked Hash Set < Integer > fragment Insns , boolean was Outside , Hash Map < Instruction , Boolean > visited ) { was Outside = was Outside || ! fragment Insns . contains ( cur . num ( ) ) ; visited . put ( cur , null ) ; Iterable < ? extends Instruction > instructions = cur . all Successors ( ) ; boolean path Exists = false ; for ( Instruction i : instructions ) { if ( i . num ( ) == destination ) return was Outside ; Boolean result ; if ( visited . contains Key ( i ) ) { result = visited . get ( i ) ; } else { result = find Path ( i , destination , fragment Insns , was Outside , visited ) ; visited . put ( i , result ) ; } if ( result != null ) { if ( result . boolean Value ( ) ) { visited . put ( cur , true ) ; return true ; } path Exists = true ; } } if ( path Exists ) { visited . put ( cur , false ) ; return false ; } else { visited . put ( cur , null ) ; return null ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private static String types String ( Class [ ] types ) { String Buffer sb = new String Buffer ( ) ; sb . append ( STR_ ) ; for ( int i = NUM_ ; i < types . length ; i ++ ) { if ( i != NUM_ ) { sb . append ( STR_ ) ; } sb . append ( Utilities . type String ( types [ i ] ) ) ; } sb . append ( STR_ ) ; return sb . to String ( ) ; }
public double pdf ( double x ) { if ( x < NUM_ || x > NUM_ ) return NUM_ ; return Math . exp ( PDF CONST ) * Math . pow ( x , alpha - NUM_ ) * Math . pow ( NUM_ - x , beta - NUM_ ) ; }
public static Timer Update empty ( ) { return new Timer Update ( null , Collections . < Timer Data > empty List ( ) , Collections . < Timer Data > empty List ( ) , Collections . < Timer Data > empty List ( ) ) ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; if ( m Stats != null ) { new Vector . add All ( Collections . list ( m Stats . enumerate Measures ( ) ) ) ; } return new Vector . elements ( ) ; }
public boolean use Recent Deletes ( ) { return is Evictable Cache Policy ( ) && ! is Memory SA && ( ! read Only SA || engine . has Mirror ( ) ) ; }
@ Layoutlib Delegate static float exp ( float value ) { return ( float ) Math . exp ( value ) ; }
public Set < String > api descriptors ( Method m ) { Set < String > apid = new Linked Hash Set < String > ( ) ; apid . add All ( m . get Permissions ( ) ) ; String cname = m . get Cname ( ) ; String sig = m . get Signature ( ) ; if ( cname . starts With ( STR_ ) ) { if ( cname . contains ( STR_ ) ) apid . add ( STR_ ) ; else if ( cname . contains ( STR_ ) || cname . contains ( STR_ ) ) apid . add ( STR_ ) ; else if ( cname . contains ( STR_ ) ) apid . add ( STR_ ) ; else if ( cname . contains ( STR_ ) ) apid . add ( STR_ ) ; else if ( cname . contains ( STR_ ) || cname . contains ( STR_ ) || ( cname . contains ( STR_ ) ) ) apid . add ( STR_ ) ; else if ( cname . contains ( STR_ ) ) apid . add ( STR_ ) ; } else if ( cname . starts With ( STR_ ) ) { if ( sig . contains ( STR_ ) ) apid . add ( STR_ ) ; if ( cname . contains ( STR_ ) ) apid . add ( STR_ ) ; } if ( apid . size ( ) == NUM_ ) apid . add ( STR_ ) ; return apid ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private static boolean is Applicable ( Method method , Class [ ] classes ) { Class [ ] method Args = method . get Parameter Types ( ) ; if ( method Args . length != classes . length ) { return false ; } for ( int i = NUM_ ; i < classes . length ; ++ i ) { if ( ! is Method Invocation Convertible ( method Args [ i ] , classes [ i ] ) ) { return false ; } } return true ; }
@ Override public String to JSON String ( ) { return to JSON String ( this ) ; }
@ Override public int hash Code ( ) { return node Id . hash Code ( ) ; }
public boolean stoplist Contains ( String x ) { if ( stopwords == null ) return false ; return stopwords . contains ( x ) ; }
public void wait For Schema Agreement ( String target Schema Version , int node Count ) { long start = System . current Time Millis ( ) ; Map < String , List < String > > versions = null ; while ( System . current Time Millis ( ) - start < MAX SCHEMA WAIT MS ) { log . info ( STR_ , target Schema Version , node Count ) ; versions = get Schema Versions ( ) ; if ( versions . size ( ) == NUM_ ) { if ( ! versions . contains Key ( target Schema Version ) ) { log . warn ( STR_ , versions , target Schema Version ) ; return ; } if ( node Count != - NUM_ ) { List < String > hosts = null ; for ( Entry < String , List < String > > entry : versions . entry Set ( ) ) { hosts = entry . get Value ( ) ; } if ( hosts != null && hosts . size ( ) == node Count ) { log . info ( STR_ , target Schema Version , node Count ) ; return ; } } else { log . info ( STR_ , target Schema Version ) ; return ; } } log . info ( STR_ ) ; try { Thread . sleep ( SCHEMA RETRY SLEEP MILLIS ) ; } catch ( Interrupted Exception ex ) { } } log . warn ( STR_ , versions ) ; }
public String binary Attributes Nominal Tip Text ( ) { return STR_ ; }
public Object invoke ( Object o ) throws Exception { return new Integer ( Array . get Length ( o ) ) ; }
public boolean handles ( Capability c ) { if ( do Not Check Capabilities ( ) ) { return true ; } return m Capabilities . contains ( c ) ; }
public byte [ ] to Byte Array ( ) { byte [ ] to Buf = new byte [ count ] ; System . arraycopy ( buf , NUM_ , to Buf , NUM_ , count ) ; return to Buf ; }
public static int index Of Java Like Extension ( String file Name ) { int file Name Length = file Name . length ( ) ; char [ ] [ ] java Like Extensions = get Java Like Extensions ( ) ; extensions : for ( int i = NUM_ , length = java Like Extensions . length ; i < length ; i ++ ) { char [ ] extension = java Like Extensions [ i ] ; int extension Length = extension . length ; int extension Start = file Name Length - extension Length ; int dot Index = extension Start - NUM_ ; if ( dot Index < NUM_ ) continue ; if ( file Name . char At ( dot Index ) != STR_ ) continue ; for ( int j = NUM_ ; j < extension Length ; j ++ ) { if ( file Name . char At ( extension Start + j ) != extension [ j ] ) continue extensions ; } return dot Index ; } return - NUM_ ; }
public Object [ ] find Tree Roots ( Object parent , boolean isolate , boolean invert ) { List < Object > roots = new Array List < Object > ( ) ; if ( parent != null ) { int child Count = model . get Child Count ( parent ) ; Object best = null ; int max Diff = NUM_ ; for ( int i = NUM_ ; i < child Count ; i ++ ) { Object cell = model . get Child At ( parent , i ) ; if ( model . is Vertex ( cell ) && is Cell Visible ( cell ) ) { Object [ ] conns = get Connections ( cell , ( isolate ) ? parent : null ) ; int fan Out = NUM_ ; int fan In = NUM_ ; for ( int j = NUM_ ; j < conns . length ; j ++ ) { Object src = view . get Visible Terminal ( conns [ j ] , true ) ; if ( src == cell ) { fan Out ++ ; } else { fan In ++ ; } } if ( ( invert && fan Out == NUM_ ) || ( ! invert && fan In == NUM_ ) ) { roots . add ( cell ) ; } int diff = ( invert ) ? fan In - fan Out : fan Out - fan In ; if ( diff > max Diff ) { max Diff = diff ; best = cell ; } } } if ( roots . is Empty ( ) && best != null ) { roots . add ( best ) ; } } return roots . to Array ( ) ; }
public static boolean is Abstract ( int mod ) { return Modifier . is Abstract ( mod ) ; }
public static int [ ] index Of Region ( String string , String left Boundary , String right Boundary , int offset ) { int ndx = offset ; int [ ] res = new int [ NUM_ ] ; ndx = string . index Of ( left Boundary , ndx ) ; if ( ndx == - NUM_ ) { return null ; } res [ NUM_ ] = ndx ; ndx += left Boundary . length ( ) ; res [ NUM_ ] = ndx ; ndx = string . index Of ( right Boundary , ndx ) ; if ( ndx == - NUM_ ) { return null ; } res [ NUM_ ] = ndx ; res [ NUM_ ] = ndx + right Boundary . length ( ) ; return res ; }
static public final float atan 2 ( float y , float x ) { float add , mul ; if ( x < NUM_ ) { if ( y < NUM_ ) { y = - y ; mul = NUM_ ; } else { mul = - NUM_ ; } x = - x ; add = - PI ; } else { if ( y < NUM_ ) { y = - y ; mul = - NUM_ ; } else { mul = NUM_ ; } add = NUM_ ; } float inv Div = NUM_ / ( ( x < y ? y : x ) * INV ATAN 2 DIM MINUS 1 ) ; if ( inv Div == Float . POSITIVE INFINITY ) { return ( ( float ) Math . atan 2 ( y , x ) + add ) * mul ; } int xi = ( int ) ( x * inv Div ) ; int yi = ( int ) ( y * inv Div ) ; return ( Atan 2 . table [ yi * ATAN 2 DIM + xi ] + add ) * mul ; }
public static AST Node node Class For Type ( int node Type , AST ast ) { switch ( node Type ) { case ANNOTATION TYPE DECLARATION : return new Annotation Type Declaration ( ast ) ; case ANNOTATION TYPE MEMBER DECLARATION : return new Annotation Type Member Declaration ( ast ) ; case ANONYMOUS CLASS DECLARATION : return new Anonymous Class Declaration ( ast ) ; case ARRAY ACCESS : return new Array Access ( ast ) ; case ARRAY CREATION : return new Array Creation ( ast ) ; case ARRAY INITIALIZER : return new Array Initializer ( ast ) ; case ARRAY TYPE : return new Array Type ( ast ) ; case ASSERT STATEMENT : return new Assert Statement ( ast ) ; case ASSIGNMENT : return new Assignment ( ast ) ; case BLOCK : return new Block ( ast ) ; case BLOCK COMMENT : return new Block Comment ( ast ) ; case BOOLEAN LITERAL : return new Boolean Literal ( ast ) ; case BREAK STATEMENT : return new Break Statement ( ast ) ; case CAST EXPRESSION : return new Cast Expression ( ast ) ; case CATCH CLAUSE : return new Catch Clause ( ast ) ; case CHARACTER LITERAL : return new Character Literal ( ast ) ; case CLASS INSTANCE CREATION : return new Class Instance Creation ( ast ) ; case COMPILATION UNIT : return new Compilation Unit ( ast ) ; case CONDITIONAL EXPRESSION : return new Conditional Expression ( ast ) ; case CONSTRUCTOR INVOCATION : return new Constructor Invocation ( ast ) ; case CONTINUE STATEMENT : return new Continue Statement ( ast ) ; case UNION TYPE : return new Union Type ( ast ) ; case DO STATEMENT : return new Do Statement ( ast ) ; case EMPTY STATEMENT : return new Empty Statement ( ast ) ; case ENHANCED FOR STATEMENT : return new Enhanced For Statement ( ast ) ; case ENUM CONSTANT DECLARATION : return new Enum Constant Declaration ( ast ) ; case ENUM DECLARATION : return new Enum Declaration ( ast ) ; case EXPRESSION STATEMENT : return new Expression Statement ( ast ) ; case FIELD ACCESS : return new Field Access ( ast ) ; case FIELD DECLARATION : return new Field Declaration ( ast ) ; case FOR STATEMENT : return new For Statement ( ast ) ; case IF STATEMENT : return new If Statement ( ast ) ; case IMPORT DECLARATION : return new Import Declaration ( ast ) ; case INFIX EXPRESSION : return new Infix Expression ( ast ) ; case INITIALIZER : return new Initializer ( ast ) ; case INSTANCEOF EXPRESSION : return new Instanceof Expression ( ast ) ; case JAVADOC : return new Javadoc ( ast ) ; case LABELED STATEMENT : return new Labeled Statement ( ast ) ; case LINE COMMENT : return new Line Comment ( ast ) ; case MARKER ANNOTATION : return new Marker Annotation ( ast ) ; case MEMBER REF : return new Member Ref ( ast ) ; case MEMBER VALUE PAIR : return new Member Value Pair ( ast ) ; case METHOD DECLARATION : return new Method Declaration ( ast ) ; case METHOD INVOCATION : return new Method Invocation ( ast ) ; case METHOD REF : return new Method Ref ( ast ) ; case METHOD REF PARAMETER : return new Method Ref Parameter ( ast ) ; case MODIFIER : return new Modifier ( ast ) ; case NORMAL ANNOTATION : return new Normal Annotation ( ast ) ; case NULL LITERAL : return new Null Literal ( ast ) ; case NUMBER LITERAL : return new Number Literal ( ast ) ; case PACKAGE DECLARATION : return new Package Declaration ( ast ) ; case PARAMETERIZED TYPE : return new Parameterized Type ( ast ) ; case PARENTHESIZED EXPRESSION : return new Parenthesized Expression ( ast ) ; case POSTFIX EXPRESSION : return new Postfix Expression ( ast ) ; case PREFIX EXPRESSION : return new Prefix Expression ( ast ) ; case PRIMITIVE TYPE : return new Primitive Type ( ast ) ; case QUALIFIED NAME : return new Qualified Name ( ast ) ; case QUALIFIED TYPE : return new Qualified Type ( ast ) ; case RETURN STATEMENT : return new Return Statement ( ast ) ; case SIMPLE NAME : return new Simple Name ( ast ) ; case SIMPLE TYPE : return new Simple Type ( ast ) ; case SINGLE MEMBER ANNOTATION : return new Single Member Annotation ( ast ) ; case SINGLE VARIABLE DECLARATION : return new Single Variable Declaration ( ast ) ; case STRING LITERAL : return new String Literal ( ast ) ; case SUPER CONSTRUCTOR INVOCATION : return new Super Constructor Invocation ( ast ) ; case SUPER FIELD ACCESS : return new Super Field Access ( ast ) ; case SUPER METHOD INVOCATION : return new Super Method Invocation ( ast ) ; case SWITCH CASE : return new Switch Case ( ast ) ; case SWITCH STATEMENT : return new Switch Statement ( ast ) ; case SYNCHRONIZED STATEMENT : return new Synchronized Statement ( ast ) ; case TAG ELEMENT : return new Tag Element ( ast ) ; case TEXT ELEMENT : return new Text Element ( ast ) ; case THIS EXPRESSION : return new This Expression ( ast ) ; case THROW STATEMENT : return new Throw Statement ( ast ) ; case TRY STATEMENT : return new Try Statement ( ast ) ; case TYPE DECLARATION : return new Type Declaration ( ast ) ; case TYPE DECLARATION STATEMENT : return new Type Declaration Statement ( ast ) ; case TYPE LITERAL : return new Type Literal ( ast ) ; case TYPE PARAMETER : return new Type Parameter ( ast ) ; case VARIABLE DECLARATION EXPRESSION : return new Variable Declaration Expression ( ast ) ; case VARIABLE DECLARATION FRAGMENT : return new Variable Declaration Fragment ( ast ) ; case VARIABLE DECLARATION STATEMENT : return new Variable Declaration Statement ( ast ) ; case WHILE STATEMENT : return new While Statement ( ast ) ; case WILDCARD TYPE : return new Wildcard Type ( ast ) ; } throw new Illegal Argument Exception ( ) ; }
public int last Index In ( Char Sequence csq , int from Index ) { for ( int i = from Index ; i >= NUM_ ; -- i ) { if ( contains ( csq . char At ( i ) ) ) return i ; } return - NUM_ ; }
public boolean contains Cycle ( ) { for ( Iterator < Edge Type > i = graph . edge Iterator ( ) ; i . has Next ( ) ; ) { Edge Type edge = i . next ( ) ; if ( get DFS Edge Type ( edge ) == BACK EDGE ) { return true ; } } return false ; }
protected boolean configurable Option ( String name ) { name = name . to Lower Case ( Locale . US ) ; if ( name . starts With ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) ) return false ; return true ; }
private void return Cipher State ( Cipher State state ) { if ( state != null ) { cipher Pool . add ( state ) ; } }
public static double guess Date ( String s ) { int i = s . length ( ) ; char c ; do { i -- ; c = s . char At ( i ) ; } while ( i >= NUM_ && ( Character . is Digit ( c ) || c == STR_ ) ) ; if ( i == s . length ( ) ) { return NUM_ ; } return Double . parse Double ( s . substring ( i + NUM_ ) ) ; }
private static void expand Number At ( String number String , int start Index , Word Relation word Relation , Item token Item ) { expand Number ( number String . substring ( start Index , number String . length ( ) ) , word Relation , token Item ) ; }
public int x ( double lon ) { return ( int ) Math . round ( dots Per Deg * ( lon - origin Lon ) * lon Corr ) ; }
@ Override public Match Result match ( String str ) { Regex Template template = new Regex Template ( to String ( ) ) ; return template . match ( str ) ; }
@ Nullable protected Peer select Download Peer ( List < Peer > peers ) { if ( peers . is Empty ( ) ) return null ; int most Common Chain Height = get Most Common Chain Height ( peers ) ; List < Peer > candidates = new Array List < Peer > ( ) ; for ( Peer peer : peers ) { if ( peer . get Best Height ( ) == most Common Chain Height ) candidates . add ( peer ) ; } int highest Version = NUM_ , preferred Version = NUM_ ; final int PREFERRED VERSION = params . get Protocol Version Num ( Network Parameters . Protocol Version . BLOOM FILTER ) ; for ( Peer peer : candidates ) { highest Version = Math . max ( peer . get Peer Version Message ( ) . client Version , highest Version ) ; preferred Version = Math . min ( highest Version , PREFERRED VERSION ) ; } Array List < Peer > candidates 2 = new Array List < Peer > ( candidates . size ( ) ) ; for ( Peer peer : candidates ) { if ( peer . get Peer Version Message ( ) . client Version >= preferred Version ) { candidates 2 . add ( peer ) ; } } int index = ( int ) ( Math . random ( ) * candidates 2 . size ( ) ) ; return candidates 2 . get ( index ) ; }
public double distance ( Coord other ) { double dx = this . x - other . x ; double dy = this . y - other . y ; return Math . sqrt ( dx * dx + dy * dy ) ; }
default Optional < Document Entity > single Result ( Document Query query ) throws Non Unique Result Exception { List < Document Entity > entities = find ( query ) ; if ( entities . is Empty ( ) ) { return Optional . empty ( ) ; } if ( entities . size ( ) == NUM_ ) { return Optional . of ( entities . get ( NUM_ ) ) ; } throw new Non Unique Result Exception ( STR_ + query ) ; }
protected Session obtain Session ( Properties props ) { return Session . get Instance ( props ) ; }
public static int prefix Length ( String s 1 , String s 2 ) { int len = NUM_ ; int max = Math . min ( s 1 . length ( ) , s 2 . length ( ) ) ; for ( int i = NUM_ ; i < max && s 1 . char At ( i ) == s 2 . char At ( i ) ; ++ i ) ++ len ; return len ; }
public Shape Tile Box vertical offset ( double p dist ) { if ( p dist == NUM_ || is empty ( ) ) { return this ; } int dist = ( int ) Math . round ( p dist ) ; Pla Point Int lower left = new Pla Point Int ( box ll . v x , box ll . v y - dist ) ; Pla Point Int upper right = new Pla Point Int ( box ur . v x , box ur . v y + dist ) ; return new Shape Tile Box ( lower left , upper right ) ; }
@ Override public boolean is Cap Present ( int cap ) { return ( ( ogl Caps . get Caps ( ) & cap ) != NUM_ ) ; }
public Float Column log 1 p ( ) { Float Column new Column = Float Column . create ( name ( ) + STR_ , size ( ) ) ; for ( float value : this ) { new Column . add ( ( float ) Math . log 1 p ( value ) ) ; } return new Column ; }
public Set < String > key Set ( ) { Hash Set < String > set = new Hash Set < String > ( ) ; Iterator < String > keys = keys ( ) ; while ( keys . has Next ( ) ) { set . add ( keys . next ( ) ) ; } return set ; }
public long time Since Last ( ) { long current Time = System . current Time Millis ( ) ; return current Time - last Message Time ; }
public static long firsttick ( Geo Time Serie gts ) { if ( is Bucketized ( gts ) ) { return gts . lastbucket - ( gts . bucketcount - NUM_ ) * gts . bucketspan ; } else { long firsttick = Long . MAX VALUE ; if ( gts . sorted && gts . values > NUM_ ) { if ( ! gts . reversed ) { firsttick = gts . ticks [ NUM_ ] ; } else { firsttick = gts . ticks [ gts . values - NUM_ ] ; } } else { for ( int i = NUM_ ; i < gts . values ; i ++ ) { if ( gts . ticks [ i ] < firsttick ) { firsttick = gts . ticks [ i ] ; } } } return firsttick ; } }
public static Set wrap In Set ( Object obj ) { Set set = null ; if ( obj != null ) { set = new Hash Set ( NUM_ ) ; set . add ( obj ) ; } else { set = Collections . EMPTY SET ; } return set ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public void reboot ( ) throws Local Repository Exception { final String prefix = STR_ ; log . debug ( prefix ) ; final String [ ] cmd = { SYSTOOL CMD , SYSTOOL REBOOT } ; final Exec . Result result = Exec . sudo ( SYSTOOL TIMEOUT , cmd ) ; check Failure ( result , prefix ) ; }
public boolean exists ( ) { return do Access ( F OK ) ; }
public void request Grace Login Use Times ( ) { operations . add ( Password Policy State Operation Type . GET GRACE LOGIN USE TIMES ) ; }
public final int read Unsigned Short ( ) throws IO Exception { m Position += NUM_ ; d . read Fully ( w , NUM_ , NUM_ ) ; return ( ( w [ NUM_ ] & NUM_ ) << NUM_ | ( w [ NUM_ ] & NUM_ ) ) ; }
public Token match ( int tok ) throws Parse Exception { if ( Debug . parser Debug ) { Debug . println ( STR_ + tok ) ; } if ( tok > START && tok < END ) { if ( tok == ID ) { if ( ! starts Id ( ) ) throw new Parse Exception ( buffer + STR_ , ptr ) ; String id = get Next Id ( ) ; this . current Match = new Token ( ) ; this . current Match . token Value = id ; this . current Match . token Type = ID ; } else if ( tok == SAFE ) { if ( ! starts Safe Token ( ) ) throw new Parse Exception ( buffer + STR_ , ptr ) ; String id = ttoken Safe ( ) ; this . current Match = new Token ( ) ; this . current Match . token Value = id ; this . current Match . token Type = SAFE ; } else { String nexttok = get Next Id ( ) ; Integer cur = ( Integer ) current Lexer . get ( nexttok . to Upper Case ( ) ) ; if ( cur == null || cur . int Value ( ) != tok ) throw new Parse Exception ( buffer + STR_ + nexttok , ptr ) ; this . current Match = new Token ( ) ; this . current Match . token Value = nexttok ; this . current Match . token Type = tok ; } } else if ( tok > END ) { char next = look Ahead ( NUM_ ) ; if ( tok == DIGIT ) { if ( ! is Digit ( next ) ) throw new Parse Exception ( buffer + STR_ , ptr ) ; this . current Match = new Token ( ) ; this . current Match . token Value = String . value Of ( next ) ; this . current Match . token Type = tok ; consume ( NUM_ ) ; } else if ( tok == ALPHA ) { if ( ! is Alpha ( next ) ) throw new Parse Exception ( buffer + STR_ , ptr ) ; this . current Match = new Token ( ) ; this . current Match . token Value = String . value Of ( next ) ; this . current Match . token Type = tok ; consume ( NUM_ ) ; } } else { char ch = ( char ) tok ; char next = look Ahead ( NUM_ ) ; if ( next == ch ) { consume ( NUM_ ) ; } else throw new Parse Exception ( buffer + STR_ + ch + STR_ + next + STR_ , ptr ) ; } return this . current Match ; }
protected boolean is Type Script Annotation ( Annotation a ) { String type = a . get Type ( ) ; return ( ( type != null && type . starts With ( ORG ECLIPSE WST SSE UI TEMP ) ) ) ; }
public boolean has No Filtered Results ( ) { return ( m Search Results != null ) && m Filtered Apps . is Empty ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
@ Override public final boolean is Cap Present ( int cap ) { return ( ( ogl Caps . get Caps ( ) & cap ) != NUM_ ) ; }
public int index Of Key ( Object key ) { return index Of ( key , key . hash Code ( ) ) ; }
private boolean is Angle At Front ( double angle ) { return ( Math . sin ( Math . to Radians ( angle ) ) < NUM_ ) ; }
private boolean is Registered For Sub Orgs ( String service Name ) throws SSO Exception { Map av Pair = new Hash Map ( ) ; Set value = new Hash Set ( ) ; value . add ( service Name ) ; av Pair . put ( SERVICE STATUS ATTRIBUTE , value ) ; Set sub Orgs = null ; try { sub Orgs = search Sub Organizations ( STR_ , av Pair , SCOPE SUB ) ; } catch ( AM Exception ae ) { } if ( ( sub Orgs != null ) && ( ! sub Orgs . is Empty ( ) ) && ( sub Orgs . size ( ) > NUM_ ) ) { return true ; } else { return false ; } }
protected SQL Exception throw Unsupported Option ( String option ) throws SQL Exception { show Usage ( ) ; throw new SQL Exception ( STR_ + option ) ; }
public final Iterator < Plugin Pattern Matcher > paths Iterator ( ) { return m Data Paths != null ? m Data Paths . iterator ( ) : null ; }
public static Converter File Chooser new Converter File Chooser ( ) { Converter File Chooser result ; File Chooser Bookmarks Panel bookmarks ; result = new Converter File Chooser ( System . get Property ( STR_ ) ) ; bookmarks = new File Chooser Bookmarks Panel ( ) ; bookmarks . set Owner ( result ) ; bookmarks . set Border ( Border Factory . create Empty Border ( NUM_ , NUM_ , NUM_ , NUM_ ) ) ; result . set Accessory ( bookmarks ) ; result . set Preferred Size ( get Default Dimensions ( STR_ , NUM_ , NUM_ ) ) ; return result ; }
public Object next Meta ( ) throws JSON Exception { char c ; char q ; do { c = next ( ) ; } while ( Character . is Whitespace ( c ) ) ; switch ( c ) { case NUM_ : throw syntax Error ( STR_ ) ; case STR_ : return XML . LT ; case STR_ : return XML . GT ; case STR_ : return XML . SLASH ; case STR_ : return XML . EQ ; case STR_ : return XML . BANG ; case STR_ : return XML . QUEST ; case STR_ : case STR_ : q = c ; for ( ; ; ) { c = next ( ) ; if ( c == NUM_ ) { throw syntax Error ( STR_ ) ; } if ( c == q ) { return Boolean . TRUE ; } } default : for ( ; ; ) { c = next ( ) ; if ( Character . is Whitespace ( c ) ) { return Boolean . TRUE ; } switch ( c ) { case NUM_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : back ( ) ; return Boolean . TRUE ; } } } }
private Iterator < Processor > handle Service Loader Unavailability ( String key , Exception e ) { Java File Manager file Manager = context . get ( Java File Manager . class ) ; if ( file Manager instanceof Javac File Manager ) { Standard Java File Manager standard File Manager = ( Javac File Manager ) file Manager ; Iterable < ? extends File > working Path = file Manager . has Location ( ANNOTATION PROCESSOR PATH ) ? standard File Manager . get Location ( ANNOTATION PROCESSOR PATH ) : standard File Manager . get Location ( CLASS PATH ) ; if ( need Class Loader ( options . get ( PROCESSOR ) , working Path ) ) handle Exception ( key , e ) ; } else { handle Exception ( key , e ) ; } java . util . List < Processor > pl = Collections . empty List ( ) ; return pl . iterator ( ) ; }
public static Media Size Name find Media ( Media [ ] media , float x , float y , int units ) { if ( x <= NUM_ || y <= NUM_ || units < NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( media == null || media . length == NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } int size = NUM_ ; Media Size Name [ ] msn = new Media Size Name [ media . length ] ; for ( int i = NUM_ ; i < media . length ; i ++ ) { if ( media [ i ] instanceof Media Size Name ) { msn [ size ++ ] = ( Media Size Name ) media [ i ] ; } } if ( size == NUM_ ) { return null ; } int match = NUM_ ; double ls = x * x + y * y ; double tmp ls ; float [ ] dim ; float diffx = x ; float diffy = y ; for ( int i = NUM_ ; i < size ; i ++ ) { Media Size media Size = Media Size . get Media Size For Name ( msn [ i ] ) ; if ( media Size == null ) { continue ; } dim = media Size . get Size ( units ) ; if ( x == dim [ NUM_ ] && y == dim [ NUM_ ] ) { match = i ; break ; } else { diffx = x - dim [ NUM_ ] ; diffy = y - dim [ NUM_ ] ; tmp ls = diffx * diffx + diffy * diffy ; if ( tmp ls < ls ) { ls = tmp ls ; match = i ; } } } return msn [ match ] ; }
private int byte Index ( int index ) throws Index Out Of Bounds Exception { if ( index < NUM_ || index >= data . length * NUM_ ) { throw new Index Out Of Bounds Exception ( ) ; } else { return index / NUM_ ; } }
final Entry < K , V > remove Entry For Key ( Object key ) { int hash = ( key == null ) ? NUM_ : hash ( key ) ; int i = index For ( hash , table . length ) ; Entry < K , V > prev = table [ i ] ; Entry < K , V > e = prev ; while ( e != null ) { Entry < K , V > next = e . next ; Object k ; if ( e . hash == hash && ( ( k = e . key ) == key || ( key != null && key . equals ( k ) ) ) ) { mod Count ++ ; size -- ; if ( prev == e ) table [ i ] = next ; else prev . next = next ; e . record Removal ( this ) ; return e ; } prev = e ; e = next ; } return e ; }
public final Set < String > aliases ( ) { return Collections . unmodifiable Set ( this . aliases Set ) ; }
static int measure Indentation Units ( I Document document , int line Of Invocation Offset , int line Offset , I Java Project project ) throws Bad Location Exception { Map < ? , ? > options = project . get Options ( true ) ; String line Text = document . get ( line Offset , document . get Line Length ( line Of Invocation Offset ) ) ; int indentation Units = Indent Manipulation . measure Indent Units ( line Text , Indent Manipulation . get Tab Width ( options ) , Indent Manipulation . get Indent Width ( options ) ) ; return indentation Units ; }
public static Poll Tcp Manager Nio create ( ) { synchronized ( nio Select Manager ) { if ( nio Select Manager . get ( ) == null ) { Poll Tcp Manager Nio select Manager = new Poll Tcp Manager Nio ( ) ; if ( select Manager . start ( ) ) { nio Select Manager . set ( select Manager ) ; } } return nio Select Manager . get ( ) ; } }
public void unload ( Paragraph paragraph , String app Id ) { executor . execute ( new Unload Application ( paragraph , app Id ) ) ; }
public static String which Media Type ( String method ) { if ( method . equals Ignore Case ( Method . XML ) ) return STR_ ; if ( method . equals Ignore Case ( Method . HTML ) ) return STR_ ; if ( method . equals Ignore Case ( Method . XHTML ) ) return STR_ ; if ( method . equals Ignore Case ( Method . TEXT ) ) return STR_ ; if ( method . equals Ignore Case ( Method . FOP ) ) return STR_ ; return null ; }
public static Row Spec decode ( String encoded Row Spec , Layout Map layout Map ) { check Not Blank ( encoded Row Spec , STR_ ) ; check Not Null ( layout Map , STR_ ) ; String trimmed = encoded Row Spec . trim ( ) ; String lower = trimmed . to Lower Case ( Locale . ENGLISH ) ; return decode Expanded ( layout Map . expand ( lower , false ) ) ; }
public Boolean is Traversable ( File f ) { return Boolean . value Of ( f . is Directory ( ) ) ; }
public static Video match URL ( String url , String text ) { Matcher m = URL PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return new Video ( m . group ( NUM_ ) , text ) ; } else { return null ; } }
protected boolean needs X Embed Impl ( ) { return false ; }
public static String filename Without Extension ( I File file ) { String filename = file . get Name ( ) ; int ext Pos = filename . last Index Of ( STR_ ) ; if ( ext Pos == - NUM_ ) { return filename ; } return filename . substring ( NUM_ , ext Pos ) ; }
public static Sha 256 Hash hash File Contents ( File f ) throws IO Exception { File Input Stream in = new File Input Stream ( f ) ; try { return create ( Byte Streams . to Byte Array ( in ) ) ; } finally { in . close ( ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public String to URI ( ) { Char Array Buffer buffer = new Char Array Buffer ( NUM_ ) ; buffer . append ( this . scheme Name ) ; buffer . append ( STR_ ) ; buffer . append ( this . hostname ) ; if ( this . port != - NUM_ ) { buffer . append ( STR_ ) ; buffer . append ( Integer . to String ( this . port ) ) ; } return buffer . to String ( ) ; }
private String field Param Comment ( Field field , String param Comment , boolean is Optional ) { String comment Type = field Type Cardinality Comment ( field ) ; String field Name = lower Underscore To Lower Camel ( field . get Simple Name ( ) ) ; field Name = STR_ + field Name ; if ( is Optional ) { comment Type = comment Type + STR_ ; } return field Comment ( String . format ( STR_ , comment Type , field Name ) , param Comment , field ) ; }
public String source locations xref ( Method m ) { String out = STR_ ; List < Source Location Tag > locs = m . get Lines ( ) ; for ( Source Location Tag loc : locs ) { String cname = loc . get Clz ( ) ; int line = loc . get Line ( ) ; out += String . format ( STR_ , app source path ( cname ) , line , TARGET , cname , line ) ; } return out ; }
public static double stirling Formula ( double x ) { double STIR [ ] = { NUM_ , - NUM_ , - NUM_ , NUM_ , NUM_ } ; double MAXSTIR = NUM_ ; double w = NUM_ / x ; double y = Math . exp ( x ) ; w = NUM_ + w * polevl ( w , STIR , NUM_ ) ; if ( x > MAXSTIR ) { double v = Math . pow ( x , NUM_ * x - NUM_ ) ; y = v * ( v / y ) ; } else { y = Math . pow ( x , x - NUM_ ) / y ; } y = SQTPI * y * w ; return y ; }
private Workflow . Method delete Mirror Device Method ( URI vplex URI , URI vplex Mirror URI ) { return new Workflow . Method ( DELETE MIRROR DEVICE METHOD NAME , vplex URI , vplex Mirror URI ) ; }
public static Long Stream of ( long ... values ) { return Arrays . stream ( values ) ; }
public static Char Sequence make Bullet List ( int leading Margin , List < ? extends Char Sequence > lines ) { Truss sb = new Truss ( ) ; for ( int idx = NUM_ ; idx < lines . size ( ) ; idx ++ ) { boolean last = idx == lines . size ( ) - NUM_ ; Char Sequence line = lines . get ( idx ) ; sb . append ( line , new Bullet Span ( leading Margin / NUM_ ) , new Leading Margin Span . Standard ( leading Margin ) ) ; sb . append ( last ? STR_ : STR_ ) ; } return sb . build ( ) ; }
public static double cauchy ( ) { return Math . tan ( Math . PI * ( uniform ( ) - NUM_ ) ) ; }
static int hash ( Object x 1 , Object x 2 , Object x 3 , Object x 4 ) { int h = NUM_ ; h ^= x 1 . hash Code ( ) ; if ( x 2 != null ) { h ^= x 2 . hash Code ( ) ; } if ( x 3 != null ) { h ^= x 3 . hash Code ( ) ; } if ( x 4 != null ) { h ^= x 4 . hash Code ( ) ; } h += ~ ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; h += ( h << NUM_ ) ; h ^= ( h > > > NUM_ ) ; return h ; }
public Data Bounds calculate Projected Image Bounds ( Projection p ) { Data Bounds db = null ; if ( source Image Bounds != null ) { int pw = p . get Width ( ) ; int ph = p . get Height ( ) ; Point 2 D min = source Image Bounds . get Min ( ) ; Point 2 D max = source Image Bounds . get Max ( ) ; double x 1 = Math . floor ( min . get X ( ) ) ; double y 1 = Math . floor ( min . get Y ( ) ) ; double x 2 = Math . ceil ( max . get X ( ) ) ; double y 2 = Math . ceil ( max . get Y ( ) ) ; double width = source Image Bounds . get Width ( ) ; double height = source Image Bounds . get Height ( ) ; Lat Lon Point tmp G = new Lat Lon Point . Double ( ) ; Point 2 D tmp P = new Point 2 D . Double ( ) ; db = new Data Bounds ( ) ; db . set Hard Limits ( new Data Bounds ( NUM_ , NUM_ , pw , ph ) ) ; db . add ( p . forward ( geo Trans . inverse ( x 1 , y 1 , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( x 1 , y 2 , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( x 2 , y 1 , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( x 2 , y 2 , tmp G ) , tmp P ) ) ; double num Splits = NUM_ ; double x Spacer = width / num Splits ; double y Spacer = height / num Splits ; for ( int i = NUM_ ; i < num Splits ; i ++ ) { db . add ( p . forward ( geo Trans . inverse ( Math . ceil ( x 1 + x Spacer * i ) , y 1 , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( x 1 , Math . ceil ( y 1 + y Spacer * i ) , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( Math . ceil ( x 1 + x Spacer * i ) , y 2 , tmp G ) , tmp P ) ) ; db . add ( p . forward ( geo Trans . inverse ( x 2 , Math . ceil ( y 1 + y Spacer * i ) , tmp G ) , tmp P ) ) ; } if ( db . get Width ( ) <= NUM_ || db . get Height ( ) <= NUM_ ) { logger . fine ( STR_ + db ) ; return null ; } } return db ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . get Class ( ) == get Class ( ) && ( ( Boolean ) obj ) . value == value ; }
public static void not Found Exception ( Exception e ) { throw new Mapping Exception ( e . get Message ( ) ) ; }
private static void reject Pooling Options ( Properties p ) throws SQL Feature Not Supported Exception { if ( p . contains Key ( Data Source Factory . JDBC INITIAL POOL SIZE ) || p . contains Key ( Data Source Factory . JDBC MAX IDLE TIME ) || p . contains Key ( Data Source Factory . JDBC MAX POOL SIZE ) || p . contains Key ( Data Source Factory . JDBC MAX STATEMENTS ) || p . contains Key ( Data Source Factory . JDBC MIN POOL SIZE ) || p . contains Key ( Data Source Factory . JDBC PROPERTY CYCLE ) ) { throw new SQL Feature Not Supported Exception ( STR_ ) ; } }
private static boolean matches ( String match header , String to match ) { String [ ] match Values = match header . split ( STR_ ) ; Arrays . sort ( match Values ) ; return Arrays . binary Search ( match Values , to match ) > - NUM_ || Arrays . binary Search ( match Values , STR_ ) > - NUM_ ; }
protected double angle Between ( Point 2 D v 1 , Point 2 D v 2 ) { double x 1 = v 1 . get X ( ) ; double y 1 = v 1 . get Y ( ) ; double x 2 = v 2 . get X ( ) ; double y 2 = v 2 . get Y ( ) ; double cross = x 1 * y 2 - x 2 * y 1 ; int cw = NUM_ ; if ( cross > NUM_ ) { cw = - NUM_ ; } double angle = cw * Math . acos ( ( x 1 * x 2 + y 1 * y 2 ) / ( Math . sqrt ( x 1 * x 1 + y 1 * y 1 ) * Math . sqrt ( x 2 * x 2 + y 2 * y 2 ) ) ) ; if ( Double . is Na N ( angle ) ) { angle = NUM_ ; } return angle ; }
public static int hash Code ( int pre , double d ) { long l = Double . double To Long Bits ( d ) ; return NUM_ * pre + ( int ) ( l ^ ( l > > > NUM_ ) ) ; }
public static String join ( String separator , Object [ ] elements ) { if ( elements == null || elements . length == NUM_ ) { return STR_ ; } return join ( separator , Arrays . as List ( elements ) ) ; }
public String encoded ( ) { String Builder buf = new String Builder ( ) ; buf . append ( get Name ( ) ) ; buf . append ( STR_ ) ; buf . append ( get Value ( ) ) ; if ( get Operator ( ) != Operator . HAS ) { buf . append ( STR_ ) ; buf . append ( get Operator ( ) ) ; } return buf . to String ( ) ; }
public int num Output Sequences ( ) { return out Error Seqs . size ( ) + out Regression Seqs . size ( ) ; }
private Shape create Ellipse Internal ( int x , int y , int w , int h ) { ellipse . set Frame ( x , y , w , h ) ; return ellipse ; }
@ Override public boolean is Characters ( ) { log . log ( Level . FINE , STR_ , event == CHARACTERS ) ; return event == CHARACTERS ; }
@ Override protected double discount Impl ( final double t ) { final double r = zero Yield Impl ( t ) ; return Math . exp ( - r * t ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static boolean is Directory ( File dir ) { return dir . exists ( ) && dir . is Directory ( ) ; }
public static String truncate ( final String string , final int max Len ) { if ( string . length ( ) <= max Len ) return string ; else return string . substring ( NUM_ , max Len ) ; }
public static double incomplete Gamma ( double a , double x ) { double ans , ax , c , r ; if ( x <= NUM_ || a <= NUM_ ) { return NUM_ ; } if ( x > NUM_ && x > a ) { return NUM_ - incomplete Gamma Complement ( a , x ) ; } ax = a * Math . log ( x ) - x - ln Gamma ( a ) ; if ( ax < - MAXLOG ) { return ( NUM_ ) ; } ax = Math . exp ( ax ) ; r = a ; c = NUM_ ; ans = NUM_ ; do { r += NUM_ ; c *= x / r ; ans += c ; } while ( c / ans > MACHEP ) ; return ( ans * ax / a ) ; }
public boolean not Required Resource Name ( Policy policy , String realm Name , String name ) { get Svc Type Name To Actions Map ( policy , realm Name ) ; return not Required Resource Name Service . contains ( name ) ; }
public static Option List create Option List ( Collection collection , Locale locale , boolean b Sort ) { Option List option List = new Option List ( ) ; if ( ( collection != null ) && ! collection . is Empty ( ) ) { if ( b Sort ) { collection = AM Format Utils . sort Items ( collection , locale ) ; } for ( Iterator iter = collection . iterator ( ) ; iter . has Next ( ) ; ) { String value = ( String ) iter . next ( ) ; option List . add ( value , value ) ; } } return option List ; }
public int num Hits ( String query ) throws Parse Exception , IO Exception { Integer count ; if ( ( count = ( Integer ) m hit Count Cache . get ( query ) ) == null ) { Hits hits = search ( query ) ; count = new Integer ( hits . length ( ) ) ; m hit Count Cache . put ( query , count ) ; } return count . int Value ( ) ; }
public String string Value ( ) { if ( actual Value == null ) { return normalized Value ; } else { return actual Value . to String ( ) ; } }
private static Entry [ ] unmarshal Attributes ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { Array List attributes = new Array List ( ) ; Marshalled Instance mi = null ; while ( ( mi = ( Marshalled Instance ) in . read Object ( ) ) != null ) { try { attributes . add ( ( Entry ) mi . get ( false ) ) ; } catch ( Throwable e ) { if ( e instanceof Error && Throwable Constants . retryable ( e ) == Throwable Constants . BAD OBJECT ) { throw ( Error ) e ; } logger . log ( Level . WARNING , STR_ , e ) ; } } Entry [ ] attrs = new Entry [ attributes . size ( ) ] ; return ( Entry [ ] ) attributes . to Array ( attrs ) ; }
public double distance ( Vector 2 point ) { double dx = this . x - point . x ; double dy = this . y - point . y ; return Math . sqrt ( dx * dx + dy * dy ) ; }
public static View Action swipe Left Slow ( ) { return action With Assertions ( new General Swipe Action ( Swipe . SLOW , translate ( General Location . CENTER RIGHT , - EDGE FUZZ FACTOR , NUM_ ) , General Location . CENTER LEFT , Press . FINGER ) ) ; }
private Automaton insertions Of ( String s ) { List < Automaton > list = new Array List < > ( ) ; for ( int i = NUM_ ; i <= s . length ( ) ; i ++ ) { Automaton a = Automata . make String ( s . substring ( NUM_ , i ) ) ; a = Operations . concatenate ( a , Automata . make Any Char ( ) ) ; a = Operations . concatenate ( a , Automata . make String ( s . substring ( i ) ) ) ; list . add ( a ) ; } Automaton a = Operations . union ( list ) ; a = Minimization Operations . minimize ( a , DEFAULT MAX DETERMINIZED STATES ) ; return a ; }
@ Override public List < Column > columns ( ) { return column List ; }
private static byte [ ] expose Byte Array Input Stream Bytes ( Byte Array Input Stream bais ) { byte [ ] buffer ; synchronized ( bais ) { byte [ ] buf ; int pos ; try { buf = ( byte [ ] ) BAIS BUF . get ( bais ) ; pos = BAIS POS . get Int ( bais ) ; } catch ( Illegal Access Exception iae ) { throw new Assertion Error ( iae ) ; } int available = bais . available ( ) ; if ( pos == NUM_ && buf . length == available ) { buffer = buf ; } else { buffer = new byte [ available ] ; System . arraycopy ( buf , pos , buffer , NUM_ , available ) ; } bais . skip ( available ) ; } return buffer ; }
public static String find Java Executable For Eclipse ( ) throws Core Exception { String java Home Prop = System . get Property ( STR_ ) ; File java Home Dir = null ; if ( java Home Prop != null ) { java Home Dir = new File ( java Home Prop ) ; } if ( java Home Dir == null || ! java Home Dir . exists ( ) ) { throw new Core Exception ( new Status ( Status . ERROR , Core Plugin . PLUGIN ID , STR_ ) ) ; } File java Executable = Standard VM Type . find Java Executable ( java Home Dir ) ; if ( java Executable == null || ! java Executable . exists ( ) ) { throw new Core Exception ( new Status ( Status . ERROR , Core Plugin . PLUGIN ID , STR_ + java Home Dir . get Absolute Path ( ) + STR_ ) ) ; } return java Executable . get Absolute Path ( ) ; }
private static String trim Leading Slash ( String value ) { if ( value == null ) return STR_ ; while ( value . index Of ( STR_ ) > - NUM_ ) { value = value . substring ( value . index Of ( STR_ ) + NUM_ ) ; } return value ; }
public Shape star ( float x , float y , float height ) { float s = ( float ) ( height / ( NUM_ * Math . sin ( Math . to Radians ( NUM_ ) ) ) ) ; float short Side = ( float ) ( height / ( NUM_ * Math . tan ( Math . to Radians ( NUM_ ) ) ) ) ; float medium Side = ( float ) ( s * Math . sin ( Math . to Radians ( NUM_ ) ) ) ; float long Side = ( float ) ( s * Math . cos ( Math . to Radians ( NUM_ ) ) ) ; float inner Long Side = ( float ) ( s / ( NUM_ * Math . cos ( Math . to Radians ( NUM_ ) ) ) ) ; float inner Short Side = inner Long Side * ( float ) Math . sin ( Math . to Radians ( NUM_ ) ) ; float inner Medium Side = inner Long Side * ( float ) Math . cos ( Math . to Radians ( NUM_ ) ) ; m path . reset ( ) ; m path . move To ( x , y + short Side ) ; m path . line To ( ( x + inner Long Side ) , ( y + short Side ) ) ; m path . line To ( ( x + height / NUM_ ) , y ) ; m path . line To ( ( x + height - inner Long Side ) , ( y + short Side ) ) ; m path . line To ( ( x + height ) , ( y + short Side ) ) ; m path . line To ( ( x + height - inner Medium Side ) , ( y + short Side + inner Short Side ) ) ; m path . line To ( ( x + height - medium Side ) , ( y + height ) ) ; m path . line To ( ( x + height / NUM_ ) , ( y + short Side + long Side - inner Short Side ) ) ; m path . line To ( ( x + medium Side ) , ( y + height ) ) ; m path . line To ( ( x + inner Medium Side ) , ( y + short Side + inner Short Side ) ) ; m path . close Path ( ) ; return m path ; }
private boolean is Valid Speed ( long time , double speed , long last Location Time , double last Location Speed ) { if ( speed == NUM_ ) { return false ; } if ( Math . abs ( speed - NUM_ ) < NUM_ ) { return false ; } long time Difference = time - last Location Time ; double speed Difference = Math . abs ( last Location Speed - speed ) ; if ( speed Difference > MAX ACCELERATION * time Difference ) { return false ; } if ( speed Buffer . is Full ( ) ) { double average = speed Buffer . get Average ( ) ; double diff = Math . abs ( average - speed ) ; return ( speed < average * NUM_ ) && ( diff < MAX ACCELERATION * time Difference ) ; } else { return true ; } }
public String print Short Locale Time ( ) { date . set Time ( local Time Of Epoch ) ; if ( short Time Format == null ) short Time Format = Date Format . get Time Instance ( Date Format . SHORT ) ; return short Time Format . format ( date ) ; }
public boolean is Composite Node ( ) { return ! parts . is Empty ( ) || returns Others Output ( ) || is Root Node ( ) ; }
public boolean contains ( Detector Factory factory ) { return member Set . contains ( factory ) ; }
public static int crc ( byte [ ] bytes , int start , int end , int initial Value ) { for ( int i = start ; i < end ; i ++ ) { initial Value = ( initial Value << NUM_ ) ^ CRC 32 BYTES MSBF [ ( ( initial Value > > > NUM_ ) ^ ( bytes [ i ] & NUM_ ) ) & NUM_ ] ; } return initial Value ; }
public static String format As Generalized Time ( final Date date ) { return format As Generalized Time ( date . get Time ( ) ) ; }
private Json Writer new Json Writer ( Writer writer ) throws IO Exception { if ( generate Non Executable Json ) { writer . write ( JSON NON EXECUTABLE PREFIX ) ; } Json Writer json Writer = new Json Writer ( writer ) ; if ( pretty Printing ) { json Writer . set Indent ( STR_ ) ; } json Writer . set Serialize Nulls ( serialize Nulls ) ; return json Writer ; }
public static String file Name Clean ( String s ) { char [ ] chars = s . to Char Array ( ) ; String Builder sb = new String Builder ( ) ; for ( char c : chars ) { if ( ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || ( c == STR_ ) ) { sb . append ( c ) ; } else { if ( c == STR_ || c == STR_ ) { sb . append ( STR_ ) ; } else { sb . append ( STR_ + ( int ) c + STR_ ) ; } } } return sb . to String ( ) ; }
public static < X , Y > boolean contains Subclass ( Set < ? extends Class < ? extends Y > > classes , X superclass Instance ) { for ( Class < ? extends Y > classs : classes ) if ( classs . is Instance ( superclass Instance ) ) return true ; return false ; }
static boolean equal ( Object [ ] arr 1 , Object [ ] arr 2 ) { if ( arr 1 == arr 2 ) { return true ; } else if ( arr 1 . length != arr 2 . length ) { return false ; } for ( int i = arr 1 . length ; -- i >= NUM_ ; ) { if ( ! contains ( arr 2 , arr 2 . length , arr 1 [ i ] ) ) { return false ; } } return true ; }
public static final double correlation ( double y 1 [ ] , double y 2 [ ] , int n ) { int i ; double av 1 = NUM_ , av 2 = NUM_ , y 11 = NUM_ , y 22 = NUM_ , y 12 = NUM_ , c ; if ( n <= NUM_ ) { return NUM_ ; } for ( i = NUM_ ; i < n ; i ++ ) { av 1 += y 1 [ i ] ; av 2 += y 2 [ i ] ; } av 1 /= n ; av 2 /= n ; for ( i = NUM_ ; i < n ; i ++ ) { y 11 += ( y 1 [ i ] - av 1 ) * ( y 1 [ i ] - av 1 ) ; y 22 += ( y 2 [ i ] - av 2 ) * ( y 2 [ i ] - av 2 ) ; y 12 += ( y 1 [ i ] - av 1 ) * ( y 2 [ i ] - av 2 ) ; } if ( y 11 * y 22 == NUM_ ) { c = NUM_ ; } else { c = y 12 / Math . sqrt ( Math . abs ( y 11 * y 22 ) ) ; } return c ; }
public synchronized String to Plain ( ) { String Buffer sb = new String Buffer ( ) ; int length = size ( ) ; for ( int i = NUM_ ; i <= length ; i ++ ) { sb . append ( i ) ; sb . append ( STR_ ) ; sb . append ( get ( i - NUM_ , null ) ) ; sb . append ( STR_ ) ; } return sb . to String ( ) ; }
public int length ( ) { return names And Values . size ( ) / NUM_ ; }
public int version Minor Number ( ) { return Integer . value Of ( properties . get Property ( STR_ ) ) ; }
public String throwable To String ( ) { String Builder sb = new String Builder ( STR_ ) ; if ( throwable != null ) sb . append ( throwable . to String ( ) ) ; else sb . append ( STR_ ) ; sb . append ( STR_ ) ; return sb . to String ( ) ; }
public int read Messages ( Reader is , Outbox Amp outbox ) throws IO Exception { Objects . require Non Null ( outbox ) ; Json Reader Impl j In = new Json Reader Impl ( is , json Factory ) ; return read Messages ( j In , outbox ) ; }
public long total Bytes Size ( ) throws IO Exception { return total Merge Bytes ; }
private static boolean covers ( String [ ] sup , String [ ] sub ) { outer : for ( int i = sub . length ; i > NUM_ ; ) { String onm = sub [ -- i ] ; String ocls = sub [ -- i ] ; for ( int j = sup . length ; j > NUM_ ; ) { String nm = sup [ -- j ] ; String cls = sup [ -- j ] ; if ( cls . equals ( ocls ) && ( nm == null || ( onm != null && nm . equals ( onm ) ) ) ) { continue outer ; } } return false ; } return true ; }
public static final String to FEN ( Position pos ) { String Builder ret = new String Builder ( ) ; for ( int r = NUM_ ; r >= NUM_ ; r -- ) { int num Empty = NUM_ ; for ( int c = NUM_ ; c < NUM_ ; c ++ ) { int p = pos . get Piece ( Position . get Square ( c , r ) ) ; if ( p == Piece . EMPTY ) { num Empty ++ ; } else { if ( num Empty > NUM_ ) { ret . append ( num Empty ) ; num Empty = NUM_ ; } switch ( p ) { case Piece . WKING : ret . append ( STR_ ) ; break ; case Piece . WQUEEN : ret . append ( STR_ ) ; break ; case Piece . WROOK : ret . append ( STR_ ) ; break ; case Piece . WBISHOP : ret . append ( STR_ ) ; break ; case Piece . WKNIGHT : ret . append ( STR_ ) ; break ; case Piece . WPAWN : ret . append ( STR_ ) ; break ; case Piece . BKING : ret . append ( STR_ ) ; break ; case Piece . BQUEEN : ret . append ( STR_ ) ; break ; case Piece . BROOK : ret . append ( STR_ ) ; break ; case Piece . BBISHOP : ret . append ( STR_ ) ; break ; case Piece . BKNIGHT : ret . append ( STR_ ) ; break ; case Piece . BPAWN : ret . append ( STR_ ) ; break ; default : throw new Runtime Exception ( ) ; } } } if ( num Empty > NUM_ ) { ret . append ( num Empty ) ; } if ( r > NUM_ ) { ret . append ( STR_ ) ; } } ret . append ( pos . white Move ? STR_ : STR_ ) ; boolean any Castle = false ; if ( pos . h 1 Castle ( ) ) { ret . append ( STR_ ) ; any Castle = true ; } if ( pos . a 1 Castle ( ) ) { ret . append ( STR_ ) ; any Castle = true ; } if ( pos . h 8 Castle ( ) ) { ret . append ( STR_ ) ; any Castle = true ; } if ( pos . a 8 Castle ( ) ) { ret . append ( STR_ ) ; any Castle = true ; } if ( ! any Castle ) { ret . append ( STR_ ) ; } { ret . append ( STR_ ) ; if ( pos . get Ep Square ( ) >= NUM_ ) { int x = Position . get X ( pos . get Ep Square ( ) ) ; int y = Position . get Y ( pos . get Ep Square ( ) ) ; ret . append ( ( char ) ( x + STR_ ) ) ; ret . append ( ( char ) ( y + STR_ ) ) ; } else { ret . append ( STR_ ) ; } } ret . append ( STR_ ) ; ret . append ( pos . half Move Clock ) ; ret . append ( STR_ ) ; ret . append ( pos . full Move Counter ) ; return ret . to String ( ) ; }
public static List < Graph Change > find Hitting Set ( List < Set < Graph Change > > Forig ) { Linked List < Hs Node > current Level = new Linked List < > ( ) ; Linked List < Hs Node > next Level = new Linked List < > ( ) ; List < Graph Change > hitting Sets = new Array List < > ( ) ; List < Set < Graph Change > > F ; F = precompute ( Forig ) ; current Level . add First ( new Hs Node ( new Graph Change ( ) , NUM_ ) ) ; while ( ! current Level . is Empty ( ) ) { Hs Node n = current Level . remove First ( ) ; if ( node Redundant ( n , hitting Sets ) ) { } else { int next UC Sigma = find Next UC Sigma ( F , n ) ; if ( next UC Sigma == - NUM_ ) hitting Sets . add ( n . get Path ( ) ) ; else { n . update Label ( next UC Sigma ) ; for ( Graph Change next LC Sigma : ( F . get ( next UC Sigma ) ) ) { Graph Change new Path = new Graph Change ( n . get Path ( ) ) ; if ( new Path . is Consistent ( next LC Sigma ) ) { new Path . union ( next LC Sigma ) ; if ( path Necessary ( new Path , next Level ) ) next Level . add ( new Hs Node ( new Path , n . get Label ( ) ) ) ; } } } } if ( current Level . is Empty ( ) ) { current Level = next Level ; next Level = new Linked List < > ( ) ; } } return hitting Sets ; }
private static boolean trust Get Context Class Loader ( Thread t ) { Class cl = t . get Class ( ) ; if ( cl == Thread . class ) { return true ; } Boolean b ; synchronized ( trust Get CCL ) { b = ( Boolean ) trust Get CCL . get ( cl ) ; } if ( b == null ) { b = trust Get Context Class Loader 0 ( cl ) ; synchronized ( trust Get CCL ) { trust Get CCL . put ( cl , b ) ; } } return b . boolean Value ( ) ; }
public static boolean is String Or Similar Type ( Type type ) { if ( type instanceof Ref Type ) { Ref Type ref Type = ( Ref Type ) type ; return ref Type . equals ( Ref Type . v ( STR_ ) ) || ref Type . equals ( Ref Type . v ( STR_ ) ) || ref Type . equals ( Ref Type . v ( STR_ ) ) || ref Type . equals ( Ref Type . v ( STR_ ) ) ; } return false ; }
public Sprog Slot slot ( int i ) { return slots . get ( i ) ; }
public boolean is Cancel Visible ( ) { return m Button Cancel . is Visible ( ) ; }
public long query For Count Star ( Database Connection database Connection ) throws SQL Exception { if ( count Star Query == null ) { String Builder sb = new String Builder ( NUM_ ) ; sb . append ( STR_ ) ; database Type . append Escaped Entity Name ( sb , table Info . get Table Name ( ) ) ; count Star Query = sb . to String ( ) ; } long count = database Connection . query For Long ( count Star Query ) ; logger . debug ( STR_ , count Star Query , count ) ; return count ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Min Inst Num ( ) + STR_ + default Max Inst Num ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public Enumeration list Options ( ) { Vector new Vector = new Vector ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public boolean is Selected ( final Sensor sensor ) { return selection . contains ( sensor ) ; }
private String find Vfiler Name ( File Share fs ) { String port Group = null ; URI port = fs . get Storage Port ( ) ; if ( port == null ) { log . info ( STR_ ) ; } else { Storage Port st Port = db Client . query Object ( Storage Port . class , port ) ; if ( st Port != null ) { URI ha Domain Uri = st Port . get Storage HA Domain ( ) ; if ( ha Domain Uri == null ) { log . info ( STR_ , port ) ; } else { Storage HA Domain ha Domain = db Client . query Object ( Storage HA Domain . class , ha Domain Uri ) ; if ( ha Domain != null && ha Domain . get Virtual ( ) == true ) { port Group = st Port . get Port Group ( ) ; log . debug ( STR_ , st Port . get Port Network Id ( ) , port Group ) ; } } } } return port Group ; }
public static java . lang . String value Of ( float f ) { return Float . to String ( f ) ; }
public long diff ( ) { if ( running ) return System . current Time Millis ( ) - start Time ; else return stop Time - start Time ; }
public int un Start Size ( ) { return m Download Queue . size ( ) ; }
@ Override public Inet Socket Address ip Remote ( ) { Socket Channel s = channel ; if ( s != null ) { try { return ( Inet Socket Address ) s . get Remote Address ( ) ; } catch ( IO Exception e ) { return null ; } } else { return null ; } }
public int read Text ( char [ ] char Buffer , int char Offset , int char Length ) throws IO Exception { byte [ ] byte Buffer = is . buffer ( ) ; int byte Offset = is . offset ( ) ; int byte Length = is . length ( ) ; if ( byte Length <= byte Offset || length ( ) == NUM_ ) { if ( ! fill Frame Buffer ( ) ) { return - NUM_ ; } byte Offset = is . offset ( ) ; byte Length = is . length ( ) ; } int char End = char Offset + char Length ; int i = char Offset ; int byte Begin = byte Offset ; int byte End = ( int ) Math . min ( byte Length , byte Offset + length ( ) ) ; while ( i < char End && byte Offset < byte End ) { int d 1 = byte Buffer [ byte Offset ++ ] & NUM_ ; char ch ; if ( d 1 < NUM_ ) { ch = ( char ) d 1 ; } else if ( ( d 1 & NUM_ ) == NUM_ ) { int d 2 = byte Buffer [ byte Offset ++ ] & NUM_ ; ch = ( char ) ( ( ( d 1 & NUM_ ) << NUM_ ) + ( d 2 & NUM_ ) ) ; if ( d 2 < NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( ( d 2 & NUM_ ) != NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( ch < NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } } else if ( ( d 1 & NUM_ ) == NUM_ ) { int d 2 = byte Buffer [ byte Offset ++ ] & NUM_ ; int d 3 = byte Buffer [ byte Offset ++ ] & NUM_ ; ch = ( char ) ( ( ( d 1 & NUM_ ) << NUM_ ) + ( ( d 2 & NUM_ ) << NUM_ ) + ( d 3 & NUM_ ) ) ; if ( d 3 < NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( ( d 2 & NUM_ ) != NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( ( d 3 & NUM_ ) != NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( ch < NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( NUM_ <= ch && ch <= NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } } else if ( ( d 1 & NUM_ ) == NUM_ ) { int d 2 = byte Buffer [ byte Offset ++ ] & NUM_ ; int d 3 = byte Buffer [ byte Offset ++ ] & NUM_ ; int d 4 = byte Buffer [ byte Offset ++ ] & NUM_ ; int cp = ( ( ( d 1 & NUM_ ) << NUM_ ) + ( ( d 2 & NUM_ ) << NUM_ ) + ( ( d 3 & NUM_ ) << NUM_ ) + ( ( d 4 & NUM_ ) ) ) ; cp -= NUM_ ; char h = ( char ) ( NUM_ + ( ( cp > > NUM_ ) & NUM_ ) ) ; char Buffer [ i ++ ] = h ; ch = ( char ) ( NUM_ + ( cp & NUM_ ) ) ; if ( d 4 < NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( ( d 2 & NUM_ ) != NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( ( d 3 & NUM_ ) != NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( ( d 4 & NUM_ ) != NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( cp < NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } else if ( cp >= NUM_ ) { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } } else { close Error ( Close Codes . NOT CONSISTENT , STR_ ) ; ch = UTF 8 ERROR ; } char Buffer [ i ++ ] = ch ; } is . offset ( byte Offset ) ; length -= ( byte Offset - byte Begin ) ; return i - char Offset ; }
default < T > Seq < U > skip Until ( final Simple React Stream < T > s ) { return Eager Future Stream Functions . skip Until ( this , s ) ; }
public String stacktrace ( ) { return stacktrace ; }
public Inference Result ask ( FOL Knowledge Base KB , Sentence query ) { if ( ! ( query instanceof Atomic Sentence ) ) { throw new Illegal Argument Exception ( STR_ ) ; } List < Literal > goals = new Array List < Literal > ( ) ; goals . add ( new Literal ( ( Atomic Sentence ) query ) ) ; BC Ask Answer Handler ans Handler = new BC Ask Answer Handler ( ) ; List < List < Proof Step Bw Ch Goal > > all Proof Steps = folbcask ( KB , ans Handler , goals , new Hash Map < Variable , Term > ( ) ) ; ans Handler . set All Proof Steps ( all Proof Steps ) ; return ans Handler ; }
public Hash Map < String , String > hash Map ( ) { Hash Map < String , String > ret Map = new Hash Map < String , String > ( ) ; for ( String key : properties . key Set ( ) ) { Object value = properties . get ( key ) ; if ( value != null ) { ret Map . put ( key , value . to String ( ) ) ; } else { ret Map . put ( key , null ) ; } } return ret Map ; }
public boolean is Selected ( final Object element ) { return selection . contains ( element ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
private Json Value create Json Message ( String key , Object message ) { Json Value result = new Json Value ( new Linked Hash Map < String , Object > ( NUM_ ) ) ; try { result . put ( key , message ) ; return result ; } catch ( final Exception e ) { throw new Json Value Exception ( result ) ; } }
protected Element parent Element ( ) { return element Stack . get ( element Stack . size ( ) - NUM_ - NUM_ ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public int hash Code ( ) { return encrypted String . hash Code ( ) ; }
public static Set < Network Lite > query Network Lites ( Collection < URI > uris , Db Client db Client ) { Set < Network Lite > networks = new Hash Set < Network Lite > ( ) ; Network Lite network Lite = null ; for ( URI uri : uris ) { network Lite = get Network Lite ( uri , db Client ) ; if ( network Lite != null ) { networks . add ( network Lite ) ; } } return networks ; }
public boolean field Is Transient ( ) { return Modifier . is Transient ( field . get Modifiers ( ) ) ; }
private void copy To Buffer ( Buffer b Dest ) { if ( reassembled Data Full Size <= MAX H 264 FRAME SIZE ) { byte [ ] final Data = new byte [ reassembled Data Full Size + NUM_ ] ; int final Data Pos = NUM_ ; final Data [ final Data Pos ] = reassembled Data NAL Header ; final Data Pos += NUM_ ; int pos Current = reassembled Data Pos Seq Start ; int pos Seq = NUM_ ; while ( ( pos Current & VIDEO DECODER MAX PAYLOADS CHUNKS MASK ) != reassembled Data Pos Seq End ) { pos Seq = pos Current & VIDEO DECODER MAX PAYLOADS CHUNKS MASK ; System . arraycopy ( reassembled Data [ pos Seq ] , NUM_ , final Data , final Data Pos , reassembled Data Size [ pos Seq ] ) ; final Data Pos += reassembled Data Size [ pos Seq ] ; pos Current ++ ; } System . arraycopy ( reassembled Data [ reassembled Data Pos Seq End ] , NUM_ , final Data , final Data Pos , reassembled Data Size [ reassembled Data Pos Seq End ] ) ; b Dest . set Data ( final Data ) ; b Dest . set Length ( reassembled Data Size [ reassembled Data Pos Seq End ] ) ; b Dest . set Offset ( NUM_ ) ; b Dest . set Time Stamp ( time Stamp ) ; b Dest . set Format ( format ) ; b Dest . set Flags ( Buffer . FLAG RTP MARKER | Buffer . FLAG RTP TIME ) ; b Dest . set Video Orientation ( video Orientation ) ; b Dest . set Sequence Number ( seq Number ) ; } reassembled Data = null ; }
public long value ( int i ) { return Array . get Long ( values , i ) ; }
public Snippet Input [ ] to Array ( ) { return inputs . to Array ( new Snippet Input [ size ( ) ] ) ; }
public static int [ ] random Ints ( int max , int count ) { int [ ] vals = new int [ count ] ; for ( int i = NUM_ ; i < count ; i ++ ) vals [ i ] = SEEDED RANDOM . next Int ( max ) ; return vals ; }
public Node previous Sibling ( ) { return sibling At Offset ( - NUM_ ) ; }
public static Date days Before Now ( int num Days ) { if ( num Days <= NUM_ ) { throw new Illegal Argument Exception ( ) ; } final Calendar cal = new Gregorian Calendar ( ) ; cal . set Time ( new Date ( ) ) ; cal . add ( Calendar . DAY OF YEAR , - num Days ) ; return cal . get Time ( ) ; }
@ Suppress Warnings ( STR_ ) public < T extends PO > T first ( ) throws DB Exception { T po = null ; String sql = build SQL ( null , true ) ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , trx Name ) ; rs = create Result Set ( pstmt ) ; if ( rs . next ( ) ) { po = ( T ) table . get PO ( rs , trx Name ) ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; throw new DB Exception ( e , sql ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return po ; }
public static boolean is Data Uri ( String text ) { return text . starts With ( DATA URI PREFIX ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public static boolean is On ( String option ) { if ( args == null ) { return false ; } else { int n = NUM_ ; option = option . to Lower Case ( Locale . ENGLISH ) ; if ( args . index Of ( STR_ ) != - NUM_ ) { return true ; } else if ( ( n = args . index Of ( STR_ ) ) != - NUM_ ) { if ( args . index Of ( STR_ , n ) == - NUM_ ) { if ( ! ( option . equals ( STR_ ) || option . equals ( STR_ ) || option . equals ( STR_ ) ) ) { return true ; } } } return ( args . index Of ( option ) != - NUM_ ) ; } }
@ Override public boolean is Date Allowed ( Local Date date ) { if ( ( date . get Day Of Month ( ) >= NUM_ ) && ( date . get Day Of Month ( ) <= NUM_ ) ) { return false ; } if ( ( date . get Day Of Week ( ) == Day Of Week . SATURDAY ) && ( ( date . get Day Of Month ( ) % NUM_ ) == NUM_ ) ) { return false ; } return true ; }
@ Override protected Object convert Array ( final Object value ) { return value ; }
public static String quantityplnoun ( final int quantity , final String noun ) { final String end = plnoun ( quantity , noun ) ; return Integer . to String ( quantity ) + STR_ + end ; }
public static byte [ ] as Unsigned Byte Array ( int length , Big Integer value ) { byte [ ] bytes = value . to Byte Array ( ) ; if ( bytes [ NUM_ ] == NUM_ ) { if ( bytes . length - NUM_ > length ) { throw new Illegal Argument Exception ( STR_ ) ; } byte [ ] tmp = new byte [ length ] ; System . arraycopy ( bytes , NUM_ , tmp , tmp . length - ( bytes . length - NUM_ ) , bytes . length - NUM_ ) ; return tmp ; } else { if ( bytes . length == length ) { return bytes ; } if ( bytes . length > length ) { throw new Illegal Argument Exception ( STR_ ) ; } byte [ ] tmp = new byte [ length ] ; System . arraycopy ( bytes , NUM_ , tmp , tmp . length - bytes . length , bytes . length ) ; return tmp ; } }
final long now ( ) { return System . nano Time ( ) ; }
public int hash Code ( ) { if ( ! is Hash Code Chosen ) { if ( name != null & type != null ) fixed Hash Code = name . hash Code ( ) + NUM_ * type . hash Code ( ) ; else if ( name != null ) fixed Hash Code = name . hash Code ( ) ; else if ( type != null ) fixed Hash Code = type . hash Code ( ) ; else fixed Hash Code = NUM_ ; is Hash Code Chosen = true ; } return fixed Hash Code ; }
public double [ ] distribution For Instance ( Instance instance ) throws Exception { if ( ! m Minimize Expected Cost ) { return m Classifier . distribution For Instance ( instance ) ; } double [ ] pred = m Classifier . distribution For Instance ( instance ) ; double [ ] costs = m Cost Matrix . expected Costs ( pred , instance ) ; int class Index = Utils . min Index ( costs ) ; for ( int i = NUM_ ; i < pred . length ; i ++ ) { if ( i == class Index ) { pred [ i ] = NUM_ ; } else { pred [ i ] = NUM_ ; } } return pred ; }
protected static Vector convert To Vector ( Object [ ] an Array ) { if ( an Array == null ) { return null ; } Vector < Object > v = new Vector < Object > ( an Array . length ) ; for ( Object o : an Array ) { v . add Element ( o ) ; } return v ; }
private Map . Entry < K , V > do Remove Last Entry ( ) { for ( ; ; ) { Node < K , V > b = find Predecessor Of Last ( ) ; Node < K , V > n = b . next ; if ( n == null ) { if ( b . is Base Header ( ) ) return null ; else continue ; } for ( ; ; ) { Node < K , V > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( f != null ) { b = n ; n = f ; continue ; } if ( ! n . cas Value ( v , null ) ) break ; K key = n . key ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find Node ( key ) ; else { find Predecessor ( key , comparator ) ; if ( head . right == null ) try Reduce Level ( ) ; } @ Suppress Warnings ( STR_ ) V vv = ( V ) v ; return new Abstract Map . Simple Immutable Entry < K , V > ( key , vv ) ; } } }
public final boolean is Managing Focus ( ) { return false ; }
String encoded Password ( ) { if ( password . is Empty ( ) ) return STR_ ; int password Start = url . index Of ( STR_ , scheme . length ( ) + NUM_ ) + NUM_ ; int password End = url . index Of ( STR_ ) ; return url . substring ( password Start , password End ) ; }
private int adjust Column ( int row , int col ) { if ( col < NUM_ ) { return NUM_ ; } if ( row == get Row Count ( ) - NUM_ ) { int last Row Count = model . get Byte Count ( ) % NUM_ ; if ( last Row Count == NUM_ ) { last Row Count = NUM_ ; } if ( last Row Count < NUM_ ) { return Math . min ( col , ( model . get Byte Count ( ) % NUM_ ) - NUM_ ) ; } } return Math . min ( col , get Column Count ( ) - NUM_ - NUM_ ) ; }
public boolean check Root By Build Tags ( ) { String build Tags = android . os . Build . TAGS ; if ( build Tags != null && build Tags . contains ( SU TAG ) ) { if ( Constants . DEBUG MODE ENABLED ) { Log . d ( TAG , STR_ ) ; } return true ; } return false ; }
public static Long to Millisec ( String datestring , String format ) { Date date = parse ( datestring , format ) ; if ( date == null ) { return null ; } return date . get Time ( ) ; }
public Set < Byte String > keys ( Byte String namespace ) { if ( namespace != null ) { Set Multimap < Byte String , Byte String > namespace Data = contents . get ( namespace ) ; if ( namespace Data != null ) { return namespace Data . key Set ( ) ; } } return Collections . empty Set ( ) ; }
public double distance From ( Connection other ) { int x Diff = m Position . x - other . get Position ( ) . x ; int y Diff = m Position . y - other . get Position ( ) . y ; return Math . sqrt ( x Diff * x Diff + y Diff * y Diff ) ; }
public void await Termination ( ) throws Interrupted Exception { do { logger . info ( STR_ ) ; } while ( ! executor . await Termination ( NUM_ , Time Unit . SECONDS ) ) ; logger . info ( STR_ ) ; }
public < T extends PO > PO Result Set < T > scroll ( ) throws DB Exception { String sql = build SQL ( null , true ) ; Prepared Statement pstmt = null ; Result Set rs = null ; PO Result Set < T > rs PO = null ; try { pstmt = DB . prepare Statement ( sql , trx Name ) ; rs = create Result Set ( pstmt ) ; rs PO = new PO Result Set < T > ( table , pstmt , rs , trx Name ) ; rs PO . set Close On Error ( true ) ; return rs PO ; } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; throw new DB Exception ( e , sql ) ; } finally { if ( rs PO == null ) { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } } }
private double manhattan Segmental Distance ( Number Vector o 1 , Number Vector o 2 , long [ ] dimensions ) { double result = NUM_ ; int card = NUM_ ; for ( int d = Bits Util . next Set Bit ( dimensions , NUM_ ) ; d >= NUM_ ; d = Bits Util . next Set Bit ( dimensions , d + NUM_ ) ) { result += Math . abs ( o 1 . double Value ( d ) - o 2 . double Value ( d ) ) ; ++ card ; } result /= card ; return result ; }
public Shape create Scroll Button Together Decrease ( int x , int y , int w , int h ) { path . reset ( ) ; path . move To ( x + w , y ) ; path . line To ( x + w , y + h ) ; path . line To ( x , y + h ) ; add Scroll Gap Path ( x , y , w , h , false ) ; path . close Path ( ) ; return path ; }
private boolean is Before End ( Fast Concurrent Skip List Map . Node < K , V > n ) { if ( n == null ) return false ; if ( hi == null ) return true ; K k = n . key ; if ( k == null ) return true ; int c = m . compare ( k , hi ) ; if ( c > NUM_ || ( c == NUM_ && ! hi Inclusive ) ) return false ; return true ; }
public Collection < Grid Client Topology Listener > topology Listeners ( ) { return Collections . unmodifiable Collection ( top Lsnrs ) ; }
public static Date string To Date ( String str Date ) throws Parse Exception { int [ ] diff Time = null ; boolean plus Time = true ; int idx T = str Date . index Of ( STR_ ) ; if ( idx T == - NUM_ ) { throw new Parse Exception ( STR_ , NUM_ ) ; } int idx Diff UTC = str Date . index Of ( STR_ , idx T ) ; if ( idx Diff UTC == - NUM_ ) { idx Diff UTC = str Date . index Of ( STR_ , idx T ) ; plus Time = false ; } if ( idx Diff UTC != - NUM_ ) { diff Time = get Diff Time ( str Date , idx Diff UTC ) ; str Date = str Date . substring ( NUM_ , idx Diff UTC ) ; } int idx Milli Sec = str Date . index Of ( STR_ ) ; if ( idx Milli Sec != - NUM_ ) { str Date = str Date . substring ( NUM_ , idx Milli Sec ) ; } else { char last Char = str Date . char At ( str Date . length ( ) - NUM_ ) ; if ( ( last Char == STR_ ) || ( last Char == STR_ ) ) { str Date = str Date . substring ( NUM_ , str Date . length ( ) - NUM_ ) ; } } return create Date ( str Date , diff Time , plus Time ) ; }
@ Deprecated public static float [ ] combine ( float [ ] x , float [ ] y ) { int len = NUM_ ; if ( x != null ) len += x . length ; if ( y != null ) len += y . length ; float [ ] z = null ; if ( len > NUM_ ) { z = new float [ len ] ; int current Pos = NUM_ ; if ( x != null ) { System . arraycopy ( x , NUM_ , z , current Pos , x . length ) ; current Pos = x . length ; } if ( y != null ) System . arraycopy ( y , NUM_ , z , current Pos , y . length ) ; } return z ; }
public synchronized boolean should Execute ( Key Select key Select ) { if ( slow Queries == null ) return true ; String query Key = key Select . generate Key ( ) ; Long pending Query Invocation = pending Queries . get ( query Key ) ; if ( pending Query Invocation != null ) { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ + query Key ) ; } return false ; } Long slow Query Invocation = slow Queries . get ( query Key ) ; if ( slow Query Invocation != null ) { key Select . set Last Invocation ( slow Query Invocation ) ; long since Last Millis = System . current Time Millis ( ) - slow Query Invocation ; if ( since Last Millis < ( slow Query Cache Duration * NUM_ ) ) { slow Queries . put ( query Key , System . current Time Millis ( ) ) ; return false ; } } pending Queries . put ( query Key , System . current Time Millis ( ) ) ; return true ; }
public static Font [ ] filter Monospaced ( Font ... fonts ) { List < Font > result = new Array List < Font > ( fonts . length ) ; for ( Font font : fonts ) { if ( is Font Monospaced ( font ) ) { result . add ( font ) ; } } return result . to Array ( new Font [ result . size ( ) ] ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
private static int parse Numeric Font Weight ( String font Weight String ) { return font Weight String . length ( ) == NUM_ && font Weight String . ends With ( STR_ ) && font Weight String . char At ( NUM_ ) <= STR_ && font Weight String . char At ( NUM_ ) >= STR_ ? NUM_ * ( font Weight String . char At ( NUM_ ) - STR_ ) : - NUM_ ; }
public int hash Code ( ) { int hash = NUM_ ; for ( Annotation Member element : elements ) { hash += element . hash Code ( ) ; } return hash ; }
public Optional < String > full Method ( ) { return Optional . of Nullable ( full Method Arg ) ; }
private boolean check Server Prefixes ( final String server ) { boolean accept = false ; if ( prefixes == null ) { accept = true ; } else { for ( String prefix : prefixes . split ( STR_ ) ) { if ( server . starts With ( prefix ) ) { accept = true ; break ; } } } if ( ! accept ) { LOGGER . warn ( STR_ , server , prefixes ) ; } return accept ; }
public Boolean is In Relation Service ( ) { return my In Rel Serv Flg . get ( ) ; }
public static Type for Value ( Object value ) { return Type . for Class ( value . get Class ( ) ) ; }
public static String extract File Set From Path ( String resource ) { String [ ] splits = resource . split ( STR_ ) ; if ( splits . length <= NUM_ ) { Stats . incr ( STR_ ) ; return null ; } return splits [ splits . length - NUM_ ] ; }
private static boolean has Ties ( double [ ] x , double [ ] y ) { final Hash Set < Double > values = new Hash Set < Double > ( ) ; for ( int i = NUM_ ; i < x . length ; i ++ ) { if ( ! values . add ( x [ i ] ) ) { return true ; } } for ( int i = NUM_ ; i < y . length ; i ++ ) { if ( ! values . add ( y [ i ] ) ) { return true ; } } return false ; }
private boolean is Parent Loader ( Class Loader parent , Class Loader child ) { for ( ; child != null ; child = child . get Parent ( ) ) { if ( child == parent ) return true ; } return false ; }
public < V extends Comparable < ? super V > > Optional Int max By ( Int Function < V > key Extractor ) { Obj Int Box < V > result = collect ( null , null , null ) ; return result . a == null ? Optional Int . empty ( ) : Optional Int . of ( result . b ) ; }
public Json Writer new Json Writer ( Writer writer ) throws IO Exception { if ( generate Non Executable Json ) { writer . write ( JSON NON EXECUTABLE PREFIX ) ; } Json Writer json Writer = new Json Writer ( writer ) ; if ( pretty Printing ) { json Writer . set Indent ( STR_ ) ; } json Writer . set Serialize Nulls ( serialize Nulls ) ; return json Writer ; }
private Set merge Set ( Set < String > set 1 , Set < String > set 2 ) { if ( set 1 == null || set 1 . is Empty ( ) ) { if ( set 2 == null || set 2 . is Empty ( ) ) { return Collections . EMPTY SET ; } else { return set 2 ; } } else { if ( set 2 == null || set 2 . is Empty ( ) ) { return set 1 ; } else { Set < String > return Set = new Hash Set < String > ( set 1 ) ; return Set . add All ( set 2 ) ; return return Set ; } } }
final void type Check ( E e ) { Class < ? > e Class = e . get Class ( ) ; if ( e Class != element Type && e Class . get Superclass ( ) != element Type ) throw new Class Cast Exception ( e Class + STR_ + element Type ) ; }
@ Override protected Size 2 D arrange RR ( Graphics 2 D g 2 , Range width Range , Range height Range ) { g 2 . set Font ( get Font ( ) ) ; Font Metrics fm = g 2 . get Font Metrics ( get Font ( ) ) ; Rectangle 2 D bounds = Text Utilities . get Text Bounds ( get Text ( ) , g 2 , fm ) ; if ( bounds . get Width ( ) <= width Range . get Upper Bound ( ) && bounds . get Height ( ) <= height Range . get Upper Bound ( ) ) { return new Size 2 D ( bounds . get Width ( ) , bounds . get Height ( ) ) ; } else { return new Size 2 D ( NUM_ , NUM_ ) ; } }
private boolean remove Lease In Renew ( Entry e ) { int index = lease In Renew . index Of ( e ) ; if ( index < NUM_ ) return false ; lease In Renew . remove ( index ) ; return true ; }
public boolean show Card ( String tag , boolean dismissible ) { final Card card = m Hidden Cards . get ( tag ) ; if ( card != null && ! m Visible Cards . contains Value ( tag ) ) { m Hidden Cards . remove ( tag ) ; m Visible Cards . put ( tag , card ) ; m Layout . add Card ( card . get View ( ) , dismissible ) ; if ( dismissible ) { m Dismissible Cards . add ( tag ) ; } return true ; } return false ; }
@ Override public Segment intersect ( long from , long to ) { long start = Math . max ( from , this . segment Start ) ; long end = Math . min ( to , this . segment End ) ; if ( start <= end ) { return new Segment Range ( start , end ) ; } else { return null ; } }
private static String build Java Source Hyperlink ( String java Source Address , String text ) { if ( java Source Address == null ) { return convert To Html Content ( text ) ; } String Buffer buf = new String Buffer ( ) ; buf . append ( STR_ ) ; buf . append ( JAVA SOURCE URL PREFIX ) ; try { buf . append ( URL Encoder . encode ( java Source Address , STR_ ) ) ; } catch ( Unsupported Encoding Exception e ) { buf . append ( java Source Address ) ; } buf . append ( STR_ ) ; buf . append ( convert To Html Content ( text ) ) ; buf . append ( STR_ ) ; return buf . to String ( ) ; }
@ Override public Iterator < Expression > iterator ( ) { return expressions . iterator ( ) ; }
public static long hours Ago ( int hours ) { long time In Millis = hours * Date Utils . HOUR IN MILLIS ; return System . current Time Millis ( ) - time In Millis ; }
public T element ( int i ) { return elements . get ( i ) ; }
public static Big Fraction parse Aspect Ratio ( String aspect Ratio ) { String [ ] parts = aspect Ratio . split ( STR_ ) ; try { if ( parts . length == NUM_ ) { return new Big Fraction ( Long . parse Long ( parts [ NUM_ ] ) , Long . parse Long ( parts [ NUM_ ] ) ) ; } else if ( parts . length == NUM_ ) { return new Big Fraction ( Long . parse Long ( parts [ NUM_ ] ) ) ; } } catch ( Number Format Exception e ) { throw new Conversion Helper Exception ( STR_ , e ) ; } throw new Conversion Helper Exception ( STR_ ) ; }
public static boolean has Token Information ( Bundle bundle ) { if ( bundle == null ) { return false ; } String token = bundle . get String ( TOKEN KEY ) ; if ( ( token == null ) || ( token . length ( ) == NUM_ ) ) { return false ; } long expires Milliseconds = bundle . get Long ( EXPIRATION DATE KEY , NUM_ ) ; if ( expires Milliseconds == NUM_ ) { return false ; } return true ; }
@ Override public int hash Code ( ) { int result = NUM_ ; Iterator < ? > it = iterator ( ) ; while ( it . has Next ( ) ) { Object next = it . next ( ) ; result += next == null ? NUM_ : next . hash Code ( ) ; } return result ; }
public Set < Map . Entry < String , Json Element > > entry Set ( ) { return Collections . unmodifiable Set ( members . entry Set ( ) ) ; }
@ Suppress Warnings ( { STR_ , STR_ } ) public static String regex Error ( String s , int groups ) { try { Pattern p = Pattern . compile ( s ) ; int actual Groups = get Group Count ( p ) ; if ( actual Groups < groups ) { return regex Error Message ( s , groups , actual Groups ) ; } } catch ( Pattern Syntax Exception e ) { return e . get Message ( ) ; } return null ; }
public static < S , K , V > Collector < S , ? , Linked Hash Map < K , V > > to Linked Map ( Function < ? super S , ? extends K > key Mapper , Function < ? super S , ? extends V > value Mapper ) { return Collectors . to Map ( key Mapper , value Mapper , Stream Utils . throwing Merger ( ) , null ) ; }
static public Timestamp add Months ( Timestamp day , int offset ) { if ( day == null ) day = new Timestamp ( System . current Time Millis ( ) ) ; Gregorian Calendar cal = new Gregorian Calendar ( ) ; cal . set Time ( day ) ; cal . set ( Calendar . HOUR OF DAY , NUM_ ) ; cal . set ( Calendar . MINUTE , NUM_ ) ; cal . set ( Calendar . SECOND , NUM_ ) ; cal . set ( Calendar . MILLISECOND , NUM_ ) ; if ( offset == NUM_ ) return new Timestamp ( cal . get Time In Millis ( ) ) ; cal . add ( Calendar . MONTH , offset ) ; return new Timestamp ( cal . get Time In Millis ( ) ) ; }
public static String format ( double [ ] v , int w , int d ) { Decimal Format format = new Decimal Format ( ) ; format . set Decimal Format Symbols ( new Decimal Format Symbols ( Locale . US ) ) ; format . set Minimum Integer Digits ( NUM_ ) ; format . set Maximum Fraction Digits ( d ) ; format . set Minimum Fraction Digits ( d ) ; format . set Grouping Used ( false ) ; int width = w + NUM_ ; String Builder msg = new String Builder ( ) ; msg . append ( STR_ ) ; for ( int i = NUM_ ; i < v . length ; i ++ ) { String s = format . format ( v [ i ] ) ; int padding = Math . max ( NUM_ , width - s . length ( ) ) ; for ( int k = NUM_ ; k < padding ; k ++ ) { msg . append ( STR_ ) ; } msg . append ( s ) ; } return msg . to String ( ) ; }
public List < Comment Info > integrate ( List < Comment Info > comments , JC Compilation Unit unit ) { List < Comment Info > out = new Array List < Comment Info > ( ) ; Comment Info last Excised Comment = null ; JC Tree last Node = null ; for ( Comment Info cmt : comments ) { if ( ! cmt . is Javadoc ( ) ) { out . add ( cmt ) ; continue ; } JC Tree node = find Javadocable Node On Or After ( unit , cmt . end Pos ) ; if ( node == null ) { out . add ( cmt ) ; continue ; } if ( node == last Node ) { out . add ( last Excised Comment ) ; } if ( ! attach ( unit , node , cmt ) ) { out . add ( cmt ) ; } else { last Node = node ; last Excised Comment = cmt ; } } return out ; }
public static < T extends Generic Entity > List < T > filter By And ( List < T > values , Map < String , ? extends Object > fields ) { if ( values == null ) return null ; List < T > result = null ; if ( Util Validate . is Empty ( fields ) ) { result = new Linked List < T > ( ) ; result . add All ( values ) ; } else { result = new Linked List < T > ( ) ; for ( T value : values ) { if ( value . matches Fields ( fields ) ) { result . add ( value ) ; } } } return result ; }
@ Override public int number Of Clusters ( ) throws Exception { if ( m num clusters == - NUM_ ) { throw new Exception ( STR_ ) ; } return m num clusters ; }
public final String to Base 58 ( ) { byte [ ] address Bytes = new byte [ NUM_ + bytes . length + NUM_ ] ; address Bytes [ NUM_ ] = ( byte ) version ; System . arraycopy ( bytes , NUM_ , address Bytes , NUM_ , bytes . length ) ; byte [ ] checksum = Sha 256 Hash . hash Twice ( address Bytes , NUM_ , bytes . length + NUM_ ) ; System . arraycopy ( checksum , NUM_ , address Bytes , bytes . length + NUM_ , NUM_ ) ; return Base 58 . encode ( address Bytes ) ; }
public static < V > Map < String , V > remove Multi Form Parameters ( Map < String , V > parameters ) { Map < String , V > filtered Parameters = new Hash Map < String , V > ( ) ; for ( Map . Entry < String , V > entry : parameters . entry Set ( ) ) { String key = entry . get Key ( ) ; if ( key != null && ( key . index Of ( MULTI ROW DELIMITER ) != - NUM_ || key . index Of ( STR_ ) != - NUM_ || key . index Of ( STR_ ) != - NUM_ ) ) { continue ; } filtered Parameters . put ( key , entry . get Value ( ) ) ; } return filtered Parameters ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof Group == false ) { return false ; } Group another = ( Group ) obj ; return group . equals ( another . to String ( ) ) ; }
public Buffer Iterator little Endian Iterator ( ) { return new Nio Buffer Iterator ( address , ( int ) size , Byte Order . native Order ( ) != Byte Order . LITTLE ENDIAN ) ; }
public List < Dexlib Abstract Instruction > instructions Before ( Dexlib Abstract Instruction instruction ) { int i = instructions . index Of ( instruction ) ; if ( i == - NUM_ ) throw new Illegal Argument Exception ( STR_ + instruction + STR_ ) ; List < Dexlib Abstract Instruction > l = new Array List < Dexlib Abstract Instruction > ( ) ; l . add All ( instructions . sub List ( NUM_ , i ) ) ; Collections . reverse ( l ) ; return l ; }
private Set < Storage Port > and Not Storage Ports ( Set < Storage Port > a , Set < String > b ) { Set < Storage Port > result = new Hash Set < Storage Port > ( ) ; for ( Storage Port port : a ) { if ( ! b . contains ( port . get Port Network Id ( ) ) ) { result . add ( port ) ; } } return result ; }
@ Override @ Suppress Warnings ( STR_ ) public synchronized < T > T [ ] to Array ( T [ ] contents ) { if ( element Count > contents . length ) { throw new Runtime Exception ( STR_ ) ; } System . arraycopy ( element Data , NUM_ , contents , NUM_ , element Count ) ; if ( element Count < contents . length ) { contents [ element Count ] = null ; } return contents ; }
public boolean is Empty ( ) { return window . is Empty ( ) ; }
private static boolean check Name ( Editable Resources r , String name ) { for ( String n : r . get Resource Names ( ) ) { if ( n . equals ( name ) ) { return true ; } } return false ; }
public static int index Of Whitespace ( String string ) { return index Of Whitespace ( string , NUM_ , string . length ( ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( NUM_ ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public boolean contains ( Data Source source ) { return sources . contains ( source ) ; }
public boolean is Empty ( ) { return events . is Empty ( ) ; }
public static RCFG v ( ) { if ( v == null ) v = new RCFG ( ) ; return v ; }
public int size ( ) { return parameters . size ( ) ; }
public String next Token ( ) { current Position = ( new Position >= NUM_ && ! delims Changed ) ? new Position : skip Delimiters ( current Position ) ; delims Changed = false ; new Position = - NUM_ ; if ( current Position >= max Position ) throw new No Such Element Exception ( ) ; int start = current Position ; current Position = scan Token ( current Position ) ; return str . substring ( start , current Position ) ; }
public boolean accept Filename Identical ( String file Name ) { return accept Identical ( null , file Name ) ; }
public static int digit ( char ch , int radix ) { return digit ( ( int ) ch , radix ) ; }
public static boolean is Absolute Path ( String system Id ) { if ( system Id == null ) return false ; final File file = new File ( system Id ) ; return file . is Absolute ( ) ; }
public long millis ( ) { long elapsed = elapsed Time ; if ( base Time != NUM_ ) { elapsed += System . current Time Millis ( ) - base Time ; } return elapsed ; }
@ Override @ Suppress Warnings ( STR_ ) public < T > T [ ] to Array ( T [ ] array ) { if ( array . length < size ) { Class array Type = array . get Class ( ) ; T [ ] copy = ( array Type == Object [ ] . class ) ? ( T [ ] ) new Object [ size ] : ( T [ ] ) Array . new Instance ( array Type . get Component Type ( ) , size ) ; System . arraycopy ( buffer , start , copy , NUM_ , size ) ; return copy ; } System . arraycopy ( buffer , start , array , NUM_ , size ) ; if ( array . length > size ) { array [ size ] = null ; } return array ; }
private Derivation State lazy K Best Extract On Node ( K Best Extractor kbest Extractor , int k ) { if ( nbests . size ( ) >= k ) { return nbests . get ( k - NUM_ ) ; } Derivation State derivation State = null ; if ( null == cand Heap ) { get Candidates ( kbest Extractor ) ; } int t Added = NUM_ ; while ( nbests . size ( ) < k ) { if ( cand Heap . size ( ) > NUM_ ) { derivation State = cand Heap . poll ( ) ; if ( extract Unique Nbest ) { final String res str = derivation State . get Hypothesis ( ) ; if ( ! unique Strings Table . contains ( res str ) ) { nbests . add ( derivation State ) ; unique Strings Table . add ( res str ) ; } } else { nbests . add ( derivation State ) ; } lazy Next ( kbest Extractor , derivation State ) ; t Added ++ ; if ( ! extract Unique Nbest && t Added > NUM_ ) { throw new Runtime Exception ( STR_ + k ) ; } } else { break ; } } if ( nbests . size ( ) < k ) { derivation State = null ; } return derivation State ; }
private static Char Handler parse Unprintable Codes ( String [ ] code Strings ) { if ( code Strings . length != NUM_ ) { throw new Illegal State Exception ( STR_ + Arrays . as List ( code Strings ) ) ; } return new Unprintable Char Handler ( codes To Bytes ( code Strings [ NUM_ ] , true ) ) ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( event Name . compare To ( STR_ ) == NUM_ && ( m training Provider != null || m data Provider != null || m instance Provider != null ) ) { return false ; } if ( event Name . compare To ( STR_ ) == NUM_ && m test Provider != null ) { return false ; } if ( event Name . compare To ( STR_ ) == NUM_ && m instance Provider != null || m training Provider != null || m data Provider != null ) { return false ; } return true ; }
public long long ( ) { return m value . long Value ( ) ; }
public int length ( ) { return m List . size ( ) ; }
public boolean is Tokenized ( ) { return ( properties & TOKENIZED ) != NUM_ ; }
public boolean is Property Matching ( Single Property < ? > updated Property ) { return property . equals ( updated Property . get Logical Name ( ) ) ; }
public boolean load In Background ( In Bitmap Provider bitmap Provider ) { Exif Interface ei = new Exif Interface ( ) ; if ( read Exif ( ei ) ) { Integer ori = ei . get Tag Int Value ( Exif Interface . TAG ORIENTATION ) ; if ( ori != null ) { m Rotation = Exif Interface . get Rotation For Orientation Value ( ori . short Value ( ) ) ; } } m Decoder = load Bitmap Region Decoder ( ) ; if ( m Decoder == null ) { m State = State . ERROR LOADING ; return false ; } else { int width = m Decoder . get Width ( ) ; int height = m Decoder . get Height ( ) ; Bitmap Factory . Options opts = new Bitmap Factory . Options ( ) ; opts . in Preferred Config = Bitmap . Config . ARGB 8888 ; opts . in Prefer Quality Over Speed = true ; float scale = ( float ) MAX PREVIEW SIZE / Math . max ( width , height ) ; opts . in Sample Size = Bitmap Utils . compute Sample Size Larger ( scale ) ; opts . in Just Decode Bounds = false ; opts . in Mutable = true ; if ( bitmap Provider != null ) { int expected Pixles = ( width / opts . in Sample Size ) * ( height / opts . in Sample Size ) ; Bitmap reusable Bitmap = bitmap Provider . for Pixel Count ( expected Pixles ) ; if ( reusable Bitmap != null ) { opts . in Bitmap = reusable Bitmap ; try { m Preview = load Preview Bitmap ( opts ) ; } catch ( Illegal Argument Exception e ) { Log . d ( TAG , STR_ , e ) ; opts . in Bitmap = null ; m Preview = null ; } } } if ( m Preview == null ) { m Preview = load Preview Bitmap ( opts ) ; } if ( m Preview == null ) { m State = State . ERROR LOADING ; return false ; } try { GL Utils . get Internal Format ( m Preview ) ; GL Utils . get Type ( m Preview ) ; m State = State . LOADED ; } catch ( Illegal Argument Exception e ) { Log . d ( TAG , STR_ , e ) ; m State = State . ERROR LOADING ; } return m State == State . LOADED ; } }
public static String [ ] chars ( final String value ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; return value . split ( STR_ ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public int index Of ( Object obj ) { final List < Node > l ; synchronized ( this ) { l = this . list ; } return l . index Of ( obj ) ; }
private List < String > missing Weapons ( final Player player , final boolean hash ) { final List < String > result = new Linked List < String > ( ) ; String done Text = player . get Quest ( QUEST SLOT ) ; if ( done Text == null ) { done Text = STR_ ; } final List < String > done = Arrays . as List ( done Text . split ( STR_ ) ) ; for ( String weapon : needed Weapons ) { if ( ! done . contains ( weapon ) ) { if ( hash ) { weapon = STR_ + weapon ; } result . add ( weapon ) ; } } return result ; }
public String equations To String ( Number Format nf ) { return equations To String ( STR_ , nf ) ; }
public static Byte String value Of Base 64 ( final String s ) { if ( s . length ( ) == NUM_ ) { return EMPTY ; } return Base 64 . decode ( s ) ; }
private Node < K , V > find Node ( Comparable < ? super K > key ) { for ( ; ; ) { Node < K , V > b = find Predecessor ( key ) ; Node < K , V > n = b . next ; for ( ; ; ) { if ( n == null ) return null ; Node < K , V > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compare To ( n . key ) ; if ( c == NUM_ ) return n ; if ( c < NUM_ ) return null ; b = n ; n = f ; } } }
protected int sizeof ( Object o ) throws Illegal Argument Exception { return Mem LRU Capacity Controller . basic Sizeof ( o , this . sizer ) ; }
public int last Index Of ( java . lang . Char Sequence csq ) { return last Index Of ( csq , count ) ; }
public String to Json ( ) { build ( ) ; try { return Json Serializer . to String ( this ) ; } catch ( IO Exception e ) { throw new Index Exception ( e , STR_ , e . get Message ( ) ) ; } }
public static org . omg . CORBA . Object remote To Corba ( Remote remote Obj , ORB orb ) throws Class Not Found Exception , Configuration Exception { synchronized ( Corba Utils . class ) { if ( to Stub Method == null ) { init Method Handles ( ) ; } } java . lang . Object stub ; try { stub = to Stub Method . invoke ( null , new java . lang . Object [ ] { remote Obj } ) ; } catch ( Invocation Target Exception e ) { Throwable real Exception = e . get Target Exception ( ) ; Configuration Exception ce = new Configuration Exception ( STR_ ) ; ce . set Root Cause ( real Exception ) ; throw ce ; } catch ( Illegal Access Exception e ) { Configuration Exception ce = new Configuration Exception ( STR_ ) ; ce . set Root Cause ( e ) ; throw ce ; } if ( ! corba Stub Class . is Instance ( stub ) ) { return null ; } try { connect Method . invoke ( stub , new java . lang . Object [ ] { orb } ) ; } catch ( Invocation Target Exception e ) { Throwable real Exception = e . get Target Exception ( ) ; if ( ! ( real Exception instanceof java . rmi . Remote Exception ) ) { Configuration Exception ce = new Configuration Exception ( STR_ ) ; ce . set Root Cause ( real Exception ) ; throw ce ; } } catch ( Illegal Access Exception e ) { Configuration Exception ce = new Configuration Exception ( STR_ ) ; ce . set Root Cause ( e ) ; throw ce ; } return ( org . omg . CORBA . Object ) stub ; }
public static void close Silently ( Connection conn ) { if ( conn != null ) { try { conn . close ( ) ; } catch ( SQL Exception e ) { } } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
@ Override public int height ( ) { return is Prone ( ) ? NUM_ : is Super Heavy ( ) ? NUM_ : NUM_ ; }
@ Override public boolean event Generatable ( String event Name ) { if ( event Name . compare To ( STR_ ) == NUM_ ) { if ( ! ( m Loader instanceof weka . core . converters . Incremental Converter ) ) { return false ; } if ( m data Set Event Targets > NUM_ ) { return false ; } } if ( event Name . compare To ( STR_ ) == NUM_ ) { if ( ! ( m Loader instanceof weka . core . converters . Batch Converter ) ) { return false ; } if ( m instance Event Targets > NUM_ ) { return false ; } } return true ; }
public void readable To Indexed ( Char Sequence val , Bytes Ref result ) { final String internal = readable To Indexed ( val . to String ( ) ) ; Unicode Util . UTF 16 to UTF 8 ( internal , result ) ; }
public static < T extends Throwable > void throw If Instance Of ( Throwable t , Class < T > cls ) throws T { if ( cls . is Instance ( t ) ) { throw cls . cast ( t ) ; } }
public List < String > names ( ) { return Collections . unmodifiable List ( names ) ; }
public static Test suite ( ) { return new Test Suite ( Merge Many Values Test . class ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new Option ( STR_ + default Amplitude ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Min Range ( ) + STR_ + default Max Range ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Noise Rate ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Noise Variance ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public static Number asin ( Number a ) { return Math . asin ( a . double Value ( ) ) ; }
private Dimension layout Size ( Container target , boolean preferred ) { synchronized ( target . get Tree Lock ( ) ) { int target Width = target . get Size ( ) . width ; if ( target Width == NUM_ ) { target Width = Integer . MAX VALUE ; } int hgap = get Hgap ( ) ; int vgap = get Vgap ( ) ; Insets insets = target . get Insets ( ) ; int horizontal Insets And Gap = insets . left + insets . right + hgap * NUM_ ; int max Width = target Width - horizontal Insets And Gap ; Dimension dim = new Dimension ( NUM_ , NUM_ ) ; int row Width = NUM_ ; int row Height = NUM_ ; int nmembers = target . get Component Count ( ) ; for ( int i = NUM_ ; i < nmembers ; i ++ ) { Component m = target . get Component ( i ) ; if ( m . is Visible ( ) ) { Dimension d = preferred ? m . get Preferred Size ( ) : m . get Minimum Size ( ) ; if ( row Width + d . width > max Width ) { add Row ( dim , row Width , row Height ) ; row Width = NUM_ ; row Height = NUM_ ; } if ( row Width != NUM_ ) { row Width += hgap ; } row Width += d . width ; row Height = Math . max ( row Height , d . height ) ; } } add Row ( dim , row Width , row Height ) ; dim . width += horizontal Insets And Gap ; dim . height += insets . top + insets . bottom + vgap * NUM_ ; Container scroll Pane = Swing Utilities . get Ancestor Of Class ( J Scroll Pane . class , target ) ; if ( scroll Pane != null && target . is Valid ( ) ) { int extra = NUM_ ; if ( scroll Pane instanceof J Scroll Pane ) { J Scroll Pane jsp = ( J Scroll Pane ) scroll Pane ; J Scroll Bar vsb = jsp . get Vertical Scroll Bar ( ) ; if ( vsb != null ) { extra += Math . max ( NUM_ , vsb . get Width ( ) ) ; } } dim . width -= hgap + extra ; } return dim ; } }
public long backoff ( int attempt ) { long duration = base * ( long ) Math . pow ( factor , attempt ) ; if ( jitter != NUM_ ) { double random = Math . random ( ) ; int deviation = ( int ) Math . floor ( random * jitter * duration ) ; if ( ( ( ( int ) Math . floor ( random * NUM_ ) ) & NUM_ ) == NUM_ ) { duration = duration - deviation ; } else { duration = duration + deviation ; } } if ( duration < NUM_ ) { duration = Long . MAX VALUE ; } return Math . min ( Math . max ( duration , base ) , cap ) ; }
public byte [ ] to Byte Array ( ) { write Current Byte ( ) ; byte [ ] byte Array = byte Stream . to Byte Array ( ) ; byte Stream . reset ( ) ; return byte Array ; }
public static String repeat Char ( char character , int repeat Count ) { String Buffer string Buffer = new String Buffer ( repeat Count ) ; for ( int i = NUM_ ; i <= repeat Count ; i ++ ) { string Buffer . append ( character ) ; } return string Buffer . to String ( ) ; }
public static void close Quietly ( Closeable c ) { if ( c != null ) { try { c . close ( ) ; } catch ( IO Exception ignored ) { } } }
@ Override public boolean event Generatable ( String event Name ) { if ( event Name . equals ( STR_ ) ) { return true ; } return false ; }
public static String key Algorithm ( String algorithm ) { int index = algorithm . index Of ( STR_ ) ; if ( index == - NUM_ ) { return algorithm ; } return algorithm . substring ( NUM_ , index ) ; }
public double slope Std Err ( ) { return Math . sqrt ( svar 1 ) ; }
public static final String stack Trace ( Throwable e ) { String foo = null ; try { Byte Array Output Stream ostr = new Byte Array Output Stream ( ) ; e . print Stack Trace ( new Print Writer ( ostr , true ) ) ; foo = ostr . to String ( ) ; } catch ( Exception f ) { } return foo ; }
private List < Type Literal < ? > > resolve All ( Type [ ] types ) { Type Literal < ? > [ ] result = new Type Literal < ? > [ types . length ] ; for ( int t = NUM_ ; t < types . length ; t ++ ) { result [ t ] = resolve ( types [ t ] ) ; } return Arrays . as List ( result ) ; }
public static long location At Tick ( Geo Time Serie gts , long tick ) { if ( null == gts . locations ) { return Geo Time Serie . NO LOCATION ; } sort ( gts , false ) ; int idx = Arrays . binary Search ( gts . ticks , NUM_ , gts . values , tick ) ; if ( idx < NUM_ ) { return Geo Time Serie . NO LOCATION ; } else { return gts . locations [ idx ] ; } }
public double clamp ( double value ) { return Math . min ( Math . max ( get Min ( ) , value ) , get Max ( ) ) ; }
@ Override public Iterator < Database > iterator ( ) { return m databases . iterator ( ) ; }
public Object next Object ( Random rnd , int type , boolean allow Null ) { Object obj = null ; switch ( type ) { case BOOLEAN : { obj = ( rnd . next Boolean ( ) ? Boolean . TRUE : Boolean . FALSE ) ; break ; } case BYTE : { obj = Byte . value Of ( ( byte ) ( rnd . next Int ( NUM_ ) - NUM_ ) ) ; break ; } case CHAR : { obj = Character . value Of ( alphabet . char At ( rnd . next Int ( alphabet . length ( ) ) ) ) ; break ; } case SHORT : { obj = Short . value Of ( ( short ) rnd . next Int ( ) ) ; break ; } case INT : { obj = Integer . value Of ( rnd . next Int ( ) ) ; break ; } case LONG : { obj = Long . value Of ( rnd . next Long ( ) ) ; break ; } case FLOAT : { obj = Float . value Of ( rnd . next Float ( ) ) ; break ; } case DOUBLE : { obj = Double . value Of ( rnd . next Double ( ) ) ; break ; } case STRING : { obj = get Random String ( NUM_ , rnd . next Int ( ) ) ; break ; } case OBJECT : { obj = get Random String ( NUM_ , rnd . next Int ( ) ) ; break ; } default : { throw new Assertion Error ( STR_ + type ) ; } } return obj ; }
public static double euclidean Distance ( double [ ] p , double [ ] q ) { double ret = NUM_ ; for ( int i = NUM_ ; i < p . length ; i ++ ) { double diff = ( q [ i ] - p [ i ] ) ; double sq = Math . pow ( diff , NUM_ ) ; ret += sq ; } return ret ; }
@ Override public double filter Fitness ( double fitness ) { return Math . exp ( fitness / temperature ) ; }
public int next Int ( int n ) { if ( n > NUM_ ) { if ( ( n & - n ) == n ) { return ( int ) ( ( n * ( long ) next ( NUM_ ) ) > > NUM_ ) ; } int bits , val ; do { bits = next ( NUM_ ) ; val = bits % n ; } while ( bits - val + ( n - NUM_ ) < NUM_ ) ; return val ; } throw new Illegal Argument Exception ( ) ; }
public int length ( ) { return values . size ( ) ; }
public boolean exists ( File file ) { return file . exists ( ) ; }
protected void assert Any Mode ( ) throws Replicator Exception { if ( mode == null ) throw new THL Exception ( STR_ + file . get Name ( ) ) ; }
@ Override public int count Missing ( ) { int count = NUM_ ; for ( int i = NUM_ ; i < size ( ) ; i ++ ) { if ( MISSING VALUE . equals ( get ( i ) ) ) { count ++ ; } } return count ; }
public String to Six Figure String ( ) { int hundredkm E = ( int ) Math . floor ( easting / NUM_ ) ; int hundredkm N = ( int ) Math . floor ( northing / NUM_ ) ; String first Letter ; if ( hundredkm N < NUM_ ) { if ( hundredkm E < NUM_ ) { first Letter = STR_ ; } else { first Letter = STR_ ; } } else if ( hundredkm N < NUM_ ) { if ( hundredkm E < NUM_ ) { first Letter = STR_ ; } else { first Letter = STR_ ; } } else { first Letter = STR_ ; } int index = NUM_ + ( ( NUM_ - ( hundredkm N % NUM_ ) ) * NUM_ ) + ( hundredkm E % NUM_ ) ; if ( index >= NUM_ ) index ++ ; String second Letter = Character . to String ( ( char ) index ) ; int e = ( int ) Math . floor ( ( easting - ( NUM_ * hundredkm E ) ) / NUM_ ) ; int n = ( int ) Math . floor ( ( northing - ( NUM_ * hundredkm N ) ) / NUM_ ) ; String es = STR_ + e ; if ( e < NUM_ ) es = STR_ + es ; if ( e < NUM_ ) es = STR_ + es ; String ns = STR_ + n ; if ( n < NUM_ ) ns = STR_ + ns ; if ( n < NUM_ ) ns = STR_ + ns ; return first Letter + second Letter + es + ns ; }
public boolean run After ( List tasks , int size ) { return false ; }
private static boolean is Same Class Package ( Class Loader loader 1 , String name 1 , Class Loader loader 2 , String name 2 ) { if ( loader 1 != loader 2 ) { return false ; } else { int last Dot 1 = name 1 . last Index Of ( STR_ ) ; int last Dot 2 = name 2 . last Index Of ( STR_ ) ; if ( ( last Dot 1 == - NUM_ ) || ( last Dot 2 == - NUM_ ) ) { return ( last Dot 1 == last Dot 2 ) ; } else { int idx 1 = NUM_ ; int idx 2 = NUM_ ; if ( name 1 . char At ( idx 1 ) == STR_ ) { do { idx 1 ++ ; } while ( name 1 . char At ( idx 1 ) == STR_ ) ; if ( name 1 . char At ( idx 1 ) != STR_ ) { throw new Internal Error ( STR_ + name 1 ) ; } } if ( name 2 . char At ( idx 2 ) == STR_ ) { do { idx 2 ++ ; } while ( name 2 . char At ( idx 2 ) == STR_ ) ; if ( name 2 . char At ( idx 2 ) != STR_ ) { throw new Internal Error ( STR_ + name 2 ) ; } } int length 1 = last Dot 1 - idx 1 ; int length 2 = last Dot 2 - idx 2 ; if ( length 1 != length 2 ) { return false ; } return name 1 . region Matches ( false , idx 1 , name 2 , idx 2 , length 1 ) ; } } }
public static boolean is Control Or Meta Down ( Mouse Event e ) { if ( ! IS MAC ) { return e . is Control Down ( ) ; } else { return e . is Meta Down ( ) ; } }
public static Vector format Decimal ( Collection c , String pattern ) { Decimal Format f = new Decimal Format ( pattern ) ; Vector v = new Vector ( ) ; for ( Iterator i = c . iterator ( ) ; i . has Next ( ) ; ) { Object o = i . next ( ) ; if ( o instanceof Double ) v . add ( f . format ( o ) ) ; else v . add ( o ) ; } return v ; }
@ Override public Shape Tile Box offset ( double p dist ) { if ( p dist == NUM_ || is empty ( ) ) { return this ; } int dist = ( int ) Math . round ( p dist ) ; Pla Point Int lower left = new Pla Point Int ( box ll . v x - dist , box ll . v y - dist ) ; Pla Point Int upper right = new Pla Point Int ( box ur . v x + dist , box ur . v y + dist ) ; return new Shape Tile Box ( lower left , upper right ) ; }
public E peek Backwards ( ) { int prev Pos = ( pos + size - NUM_ ) % size ; if ( prev Pos >= data . size ( ) || pos == start ) { return null ; } return data . get ( prev Pos ) ; }
public Map < String , List < String > > to Multimap ( boolean response ) { Map < String , List < String > > result = new Tree Map < String , List < String > > ( FIELD NAME COMPARATOR ) ; for ( int i = NUM_ ; i < names And Values . size ( ) ; i += NUM_ ) { String field Name = names And Values . get ( i ) ; String value = names And Values . get ( i + NUM_ ) ; List < String > all Values = new Array List < String > ( ) ; List < String > other Values = result . get ( field Name ) ; if ( other Values != null ) { all Values . add All ( other Values ) ; } all Values . add ( value ) ; result . put ( field Name , Collections . unmodifiable List ( all Values ) ) ; } if ( response && status Line != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( status Line ) ) ) ; } else if ( request Line != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( request Line ) ) ) ; } return Collections . unmodifiable Map ( result ) ; }
@ Layoutlib Delegate static float floor ( float value ) { return ( float ) Math . floor ( value ) ; }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; }
public static Element first Child Element ( Element element ) { if ( element == null ) return null ; Node node = element . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE ) { Element child Element = ( Element ) node ; return child Element ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return null ; }
public synchronized byte [ ] to Byte Array ( ) { byte [ ] new Array = new byte [ count ] ; System . arraycopy ( buf , NUM_ , new Array , NUM_ , count ) ; return new Array ; }
@ Suppress Warnings ( STR_ ) public Binary Vector copy ( ) { Binary Vector copy = new Binary Vector ( dimension ) ; copy . bit Set = ( Fixed Bit Set ) bit Set . clone ( ) ; if ( ! is Sparse ) copy . voting Record = ( Array List < Fixed Bit Set > ) voting Record . clone ( ) ; return copy ; }
public Basic Effect copy ( ) { Basic Effect copy = new Basic Effect ( variable Label , variable Value , priority , exclusive , negated ) ; return copy ; }
protected Snmp Cached Data update Cached Datas ( Object user Data ) { final String [ ] path = Jvm Runtime Impl . get Boot Class Path ( user Data ) ; final long time = System . current Time Millis ( ) ; final int len = path . length ; Snmp Oid indexes [ ] = new Snmp Oid [ len ] ; for ( int i = NUM_ ; i < len ; i ++ ) { indexes [ i ] = new Snmp Oid ( i + NUM_ ) ; } return new Snmp Cached Data ( time , indexes , path ) ; }
@ Suppress Warnings ( STR_ ) public final < T extends Extension > boolean has Repeating Extension ( Class < T > extension Class ) { List < T > ret = ( List < T > ) repeating Extension Map . get ( extension Class ) ; return ret != null && ! ret . is Empty ( ) ; }
protected Snmp Cached Data update Cached Datas ( Object user Data ) { final String [ ] path = Jvm Runtime Impl . get Class Path ( user Data ) ; final long time = System . current Time Millis ( ) ; final int len = path . length ; Snmp Oid indexes [ ] = new Snmp Oid [ len ] ; for ( int i = NUM_ ; i < len ; i ++ ) { indexes [ i ] = new Snmp Oid ( i + NUM_ ) ; } return new Snmp Cached Data ( time , indexes , path ) ; }
public boolean uses Relevance ( ) { return ! query . is Empty ( ) ; }
private Op Arg Node generate Op Arg ( Symbol Node target Symbol , Tree Node op Arg Syntax Node , Module Node mn ) throws Abort Exception { if ( op Arg Syntax Node . is Kind ( N Lambda ) ) { return new Op Arg Node ( generate Lambda ( op Arg Syntax Node , mn ) , op Arg Syntax Node , mn ) ; } ; if ( ! ( op Arg Syntax Node . is Kind ( N General Id ) || op Arg Syntax Node . is Kind ( N Gen Infix Op ) || op Arg Syntax Node . is Kind ( N Gen Prefix Op ) || op Arg Syntax Node . is Kind ( N Gen Non Exp Prefix Op ) || op Arg Syntax Node . is Kind ( N Gen Postfix Op ) ) ) { errors . add Error ( op Arg Syntax Node . get Location ( ) , STR_ + target Symbol . get Arity ( ) + STR_ + STR_ + target Symbol . get Name ( ) + STR_ ) ; return null Op Arg ; } if ( op Arg Syntax Node . get Kind ( ) == N General Id ) { if ( target Symbol . get Arity ( ) <= NUM_ ) { errors . add Abort ( op Arg Syntax Node . get Location ( ) , STR_ , true ) ; } ; Level Node ln = selector To Node ( gen Id To Selector ( ( Syntax Tree Node ) op Arg Syntax Node ) , target Symbol . get Arity ( ) , false , false , mn ) ; if ( ! ( ln instanceof Op Arg Node ) ) { if ( errors . get Num Errors ( ) > NUM_ ) { return null Op Arg ; } errors . add Abort ( op Arg Syntax Node . get Location ( ) , STR_ + STR_ + STR_ ) ; } ; return ( Op Arg Node ) ln ; } ; Gen ID gen ID = generate Gen ID ( op Arg Syntax Node , mn ) ; if ( gen ID . get Fully Qualified Op ( ) != null && gen ID . get Args ( ) . length == NUM_ ) { return new Op Arg Node ( gen ID . get Fully Qualified Op ( ) , op Arg Syntax Node , mn ) ; } else if ( gen ID . get Args ( ) . length > NUM_ ) { errors . add Error ( op Arg Syntax Node . get Location ( ) , STR_ + target Symbol . get Arity ( ) + STR_ + STR_ + target Symbol . get Name ( ) + STR_ ) ; return null Op Arg ; } else { return null Op Arg ; } }
public String TO NUMBER ( Big Decimal number , int display Type ) { if ( number == null ) return STR_ ; Big Decimal result = number ; int scale = Display Type . get Default Precision ( display Type ) ; if ( scale > number . scale ( ) ) { try { result = number . set Scale ( scale , Big Decimal . ROUND HALF UP ) ; } catch ( Exception e ) { } } return result . to String ( ) ; }
public static < T > String path ( Tree Def . Parented < T > tree Def , T node , Function < ? super T , String > to String , String delimiter ) { List < T > to Root = to Root ( tree Def , node ) ; List Iterator < T > iterator = to Root . list Iterator ( to Root . size ( ) ) ; String Builder builder = new String Builder ( ) ; while ( iterator . has Previous ( ) ) { T segment = iterator . previous ( ) ; builder . append ( to String . apply ( segment ) ) ; if ( iterator . has Previous ( ) ) { builder . append ( delimiter ) ; } } return builder . to String ( ) ; }
Node clone Or Import Node ( short operation , Node node , boolean deep ) { Node Impl copy = shallow Copy ( operation , node ) ; if ( deep ) { Node List list = node . get Child Nodes ( ) ; for ( int i = NUM_ ; i < list . get Length ( ) ; i ++ ) { copy . append Child ( clone Or Import Node ( operation , list . item ( i ) , deep ) ) ; } } notify User Data Handlers ( operation , node , copy ) ; return copy ; }
public static Number floor ( Number a ) { if ( is Floating Point ( a ) ) { return Math . floor ( a . double Value ( ) ) ; } else { return a . long Value ( ) ; } }
public List < Node > list Available Functions ( Class < ? > type ) { List < Node > result = new Array List < Node > ( ) ; for ( Node node : available Nodes ) { if ( ( node . get Number Of Arguments ( ) > NUM_ ) && type . is Assignable From ( node . get Return Type ( ) ) ) { result . add ( node ) ; } } if ( result . is Empty ( ) ) { result . add All ( list Available Terminals ( type ) ) ; } return result ; }
public static Delete Status delete Async Id ( String request Id ) { return new Delete Status ( request Id ) ; }
public String which ( String session ID , String path ) throws Directory Not Found Exception { Resource Node node = null ; try { node = locate ( session ID , path ) ; } catch ( Directory Not Found Exception d ) { return null ; } String the Path = format Path ( get Absolute Path ( get Root Node ( ) , node , true ) , true ) ; int param Start = the Path . index Of ( STR_ ) ; if ( param Start != - NUM_ ) { return the Path . substring ( NUM_ , param Start ) ; } return the Path ; }
public synchronized boolean is Closed ( ) { return closed ; }
public boolean has More Turns ( ) { return turn Vector . size ( ) > ( turn Index + NUM_ ) ; }
public Text trim ( ) { int first = NUM_ ; int last = length ( ) - NUM_ ; while ( ( first <= last ) && ( char At ( first ) <= STR_ ) ) { first ++ ; } while ( ( last >= first ) && ( char At ( last ) <= STR_ ) ) { last -- ; } return subtext ( first , last + NUM_ ) ; }
public String as String ( ) { return String . value Of ( version ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public static < T > Big Decimal sum Of Big Decimal ( Iterable < T > iterable , Function < ? super T , Big Decimal > function ) { if ( iterable instanceof List ) { return List Iterate . sum Of Big Decimal ( ( List < T > ) iterable , function ) ; } if ( iterable != null ) { return Iterable Iterate . sum Of Big Decimal ( iterable , function ) ; } throw new Illegal Argument Exception ( STR_ ) ; }
public boolean r Flag Function For Recompile Once ( Statement Block sb , boolean in Loop ) { boolean ret = false ; if ( sb instanceof Function Statement Block ) { Function Statement Block fsb = ( Function Statement Block ) sb ; Function Statement fstmt = ( Function Statement ) fsb . get Statement ( NUM_ ) ; for ( Statement Block c : fstmt . get Body ( ) ) ret |= r Flag Function For Recompile Once ( c , in Loop ) ; } else if ( sb instanceof While Statement Block ) { ret = true ; } else if ( sb instanceof If Statement Block ) { If Statement Block isb = ( If Statement Block ) sb ; If Statement istmt = ( If Statement ) isb . get Statement ( NUM_ ) ; ret |= ( in Loop && isb . requires Predicate Recompilation ( ) ) ; for ( Statement Block c : istmt . get If Body ( ) ) ret |= r Flag Function For Recompile Once ( c , in Loop ) ; for ( Statement Block c : istmt . get Else Body ( ) ) ret |= r Flag Function For Recompile Once ( c , in Loop ) ; } else if ( sb instanceof For Statement Block ) { ret = true ; } else { ret |= ( in Loop && sb . requires Recompilation ( ) ) ; } return ret ; }
public Thrown Exception Iterator iterator ( ) { return new Thrown Exception Iterator ( ) ; }
public void request Account Expiration Time ( ) { operations . add ( Password Policy State Operation Type . GET ACCOUNT EXPIRATION TIME ) ; }
public static List < File > annotated Files ( ) throws File Not Found Exception , Loading File Exception , IO Exception { List < File > annotated Files = new Array List < File > ( ) ; for ( File java File : get Java Files ( ) ) if ( is File Annotated ( java File ) ) annotated Files . add ( java File ) ; return annotated Files ; }
final int length In Bits ( K key ) { return key == null ? NUM_ : key Analyzer . length In Bits ( key ) ; }
public float maximum Absolute ( ) { if ( Math . abs ( m Left ) > Math . abs ( m Right ) ) { return Math . abs ( m Left ) ; } else { return Math . abs ( m Right ) ; } }
public boolean is Logged In ( ) { return m Logged In User Id != null ; }
public static Vector < Object > inputs ( Vector < Object > subset , Integer ... tab ) { Vector < Object > result = new Vector < Object > ( ) ; for ( int i = NUM_ ; i < subset . size ( ) ; i ++ ) { Bean Instance temp = ( Bean Instance ) subset . element At ( i ) ; if ( check Target Constraint ( temp , subset , tab ) ) { result . add ( temp ) ; } } return result ; }
public String body ( ) throws IO Exception { if ( headers == null ) parse Headers ( ) ; String Builder builder = new String Builder ( ) ; for ( int i = in . read ( ) ; i > - NUM_ ; i = in . read ( ) ) { builder . append ( ( char ) i ) ; } return builder . to String ( ) ; }
@ Override public Example Set create Example Set ( ) { return create Example Set ( Collections . < Attribute , String > empty Map ( ) ) ; }
public boolean has Property ( CSS Name css Name ) { return cascaded Properties . get ( css Name ) != null ; }
protected int choose High Water Mark ( int capacity , double max Load ) { return Math . min ( capacity - NUM_ , ( int ) ( capacity * max Load ) ) ; }
private static Byte String read Chunk ( Input Stream in , final int chunk Size ) throws IO Exception { final byte [ ] buf = new byte [ chunk Size ] ; int bytes Read = NUM_ ; while ( bytes Read < chunk Size ) { final int count = in . read ( buf , bytes Read , chunk Size - bytes Read ) ; if ( count == - NUM_ ) { break ; } bytes Read += count ; } if ( bytes Read == NUM_ ) { return null ; } else { return Byte String . copy From ( buf , NUM_ , bytes Read ) ; } }
private byte [ ] first Token ( ) throws IO Exception { negotiator = null ; if ( cache != null ) { synchronized ( cache ) { negotiator = cache . get ( get Host ( ) ) ; if ( negotiator != null ) { cache . remove ( get Host ( ) ) ; } } } if ( negotiator == null ) { negotiator = Negotiator . get Negotiator ( hci ) ; if ( negotiator == null ) { IO Exception ioe = new IO Exception ( STR_ ) ; throw ioe ; } } return negotiator . first Token ( ) ; }
private String pre Process Signature ( String signature ) { int index ; if ( ( index = signature . index Of ( STR_ ) ) > NUM_ ) { signature = signature . substring ( NUM_ , index ) ; } while ( ( index = signature . index Of ( STR_ ) ) > NUM_ ) { signature = signature . substring ( NUM_ , index ) + signature . substring ( index + NUM_ , signature . length ( ) ) ; } return signature ; }
static int address Size ( ) { return unsafe . address Size ( ) ; }
@ Override public Value concatenate ( Value v ) { if ( v instanceof String Val ) { return Value Factory . create ( str + STR_ + v . to String ( ) ) ; } else if ( v instanceof Double Val ) { return Value Factory . create ( str + STR_ + v . to String ( ) ) ; } else if ( v instanceof None Val ) { return this ; } else { log . warning ( STR_ + this + STR_ + v ) ; return Value Factory . none Value ; } }
boolean excluded ( int elem Index ) { return ( exclusions != null ) && exclusions . get ( elem . get Index ( ) ) ; }
private Map < String , Metric Header Info > process CSV File Data Header ( Db Client db Client , Storage System storage System , String director Name , List < String > headers ) { Map < String , Metric Header Info > metric To Object Map = new Hash Map < > ( ) ; for ( String header : headers ) { Matcher matcher = METRIC NAME PATTERN . matcher ( header ) ; if ( matcher . matches ( ) ) { String name = matcher . group ( NUM_ ) ; if ( ! METRICS NAMES TO GATHER . contains ( name ) ) { continue ; } String object Name = matcher . group ( NUM_ ) ; String units = matcher . group ( NUM_ ) ; if ( Strings . is Null Or Empty ( object Name ) ) { object Name = EMPTY ; } Storage HA Domain vplex Director = lookup V Plex Director By Name ( db Client , storage System , director Name ) ; if ( object Name . equals ( EMPTY ) ) { Metric Header Info header Info = new Metric Header Info ( ) ; header Info . type = Metric Header Info . Type . DIRECTOR ; header Info . director = vplex Director ; header Info . units = units ; metric To Object Map . put ( header , header Info ) ; } else { Storage Port storage Port = lookup V Plex Front Storage Port By Name ( db Client , vplex Director , object Name ) ; if ( storage Port != null ) { Metric Header Info header Info = new Metric Header Info ( ) ; header Info . type = Metric Header Info . Type . PORT ; header Info . director = vplex Director ; header Info . port = storage Port ; header Info . units = units ; metric To Object Map . put ( header , header Info ) ; } } } } return metric To Object Map ; }
public static boolean is File Upload Available ( final boolean needs Correct Mime Type ) { if ( Build . VERSION . SDK INT == NUM_ ) { final String platform Version = ( Build . VERSION . RELEASE == null ) ? STR_ : Build . VERSION . RELEASE ; return ! needs Correct Mime Type && ( platform Version . starts With ( STR_ ) || platform Version . starts With ( STR_ ) ) ; } else { return true ; } }
Iterator < Heap Variable < Object > > enumerate Exposed Heap Variables ( ) { Array List < Heap Variable < Object > > v = new Array List < Heap Variable < Object > > ( ) ; for ( Iterator < Heap Variable < Object > > e = get Heap Variables ( ) ; e . has Next ( ) ; ) { Heap Variable < Object > H = e . next ( ) ; if ( is Exposed On Exit ( H ) ) { v . add ( H ) ; } } return v . iterator ( ) ; }
public String read Entire Document ( String path , String key ) { String ret = read Entire File Or Resource From Path ( path ) ; if ( ret == null || ret . is Empty ( ) ) { ret = read Entire File Or Resource ( key ) ; } return ret ; }
@ Suppress Warnings ( STR_ ) public Enumeration < Permission > elements ( ) { synchronized ( this ) { return Collections . enumeration ( ( List < Permission > ) ( List ) perms ) ; } }
public static Managed Object Path < ? , ? > value Of ( String s ) { String ns = s . trim ( ) ; if ( ns . equals ( STR_ ) ) { return EMPTY PATH ; } Linked List < Element < ? , ? > > elements = new Linked List < > ( ) ; Element < ? , ? > last Element = null ; Abstract Managed Object Definition < ? , ? > definition = Root Cfg Defn . get Instance ( ) ; if ( ! ns . starts With ( STR_ ) ) { throw new Illegal Argument Exception ( STR_ + ns + STR_ ) ; } int start = NUM_ ; while ( true ) { int end ; for ( end = start ; end < ns . length ( ) ; end ++ ) { char c = ns . char At ( end ) ; if ( c == STR_ ) { if ( end == ( ns . length ( ) - NUM_ ) ) { throw new Illegal Argument Exception ( STR_ + ns + STR_ ) ; } if ( ns . char At ( end + NUM_ ) == STR_ ) { end ++ ; } else { break ; } } } String es = ns . substring ( start , end ) ; Matcher m = PE REGEXP . matcher ( es ) ; if ( ! m . matches ( ) ) { throw new Illegal Argument Exception ( STR_ + es + STR_ + ns + STR_ ) ; } String relation = m . group ( NUM_ ) ; String type = m . group ( NUM_ ) ; String name = m . group ( NUM_ ) ; Relation Definition < ? , ? > r ; try { r = definition . get Relation Definition ( relation ) ; } catch ( Illegal Argument Exception e ) { throw new Illegal Argument Exception ( STR_ + es + STR_ + ns + STR_ + relation + STR_ ) ; } last Element = create Element ( r , ns , es , type , name ) ; elements . add ( last Element ) ; definition = last Element . get Managed Object Definition ( ) ; if ( end < ns . length ( ) ) { start = end + NUM_ ; } else { break ; } } return create ( elements , last Element ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
protected Replaced Element lookup Image Replaced Element ( Element e ) { if ( image Components . size ( ) == NUM_ ) { return null ; } Replaced Element replaced Element = ( Replaced Element ) image Components . get ( e ) ; return replaced Element ; }
public static String commit ( String ... args ) { return simple Tag ( STR_ , args ) ; }
public Iterator < Byte Code Pattern Match > byte Code Pattern Match Iterator ( ) { return result List . iterator ( ) ; }
@ Override public double downside Deviation ( ) { return Math . sqrt ( downside Variance ( ) ) ; }
private static int hash Code ( double [ ] array ) { int prime = NUM_ ; if ( array == null ) { return NUM_ ; } int result = NUM_ ; for ( double element : array ) { long temp = Double . double To Long Bits ( element ) ; result = ( prime * result ) + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; } return result ; }
public static Class to Return Type ( short xs Type , String type Name , Integer optional Fraction Digits ) { if ( type Name != null ) { Class result = type Map . get ( type Name ) ; if ( result != null ) { return result ; } } switch ( xs Type ) { case XS Simple Type . PRIMITIVE BOOLEAN : return Boolean . class ; case XS Simple Type . PRIMITIVE STRING : return String . class ; case XS Simple Type . PRIMITIVE DECIMAL : if ( ( optional Fraction Digits != null ) && ( optional Fraction Digits > NUM_ ) ) { return Double . class ; } return Integer . class ; case XS Simple Type . PRIMITIVE FLOAT : return Float . class ; case XS Simple Type . PRIMITIVE DOUBLE : return Double . class ; default : return String . class ; } }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ ; }
public String process Filename ( String filename ) { if ( ! filename . starts With ( get Dir ( ) ) ) filename = get Dir ( ) + filename ; return filename ; }
public Optional Long min By Long ( Long Unary Operator key Extractor ) { long [ ] result = collect ( null , null , null ) ; return result [ NUM_ ] == NUM_ ? Optional Long . of ( result [ NUM_ ] ) : Optional Long . empty ( ) ; }
public static double determination Coefficient ( double [ ] y 1 , double [ ] y 2 , int n ) { return Math . pow ( correlation ( y 1 , y 2 ) , NUM_ ) ; }
private int current ( ) { if ( buf != null ) { return UTF 16 . char At ( buf , NUM_ , buf . length , buf Pos ) ; } else { int i = pos . get Index ( ) ; return ( i < text . length ( ) ) ? UTF 16 . char At ( text , i ) : DONE ; } }
private static P Cal Location Get Last Location End ( ) { return new P Cal Location ( last Tok Line - NUM_ , last Tok Col - NUM_ + last Tok String . length ( ) ) ; }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; }
public static Object static Field Base ( Field field ) { return UNSAFE . static Field Base ( field ) ; }
public List < Node > list Available Mutations ( Node node ) { List < Node > result = new Array List < Node > ( ) ; for ( Node mutation : available Nodes ) { if ( is Mutation Compatible ( node , mutation ) ) { result . add ( mutation ) ; } } return result ; }
public static String compute Unique Name ( String [ ] existing Names , String base Name ) { Set < String > name Set = new Hash Set < String > ( Arrays . as List ( existing Names ) ) ; String proposed Name = base Name ; int i = NUM_ ; while ( name Set . contains ( proposed Name ) ) { proposed Name = base Name + i ++ ; } return proposed Name ; }
public static Map < String , Mapped Class > mappings From Enigma ( File file , Map < String , Class Node > nodes ) { Map < String , Mapped Class > base = mappings From Nodes ( nodes ) ; Mapping Loader loader = new Enigma Loader ( nodes ) ; try { Map < String , Mapped Class > new Mappings = loader . read ( new File Reader ( file ) ) ; for ( Mapped Class mapped Class : new Mappings . values ( ) ) { new Mappings = link Mappings ( mapped Class , new Mappings ) ; } base = fix From Mappings Text ( base , new Mappings ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } return base ; }
public boolean empty ( ) { return individuals . size ( ) == NUM_ ; }
public String description ( ) { synchronized ( this ) { if ( messages == null ) { messages = Resource Bundle . get Bundle ( STR_ ) ; } } return messages . get String ( STR_ ) ; }
private boolean mouse Pressed Impl ( Mouse Event me ) { component = ( J Component ) me . get Source ( ) ; if ( map Drag Operation From Modifiers ( me , component . get Transfer Handler ( ) ) != Transfer Handler . NONE ) { motion Threshold = Drag Source . get Drag Threshold ( ) ; dnd Armed Event = me ; return true ; } clear State ( ) ; return false ; }
private Byte Buffer buffer Object ( final Object obj ) throws IO Exception { return Byte Buffer . wrap ( Serializer Util . serialize ( obj ) ) ; }
public boolean is Private ( ) { return Modifier . is Private ( get Access Flags ( ) ) ; }
public Instance first Instance ( ) { return m Instances . get ( NUM_ ) ; }
public < V extends Comparable < ? super V > > Optional Long min By ( Long Function < V > key Extractor ) { Obj Long Box < V > result = collect ( null , null , null ) ; return result . a == null ? Optional Long . empty ( ) : Optional Long . of ( result . b ) ; }
private static boolean is Encrypted ( String password ) { for ( int i = NUM_ ; i < ALGORITHMS . length ; i ++ ) { if ( password . starts With ( ALGORITHMS [ i ] + SEPERATOR ) ) { return true ; } } return false ; }
public java . lang . String replace ( char old Char , char new Char ) { char [ ] buffer = value ; int offset = offset ; int count = count ; int idx = offset ; int last = offset + count ; boolean copied = false ; while ( idx < last ) { if ( buffer [ idx ] == old Char ) { if ( ! copied ) { char [ ] new Buffer = new char [ count ] ; System . arraycopy ( buffer , offset , new Buffer , NUM_ , count ) ; buffer = new Buffer ; idx -= offset ; last -= offset ; copied = true ; } buffer [ idx ] = new Char ; } idx ++ ; } return copied ? new String ( buffer ) : this ; }
public synchronized int size ( ) { return m Ordered . size ( ) ; }
public int search ( char [ ] text ) { int m = pattern . length ; int n = text . length ; int skip ; for ( int i = NUM_ ; i <= n - m ; i += skip ) { skip = NUM_ ; for ( int j = m - NUM_ ; j >= NUM_ ; j -- ) { if ( pattern [ j ] != text [ i + j ] ) { skip = Math . max ( NUM_ , j - right [ text [ i + j ] ] ) ; break ; } } if ( skip == NUM_ ) return i ; } return n ; }
public static long current Time Millis ( ) { return mock Time != null ? mock Time . get Time ( ) : System . current Time Millis ( ) ; }
public J Class for Name ( String name ) { Soft Reference < J Class > j Class Ref = class Map . get ( name ) ; J Class j Class = j Class Ref != null ? j Class Ref . get ( ) : null ; if ( j Class == null ) { j Class = static Class Map . get ( name ) ; if ( j Class == null ) { if ( name . starts With ( STR_ ) ) { J Class sub Class = descriptor To Class ( name , NUM_ ) ; j Class = new J Class Array ( sub Class ) ; } else j Class = load Class ( name ) ; } class Map . put ( name , new Soft Reference < J Class > ( j Class ) ) ; } return j Class ; }
public char to Char Array ( ) [ ] { synchronized ( lock ) { return Arrays . copy Of ( buf , count ) ; } }
public CC Menu Item selected Item ( ) { return sub Items . get ( selected Index ) ; }
public static boolean is Termination Success ( Http Servlet Request request ) { String status = request . get Parameter ( IFS Constants . TERMINATION STATUS ) ; if ( status == null || status . equals Ignore Case ( IFS Constants . TERMINATION SUCCESS ) ) { return true ; } else { return false ; } }
public Enumeration < Permission > elements ( ) { synchronized ( this ) { return Collections . enumeration ( perms ) ; } }
public double next Double ( double mean , double standard Deviation ) { if ( cache Filled && this . mean == mean && this . standard Deviation == standard Deviation ) { cache Filled = false ; return cache ; } ; double x , y , r , z ; do { x = NUM_ * random Generator . raw ( ) - NUM_ ; y = NUM_ * random Generator . raw ( ) - NUM_ ; r = x * x + y * y ; } while ( r >= NUM_ ) ; z = Math . sqrt ( - NUM_ * Math . log ( r ) / r ) ; cache = mean + standard Deviation * x * z ; cache Filled = true ; return mean + standard Deviation * y * z ; }
public static boolean is Source Title Valid ( String value ) { return value == null || value . length ( ) < NUM_ * NUM_ ; }
default long now ( Time Unit unit ) { return unit . convert ( System . current Time Millis ( ) , Time Unit . MILLISECONDS ) ; }
public double probability Of ( T key ) { Integer value = get Count ( key ) ; if ( NUM_ == total || NUM_ == value . int Value ( ) ) { return NUM_ ; } else { return value . double Value ( ) / total ; } }
public static boolean check Deprecation ( Property property , String path , int line ) { flex 2 . compiler . mxml . reflect . Deprecated deprecated = property . get Deprecated ( ) ; if ( ( deprecated != null ) ) { if ( ! check Log Deprecation Warning ( path , line , property . get Name ( ) , deprecated . get Since ( ) , deprecated . get Message ( ) , deprecated . get Replacement ( ) ) ) { Thread Local Toolkit . log ( new Deprecated ( property . get Name ( ) ) , path , line ) ; } return false ; } return true ; }
public boolean empty ( ) { return is Empty ( ) ; }
public boolean read Message ( Input Stream is , Outbox Amp outbox ) throws IO Exception { In H 3 h In = h In ; if ( is . available ( ) < NUM_ ) { return false ; } try { return read Message ( h In , outbox ) ; } finally { } }
public final boolean is Cancelled ( ) { return cancelled ; }
public boolean is Caller Valid For Package ( Context context , int auth Requirements , String package To Match ) { assert ! Text Utils . is Empty ( package To Match ) ; return is Caller Valid ( context , auth Requirements , package To Match ) ; }
public boolean is Empty ( ) { return events . size ( ) == NUM_ ; }
public final boolean is Vertical ( ) { final Split parent = get Parent ( ) ; return parent != null && parent . is Row Layout ( ) ; }
public double pdf ( int k ) { if ( k < NUM_ ) throw new Illegal Argument Exception ( ) ; int r = this . n - k ; return Math . exp ( this . log n - Arithmetic . log Factorial ( k ) - Arithmetic . log Factorial ( r ) + this . log p * k + this . log q * r ) ; }
@ Override public Tree Node next Element ( ) { return iterator . next ( ) ; }
public static double sample Kurtosis Standard Error ( int size ) { int n = size ; return Math . sqrt ( NUM_ * n * ( n - NUM_ ) * ( n - NUM_ ) / ( ( n - NUM_ ) * ( n - NUM_ ) * ( n + NUM_ ) * ( n + NUM_ ) ) ) ; }
public static Number cos ( Number a ) { return Math . cos ( a . double Value ( ) ) ; }
@ Override public Iterator < Value Graph Vertex > iterator ( ) { return vertices . iterator ( ) ; }
public boolean valid System Name Format ( String system Name ) { if ( tc . get Node From Name ( address From System Name ( system Name ) ) == null && tc . get Node From Address ( address From System Name ( system Name ) ) == null ) { try { if ( tc . get Node From Address ( Integer . parse Int ( address From System Name ( system Name ) ) ) == null ) { return false ; } else { return ( pin From System Name ( system Name ) >= NUM_ && pin From System Name ( system Name ) <= NUM_ && ( pin 2 From System Name ( system Name ) == - NUM_ || ( pin 2 From System Name ( system Name ) >= NUM_ && pin 2 From System Name ( system Name ) <= NUM_ ) ) ) ; } } catch ( java . lang . Number Format Exception nfe ) { return false ; } } else { return ( pin From System Name ( system Name ) >= NUM_ && pin From System Name ( system Name ) <= NUM_ && ( pin 2 From System Name ( system Name ) == - NUM_ || ( pin 2 From System Name ( system Name ) >= NUM_ && pin 2 From System Name ( system Name ) <= NUM_ ) ) ) ; } }
protected boolean is Valid Domain ( String domain ) { Matcher ip Domain Matcher = IP DOMAIN PATTERN . matcher ( domain ) ; if ( ip Domain Matcher . matches ( ) ) { Inet Address Validator inet Address Validator = Inet Address Validator . get Instance ( ) ; return inet Address Validator . is Valid ( ip Domain Matcher . group ( NUM_ ) ) ; } Domain Validator domain Validator = Domain Validator . get Instance ( allow Local ) ; return domain Validator . is Valid ( domain ) || domain Validator . is Valid Tld ( domain ) ; }
static Object new Property Change Event ( Object source , String prop , Object old Value , Object new Value ) { try { return property Event Ctor . new Instance ( source , prop , old Value , new Value ) ; } catch ( Instantiation Exception | Illegal Access Exception x ) { throw new Assertion Error ( x ) ; } catch ( Invocation Target Exception x ) { Throwable cause = x . get Cause ( ) ; if ( cause instanceof Error ) throw ( Error ) cause ; if ( cause instanceof Runtime Exception ) throw ( Runtime Exception ) cause ; throw new Assertion Error ( x ) ; } }
public static int h ( long key ) { return ( int ) ( ( int ) ( key > > NUM_ ) ^ Integer . reverse Bytes ( ( int ) ( key & NUM_ ) ) ) & NUM_ ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override Reduced Printer Parser with Fixed Width ( ) { if ( subsequent Width == - NUM_ ) { return this ; } return new Reduced Printer Parser ( field , min Width , max Width , base Value , base Date , - NUM_ ) ; }
public static List < Date > holiday List ( final Calendar c , final Date from , final Date to , final boolean include Week Ends ) { QL . require ( to . gt ( from ) , STR_ + from . to String ( ) + STR_ + to . to String ( ) + STR_ ) ; final List < Date > result = new Array List < Date > ( ) ; for ( Date d = from . clone ( ) ; d . le ( to ) ; d = d . add ( NUM_ ) ) { if ( c . is Holiday ( d ) && ( include Week Ends || ! c . is Weekend ( d . weekday ( ) ) ) ) { result . add ( d ) ; } } return result ; }
public final boolean does FFDC Directory Exist ( String [ ] args ) throws Ade Exception { final String dir Name = get FFDCDB Workspace Directory ( args ) ; if ( dir Name != null ) { final File ffdc Dir = new File ( dir Name ) ; if ( ffdc Dir != null && ffdc Dir . exists ( ) ) { return true ; } } return false ; }
public int matches Recommended ( Map < String , String > tag Set ) { if ( name . equals ( STR_ ) ) { Log . d ( DEBUG TAG , STR_ ) ; } int matches = NUM_ ; for ( Entry < String , String With Description [ ] > tag : recommended Tags . entry Set ( ) ) { String key = tag . get Key ( ) ; if ( tag Set . contains Key ( key ) ) { if ( get Match Type ( key ) == Match Type . NONE ) { break ; } if ( get Match Type ( key ) == Match Type . KEY ) { matches ++ ; break ; } String other Tag Value = tag Set . get ( key ) ; for ( String With Description v : tag . get Value ( ) ) { if ( v . equals ( other Tag Value ) ) { matches ++ ; break ; } } } } return matches ; }
public String documentation Wiki Url ( ) { return properties . get Property ( STR_ ) ; }
public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj instanceof EC Field F 2 m ) { EC Field F 2 m o = ( EC Field F 2 m ) obj ; if ( this . m == o . m ) { if ( this . rp == null ) { if ( o . rp == null ) { return true ; } } else { return Arrays . equals ( this . ks , o . ks ) ; } } } return false ; }
public static String pad ( String str , int total Chars ) { if ( str == null ) str = STR_ ; int slen = str . length ( ) ; String Buffer sb = new String Buffer ( str ) ; for ( int i = NUM_ ; i < total Chars - slen ; i ++ ) { sb . append ( STR_ ) ; } return sb . to String ( ) ; }
public String validate Edge ( Object edge , Object source , Object target ) { return null ; }
public static boolean check Instance Of ( Char Sequence target Class Name , Char Sequence reference Class Name ) { if ( ( target Class Name == null ) || ( reference Class Name == null ) ) return false ; if ( Text Utils . equals ( target Class Name , reference Class Name ) ) return true ; final Class < ? > reference Class = load Or Get Cached Class ( reference Class Name . to String ( ) ) ; final Class < ? > target Class = load Or Get Cached Class ( target Class Name . to String ( ) ) ; return reference Class != null && target Class != null && reference Class . is Assignable From ( target Class ) ; }
private boolean string Match ( String str , Ocr Result Iterator iter ) { Ocr Result Iterator iter Copy = new Ocr Result Iterator ( iter ) ; for ( int pos = NUM_ ; pos < str . length ( ) ; ++ pos ) { if ( ! char Match ( str . char At ( pos ) , iter Copy . get Current Char ( ) ) ) return false ; if ( pos != str . length ( ) - NUM_ && ! iter Copy . has Next ( ) ) return false ; iter Copy . move To Next ( ) ; } return true ; }
private static int [ ] Windows Reg Query Info Key 1 ( int h Key ) { int [ ] result = Windows Reg Query Info Key ( h Key ) ; if ( result [ ERROR CODE ] == ERROR SUCCESS ) { return result ; } else { long sleep Time = INIT SLEEP TIME ; for ( int i = NUM_ ; i < MAX ATTEMPTS ; i ++ ) { try { Thread . sleep ( sleep Time ) ; } catch ( Interrupted Exception e ) { return result ; } sleep Time *= NUM_ ; result = Windows Reg Query Info Key ( h Key ) ; if ( result [ ERROR CODE ] == ERROR SUCCESS ) { return result ; } } } return result ; }
private static boolean does New Vpool Contains Volume Pool ( URI volume Pool , Virtual Pool v Pool ) { boolean v Pool Has Volume Pool = false ; if ( volume Pool != null && v Pool != null ) { String Set pools To Check = v Pool . get Use Matched Pools ( ) ? v Pool . get Matched Storage Pools ( ) : v Pool . get Assigned Storage Pools ( ) ; if ( pools To Check != null && pools To Check . contains ( volume Pool . to String ( ) ) ) { v Pool Has Volume Pool = true ; } } return v Pool Has Volume Pool ; }
List < Field > own Fields ( ) { return own Fields ; }
public int size ( ) { return selection . size ( ) ; }
public static Point 2 D intersect Param ( Point 2 D u 0 , Point 2 D v 0 , Point 2 D u 1 , Point 2 D v 1 ) { double det = determinant 2 by 2 ( v 1 , v 0 ) ; if ( Double . is Na N ( det ) || det == NUM_ ) { return null ; } double x 00 = u 0 . get X ( ) ; double y 00 = u 0 . get Y ( ) ; double x 10 = u 1 . get X ( ) ; double y 10 = u 1 . get Y ( ) ; double x 01 = v 0 . get X ( ) ; double y 01 = v 0 . get Y ( ) ; double x 11 = v 1 . get X ( ) ; double y 11 = v 1 . get Y ( ) ; double s = ( NUM_ / det ) * ( ( x 00 - x 10 ) * y 01 - ( y 00 - y 10 ) * x 01 ) ; double t = ( NUM_ / det ) * - ( - ( x 00 - x 10 ) * y 11 + ( y 00 - y 10 ) * x 11 ) ; return new java . awt . geom . Point 2 D . Double ( t , s ) ; }
public void filter Paths ( Path Callback cb ) { String dir Path = dir . get Path ( ) ; if ( ! dir Path . ends With ( STR_ ) ) { dir Path += STR_ ; } filter Paths ( dir , dir Path , cb ) ; }
private boolean match Filter ( String string , String pattern ) { if ( pattern . equals ( STR_ ) || pattern . equals ( string ) ) { return true ; } int length = pattern . length ( ) ; int wild Card Index = pattern . index Of ( STR_ ) ; if ( wild Card Index >= NUM_ ) { String pattern Sub Str = pattern . substring ( NUM_ , wild Card Index ) ; if ( ! string . starts With ( pattern Sub Str , NUM_ ) ) { return false ; } int begin Index = pattern Sub Str . length ( ) + NUM_ ; int string Index = NUM_ ; if ( wild Card Index > NUM_ ) { string Index = begin Index ; } String sub = pattern . substring ( begin Index , length ) ; while ( ( wild Card Index = pattern . index Of ( STR_ , begin Index ) ) != - NUM_ ) { pattern Sub Str = pattern . substring ( begin Index , wild Card Index ) ; if ( string . index Of ( pattern Sub Str , string Index ) == - NUM_ ) { return false ; } begin Index = wild Card Index + NUM_ ; string Index = string Index + pattern Sub Str . length ( ) + NUM_ ; sub = pattern . substring ( begin Index , length ) ; } if ( string . ends With ( sub ) ) { return true ; } } return false ; }
public static long current Time ( ) { if ( test Time > NUM_ ) return test Time ; else return System . current Time Millis ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
final boolean matches ( String s ) { return matches ( s , NUM_ , s . length ( ) ) ; }
private int fix Font Size ( float point Size ) { if ( screen Res != NUM_ ) { point Size = ( int ) Math . round ( point Size * screen Res / NUM_ ) ; } return ( int ) point Size ; }
boolean terminate ( ) { return ( state == null ) || state . terminate ( ) ; }
public int hash Code ( ) { int retval = NUM_ ; try { byte [ ] crl Data = X 509 CRL Impl . get Encoded Internal ( this ) ; for ( int i = NUM_ ; i < crl Data . length ; i ++ ) { retval += crl Data [ i ] * i ; } return retval ; } catch ( CRL Exception e ) { return retval ; } }
public Event do Wait Timeout ( long timeout ) { Event e = null ; long towait = NUM_ ; long endtime = - NUM_ ; boolean usetimeout = ( timeout > NUM_ ) ; if ( usetimeout ) { endtime = System . nano Time ( ) + timeout * NUM_ * NUM_ ; } if ( network Thread . get Done ( ) ) return null ; while ( e == null ) { if ( usetimeout ) { towait = ( endtime - System . nano Time ( ) ) ; if ( towait <= NUM_ ) { break ; } } else { if ( timeout == NUM_ ) { return latest Events . poll ( ) ; } } try { if ( usetimeout ) { e = latest Events . poll ( towait , Time Unit . NANOSECONDS ) ; } else { e = latest Events . take ( ) ; } } catch ( Interrupted Exception e 1 ) { } if ( e != null && e . t == E Type . KILLSENDER ) { return null ; } if ( network Thread . get Done ( ) ) return null ; } return e ; }
private int first Doc ( int i 4096 ) { long index = NUM_ ; while ( i 4096 < indices . length ) { index = indices [ i 4096 ] ; if ( index != NUM_ ) { final int i 64 = Long . number Of Trailing Zeros ( index ) ; return ( i 4096 << NUM_ ) | ( i 64 << NUM_ ) | Long . number Of Trailing Zeros ( bits [ i 4096 ] [ NUM_ ] ) ; } i 4096 += NUM_ ; } return Doc Id Set Iterator . NO MORE DOCS ; }
public synchronized Code Template remove Template ( String id ) { if ( id == null ) { throw new Illegal Argument Exception ( STR_ ) ; } for ( Iterator i = templates . iterator ( ) ; i . has Next ( ) ; ) { Code Template template = ( Code Template ) i . next ( ) ; if ( id . equals ( template . get ID ( ) ) ) { i . remove ( ) ; return template ; } } return null ; }
public static List < Trip > spatial Trip Filter ( List < Trip > trips , Spatial Trip Cutter cutter ) { List < Trip > filtered Trips = new Linked List < > ( ) ; for ( Trip temp Trip : trips ) { if ( cutter . spatially Considering Trip ( temp Trip ) ) { filtered Trips . add ( temp Trip . clone ( ) ) ; } } return Collections . unmodifiable List ( filtered Trips ) ; }
byte dir Type Backward ( ) { last Char = text . char At ( char Index - NUM_ ) ; if ( Character . is Low Surrogate ( last Char ) ) { int code Point = Character . code Point Before ( text , char Index ) ; char Index -= Character . char Count ( code Point ) ; return Character . get Directionality ( code Point ) ; } char Index -- ; byte dir Type = get Cached Directionality ( last Char ) ; if ( is Html ) { if ( last Char == STR_ ) { dir Type = skip Tag Backward ( ) ; } else if ( last Char == STR_ ) { dir Type = skip Entity Backward ( ) ; } } return dir Type ; }
@ Override public Shard Response take Completed Including Errors ( ) { return take ( false ) ; }
public boolean has Type Listeners ( ) { return ! type Listener Bindings . is Empty ( ) ; }
static boolean compatible Methods ( Class c 1 , Class c 2 ) { Method [ ] meths = c 1 . get Methods ( ) ; for ( int i = meths . length ; -- i >= NUM_ ; ) { Method m 1 = meths [ i ] ; try { Method m 2 = c 2 . get Method ( m 1 . get Name ( ) , m 1 . get Parameter Types ( ) ) ; if ( m 2 != null && m 1 . get Return Type ( ) != m 2 . get Return Type ( ) ) { return false ; } } catch ( No Such Method Exception e ) { } } return true ; }
static public final int random ( int start , int end ) { return start + random . next Int ( end - start + NUM_ ) ; }
public Interval reverse This ( ) { return Interval . from To By ( this . to , this . from , - this . step ) ; }
private boolean is First Record ( ) { return this . first Record ; }
public boolean is Empty ( ) { return collections . is Empty ( ) ; }
@ Override public Enumeration < String > enumerate Requests ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; if ( m fold Thread != null ) { new Vector . add Element ( STR_ ) ; } return new Vector . elements ( ) ; }
public boolean contains ( Key key ) { if ( key == null ) throw new Null Pointer Exception ( STR_ ) ; return set . contains ( key ) ; }
boolean within Max Capacity ( ) { return item List . size ( ) < CAPACITY ; }
public String path ( ) { if ( path == null ) { if ( ! has Path ) { return path = STR_ ; } int path End Pos = uri . index Of ( STR_ ) ; if ( path End Pos < NUM_ ) { path = uri ; } else { return path = uri . substring ( NUM_ , path End Pos ) ; } } return path ; }
public boolean contains Element ( Sequence Element element ) { return included Elements . contains ( element ) ; }
private static boolean has Selection Handle ( final P Node node ) { for ( Iterator i = node . get Children Iterator ( ) ; i . has Next ( ) ; ) { P Node n = ( P Node ) i . next ( ) ; if ( n instanceof Selection Handle ) { return true ; } } return false ; }
public static < T extends Generic Entity > List < T > filter By And ( List < T > values , List < ? extends Entity Condition > exprs ) { if ( values == null ) return null ; if ( Util Validate . is Empty ( exprs ) ) { return values ; } List < T > result = new Linked List < T > ( ) ; for ( T value : values ) { boolean include = true ; for ( Entity Condition condition : exprs ) { include = condition . entity Matches ( value ) ; if ( ! include ) break ; } if ( include ) { result . add ( value ) ; } } return result ; }
public double distance ( Coord coord ) { return Math . sqrt ( distance Square ( coord ) ) ; }
public Set < Property > all Properties ( ) { Set < Property > properties = new Hash Set < Property > ( ) ; for ( Node n : nodes ) { n . include Properties ( properties ) ; } return Collections . unmodifiable Set ( properties ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public int list Max Channel ( Database conn ) throws SQL Exception { Result Set rs = null ; Statement statement = null ; int max Channel = - NUM_ ; try { statement = conn . create Statement ( ) ; rs = statement . execute Query ( select Max ) ; while ( rs . next ( ) ) { max Channel = rs . get Int ( NUM_ ) ; } } finally { close ( rs ) ; close ( statement ) ; } return max Channel ; }
public boolean var Is Defined ( String var Name ) { return vars Defined . contains ( var Name ) ; }
public static int last Index Of ( final String value , final String needle , boolean case Sensitive ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; return last Index Of ( value , needle , value . length ( ) , case Sensitive ) ; }
public int index Of ( java . lang . String string ) { int start = NUM_ ; int sub Count = string . count ; int count = count ; if ( sub Count > NUM_ ) { if ( sub Count > count ) { return - NUM_ ; } char [ ] target = string . value ; int sub Offset = string . offset ; char first Char = target [ sub Offset ] ; int end = sub Offset + sub Count ; while ( true ) { int i = index Of ( first Char , start ) ; if ( i == - NUM_ || sub Count + i > count ) { return - NUM_ ; } int o 1 = offset + i , o 2 = sub Offset ; char [ ] value = value ; while ( ++ o 2 < end && value [ ++ o 1 ] == target [ o 2 ] ) { } if ( o 2 == end ) { return i ; } start = i + NUM_ ; } } return start < count ? start : count ; }
@ Override public Enumeration < String > enumerate Requests ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; if ( m build Thread != null ) { new Vector . add Element ( STR_ ) ; } if ( m build Thread == null && m Clusterer != null ) { new Vector . add Element ( STR_ ) ; } if ( m build Thread == null ) { new Vector . add Element ( STR_ ) ; } return new Vector . elements ( ) ; }
public static boolean is XML 11 Space ( int c ) { return ( c < NUM_ && ( XML 11 CHARS [ c ] & MASK XML 11 SPACE ) != NUM_ ) ; }
public Type type ( String fld Name ) { return fields . get ( fld Name ) ; }
public List < Correlation Identifier > find Correlation Ids ( Scope ... scope ) { List < Correlation Identifier > ret = null ; for ( int i = NUM_ ; i < correlation Ids . size ( ) ; i ++ ) { Correlation Identifier cid = correlation Ids . get ( i ) ; for ( int j = NUM_ ; j < scope . length ; j ++ ) { if ( cid . get Scope ( ) == scope [ j ] ) { if ( ret == null ) { ret = new Array List < Correlation Identifier > ( ) ; } if ( ! ret . contains ( cid ) ) { ret . add ( cid ) ; } } } } return ret == null ? Collections . empty List ( ) : ret ; }
public float distance ( double x , double y ) { Shape shape = get Shape ( ) ; if ( shape != null ) { return super . distance ( x , y ) ; } float temp , distance = Float . POSITIVE INFINITY ; if ( get Need To Regenerate ( ) ) { return distance ; } float [ ] [ ] xpts = xpoints ; float [ ] [ ] ypts = ypoints ; float [ ] x , y ; int len = xpts . length ; for ( int i = NUM_ ; i < len ; i ++ ) { x = xpts [ i ] ; y = ypts [ i ] ; if ( is Polygon ( ) && Draw Util . inside polygon ( x , y , x , y ) ) return NUM_ ; temp = Draw Util . closest Poly Distance ( x , y , x , y , false ) ; if ( temp < distance ) distance = temp ; } return normalize Distance For Line Width ( distance ) ; }
public int hash Code ( ) { return name . hash Code ( ) ^ owner . hash Code ( ) ; }
public int size ( ) { return m keys . size ( ) ; }
private static int [ ] strip Leading Zero Bytes ( byte a [ ] ) { int byte Length = a . length ; int keep ; for ( keep = NUM_ ; keep < byte Length && a [ keep ] == NUM_ ; keep ++ ) ; int int Length = ( ( byte Length - keep ) + NUM_ ) > > > NUM_ ; int [ ] result = new int [ int Length ] ; int b = byte Length - NUM_ ; for ( int i = int Length - NUM_ ; i >= NUM_ ; i -- ) { result [ i ] = a [ b -- ] & NUM_ ; int bytes Remaining = b - keep + NUM_ ; int bytes To Transfer = Math . min ( NUM_ , bytes Remaining ) ; for ( int j = NUM_ ; j <= ( bytes To Transfer << NUM_ ) ; j += NUM_ ) result [ i ] |= ( ( a [ b -- ] & NUM_ ) << j ) ; } return result ; }
@ Override protected boolean mouse Entered Drawable ( Drawable drawable ) { Diagram diag = tab . get Diagram ( ) ; if ( diag != null && diag . get State For Drawable ( drawable ) != null ) { return true ; } return false ; }
public void check Is Allocated ( ) { int original Bits = Addressable Memory Manager . read Int Volatile ( this . memory Address + REF COUNT OFFSET ) ; if ( ( original Bits & MAGIC MASK ) != MAGIC NUMBER ) { throw new Illegal State Exception ( STR_ + Integer . to Hex String ( original Bits ) ) ; } }
public double norm 2 ( ) { return Math . sqrt ( sum 2 ( ) ) ; }
public void shutdown ( ) { if ( VERBOSE ) Util . verbose ( STR_ ) ; disable ( ) ; discard Jobs ( null ) ; Thread thread = this . processing Thread ; try { if ( thread != null ) { synchronized ( this ) { this . processing Thread = null ; notify All ( ) ; } thread . join ( ) ; } Job job = this . progress Job ; if ( job != null ) { job . cancel ( ) ; job . join ( ) ; } } catch ( Interrupted Exception e ) { } }
public int value For Y Position ( int y Pos ) { int value ; int min Value = slider . get Minimum ( ) ; int max Value = slider . get Maximum ( ) ; int track Top = track Rect . y + thumb Rect . height / NUM_ + track Border ; int track Bottom = track Rect . y + track Rect . height - thumb Rect . height / NUM_ - track Border ; int track Length = track Bottom - track Top ; if ( y Pos <= track Top ) { value = draw Inverted ( ) ? min Value : max Value ; } else if ( y Pos >= track Bottom ) { value = draw Inverted ( ) ? max Value : min Value ; } else { int distance From Track Top = y Pos - track Top ; double value Range = ( double ) max Value - ( double ) min Value ; double value Per Pixel = value Range / ( double ) track Length ; int value From Track Top = ( int ) Math . round ( distance From Track Top * value Per Pixel ) ; value = draw Inverted ( ) ? min Value + value From Track Top : max Value - value From Track Top ; } return value ; }
protected synchronized void on Send Accepted ( Record Buffer < R > buffer ) { logger . trace ( STR_ , name ( ) , buffer ) ; throttler . on Send Accepted ( ) ; active Send Tasks . increment And Get ( ) ; }
protected boolean is Expanded ( Component node ) { Object e = node . get Client Property ( KEY EXPANDED ) ; return e != null && e . equals ( STR_ ) ; }
public boolean is Na N ( ) { return is Na N ( value ) ; }
public Iterator < I Point > points ( ) { return points . iterator ( ) ; }
private void dump ( int counter , I Node next ) { if ( ! logger . is Trace Enabled ( ) ) { return ; } String leaf Text = leaf Text ( next ) ; logger . trace ( String . format ( STR_ , counter , next . to String ( ) , leaf Text ) ) ; }
public boolean contains ( Album p ) { synchronized ( m Albums ) { return m Albums . contains ( p ) ; } }
protected Collection < T > sort ( Collection < T > records ) { return records ; }
public int size ( ) { return edges . size ( ) ; }
public static String extract Classname ( String fullname ) { return fullname . replace First ( STR_ , STR_ ) ; }
public boolean is Incremental Build ( ) { return incremental Build ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; return new Vector . elements ( ) ; }
public static String to Hex String ( Big Integer b ) { String hex Value = b . to String ( NUM_ ) ; String Buffer buf = new String Buffer ( hex Value . length ( ) * NUM_ ) ; if ( hex Value . starts With ( STR_ ) ) { buf . append ( STR_ ) ; hex Value = hex Value . substring ( NUM_ ) ; } else { buf . append ( STR_ ) ; } if ( ( hex Value . length ( ) % NUM_ ) != NUM_ ) { hex Value = STR_ + hex Value ; } int i = NUM_ ; while ( i < hex Value . length ( ) ) { buf . append ( hex Value . substring ( i , i + NUM_ ) ) ; i += NUM_ ; if ( i != hex Value . length ( ) ) { if ( ( i % NUM_ ) == NUM_ ) { buf . append ( STR_ ) ; } else if ( i % NUM_ == NUM_ ) { buf . append ( STR_ ) ; } } } return buf . to String ( ) ; }
public URI to URI ( ) throws URI Syntax Exception { return new URI ( to External Form ( ) ) ; }
protected static Long max ( Long l 1 , Long l 2 ) { if ( l 1 == null && l 2 == null ) { return null ; } if ( l 2 == null ) { return l 1 ; } if ( l 1 == null ) { return l 2 ; } return Math . max ( l 1 , l 2 ) ; }
public String to String Atomic ( ) { lock . lock ( ) ; try { return to String ( ) ; } finally { lock . unlock ( ) ; } }
static boolean are Equal ( Object a , Object b ) { return ( a == null ? b == null : a . equals ( b ) ) ; }
public static boolean is Volatile ( int mod ) { return Modifier . is Volatile ( mod ) ; }
public boolean contains ( final double VALUE ) { return ( Double . compare ( VALUE , get Start ( ) ) >= NUM_ && Double . compare ( VALUE , get Stop ( ) ) <= NUM_ ) ; }
public static String element Value ( Element element ) { if ( element == null ) return null ; element . normalize ( ) ; Node text Node = element . get First Child ( ) ; if ( text Node == null ) return null ; String Builder value Buffer = new String Builder ( ) ; do { if ( text Node . get Node Type ( ) == Node . CDATA SECTION NODE || text Node . get Node Type ( ) == Node . TEXT NODE ) { value Buffer . append ( text Node . get Node Value ( ) ) ; } } while ( ( text Node = text Node . get Next Sibling ( ) ) != null ) ; return value Buffer . to String ( ) ; }
private static boolean is Bk Error Not Recoverable ( int rc ) { switch ( rc ) { case Code . No Such Ledger Exists Exception : case Code . Read Exception : case Code . Ledger Recovery Exception : return true ; default : return false ; } }
public boolean implies ( Permission p ) { if ( ! ( p instanceof Discovery Permission ) ) return false ; String grp = p . get Name ( ) ; String group = get Name ( ) ; if ( group . starts With ( STR_ ) ) { if ( group . length ( ) == NUM_ ) return true ; if ( grp . length ( ) == NUM_ ) return false ; return ( grp . length ( ) >= group . length ( ) && group . region Matches ( false , NUM_ , grp , grp . length ( ) - group . length ( ) + NUM_ , group . length ( ) - NUM_ ) ) ; } if ( grp . starts With ( STR_ ) ) return false ; return group . equals ( grp ) ; }
public static String last ( final String value , int n ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; if ( n > value . length ( ) ) { return value ; } return value . substring ( value . length ( ) - n ) ; }
@ Override public Object clone ( ) { try { Identity Hash Map < K , V > clone Hash Map = ( Identity Hash Map < K , V > ) super . clone ( ) ; clone Hash Map . element Data = new Element Array ( element Data . length ) ; System . arraycopy ( element Data , NUM_ , clone Hash Map . element Data , NUM_ , element Data . length ) ; return clone Hash Map ; } catch ( Clone Not Supported Exception e ) { throw new Assertion Error ( e ) ; } }
@ Override public Set < K > key Set ( ) { return new Key Set ( this ) ; }
private boolean has Next Proxy ( ) { return next Proxy Index < proxies . size ( ) ; }
private boolean is Empty ( ) { return m Path . get Current Point ( ) == null ; }
public boolean is Shareable ( Class < ? > entity Class ) { return get Annotation ( entity Class , Share Permission . class ) != null ; }
public long real Length ( ) throws IO Exception { long ret = backing Random Access File . length ( ) ; return ret ; }
public void enter ( ) throws Exception { enter ( - NUM_ , null ) ; }
private static boolean is Integer Translation ( Affine Transform xform ) { if ( xform . is Identity ( ) ) { return true ; } if ( xform . get Type ( ) == Affine Transform . TYPE TRANSLATION ) { double tx = xform . get Translate X ( ) ; double ty = xform . get Translate Y ( ) ; return ( tx == ( int ) tx && ty == ( int ) ty ) ; } return false ; }
public int length ( ) { return ( my Message . length ( ) ) ; }
public String obtain Foundation For Peer Reflexive Candidate ( ) { return Integer . to String ( last Assigned Remote Foundation ++ ) ; }
public static String format As Generalized Time ( final long date ) { final String Builder sb = new String Builder ( NUM_ ) ; final Gregorian Calendar calendar = new Gregorian Calendar ( TIME ZONE UTC OBJ ) ; calendar . set Lenient ( false ) ; calendar . set Time In Millis ( date ) ; int n = calendar . get ( Calendar . YEAR ) ; if ( n < NUM_ ) { final Illegal Argument Exception e = new Illegal Argument Exception ( STR_ + n ) ; throw e ; } else if ( n < NUM_ ) { sb . append ( STR_ ) ; } else if ( n < NUM_ ) { sb . append ( STR_ ) ; } else if ( n < NUM_ ) { sb . append ( STR_ ) ; } sb . append ( n ) ; n = calendar . get ( Calendar . MONTH ) + NUM_ ; if ( n < NUM_ ) { sb . append ( STR_ ) ; } sb . append ( n ) ; n = calendar . get ( Calendar . DAY OF MONTH ) ; if ( n < NUM_ ) { sb . append ( STR_ ) ; } sb . append ( n ) ; n = calendar . get ( Calendar . HOUR OF DAY ) ; if ( n < NUM_ ) { sb . append ( STR_ ) ; } sb . append ( n ) ; n = calendar . get ( Calendar . MINUTE ) ; if ( n < NUM_ ) { sb . append ( STR_ ) ; } sb . append ( n ) ; n = calendar . get ( Calendar . SECOND ) ; if ( n < NUM_ ) { sb . append ( STR_ ) ; } sb . append ( n ) ; sb . append ( STR_ ) ; n = calendar . get ( Calendar . MILLISECOND ) ; if ( n < NUM_ ) { sb . append ( STR_ ) ; } else if ( n < NUM_ ) { sb . append ( STR_ ) ; } sb . append ( n ) ; sb . append ( STR_ ) ; return sb . to String ( ) ; }
public static String extract Response ( String saml Request Parameter ) throws Exception { Inflater decompresser = new Inflater ( true ) ; Byte Array Output Stream byte Array Output Stream = new Byte Array Output Stream ( ) ; Inflater Output Stream inflater Output Stream = new Inflater Output Stream ( byte Array Output Stream , decompresser ) ; inflater Output Stream . write ( Base 64 . decode ( saml Request Parameter ) ) ; inflater Output Stream . close ( ) ; String output String = new String ( byte Array Output Stream . to Byte Array ( ) , STR_ ) ; return output String ; }
@ Override public synchronized boolean take Partition ( String topic , int partition ) { Set < Integer > partition Set = m my Topic Partitions . get ( topic ) ; if ( partition Set == null ) return false ; String owner Path = owner Path ( topic , partition ) ; try { if ( m zk . exists ( owner Path ) ) { return false ; } if ( m zk . create ( owner Path , true ) ) { m zk . write String ( owner Path , m consumer Id ) ; partition Set . add ( partition ) ; return true ; } else return false ; } catch ( Runtime Exception e ) { throw e ; } catch ( Exception e ) { LOGGER . error ( STR_ + owner Path , e ) ; return false ; } }
public Tungsten Properties subset ( String prefix , boolean remove Prefix ) { return subset ( prefix , remove Prefix , false ) ; }
public void request Seconds Until Authentication Failure Unlock ( ) { operations . add ( Password Policy State Operation Type . GET SECONDS UNTIL AUTHENTICATION FAILURE UNLOCK ) ; }
public static Vector weighted Superposition ( Vector left , double left Weight , Vector right , double right Weight ) { if ( ( left . get Vector Type ( ) != right . get Vector Type ( ) ) || ( left . get Dimension ( ) != right . get Dimension ( ) ) ) { throw new Incompatible Vectors Exception ( String . format ( STR_ , left . to String ( ) , right . to String ( ) ) ) ; } switch ( left . get Vector Type ( ) ) { case REAL : case COMPLEX : Vector superposition = Vector Factory . create Zero Vector ( left . get Vector Type ( ) , left . get Dimension ( ) ) ; superposition . superpose ( left , left Weight , null ) ; superposition . superpose ( right , right Weight , null ) ; superposition . normalize ( ) ; return superposition ; case BINARY : return Binary Vector Utils . weighted Superposition ( ( Binary Vector ) left , left Weight , ( Binary Vector ) right , right Weight ) ; default : throw new Incompatible Vectors Exception ( STR_ + left . get Vector Type ( ) ) ; } }
public byte [ ] to Byte Array ( ) { int len = data . length + NUM_ ; byte b [ ] = new byte [ len ] ; b [ NUM_ ] = ( byte ) ( ( len > > > NUM_ ) & NUM_ ) ; b [ NUM_ ] = ( byte ) ( ( len > > > NUM_ ) & NUM_ ) ; b [ NUM_ ] = ( byte ) ( ( len > > > NUM_ ) & NUM_ ) ; b [ NUM_ ] = ( byte ) ( ( len > > > NUM_ ) & NUM_ ) ; b [ NUM_ ] = ( byte ) ( ( id > > > NUM_ ) & NUM_ ) ; b [ NUM_ ] = ( byte ) ( ( id > > > NUM_ ) & NUM_ ) ; b [ NUM_ ] = ( byte ) ( ( id > > > NUM_ ) & NUM_ ) ; b [ NUM_ ] = ( byte ) ( ( id > > > NUM_ ) & NUM_ ) ; b [ NUM_ ] = ( byte ) flags ; if ( ( flags & Packet . Reply ) == NUM_ ) { b [ NUM_ ] = ( byte ) cmd Set ; b [ NUM_ ] = ( byte ) cmd ; } else { b [ NUM_ ] = ( byte ) ( ( error Code > > > NUM_ ) & NUM_ ) ; b [ NUM_ ] = ( byte ) ( ( error Code > > > NUM_ ) & NUM_ ) ; } if ( data . length > NUM_ ) { System . arraycopy ( data , NUM_ , b , NUM_ , data . length ) ; } return b ; }
public int size ( ) { return this . values ; }
public static String [ ] sort Copy ( String [ ] objects ) { int len = objects . length ; String [ ] copy = new String [ len ] ; System . arraycopy ( objects , NUM_ , copy , NUM_ , len ) ; sort ( copy ) ; return copy ; }
@ Override public int insert Unassigned Group ( int analysis Group ) throws Ade Exception { if ( analysis Group != UNASSIGNED ANALYSIS GROUP ID ) { throw new Ade Internal Exception ( STR_ ) ; } int analysis Group Internal Id ; analysis Group Internal Id = get Unassigned Group Internal Id ( ) ; if ( analysis Group Internal Id != NUM_ ) return analysis Group Internal Id ; final Connection Wrapper cw = new Connection Wrapper ( Ade Internal . get Default Connection ( ) ) ; Result Set generated Key = null ; Prepared Statement ps = null ; try { final int rule Id = insert Unassigned Rules ( ) ; final int evaluation Order = get Num Of Groups ( cw ) + NUM_ ; Prepared Statement Wrapper psw = cw . prepared Statement ( STR_ + SQL . GROUPS + STR_ + STR_ + STR_ , new String [ ] { STR_ } ) ; ps = psw . get Prepared Statement ( ) ; int pos = NUM_ ; ps . set String ( pos ++ , UNASSIGNED GROUP NAME ) ; ps . set Int ( pos ++ , UNASSIGNED GROUP TYPE ) ; ps . set Int ( pos ++ , UNASSIGNED DATA TYPE ) ; ps . set Int ( pos ++ , rule Id ) ; ps . set Int ( pos ++ , evaluation Order ) ; ps . execute ( ) ; generated Key = ps . get Generated Keys ( ) ; if ( generated Key . next ( ) ) { analysis Group Internal Id = generated Key . get Int ( NUM_ ) ; } cw . close ( ) ; } catch ( SQL Exception e ) { cw . failed ( e ) ; } finally { cw . quiet Cleanup ( ) ; try { if ( generated Key != null ) generated Key . close ( ) ; } catch ( SQL Exception e ) { logger . error ( STR_ , e ) ; } try { if ( ps != null ) ps . close ( ) ; } catch ( SQL Exception e ) { logger . error ( STR_ , e ) ; } } return analysis Group Internal Id ; }
public final Assert Subscriber < T > await ( Duration timeout ) { if ( cdl . get Count ( ) == NUM_ ) { return this ; } try { if ( ! cdl . await ( timeout . to Millis ( ) , Time Unit . MILLISECONDS ) ) { throw new Assertion Error ( STR_ ) ; } return this ; } catch ( Interrupted Exception ex ) { throw new Assertion Error ( STR_ , ex ) ; } }
@ Override public String model Name ( ) { return STR_ ; }
public boolean contains ( T obj ) { if ( ! map . contains ( obj ) ) return false ; return bits . get ( map . get Int ( obj ) ) ; }
public static Date string To Date ( String str Date ) throws Parse Exception { int [ ] diff Time = null ; boolean plus Time = true ; int idx T = str Date . index Of ( STR_ ) ; if ( idx T == - NUM_ ) { throw new Parse Exception ( STR_ , NUM_ ) ; } int idx Diff UTC = str Date . index Of ( STR_ , idx T ) ; if ( idx Diff UTC == - NUM_ ) { idx Diff UTC = str Date . index Of ( STR_ , idx T ) ; plus Time = false ; } if ( idx Diff UTC != - NUM_ ) { diff Time = get Diff Time ( str Date , idx Diff UTC ) ; str Date = str Date . substring ( NUM_ , idx Diff UTC ) ; } char last Char = str Date . char At ( str Date . length ( ) - NUM_ ) ; if ( ( last Char == STR_ ) || ( last Char == STR_ ) ) { str Date = str Date . substring ( NUM_ , str Date . length ( ) - NUM_ ) ; } return create Date ( str Date , diff Time , plus Time ) ; }
@ Suppress Warnings ( STR_ ) public List < Object > split By Lists ( String text , boolean recurse ) { List < Object > text List = new Array List < > ( ) ; String remain Text = text ; msg Handler . log Debug ( STR_ + STR_ + STR_ ) ; while ( true ) { Map < String , Object > list Info = find Parse Bullet List ( remain Text , false ) ; if ( list Info == null ) { break ; } int start Index = ( int ) list Info . get ( STR_ ) ; int end Index = ( int ) list Info . get ( STR_ ) ; if ( start Index > NUM_ ) { text List . add ( remain Text . substring ( NUM_ , start Index ) ) ; } if ( recurse ) { List < Object > parsed Items = new Array List < > ( ) ; List < Object > item Texts = ( List < Object > ) list Info . get ( STR_ ) ; if ( item Texts != null && ! item Texts . is Empty ( ) ) { for ( Object item Entry : item Texts ) { String item Text = ( String ) item Entry ; List < Object > parsed Item List = split By Structural Elems ( item Text ) ; parsed Items . add ( parsed Item List ) ; } } list Info . put ( STR_ , parsed Items ) ; } text List . add ( list Info ) ; remain Text = remain Text . substring ( end Index ) ; } if ( ! remain Text . is Empty ( ) ) { text List . add ( remain Text ) ; } msg Handler . log Debug ( STR_ + text List . size ( ) ) ; return text List ; }
public int size ( ) { return read Methods . size ( ) ; }
default Type Declaration as Type ( ) { throw new Unsupported Operation Exception ( String . format ( STR_ , this ) ) ; }
public static Input . Tok start Tok ( Token token ) { for ( Input . Tok tok : token . get Toks Before ( ) ) { if ( tok . get Index ( ) >= NUM_ ) { return tok ; } } return token . get Tok ( ) ; }
public final int size ( ) { return vertices . size ( ) ; }
protected static String reverse ( String str ) { String Builder buf = new String Builder ( ) ; for ( int i = str . length ( ) - NUM_ ; i >= NUM_ ; -- i ) { buf . append ( str . char At ( i ) ) ; } return buf . to String ( ) ; }
private boolean do Flush ( boolean apply All Deletes ) throws IO Exception { if ( tragedy != null ) { throw new Illegal State Exception ( STR_ , tragedy ) ; } do Before Flush ( ) ; test Point ( STR_ ) ; boolean success = false ; try { if ( info Stream . is Enabled ( STR_ ) ) { info Stream . message ( STR_ , STR_ + apply All Deletes ) ; info Stream . message ( STR_ , STR_ + seg String ( ) ) ; } boolean any Changes = false ; synchronized ( full Flush Lock ) { boolean flush Success = false ; try { long seq No = doc Writer . flush All Threads ( ) ; if ( seq No < NUM_ ) { seq No = - seq No ; any Changes = true ; } else { any Changes = false ; } if ( ! any Changes ) { flush Count . increment And Get ( ) ; } flush Success = true ; } finally { doc Writer . finish Full Flush ( this , flush Success ) ; process Events ( false , true ) ; } } synchronized ( this ) { any Changes |= maybe Apply Deletes ( apply All Deletes ) ; do After Flush ( ) ; success = true ; return any Changes ; } } catch ( Aborting Exception | Virtual Machine Error tragedy ) { tragic Event ( tragedy , STR_ ) ; return false ; } finally { if ( ! success ) { if ( info Stream . is Enabled ( STR_ ) ) { info Stream . message ( STR_ , STR_ ) ; } } } }
@ Override public File Channel open File Channel ( Open Option ... options ) throws IO Exception { return File Channel . open ( get Jdk Path ( ) , options ) ; }
public static String create Hash ( char [ ] password ) throws No Such Algorithm Exception , Invalid Key Spec Exception { Secure Random random = new Secure Random ( ) ; byte [ ] salt = new byte [ SALT BYTE SIZE ] ; random . next Bytes ( salt ) ; byte [ ] hash = pbkdf 2 ( password , salt , PBKDF 2 ITERATIONS , HASH BYTE SIZE ) ; return PBKDF 2 ITERATIONS + STR_ + to Hex ( salt ) + STR_ + to Hex ( hash ) ; }
public boolean has Sub Attributes ( ) { return sub Attributes != null && ! sub Attributes . is Empty ( ) ; }
public static String time To String ( String time ) { String the Time = null ; if ( Pattern . matches ( STR_ , time ) ) { int hour = Integer . parse Int ( time . substring ( NUM_ , NUM_ ) ) ; int min = Integer . parse Int ( time . substring ( NUM_ ) ) ; the Time = time To String ( hour , min ) ; } return the Time ; }
public double distance ( Vector 3 point ) { double xd = this . x - point . x ; double yd = this . y - point . y ; double zd = this . z - point . z ; return Math . sqrt ( xd * xd + yd * yd + zd * zd ) ; }
public static List < Mapped Member > find Method Parent ( Mapped Class owner , String name , String desc , boolean original Names ) { List < Mapped Member > list = new Array List < Mapped Member > ( ) ; for ( Mapped Class interface Class : owner . get Interfaces ( ) ) { Mapped Member mm = find Method In Parent Inclusive ( interface Class , name , desc , original Names ) ; if ( mm != null ) { list . add ( mm ) ; } } if ( owner . get Parent ( ) != null ) { Mapped Member mm = find Method In Parent Inclusive ( owner . get Parent ( ) , name , desc , original Names ) ; if ( mm != null ) { list . add ( mm ) ; } } return list ; }
public Logger logger ( ) { return logger ; }
List help Options ( ) { return new Array List ( short Opts . values ( ) ) ; }
public Set key Set ( ) { if ( key Set == null ) key Set = new Synchronized Set ( new Key Set ( ) , this ) ; return key Set ; }
@ Override public Object clone ( ) throws Clone Not Supported Exception { XY Area Renderer clone = ( XY Area Renderer ) super . clone ( ) ; clone . legend Area = Shape Utilities . clone ( this . legend Area ) ; return clone ; }
public Shape create Scroll Button Apart ( int x , int y , int w , int h ) { path . reset ( ) ; path . move To ( x , y ) ; path . line To ( x , y + h ) ; path . line To ( x + w , y + h ) ; add Scroll Gap Path ( x , y , w , h , true ) ; path . close Path ( ) ; return path ; }
public String create Hash ( char [ ] password ) { Secure Random random = new Secure Random ( ) ; byte [ ] salt = new byte [ salt Bytes ] ; random . next Bytes ( salt ) ; byte [ ] hash = pbkdf 2 ( password , salt , pbkdf 2 Iterations , hash Bytes ) ; return pbkdf 2 Iterations + STR_ + to Hex ( salt ) + STR_ + to Hex ( hash ) ; }
public static Credential basic ( String user Name , String password ) { try { String username And Password = user Name + STR_ + password ; byte [ ] bytes = username And Password . get Bytes ( STR_ ) ; String encoded = Base 64 . encode ( bytes ) ; return new Credential ( STR_ + encoded ) ; } catch ( Unsupported Encoding Exception e ) { throw new Assertion Error ( ) ; } }
public Edge find Edge ( Coordinate p 0 , Coordinate p 1 ) { for ( int i = NUM_ ; i < edges . size ( ) ; i ++ ) { Edge e = ( Edge ) edges . get ( i ) ; Coordinate [ ] e Coord = e . get Coordinates ( ) ; if ( p 0 . equals ( e Coord [ NUM_ ] ) && p 1 . equals ( e Coord [ NUM_ ] ) ) return e ; } return null ; }
protected static Vector convert To Vector ( final Object [ ] [ ] an Array ) { if ( an Array == null ) { return null ; } final Vector v = new Vector ( an Array . length ) ; for ( final Object [ ] element : an Array ) { v . add Element ( convert To Vector ( element ) ) ; } return v ; }
public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM_ ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
public void request Remaining Grace Login Count ( ) { operations . add ( Password Policy State Operation Type . GET REMAINING GRACE LOGIN COUNT ) ; }
@ Override public boolean can Produce Rules ( ) { return true ; }
private static int translate Batch ( Hyper Graph graph , Set < HG Handle > batch , RAM Storage Graph subgraph , Map < HG Handle , Object > objects , Mapping < Pair < HG Handle , Object > , HG Handle > atom Finder , Map < HG Handle , HG Handle > substitutes ) { int replacements = NUM_ ; for ( HG Handle atom : batch ) { Object object = read Atom ( atom , graph , new HG Atom Resolver < HG Atom Type > ( graph ) , subgraph ) ; HG Handle existing = atom Finder == null ? null : atom Finder . eval ( new Pair < HG Handle , Object > ( atom , object ) ) ; if ( existing != null ) { substitutes . put ( atom , existing ) ; if ( ! existing . equals ( atom ) ) replacements ++ ; } else objects . put ( atom , object ) ; } return replacements ; }
public static char [ ] copy ( final char [ ] array , final int offset , final int length ) { ensure Offset Length ( array , offset , length ) ; final char [ ] a = length == NUM_ ? EMPTY ARRAY : new char [ length ] ; System . arraycopy ( array , offset , a , NUM_ , length ) ; return a ; }
protected void do Sub Line ( byte [ ] cur Line ) { int sub = ( int ) Math . ceil ( ( get Bits Per Component ( ) * get Colors ( ) ) / NUM_ ) ; for ( int i = NUM_ ; i < cur Line . length ; i ++ ) { int prev Idx = i - sub ; if ( prev Idx >= NUM_ ) { cur Line [ i ] += cur Line [ prev Idx ] ; } } }
private void check Required Fields ( Simple Object simple Object , String [ ] required Fields ) { List < String > missing Fields = new Array List < > ( ) ; for ( String required Field : required Fields ) { if ( ! simple Object . contains Key ( required Field ) ) { missing Fields . add ( required Field ) ; } } if ( ! missing Fields . is Empty ( ) ) { throw new Invalid Object Data Exception ( STR_ + String Utils . join ( missing Fields , STR_ ) ) ; } }
private int pick Color ( final String identifier ) { if ( Text Utils . is Empty ( identifier ) ) { return s Default Color ; } final int color = Math . abs ( identifier . hash Code ( ) ) % s Colors . length ( ) ; return s Colors . get Color ( color , s Default Color ) ; }
public Long Stream Ex remove ( Long Predicate predicate ) { return filter ( predicate . negate ( ) ) ; }
public Enumeration < String > communities ( ) { Hash Set < String > set = new Hash Set < String > ( ) ; Vector < String > res = new Vector < String > ( ) ; for ( Enumeration < Acl Entry > e = acl . entries ( ) ; e . has More Elements ( ) ; ) { Acl Entry Impl entry = ( Acl Entry Impl ) e . next Element ( ) ; for ( Enumeration < String > cs = entry . communities ( ) ; cs . has More Elements ( ) ; ) { set . add ( cs . next Element ( ) ) ; } } String [ ] objs = set . to Array ( new String [ NUM_ ] ) ; for ( int i = NUM_ ; i < objs . length ; i ++ ) res . add Element ( objs [ i ] ) ; return res . elements ( ) ; }
protected String handle Time ( Time time ) { return time == null ? null : time . to String ( ) ; }
public int current Segment ( float [ ] coords ) { if ( is Done ( ) ) { throw new No Such Element Exception ( STR_ ) ; } double angle = ang St Rad ; if ( index == NUM_ ) { coords [ NUM_ ] = ( float ) ( x + Math . cos ( angle ) * w ) ; coords [ NUM_ ] = ( float ) ( y + Math . sin ( angle ) * h ) ; if ( affine != null ) { affine . transform ( coords , NUM_ , coords , NUM_ , NUM_ ) ; } return SEG MOVETO ; } if ( index > arc Segs ) { if ( index == arc Segs + line Segs ) { return SEG CLOSE ; } coords [ NUM_ ] = ( float ) x ; coords [ NUM_ ] = ( float ) y ; if ( affine != null ) { affine . transform ( coords , NUM_ , coords , NUM_ , NUM_ ) ; } return SEG LINETO ; } angle += increment * ( index - NUM_ ) ; double relx = Math . cos ( angle ) ; double rely = Math . sin ( angle ) ; coords [ NUM_ ] = ( float ) ( x + ( relx - cv * rely ) * w ) ; coords [ NUM_ ] = ( float ) ( y + ( rely + cv * relx ) * h ) ; angle += increment ; relx = Math . cos ( angle ) ; rely = Math . sin ( angle ) ; coords [ NUM_ ] = ( float ) ( x + ( relx + cv * rely ) * w ) ; coords [ NUM_ ] = ( float ) ( y + ( rely - cv * relx ) * h ) ; coords [ NUM_ ] = ( float ) ( x + relx * w ) ; coords [ NUM_ ] = ( float ) ( y + rely * h ) ; if ( affine != null ) { affine . transform ( coords , NUM_ , coords , NUM_ , NUM_ ) ; } return SEG CUBICTO ; }
public List < String > explain Mismatch ( Issue issue ) { Objects . require Non Null ( issue ) ; List < String > result = new Linked List < > ( ) ; for ( Issue Property Matcher property Matcher : property Matchers ) { if ( ! property Matcher . matches ( issue ) ) result . add ( property Matcher . get Message ( issue ) ) ; } return result ; }
public String Builder encode Body ( String Builder buffer ) { return buffer . append ( organization ) ; }
public int size ( ) { return cells . size ( ) ; }
private String [ ] split Out Nag ( String word Token ) { if ( word Token . starts With ( STR_ ) ) { int digit End Index = NUM_ ; for ( int i = NUM_ ; i < word Token . length ( ) ; i ++ ) { if ( ! Character . is Digit ( word Token . char At ( i ) ) ) { break ; } else { digit End Index ++ ; } } if ( digit End Index <= NUM_ ) { return null ; } else if ( word Token . length ( ) == digit End Index ) { return new String [ ] { word Token } ; } else { return new String [ ] { word Token . substring ( NUM_ , digit End Index ) , word Token . substring ( digit End Index , word Token . length ( ) ) } ; } } return null ; }
private static String fields To String Pretty ( Json Object json Obj , int level ) { String Buffer buf = new String Buffer ( ) ; String indent = STR_ + VA Utils . indent ( level ) ; boolean first Field = true ; for ( Map . Entry < String , Json Element > entry : json Obj . entry Set ( ) ) { String field = entry . get Key ( ) ; if ( ! field . equals ( CHILDREN PROP ) && ! field . equals ( STR_ ) ) { if ( ! first Field ) buf . append ( STR_ ) ; if ( level == NUM_ && first Field ) buf . append ( STR_ ) ; else buf . append ( indent ) ; first Field = false ; buf . append ( field ) ; buf . append ( STR_ ) ; Json Element value = entry . get Value ( ) ; buf . append ( to String Pretty ( value , level + NUM_ ) ) ; } } return buf . to String ( ) ; }
public static Book book ( String name ) { if ( name . equals ( DEFAULT DB NAME ) ) throw new Paper Db Exception ( DEFAULT DB NAME + STR_ ) ; return get Book ( name ) ; }
void return Object To Pool ( V v ) { m Object Creator . prepare Object To Enter Pool ( v ) ; m Pool . push ( v ) ; }
public void rethrow Error ( ) throws Throwable { if ( tag == ERROR ) { if ( value instanceof Type Not Present Exception ) { Type Not Present Exception tnpe = ( Type Not Present Exception ) value ; throw new Type Not Present Exception ( tnpe . type Name ( ) , tnpe . get Cause ( ) ) ; } else if ( value instanceof Enum Constant Not Present Exception ) { Enum Constant Not Present Exception ecnpe = ( Enum Constant Not Present Exception ) value ; throw new Enum Constant Not Present Exception ( ecnpe . enum Type ( ) , ecnpe . constant Name ( ) ) ; } else if ( value instanceof Array Store Exception ) { Array Store Exception ase = ( Array Store Exception ) value ; throw new Array Store Exception ( ase . get Message ( ) ) ; } Throwable error = ( Throwable ) value ; Stack Trace Element [ ] ste = error . get Stack Trace ( ) ; Byte Array Output Stream bos = new Byte Array Output Stream ( ste == null ? NUM_ : ( ste . length + NUM_ ) * NUM_ ) ; Object Output Stream oos = new Object Output Stream ( bos ) ; oos . write Object ( error ) ; oos . flush ( ) ; oos . close ( ) ; Byte Array Input Stream bis = new Byte Array Input Stream ( bos . to Byte Array ( ) ) ; Object Input Stream ois = new Object Input Stream ( bis ) ; error = ( Throwable ) ois . read Object ( ) ; ois . close ( ) ; throw error ; } }
@ Suppress Warnings ( STR_ ) public Registry Context ( String host , int port , Hashtable < ? , ? > env ) throws Naming Exception { environment = ( env == null ) ? new Hashtable < String , Object > ( NUM_ ) : ( Hashtable < String , Object > ) env ; if ( environment . get ( SECURITY MGR ) != null ) { install Security Mgr ( ) ; } if ( ( host != null ) && ( host . char At ( NUM_ ) == STR_ ) ) { host = host . substring ( NUM_ , host . length ( ) - NUM_ ) ; } RMI Client Socket Factory socket Factory = ( RMI Client Socket Factory ) environment . get ( SOCKET FACTORY ) ; registry = get Registry ( host , port , socket Factory ) ; this . host = host ; this . port = port ; }
@ Deprecated public boolean is Session Valid ( ) { return ( get Access Token ( ) != null ) && ( ( get Access Expires ( ) == NUM_ ) || ( System . current Time Millis ( ) < get Access Expires ( ) ) ) ; }
public Iterator < X Atom > iterator ( ) { return atoms . iterator ( ) ; }
static public boolean is Equal ( float a , float b ) { return Math . abs ( a - b ) <= FLOAT ROUNDING ERROR ; }
public V Plex Virtual Volume Info find Virtual Volume ( String virtual Volume Name , String virtual Volume Path ) { V Plex Virtual Volume Info vvinfo = null ; if ( virtual Volume Path != null && ! virtual Volume Path . is Empty ( ) ) { try { vvinfo = get Virtual Volume By Path ( virtual Volume Path ) ; } catch ( Exception ex ) { s logger . warn ( STR_ , virtual Volume Path , virtual Volume Name ) ; } } if ( null == vvinfo && ( null != virtual Volume Name && ! virtual Volume Name . is Empty ( ) ) ) { vvinfo = find Virtual Volume And Update Info ( virtual Volume Name ) ; } s logger . info ( STR_ ) ; return vvinfo ; }
public boolean is Service Visible ( String service Name ) { return ! Collection Utils . is Empty ( hidden Services ) && ! hidden Services . contains ( service Name ) ; }
static boolean is Empty ( Char Sequence str ) { return str == null || str . length ( ) == NUM_ ; }
private boolean has Emailable Attendees ( ) { for ( Attendee attendee : m Accepted Attendees ) { if ( Utils . is Emailable From ( attendee . m Email , m Sync Account Name ) ) { return true ; } } for ( Attendee attendee : m Tentative Attendees ) { if ( Utils . is Emailable From ( attendee . m Email , m Sync Account Name ) ) { return true ; } } for ( Attendee attendee : m No Response Attendees ) { if ( Utils . is Emailable From ( attendee . m Email , m Sync Account Name ) ) { return true ; } } for ( Attendee attendee : m Declined Attendees ) { if ( Utils . is Emailable From ( attendee . m Email , m Sync Account Name ) ) { return true ; } } return false ; }
public static float next Random Float ( ) { return rand . next Float ( ) ; }
public int num Checkpoints ( ) { return checkpoints . size ( ) ; }
public boolean distributed Experiment Selected ( ) { return m enable Distributed Experiment . is Selected ( ) ; }
protected String to String Char Char ( char [ ] [ ] names ) { String Buffer result = new String Buffer ( ) ; for ( int i = NUM_ ; i < names . length ; i ++ ) { result . append ( to String Char ( names [ i ] ) ) ; } return result . to String ( ) ; }
public static boolean is Thread Alerting ( ) { return alerting . get ( ) ; }
public Dimension preferred Layout Size ( Container target ) { synchronized ( target . get Tree Lock ( ) ) { Dimension dim = new Dimension ( NUM_ , NUM_ ) ; if ( ( chart != null ) && chart . is Visible ( ) ) { Dimension d = chart . get Preferred Size ( ) ; dim . width = d . width ; dim . height = d . height ; } if ( ( x Label != null ) && x Label . is Visible ( ) ) { Dimension d = x Label . get Preferred Size ( ) ; dim . width = Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } if ( ( y Label != null ) && y Label . is Visible ( ) ) { Dimension d = y Label . get Preferred Size ( ) ; dim . width += d . width + hgap ; dim . height = Math . max ( d . height , dim . height ) ; } if ( ( title != null ) && title . is Visible ( ) ) { Dimension d = title . get Preferred Size ( ) ; dim . width = Math . max ( d . width , dim . width ) ; dim . height += d . height + vgap ; } Insets insets = target . get Insets ( ) ; dim . width += insets . left + insets . right ; dim . height += insets . top + insets . bottom ; return dim ; } }
public Set < I Privilege > search ( Subject admin Subject , String realm , Buffered Iterator iterator , Resource Search Indexes indexes , Set < String > subject Indexes , boolean b Sub Tree , Set < String > exclude D Ns ) throws Entitlement Exception { SSO Token token = get SSO Token ( admin Subject ) ; Set < I Privilege > results = search Privileges ( realm , iterator , indexes , subject Indexes , b Sub Tree , exclude D Ns ) ; int count Int = get Number Of Referrals ( realm ) ; if ( count Int > NUM_ ) { results . add All ( search Referral ( token , realm , iterator , indexes , b Sub Tree , exclude D Ns ) ) ; } return results ; }
public static File task Local Dir ( UUID loc Node Id , Hadoop Task Info info ) throws Ignite Checked Exception { File job Loc Dir = job Local Dir ( loc Node Id , info . job Id ( ) ) ; return new File ( job Loc Dir , info . type ( ) + STR_ + info . task Number ( ) + STR_ + info . attempt ( ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override public final int hash Code ( ) { int rc = NUM_ + property Name . hash Code ( ) ; return NUM_ * rc + the Class . hash Code ( ) ; }
public boolean is Healthy ( boolean do Extensive Checks ) { if ( socket . is Closed ( ) || socket . is Input Shutdown ( ) || socket . is Output Shutdown ( ) ) { return false ; } if ( framed Connection != null ) { return true ; } if ( do Extensive Checks ) { try { int read Timeout = socket . get So Timeout ( ) ; try { socket . set So Timeout ( NUM_ ) ; if ( source . exhausted ( ) ) { return false ; } return true ; } finally { socket . set So Timeout ( read Timeout ) ; } } catch ( Socket Timeout Exception ignored ) { } catch ( IO Exception e ) { return false ; } } return true ; }
public boolean is Lib Class ( String clz ) { if ( Config . v ( ) . apk != null ) { for ( String lib Pkg Prefix : Config . v ( ) . library Package Prefixes ) { if ( clz . starts With ( lib Pkg Prefix ) ) return true ; } } return lib Classes . contains ( clz ) ; }
static < T > T check Not Null ( T instance , String name ) { if ( instance == null ) { throw new Null Pointer Exception ( name + STR_ ) ; } return instance ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public boolean contains ( String name ) { return legions By Name . contains Key ( name . to Lower Case ( ) ) ; }
protected static Segment Info new Segment Info ( Directory dir , String name ) { return new Segment Info ( dir , Version . LATEST , name , NUM_ , false , Codec . get Default ( ) , Collections . empty Map ( ) , String Helper . random Id ( ) , new Hash Map < > ( ) , null ) ; }
protected boolean is Relevant ( String term ) { return term . length ( ) >= NUM_ && matches ( character Pattern , term ) ; }
public S 1 Interval expanded ( double radius ) { if ( is Empty ( ) ) { return this ; } if ( get Length ( ) + NUM_ * radius >= NUM_ * S 2 . M PI - NUM_ ) { return full ( ) ; } double lo = Math . IEE Eremainder ( lo ( ) - radius , NUM_ * S 2 . M PI ) ; double hi = Math . IEE Eremainder ( hi ( ) + radius , NUM_ * S 2 . M PI ) ; if ( lo == - S 2 . M PI ) { lo = S 2 . M PI ; } return new S 1 Interval ( lo , hi ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public boolean mark Time If Delay ( World world , long delay ) { if ( world == null ) { return false ; } long current Time = world . get Total World Time ( ) ; if ( current Time < last Mark ) { last Mark = current Time ; return false ; } else if ( last Mark + delay + last Random Delay <= current Time ) { duration = current Time - last Mark ; last Mark = current Time ; last Random Delay = ( int ) ( Math . random ( ) * random Range ) ; return true ; } else { return false ; } }
public static boolean is Termination Cancelled ( Http Servlet Request request ) { String status = request . get Parameter ( IFS Constants . TERMINATION STATUS ) ; if ( status != null && status . equals Ignore Case ( IFS Constants . CANCEL ) ) { return true ; } else { return false ; } }
protected synchronized byte [ ] engine Generate Seed ( int num Bytes ) { byte [ ] my Bytes ; if ( num Bytes < NUM_ ) { throw new Negative Array Size Exception ( Integer . to String ( num Bytes ) ) ; } if ( num Bytes == NUM_ ) { return Empty Array . BYTE ; } if ( my Random == null ) { my Random = new SHA 1 PRNG Secure Random Impl ( ) ; my Random . engine Set Seed ( get Random Bytes ( DIGEST LENGTH ) ) ; } my Bytes = new byte [ num Bytes ] ; my Random . engine Next Bytes ( my Bytes ) ; return my Bytes ; }
public static Method find Method With ( Class < ? > search Class , Class < ? extends Annotation > annotation Class ) { Method found Method = null ; method Finder : while ( search Class != null && search Class != Object . class ) { for ( Method method : search Class . get Declared Methods ( ) ) { if ( method . is Annotation Present ( annotation Class ) ) { found Method = method ; break method Finder ; } } search Class = search Class . get Superclass ( ) ; } return found Method ; }
public boolean is Not ( ) { return not ; }
public int [ ] to Array ( ) { int [ ] value = new int [ size ] ; System . arraycopy ( data , NUM_ , value , NUM_ , size ) ; return value ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static Collection < String > node Id 8 s ( @ Nullable Collection < ? extends Cluster Node > nodes ) { if ( nodes == null || nodes . is Empty ( ) ) return Collections . empty List ( ) ; return F . view Read Only ( nodes , NODE 2 ID 8 ) ; }
private List < String > missing Food ( final Player player , final boolean hash ) { final List < String > result = new Linked List < String > ( ) ; String done Text = player . get Quest ( QUEST SLOT ) ; if ( done Text == null ) { done Text = STR_ ; } final List < String > done = Arrays . as List ( done Text . split ( STR_ ) ) ; for ( String ingredient : NEEDED FOOD ) { if ( ! done . contains ( ingredient ) ) { if ( hash ) { ingredient = STR_ + ingredient ; } result . add ( ingredient ) ; } } return result ; }
public static String repeat ( String source String , int factor ) { if ( factor < NUM_ ) { return STR_ ; } if ( factor == NUM_ ) { return source String ; } String Builder sb = new String Builder ( factor * source String . length ( ) ) ; while ( factor > NUM_ ) { sb . append ( source String ) ; factor -- ; } return sb . to String ( ) ; }
public static boolean is Watch Feature Required ( @ Not Null Android Facet facet ) { Merged Manifest merged Manifest = Merged Manifest . get ( facet ) ; Element feature = merged Manifest . find Used Feature ( Uses Feature . HARDWARE TYPE WATCH ) ; return feature != null && is Required ( feature ) ; }
private static int index Of Least Significant Zero Bit ( int value ) { int index = NUM_ ; while ( ( value & NUM_ ) != NUM_ ) { value >>= NUM_ ; index ++ ; } return index ; }
public static boolean is Dual Role ( String host Entity Id , String realm ) { try { SPSSO Config Element sp Config = saml 2 Meta Manager . get SPSSO Config ( realm , host Entity Id ) ; if ( sp Config == null ) { return false ; } IDPSSO Config Element idp Config = saml 2 Meta Manager . get IDPSSO Config ( realm , host Entity Id ) ; return idp Config != null ; } catch ( Exception e ) { return false ; } }
public boolean needs Upgrading ( Shard Id shard ) { final Path [ ] paths = node Environment . available Shard Paths ( shard ) ; if ( paths . length > NUM_ ) { int num Paths Exist = NUM_ ; for ( Path path : paths ) { if ( Files . exists ( path . resolve ( Meta Data State Format . STATE DIR NAME ) ) ) { num Paths Exist ++ ; if ( num Paths Exist > NUM_ ) { return true ; } } } } return false ; }
public static final double correlation ( double y 1 [ ] , double y 2 [ ] , int n ) { int i ; double av 1 = NUM_ , av 2 = NUM_ , y 11 = NUM_ , y 22 = NUM_ , y 12 = NUM_ , c ; if ( n <= NUM_ ) { return NUM_ ; } for ( i = NUM_ ; i < n ; i ++ ) { av 1 += y 1 [ i ] ; av 2 += y 2 [ i ] ; } av 1 /= ( double ) n ; av 2 /= ( double ) n ; for ( i = NUM_ ; i < n ; i ++ ) { y 11 += ( y 1 [ i ] - av 1 ) * ( y 1 [ i ] - av 1 ) ; y 22 += ( y 2 [ i ] - av 2 ) * ( y 2 [ i ] - av 2 ) ; y 12 += ( y 1 [ i ] - av 1 ) * ( y 2 [ i ] - av 2 ) ; } if ( y 11 * y 22 == NUM_ ) { c = NUM_ ; } else { c = y 12 / Math . sqrt ( Math . abs ( y 11 * y 22 ) ) ; } return c ; }
public String product Release Date ( ) { return properties . get Property ( STR_ ) ; }
@ Override public Version version ( ) { return Version Util . version For ( get Class ( ) ) ; }
public boolean equals ( Object another ) { if ( another instanceof Principal Impl ) { Principal Impl p = ( Principal Impl ) another ; return user . equals ( p . to String ( ) ) ; } else return false ; }
@ Suppress Warnings ( STR_ ) public < V > Flux Concat Array < V > concat Additional Ignored Last ( Publisher < ? extends V > source ) { int n = array . length ; Publisher < ? extends V > [ ] new Array = new Publisher [ n + NUM_ ] ; System . arraycopy ( array , NUM_ , new Array , NUM_ , n ) ; new Array [ n - NUM_ ] = new Mono Ignore Then < > ( new Array [ n - NUM_ ] ) ; new Array [ n ] = source ; return new Flux Concat Array < > ( delay Error , new Array ) ; }
protected double compute Log Floor ( double lower ) { double log Floor ; if ( this . allow Negatives Flag ) { if ( lower > NUM_ ) { log Floor = Math . log ( lower ) / LOG 10 VALUE ; log Floor = Math . floor ( log Floor ) ; log Floor = Math . pow ( NUM_ , log Floor ) ; } else if ( lower < - NUM_ ) { log Floor = Math . log ( - lower ) / LOG 10 VALUE ; log Floor = Math . floor ( - log Floor ) ; log Floor = - Math . pow ( NUM_ , - log Floor ) ; } else { log Floor = Math . floor ( lower ) ; } } else { if ( lower > NUM_ ) { log Floor = Math . log ( lower ) / LOG 10 VALUE ; log Floor = Math . floor ( log Floor ) ; log Floor = Math . pow ( NUM_ , log Floor ) ; } else { log Floor = Math . floor ( lower ) ; } } return log Floor ; }
@ Nullable public Pki Verification Data verify Pki ( ) { return pki Verification Data ; }
public boolean has Migration ( Submitted Migration m ) { return migrations . contains ( m ) ; }
public Shape create Internal Drop Shadow Rounded ( final int x , final int y , final int w , final int h ) { final double radius = h / NUM_ ; final int right = x + w ; final double bottom = y + radius ; path . reset ( ) ; path . move To ( x , bottom ) ; path . quad To ( x , y , x + radius , y ) ; path . line To ( right - radius , y ) ; path . quad To ( right , y , right , bottom ) ; path . line To ( right - NUM_ , bottom ) ; path . quad To ( right - NUM_ , y + NUM_ , right - radius - NUM_ , y + NUM_ ) ; path . line To ( x + radius + NUM_ , y + NUM_ ) ; path . quad To ( x + NUM_ , y + NUM_ , x + NUM_ , bottom ) ; path . close Path ( ) ; return path ; }
public int hash Code ( ) { if ( hashcode == NUM_ ) { int result = NUM_ ; result = NUM_ * result + issuer . hash Code ( ) ; result = NUM_ * result + serial . hash Code ( ) ; hashcode = result ; } return hashcode ; }
public static void assert Symmetric ( I Double Matrix mat , double epsilon ) { assert Square ( mat ) ; for ( int i = NUM_ ; i < mat . get Row Num ( ) ; ++ i ) { for ( int j = i + NUM_ ; j < mat . get Row Num ( ) ; ++ j ) { final double v 1 = mat . get ( i , j ) ; final double v 2 = mat . get ( j , i ) ; if ( Double . is Na N ( v 1 ) || Double . is Na N ( v 2 ) ) { if ( ! Double . is Na N ( v 1 ) || ! Double . is Na N ( v 2 ) ) { final String msg = String . format ( STR_ , i , j , v 1 , j , i , v 2 ) ; throw new Ade Core Illegal Argument Exception ( msg ) ; } } else if ( Math . abs ( v 1 - v 2 ) > epsilon ) { final String error Msg = String . format ( STR_ , i , j , v 1 , j , i , v 2 , epsilon ) ; throw new Ade Core Illegal Argument Exception ( error Msg ) ; } } } }
public static Char Array Writer read All Chars From Reader ( Reader reader ) throws IO Exception { try { final int BUFFER SIZE = NUM_ ; char [ ] buffer = new char [ BUFFER SIZE ] ; Char Array Writer chars = new Char Array Writer ( ) ; int read ; while ( ( read = reader . read ( buffer ) ) != EOF ) { chars . write ( buffer , NUM_ , read ) ; } return chars ; } finally { reader . close ( ) ; } }
public Collection < Output Port > output Ports ( ) { return output Ports . values ( ) ; }
public Period plus Months ( long months To Add ) { if ( months To Add == NUM_ ) { return this ; } return create ( years , Math . to Int Exact ( Math . add Exact ( months , months To Add ) ) , days ) ; }
protected static @ Not Null String convert Map To Groovy Source ( @ Not Null Map < String , Object > map ) { String Builder sb = new String Builder ( ) ; for ( Map . Entry < String , Object > entry : map . entry Set ( ) ) { if ( sb . length ( ) > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( entry . get Key ( ) ) ; sb . append ( STR_ ) ; sb . append ( convert Value To Groovy Source ( entry . get Value ( ) ) ) ; } return sb . to String ( ) ; }
public static boolean is On ( String option ) { if ( args == null ) return false ; else { if ( args . index Of ( STR_ ) != - NUM_ ) return true ; else return ( args . index Of ( option ) != - NUM_ ) ; } }
public Register Spec List subset ( Bit Set exclusion Set ) { int new Size = size ( ) - exclusion Set . cardinality ( ) ; if ( new Size == NUM_ ) { return EMPTY ; } Register Spec List result = new Register Spec List ( new Size ) ; int new Index = NUM_ ; for ( int old Index = NUM_ ; old Index < size ( ) ; old Index ++ ) { if ( ! exclusion Set . get ( old Index ) ) { result . set 0 ( new Index , get 0 ( old Index ) ) ; new Index ++ ; } } if ( is Immutable ( ) ) { result . set Immutable ( ) ; } return result ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public boolean is Accept ( int state ) { return is Accept . get ( state ) ; }
public int num Records ( ) { return super . num Records ( ) ; }
public String next String ( char quote ) throws JSON Exception { char c ; String Buffer sb = new String Buffer ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case NUM_ : case STR_ : case STR_ : throw syntax Error ( STR_ ) ; case STR_ : c = next ( ) ; switch ( c ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : try { sb . append ( ( char ) Integer . parse Int ( next ( NUM_ ) , NUM_ ) ) ; } catch ( Number Format Exception e ) { throw new JSON Exception ( STR_ ) ; } break ; case STR_ : case STR_ : case STR_ : case STR_ : sb . append ( c ) ; break ; default : throw syntax Error ( STR_ ) ; } break ; default : if ( c == quote ) { return sb . to String ( ) ; } sb . append ( c ) ; } } }
private void parse Token ( String token ) { int len = token . length ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { int chr = sr . read ( ) ; if ( chr == - NUM_ ) { throw new Illegal Argument Exception ( STR_ + token ) ; } chr = Character . to Lower Case ( ( char ) chr ) ; int lo Token Char = token . char At ( i ) ; if ( lo Token Char != chr ) { throw new Illegal Argument Exception ( STR_ + token + STR_ + sr . get Position ( ) ) ; } } }
public static boolean has Digit ( String token ) { int len = token . length ( ) ; for ( int i = NUM_ ; i < len ; ++ i ) { char c = token . char At ( i ) ; if ( Character . is Digit ( c ) ) { return true ; } } return false ; }
public boolean is Directory ( ) { return name . ends With ( STR_ ) ; }
public static boolean property Inherits ( CSS Name css Name ) { return css Name . property Inherits ; }
public int size ( ) { return list . size ( ) ; }
public final static boolean ends With Ignore Case ( String str , String end ) { int str Length = str == null ? NUM_ : str . length ( ) ; int end Length = end == null ? NUM_ : end . length ( ) ; if ( end Length > str Length ) return false ; for ( int i = NUM_ ; i <= end Length ; i ++ ) { if ( Scanner Helper . to Lower Case ( end . char At ( end Length - i ) ) != Scanner Helper . to Lower Case ( str . char At ( str Length - i ) ) ) return false ; } return true ; }
public static UDP Heart Beat create Client Heart Beat ( Inet Address address , int port , int interval Ms ) { return new UDP Client Heart Beat ( address , port , interval Ms ) ; }
private static boolean should Include Field ( Field Doc field , String access Type ) { if ( field . is Static ( ) || Annotation Utils . has Annotation ( field , Known Annotations . XML Transient Annotation ) || Annotation Utils . has Annotation ( field , Known Annotations . XML Attribute Annotation ) ) { return false ; } if ( access Type . equals ( STR_ ) ) { return ! field . is Static ( ) && ! field . is Transient ( ) ; } else if ( access Type . equals ( STR_ ) ) { return field . is Public ( ) ; } else if ( access Type . equals ( STR_ ) ) { return false ; } else if ( access Type . equals ( STR_ ) ) { return false ; } return false ; }
protected void wait Until Stopped ( ) { boolean done Waiting = false ; while ( ! done Waiting ) { if ( auto Engineer != null ) { done Waiting = auto Engineer . is Stopped ( ) ; } else { done Waiting = true ; } if ( ! done Waiting ) { try { Thread . sleep ( NUM_ ) ; } catch ( Interrupted Exception e ) { } } } }
public static Vector 3 min ( Vector 3 o 1 , Vector 3 o 2 ) { return new Vector 3 ( Math . min ( o 1 . x , o 2 . x ) , Math . min ( o 1 . y , o 2 . y ) , Math . min ( o 1 . z , o 2 . z ) ) ; }
public static String left Pad ( final String value , final String pad , final int length ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; validate ( pad , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; if ( value . length ( ) > length ) { return value ; } return append ( repeat ( pad , length - value . length ( ) ) , value ) ; }
protected int hprs ( int N , int M , int n , Random Engine random Generator ) { int Dk , X , V ; double Mp , np , p , nu , U , Y , W ; if ( N != N last || M != M last || n != n last ) { N last = N ; M last = M ; n last = n ; Mp = ( double ) ( M + NUM_ ) ; np = ( double ) ( n + NUM_ ) ; N Mn = N - M - n ; p = Mp / ( N + NUM_ ) ; nu = np * p ; U = Math . sqrt ( nu * ( NUM_ - p ) * ( NUM_ - ( n + NUM_ ) / ( N + NUM_ ) ) + NUM_ ) ; m = ( int ) nu ; k 2 = ( int ) Math . ceil ( nu - NUM_ - U ) ; if ( k 2 >= m ) k 2 = m - NUM_ ; k 4 = ( int ) ( nu - NUM_ + U ) ; k 1 = k 2 + k 2 - m + NUM_ ; k 5 = k 4 + k 4 - m ; dl = ( double ) ( k 2 - k 1 ) ; dr = ( double ) ( k 5 - k 4 ) ; r 1 = ( np / ( double ) k 1 - NUM_ ) * ( Mp - k 1 ) / ( double ) ( N Mn + k 1 ) ; r 2 = ( np / ( double ) k 2 - NUM_ ) * ( Mp - k 2 ) / ( double ) ( N Mn + k 2 ) ; r 4 = ( np / ( double ) ( k 4 + NUM_ ) - NUM_ ) * ( M - k 4 ) / ( double ) ( N Mn + k 4 + NUM_ ) ; r 5 = ( np / ( double ) ( k 5 + NUM_ ) - NUM_ ) * ( M - k 5 ) / ( double ) ( N Mn + k 5 + NUM_ ) ; ll = Math . log ( r 1 ) ; lr = - Math . log ( r 5 ) ; c pm = fc lnpk ( m , N Mn , M , n ) ; f 2 = Math . exp ( c pm - fc lnpk ( k 2 , N Mn , M , n ) ) ; f 4 = Math . exp ( c pm - fc lnpk ( k 4 , N Mn , M , n ) ) ; f 1 = Math . exp ( c pm - fc lnpk ( k 1 , N Mn , M , n ) ) ; f 5 = Math . exp ( c pm - fc lnpk ( k 5 , N Mn , M , n ) ) ; p 1 = f 2 * ( dl + NUM_ ) ; p 2 = f 2 * dl + p 1 ; p 3 = f 4 * ( dr + NUM_ ) + p 2 ; p 4 = f 4 * dr + p 3 ; p 5 = f 1 / ll + p 4 ; p 6 = f 5 / lr + p 5 ; } for ( ; ; ) { if ( ( U = random Generator . raw ( ) * p 6 ) < p 2 ) { if ( ( W = U - p 1 ) < NUM_ ) return ( k 2 + ( int ) ( U / f 2 ) ) ; if ( ( Y = W / dl ) < f 1 ) return ( k 1 + ( int ) ( W / f 1 ) ) ; Dk = ( int ) ( dl * random Generator . raw ( ) ) + NUM_ ; if ( Y <= f 2 - Dk * ( f 2 - f 2 / r 2 ) ) { return ( k 2 - Dk ) ; } if ( ( W = f 2 + f 2 - Y ) < NUM_ ) { V = k 2 + Dk ; if ( W <= f 2 + Dk * ( NUM_ - f 2 ) / ( dl + NUM_ ) ) { return ( V ) ; } if ( Math . log ( W ) <= c pm - fc lnpk ( V , N Mn , M , n ) ) { return ( V ) ; } } X = k 2 - Dk ; } else if ( U < p 4 ) { if ( ( W = U - p 3 ) < NUM_ ) return ( k 4 - ( int ) ( ( U - p 2 ) / f 4 ) ) ; if ( ( Y = W / dr ) < f 5 ) return ( k 5 - ( int ) ( W / f 5 ) ) ; Dk = ( int ) ( dr * random Generator . raw ( ) ) + NUM_ ; if ( Y <= f 4 - Dk * ( f 4 - f 4 * r 4 ) ) { return ( k 4 + Dk ) ; } if ( ( W = f 4 + f 4 - Y ) < NUM_ ) { V = k 4 - Dk ; if ( W <= f 4 + Dk * ( NUM_ - f 4 ) / dr ) { return ( V ) ; } if ( Math . log ( W ) <= c pm - fc lnpk ( V , N Mn , M , n ) ) { return ( V ) ; } } X = k 4 + Dk ; } else { Y = random Generator . raw ( ) ; if ( U < p 5 ) { Dk = ( int ) ( NUM_ - Math . log ( Y ) / ll ) ; if ( ( X = k 1 - Dk ) < NUM_ ) continue ; Y *= ( U - p 4 ) * ll ; if ( Y <= f 1 - Dk * ( f 1 - f 1 / r 1 ) ) { return ( X ) ; } } else { Dk = ( int ) ( NUM_ - Math . log ( Y ) / lr ) ; if ( ( X = k 5 + Dk ) > n ) continue ; Y *= ( U - p 5 ) * lr ; if ( Y <= f 5 - Dk * ( f 5 - f 5 * r 5 ) ) { return ( X ) ; } } } if ( Math . log ( Y ) <= c pm - fc lnpk ( X , N Mn , M , n ) ) return ( X ) ; } }
public float distance To Center ( float x , float y ) { MP Point F c = get Center Offsets ( ) ; float dist = NUM_ ; float x Dist = NUM_ ; float y Dist = NUM_ ; if ( x > c . x ) { x Dist = x - c . x ; } else { x Dist = c . x - x ; } if ( y > c . y ) { y Dist = y - c . y ; } else { y Dist = c . y - y ; } dist = ( float ) Math . sqrt ( Math . pow ( x Dist , NUM_ ) + Math . pow ( y Dist , NUM_ ) ) ; MP Point F . recycle Instance ( c ) ; return dist ; }
public String next String ( int length ) { char [ ] chars = new char [ length ] ; for ( int i = NUM_ ; i < chars . length ; i ++ ) { chars [ i ] = ALPHABET . char At ( next Int ( ALPHABET . length ( ) ) ) ; } return new String ( chars ) ; }
public int hash Code ( ) { return addr . hash Code ( ) ; }
public String connection String ( String url Pattern ) { Properties props = config . as Properties ( ) ; return find And Replace ( url Pattern , props , Jdbc Configuration . DATABASE , Jdbc Configuration . HOSTNAME , Jdbc Configuration . PORT , Jdbc Configuration . USER , Jdbc Configuration . PASSWORD ) ; }
public static boolean ends With ( char s [ ] , int len , String suffix ) { final int suffix Len = suffix . length ( ) ; if ( suffix Len > len ) return false ; for ( int i = suffix Len - NUM_ ; i >= NUM_ ; i -- ) if ( s [ len - ( suffix Len - i ) ] != suffix . char At ( i ) ) return false ; return true ; }
private boolean is Named Param ( String arg ) { return arg . starts With ( STR_ ) && ( arg . index Of ( STR_ ) > NUM_ && valid First Char ( arg . char At ( NUM_ ) ) ) ; }
@ Method Desc ( description = STR_ , usage = STR_ ) public Map < String , String > replicator Status ( @ Param Desc ( name = STR_ , description = STR_ ) String name ) throws Exception { Open Replicator Manager M Bean mgr = replicators . get ( name ) ; if ( mgr == null ) { throw new Exception ( String . format ( STR_ , name ) ) ; } return mgr . status ( ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
default Parameter Declaration as Parameter ( ) { throw new Unsupported Operation Exception ( String . format ( STR_ , this ) ) ; }
public static Number sqrt ( Number a ) { if ( ( a . double Value ( ) < NUM_ ) && Settings . is Protected Functions ( ) ) { return Math . sqrt ( Math . abs ( a . double Value ( ) ) ) ; } else { return Math . sqrt ( a . double Value ( ) ) ; } }
public void save Selection ( I Mini Table mini Table ) { log . info ( STR_ ) ; Array List < Integer > results = new Array List < Integer > ( ) ; set Selection ( null ) ; int rows = mini Table . get Row Count ( ) ; for ( int i = NUM_ ; i < rows ; i ++ ) { ID Column id = ( ID Column ) mini Table . get Value At ( i , NUM_ ) ; if ( id != null && id . is Selected ( ) ) results . add ( id . get Record ID ( ) ) ; } if ( results . size ( ) == NUM_ ) return ; log . config ( STR_ + results . size ( ) ) ; set Selection ( results ) ; }
public static boolean same Document URI ( String uri ) { return ( uri != null && ( uri . length ( ) == NUM_ || uri . char At ( NUM_ ) == STR_ ) ) ; }
public int number Of Disconnected Groups ( Collection < String > genomes ) { final String [ ] genomes 2 = genomes . to Array ( new String [ genomes . size ( ) ] ) ; final int [ ] connections Matrix = new int [ genomes . size ( ) * genomes . size ( ) ] ; final Hash Set < Integer > group Ids = new Hash Set < > ( ) ; for ( int j = NUM_ ; j < genomes 2 . length ; j ++ ) { int min = j + NUM_ ; final String g 1 = genomes 2 [ j ] ; for ( int i = NUM_ ; i < genomes 2 . length ; i ++ ) { final String g 2 = genomes 2 [ i ] ; if ( are Related ( g 1 , g 2 ) ) { connections Matrix [ j * genomes 2 . length + i ] = j + NUM_ ; for ( int k = NUM_ ; k < j ; k ++ ) { final int value = connections Matrix [ k * genomes 2 . length + i ] ; if ( value != NUM_ && value < min ) { min = value ; } } } } for ( int i = NUM_ ; i < genomes 2 . length ; i ++ ) { if ( connections Matrix [ j * genomes 2 . length + i ] != NUM_ ) { connections Matrix [ j * genomes 2 . length + i ] = min ; group Ids . add ( min ) ; } } } return group Ids . size ( ) ; }
private I Container container For Path ( I Path path ) { if ( path . segment Count ( ) == NUM_ ) { return workspace Root . get Project ( path . segment ( NUM_ ) ) ; } else { return workspace Root . get Folder ( path ) ; } }
public static int expand Roman ( String roman ) { int value = NUM_ ; for ( int p = NUM_ ; p < roman . length ( ) ; p ++ ) { char c = roman . char At ( p ) ; if ( c == STR_ ) { value += NUM_ ; } else if ( c == STR_ ) { value += NUM_ ; } else if ( c == STR_ ) { if ( p + NUM_ < roman . length ( ) ) { char p 1 = roman . char At ( p + NUM_ ) ; if ( p 1 == STR_ ) { value += NUM_ ; p ++ ; } else if ( p 1 == STR_ ) { value += NUM_ ; p ++ ; } else { value += NUM_ ; } } else { value += NUM_ ; } } } return value ; }
public final Sector union ( Sector that ) { if ( that == null ) return this ; Angle min Lat = this . min Latitude ; Angle max Lat = this . max Latitude ; Angle min Lon = this . min Longitude ; Angle max Lon = this . max Longitude ; if ( that . min Latitude . degrees < this . min Latitude . degrees ) min Lat = that . min Latitude ; if ( that . max Latitude . degrees > this . max Latitude . degrees ) max Lat = that . max Latitude ; if ( that . min Longitude . degrees < this . min Longitude . degrees ) min Lon = that . min Longitude ; if ( that . max Longitude . degrees > this . max Longitude . degrees ) max Lon = that . max Longitude ; return new Sector ( min Lat , max Lat , min Lon , max Lon ) ; }
public void throw Runtime ( String reason ) { throw Runtime ( reason , Optional . empty ( ) ) ; }
public boolean is Selected ( Object cell ) { return ( cell == null ) ? false : cells . contains ( cell ) ; }
public static < T > int detect Last Index ( List < T > list , Predicate < ? super T > predicate ) { if ( list instanceof Random Access ) { return Random Access List Iterate . detect Last Index ( list , predicate ) ; } int size = list . size ( ) ; int i = size - NUM_ ; List Iterator < T > reverse Iterator = list . list Iterator ( size ) ; while ( reverse Iterator . has Previous ( ) ) { if ( predicate . accept ( reverse Iterator . previous ( ) ) ) { return i ; } i -- ; } return - NUM_ ; }
public String read Entry ( String folder Name , int folder Id ) throws Exception { String db Name = Folder Utils . get Db Name ( folder Id ) ; Zip Entry folder Entry = zip . get Entry ( db Name ) ; if ( folder Entry == null ) { throw new Exception ( ) ; } Parse Data parse Data = new Parse Data ( ) ; parse Data . dest Name = Folder Utils . new Db Name ( context , m Ignore Db Names ) ; parse Data . folder Name = folder Name ; parse Data . src Entry = folder Entry ; m Ignore Db Names . add ( parse Data . dest Name ) ; m Parsed List . add ( parse Data ) ; return parse Data . dest Name ; }
public final boolean has Subscription ( ) { return subscription . get ( ) != null ; }
public final int count Data Scheme Specific Parts ( ) { return m Data Scheme Specific Parts != null ? m Data Scheme Specific Parts . size ( ) : NUM_ ; }
@ Override public int length Of Month ( ) { return iso Date . length Of Month ( ) ; }
public boolean is Delete Allowed ( Cn A Tree Element cte ) { if ( cte instanceof Import Iso Group ) { return true ; } if ( cte instanceof IBSI Struktur Kategorie ) { return false ; } if ( cte instanceof IT Verbund || cte instanceof Organization ) { return is Write Allowed ( cte ) ; } return is Write Allowed ( cte ) && is Write Allowed ( cte . get Parent ( ) ) ; }
public Wrapped Byte Buffer slice ( ) { return Wrapped Byte Buffer . wrap ( buf . slice ( ) ) ; }
@ Override public int port Local ( ) { Socket Channel s = channel ; if ( s != null ) { try { Inet Socket Address addr = ( Inet Socket Address ) s . get Local Address ( ) ; return addr . get Port ( ) ; } catch ( IO Exception e ) { throw new Runtime Exception ( e ) ; } } else { return - NUM_ ; } }
@ Override public double max Impurity ( ) { return m max Impurity ; }
private static int hash ( Object x , int length ) { int h = System . identity Hash Code ( x ) ; return ( ( h << NUM_ ) - ( h << NUM_ ) ) & ( length - NUM_ ) ; }
@ Override public Selectable Channel selectable Channel ( ) { if ( s != null ) { return s . get Channel ( ) ; } else { return null ; } }
private String token Class ( String string ) { if ( string == null ) { return null ; } else if ( string . starts With ( STR_ ) ) { return STR_ ; } else if ( is Number And Punctuation ( string ) ) { return STR_ ; } return string ; }
public synchronized long time ( ) { if ( start Nano Time == NUM_ ) { return NUM_ ; } if ( time >= NUM_ ) { return time ; } return Math . max ( NUM_ , Time Value . nsec To M Sec ( System . nano Time ( ) - start Nano Time ) ) ; }
public static boolean is File Valid ( @ Nullable File file ) { return file != null && file . exists ( ) ; }
public static List order By String Length ( Collection collection ) { List ordered = new Array List ( collection ) ; Collections . sort ( ordered , new String Length Comparator ( ) ) ; return ordered ; }
public static float random ( float f ) { return ( ( float ) Math . random ( ) ) * f ; }
private int root Native Handle ( ) { return ( is User Node ( ) ? USER ROOT NATIVE HANDLE : SYSTEM ROOT NATIVE HANDLE ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public Object Vector parse Vector Line ( String line ) throws IO Exception { int first Split Point = line . index Of ( STR_ ) ; String object Name = new String ( line . substring ( NUM_ , first Split Point ) ) ; Vector tmp Vector = Vector Factory . create Zero Vector ( vector Type , dimension ) ; tmp Vector . read From String ( line . substring ( first Split Point + NUM_ , line . length ( ) ) ) ; return new Object Vector ( object Name , tmp Vector ) ; }
private void raise Error Event ( int dialog Timeout Error ) { SIP Dialog Error Event new Error Event ; Iterator < SIP Dialog Event Listener > listener Iterator ; SIP Dialog Event Listener next Listener ; new Error Event = new SIP Dialog Error Event ( this , dialog Timeout Error ) ; synchronized ( event Listeners ) { listener Iterator = event Listeners . iterator ( ) ; while ( listener Iterator . has Next ( ) ) { next Listener = ( SIP Dialog Event Listener ) listener Iterator . next ( ) ; next Listener . dialog Error Event ( new Error Event ) ; } } event Listeners . clear ( ) ; if ( dialog Timeout Error != SIP Dialog Error Event . DIALOG ACK NOT SENT TIMEOUT && dialog Timeout Error != SIP Dialog Error Event . DIALOG ACK NOT RECEIVED TIMEOUT && dialog Timeout Error != SIP Dialog Error Event . DIALOG REINVITE TIMEOUT ) { delete ( ) ; } stop Timer ( ) ; }
boolean is Contextual Search Url ( String url ) { return url . equals ( get Search Url ( ) ) ; }
public Comm Message create Aggregated Request ( Comm Message message ) throws URI Syntax Exception { return new Comm Message ( Comm Message . get New Message Id ( ) , message . operation Name ( ) , get Resource Path ( ) , message . value ( ) , message . fault ( ) ) ; }
public static Double Stream of ( double ... values ) { return Arrays . stream ( values ) ; }
public long available ( ) throws IO Exception { return ( is . available ( ) + avail ) * NUM_ + fill ; }
public String next ( Pattern pattern ) { check Open ( ) ; check Not Null ( pattern ) ; match Successful = false ; save Current Status ( ) ; if ( ! set Token Region ( ) ) { recover Previous Status ( ) ; throw new No Such Element Exception ( ) ; } matcher . use Pattern ( pattern ) ; if ( ! matcher . matches ( ) ) { recover Previous Status ( ) ; throw new Input Mismatch Exception ( ) ; } match Successful = true ; return matcher . group ( ) ; }
@ Suppress Warnings ( STR_ ) public static String unqualified Class Name ( Class type ) { if ( type . is Array ( ) ) { return unqualified Class Name ( type . get Component Type ( ) ) + STR_ ; } String name = type . get Name ( ) ; return name . substring ( name . last Index Of ( STR_ ) + NUM_ ) ; }
static public double k 0 ( double x ) throws Arithmetic Exception { double y , z ; if ( x <= NUM_ ) throw new Arithmetic Exception ( ) ; if ( x <= NUM_ ) { y = x * x - NUM_ ; y = Arithmetic . chbevl ( y , A k 0 , NUM_ ) - Math . log ( NUM_ * x ) * i 0 ( x ) ; return ( y ) ; } z = NUM_ / x - NUM_ ; y = Math . exp ( - x ) * Arithmetic . chbevl ( z , B k 0 , NUM_ ) / Math . sqrt ( x ) ; return ( y ) ; }
public List < Local Date > bottom ( int n ) { List < Local Date > bottom = new Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ; Int Arrays . parallel Quick Sort ( values ) ; for ( int i = NUM_ ; i < n && i < values . length ; i ++ ) { bottom . add ( Packed Local Date . as Local Date ( values [ i ] ) ) ; } return bottom ; }
private boolean ends With Separator ( String path ) { return path . ends With ( STR_ ) || path . ends With ( STR_ ) ; }
public String cross Val Tip Text ( ) { return STR_ ; }
private String string ( int val ) { return val != - NUM_ ? String . value Of ( val ) : STR_ ; }
public static int uniform ( int n ) { if ( n <= NUM_ ) throw new Illegal Argument Exception ( STR_ ) ; return random . next Int ( n ) ; }
public boolean is Reversed ( ) { return modifiers . contains ( SGR . REVERSE ) ; }
public static boolean calls Sensitive Sink ( Stmt stmt ) { for ( Info Kind info K : get Sink Info Kinds ( stmt ) ) { if ( info K . is Sensitive ( ) ) return true ; } return false ; }
@ Override public Range find Range Bounds ( Category Dataset dataset ) { if ( dataset == null ) { return null ; } boolean all Items Null = true ; double minimum = NUM_ ; double maximum = NUM_ ; int column Count = dataset . get Column Count ( ) ; for ( int row = NUM_ ; row < dataset . get Row Count ( ) ; row ++ ) { double running Total = NUM_ ; for ( int column = NUM_ ; column <= column Count - NUM_ ; column ++ ) { Number n = dataset . get Value ( row , column ) ; if ( n != null ) { all Items Null = false ; double value = n . double Value ( ) ; if ( column == column Count - NUM_ ) { running Total = value ; } else { running Total = running Total + value ; } minimum = Math . min ( minimum , running Total ) ; maximum = Math . max ( maximum , running Total ) ; } } } if ( ! all Items Null ) { return new Range ( minimum , maximum ) ; } else { return null ; } }
public int hash Code ( ) { if ( myhash == - NUM_ ) { myhash = NUM_ + oid . hash Code ( ) ; for ( int i = NUM_ ; i < name Value . length ; i ++ ) { myhash = NUM_ * myhash + name Value [ i ] ; } } return myhash ; }
public static Menu Selection Manager default Manager ( ) { synchronized ( MENU SELECTION MANAGER KEY ) { App Context context = App Context . get App Context ( ) ; Menu Selection Manager msm = ( Menu Selection Manager ) context . get ( MENU SELECTION MANAGER KEY ) ; if ( msm == null ) { msm = new Menu Selection Manager ( ) ; context . put ( MENU SELECTION MANAGER KEY , msm ) ; Object o = context . get ( Swing Utilities 2 . MENU SELECTION MANAGER LISTENER KEY ) ; if ( o != null && o instanceof Change Listener ) { msm . add Change Listener ( ( Change Listener ) o ) ; } } return msm ; } }
private boolean can Sdk Version Use Super Dev Mode ( String version ) { return version . matches ( STR_ ) || version . matches ( STR_ ) ; }
protected long calculate Duration ( Leased Resource resource , long requested Duration ) { if ( requested Duration == Lease . FOREVER ) requested Duration = Long . MAX VALUE ; else if ( requested Duration == Lease . ANY ) requested Duration = default Length ; else if ( requested Duration < NUM_ ) throw new Illegal Argument Exception ( STR_ + STR_ ) ; return Math . min ( requested Duration , maximum ) ; }
@ Suppress Warnings ( STR_ ) public static Pattern Syntax Exception regex Exception ( String s , int groups ) { try { Pattern p = Pattern . compile ( s ) ; int actual Groups = get Group Count ( p ) ; if ( actual Groups < groups ) { return new Pattern Syntax Exception ( regex Error Message ( s , groups , actual Groups ) , s , - NUM_ ) ; } } catch ( Pattern Syntax Exception pse ) { return pse ; } return null ; }
public static Driver driver ( String uri , Auth Token auth Token , Config config ) { return driver ( URI . create ( uri ) , auth Token , config ) ; }
public double log Density ( double value ) { update Mean And Variance ( ) ; double val = - NUM_ * ( CONST + Math . log ( m Variance ) + ( value - m Mean ) * ( value - m Mean ) / m Variance ) ; return val ; }
boolean has Known Object ( Parse Object object ) { synchronized ( mutex ) { return known Objects . contains ( object ) ; } }
public double next Double ( double freedom ) { double u , v , z , zz , r ; if ( freedom == NUM_ ) { for ( ; ; ) { u = random Generator . raw ( ) ; v = random Generator . raw ( ) * NUM_ ; z = v / u ; if ( z < NUM_ ) continue ; zz = z * z ; r = NUM_ - zz ; if ( z < NUM_ ) r = r + zz * z / ( NUM_ * z ) ; if ( u < r * NUM_ ) return ( z * z ) ; if ( zz > ( NUM_ / u + NUM_ ) ) continue ; if ( NUM_ * Math . log ( u ) < ( - zz * NUM_ ) ) return ( z * z ) ; } } else { if ( freedom != freedom in ) { b = Math . sqrt ( freedom - NUM_ ) ; vm = - NUM_ * ( NUM_ - NUM_ / ( b * b + NUM_ ) ) ; vm = ( - b > vm ) ? - b : vm ; vp = NUM_ * ( NUM_ + b ) / ( NUM_ + b ) ; vd = vp - vm ; freedom in = freedom ; } for ( ; ; ) { u = random Generator . raw ( ) ; v = random Generator . raw ( ) * vd + vm ; z = v / u ; if ( z < - b ) continue ; zz = z * z ; r = NUM_ - zz ; if ( z < NUM_ ) r = r + zz * z / ( NUM_ * ( z + b ) ) ; if ( u < r * NUM_ ) return ( ( z + b ) * ( z + b ) ) ; if ( zz > ( NUM_ / u + NUM_ ) ) continue ; if ( NUM_ * Math . log ( u ) < ( Math . log ( NUM_ + z / b ) * b * b - zz * NUM_ - z * b ) ) return ( ( z + b ) * ( z + b ) ) ; } } }
private static int starts With Lenient ( String s , String match , int min Chars , boolean accept Trailing ) { if ( s . char At ( NUM_ ) != match . char At ( NUM_ ) ) return - NUM_ ; if ( min Chars == - NUM_ ) min Chars = match . length ( ) ; int s Sz = s . length ( ) ; if ( s Sz < min Chars ) return - NUM_ ; int m Sz = match . length ( ) ; int s Ix = NUM_ ; for ( int m Ix = NUM_ ; m Ix < m Sz ; s Ix ++ , m Ix ++ ) { while ( s Ix < s Sz && ( s . char At ( s Ix ) == STR_ || s . char At ( s Ix ) == STR_ ) ) s Ix ++ ; if ( s Ix >= s Sz || s . char At ( s Ix ) != match . char At ( m Ix ) ) return m Ix >= min Chars && ( accept Trailing || s Ix >= s Sz ) && ( s Ix >= s Sz || s . char At ( s Ix - NUM_ ) == STR_ ) ? s Ix : - NUM_ ; } return s Ix >= s Sz || accept Trailing || s . char At ( s Ix ) == STR_ ? s Ix : - NUM_ ; }
public boolean offer ( E e ) { buffer . offer ( e ) ; if ( consumer != null ) { consumer . wake Up ( ) ; } return true ; }
@ Override public int hash Code ( ) { int result = bucket Name . hash Code ( ) ; result = NUM_ * result + name . hash Code ( ) ; result = NUM_ * result + created Time . hash Code ( ) ; result = NUM_ * result + ( int ) ( length ^ ( length > > > NUM_ ) ) ; result = NUM_ * result + etag . hash Code ( ) ; result = NUM_ * result + content Type . hash Code ( ) ; return result ; }
public static < T extends Generic Entity > List < T > order By ( Collection < T > values , List < String > order By ) { if ( values == null ) return null ; if ( values . size ( ) == NUM_ ) return new Linked List < T > ( ) ; if ( Util Validate . is Empty ( order By ) ) { List < T > new List = new Linked List < T > ( ) ; new List . add All ( values ) ; return new List ; } List < T > result = new Linked List < T > ( ) ; result . add All ( values ) ; if ( Debug . verbose On ( ) ) Debug . log Verbose ( STR_ + values . size ( ) + STR_ + order By . to String ( ) , module ) ; Collections . sort ( result , new Order By List ( order By ) ) ; return result ; }
public Enumeration unused ( ) { Vector un Used = new Vector ( ) ; Enumeration names = used . keys ( ) ; while ( names . has More Elements ( ) ) { String name = ( String ) names . next Element ( ) ; Boolean is Used = ( Boolean ) used . get ( name ) ; if ( ! is Used . boolean Value ( ) ) un Used . add Element ( name ) ; } return un Used . elements ( ) ; }
public static double regularized Gamma P ( final double a , final double x ) { if ( Double . is Infinite ( a ) || Double . is Infinite ( x ) || ! ( a > NUM_ ) || ! ( x >= NUM_ ) ) { return Double . Na N ; } if ( x == NUM_ ) { return NUM_ ; } if ( x >= a + NUM_ ) { return NUM_ - regularized Gamma Q ( a , x ) ; } double term = NUM_ / a ; double sum = term ; for ( int n = NUM_ ; n < MAX ITERATIONS ; n ++ ) { term = x / ( a + n ) * term ; sum = sum + term ; if ( sum == Double . POSITIVE INFINITY ) { return NUM_ ; } if ( Math . abs ( term / sum ) < NUM PRECISION ) { break ; } } return Math . exp ( - x + ( a * Math . log ( x ) ) - log Gamma ( a ) ) * sum ; }
public static Number tan ( Number a ) { return Math . tan ( a . double Value ( ) ) ; }
Named List < Solr Document List > build More Like This Named ( Map < Object , Solr Document List > all Mlt , Map < Object , Shard Doc > result Ids ) { Named List < Solr Document List > result = new Named List < > ( ) ; Tree Map < Integer , Object > sorting Map = new Tree Map < > ( ) ; for ( Entry < Object , Shard Doc > next : result Ids . entry Set ( ) ) { sorting Map . put ( next . get Value ( ) . position In Response , next . get Key ( ) ) ; } for ( Object key : sorting Map . values ( ) ) { Solr Document List sdl = all Mlt . get ( key ) ; if ( sdl == null ) { sdl = new Solr Document List ( ) ; sdl . set Num Found ( NUM_ ) ; sdl . set Start ( NUM_ ) ; } result . add ( key . to String ( ) , sdl ) ; } return result ; }
public String global Info ( ) { return STR_ + STR_ ; }
public int hash Code ( ) { return id . hash Code ( ) ; }
protected synchronized long numchunks ( ) throws IO Exception { if ( backing Random Access File . length ( ) <= f Header . header Size ( ) ) { return NUM_ ; } else { long len = backing Random Access File . length ( ) - f Header . header Size ( ) ; return ( ( ( len % CHUNK ENC SIZE ) == NUM_ ) ? ( len / CHUNK ENC SIZE ) : ( ( len / CHUNK ENC SIZE ) + NUM_ ) ) ; } }
public Shape ellipse ( double x , double y , double width , double height ) { m ellipse . set Frame ( x , y , width , height ) ; return m ellipse ; }
public static boolean is Numeric ( Type Mirror type ) { switch ( type . get Kind ( ) ) { case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : return true ; default : return false ; } }
@ Override public final int read Unsigned Short ( ) throws IO Exception { d . read Fully ( w , NUM_ , NUM_ ) ; return ( ( w [ NUM_ ] & NUM_ ) << NUM_ | ( w [ NUM_ ] & NUM_ ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; Enumeration < Option > enm = super . list Options ( ) ; while ( enm . has More Elements ( ) ) result . add ( enm . next Element ( ) ) ; result . add Element ( new Option ( STR_ + stopwords Tip Text ( ) + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
@ Override public Inet Address address Remote ( ) { if ( remote Addr == null ) { try { remote Addr = Inet Address . get By Name ( get Remote Host ( ) ) ; } catch ( Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } } return remote Addr ; }
public int port ( ) { return address . get Port ( ) ; }
protected R Text Area UI create R Text Area UI ( ) { return new R Text Area UI ( this ) ; }
public String canonize String ( String file ) { int i = NUM_ ; int lim = file . length ( ) ; while ( ( i = file . index Of ( STR_ ) ) >= NUM_ ) { if ( ( lim = file . last Index Of ( STR_ , i - NUM_ ) ) >= NUM_ ) { file = file . substring ( NUM_ , lim ) + file . substring ( i + NUM_ ) ; } else { file = file . substring ( i + NUM_ ) ; } } while ( ( i = file . index Of ( STR_ ) ) >= NUM_ ) { file = file . substring ( NUM_ , i ) + file . substring ( i + NUM_ ) ; } while ( file . ends With ( STR_ ) ) { i = file . index Of ( STR_ ) ; if ( ( lim = file . last Index Of ( STR_ , i - NUM_ ) ) >= NUM_ ) { file = file . substring ( NUM_ , lim + NUM_ ) ; } else { file = file . substring ( NUM_ , i ) ; } } if ( file . ends With ( STR_ ) ) file = file . substring ( NUM_ , file . length ( ) - NUM_ ) ; return file ; }
public boolean is Lib Class ( Soot Class clz ) { return is Lib Class ( clz . get Name ( ) ) ; }
public URI to URI ( ) { String name = get Absolute Name ( ) ; try { if ( ! name . starts With ( STR_ ) ) { return new URI ( STR_ , null , STR_ + name , null , null ) ; } else if ( name . starts With ( STR_ ) ) { return new URI ( STR_ , STR_ , name , null ) ; } return new URI ( STR_ , null , name , null , null ) ; } catch ( URI Syntax Exception e ) { return null ; } }
static public boolean is Zero ( float value ) { return Math . abs ( value ) <= FLOAT ROUNDING ERROR ; }
@ Override public Reversible Iterator < Basic Log Record > iterator ( ) { log Mgr Lock . lock ( ) ; try { flush ( ) ; return new Log Iterator ( current Blk ) ; } finally { log Mgr Lock . unlock ( ) ; } }
@ Safe Varargs public static < T > Optional < T > lowest Common Ancestor ( Tree Def . Parented < T > tree Def , T ... nodes ) { return lowest Common Ancestor ( tree Def , Arrays . as List ( nodes ) ) ; }
@ Override public int column Count ( ) { return column List . size ( ) ; }
static synchronized Explorer Context Menu Factory instance ( ) { if ( shared Instance == null ) shared Instance = new Explorer Context Menu Factory ( ) ; return shared Instance ; }
private List < Entity > list Network ( Entity e , boolean planned ) { List < Entity > nova Network Members = new Linked List < Entity > ( ) ; List < Entity > nova Units = get My Nova Units ( ) ; for ( Entity ent : nova Units ) { if ( planned ) { if ( ent . get New Round Nova Network String ( ) == e . get New Round Nova Network String ( ) ) { nova Network Members . add ( ent ) ; } } else { if ( ent . get C 3 Net Id ( ) == e . get C 3 Net Id ( ) ) { nova Network Members . add ( ent ) ; } } } return nova Network Members ; }
private Feature Vector load Feature Vector ( int block id ) { int feature Position = get Int From Byte Buffer ( block id , features ) ; final int num Features = encoding . read Id ( features , feature Position ) ; feature Position += Encoder Configuration . ID SIZE ; final Feature Vector feature Vector = new Feature Vector ( ) ; Float Encoder encoder ; String feature Name ; for ( int i = NUM_ ; i < num Features ; i ++ ) { final int inner Id = encoding . read Id ( features , feature Position ) ; final int outer Id = encoding . outer Id ( inner Id ) ; encoder = encoding . encoder ( inner Id ) ; feature Name = Vocabulary . word ( outer Id ) ; final float value = encoder . read ( features , feature Position ) ; try { int index = Integer . parse Int ( feature Name ) ; feature Vector . increment ( index , - value ) ; } catch ( Number Format Exception e ) { feature Vector . increment ( feature Name , value ) ; } feature Position += Encoder Configuration . ID SIZE + encoder . size ( ) ; } return feature Vector ; }
public boolean shipping Applies ( ) { boolean shipping Applies = false ; for ( Shopping Cart Item item : this ) { if ( item . shipping Applies ( ) ) { shipping Applies = true ; break ; } } return shipping Applies ; }
@ Override public Enumeration < URL > find Resources ( final String name ) throws IO Exception { if ( name == null ) { return null ; } Array List < URL > result = new Array List < URL > ( ) ; int n = NUM_ ; while ( true ) { URL Handler handler = get Handler ( n ++ ) ; if ( handler == null ) { break ; } handler . find Resources ( name , result ) ; } return Collections . enumeration ( result ) ; }
public Iterable < Divider > dividers That Overlap ( final Rectangle r ) { if ( r == null ) { throw new Illegal Argument Exception ( STR_ ) ; } return dividers That Overlap ( get Model ( ) , r ) ; }
public static String to Tool Tip Text ( Color c ) { if ( formatter == null ) { formatter = new Color Tool Tip Text Formatter ( ) ; } try { return formatter . value To String ( c ) ; } catch ( Parse Exception ex ) { Internal Error error = new Internal Error ( STR_ + c ) ; error . init Cause ( ex ) ; throw error ; } }
private int max ( Map < Integer , Modifiable DBI Ds > candidates ) { DBI Ds max Set = null ; Integer max Dim = null ; for ( Integer next Dim : candidates . key Set ( ) ) { DBI Ds next Set = candidates . get ( next Dim ) ; if ( max Set == null || max Set . size ( ) < next Set . size ( ) ) { max Set = next Set ; max Dim = next Dim ; } } return max Dim ; }
public List < Node > expand ( Node node , Problem problem ) { List < Node > successors = new Array List < Node > ( ) ; Actions Function actions Function = problem . get Actions Function ( ) ; Result Function result Function = problem . get Result Function ( ) ; Step Cost Function step Cost Function = problem . get Step Cost Function ( ) ; for ( Action action : actions Function . actions ( node . get State ( ) ) ) { Object successor State = result Function . result ( node . get State ( ) , action ) ; double step Cost = step Cost Function . c ( node . get State ( ) , action , successor State ) ; successors . add ( create Node ( successor State , node , action , step Cost ) ) ; } for ( Node Listener listener : node Listeners ) listener . on Node Expanded ( node ) ; counter ++ ; return successors ; }
public int search ( String txt ) { int m = pat . length ( ) ; int n = txt . length ( ) ; int skip ; for ( int i = NUM_ ; i <= n - m ; i += skip ) { skip = NUM_ ; for ( int j = m - NUM_ ; j >= NUM_ ; j -- ) { if ( pat . char At ( j ) != txt . char At ( i + j ) ) { skip = Math . max ( NUM_ , j - right [ txt . char At ( i + j ) ] ) ; break ; } } if ( skip == NUM_ ) return i ; } return n ; }
public static String unescape Pipe ( String text ) { return text . replace All ( STR_ , STR_ ) ; }
public String load Full Document Text To String ( String s Doc ID ) { Node n Doc = XML Doc . get Element By Id ( s Doc ID ) ; if ( n Doc == null ) return null ; Element e Doc = ( Element ) n Doc ; String s Res = e Doc . get Text Content ( ) ; return s Res ; }
public static boolean are Same Primitive Types ( Type Mirror left , Type Mirror right ) { if ( ! is Primitive ( left ) || ! is Primitive ( right ) ) { return false ; } return ( left . get Kind ( ) == right . get Kind ( ) ) ; }
private Script Engine new Script Engine ( File file ) throws Script Exception { String filename = file . get Name ( ) ; int index = filename . last Index Of ( STR_ ) ; if ( ( index < NUM_ ) || ( index >= filename . length ( ) - NUM_ ) ) { throw new Script Exception ( STR_ ) ; } String extension = filename . substring ( index + NUM_ ) ; Script Engine Manager manager = new Script Engine Manager ( ) ; Script Engine engine = manager . get Engine By Extension ( extension ) ; if ( engine == null ) { throw new Script Exception ( STR_ + extension ) ; } return engine ; }
public int size ( ) { return children . size ( ) ; }
public Array List < Art Layer > art layer list ( ) { return layers list ; }
private final boolean handle Blocked Write ( Byte Buffer buffer , Distribution Message msg ) throws Connection Exception { if ( ! add To Queue ( buffer , msg , true ) ) { return false ; } else { start Nio Pusher ( ) ; return true ; } }
public void shutdown If Fatal ( ) { if ( fatal ) { try { logger . log ( Level . SEVERE , STR_ , throwable ) ; } finally { Safe Shutdown . exit ( NUM_ ) ; } } }
@ Override public int num Elements ( ) throws Exception { if ( m zero R != null ) { return NUM_ ; } return num Nodes ( ) ; }
@ Override public void assert Operation Supported ( Component target , int num Buffers , Buffer Capabilities caps ) throws AWT Exception { if ( num Buffers < NUM_ || num Buffers > NUM_ ) { throw new AWT Exception ( STR_ ) ; } if ( caps . get Flip Contents ( ) == Buffer Capabilities . Flip Contents . COPIED && num Buffers != NUM_ ) { throw new AWT Exception ( STR_ + STR_ ) ; } }
protected byte [ ] engine Get Encoded ( ) throws IO Exception { PSS Parameter Spec pss Spec = current Spec ; Algorithm Identifier hash Algorithm = new Algorithm Identifier ( Digest Factory . get OID ( pss Spec . get Digest Algorithm ( ) ) , DER Null . INSTANCE ) ; MGF 1 Parameter Spec mgf Spec = ( MGF 1 Parameter Spec ) pss Spec . get MGF Parameters ( ) ; Algorithm Identifier mask Gen Algorithm = new Algorithm Identifier ( PKCS Object Identifiers . id mgf 1 , new Algorithm Identifier ( Digest Factory . get OID ( mgf Spec . get Digest Algorithm ( ) ) , DER Null . INSTANCE ) ) ; RSASSAPS Sparams pss P = new RSASSAPS Sparams ( hash Algorithm , mask Gen Algorithm , new ASN 1 Integer ( pss Spec . get Salt Length ( ) ) , new ASN 1 Integer ( pss Spec . get Trailer Field ( ) ) ) ; return pss P . get Encoded ( STR_ ) ; }
public static float fast Length ( Vector 3 a ) { return ( float ) Math . sqrt ( length Squared ( a ) ) ; }
@ Override public boolean log Modified ( Logger log ) { if ( dependency List . log Modified ( log ) ) { return true ; } else if ( is Modified ( ) ) { log . info ( this + STR_ ) ; return true ; } else { return false ; } }
public static < T > T [ ] concat ( T [ ] first , T [ ] second , Class < T > type ) { T [ ] result = new Array ( type , first . length + second . length ) ; System . arraycopy ( first , NUM_ , result , NUM_ , first . length ) ; System . arraycopy ( second , NUM_ , result , first . length , second . length ) ; return result ; }
@ Data Provider public Object [ ] [ ] bad Experiments DELETE ( ) { Experiment experiment = new Experiment ( ) ; return new Object [ ] [ ] { new Object [ ] { new Experiment ( experiment . set Id ( STR_ ) ) , STR_ , Http Status . SC NOT FOUND } , new Object [ ] { new Experiment ( experiment . set Id ( STR_ ) ) , STR_ , Http Status . SC INTERNAL SERVER ERROR } , new Object [ ] { new Experiment ( experiment . set Id ( STR_ ) ) , STR_ , Http Status . SC INTERNAL SERVER ERROR } } ; }
public static Column Spec decode ( String encoded Column Spec , Layout Map layout Map ) { check Not Blank ( encoded Column Spec , STR_ ) ; check Not Null ( layout Map , STR_ ) ; String trimmed = encoded Column Spec . trim ( ) ; String lower = trimmed . to Lower Case ( Locale . ENGLISH ) ; return decode Expanded ( layout Map . expand ( lower , true ) ) ; }
public double predict Quantile ( double percentage ) { update Mean And Variance ( ) ; return m Mean + Statistics . normal Inverse ( percentage ) * Math . sqrt ( m Variance ) ; }
public boolean is Open ( ) { if ( secure Channel Id == - NUM_ ) return false ; long expire Time = ( ( long ) ( token Lifetime * NUM_ ) ) + token Issue Time ; long current Time = System . current Time Millis ( ) ; return expire Time > current Time ; }
@ Override public Enumeration < URL > find Resources ( String name ) { if ( name . starts With ( STR_ ) ) name = name . substring ( NUM_ ) ; Vector < URL > resources = new Vector < URL > ( ) ; fill Resources ( resources , name ) ; String alias = get Resource Alias ( name ) ; if ( alias != null ) fill Resources ( resources , alias ) ; return resources . elements ( ) ; }
public static String slurp File No Exceptions ( String filename ) { try { return slurp File ( filename ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
public static String [ ] signature Parameter Types ( String sig ) { int pos 1 = sig . index Of ( STR_ ) ; int pos 2 = sig . index Of ( STR_ , pos 1 + NUM_ ) ; int pos 3 = sig . last Index Of ( STR_ ) ; String param Type ; List < String > param Types = new Array List < String > ( ) ; while ( pos 2 > NUM_ ) { param Type = sig . substring ( pos 1 + NUM_ , pos 2 ) ; param Types . add ( param Type ) ; pos 1 = pos 2 ; pos 2 = sig . index Of ( STR_ , pos 1 + NUM_ ) ; } param Type = sig . substring ( pos 1 + NUM_ , pos 3 ) ; if ( ! param Type . is Empty ( ) ) param Types . add ( param Type ) ; return param Types . to Array ( new String [ NUM_ ] ) ; }
private boolean use Date Format Symbols ( ) { return use Date Format Symbols || locale == null ; }
public Map < String , Long > read Lock Columns ( ) throws Exception { return read Lock Columns ( false ) ; }
public synchronized int size ( ) { return index . size ( ) ; }
public boolean can Be Legacy ( ) { if ( this . click Event != null ) { return false ; } if ( this . hover Event != null ) { return false ; } List < Base Component > extra = this . extra ; if ( ( extra == null ) || extra . is Empty ( ) ) { return true ; } for ( Base Component component : extra ) { if ( ! component . can Be Legacy ( ) ) { return false ; } } return true ; }
public static boolean eq Param Types ( String desc 1 , String desc 2 ) { if ( desc 1 . char At ( NUM_ ) != STR_ ) return false ; for ( int i = NUM_ ; true ; ++ i ) { char c = desc 1 . char At ( i ) ; if ( c != desc 2 . char At ( i ) ) return false ; if ( c == STR_ ) return true ; } }
public boolean is Signature Valid ( ) { return EC Key . verify ( Sha 256 Hash . hash Twice ( content ) , signature , params . get Alert Signing Key ( ) ) ; }
public static List to Edges ( Collection dir Edges ) { List edges = new Array List ( ) ; for ( Iterator i = dir Edges . iterator ( ) ; i . has Next ( ) ; ) { edges . add ( ( ( Directed Edge ) i . next ( ) ) . parent Edge ) ; } return edges ; }
private static boolean is Float Property ( String property Name ) { return PROPERTY EVENT TIME . equals ( property Name ) ; }
private double calculate Best ( ) { double best = NUM_ ; for ( int i = NUM_ ; i < metrics . length ; i ++ ) { best = Math . max ( metrics [ i ] [ metric ] , best ) ; } return best ; }
public synchronized < T extends Tool > Tool Model < T > load Tool Model ( String tool Name ) { @ Suppress Warnings ( STR_ ) Tool Model < T > loaded Model = ( Tool Model < T > ) tool Models . get ( tool Name ) ; if ( loaded Model == null ) { loaded Model = load Tool Model Memoised ( tool Name ) ; tool Models . put ( tool Name , loaded Model ) ; } return loaded Model ; }
public static double pareto ( double alpha ) { return Math . pow ( NUM_ - uniform ( ) , - NUM_ / alpha ) - NUM_ ; }
public static Map < String , List < String > > to Multimap ( Headers headers , String value For Null Key ) { Map < String , List < String > > result = new Tree Map < > ( FIELD NAME COMPARATOR ) ; for ( int i = NUM_ , size = headers . size ( ) ; i < size ; i ++ ) { String field Name = headers . name ( i ) ; String value = headers . value ( i ) ; List < String > all Values = new Array List < > ( ) ; List < String > other Values = result . get ( field Name ) ; if ( other Values != null ) { all Values . add All ( other Values ) ; } all Values . add ( value ) ; result . put ( field Name , Collections . unmodifiable List ( all Values ) ) ; } if ( value For Null Key != null ) { result . put ( null , Collections . unmodifiable List ( Collections . singleton List ( value For Null Key ) ) ) ; } return Collections . unmodifiable Map ( result ) ; }
public static byte [ ] sum Hmac ( byte [ ] key , byte [ ] data ) throws No Such Algorithm Exception , Invalid Key Exception { Mac mac = Mac . get Instance ( STR_ ) ; mac . init ( new Secret Key Spec ( key , STR_ ) ) ; mac . update ( data ) ; return mac . do Final ( ) ; }
private static void throw Bounds ( ) { throw new Index Out Of Bounds Exception ( STR_ ) ; }
public final Iterator < String > types Iterator ( ) { return m Data Types != null ? m Data Types . iterator ( ) : null ; }
public boolean is Use First Pass Enabled ( ) { return ( shared State Behavior Pattern != null ) && shared State Behavior Pattern . equals ( STR_ ) ; }
public double distance ( double x , double y , double z ) { double xd = this . x - x ; double yd = this . y - y ; double zd = this . z - z ; return Math . sqrt ( xd * xd + yd * yd + zd * zd ) ; }
public double theta ( ) { return Math . atan 2 ( y , x ) ; }
public static Preferences user Root ( ) { return factory . user Root ( ) ; }
public double skewness ( ) { double mu = mean ( ) ; double devsum = NUM_ ; double wsum = NUM_ ; int size = values . size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { double dev = values . get ( i ) - mu ; devsum += dev * dev * dev * weights . get ( i ) ; wsum += weights . get ( i ) ; } double mu 3 = devsum / wsum ; double s 3 = Math . pow ( variance ( ) , NUM_ / NUM_ ) ; return mu 3 / s 3 ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( event Name . compare To ( STR_ ) == NUM_ && ( m data Provider != null ) ) { return false ; } return true ; }
public boolean is Granted ( final T tx ) { if ( tx == null ) { throw new Illegal Argument Exception ( ) ; } return queue . peek ( ) == tx ; }
public int count Users ( ) throws Users Repository Exception { List < String > usernames = list User Names ( ) ; return usernames . size ( ) ; }
@ Exception Handler ( Type Not Found Exception . class ) @ Response Status ( value = Http Status . NOT FOUND ) public @ Response Body Error Response resolve Type Descriptor Not Found Exception ( Type Not Found Exception e ) throws IO Exception { if ( logger . is Loggable ( Level . FINE ) ) logger . fine ( STR_ + e . get Type Name ( ) + STR_ ) ; return new Error Response ( new Error Message ( STR_ + e . get Type Name ( ) + STR_ ) ) ; }
public String discrete Value ( Object example ) { return compute Prediction ( example ) ; }
boolean is Scroll Out Of Bounds ( ) { return Float . compare ( get Scroll Amount Out Of Bounds ( m Stack Scroll P ) , NUM_ ) != NUM_ ; }
static String to Class Name ( String s ) { int i = s . index Of ( STR_ ) ; if ( i > NUM_ ) s = s . substring ( NUM_ , i ) ; return s . replace ( STR_ , STR_ ) ; }
@ Override public Enumeration < Option > list Options ( ) { String string 1 = STR_ + m num Rules + STR_ , string 2 = STR_ + m min Metric + STR_ , string 3 = STR_ , string 4 = STR_ + m delta + STR_ , string 5 = STR_ + m lower Bound Min Support + STR_ , string 6 = STR_ , string 7 = STR_ , string 8 = STR_ , string 9 = STR_ , string 10 = STR_ , string Type = STR_ + STR_ , string Zero As Missing = STR_ + STR_ , string To String Delimiters = STR_ + STR_ + STR_ + STR_ ; Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add ( new Option ( string 1 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string Type , STR_ , NUM_ , STR_ + STR_ ) ) ; new Vector . add ( new Option ( string 2 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 3 + string 4 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 5 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 6 + string 7 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 8 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 9 , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string Zero As Missing , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string To String Delimiters , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( string 10 , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private static boolean is Full Name ( String file Name ) { for ( String suffix : file Names ) { if ( file Name . equals ( suffix ) ) { return true ; } } for ( String suffix : directory Names ) { if ( file Name . equals ( suffix + ZIP ) || file Name . equals ( suffix + ZIP + SHA 1 ) ) { return true ; } } return false ; }
public static List < ? extends Element > child Element List ( Document Fragment fragment ) { if ( fragment == null ) return null ; List < Element > elements = new Linked List < Element > ( ) ; Node node = fragment . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE ) { Element child Element = ( Element ) node ; elements . add ( child Element ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return elements ; }
public J Menu create Align Menu ( ) { J Menu align Sub Menu = new J Menu ( STR_ ) ; align Sub Menu . add ( action Manager . get Align Horizontal Action ( ) ) ; align Sub Menu . add ( action Manager . get Align Vertical Action ( ) ) ; return align Sub Menu ; }
public String to Simple String ( ) { String Buffer buffer = new String Buffer ( ) ; buffer . append ( STR_ + m Label + STR_ + m Y Vals . size ( ) + STR_ ) ; return buffer . to String ( ) ; }
private static Locale strip ( Locale locale ) { String language = locale . get Language ( ) ; String country = locale . get Country ( ) ; String variant = locale . get Variant ( ) ; if ( ! variant . is Empty ( ) ) { variant = STR_ ; } else if ( ! country . is Empty ( ) ) { country = STR_ ; } else if ( ! language . is Empty ( ) ) { language = STR_ ; } else { return null ; } return new Locale ( language , country , variant ) ; }
public long extract Alarm ( long now , boolean is Test ) { long last Time = now . get And Set ( now ) ; long next Time = next Alarm Time . get ( ) ; if ( now < next Time ) { return next Time ; } next Alarm Time . set ( now + CLOCK NEXT ) ; int delta ; delta = ( int ) ( now - last Time ) / CLOCK INTERVAL ; delta = Math . min ( delta , CLOCK PERIOD ) ; Alarm alarm ; int bucket = get Bucket ( last Time ) ; for ( int i = NUM_ ; i <= delta ; i ++ ) { while ( ( alarm = extract Next Alarm ( bucket , now , is Test ) ) != null ) { dispatch ( alarm , now , is Test ) ; } bucket = ( bucket + NUM_ ) % CLOCK PERIOD ; } while ( ( alarm = extract Next Current Alarm ( ) ) != null ) { dispatch ( alarm , now , is Test ) ; } long next = update Next Alarm Time ( now ) ; last Time = now ; return next ; }
public Address to Address ( Network Parameters params ) { byte [ ] hash 160 = Utils . sha 256 hash 160 ( pub ) ; return new Address ( params , hash 160 ) ; }
@ Suppress Warnings ( STR_ ) public static < T > T from Pem ( String pem ) throws Exception { String Reader sr = new String Reader ( pem ) ; PEM Reader pw = new PEM Reader ( sr ) ; Object object = pw . read Object ( ) ; return ( T ) object ; }
public boolean contains ( ) { int next = NUM_ ; final int size = f Values . size ( ) ; LOOP : for ( int i = NUM_ ; i < size ; i = next ) { next = i + f Field Count ; for ( int j = NUM_ ; j < f Field Count ; j ++ ) { Object value 1 = f Local Values [ j ] ; Object value 2 = f Values . element At ( i ) ; short value Type 1 = f Local Value Types [ j ] ; short value Type 2 = get Value Type At ( i ) ; if ( value 1 == null || value 2 == null || value Type 1 != value Type 2 || ! ( value 1 . equals ( value 2 ) ) ) { continue LOOP ; } else if ( value Type 1 == XS Constants . LIST DT || value Type 1 == XS Constants . LISTOFUNION DT ) { Short List list 1 = f Local Item Value Types [ j ] ; Short List list 2 = get Item Value Type At ( i ) ; if ( list 1 == null || list 2 == null || ! list 1 . equals ( list 2 ) ) continue LOOP ; } i ++ ; } return true ; } return false ; }
@ Override public int hash Code ( ) { return node Id . hash Code ( ) + action Values . hash Code ( ) ; }
private void release Reservation ( int n Bytes ) { assert Open ( ) ; release Bytes ( n Bytes ) ; if ( DEBUG ) { historical Log . record Event ( STR_ , n Bytes ) ; } }
protected static @ Not Null String convert Value To Groovy Source ( @ Not Null Object value ) { if ( value instanceof List ) { String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; for ( Object v : ( ( List ) value ) ) { if ( sb . length ( ) > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( convert Value To Groovy Source ( v ) ) ; } sb . append ( STR_ ) ; return sb . to String ( ) ; } else if ( value instanceof Number || value instanceof Boolean ) { return value . to String ( ) ; } else { return STR_ + escape Literal String ( value . to String ( ) ) + STR_ ; } }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; return new Vector . elements ( ) ; }
public void request Account Disabled State ( ) { operations . add ( Password Policy State Operation Type . GET ACCOUNT DISABLED STATE ) ; }
public int hash Code ( ) { return map . hash Code ( ) ; }
public static boolean is Likely Person ( String word ) { String stripped Word = strip Word ( word ) ; if ( stripped Word != null && stripped Word . length ( ) > NUM_ && stripped Word . length ( ) <= NUM_ ) { boolean result = true ; for ( int i = NUM_ ; result && i < stripped Word . length ( ) ; i ++ ) { result = VALID PERSON CHARS . index Of ( stripped Word . char At ( i ) ) != - NUM_ ; } return result ; } else { return false ; } }
private Integer [ ] split Points By Delimiter List ( String s Str , char [ ] l Delimiters ) { Tree Map tm Dels = new Tree Map ( ) ; for ( int i Cnt = NUM_ ; i Cnt < l Delimiters . length ; i Cnt ++ ) tm Dels . put ( i Cnt , new String ( ) + l Delimiters [ i Cnt ] ) ; return split Points By Delimiter List ( s Str , tm Dels ) ; }
public static boolean is Absolute ( File f ) { boolean absolute = false ; try { absolute = f . is Absolute ( ) ; } catch ( Security Exception se ) { if ( Trace . path Resolver ) { Trace . trace ( se . get Message ( ) ) ; } } return absolute ; }
@ Override public void assert Operation Supported ( Component target , int num Buffers , Buffer Capabilities caps ) throws AWT Exception { if ( num Buffers > NUM_ ) { throw new AWT Exception ( STR_ ) ; } Buffer Capabilities config Caps = get Buffer Capabilities ( ) ; if ( ! config Caps . is Page Flipping ( ) ) { throw new AWT Exception ( STR_ ) ; } if ( caps . get Flip Contents ( ) == Buffer Capabilities . Flip Contents . PRIOR ) { throw new AWT Exception ( STR_ ) ; } }
public String start graph ( ) { return STR_ ; }
private static boolean is Rounded To Zero ( double source , int decimals , int precision ) { return source == NUM_ || Math . abs ( source ) < NUM_ / ten Pow Double ( Math . max ( decimals , precision ) + NUM_ ) ; }
public int size ( ) { return symbols . size ( ) ; }
public boolean is Set Message Type ( ) { return isset bit vector . get ( MESSAGETYPE ISSET ID ) ; }
public Span trim Trail ( Char Sequence src ) { if ( start < end ) { while ( src . char At ( end - NUM_ ) == NUM_ ) { end -- ; if ( start == end ) break ; } } return this ; }
public Session Name create Session Name ( String name ) { Session Name Field session Name Impl = new Session Name Field ( ) ; try { session Name Impl . set Value ( name ) ; } catch ( Sdp Exception s ) { s . print Stack Trace ( ) ; } return session Name Impl ; }
private Element create X 509 Data ( ) throws Exception { Element x 509 Data Ele = null ; List < Certificate > certs = idm Client . get Tenant Certificate ( tenant Name ) ; if ( ! certs . is Empty ( ) ) { x 509 Data Ele = doc . create Element ( SAML Names . DS X 509 DATA ) ; for ( Certificate cert : certs ) { Element x 509 Certificate Ele = create Certificate ( cert ) ; x 509 Data Ele . append Child ( x 509 Certificate Ele ) ; } } return x 509 Data Ele ; }
public void request Password Expiration Warned Time ( ) { operations . add ( Password Policy State Operation Type . GET PASSWORD EXPIRATION WARNED TIME ) ; }
public boolean is Empty ( ) { if ( last Batch != null ) { if ( ! last Batch . is Empty ( ) ) { return false ; } } return current Batch . is Empty ( ) ; }
protected static Collection find Certificates ( X 509 Cert Store Selector cert Select , List cert Stores ) throws Annotated Exception { Set certs = new Hash Set ( ) ; Iterator iter = cert Stores . iterator ( ) ; while ( iter . has Next ( ) ) { Object obj = iter . next ( ) ; if ( obj instanceof X 509 Store ) { X 509 Store cert Store = ( X 509 Store ) obj ; try { certs . add All ( cert Store . get Matches ( cert Select ) ) ; } catch ( Store Exception e ) { throw new Annotated Exception ( STR_ , e ) ; } } else { Cert Store cert Store = ( Cert Store ) obj ; try { certs . add All ( cert Store . get Certificates ( cert Select ) ) ; } catch ( Cert Store Exception e ) { throw new Annotated Exception ( STR_ , e ) ; } } } return certs ; }
static public Timestamp add Days ( Timestamp day , int offset ) { if ( day == null ) day = new Timestamp ( System . current Time Millis ( ) ) ; Gregorian Calendar cal = new Gregorian Calendar ( ) ; cal . set Time ( day ) ; cal . set ( Calendar . HOUR OF DAY , NUM_ ) ; cal . set ( Calendar . MINUTE , NUM_ ) ; cal . set ( Calendar . SECOND , NUM_ ) ; cal . set ( Calendar . MILLISECOND , NUM_ ) ; if ( offset != NUM_ ) cal . add ( Calendar . DAY OF YEAR , offset ) ; return new Timestamp ( cal . get Time In Millis ( ) ) ; }
public static double stddev ( int [ ] a ) { return Math . sqrt ( var ( a ) ) ; }
@ Override public boolean on Options Item Selected ( Menu Item item ) { if ( item . get Item Id ( ) == android . R . id . home ) { Nav Utils . navigate Up From Same Task ( this ) ; return true ; } return super . on Options Item Selected ( item ) ; }
static private byte [ ] class To Bytes ( Class c ) { return class Name To Bytes ( c . get Name ( ) ) ; }
int accum Default Entity ( java . io . Writer writer , char ch , int i , char [ ] chars , int len , boolean from Text Node , boolean esc LF ) throws IO Exception { if ( ! esc LF && Char Info . S LINEFEED == ch ) { writer . write ( m line Sep , NUM_ , m line Sep Len ) ; } else { if ( ( from Text Node && m char Info . should Map Text Char ( ch ) ) || ( ! from Text Node && m char Info . should Map Attr Char ( ch ) ) ) { String output String For Char = m char Info . get Output String For Char ( ch ) ; if ( null != output String For Char ) { writer . write ( output String For Char ) ; } else return i ; } else return i ; } return i + NUM_ ; }
public static byte [ ] string 2 utf ( String s ) { return chars 2 utf ( s . to Char Array ( ) ) ; }
public String cardinality Tip Text ( ) { return STR_ ; }
@ Suppress Warnings ( STR_ ) @ Override public boolean contains Key ( Object key ) { java . lang . Comparable < K > object = comparator == null ? to Comparable ( ( K ) key ) : null ; K key K = ( K ) key ; Node < K , V > node = root ; while ( node != null ) { K [ ] keys = node . keys ; int left idx = node . left idx ; int result = object != null ? object . compare To ( keys [ left idx ] ) : - comparator . compare ( keys [ left idx ] , key K ) ; if ( result < NUM_ ) { node = node . left ; } else if ( result == NUM_ ) { return true ; } else { int right idx = node . right idx ; if ( left idx != right idx ) { result = cmp ( object , key K , keys [ right idx ] ) ; } if ( result > NUM_ ) { node = node . right ; } else if ( result == NUM_ ) { return true ; } else { int low = left idx + NUM_ , mid = NUM_ , high = right idx - NUM_ ; while ( low <= high ) { mid = ( low + high ) > > > NUM_ ; result = cmp ( object , key K , keys [ mid ] ) ; if ( result > NUM_ ) { low = mid + NUM_ ; } else if ( result == NUM_ ) { return true ; } else { high = mid - NUM_ ; } } return false ; } } } return false ; }
public static < T > List < T > as List ( T ... a ) { Array List < T > list = new Array List < T > ( ) ; for ( T elem : a ) list . add ( elem ) ; return list ; }
public static boolean version Known ( ) { return known ; }
private boolean is Tree Symbol Effectively Final Or Unmodifiable ( Tree tree ) { Element elem = Internal Utils . symbol ( tree ) ; Element Kind ek = elem . get Kind ( ) ; return ek == Element Kind . PACKAGE || ek == Element Kind . CLASS || ek == Element Kind . METHOD || Element Utils . is Effectively Final ( elem ) ; }
private static long sublong ( String value , int begin index , int end index ) { String substring = value . substring ( begin index , end index ) ; return ( substring . length ( ) > NUM_ ) ? Long . parse Long ( substring ) : - NUM_ ; }
public static double prob To Log Odds ( double prob ) { if ( gr ( prob , NUM_ ) || ( sm ( prob , NUM_ ) ) ) { throw new Illegal Argument Exception ( STR_ + STR_ + prob ) ; } double p = SMALL + ( NUM_ - NUM_ * SMALL ) * prob ; return Math . log ( p / ( NUM_ - p ) ) ; }
public Object return Instance ( final String instance Key , final Map < String , Object > key Map ) { Object instance = null ; if ( key Map . contains Key ( instance Key ) ) { instance = key Map . get ( instance Key ) ; } else { logger . error ( STR_ , instance Key ) ; } return instance ; }
public boolean is Connected ( ) { return keeper != null && keeper . get State ( ) == Zoo Keeper . States . CONNECTED ; }
protected boolean is Reflex ( Vector 2 p 0 , Vector 2 p , Vector 2 p 1 ) { return right ( p 1 , p 0 , p ) ; }
public static boolean is DWM Composition Enabled ( ) { return is DWM Composition Enabled ; }
public List < Certificate > local Certificates ( ) { return local Certificates ; }
public static boolean is Local File Uri ( Uri uri ) { String scheme = uri . get Scheme ( ) ; return Text Utils . is Empty ( scheme ) || scheme . equals ( STR_ ) ; }
public String execute ( Locale locale , Map params ) throws Workflow Exception { String realm = get String ( params , Parameter Keys . P REALM ) ; if ( realm == null ) { String extended Meta Data = get String ( params , Parameter Keys . P EXTENDED DATA ) ; if ( extended Meta Data != null ) { realm = get Realm From Ext Data ( get Content ( extended Meta Data , locale ) ) ; } } if ( realm == null ) { throw new Workflow Exception ( STR_ , null ) ; } try { Circle Of Trust Manager mgr = new Circle Of Trust Manager ( ) ; Set cots = mgr . get All Circles Of Trust ( realm ) ; String Buffer buff = new String Buffer ( ) ; if ( ( cots != null ) && ! cots . is Empty ( ) ) { boolean first = true ; for ( Iterator i = cots . iterator ( ) ; i . has Next ( ) ; ) { String c = ( String ) i . next ( ) ; if ( first ) { first = false ; } else { buff . append ( STR_ ) ; } try { buff . append ( String Utils . encode URI Component ( c , STR_ ) ) ; } catch ( Unsupported Encoding Exception e ) { buff . append ( c ) ; } } } return buff . to String ( ) ; } catch ( COT Exception e ) { throw new Workflow Exception ( STR_ , null ) ; } }
private static String Exponent Pair initial Parse ( String s , int length , boolean is Double ) { String Exponent Pair result = new String Exponent Pair ( ) ; if ( length == NUM_ ) { throw invalid Real ( s , is Double ) ; } result . negative = ( s . char At ( NUM_ ) == STR_ ) ; char c = s . char At ( length - NUM_ ) ; if ( c == STR_ || c == STR_ || c == STR_ || c == STR_ ) { length -- ; if ( length == NUM_ ) { throw invalid Real ( s , is Double ) ; } } int end = Math . max ( s . index Of ( STR_ ) , s . index Of ( STR_ ) ) ; if ( end != - NUM_ ) { if ( end + NUM_ == length ) { throw invalid Real ( s , is Double ) ; } int exponent Offset = end + NUM_ ; boolean negative Exponent = false ; char first Exponent Char = s . char At ( exponent Offset ) ; if ( first Exponent Char == STR_ || first Exponent Char == STR_ ) { negative Exponent = ( first Exponent Char == STR_ ) ; ++ exponent Offset ; } String exponent String = s . substring ( exponent Offset , length ) ; if ( exponent String . length ( ) == NUM_ ) { throw invalid Real ( s , is Double ) ; } for ( int i = NUM_ ; i < exponent String . length ( ) ; ++ i ) { char ch = exponent String . char At ( i ) ; if ( ch < STR_ || ch > STR_ ) { throw invalid Real ( s , is Double ) ; } } try { result . e = Integer . parse Int ( exponent String ) ; if ( negative Exponent ) { result . e = - result . e ; } } catch ( Number Format Exception ex ) { if ( negative Exponent ) { result . zero = true ; } else { result . infinity = true ; } return result ; } } else { end = length ; } if ( length == NUM_ ) { throw invalid Real ( s , is Double ) ; } int start = NUM_ ; c = s . char At ( start ) ; if ( c == STR_ ) { ++ start ; -- length ; result . negative = true ; } else if ( c == STR_ ) { ++ start ; -- length ; } if ( length == NUM_ ) { throw invalid Real ( s , is Double ) ; } int decimal = s . index Of ( STR_ ) ; if ( decimal > - NUM_ ) { result . e -= end - decimal - NUM_ ; s = s . substring ( start , decimal ) + s . substring ( decimal + NUM_ , end ) ; } else { s = s . substring ( start , end ) ; } if ( ( length = s . length ( ) ) == NUM_ ) { throw invalid Real ( s , is Double ) ; } end = length ; while ( end > NUM_ && s . char At ( end - NUM_ ) == STR_ ) { -- end ; } start = NUM_ ; while ( start < end - NUM_ && s . char At ( start ) == STR_ ) { start ++ ; } if ( end != length || start != NUM_ ) { result . e += length - end ; s = s . substring ( start , end ) ; } final int APPROX MIN MAGNITUDE = - NUM_ ; final int MAX DIGITS = NUM_ ; length = s . length ( ) ; if ( length > MAX DIGITS && result . e < APPROX MIN MAGNITUDE ) { int d = Math . min ( APPROX MIN MAGNITUDE - ( int ) result . e , length - NUM_ ) ; s = s . substring ( NUM_ , length - d ) ; result . e += d ; } if ( result . e < - NUM_ ) { result . zero = true ; return result ; } else if ( result . e > NUM_ ) { result . infinity = true ; return result ; } result . s = s ; return result ; }
public double next Double ( double tau ) { double u , u 1 , v , x , y ; if ( tau != tau set ) { s = NUM_ / tau ; sm 1 = NUM_ - s ; tau set = tau ; } do { u = random Generator . raw ( ) ; u = ( NUM_ * u ) - NUM_ ; u 1 = Math . abs ( u ) ; v = random Generator . raw ( ) ; if ( u 1 <= sm 1 ) { x = u 1 ; } else { y = tau * ( NUM_ - u 1 ) ; x = sm 1 - s * Math . log ( y ) ; v = v * y ; } } while ( Math . log ( v ) > - Math . exp ( Math . log ( x ) * tau ) ) ; if ( u < NUM_ ) return x ; else return - x ; }
public boolean generates Output ( ) { return m Output File . is Directory ( ) || ( ! m Output File . is Directory ( ) && ! m Suppress Output ) ; }
private void validate Alias ( Wwn Alias Param alias , boolean for Add ) { if ( for Add || ! String Utils . is Empty ( alias . get Address ( ) ) ) { validate WWN ( alias . get Address ( ) ) ; } validate WWN Alias ( alias . get Name ( ) ) ; }
public Ct Class [ ] may Throw ( ) { Class Pool pool = this Class . get Class Pool ( ) ; Const Pool cp = this Method . get Const Pool ( ) ; Linked List list = new Linked List ( ) ; try { Code Attribute ca = this Method . get Code Attribute ( ) ; Exception Table et = ca . get Exception Table ( ) ; int pos = current Pos ; int n = et . size ( ) ; for ( int i = NUM_ ; i < n ; ++ i ) if ( et . start Pc ( i ) <= pos && pos < et . end Pc ( i ) ) { int t = et . catch Type ( i ) ; if ( t > NUM_ ) try { add Class ( list , pool . get ( cp . get Class Info ( t ) ) ) ; } catch ( Not Found Exception e ) { } } } catch ( Null Pointer Exception e ) { } Exceptions Attribute ea = this Method . get Exceptions Attribute ( ) ; if ( ea != null ) { String [ ] exceptions = ea . get Exceptions ( ) ; if ( exceptions != null ) { int n = exceptions . length ; for ( int i = NUM_ ; i < n ; ++ i ) try { add Class ( list , pool . get ( exceptions [ i ] ) ) ; } catch ( Not Found Exception e ) { } } } return ( Ct Class [ ] ) list . to Array ( new Ct Class [ list . size ( ) ] ) ; }
public static String indent ( int indent ) { String Buffer s = new String Buffer ( ) ; for ( int i = NUM_ ; i < indent ; i ++ ) { s . append ( STR_ ) ; } return s . to String ( ) ; }
public int size ( ) { return all . size ( ) ; }
public static String ago ( final Calendar date ) { final Calendar now = Calendar . get Instance ( ) ; final double seconds = ( now . get Time In Millis ( ) - date . get Time In Millis ( ) ) / NUM_ ; return format Time Span ( seconds ) ; }
public static Element first Child Element ( Element element , String child Element Name , String attr Name , String attr Value ) { if ( element == null ) return null ; Node node = element . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE && ( child Element Name == null || child Element Name . equals ( node . get Local Name ( ) != null ? node . get Local Name ( ) : node . get Node Name ( ) ) ) ) { Element child Element = ( Element ) node ; String value = child Element . get Attribute ( attr Name ) ; if ( value != null && value . equals ( attr Value ) ) { return child Element ; } } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return null ; }
private List < String > find Foreign Key To Remove ( Table Model table Model ) { List < String > remove Relations = new Array List < String > ( ) ; List < String > foreign Key Columns = get Foreign Key Columns ( table Model ) ; String self Table Name = table Model . get Table Name ( ) ; for ( String foreign Key Column : foreign Key Columns ) { String associated Table Name = DB Utility . get Table Name By Foreign Column ( foreign Key Column ) ; if ( should Drop Foreign Key ( self Table Name , associated Table Name ) ) { remove Relations . add ( foreign Key Column ) ; } } Log Util . d ( TAG , STR_ + table Model . get Table Name ( ) + STR_ + remove Relations ) ; return remove Relations ; }
public static int index Of Whitespace ( String string , int startindex , int endindex ) { for ( int i = startindex ; i < endindex ; i ++ ) { if ( Char Util . is Whitespace ( string . char At ( i ) ) ) { return i ; } } return - NUM_ ; }
public Shape create Tab Close Icon ( int x , int y , int w , int h ) { final double x Mid = x + w / NUM_ ; final double y Mid = y + h / NUM_ ; path . reset ( ) ; final double x Offset L = w / NUM_ ; final double x Offset S = w / NUM_ - NUM_ ; final double y Offset L = h / NUM_ ; final double y Offset S = h / NUM_ - NUM_ ; final double offset C = NUM_ ; path . move To ( x Mid , y Mid - offset C ) ; path . line To ( x Mid + x Offset S , y Mid - y Offset L ) ; path . line To ( y Mid + x Offset L , y Mid - y Offset S ) ; path . line To ( x Mid + offset C , y Mid ) ; path . line To ( x Mid + x Offset L , y Mid + y Offset S ) ; path . line To ( x Mid + x Offset S , y Mid + y Offset L ) ; path . line To ( x Mid , y Mid + offset C ) ; path . line To ( x Mid - x Offset S , y Mid + y Offset L ) ; path . line To ( x Mid - x Offset L , y Mid + y Offset S ) ; path . line To ( x Mid - offset C , y Mid ) ; path . line To ( x Mid - x Offset L , y Mid - y Offset S ) ; path . line To ( x Mid - x Offset S , y Mid - y Offset L ) ; path . close Path ( ) ; return path ; }
public Object [ ] to Array ( ) { if ( row == null ) { if ( key To String ) row = new Object [ ] { Misc . get As String ( key . get Details ( ) ) , new Double ( value ) , new Double ( active ) , new Date ( time ) } ; else { List list = new Array List ( ) ; Misc . add To ( list , key . get Details ( ) ) ; list . add ( new Double ( value ) ) ; list . add ( new Double ( active ) ) ; list . add ( new Date ( time ) ) ; row = list . to Array ( ) ; } } return row ; }
public Shard Id shard Id ( ) { return shard Id ; }
public boolean match Inet Network ( Inet Address ip ) { boolean same Net = false ; for ( Iterator < Inet Network > iter = networks . iterator ( ) ; ( ! same Net ) && iter . has Next ( ) ; ) { Inet Network network = iter . next ( ) ; same Net = network . contains ( ip ) ; } return same Net ; }
public static synchronized Activation Group ID current Group ID ( ) { return curr Group ID ; }
public int plaline len ( int offset ) { return lines list . size ( ) + offset ; }
public final void quietly Join ( ) { do Join ( ) ; }
@ Visible For Testing public Block create Next Block ( Address to , long time ) { return create Next Block ( to , null , time , EMPTY BYTES , Utils . to Nano Coins ( NUM_ , NUM_ ) ) ; }
private boolean check Attribute ( String serv Alg , String attribute , String val ) { String attribute Value = get Property Ignore Case ( serv Alg + STR_ + attribute ) ; if ( attribute Value != null ) { if ( attribute . equals Ignore Case ( STR_ ) ) { if ( Integer . parse Int ( attribute Value ) >= Integer . parse Int ( val ) ) { return true ; } } else { if ( attribute Value . equals Ignore Case ( val ) ) { return true ; } } } return false ; }
public Image base For ( I Hex hex ) { return hex Tileset . get Base ( hex , boardview ) ; }
public int index ( String what ) { if ( what == null ) { for ( int i = NUM_ ; i < count ; i ++ ) { if ( data [ i ] == null ) { return i ; } } } else { for ( int i = NUM_ ; i < count ; i ++ ) { if ( what . equals ( data [ i ] ) ) { return i ; } } } return - NUM_ ; }
public static Wallet load From File ( File f ) throws Unreadable Wallet Exception { try { File Input Stream stream = null ; try { stream = new File Input Stream ( f ) ; return load From File Stream ( stream ) ; } finally { if ( stream != null ) stream . close ( ) ; } } catch ( IO Exception e ) { throw new Unreadable Wallet Exception ( STR_ , e ) ; } }
private int index Of ( String container Path , String relative Path ) { int length = this . container Paths . length , index = ( container Path . hash Code ( ) & NUM_ ) % length ; String current Container Path ; while ( ( current Container Path = this . container Paths [ index ] ) != null ) { if ( current Container Path . equals ( container Path ) ) { String current Relative Path = this . relative Paths [ index ] ; if ( encloses ( current Relative Path , relative Path , index ) ) return index ; } if ( ++ index == length ) { index = NUM_ ; } } return - NUM_ ; }
final public boolean ends With Ignore Case ( final Char Sequence suffix ) { final int l = suffix . length ( ) ; int length = length ( ) ; if ( l > length ) return false ; int i = l ; final char [ ] a = array ; char c , d ; while ( i -- != NUM_ ) { c = Character . to Lower Case ( Character . to Upper Case ( suffix . char At ( i ) ) ) ; d = Character . to Lower Case ( Character . to Upper Case ( a [ -- length ] ) ) ; if ( c != d ) return false ; } return true ; }
public String attribute Indices Tip Text ( ) { return STR_ + STR_ + STR_ + STR_ ; }
public static long pop array ( long [ ] arr , int word Offset , int num Words ) { long pop Count = NUM_ ; for ( int i = word Offset , end = word Offset + num Words ; i < end ; ++ i ) { pop Count += Long . bit Count ( arr [ i ] ) ; } return pop Count ; }
public static synchronized void recycle ( Rectangle r ) { if ( pool . size ( ) >= MAX POOL SIZE || r == null ) { return ; } pool . add ( r ) ; }
public static byte [ ] read Fully No Close ( Input Stream in ) throws IO Exception { Byte Array Output Stream bytes = new Byte Array Output Stream ( ) ; byte [ ] buffer = new byte [ NUM_ ] ; int count ; while ( ( count = in . read ( buffer ) ) != - NUM_ ) { bytes . write ( buffer , NUM_ , count ) ; } return bytes . to Byte Array ( ) ; }
private void parse ( ) { if ( lexer == null ) { tokens = null ; return ; } List < Token > toks = new Array List < Token > ( get Length ( ) / NUM_ ) ; long ts = System . nano Time ( ) ; int len = get Length ( ) ; try { Segment seg = new Segment ( ) ; get Text ( NUM_ , get Length ( ) , seg ) ; Char Array Reader reader = new Char Array Reader ( seg . array , seg . offset , seg . count ) ; lexer . yyreset ( reader ) ; Token token ; while ( ( token = lexer . yylex ( ) ) != null ) { toks . add ( token ) ; } } catch ( Bad Location Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } catch ( IO Exception ex ) { log . log ( Level . SEVERE , null , ex ) ; } finally { if ( log . is Loggable ( Level . FINEST ) ) { log . finest ( String . format ( STR_ , len , ( System . nano Time ( ) - ts ) / NUM_ , toks . size ( ) ) ) ; } tokens = toks ; } }
public Double Vector rev ( ) { int n = size ( ) ; Double Vector w = new Double Vector ( n ) ; for ( int i = NUM_ ; i < n ; i ++ ) { w . V [ i ] = V [ n - i - NUM_ ] ; } return w ; }
public final int length ( ) { return remaining ( ) ; }
public byte [ ] to Byte Array ( ) { byte [ ] new Array = new byte [ count ] ; System . arraycopy ( buf , NUM_ , new Array , NUM_ , count ) ; return new Array ; }
@ Suppress Warnings ( STR_ ) public static < T extends T Member > Member List < T > empty List ( ) { return ( Member List < T > ) EMPTY LIST ; }
public int size ( ) { return serial Queue . size ( ) ; }
public final int clearance violation count ( ) { Collection < Brd Item Violation > violations = clearance violations ( ) ; return violations . size ( ) ; }
public static void close Silently ( Input Stream in ) { if ( in != null ) { try { trace ( STR_ , null , in ) ; in . close ( ) ; } catch ( Exception e ) { } } }
Object Stream Field [ ] fields ( ) { if ( fields == null ) { Class < ? > for Cl = for Class ( ) ; if ( for Cl != null && is Serializable ( ) && ! for Cl . is Array ( ) ) { build Field Descriptors ( for Cl . get Declared Fields ( ) ) ; } else { set Fields ( NO FIELDS ) ; } } return fields ; }
@ Override public int hash Code ( ) { return canonical Name . hash Code ( ) ; }
@ Override public Iterator < Field Info > iterator ( ) { return values . iterator ( ) ; }
public String scm Url ( ) { return properties . get Property ( STR_ ) ; }
public int pkg count ( ) { return package list . size ( ) ; }
private void usage ( ) { throw new Usage Exception ( STR_ ) ; }
public static cu Complex cu Cdiv ( cu Complex x , cu Complex y ) { cu Complex quot ; float s = ( ( float ) Math . abs ( cu Creal ( y ) ) ) + ( ( float ) Math . abs ( cu Cimag ( y ) ) ) ; float oos = NUM_ / s ; float ars = cu Creal ( x ) * oos ; float ais = cu Cimag ( x ) * oos ; float brs = cu Creal ( y ) * oos ; float bis = cu Cimag ( y ) * oos ; s = ( brs * brs ) + ( bis * bis ) ; oos = NUM_ / s ; quot = cu Cmplx ( ( ( ars * brs ) + ( ais * bis ) ) * oos , ( ( ais * brs ) - ( ars * bis ) ) * oos ) ; return quot ; }
@ Override public int hash Code ( ) { return principal Class . hash Code ( ) ; }
public synchronized Set Layer Runnable pop Layer Event ( ) { try { return events . remove ( NUM_ ) ; } catch ( Array Index Out Of Bounds Exception aioobe ) { return null ; } }
private String find SVM Name ( File Share fs ) { String port Group = null ; URI port = fs . get Storage Port ( ) ; if ( port == null ) { log . info ( STR_ ) ; } else { Storage Port st Port = db Client . query Object ( Storage Port . class , port ) ; if ( st Port != null ) { URI ha Domain Uri = st Port . get Storage HA Domain ( ) ; if ( ha Domain Uri == null ) { log . info ( STR_ , port ) ; } else { Storage HA Domain ha Domain = db Client . query Object ( Storage HA Domain . class , ha Domain Uri ) ; if ( ha Domain != null && ha Domain . get Virtual ( ) == true ) { port Group = st Port . get Port Group ( ) ; log . debug ( STR_ , st Port . get Port Network Id ( ) , port Group ) ; } } } } return port Group ; }
public boolean is Default Value Mutable ( Field field ) { Type Ref type = field . get Type ( ) ; if ( type . get Cardinality ( ) == Cardinality . REPEATED ) { return true ; } switch ( type . get Kind ( ) ) { case TYPE MESSAGE : case TYPE ENUM : return true ; default : return false ; } }
public String basic Type Name ( Field field ) { String result = FIELD TYPE MAP . get ( field . get Kind ( ) ) ; if ( result != null ) { if ( result . contains ( STR_ ) ) { return get Type Name ( result ) ; } return result ; } throw new Illegal Argument Exception ( STR_ + field . get Kind ( ) ) ; }
public static String now As String ( ) { return Long . to String ( System . current Time Millis ( ) ) ; }
@ Override public String to String Key ( ) { String result ; int i ; result = STR_ ; for ( i = NUM_ ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) { continue ; } result += LEFT PARENTHESES + ( i + NUM_ ) + RIGHT PARENTHESES + STR_ + remove Filter Name ( m Col Names [ i ] ) + STR_ ; } return result ; }
public boolean exists ( String ... keys ) { return get 0 ( keys ) != null ; }
private boolean is Widget ( String node String ) { return node String . contains ( STR_ ) || node String . contains ( STR_ ) ; }
public static Number asinh ( Number a ) { return Fast Math . asinh ( a . double Value ( ) ) ; }
public boolean should Ignore For Stats ( Soot Class clz ) { return STATS IGNORE SOOTCLASSES . contains ( clz ) ; }
boolean suppressed By ( DNS Incoming msg ) { try { for ( DNS Record answer : msg . get All Answers ( ) ) { if ( suppressed By ( answer ) ) { return true ; } } return false ; } catch ( Array Index Out Of Bounds Exception e ) { logger . log ( Level . WARNING , STR_ + msg + STR_ , e ) ; return false ; } }
@ Override public String first Chunk ( List < String > chunks ) { if ( chunks == null || chunks . size ( ) == NUM_ ) { return null ; } return chunks . get ( NUM_ ) ; }
public String to XML ( ) { return to XML ( true ) ; }
private static boolean is Unexpected Bug ( Bug Instance bug ) { return FB MISSING EXPECTED WARNING . equals ( bug . get Type ( ) ) || FB UNEXPECTED WARNING . equals ( bug . get Type ( ) ) ; }
private boolean is Non Command Line Argument ( String prop Name ) { return prop Name . equals ( EXECUTABLE NAME KEY ) || prop Name . equals ( EXECUTABLE PATH KEY ) ; }
public boolean equals ( Object other ) { if ( other == this ) { return true ; } if ( ! ( other instanceof X 509 CRL ) ) { return false ; } X 509 CRL obj = ( X 509 CRL ) other ; try { return Arrays . equals ( get Encoded ( ) , obj . get Encoded ( ) ) ; } catch ( CRL Exception e ) { return false ; } }
@ Suppress Warnings ( STR_ ) public < T extends PO > T first Only ( ) throws DB Exception { T po = null ; String sql = build SQL ( null , true ) ; Prepared Statement pstmt = null ; Result Set rs = null ; try { pstmt = DB . prepare Statement ( sql , trx Name ) ; rs = create Result Set ( pstmt ) ; if ( rs . next ( ) ) { po = ( T ) table . get PO ( rs , trx Name ) ; } if ( rs . next ( ) ) { throw new DB Exception ( STR_ ) ; } } catch ( SQL Exception e ) { log . log ( Level . SEVERE , sql , e ) ; throw new DB Exception ( e , sql ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return po ; }
public Inline Menu Row row At ( int index ) { return rows . get ( index ) ; }
public double predict char prob ( String pre , int n ) { if ( n < NUM_ || n > predicted chars ) { return NUM_ ; } if ( pre . equals ( STR_ ) ) { pre = STR_ ; } String key = pre + n ; Double prob = context prob . get ( key ) ; if ( prob != null ) { prob = Math . pow ( NUM_ , prob ) ; } return prob ; }
public static Test suite ( ) { return new Test Suite ( Merge Infrequent Nominal Values Test . class ) ; }
@ Deprecated public static String join ( String delimiter , String ... parts ) { if ( delimiter == null ) { throw new Illegal Argument Exception ( STR_ ) ; } String Builder sb = new String Builder ( ) ; for ( String alias : parts ) { if ( sb . length ( ) != NUM_ ) { sb . append ( delimiter ) ; } sb . append ( alias ) ; } return sb . to String ( ) ; }
public int size ( ) { return to Export . size ( ) ; }
public String to XML String ( ) throws XACML Exception { return to XML String ( true , false ) ; }
public boolean is Empty ( ) { return cells . is Empty ( ) ; }
public String host ( ) { return address . get Host String ( ) ; }
public static boolean requires Bidi ( char [ ] text , int start , int limit ) { return Bidi Base . requires Bidi ( text , start , limit ) ; }
@ Override public int size ( ) { return data List . size ( ) ; }
public static < K , V > Multi Value Map < K , V > unmodifiable Multi Value Map ( Multi Value Map < ? extends K , ? extends V > map ) { Assert . not Null ( map , STR_ ) ; Map < K , List < V > > result = new Linked Hash Map < K , List < V > > ( map . size ( ) ) ; for ( Map . Entry < ? extends K , ? extends List < ? extends V > > entry : map . entry Set ( ) ) { List < V > values = Collections . unmodifiable List ( entry . get Value ( ) ) ; result . put ( entry . get Key ( ) , values ) ; } Map < K , List < V > > unmodifiable Map = Collections . unmodifiable Map ( result ) ; return to Multi Value Map ( unmodifiable Map ) ; }
public int available ( ) throws IO Exception { ensure Open ( ) ; if ( reach EOF ) { return NUM_ ; } else { return NUM_ ; } }
private int epoch Day To Epoch Month ( int epoch Day ) { int ndx = Arrays . binary Search ( hijrah Epoch Month Start Days , epoch Day ) ; if ( ndx < NUM_ ) { ndx = - ndx - NUM_ ; } return ndx ; }
public int hash Code ( ) { int hash = type . hash Code ( ) ; if ( name != null ) hash ^= name . hash Code ( ) ; if ( actions != null ) hash ^= actions . hash Code ( ) ; return hash ; }
public String save Instances Tip Text ( ) { return STR_ + STR_ ; }
public Shape create Cancel Icon ( int x , int y , int w , int h ) { final double x Mid = x + w / NUM_ ; final double y Mid = y + h / NUM_ ; path . reset ( ) ; path . move To ( x Mid , y ) ; path . quad To ( x , y , x , y Mid ) ; path . quad To ( x , y + h , x Mid , y + h ) ; path . quad To ( x + w , y + h , x + w , y Mid ) ; path . quad To ( x + w , y , x Mid , y ) ; path . close Path ( ) ; final double x Offset L = w / NUM_ - NUM_ ; final double x Offset S = w / NUM_ - NUM_ ; final double y Offset L = h / NUM_ - NUM_ ; final double y Offset S = h / NUM_ - NUM_ ; final double offset C = NUM_ ; path . move To ( x Mid , y Mid - offset C ) ; path . line To ( x Mid + x Offset S , y Mid - y Offset L ) ; path . line To ( y Mid + x Offset L , y Mid - y Offset S ) ; path . line To ( x Mid + offset C , y Mid ) ; path . line To ( x Mid + x Offset L , y Mid + y Offset S ) ; path . line To ( x Mid + x Offset S , y Mid + y Offset L ) ; path . line To ( x Mid , y Mid + offset C ) ; path . line To ( x Mid - x Offset S , y Mid + y Offset L ) ; path . line To ( x Mid - x Offset L , y Mid + y Offset S ) ; path . line To ( x Mid - offset C , y Mid ) ; path . line To ( x Mid - x Offset L , y Mid - y Offset S ) ; path . line To ( x Mid - x Offset S , y Mid - y Offset L ) ; path . close Path ( ) ; return path ; }
public boolean is Empty ( ) { return selection . is Empty ( ) ; }
private Object timed Get ( long nanos ) throws Timeout Exception { if ( Thread . interrupted ( ) ) return null ; if ( nanos > NUM_ ) { long d = System . nano Time ( ) + nanos ; long deadline = ( d == NUM_ ) ? NUM_ : d ; Signaller q = null ; boolean queued = false ; Object r ; while ( ( r = result ) == null ) { if ( q == null ) { q = new Signaller ( true , nanos , deadline ) ; if ( Thread . current Thread ( ) instanceof Fork Join Worker Thread ) Fork Join Pool . help Async Blocker ( default Executor ( ) , q ) ; } else if ( ! queued ) queued = try Push Stack ( q ) ; else if ( q . nanos <= NUM_ ) break ; else { try { Fork Join Pool . managed Block ( q ) ; } catch ( Interrupted Exception ie ) { q . interrupted = true ; } if ( q . interrupted ) break ; } } if ( q != null && queued ) { q . thread = null ; if ( r == null ) clean Stack ( ) ; } if ( r != null || ( r = result ) != null ) post Complete ( ) ; if ( r != null || ( q != null && q . interrupted ) ) return r ; } throw new Timeout Exception ( ) ; }
public String to XML String ( ) throws FS Msg Exception { return to XML String ( true , true ) ; }
public List < Local Time > bottom ( int n ) { List < Local Time > bottom = new Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ; Int Arrays . parallel Quick Sort ( values ) ; for ( int i = NUM_ ; i < n && i < values . length ; i ++ ) { bottom . add ( Packed Local Time . as Local Time ( values [ i ] ) ) ; } return bottom ; }
public Character char At ( int i ) { return str . char At ( i ) ; }
public static boolean is Gzip Encoding ( @ Nullable final String encoding Type ) { return CONTENT ENCODING GZIP . equals Ignore Case ( encoding Type ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public List < Node > list Available Crossover Nodes ( Node node , Class < ? > type ) { List < Node > result = new Array List < Node > ( ) ; if ( type . is Assignable From ( node . get Return Type ( ) ) ) { result . add ( node ) ; } for ( int i = NUM_ ; i < node . get Number Of Arguments ( ) ; i ++ ) { result . add All ( list Available Crossover Nodes ( node . get Argument ( i ) , type ) ) ; } return result ; }
public static Tag value Of ( String name ) { Reject . if Null ( name ) ; Root Cfg Defn . get Instance ( ) ; Tag tag = TAGS . get ( name . to Lower Case ( ) ) ; if ( tag == null ) { throw new Illegal Argument Exception ( STR_ + name + STR_ ) ; } return tag ; }
public Object [ ] to Array ( ) { final Object [ ] items = this . items ; final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { final int count = this . count ; Object [ ] a = new Object [ count ] ; int n = items . length - take Index ; if ( count <= n ) { System . arraycopy ( items , take Index , a , NUM_ , count ) ; } else { System . arraycopy ( items , take Index , a , NUM_ , n ) ; System . arraycopy ( items , NUM_ , a , n , count - n ) ; } return a ; } finally { lock . unlock ( ) ; } }
public double min ( ) { int size = values . size ( ) ; double min = Double . MAX VALUE ; for ( int i = NUM_ ; i < size ; i ++ ) min = Math . min ( min , values . get ( i ) ) ; return min ; }
public Iterator iterator ( ) { sort Edges ( ) ; return out Edges . iterator ( ) ; }
@ Override public int hash Code ( ) { return hashcode ; }
private int find Last Group Index ( int group Id ) { int i = NUM_ , size = m Items . size ( ) ; boolean traversing Group = false ; while ( true ) { if ( i < size ) { final Sublime Base Menu Item item = m Items . get ( i ) ; if ( item . get Group Id ( ) == group Id ) { traversing Group = true ; } else if ( traversing Group ) { return i - NUM_ ; } i ++ ; } else { return traversing Group ? size - NUM_ : size ; } } }
public static int count Nnz ( String [ ] cols , int pos , int len ) { int lnnz = NUM_ ; for ( int i = pos ; i < pos + len ; i ++ ) { String col = cols [ i ] ; lnnz += ( ! col . is Empty ( ) && ! col . equals ( STR_ ) && ! col . equals ( STR_ ) ) ? NUM_ : NUM_ ; } return lnnz ; }
@ Method Desc ( description = STR_ , usage = STR_ ) public boolean is Alive ( ) { return true ; }
public byte [ ] encode ( ) { char type = get Attribute Type ( ) ; byte bin Value [ ] = new byte [ HEADER LENGTH + get Data Length ( ) + ( NUM_ - get Data Length ( ) % NUM_ ) % NUM_ ] ; bin Value [ NUM_ ] = ( byte ) ( type > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( type & NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) & NUM_ ) ; System . arraycopy ( software , NUM_ , bin Value , NUM_ , get Data Length ( ) ) ; return bin Value ; }
public static boolean is Empty ( String str ) { return is Null ( str ) || str . length ( ) <= NUM_ ; }
private String z Get Standard Text Field Date String ( Local Date date ) { if ( settings == null ) { return STR_ ; } String standard Date String = STR_ ; if ( date == null ) { return standard Date String ; } if ( date . get Era ( ) == Iso Era . CE ) { standard Date String = date . format ( settings . get Format For Dates Common Era ( ) ) ; } else { standard Date String = date . format ( settings . get Format For Dates Before Common Era ( ) ) ; } return standard Date String ; }
public static Map < Unit , Unit > map Transports Already Loaded ( final Collection < Unit > units , final Collection < Unit > transports ) { final Collection < Unit > can Be Transported = Match . get Matches ( units , Matches . Unit Can Be Transported ) ; final Collection < Unit > can Transport = Match . get Matches ( transports , Matches . Unit Can Transport ) ; final Map < Unit , Unit > mapping = new Hash Map < > ( ) ; for ( final Unit current Transported : can Be Transported ) { final Unit transport = Transport Tracker . transported By ( current Transported ) ; if ( transport == null || ! can Transport . contains ( transport ) ) { continue ; } mapping . put ( current Transported , transport ) ; } return mapping ; }
public String to External Form ( ) { if ( stream Handler == null ) { return STR_ + protocol + STR_ + host + file ; } return stream Handler . to External Form ( this ) ; }
public Boolean element Exists ( String target Img Path ) { Point 2 D coords = get Coords ( take Screenshot ( ) , target Img Path ) ; return ( coords . get X ( ) >= NUM_ ) && ( coords . get Y ( ) >= NUM_ ) ; }
@ Override public int is Match ( final char [ ] buffer , final int pos , final int buffer Start , final int buffer End ) { return Arrays . binary Search ( chars , buffer [ pos ] ) >= NUM_ ? NUM_ : NUM_ ; }
boolean is Meta ( char c ) { return meta Character Set . get ( c ) ; }
public static Date days After Without Time Zone ( Date date Inst , int num Days ) { if ( ( num Days <= NUM_ ) || ( date Inst == null ) ) { throw new Illegal Argument Exception ( ) ; } final long days In Millis = num Days * MILLIS IN DAY ; return new Date ( date Inst . get Time ( ) + days In Millis ) ; }
public int [ ] find Row Indices ( String value , String column Name ) { return find Row Indices ( value , get Column Index ( column Name ) ) ; }
public String to Fast A ( ) { return to Fast A ( false , NUM_ , NUM_ , get Number Of Sequences ( ) - NUM_ , get Length ( ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private int end Recover Animation ( Recycler View . View Holder view Holder , boolean override ) { final int recover Anim Size = m Recover Animations . size ( ) ; for ( int i = recover Anim Size - NUM_ ; i >= NUM_ ; i -- ) { final Recover Animation anim = m Recover Animations . get ( i ) ; if ( anim . m View Holder == view Holder ) { anim . m Overridden |= override ; if ( ! anim . m Ended ) { anim . cancel ( ) ; } m Recover Animations . remove ( i ) ; return anim . m Animation Type ; } } return NUM_ ; }
public Stream Impl open Read Impl ( ) throws IO Exception { if ( is Windows && is Aux ( ) ) throw new File Not Found Exception ( file . to String ( ) ) ; return new File Read Stream ( new File Input Stream ( get File ( ) ) , this ) ; }
public Grouped Facet Result merge Segment Results ( int size , int min Count , boolean order By Count ) throws IO Exception { if ( segment Facet Counts != null ) { segment Results . add ( create Segment Result ( ) ) ; segment Facet Counts = null ; } int total Count = NUM_ ; int missing Count = NUM_ ; Segment Result Priority Queue segments = new Segment Result Priority Queue ( segment Results . size ( ) ) ; for ( Segment Result segment Result : segment Results ) { missing Count += segment Result . missing ; if ( segment Result . merge Pos >= segment Result . max Term Pos ) { continue ; } total Count += segment Result . total ; segments . add ( segment Result ) ; } Grouped Facet Result facet Result = new Grouped Facet Result ( size , min Count , order By Count , total Count , missing Count ) ; while ( segments . size ( ) > NUM_ ) { Segment Result segment Result = segments . top ( ) ; Bytes Ref current Facet Value = Bytes Ref . deep Copy Of ( segment Result . merge Term ) ; int count = NUM_ ; do { count += segment Result . counts [ segment Result . merge Pos ++ ] ; if ( segment Result . merge Pos < segment Result . max Term Pos ) { segment Result . next Term ( ) ; segment Result = segments . update Top ( ) ; } else { segments . pop ( ) ; segment Result = segments . top ( ) ; if ( segment Result == null ) { break ; } } } while ( current Facet Value . equals ( segment Result . merge Term ) ) ; facet Result . add Facet Count ( current Facet Value , count ) ; } return facet Result ; }
private Vector string To TLA Tokens ( String token ) { Vector result = new Vector ( NUM_ ) ; String trimmed Token = token . trim ( ) ; int number Of Left Trimmed Tokens = ( trimmed Token . length ( ) == NUM_ ) ? - NUM_ : token . index Of ( trimmed Token . char At ( NUM_ ) ) ; if ( number Of Left Trimmed Tokens == - NUM_ ) { number Of Left Trimmed Tokens = NUM_ ; trimmed Token = token ; } int obj Begin = number Of Left Trimmed Tokens ; result . add Element ( new Mapping Object . Begin TLA Token ( obj Begin ) ) ; result . add Element ( new Mapping Object . End TLA Token ( obj Begin + trimmed Token . length ( ) ) ) ; return result ; }
public short item At ( int pos ) { if ( pos < NUM_ || pos > state . length ) { throw new Index Out Of Bounds Exception ( ) ; } for ( ; iter <= pos ; ++ iter ) { int r = random . next Int ( state . length - iter ) + iter ; short tmp = state [ r ] ; state [ r ] = state [ iter ] ; state [ iter ] = tmp ; } return state [ pos ] ; }
public static double ulp ( double d ) { if ( Double . is Na N ( d ) ) { return Double . Na N ; } if ( Double . is Infinite ( d ) ) { return Double . POSITIVE INFINITY ; } if ( d == NUM_ ) { return Double . MIN VALUE ; } d = Math . abs ( d ) ; if ( d == Double . MAX VALUE ) { return MAX ULP ; } return next After ( d , Double . MAX VALUE ) - d ; }
public S 1 Angle angle ( ) { if ( is Empty ( ) ) { return S 1 Angle . radians ( - NUM_ ) ; } return S 1 Angle . radians ( NUM_ * Math . asin ( Math . sqrt ( NUM_ * height ) ) ) ; }
private static void divide ( int [ ] n 1 , int [ ] n 2 , int [ ] quotient , int [ ] remainder ) { if ( is Zero ( n 2 ) ) { throw new Arithmetic Exception ( STR_ ) ; } clear ( remainder ) ; clear ( quotient ) ; if ( compare To ( n 2 , n 1 ) > NUM_ ) { int idx = remainder . length - NUM_ ; for ( int i = NUM_ ; i < n 1 . length ; i ++ ) { remainder [ idx -- ] = n 1 [ i ] ; } return ; } n 1 = reduce ( n 1 ) ; n 2 = reduce ( n 2 ) ; while ( compare To ( n 2 , NUM_ , n 2 . length , n 1 , NUM_ ) > NUM_ ) { n 2 = expand ( n 2 ) ; } String result = sub Process ( n 1 , n 2 ) ; int idx = result . index Of ( STR_ ) ; if ( idx == - NUM_ ) { for ( int i = NUM_ ; i < quotient . length ; i ++ ) { quotient [ i ] = NUM_ ; } pack ( remainder , result ) ; } else { pack ( quotient , result . substring ( NUM_ , idx ) ) ; pack ( remainder , result . substring ( idx + NUM_ ) ) ; } }
public boolean is Editable ( ) { return m Pane View . is Editable ( ) ; }
public static boolean has Property ( String property Name ) { return props . contains Key ( property Name ) ; }
public static List property Descriptors ( int api Level ) { return PROPERTY DESCRIPTORS ; }
public boolean reload Is Modified ( ) { if ( class Is Modified ) { return true ; } if ( ! has JNI Reload || ! class Path . can Read ( ) ) { return true ; } try { long length = class Path . length ( ) ; Class < ? > cl = cl Ref != null ? cl Ref . get ( ) : null ; if ( cl == null ) { return false ; } byte [ ] bytecode = new byte [ ( int ) length ] ; try ( Input Stream is = class Path . input Stream ( ) ) { Io Util . read All ( is , bytecode , NUM_ , bytecode . length ) ; } int result = reload Native ( cl , bytecode , NUM_ , bytecode . length ) ; if ( result != NUM_ ) { class Is Modified = true ; return true ; } if ( source Path != null ) { source Last Modified = source Path . get Last Modified ( ) ; source Length = source Path . length ( ) ; } log . info ( STR_ + cl . get Name ( ) ) ; return false ; } catch ( Exception e ) { log . log ( Level . WARNING , e . to String ( ) , e ) ; class Is Modified = true ; return true ; } }
public void select Parameters ( List < Parameter > params ) { if ( node Height Prior == Tree Prior Type . CONSTANT ) { params . add ( get Parameter ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . EXPONENTIAL ) { params . add ( get Parameter ( STR_ ) ) ; if ( parameterization == Tree Prior Parameterization Type . GROWTH RATE ) { params . add ( get Parameter ( STR_ ) ) ; } else { params . add ( get Parameter ( STR_ ) ) ; } } else if ( node Height Prior == Tree Prior Type . LOGISTIC ) { params . add ( get Parameter ( STR_ ) ) ; if ( parameterization == Tree Prior Parameterization Type . GROWTH RATE ) { params . add ( get Parameter ( STR_ ) ) ; } else { params . add ( get Parameter ( STR_ ) ) ; } params . add ( get Parameter ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . EXPANSION ) { params . add ( get Parameter ( STR_ ) ) ; if ( parameterization == Tree Prior Parameterization Type . GROWTH RATE ) { params . add ( get Parameter ( STR_ ) ) ; } else { params . add ( get Parameter ( STR_ ) ) ; } params . add ( get Parameter ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . SKYLINE ) { params . add ( get Parameter ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . EXTENDED SKYLINE ) { params . add ( get Parameter ( STR_ ) ) ; params . add ( get Parameter ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . GMRF SKYRIDE ) { params . add ( get Parameter ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . SKYGRID ) { params . add ( get Parameter ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . YULE || node Height Prior == Tree Prior Type . YULE CALIBRATION ) { params . add ( get Parameter ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . BIRTH DEATH || node Height Prior == Tree Prior Type . BIRTH DEATH INCOMPLETE SAMPLING ) { params . add ( get Parameter ( Birth Death Model Parser . MEAN GROWTH RATE PARAM NAME ) ) ; params . add ( get Parameter ( Birth Death Model Parser . RELATIVE DEATH RATE PARAM NAME ) ) ; if ( node Height Prior == Tree Prior Type . BIRTH DEATH INCOMPLETE SAMPLING ) params . add ( get Parameter ( Birth Death Model Parser . BIRTH DEATH + STR_ + Birth Death Model Parser . SAMPLE PROB ) ) ; } else if ( node Height Prior == Tree Prior Type . BIRTH DEATH SERIAL SAMPLING ) { params . add ( get Parameter ( Birth Death Serial Sampling Model Parser . BDSS + STR_ + Birth Death Serial Sampling Model Parser . LAMBDA ) ) ; params . add ( get Parameter ( Birth Death Serial Sampling Model Parser . BDSS + STR_ + Birth Death Serial Sampling Model Parser . RELATIVE MU ) ) ; Parameter psi = get Parameter ( Birth Death Serial Sampling Model Parser . BDSS + STR_ + Birth Death Serial Sampling Model Parser . PSI ) ; if ( options . maximum Tip Height > NUM_ ) { psi . set Initial ( Math Utils . round ( NUM_ / options . maximum Tip Height , NUM_ ) ) ; } params . add ( psi ) ; params . add ( get Parameter ( Birth Death Serial Sampling Model Parser . BDSS + STR_ + Birth Death Serial Sampling Model Parser . ORIGIN ) ) ; } else if ( node Height Prior == Tree Prior Type . BIRTH DEATH BASIC REPRODUCTIVE NUMBER ) { params . add ( get Parameter ( Birth Death Epidemiology Model Parser . ORIGIN ) ) ; params . add ( get Parameter ( Birth Death Epidemiology Model Parser . R 0 ) ) ; params . add ( get Parameter ( Birth Death Epidemiology Model Parser . RECOVERY RATE ) ) ; params . add ( get Parameter ( Birth Death Epidemiology Model Parser . SAMPLING PROBABILITY ) ) ; } }
public Optional Double min By Double ( Double Unary Operator key Extractor ) { double [ ] result = collect ( null , null , null ) ; return result [ NUM_ ] == NUM_ ? Optional Double . of ( result [ NUM_ ] ) : Optional Double . empty ( ) ; }
public static String null To Empty ( @ Nullable Char Sequence string ) { return string == null ? EMPTY : string . to String ( ) ; }
public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( ) ; new Vector . add All ( Collections . list ( super . enumerate Measures ( ) ) ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; return new Vector . elements ( ) ; }
public static String of Method ( Ct Class return Type , Ct Class [ ] param Types ) { String Buffer desc = new String Buffer ( ) ; desc . append ( STR_ ) ; if ( param Types != null ) { int n = param Types . length ; for ( int i = NUM_ ; i < n ; ++ i ) to Descriptor ( desc , param Types [ i ] ) ; } desc . append ( STR_ ) ; if ( return Type != null ) to Descriptor ( desc , return Type ) ; return desc . to String ( ) ; }
private String title Of ( Search Result Mediator rp ) { int total = rp . total Results ( ) ; String title = rp . get Title ( ) ; if ( title . length ( ) > NUM_ ) { title = title . substring ( NUM_ , NUM_ ) + STR_ ; } return title + STR_ + total + STR_ + I 18 n . tr ( STR_ ) + STR_ ; }
public T Double Double Hash Map absolute Distribution Log 2 ( double descretization ) { T Double Double Hash Map freq = new T Double Double Hash Map ( ) ; int size = values . size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { double bin = Math . ceil ( Math . log ( values . get ( i ) / descretization ) / Math . log ( NUM_ ) ) ; bin = Math . max ( bin , NUM_ ) ; double bin Width = Math . pow ( NUM_ , bin ) - Math . pow ( NUM_ , bin - NUM_ ) ; bin Width = Math . max ( NUM_ , bin Width ) ; freq . adjust Or Put Value ( Math . pow ( NUM_ , bin ) * descretization , weights . get ( i ) / bin Width , weights . get ( i ) / bin Width ) ; } return freq ; }
public String shortest Match ( String input ) { Trie Node node = root ; for ( int i = input . length ( ) - NUM_ ; i >= NUM_ ; i -- ) { node = node . get Child ( input . char At ( i ) ) ; if ( node == null ) return null ; if ( node . is Terminal ( ) ) return input . substring ( i ) ; } return null ; }
@ Override public int hash Code ( ) { return Objects . hash ( id , version , update Site ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
boolean has Animations ( ) { return ( animatable Components != null && animatable Components . size ( ) > NUM_ ) || ( internal Animatable Components != null && internal Animatable Components . size ( ) > NUM_ ) || ( anim Mananger != null && anim Mananger . is Animating ( ) ) ; }
public Dimension preferred Layout Size ( Container parent ) { Dimension rd , mbd ; Insets i = get Insets ( ) ; if ( content Pane != null ) { rd = content Pane . get Preferred Size ( ) ; } else { rd = parent . get Size ( ) ; } if ( menu Bar != null && menu Bar . is Visible ( ) ) { mbd = menu Bar . get Preferred Size ( ) ; } else { mbd = new Dimension ( NUM_ , NUM_ ) ; } return new Dimension ( Math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
char char At ( int i ) { return text . char At ( i ) ; }
public static boolean string Length OK ( String s ) { if ( s == null ) { throw new Illegal Argument Exception ( STR_ ) ; } Boolean b = string Length OK Cached . get ( s ) ; if ( b != null ) { return b ; } boolean retval = is OK Length ( s ) ; string Length OK Cached . put ( s , retval ) ; return retval ; }
private Concurrent Skip List Map . Node < K , V > lo Node ( ) { if ( lo == null ) return m . find First ( ) ; else if ( lo Inclusive ) return m . find Near ( lo , GT | EQ ) ; else return m . find Near ( lo , GT ) ; }
public int append Until Break ( final Iterator < Expression > it ) { int count = NUM_ ; while ( it . has Next ( ) ) { final Expression expr = it . next ( ) ; append ( expr . get Normalized ( ) ) ; ++ count ; if ( expr . get Break Flag ( ) ) { break ; } } return count ; }
private static String read Link Impl ( long handle ) throws IO Exception { int size = MAXIMUM REPARSE DATA BUFFER SIZE ; Native Buffer buffer = Native Buffers . get Native Buffer ( size ) ; try { try { Device Io Control Get Reparse Point ( handle , buffer . address ( ) , size ) ; } catch ( Windows Exception x ) { if ( x . last Error ( ) == ERROR NOT A REPARSE POINT ) throw new Not Link Exception ( null , null , x . error String ( ) ) ; x . rethrow As IO Exception ( ( String ) null ) ; } final short OFFSETOF REPARSETAG = NUM_ ; final short OFFSETOF PATHOFFSET = NUM_ ; final short OFFSETOF PATHLENGTH = NUM_ ; final short OFFSETOF PATHBUFFER = NUM_ + NUM_ ; int tag = ( int ) unsafe . get Long ( buffer . address ( ) + OFFSETOF REPARSETAG ) ; if ( tag != IO REPARSE TAG SYMLINK ) { throw new Not Link Exception ( null , null , STR_ ) ; } short name Offset = unsafe . get Short ( buffer . address ( ) + OFFSETOF PATHOFFSET ) ; short name Length In Bytes = unsafe . get Short ( buffer . address ( ) + OFFSETOF PATHLENGTH ) ; if ( ( name Length In Bytes % NUM_ ) != NUM_ ) throw new File System Exception ( null , null , STR_ ) ; char [ ] name = new char [ name Length In Bytes / NUM_ ] ; unsafe . copy Memory ( null , buffer . address ( ) + OFFSETOF PATHBUFFER + name Offset , name , Unsafe . ARRAY CHAR BASE OFFSET , name Length In Bytes ) ; String target = strip Prefix ( new String ( name ) ) ; if ( target . length ( ) == NUM_ ) { throw new IO Exception ( STR_ ) ; } return target ; } finally { buffer . release ( ) ; } }
public static Photo match URL ( String url , String text ) { Matcher m = URL PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return new Photo ( m . group ( NUM_ ) , m . group ( NUM_ ) , m . group ( NUM_ ) , text ) ; } else { return null ; } }
public double exact Area ( ) { S 2 Point v 0 = get Vertex ( NUM_ ) ; S 2 Point v 1 = get Vertex ( NUM_ ) ; S 2 Point v 2 = get Vertex ( NUM_ ) ; S 2 Point v 3 = get Vertex ( NUM_ ) ; return S 2 . area ( v 0 , v 1 , v 2 ) + S 2 . area ( v 0 , v 2 , v 3 ) ; }
public String global Info ( ) { return STR_ + STR_ ; }
public long free Memory ( ) { return free Memory Impl ( ) ; }
public int add Taxon ( Taxon taxon ) { int index = get Taxon Index ( taxon ) ; if ( index == - NUM_ ) { taxa . add ( taxon ) ; fire Taxon Added ( taxon ) ; index = taxa . size ( ) - NUM_ ; } return index ; }
public Name append ( Name n ) { int len = get Byte Length ( ) ; byte [ ] bs = new byte [ len + n . get Byte Length ( ) ] ; get Bytes ( bs , NUM_ ) ; n . get Bytes ( bs , len ) ; return table . from Utf ( bs , NUM_ , bs . length ) ; }
public static Request Security Token Response parse XML ( Input Stream is ) throws WS Federation Exception { Document doc = XML Utils . to DOM Document ( is , debug ) ; Element root = doc . get Document Element ( ) ; return new Request Security Token Response ( root ) ; }
public long round Trip Time ( ) throws Interrupted Exception { latch . await ( ) ; return received - sent ; }
private List do Get Document Setup Participants ( I Content Type [ ] content Types ) { Set result Set = new Hash Set ( ) ; int i = NUM_ ; while ( i < content Types . length ) { Set set = ( Set ) f Setup Participant Descriptors . get ( new Content Type Adapter ( content Types [ i ++ ] ) ) ; if ( set != null ) result Set . add All ( set ) ; } List participants = new Array List ( ) ; Iterator e = result Set . iterator ( ) ; while ( e . has Next ( ) ) { I Configuration Element entry = ( I Configuration Element ) e . next ( ) ; Object participant = get Extension ( entry , f Setup Participants , I Document Setup Participant . class ) ; if ( participant != null ) participants . add ( participant ) ; } return participants . is Empty ( ) ? null : participants ; }
public static double tan ( double radians ) { return Math . tan ( radians ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public static List < Web Element > find Elements Present After ( Search Context parent , By by , int wait In Seconds ) { Preconditions . check Not Null ( parent ) ; Preconditions . check Not Null ( by ) ; find Element Present After ( parent , by , wait In Seconds ) ; return parent . find Elements ( by ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
private static int starts With Lenient ( String s , String match , int min Chars , boolean accept Trailing ) { if ( s . char At ( NUM_ ) != match . char At ( NUM_ ) ) { return - NUM_ ; } if ( min Chars == - NUM_ ) { min Chars = match . length ( ) ; } int s Sz = s . length ( ) ; if ( s Sz < min Chars ) { return - NUM_ ; } int m Sz = match . length ( ) ; int s Ix = NUM_ ; for ( int m Ix = NUM_ ; m Ix < m Sz ; s Ix ++ , m Ix ++ ) { while ( s Ix < s Sz && ( s . char At ( s Ix ) == STR_ || s . char At ( s Ix ) == STR_ ) ) { s Ix ++ ; } if ( s Ix >= s Sz || s . char At ( s Ix ) != match . char At ( m Ix ) ) { return m Ix >= min Chars && ( accept Trailing || s Ix >= s Sz ) && ( s Ix >= s Sz || s . char At ( s Ix - NUM_ ) == STR_ ) ? s Ix : - NUM_ ; } } return s Ix >= s Sz || accept Trailing || s . char At ( s Ix ) == STR_ ? s Ix : - NUM_ ; }
public Percentiles percentiles ( Constant Range range ) { Sorted Set < Constant > sorted = values ( ) ; Sorted Set < Constant > contained = new Tree Set < Constant > ( ) ; Constant prev = null ; for ( Constant pct : sorted ) { if ( range . contains ( pct ) ) { contained . add ( pct ) ; } else if ( contained . is Empty ( ) ) prev = pct ; } if ( contained . is Empty ( ) ) return null ; double prev Percent = prev == null ? NUM_ : pcts . get ( prev ) ; double total Percent = pcts . get ( contained . last ( ) ) - prev Percent ; Map < Constant , Double > new Pcts = new Hash Map < Constant , Double > ( ) ; for ( Constant p : contained ) new Pcts . put ( p , ( pcts . get ( p ) - prev Percent ) / total Percent ) ; return new Percentiles ( new Pcts ) ; }
public boolean is Infinite ( ) { return ! is Na N ( ) && ( Double . is Infinite ( x . get Real ( ) ) || Double . is Infinite ( y . get Real ( ) ) || Double . is Infinite ( z . get Real ( ) ) ) ; }
public Class Node redirect ( ) { if ( redirect == null ) return this ; return redirect . redirect ( ) ; }
public boolean is Debug On ( ) { return ( environment . get ( CLI Constants . ARGUMENT DEBUG ) != null ) ; }
private static boolean determine Unaligned ( ) { try { Class c = Class . for Name ( STR_ ) ; Method m = c . get Declared Method ( STR_ ) ; m . set Accessible ( true ) ; return ( boolean ) m . invoke ( null ) ; } catch ( Class Not Found Exception | No Such Method Exception | Security Exception | Illegal Access Exception | Illegal Argument Exception | Invocation Target Exception e ) { return false ; } }
boolean rhs Equal To Field ( ) { return rhs != null && member Name . equals ( rhs . get Qualified Name ( ) ) ; }
public static boolean is Whitespace ( char c ) { return ! Reg Exp Utils . reset And Test ( regexp Not Whitespace , String . value Of ( c ) ) ; }
public static boolean closer ( long v , long prev , long next ) { return Math . abs ( v - prev ) <= Math . abs ( v - next ) ; }
public int length ( ) { return N Gram Histogram . size ( ) ; }
public Date next Date In Range ( Date start , Date end ) { return new Date ( next Long In Range ( start . get Time ( ) , end . get Time ( ) ) ) ; }
@ Override public boolean is Modified ( ) { if ( dependency List . is Modified ( ) ) { return true ; } synchronized ( path List ) { new Path List . clear ( ) ; load Paths ( new Path List ) ; Collections . sort ( new Path List ) ; return ! new Path List . equals ( path List ) ; } }
public static < T > List < T > intersection ( final Collection < T > c 1 , final Collection < T > c 2 ) { if ( c 1 == null || c 2 == null ) { return new Array List < > ( ) ; } if ( c 1 . size ( ) == NUM_ || c 2 . size ( ) == NUM_ ) { return new Array List < > ( ) ; } final List < T > intersection = new Array List < > ( ) ; for ( final T current : c 1 ) { if ( c 2 . contains ( current ) ) { intersection . add ( current ) ; } } return intersection ; }
public static boolean is Non Missing Gt ( String gt ) { final int gtlen = gt . length ( ) ; for ( int i = NUM_ ; i < gtlen ; i ++ ) { final char c = gt . char At ( i ) ; switch ( c ) { case PHASED SEPARATOR : case UNPHASED SEPARATOR : case MISSING VALUE : continue ; default : return true ; } } return false ; }
public final static boolean is Java File Name ( String name ) { int name Length = name == null ? NUM_ : name . length ( ) ; int suffix Length = SUFFIX JAVA . length ; if ( name Length < suffix Length ) return false ; for ( int i = NUM_ ; i < suffix Length ; i ++ ) { char c = name . char At ( name Length - i - NUM_ ) ; int suffix Index = suffix Length - i - NUM_ ; if ( c != SUFFIX java [ suffix Index ] && c != SUFFIX JAVA [ suffix Index ] ) return false ; } return true ; }
public static boolean is Name Registration Success ( Http Servlet Request request ) { String status = request . get Parameter ( IFS Constants . REGISTRATION STATUS ) ; if ( status != null && status . equals Ignore Case ( IFS Constants . REGISTRATION SUCCESS ) ) { return true ; } else { return false ; } }
public Iterator < Detector Ordering Constraint > inter Pass Constraint Iterator ( ) { return inter Pass Constraint List . iterator ( ) ; }
public static boolean is Class Available ( String class Name ) { boolean result = false ; try { Class . for Name ( class Name ) ; result = true ; } catch ( Class Not Found Exception ex ) { } return result ; }
public boolean is Primary ( ) { return is Primary ; }
public final Population next Generation ( ) { calculate Cumulative Relative Fitnesses ( ) ; int pop Size = population . size ( ) ; List < Genome > next Population = new Array List < Genome > ( ) ; for ( int i = NUM_ ; i < pop Size ; i ++ ) { Genome parent = population . get ( pick Parent ( ) ) ; next Population . add ( parent . replicate ( mutator , fitness Function ) ) ; } Population p = new Population ( next Population , mutator , fitness Function ) ; return p ; }
public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; return new Vector . elements ( ) ; }
public static String hash ( String p ) { String str = null ; try { byte [ ] bb = p . get Bytes ( ) ; str = Salted SHA 512 Password Storage Scheme . encode Offline ( bb ) ; } catch ( Exception ex ) { Debug debug = Debug . get Instance ( Setup Constants . DEBUG NAME ) ; debug . error ( STR_ + ex ) ; } return str ; }
public boolean is Major Grid X ( ) { return major Grid X ; }
private final String curr Path Name ( ) { int ft = settings . get Int ( STR_ , FT NONE ) ; switch ( ft ) { case FT PGN : { String ret = settings . get String ( STR_ , STR_ ) ; String sep = File . separator ; if ( ! ret . contains ( sep ) ) ret = Environment . get External Storage Directory ( ) + sep + pgn Dir + sep + ret ; return ret ; } case FT SCID : return settings . get String ( STR_ , STR_ ) ; case FT FEN : return settings . get String ( STR_ , STR_ ) ; default : return STR_ ; } }
public boolean equals ( Object obj ) { if ( obj == this ) { return true ; } if ( obj instanceof Annotation Member ) { Annotation Member that = ( Annotation Member ) obj ; if ( name . equals ( that . name ) && tag == that . tag ) { if ( tag == ARRAY ) { return equal Array Value ( that . value ) ; } else if ( tag == ERROR ) { return false ; } else { return value . equals ( that . value ) ; } } } return false ; }
@ Override public synchronized void flush ( ) throws IO Exception { logger . log ( Level . FINE , STR_ ) ; long start = System . current Time Millis ( ) ; final Object ack Notify = pseudo Tcp . get Ack Notify ( ) ; synchronized ( ack Notify ) { while ( pseudo Tcp . get Bytes Buffered Not Sent ( ) > NUM_ ) { try { if ( write Timeout > NUM_ ) { long elapsed = System . current Time Millis ( ) - start ; long left = write Timeout - elapsed ; if ( left <= NUM_ ) { IO Exception e = new IO Exception ( STR_ ) ; pseudo Tcp . closedown ( e ) ; throw e ; } ack Notify . wait ( left ) ; } else { ack Notify . wait ( ) ; } } catch ( Interrupted Exception ex ) { throw new IO Exception ( STR_ , ex ) ; } } } logger . log ( Level . FINE , STR_ ) ; }
public static final String trim Front ( String str ) { int position = NUM_ ; while ( ( position < str . length ( ) ) && Character . is Whitespace ( str . char At ( position ) ) ) { position ++ ; } return str . substring ( position , str . length ( ) ) ; }
public String extract package ( String fullname ) { return fullname . replace First ( STR_ , STR_ ) ; }
public static String now Date String ( String format ) { Simple Date Format df = new Simple Date Format ( format ) ; return df . format ( new Date ( ) ) ; }
public S 2 Cap complement ( ) { double c Height = is Full ( ) ? - NUM_ : NUM_ - Math . max ( height , NUM_ ) ; return S 2 Cap . from Axis Height ( S 2 Point . neg ( axis ) , c Height ) ; }
boolean is Ready ( ) { return this . state == READY ; }
public static Vector 2 rand ( ) { return new Vector 2 ( Math . random ( ) , Math . random ( ) ) ; }
public boolean is Preferred Connection ( String identifier ) { return preferred Connections . contains ( identifier ) ; }
private void await Control Op ( ) { if ( control Waiters . size ( ) > NUM_ || control Operation Executing . get ( ) ) { eval Waiters . add ( Thread . current Thread ( ) ) ; Lock Support . park ( this ) ; } }
public String build Java Version ( ) { return properties . get Property ( STR_ ) ; }
public static String join ( String separator , List < ? > elements ) { if ( elements == null || elements . size ( ) == NUM_ ) { return STR_ ; } String Builder sb = new String Builder ( elements . size ( ) * NUM_ ) ; int i = NUM_ ; for ( Object elem : elements ) { if ( separator . length ( ) > NUM_ && i ++ > NUM_ ) { sb . append ( separator ) ; } sb . append ( format ( elem ) ) ; } return sb . to String ( ) ; }
public static long distance ( double latitude 1 , double longitude 1 , double latitude 2 , double longitude 2 ) { double latitude Sin = Math . sin ( Math . to Radians ( latitude 2 - latitude 1 ) / NUM_ ) ; double longitude Sin = Math . sin ( Math . to Radians ( longitude 2 - longitude 1 ) / NUM_ ) ; double a = latitude Sin * latitude Sin + Math . cos ( Math . to Radians ( latitude 1 ) ) * Math . cos ( Math . to Radians ( latitude 2 ) ) * longitude Sin * longitude Sin ; double c = NUM_ * Math Util . atan 2 ( Math . sqrt ( a ) , Math . sqrt ( NUM_ - a ) ) ; return ( long ) ( NUM_ * c ) ; }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( true ) ; if ( Build Config . DEBUG ) { Log . d ( TAG , STR_ + data ) ; } } else { return false ; } } return true ; }
public static void in Range ( final int value , final String name , final int min Inclusive , final int max Inclusive ) { in Range ( ( long ) value , name , min Inclusive , max Inclusive ) ; }
public String to XML ( ) { String Builder sb = new String Builder ( ) ; Iterator iter = resource Results . iterator ( ) ; while ( iter . has Next ( ) ) { Resource Result rr = ( Resource Result ) iter . next ( ) ; sb . append ( rr . to XML ( ) ) ; } return sb . to String ( ) ; }
public boolean has Update Listeners ( ) { boolean is Empty = ! listeners . is Empty ( ) ; return is Empty ; }
@ Override public boolean fire ( final Player player , final Sentence sentence , final Entity npc ) { final String temp = player . get Quest ( quest Slot , quest Index ) ; if ( temp == null ) { return false ; } final List < String > tokens = Arrays . as List ( temp . split ( STR_ ) ) ; if ( ( tokens . size ( ) % NUM_ ) != NUM_ ) { logger . error ( STR_ + player . get Name ( ) + STR_ + quest Slot + STR_ + player . get Quest ( quest Slot ) + STR_ ) ; return false ; } for ( int i = NUM_ ; i < tokens . size ( ) / NUM_ ; i ++ ) { final String creature Name = tokens . get ( i * NUM_ ) ; int to Kill Solo ; int to Kill Shared ; int killed Solo ; int killed Shared ; try { to Kill Solo = Integer . parse Int ( tokens . get ( i * NUM_ + NUM_ ) ) ; to Kill Shared = Integer . parse Int ( tokens . get ( i * NUM_ + NUM_ ) ) ; killed Solo = Integer . parse Int ( tokens . get ( i * NUM_ + NUM_ ) ) ; killed Shared = Integer . parse Int ( tokens . get ( i * NUM_ + NUM_ ) ) ; } catch ( Number Format Exception npe ) { logger . error ( STR_ + quest Slot + STR_ + player . get Name ( ) + STR_ + i * NUM_ ) ; return false ; } final int diff Solo = player . get Solo Kill ( creature Name ) - killed Solo - to Kill Solo ; final int diff Shared = player . get Shared Kill ( creature Name ) - killed Shared - to Kill Shared ; if ( diff Solo < NUM_ ) { return false ; } if ( ( diff Solo + diff Shared ) < NUM_ ) { return false ; } } return true ; }
static boolean using Ocean ( ) { return ( get Current Theme ( ) instanceof Ocean Theme ) ; }
private int extend ( final int required ) { final int capacity = Math . max ( required , capacity ( ) * NUM_ ) ; if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + capacity + STR_ ) ; return capacity ; }
private byte [ ] first Element ( ) throws Keeper Exception , Interrupted Exception { while ( true ) { String first Child = first Child ( false ) ; if ( first Child == null ) { return null ; } try { return zookeeper . get Data ( dir + STR_ + first Child , null , null , true ) ; } catch ( Keeper Exception . No Node Exception e ) { update Lock . lock Interruptibly ( ) ; try { known Children . remove ( first Child ) ; } finally { update Lock . unlock ( ) ; } } } }
private static void assert Files Exist ( final List < File > expected Files ) { final List < File > missing Files = new Array List < File > ( ) ; for ( final File file : expected Files ) { if ( file == null ) { throw new Runtime Exception ( STR_ ) ; } if ( ! file . exists ( ) ) { missing Files . add ( file ) ; } } if ( ! missing Files . is Empty ( ) ) { List < String > missing Absolute Filenames = new Array List < String > ( missing Files . size ( ) ) ; for ( File missing File : missing Files ) { missing Absolute Filenames . add ( missing File . get Absolute Path ( ) ) ; } throw new Runtime Exception ( STR_ + Plugin Util . join ( STR_ , missing Absolute Filenames ) ) ; } }
@ Override public boolean is Allowed To Transfer File ( Contact Id contact ) throws Remote Exception { if ( contact == null ) { throw new Server Api Illegal Argument Exception ( STR_ ) ; } try { Capabilities remote Capabilities = m Contact Manager . get Contact Capabilities ( contact ) ; if ( remote Capabilities == null ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STR_ + contact + STR_ ) ; } return false ; } File Transfer Protocol protocol = get File Transfer Protocol For One To One File Transfer ( contact ) ; if ( protocol == null ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STR_ ) ; } return false ; } Messaging Mode mode = m Rcs Settings . get Messaging Mode ( ) ; switch ( mode ) { case INTEGRATED : case SEAMLESS : if ( ( File Transfer Protocol . MSRP == protocol && m Rcs Settings . is Ft Always On ( ) ) || ( File Transfer Protocol . HTTP == protocol && m Rcs Settings . is Ft Http Cap Always On ( ) ) ) { break ; } if ( ! m Im Service . is Capabilities Valid ( remote Capabilities ) ) { if ( s Logger . is Activated ( ) ) { s Logger . debug ( STR_ + contact + STR_ ) ; } return false ; } break ; default : break ; } return true ; } catch ( Server Api Base Exception e ) { if ( ! e . should Not Be Logged ( ) ) { s Logger . error ( Exception Util . get Full Stack Trace ( e ) ) ; } throw e ; } catch ( Exception e ) { s Logger . error ( Exception Util . get Full Stack Trace ( e ) ) ; throw new Server Api Generic Exception ( e ) ; } }
public boolean is Claimed ( int row , int col ) { return effect Claims . contains Key ( get Key For Coords ( row , col ) ) ; }
@ Override public int hash Code ( ) { int result = NUM_ ; long temp = Double . double To Long Bits ( this . x ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . y ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; return result ; }
@ Override public String [ ] start Symbols ( ) { return start Symbols ; }
public boolean is Rec Or Arg For API Call ( I Alloc Node an ) { return api Call Nodes . contains ( an ) ; }
public State is Watching ( ) { lock . lock ( ) ; try { if ( hash To Keys . is Empty ( ) ) return State . EMPTY ; return is Watching ? State . WATCHING : State . REGULAR ; } finally { lock . unlock ( ) ; } }
public int hash Code ( ) { return attr Type . hash Code ( ) ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( ! ( obj instanceof Ndef Record ) ) return false ; Ndef Record other = ( Ndef Record ) obj ; if ( ! Arrays . equals ( m Id , other . get Id ( ) ) ) return false ; if ( ! Arrays . equals ( m Payload , other . get Payload ( ) ) ) return false ; if ( m Tnf != other . get Tnf ( ) ) return false ; return Arrays . equals ( m Type , other . get Type ( ) ) ; }
public Shape create Arrow Right ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . move To ( x , y ) ; path . line To ( x + w , y + h / NUM_ ) ; path . line To ( x , y + h ) ; path . close Path ( ) ; return path ; }
public int byte Size ( ) { if ( text == null ) { return NUM_ ; } return NUM_ + text . length ( ) ; }
public boolean has Next Word ( ) { int index = remaining . index Of ( STR_ ) ; return has Next ( ) && index < remaining . length ( ) - NUM_ ; }
protected long generate Zeta ( double ro , double pk , Random Engine random Generator ) { double u , v , e , x ; long k ; if ( ro != ro prev || pk != pk prev ) { ro prev = ro ; pk prev = pk ; if ( ro < pk ) { c = pk - NUM_ ; d = NUM_ ; } else { c = ro - NUM_ ; d = ( NUM_ + ro ) * Math . log ( ( NUM_ + pk ) / ( NUM_ + ro ) ) ; } } do { do { u = random Generator . raw ( ) ; v = random Generator . raw ( ) ; x = ( c + NUM_ ) * Math . exp ( - Math . log ( u ) / ro ) - c ; } while ( x <= NUM_ || x >= maxlongint ) ; k = ( int ) ( x + NUM_ ) ; e = - Math . log ( v ) ; } while ( e < ( NUM_ + ro ) * Math . log ( ( k + pk ) / ( x + c ) ) - d ) ; return k ; }
public void request Password History ( ) { operations . add ( Password Policy State Operation Type . GET PASSWORD HISTORY ) ; }
public static double ln Gamma ( double x ) { double p , q , w , z ; double A [ ] = { NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ } ; double B [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; double C [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; if ( x < - NUM_ ) { q = - x ; w = ln Gamma ( q ) ; p = Math . floor ( q ) ; if ( p == q ) throw new Arithmetic Exception ( STR_ ) ; z = q - p ; if ( z > NUM_ ) { p += NUM_ ; z = p - q ; } z = q * Math . sin ( Math . PI * z ) ; if ( z == NUM_ ) throw new Arithmetic Exception ( STR_ ) ; z = LOGPI - Math . log ( z ) - w ; return z ; } if ( x < NUM_ ) { z = NUM_ ; while ( x >= NUM_ ) { x -= NUM_ ; z *= x ; } while ( x < NUM_ ) { if ( x == NUM_ ) throw new Arithmetic Exception ( STR_ ) ; z /= x ; x += NUM_ ; } if ( z < NUM_ ) z = - z ; if ( x == NUM_ ) return Math . log ( z ) ; x -= NUM_ ; p = x * polevl ( x , B , NUM_ ) / p 1 evl ( x , C , NUM_ ) ; return ( Math . log ( z ) + p ) ; } if ( x > NUM_ ) throw new Arithmetic Exception ( STR_ ) ; q = ( x - NUM_ ) * Math . log ( x ) - x + NUM_ ; if ( x > NUM_ ) return ( q ) ; p = NUM_ / ( x * x ) ; if ( x >= NUM_ ) q += ( ( NUM_ * p - NUM_ ) * p + NUM_ ) / x ; else q += polevl ( p , A , NUM_ ) / x ; return q ; }
public final Vector 2 [ ] to Array ( ) { Vector 2 [ ] points = new Vector 2 [ this . size ] ; Linked Vertex vertex = this . root ; for ( int i = NUM_ ; i < this . size ; i ++ ) { points [ i ] = vertex . point ; vertex = vertex . next ; } return points ; }
public boolean is Ssl Rmi Registry ( ) { if ( ! is Vm Connector ( ) ) { throw new Unsupported Operation Exception ( STR_ + STR_ ) ; } return ssl Registry ; }
protected static Network Topology Discovery new Network Topology Discovery ( ) { Network Topology Discovery instance = null ; Class Delegate delegate = database Class Delegate . get ( ) ; if ( delegate != null ) { instance = delegate . new Network Topology Discovery ( ) ; } return ( instance != null ? instance : new Network Topology Discovery Impl ( ) ) ; }
public static boolean is Attachment ( String content Disposition ) { return content Disposition != null && content Disposition . region Matches ( true , NUM_ , STR_ , NUM_ , NUM_ ) ; }
public Set < Type > used Types ( ) { Set < Type > types = new Hash Set < Type > ( ) ; for ( Dexlib Abstract Instruction i : instructions ) types . add All ( i . introduced Types ( ) ) ; if ( tries != null ) { for ( Try Block < ? extends Exception Handler > try Item : tries ) { List < ? extends Exception Handler > h List = try Item . get Exception Handlers ( ) ; for ( Exception Handler handler : h List ) { String ex Type = handler . get Exception Type ( ) ; if ( ex Type == null ) continue ; types . add ( Dex Type . to Soot ( ex Type ) ) ; } } } return types ; }
public boolean is Show Thunk Functions ( ) { return m thunk Function Checkbox . is Selected ( ) ; }
private static Entry [ ] delete ( Entry [ ] attrs , int i ) { int len = attrs . length - NUM_ ; Entry [ ] nattrs = new Entry [ len ] ; System . arraycopy ( attrs , NUM_ , nattrs , NUM_ , i ) ; System . arraycopy ( attrs , i + NUM_ , nattrs , i , len - i ) ; return nattrs ; }
Name And Type name Type ( Symbol sym ) { return new Name And Type ( field Name ( sym ) , retrofit ? sym . erasure ( types ) : sym . external Type ( types ) , types ) ; }
public static boolean is Security Manager Enabled ( ) { return System . get Security Manager ( ) != null ; }
private boolean is Compatible ( String guacamole Version ) { return ALLOWED GUACAMOLE VERSIONS . contains ( guacamole Version ) ; }
public static Number atanh ( Number a ) { return Fast Math . atanh ( a . double Value ( ) ) ; }
public static String slurp Reader ( Reader reader ) { Buffered Reader r = new Buffered Reader ( reader ) ; String Builder buff = new String Builder ( ) ; try { char [ ] chars = new char [ SLURPBUFFSIZE ] ; while ( true ) { int amount Read = r . read ( chars , NUM_ , SLURPBUFFSIZE ) ; if ( amount Read < NUM_ ) { break ; } buff . append ( chars , NUM_ , amount Read ) ; } r . close ( ) ; } catch ( Exception e ) { throw new Runtime Exception ( ) ; } return buff . to String ( ) ; }
@ Override public Object clone ( ) throws Clone Not Supported Exception { XY Shape Renderer clone = ( XY Shape Renderer ) super . clone ( ) ; if ( this . paint Scale instanceof Public Cloneable ) { Public Cloneable pc = ( Public Cloneable ) this . paint Scale ; clone . paint Scale = ( Paint Scale ) pc . clone ( ) ; } return clone ; }
public static Test suite ( ) { return new Test Suite ( Merge Nominal Values Test . class ) ; }
public static DB Handler acquire DB ( ) throws GB Exception { try { if ( db Lock . try Lock ( NUM_ , Time Unit . SECONDS ) ) { return lock Handler ; } } catch ( Interrupted Exception ex ) { Log . i ( TAG , STR_ ) ; } throw new GB Exception ( STR_ ) ; }
public boolean is Paused ( ) { return this . is Paused ; }
private boolean contains Mapping ( Object key , Object value ) { if ( key == null ) { Hash Map Entry < K , V > e = entry For Null Key ; return e != null && Objects . equals ( value , e . value ) ; } int hash = secondary Hash ( key ) ; Hash Map Entry < K , V > [ ] tab = table ; int index = hash & ( tab . length - NUM_ ) ; for ( Hash Map Entry < K , V > e = tab [ index ] ; e != null ; e = e . next ) { if ( e . hash == hash && key . equals ( e . key ) ) { return Objects . equals ( value , e . value ) ; } } return false ; }
@ Visible For Testing public static boolean is Text File ( @ Non Null File file ) { String name = file . get Name ( ) ; return name . ends With ( DOT JAVA ) || name . ends With ( DOT XML ) || name . ends With ( DOT AIDL ) || name . ends With ( DOT FS ) || name . ends With ( DOT RS ) || name . ends With ( DOT RSH ) || name . ends With ( DOT RSH ) || name . ends With ( DOT TXT ) || name . ends With ( DOT GRADLE ) || name . ends With ( DOT PROPERTIES ) || name . ends With ( STR_ ) || name . ends With ( STR_ ) || name . ends With ( STR_ ) || name . ends With ( STR_ ) || name . ends With ( STR_ ) ; }
public Object 2 Double Open Hash Map < int [ ] > support Map ( int support Threshold ) { List < Item Set > item Sets = learn ( ) ; Object 2 Double Open Hash Map < int [ ] > support Map = new Object 2 Double Open Hash Map < > ( item Sets . size ( ) ) ; for ( Item Set item Set : item Sets ) { if ( item Set . support >= support Threshold ) { support Map . put ( item Set . items , item Set . support ) ; } } return support Map ; }
private void send Error ( String status , String msg ) throws Interrupted Exception { send Response ( status , MIME PLAINTEXT , null , new Byte Array Input Stream ( msg . get Bytes ( ) ) ) ; throw new Interrupted Exception ( ) ; }
@ Override public int hash Code ( ) { int code = super . hash Code ( ) ; if ( e Condition != null ) { code += e Condition . hash Code ( ) ; } if ( p Condition Name != null ) { code += p Condition Name . hash Code ( ) ; } return code ; }
protected synchronized void on Send Rejected ( Record Buffer < R > buffer ) { logger . trace ( STR_ , name ( ) , buffer ) ; total Rejected Send Tasks . increment And Get ( ) ; throttler . on Send Rejected ( ) ; queue Buffer For Retry ( buffer ) ; }
static List < Hue > random Hues ( int n ) { List < Hue > result List = new Array List < > ( n ) ; int hues Available = Hue . values ( ) . length - NUM_ ; int max Distance = hues Available / n ; Random random = new Random ( ) ; int starting = random . next Int ( hues Available ) ; List < Hue > hues = new Array List < > ( hues Available ) ; for ( int i = starting ; i < hues Available ; i ++ ) { if ( Hue . values ( ) [ i ] != Hue . Neutral ) { hues . add ( Hue . values ( ) [ i ] ) ; } } for ( int i = NUM_ ; i < starting ; i ++ ) { if ( Hue . values ( ) [ i ] != Hue . Neutral ) { hues . add ( Hue . values ( ) [ i ] ) ; } } for ( int j = NUM_ ; j < hues Available && result List . size ( ) < n ; j = j + max Distance ) { result List . add ( hues . get ( j ) ) ; } return result List ; }
private static Reserve Response check Reserve Response ( Reserve Response reserve Response ) throws Rpc Exception { logger . info ( STR_ , reserve Response ) ; switch ( reserve Response . get Result ( ) ) { case OK : break ; case STALE GENERATION : logger . warn ( STR_ , reserve Response . get Error ( ) ) ; throw new Stale Generation Exception ( reserve Response . get Error ( ) ) ; case SYSTEM ERROR : logger . warn ( STR_ , reserve Response . get Error ( ) ) ; throw new System Error Exception ( reserve Response . get Error ( ) ) ; default : throw new Rpc Exception ( String . format ( STR_ , reserve Response . get Result ( ) ) ) ; } return reserve Response ; }
public int port ( Properties props ) { return Integer . parse Int ( props . get Property ( PORT PROPERTY KEY , STR_ ) ) ; }
public Repl DBMS Event peek ( ) { return serial Queue . peek ( ) ; }
public Name compose Name ( Name name , Name prefix ) throws Naming Exception { check Is Destroyed ( ) ; Name parsed Prefix = get Parsed Name ( ( Name ) prefix . clone ( ) ) ; Name parsed Name = get Parsed Name ( name ) ; return parsed Prefix . add All ( parsed Name ) ; }
public int debugger Count ( ) { return debuggers . size ( ) ; }
public Collection < T Field Id Enum > exception Fields ( ) { return exception Fields . values ( ) ; }
public static Option List create Option List ( Map map , Locale locale ) { Option List option List = new Option List ( ) ; if ( ( map != null ) && ! map . is Empty ( ) ) { Map reverse Map = AM Format Utils . reverse String Map ( map ) ; List list = AM Format Utils . sort Key In Map ( reverse Map , locale ) ; for ( Iterator iter = list . iterator ( ) ; iter . has Next ( ) ; ) { String label = ( String ) iter . next ( ) ; option List . add ( label , ( String ) reverse Map . get ( label ) ) ; } } return option List ; }
private Rect strip Whitespace ( Buffered Image source ) { Writable Raster alpha Raster = source . get Alpha Raster ( ) ; if ( alpha Raster == null || ( ! settings . strip Whitespace X && ! settings . strip Whitespace Y ) ) return new Rect ( source , NUM_ , NUM_ , source . get Width ( ) , source . get Height ( ) , false ) ; final byte [ ] a = new byte [ NUM_ ] ; int top = NUM_ ; int bottom = source . get Height ( ) ; if ( settings . strip Whitespace X ) { outer : for ( int y = NUM_ ; y < source . get Height ( ) ; y ++ ) { for ( int x = NUM_ ; x < source . get Width ( ) ; x ++ ) { alpha Raster . get Data Elements ( x , y , a ) ; int alpha = a [ NUM_ ] ; if ( alpha < NUM_ ) alpha += NUM_ ; if ( alpha > settings . alpha Threshold ) break outer ; } top ++ ; } outer : for ( int y = source . get Height ( ) ; -- y >= top ; ) { for ( int x = NUM_ ; x < source . get Width ( ) ; x ++ ) { alpha Raster . get Data Elements ( x , y , a ) ; int alpha = a [ NUM_ ] ; if ( alpha < NUM_ ) alpha += NUM_ ; if ( alpha > settings . alpha Threshold ) break outer ; } bottom -- ; } } int left = NUM_ ; int right = source . get Width ( ) ; if ( settings . strip Whitespace Y ) { outer : for ( int x = NUM_ ; x < source . get Width ( ) ; x ++ ) { for ( int y = top ; y < bottom ; y ++ ) { alpha Raster . get Data Elements ( x , y , a ) ; int alpha = a [ NUM_ ] ; if ( alpha < NUM_ ) alpha += NUM_ ; if ( alpha > settings . alpha Threshold ) break outer ; } left ++ ; } outer : for ( int x = source . get Width ( ) ; -- x >= left ; ) { for ( int y = top ; y < bottom ; y ++ ) { alpha Raster . get Data Elements ( x , y , a ) ; int alpha = a [ NUM_ ] ; if ( alpha < NUM_ ) alpha += NUM_ ; if ( alpha > settings . alpha Threshold ) break outer ; } right -- ; } } int new Width = right - left ; int new Height = bottom - top ; if ( new Width <= NUM_ || new Height <= NUM_ ) { if ( settings . ignore Blank Images ) return null ; else return new Rect ( empty Image , NUM_ , NUM_ , NUM_ , NUM_ , false ) ; } return new Rect ( source , left , top , new Width , new Height , false ) ; }
public List < T > sub List ( int begin Idx , int upto Length ) { return elements . sub List ( begin Idx , upto Length ) ; }
public static boolean is Agree ( Feature Structure a Merge Fs , Map < String , List < Feature Structure > > a Annos Per User ) { for ( String usr : a Annos Per User . key Set ( ) ) { boolean agree = false ; for ( Feature Structure usr Fs : a Annos Per User . get ( usr ) ) { if ( is Same Anno ( a Merge Fs , usr Fs ) ) { if ( ! agree ) { agree = true ; } else if ( agree ) { return false ; } } } if ( ! agree ) { return false ; } } return true ; }
public static int thread Init Level Requirement ( ) { Integer init Level = ( Integer ) initialization Thread . get ( ) ; if ( init Level == null ) { return AFTER INITIAL IMAGE ; } return init Level . int Value ( ) ; }
private boolean can Pluralize ( String type Name ) { return ! type Name . ends With ( PLURAL S ) ; }
public double norm 1 ( ) { double s = NUM_ ; for ( int i = NUM_ ; i < size ( ) ; i ++ ) { s += Math . abs ( V [ i ] ) ; } return s ; }
public boolean has Forward ( ) { if ( index + NUM_ < history . size ( ) && index >= NUM_ ) { return true ; } else { return false ; } }
public static String format Date ( Date date ) { String format String = STR_ ; Calendar cal = Calendar . get Instance ( ) ; cal . set Time ( date ) ; if ( cal . is Set ( Calendar . MINUTE ) ) format String = STR_ ; else format String = STR_ ; Simple Date Format formatter = new Simple Date Format ( format String ) ; return formatter . format ( date ) ; }
public static double bernoullis ( double n , double k , double success Prob ) { double combo = Math Utils . combination ( n , k ) ; double q = NUM_ - success Prob ; return combo * Math . pow ( success Prob , k ) * Math . pow ( q , n - k ) ; }
protected boolean is Side Channel Active ( ) { return System . getenv ( SIDECHANNEL AUTH ENV NAME ) != null ; }
public boolean is Mbean Support ( ) { return mbean Support . get ( ) ; }
private static boolean is Ancestor ( Class Loader first , Class Loader second ) { Class Loader acl = first ; do { acl = acl . get Parent ( ) ; if ( second == acl ) { return true ; } } while ( acl != null ) ; return false ; }
public Collection < I Game Move > valid Moves ( I Player ip , I Game State state ) { Player player = ( Player ) ip ; Array List < I Game Move > valids = new Array List < I Game Move > ( ) ; if ( state . is Win ( ) ) { return valids ; } if ( state . is Draw ( ) ) { return valids ; } Tic Tac Toe State game State = ( Tic Tac Toe State ) state ; Tic Tac Toe Board board = game State . board ( ) ; for ( int c = NUM_ ; c < board . num Columns ( ) ; c ++ ) { for ( int r = NUM_ ; r < board . num Rows ( ) ; r ++ ) { Move move = interpret Move ( state , c , r , player ) ; if ( move != null ) { valids . add ( move ) ; } } } return valids ; }
private static Entry new Entry ( Byte Buffer buffer , int entry Length , boolean is Leaf ) throws IO Exception { if ( is Leaf ) { return new Entry ( buffer , entry Length ) ; } return new Node Entry ( buffer , entry Length ) ; }
private static Object invoke Or Die ( final Method method , final Object object , final Object ... params ) { try { return method . invoke ( object , params ) ; } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( STR_ + STR_ , e ) ; } catch ( Invocation Target Exception e ) { final Throwable cause = e . get Cause ( ) ; if ( cause instanceof Runtime Exception ) { throw ( Runtime Exception ) cause ; } else if ( cause instanceof Error ) { throw ( Error ) cause ; } else { throw new Runtime Exception ( STR_ , cause ) ; } } }
private boolean is Valid Cell ( Grid Pos cell ) { if ( cell . col < NUM_ || cell . col >= columns . size ( ) ) return false ; if ( cell . row < NUM_ || cell . row >= get Item Count ( ) ) { return false ; } return true ; }
@ Override public int hash Code ( ) { return transition . hash Code ( ) ^ offset Before . hash Code ( ) ^ Integer . rotate Left ( offset After . hash Code ( ) , NUM_ ) ; }
public static Object [ ] sort Copy ( Object [ ] objects , Comparer comparer ) { int len = objects . length ; Object [ ] copy = new Object [ len ] ; System . arraycopy ( objects , NUM_ , copy , NUM_ , len ) ; sort ( copy , comparer ) ; return copy ; }
public boolean is Static ( ) { return Modifier . is Static ( get Access Flags ( ) ) ; }
public String documentation Admin Guide Url ( ) { return properties . get Property ( STR_ ) ; }
public static int [ ] clone ( int [ ] array ) { int [ ] result = new int [ array . length ] ; System . arraycopy ( array , NUM_ , result , NUM_ , array . length ) ; return result ; }
default Enum Declaration as Enum ( ) { throw new Unsupported Operation Exception ( String . format ( STR_ , this ) ) ; }
public static void insert Topic ( List < I Topic > topics , I Topic topic ) { if ( topics == null || topics . size ( ) == NUM_ || topics . contains ( topic ) ) { return ; } List < I Topic > all Topics = Mind Map Utils . get All Topics ( topic . get Owned Sheet ( ) , true , true ) ; int index = all Topics . index Of ( topic ) ; for ( int i = index + NUM_ ; i < all Topics . size ( ) ; i ++ ) { I Topic t = all Topics . get ( i ) ; if ( topics . contains ( t ) ) { topics . add ( topics . index Of ( t ) , topic ) ; return ; } } topics . add ( topic ) ; }
public Char Sequence sub Sequence ( int start , int end ) { return to String . substring ( start , end ) ; }
public boolean is Null Stroke Fill ( boolean is Rectangle ) { Meta Pen pen = state . get Current Pen ( ) ; Meta Brush brush = state . get Current Brush ( ) ; boolean no Pen = pen . get Style ( ) == Meta Pen . PS NULL ; int style = brush . get Style ( ) ; boolean is Brush = style == Meta Brush . BS SOLID || style == Meta Brush . BS HATCHED && state . get Background Mode ( ) == Meta State . OPAQUE ; boolean result = no Pen && ! is Brush ; if ( ! no Pen ) { if ( is Rectangle ) state . set Line Join Rectangle ( cb ) ; else state . set Line Join Polygon ( cb ) ; } return result ; }
public static String mangle Native Method ( String owner , String name , String desc ) { String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; sb . append ( mangle Native String ( owner ) ) ; sb . append ( STR_ ) ; sb . append ( mangle Native String ( name ) ) ; if ( desc != null ) { sb . append ( STR_ ) ; sb . append ( mangle Native String ( desc . substring ( NUM_ , desc . last Index Of ( STR_ ) ) ) ) ; } return sb . to String ( ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public boolean is Overriden ( ) { return overrides Me . size ( ) > NUM_ ; }
public boolean can Edit ( Class omgc ) { Iterator iterator ; if ( possible Editable Classes == null ) { Set keys = loaders . key Set ( ) ; possible Editable Classes = new Vector ( keys . size ( ) ) ; iterator = keys . iterator ( ) ; while ( iterator . has Next ( ) ) { String key = ( String ) iterator . next ( ) ; try { possible Editable Classes . add ( Class . for Name ( key ) ) ; } catch ( Class Not Found Exception cnfe ) { } } } iterator = possible Editable Classes . iterator ( ) ; while ( iterator . has Next ( ) ) { Class kc = ( Class ) iterator . next ( ) ; if ( kc == omgc || kc . is Assignable From ( omgc ) ) { return true ; } } return false ; }
private static Generalized Time create Time ( final String value , final int year , final int month , final int day , final int hour , final int minute , final int second , final Time Zone tz ) { try { final Gregorian Calendar calendar = new Gregorian Calendar ( ) ; calendar . set Lenient ( false ) ; calendar . set Time Zone ( tz ) ; calendar . set ( year , month , day , hour , minute , second ) ; calendar . set ( Calendar . MILLISECOND , NUM_ ) ; return new Generalized Time ( calendar , null , Long . MIN VALUE , value ) ; } catch ( final Exception e ) { final Localizable Message message = WARN ATTR SYNTAX GENERALIZED TIME ILLEGAL TIME . get ( value , String . value Of ( e ) ) ; throw new Localized Illegal Argument Exception ( message , e ) ; } }
public static < T > Set < T > frozenset ( T ... objects ) { return Collections . unmodifiable Set ( set ( objects ) ) ; }
public final int index Of ( java . lang . Char Sequence csq , int from Index ) { if ( ( offset + from Index + csq . length ( ) - NUM_ ) >= ( offset + length ) ) throw new Index Out Of Bounds Exception ( String . format ( STR_ , from Index ) ) ; final char c = csq . char At ( NUM_ ) ; final int csq Length = csq . length ( ) ; for ( int i = offset + from Index , end = offset + length - csq Length + NUM_ ; i < end ; i ++ ) { if ( array [ i ] == c ) { boolean match = true ; for ( int j = NUM_ ; j < csq Length ; j ++ ) { if ( array [ i + j ] != csq . char At ( j ) ) { match = false ; break ; } } if ( match ) { return i - offset ; } } } return - NUM_ ; }
public cc Quad 3 tile ( cc Grid Size pos ) { int idx = ( grid Size . y * pos . x + pos . y ) * NUM_ * NUM_ ; float [ ] vert Array = new float [ cc Quad 3 . size ] ; for ( int i = NUM_ ; i < cc Quad 3 . size ; i ++ ) { vert Array [ i ] = vertices . get ( idx + i ) ; } return new cc Quad 3 ( vert Array ) ; }
private Object registered Object Read ( int handle ) throws Invalid Object Exception { Object res = objects Read . get ( handle - Object Stream Constants . base Wire Handle ) ; if ( res == UNSHARED OBJ ) { throw new Invalid Object Exception ( STR_ ) ; } return res ; }
public static Real Variable new Int ( int lower Bound , int upper Bound ) { return new Real Variable ( lower Bound , Math . next After ( ( double ) ( upper Bound + NUM_ ) , Double . NEGATIVE INFINITY ) ) ; }
public static < T > Stream < T > empty ( ) { return of ( Collections . < T > empty List ( ) ) ; }
public static final List < Vector 2 > cleanse ( List < Vector 2 > points ) { if ( points == null ) throw new Null Pointer Exception ( Messages . get String ( STR_ ) ) ; int size = points . size ( ) ; if ( size == NUM_ ) return points ; List < Vector 2 > result = new Array List < Vector 2 > ( size ) ; double winding = NUM_ ; for ( int i = NUM_ ; i < size ; i ++ ) { Vector 2 point = points . get ( i ) ; Vector 2 prev = points . get ( i - NUM_ < NUM_ ? size - NUM_ : i - NUM_ ) ; Vector 2 next = points . get ( i + NUM_ == size ? NUM_ : i + NUM_ ) ; if ( point == null || prev == null || next == null ) throw new Null Pointer Exception ( Messages . get String ( STR_ ) ) ; Vector 2 diff = point . difference ( next ) ; if ( diff . is Zero ( ) ) { continue ; } Vector 2 prev To Point = prev . to ( point ) ; Vector 2 point To Next = point . to ( next ) ; if ( ! prev To Point . is Zero ( ) ) { double cross = prev To Point . cross ( point To Next ) ; if ( Math . abs ( cross ) <= Epsilon . E ) { continue ; } } winding += point . cross ( next ) ; result . add ( point ) ; } if ( winding < NUM_ ) { Geometry . reverse Winding ( result ) ; } return result ; }
protected String cut Extension ( String name ) { int idx = name . last Index Of ( STR_ ) ; if ( idx >= NUM_ ) { return name . substring ( NUM_ , idx ) ; } else { return name ; } }
public boolean header Has Been Sent ( ) { return this . header Sent ; }
String encoded Query ( ) { if ( query Names And Values == null ) return null ; int query Start = url . index Of ( STR_ ) + NUM_ ; int query End = delimiter Offset ( url , query Start + NUM_ , url . length ( ) , STR_ ) ; return url . substring ( query Start , query End ) ; }
public static Driver driver ( String uri , Config config ) { return driver ( URI . create ( uri ) , config ) ; }
public synchronized Object [ ] to Array ( ) { Object [ ] result = new Object [ element Count ] ; System . arraycopy ( element Data , NUM_ , result , NUM_ , element Count ) ; return result ; }
public static boolean is Null Or Empty ( @ Nullable Collection collection ) { return is Null ( collection ) || collection . is Empty ( ) ; }
@ Layoutlib Delegate static long current Thread Time Micro ( ) { return System . current Time Millis ( ) * NUM_ ; }
public static final float [ ] convert Color ( Color color ) { return color . get RGB Components ( null ) ; }
public static List < Integer > extract Original Sequence I Ds ( File feature Vectors File ) throws IO Exception { List < Integer > result = new Array List < > ( ) ; Iterator < List < String > > comments = extract Comments ( feature Vectors File ) ; while ( comments . has Next ( ) ) { List < String > comment = comments . next ( ) ; result . add ( Integer . value Of ( comment . get ( NUM_ ) ) ) ; } return result ; }
public static Attribute attribute From Annotation Value ( Processing Environment env , Executable Element meth , Annotation Value av ) { return av . accept ( new Attribute Creator ( env , meth ) , null ) ; }
protected boolean is Saved Connection ( Database Connection connection ) { Nested Connection current Saved = special Connection . get ( ) ; if ( current Saved == null ) { return false ; } else if ( current Saved . connection == connection ) { return true ; } else { return false ; } }
public static Range find Stacked Range Bounds ( Category Dataset dataset , double base ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; Range result = null ; double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; int category Count = dataset . get Column Count ( ) ; for ( int item = NUM_ ; item < category Count ; item ++ ) { double positive = base ; double negative = base ; int series Count = dataset . get Row Count ( ) ; for ( int series = NUM_ ; series < series Count ; series ++ ) { Number number = dataset . get Value ( series , item ) ; if ( number != null ) { double value = number . double Value ( ) ; if ( value > NUM_ ) { positive = positive + value ; } if ( value < NUM_ ) { negative = negative + value ; } } } minimum = Math . min ( minimum , negative ) ; maximum = Math . max ( maximum , positive ) ; } if ( minimum <= maximum ) { result = new Range ( minimum , maximum ) ; } return result ; }
public boolean is Low Endpoint Included ( ) { return is Low Endpoint Included ; }
public static boolean has Possible Static Property ( Class Node candidate , String method Name ) { if ( ! method Name . starts With ( STR_ ) && ! method Name . starts With ( STR_ ) ) { return false ; } String prop Name = get Prop Name For Accessor ( method Name ) ; Property Node p Node = get Static Property ( candidate , prop Name ) ; return p Node != null && ( method Name . starts With ( STR_ ) || boolean TYPE . equals ( p Node . get Type ( ) ) ) ; }
public double pixel Size At Distance ( double distance ) { if ( this . pixel Size Factor == NUM_ ) { double fovy Degrees = this . field Of View ; double tanfovy 2 = Math . tan ( Math . to Radians ( fovy Degrees * NUM_ ) ) ; this . pixel Size Factor = NUM_ * tanfovy 2 / this . viewport . height ; } return distance * this . pixel Size Factor ; }
private static Charset to Charset ( String csn ) throws Unsupported Encoding Exception { Objects . require Non Null ( csn , STR_ ) ; try { return Charset . for Name ( csn ) ; } catch ( Illegal Charset Name Exception | Unsupported Charset Exception unused ) { throw new Unsupported Encoding Exception ( csn ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add ( new Option ( STR_ + default Num Arcs ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add ( new Option ( STR_ + default Cardinality ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public static boolean is A Target ( final Annotated Type Mirror type , final Set < Type Variable > target Type Vars ) { return type . get Kind ( ) == Type Kind . TYPEVAR && target Type Vars . contains ( type . get Underlying Type ( ) ) ; }
public Bounded Object query One ( Bounding Box box ) { return query One ( box , root ) ; }
public boolean check In Failed ( I Scheduling Rule rule ) { if ( check In Failed . get ( ) != null ) { check In Failed . set ( null ) ; if ( ! workspace . is Tree Locked ( ) ) job Manager . end Rule ( rule ) ; return true ; } return false ; }
public static double distance ( double x 1 , double y 1 , double x 2 , double y 2 ) { x 1 -= x 2 ; y 1 -= y 2 ; return Math . sqrt ( x 1 * x 1 + y 1 * y 1 ) ; }
private void raise Error Event ( int dialog Timeout Error , SIP Client Transaction client Transaction ) { SIP Dialog Error Event new Error Event ; Iterator < SIP Dialog Event Listener > listener Iterator ; SIP Dialog Event Listener next Listener ; new Error Event = new SIP Dialog Error Event ( this , dialog Timeout Error ) ; new Error Event . set Client Transaction ( client Transaction ) ; synchronized ( event Listeners ) { listener Iterator = event Listeners . iterator ( ) ; while ( listener Iterator . has Next ( ) ) { next Listener = ( SIP Dialog Event Listener ) listener Iterator . next ( ) ; next Listener . dialog Error Event ( new Error Event ) ; } } event Listeners . clear ( ) ; if ( dialog Timeout Error != SIP Dialog Error Event . DIALOG ACK NOT SENT TIMEOUT && dialog Timeout Error != SIP Dialog Error Event . DIALOG ACK NOT RECEIVED TIMEOUT && dialog Timeout Error != SIP Dialog Error Event . EARLY STATE TIMEOUT && dialog Timeout Error != SIP Dialog Error Event . DIALOG REINVITE TIMEOUT ) { delete ( ) ; } stop Timer ( ) ; }
static private void throw Failure ( ) throws Internal Gem Fire Error , Error { if ( failure != null ) throw failure ; }
static Util Eval Error cast Error ( Class lhs Type , Class rhs Type , int operation ) { return cast Error ( Reflect . normalize Class Name ( lhs Type ) , Reflect . normalize Class Name ( rhs Type ) , operation ) ; }
@ Override public int hash Code ( ) { int result = NUM_ ; result = Hash Utilities . hash Code ( result , this . label Format ) ; result = Hash Utilities . hash Code ( result , this . null Value String ) ; result = Hash Utilities . hash Code ( result , this . date Format ) ; result = Hash Utilities . hash Code ( result , this . number Format ) ; result = Hash Utilities . hash Code ( result , this . percent Format ) ; return result ; }
public long next ID ( ) { return id . get And Increment ( ) ; }
public boolean is Affiliate ( String protocol , String realm , String name ) throws AM Console Exception { boolean is Affiliate = false ; com . sun . identity . liberty . ws . meta . jaxb . Affiliation Descriptor Type idff ad = null ; com . sun . identity . saml 2 . jaxb . metadata . Affiliation Descriptor Type samlv 2 sd = null ; try { if ( protocol . equals ( IDFF ) ) { IDFF Meta Manager idff Manager = new IDFF Meta Manager ( null ) ; idff ad = ( com . sun . identity . liberty . ws . meta . jaxb . Affiliation Descriptor Type ) idff Manager . get Affiliation Descriptor ( realm , name ) ; } else if ( protocol . equals ( SAMLV 2 ) ) { SAML 2 Meta Manager saml Manager = new SAML 2 Meta Manager ( ) ; samlv 2 sd = ( com . sun . identity . saml 2 . jaxb . metadata . Affiliation Descriptor Type ) saml Manager . get Affiliation Descriptor ( realm , name ) ; } if ( idff ad != null || samlv 2 sd != null ) { is Affiliate = true ; } } catch ( IDFF Meta Exception e ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STR_ , e ) ; } throw new AM Console Exception ( get Error String ( e ) ) ; } catch ( SAML 2 Meta Exception s ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STR_ + STR_ ) ; } throw new AM Console Exception ( get Error String ( s ) ) ; } return is Affiliate ; }
private boolean decode Handshake ( Byte Buffer socket Buffer New ) { Byte Buffer socket Buffer ; if ( tmp Handshake Bytes . capacity ( ) == NUM_ ) { socket Buffer = socket Buffer New ; } else { if ( tmp Handshake Bytes . remaining ( ) < socket Buffer New . remaining ( ) ) { Byte Buffer buf = Byte Buffer . allocate ( tmp Handshake Bytes . capacity ( ) + socket Buffer New . remaining ( ) ) ; tmp Handshake Bytes . flip ( ) ; buf . put ( tmp Handshake Bytes ) ; tmp Handshake Bytes = buf ; } tmp Handshake Bytes . put ( socket Buffer New ) ; tmp Handshake Bytes . flip ( ) ; socket Buffer = tmp Handshake Bytes ; } socket Buffer . mark ( ) ; try { if ( draft == null ) { Handshake State isflashedgecase = is Flash Edge Case ( socket Buffer ) ; if ( isflashedgecase == Handshake State . MATCHED ) { try { write ( Byte Buffer . wrap ( Charsetfunctions . utf 8 Bytes ( wsl . get Flash Policy ( this ) ) ) ) ; close ( Close Frame . FLASHPOLICY , STR_ ) ; } catch ( Invalid Data Exception e ) { close ( Close Frame . ABNORMAL CLOSE , STR_ , true ) ; } return false ; } } Handshake State handshakestate = null ; try { if ( role == Role . SERVER ) { if ( draft == null ) { for ( Draft d : known Drafts ) { d = d . copy Instance ( ) ; try { d . set Parse Mode ( role ) ; socket Buffer . reset ( ) ; Handshakedata tmphandshake = d . translate Handshake ( socket Buffer ) ; if ( tmphandshake instanceof Client Handshake == false ) { flush And Close ( Close Frame . PROTOCOL ERROR , STR_ , false ) ; return false ; } Client Handshake handshake = ( Client Handshake ) tmphandshake ; handshakestate = d . accept Handshake As Server ( handshake ) ; if ( handshakestate == Handshake State . MATCHED ) { resource Descriptor = handshake . get Resource Descriptor ( ) ; Server Handshake Builder response ; try { response = wsl . on Websocket Handshake Received As Server ( this , d , handshake ) ; } catch ( Invalid Data Exception e ) { flush And Close ( e . get Close Code ( ) , e . get Message ( ) , false ) ; return false ; } catch ( Runtime Exception e ) { wsl . on Websocket Error ( this , e ) ; flush And Close ( Close Frame . NEVER CONNECTED , e . get Message ( ) , false ) ; return false ; } write ( d . create Handshake ( d . post Process Handshake Response As Server ( handshake , response ) , role ) ) ; draft = d ; open ( handshake ) ; return true ; } } catch ( Invalid Handshake Exception e ) { } } if ( draft == null ) { close ( Close Frame . PROTOCOL ERROR , STR_ ) ; } return false ; } else { Handshakedata tmphandshake = draft . translate Handshake ( socket Buffer ) ; if ( tmphandshake instanceof Client Handshake == false ) { flush And Close ( Close Frame . PROTOCOL ERROR , STR_ , false ) ; return false ; } Client Handshake handshake = ( Client Handshake ) tmphandshake ; handshakestate = draft . accept Handshake As Server ( handshake ) ; if ( handshakestate == Handshake State . MATCHED ) { open ( handshake ) ; return true ; } else { close ( Close Frame . PROTOCOL ERROR , STR_ ) ; } return false ; } } else if ( role == Role . CLIENT ) { draft . set Parse Mode ( role ) ; Handshakedata tmphandshake = draft . translate Handshake ( socket Buffer ) ; if ( tmphandshake instanceof Server Handshake == false ) { flush And Close ( Close Frame . PROTOCOL ERROR , STR_ , false ) ; return false ; } Server Handshake handshake = ( Server Handshake ) tmphandshake ; handshakestate = draft . accept Handshake As Client ( handshakerequest , handshake ) ; if ( handshakestate == Handshake State . MATCHED ) { try { wsl . on Websocket Handshake Received As Client ( this , handshakerequest , handshake ) ; } catch ( Invalid Data Exception e ) { flush And Close ( e . get Close Code ( ) , e . get Message ( ) , false ) ; return false ; } catch ( Runtime Exception e ) { wsl . on Websocket Error ( this , e ) ; flush And Close ( Close Frame . NEVER CONNECTED , e . get Message ( ) , false ) ; return false ; } open ( handshake ) ; return true ; } else { close ( Close Frame . PROTOCOL ERROR , STR_ + draft + STR_ ) ; } } } catch ( Invalid Handshake Exception e ) { close ( e ) ; } } catch ( Incomplete Handshake Exception e ) { if ( tmp Handshake Bytes . capacity ( ) == NUM_ ) { socket Buffer . reset ( ) ; int newsize = e . get Prefered Size ( ) ; if ( newsize == NUM_ ) { newsize = socket Buffer . capacity ( ) + NUM_ ; } else { assert ( e . get Prefered Size ( ) >= socket Buffer . remaining ( ) ) ; } tmp Handshake Bytes = Byte Buffer . allocate ( newsize ) ; tmp Handshake Bytes . put ( socket Buffer New ) ; } else { tmp Handshake Bytes . position ( tmp Handshake Bytes . limit ( ) ) ; tmp Handshake Bytes . limit ( tmp Handshake Bytes . capacity ( ) ) ; } } return false ; }
@ Not Null public Couple < Hg Revision Number > identify ( @ Not Null Virtual File repo ) { Hg Command Executor command Executor = new Hg Command Executor ( my Project ) ; command Executor . set Silent ( true ) ; Hg Command Result result = command Executor . execute In Current Thread ( repo , STR_ , Arrays . as List ( STR_ , STR_ ) ) ; if ( result == null ) { return Couple . of ( Hg Revision Number . NULL REVISION NUMBER , null ) ; } final List < String > lines = result . get Output Lines ( ) ; if ( lines != null && ! lines . is Empty ( ) ) { List < String > parts = String Util . split ( lines . get ( NUM_ ) , STR_ ) ; String changesets = parts . get ( NUM_ ) ; String revisions = parts . get ( NUM_ ) ; if ( parts . size ( ) >= NUM_ ) { if ( changesets . index Of ( STR_ ) != changesets . last Index Of ( STR_ ) ) { List < String > chsets = String Util . split ( changesets , STR_ ) ; List < String > revs = String Util . split ( revisions , STR_ ) ; return Couple . of ( Hg Revision Number . get Instance ( revs . get ( NUM_ ) + STR_ , chsets . get ( NUM_ ) + STR_ ) , Hg Revision Number . get Instance ( revs . get ( NUM_ ) + STR_ , chsets . get ( NUM_ ) + STR_ ) ) ; } else { return Couple . of ( Hg Revision Number . get Instance ( revisions , changesets ) , null ) ; } } } return Couple . of ( Hg Revision Number . NULL REVISION NUMBER , null ) ; }
private int white Space Length ( String indent ) { if ( indent == null ) return NUM_ ; else { int size = NUM_ ; int l = indent . length ( ) ; int tab Size = get Tab Size ( ) ; for ( int i = NUM_ ; i < l ; i ++ ) size += indent . char At ( i ) == STR_ ? tab Size : NUM_ ; return size ; } }
public boolean matches Method ( String target Class Name , String target Method Name , String candidate Class Name , String candidate Method Name ) { if ( target Class Name != null ) { return ( candidate Class Name == null || target Class Name . equals ( candidate Class Name ) ) && ( candidate Method Name == null || target Method Name . equals ( candidate Method Name ) ) ; } else { return target Method Name . equals ( candidate Method Name ) ; } }
public Cors Service Builder preflight Response Header ( final Ascii String name , final Object ... values ) { require Non Null ( name , STR_ ) ; require Non Null ( values , STR_ ) ; for ( int i = NUM_ ; i < values . length ; i ++ ) { if ( values [ i ] == null ) { throw new Null Pointer Exception ( STR_ + i + STR_ ) ; } } if ( values . length == NUM_ ) { preflight Response Headers . put ( name , new Constant Value Supplier ( values [ NUM_ ] ) ) ; } else { preflight Response Header ( name , Arrays . as List ( values ) ) ; } return this ; }
@ Override public String name ( ) { return name ; }
public String read Process Stat ( int pid ) { Random Access File reader = null ; String line = null ; try { reader = new Random Access File ( STR_ + pid + STR_ , STR_ ) ; line = reader . read Line ( ) ; } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; } finally { } return line ; }
public static int index Of Ignore Parentheses ( char c , String s , int start ) { int level = NUM_ ; for ( int i = start ; i < s . length ( ) ; i ++ ) { char other = s . char At ( i ) ; if ( other == STR_ ) { level ++ ; } else if ( other == STR_ ) { level -- ; } else if ( other == c && level == NUM_ ) { return i ; } } return - NUM_ ; }
public int hash Code ( ) { int v = float To Int Bits ( value ) ; return v ^ ( v > > > NUM_ ) ; }
private List < Validation Result > ordered List ( Collection < Validation Result > results ) { List < Validation Result > result List = new Array List < > ( results ) ; Collections . sort ( result List ) ; return result List ; }
public int next Int ( ) { throw new Unsupported Operation Exception ( STR_ ) ; }
public String num Folds Tip Text ( ) { return STR_ + STR_ ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + pre Compute Correlation Matrix Tip Text ( ) , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + pool Size Tip Text ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + num Threads Tip Text ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public String decode ( Abstract Message msg , Boolean ext , int header ) { String str = Cbus Op Codes . decode ( msg , ext , header ) ; return ( str ) ; }
public Enumeration < String > enumerate Measures ( ) { Vector < String > result = new Vector < String > ( ) ; result . add Element ( STR_ ) ; result . add Element ( STR_ ) ; return result . elements ( ) ; }
protected boolean is Not Fully Initialized Receiver ( Method Tree method Tree ) { return Tree Utils . is Constructor ( method Tree ) ; }
public Resource Bundle new Bundle ( String base Name , Locale locale , String format , Class Loader loader , boolean reload ) throws Illegal Access Exception , Instantiation Exception , IO Exception { if ( format == null ) { throw new Null Pointer Exception ( STR_ ) ; } else if ( loader == null ) { throw new Null Pointer Exception ( STR_ ) ; } final String bundle Name = to Bundle Name ( base Name , locale ) ; final Class Loader clsloader = loader ; Resource Bundle ret ; if ( format . equals ( JAVACLASS ) ) { Class < ? > cls = null ; try { cls = clsloader . load Class ( bundle Name ) ; } catch ( Exception e ) { } catch ( No Class Def Found Error e ) { } if ( cls == null ) { return null ; } try { Resource Bundle bundle = ( Resource Bundle ) cls . new Instance ( ) ; bundle . set Locale ( locale ) ; return bundle ; } catch ( Null Pointer Exception e ) { return null ; } } if ( format . equals ( JAVAPROPERTIES ) ) { Input Stream streams = null ; final String resource Name = to Resource Name ( bundle Name , STR_ ) ; if ( reload ) { URL url = null ; try { url = loader . get Resource ( resource Name ) ; } catch ( Null Pointer Exception e ) { } if ( url != null ) { URL Connection con = url . open Connection ( ) ; con . set Use Caches ( false ) ; streams = con . get Input Stream ( ) ; } } else { try { streams = clsloader . get Resource As Stream ( resource Name ) ; } catch ( Null Pointer Exception e ) { } } if ( streams != null ) { try { ret = new Property Resource Bundle ( new Input Stream Reader ( streams ) ) ; ret . set Locale ( locale ) ; streams . close ( ) ; } catch ( IO Exception e ) { return null ; } return ret ; } return null ; } throw new Illegal Argument Exception ( ) ; }
public Int Buffer minor Version Buffer ( ) { int [ ] holder = new int [ NUM_ ] ; holder [ NUM_ ] = get Minor Version ( ) ; Int Buffer ib = Int Buffer . wrap ( holder ) ; ib . limit ( NUM_ ) ; return ib ; }
private boolean wait For Backup To Become Active ( Testable Server backup Server , long wait Timeout ) throws Exception { long start Time = System . current Time Millis ( ) ; boolean is Backup Started ; while ( ! ( is Backup Started = backup Server . is Active ( ) ) && System . current Time Millis ( ) - start Time < wait Timeout ) { Thread . sleep ( NUM_ ) ; } return is Backup Started ; }
public boolean is Set Send Time ( ) { return isset bit vector . get ( SENDTIME ISSET ID ) ; }
@ Override public Dimension preferred Layout Size ( Container parent ) { Dimension rd , mbd ; Insets i = root Pane . get Insets ( ) ; Container content Pane = root Pane . get Content Pane ( ) ; J Menu Bar menu Bar = root Pane . get J Menu Bar ( ) ; if ( content Pane . is Visible ( ) ) { rd = content Pane . get Preferred Size ( ) ; } else { rd = new Dimension ( NUM_ , content Pane . get Preferred Size ( ) . height ) ; } if ( menu Bar != null && menu Bar . is Visible ( ) ) { mbd = menu Bar . get Preferred Size ( ) ; } else { mbd = new Dimension ( NUM_ , NUM_ ) ; } return new Dimension ( Math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
public boolean contains Symbol ( String symbol ) { int bucket = hash ( symbol ) % f Table Size ; int length = symbol . length ( ) ; OUTER : for ( Entry entry = f Buckets [ bucket ] ; entry != null ; entry = entry . next ) { if ( length == entry . characters . length ) { for ( int i = NUM_ ; i < length ; i ++ ) { if ( symbol . char At ( i ) != entry . characters [ i ] ) { continue OUTER ; } } return true ; } } return false ; }
public boolean equals ( Object o ) { if ( o instanceof Service Schema Manager ) { Service Schema Manager ossm = ( Service Schema Manager ) o ; if ( service Name . equals ( ossm . service Name ) && version . equals ( ossm . version ) ) { return ( true ) ; } } return ( false ) ; }
@ Not Null public static String capitalize ( @ Not Null String s ) { return s . is Empty ( ) ? s : ( to Upper Case ( s . char At ( NUM_ ) ) + s . substring ( NUM_ ) ) ; }
@ Override public int hash Code ( ) { int result = NUM_ ; long temp = Double . double To Long Bits ( this . lower Bound ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . upper Bound ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . inner Radius ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . outer Radius ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; result = NUM_ * result + Hash Utilities . hash Code For Paint ( this . paint ) ; return result ; }
public boolean notify ( final String type , String message ) { try { Notification n = new Notification ( type , this , sequence . increment And Get ( ) , System . current Time Millis ( ) , STR_ + type + STR_ + message ) ; send Notification ( n ) ; for ( Notification Listener listener : listeners ) { listener . handle Notification ( n , this ) ; } return true ; } catch ( Exception x ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + type + STR_ + message , x ) ; } return false ; } }
public static Acl Scope from External Form ( String external Form ) { if ( external Form == null ) { return null ; } if ( external Form . equals ( get Type Identifier ( Type . DEFAULT ) ) ) { return new Acl Scope ( Type . DEFAULT , null ) ; } String [ ] components = external Form . split ( STR_ ) ; if ( components . length != NUM_ ) { return null ; } Type type = get Type ( components [ NUM_ ] ) ; if ( type == null || type == Type . DEFAULT ) { return null ; } return new Acl Scope ( type , components [ NUM_ ] ) ; }
public static Number extract Number ( Object value ) { Number Format number Format = Number Format . get Instance ( ) ; if ( value instanceof Number ) { return ( Number ) value ; } else if ( value == null ) { return new Long ( NUM_ ) ; } else { try { return number Format . parse ( value . to String ( ) ) ; } catch ( Parse Exception ex ) { DT Throwable . rethrow ( ex ) ; } } return new Long ( NUM_ ) ; }
public static boolean is Integral ( Type Mirror type ) { switch ( type . get Kind ( ) ) { case BYTE : case CHAR : case INT : case LONG : case SHORT : return true ; default : return false ; } }
public String local Move Car ( Car car , boolean is Manifest ) { String Buffer buf = new String Buffer ( ) ; String [ ] format ; if ( is Manifest ) { format = Setup . get Local Manifest Message Format ( ) ; } else { format = Setup . get Local Switch List Message Format ( ) ; } for ( String attribute : format ) { String s = get Car Attribute ( car , attribute , ! PICKUP , LOCAL ) ; buf . append ( s ) ; } return buf . to String ( ) ; }
public static String canonical ( File p ) { try { return p . get Canonical Path ( ) ; } catch ( IO Exception e ) { String x = p . get Absolute Path ( ) ; return x == null ? p . get Path ( ) : x ; } }
public Double Vector sqrt ( ) { Double Vector v = new Double Vector ( size ( ) ) ; for ( int i = NUM_ ; i < size ( ) ; i ++ ) { v . V [ i ] = Math . sqrt ( V [ i ] ) ; } return v ; }
public String [ ] segments ( ) { String [ ] segment Copy = new String [ segments . length ] ; System . arraycopy ( segments , NUM_ , segment Copy , NUM_ , segments . length ) ; return segment Copy ; }
private Buffered Writer init Zone 2 Zone Impedace Writer ( String travel Data Path ) throws File Not Found Exception , IO Exception { Buffered Writer travel Data Writer = IO Utils . get Buffered Writer ( travel Data Path ) ; travel Data Writer . write ( STR_ + STR_ + STR_ ) ; travel Data Writer . new Line ( ) ; return travel Data Writer ; }
public boolean is Set Thread Num ( ) { return isset bit vector . get ( THREADNUM ISSET ID ) ; }
public boolean is Src Class ( String clz ) { return src Classes . contains ( clz ) ; }
@ Override public void process ( String tuple ) { if ( ! valid Tuple ( tuple ) ) { return ; } begin Process Tokens ( ) ; process Tokens ( tuple . split ( split By ) ) ; end Process Tokens ( ) ; }
public String to String By Value ( ) { Long Array List the Keys = new Long Array List ( ) ; keys Sorted By Value ( the Keys ) ; String Buffer buf = new String Buffer ( ) ; buf . append ( STR_ ) ; int max Index = the Keys . size ( ) - NUM_ ; for ( int i = NUM_ ; i <= max Index ; i ++ ) { long key = the Keys . get ( i ) ; buf . append ( String . value Of ( key ) ) ; buf . append ( STR_ ) ; buf . append ( String . value Of ( get ( key ) ) ) ; if ( i < max Index ) buf . append ( STR_ ) ; } buf . append ( STR_ ) ; return buf . to String ( ) ; }
public String to String Matrix ( ) { String Buffer result ; String [ ] [ ] cells ; int i ; int n ; String line ; String title ; String generated ; result = new String Buffer ( ) ; cells = to Array ( ) ; generated = STR_ + Version . VERSION + STR_ ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( generated ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; for ( i = NUM_ ; i < cells . length - NUM_ ; i ++ ) result . append ( STR_ + i + STR_ + cells [ i ] [ NUM_ ] + STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; for ( i = NUM_ ; i < cells . length - NUM_ ; i ++ ) { result . append ( Integer . to String ( i ) ) ; for ( n = NUM_ ; n < cells [ i ] . length ; n ++ ) { if ( is Significance ( n ) ) continue ; result . append ( STR_ ) ; result . append ( Utils . quote ( cells [ i ] [ n ] ) ) ; } result . append ( STR_ ) ; } result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( generated ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ + ( ( cells . length - NUM_ ) + NUM_ ) + STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; n = NUM_ ; i = NUM_ ; while ( i < cells [ NUM_ ] . length - NUM_ ) { i ++ ; if ( is Significance ( i ) ) continue ; n ++ ; if ( i == NUM_ ) line = STR_ ; else line = STR_ ; line += STR_ ; title = STR_ + cells [ NUM_ ] [ i ] + STR_ ; line += STR_ + n ; if ( get Show Std Dev ( ) ) { n ++ ; i ++ ; line += STR_ + n ; } line += STR_ ; if ( get Show Std Dev ( ) ) line += STR_ ; else line += STR_ ; line += STR_ + title ; result . append ( line + STR_ ) ; } result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; result . append ( STR_ ) ; return result . to String ( ) ; }
protected static double distance ( Solution s 1 , Solution s 2 ) { double distance = NUM_ ; for ( int i = NUM_ ; i < s 1 . get Number Of Objectives ( ) ; i ++ ) { distance += Math . pow ( s 1 . get Objective ( i ) - s 2 . get Objective ( i ) , NUM_ ) ; } return Math . sqrt ( distance ) ; }
@ Override public double [ ] distribution For Instance ( Instance inst ) throws Exception { if ( m thresholds != null ) { double [ ] dist = m Iterative Classifier . distribution For Instance ( inst ) ; double [ ] new Dist = new double [ dist . length ] ; for ( int i = NUM_ ; i < dist . length ; i ++ ) { if ( dist [ i ] >= m thresholds [ i ] ) { new Dist [ i ] = NUM_ ; } } Utils . normalize ( new Dist ) ; return new Dist ; } else { return m Iterative Classifier . distribution For Instance ( inst ) ; } }
private boolean run After ( Task t , int i ) { try { return t . run After ( ro Tasks , i ) ; } catch ( Throwable tt ) { try { logger . log ( Level . WARNING , STR_ , tt ) ; } catch ( Throwable ttt ) { } return false ; } }
public Optional Double max By Double ( Double Unary Operator key Extractor ) { double [ ] result = collect ( null , null , null ) ; return result [ NUM_ ] == NUM_ ? Optional Double . of ( result [ NUM_ ] ) : Optional Double . empty ( ) ; }
public boolean contains All ( Taxon List taxon List ) { for ( int i = NUM_ ; i < taxon List . get Taxon Count ( ) ; i ++ ) { Taxon taxon = taxon List . get Taxon ( i ) ; if ( ! taxa . contains ( taxon ) ) { return false ; } } return true ; }
public static String swap XML Property ( String xml , String property Name , String property XML ) { String cc Head = STR_ + property Name + STR_ ; int start = xml . index Of ( cc Head ) ; if ( start != - NUM_ ) { start = xml . last Index Of ( Property Template . PROPERTY START OPEN TAG , start ) ; int end = xml . index Of ( STR_ , start ) ; if ( end != - NUM_ ) { xml = xml . substring ( NUM_ , start ) + property XML + xml . substring ( end + NUM_ ) ; } } return xml ; }
public char [ ] to Char Array ( ) { synchronized ( lock ) { char [ ] result = new char [ count ] ; System . arraycopy ( buf , NUM_ , result , NUM_ , count ) ; return result ; } }
private List < Parameter > load ( Commented Line Reader reader ) throws IO Exception { List < Parameter > parameters = new Array List < Parameter > ( ) ; String line = null ; try { while ( ( line = reader . read Line ( ) ) != null ) { String [ ] tokens = line . split ( STR_ ) ; if ( tokens . length != NUM_ ) { throw new IO Exception ( STR_ ) ; } parameters . add ( new Parameter ( tokens [ NUM_ ] , Double . parse Double ( tokens [ NUM_ ] ) , Double . parse Double ( tokens [ NUM_ ] ) ) ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } } return parameters ; }
public static boolean is Case Insensitive ( ) { Boolean value = case Insensitive . get ( ) ; if ( value == null ) { return is Case Insensitive ; } else return value . boolean Value ( ) ; }
public static boolean starts With Char ( String s , char c ) { if ( s . length ( ) == NUM_ ) { return false ; } return s . char At ( NUM_ ) == c ; }
public List < T > to List ( ) { @ Suppress Warnings ( STR_ ) T [ ] copied Elements = ( T [ ] ) new Object [ num Elements ] ; System . arraycopy ( elements , NUM_ , copied Elements , NUM_ , num Elements ) ; return Arrays . as List ( copied Elements ) ; }
private static int index Of ( Object [ ] array , int len , Object elt ) { for ( int i = NUM_ ; i < len ; i ++ ) { if ( elt . equals ( array [ i ] ) ) return i ; } return - NUM_ ; }
protected Color disable ( Color color ) { return Sea Glass Graphics Utils . disable ( color ) ; }
public boolean is Valid ( ) { SSL Session Context context = session Context ; if ( is Valid && context != null && context . get Session Timeout ( ) != NUM_ && get Creation Time ( ) + ( context . get Session Timeout ( ) * NUM_ ) < System . current Time Millis ( ) ) { is Valid = false ; } return is Valid ; }
public boolean is Modified Now ( ) { boolean is Modified = class Loader . is Modified Now ( ) ; if ( is Modified ) log . fine ( STR_ ) ; return is Modified ; }
public static double stddevp ( double [ ] a ) { return Math . sqrt ( varp ( a ) ) ; }
@ Override public boolean is Boundary ( int offset ) { Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; if ( offset == text . get Begin Index ( ) ) { return true ; } else { return following ( offset - NUM_ ) == offset ; } }
private static String to Startup Shutdown String ( String prefix , String [ ] msg ) { String Builder b = new String Builder ( prefix ) ; b . append ( STR_ ) ; for ( String s : msg ) b . append ( STR_ + prefix + s ) ; b . append ( STR_ ) ; return b . to String ( ) ; }
public static int display Width ( String s ) { int width = NUM_ ; int len = s . length ( ) ; for ( int i = NUM_ ; i < len ; ++ i ) { width += display Width ( s . char At ( i ) ) ; } return width ; }
public static double gaussian ( ) { double r , x , y ; do { x = uniform ( - NUM_ , NUM_ ) ; y = uniform ( - NUM_ , NUM_ ) ; r = x * x + y * y ; } while ( r >= NUM_ || r == NUM_ ) ; return x * Math . sqrt ( - NUM_ * Math . log ( r ) / r ) ; }
private String lock Random Namespace ( final boolean read Only ) { final int k = r . next Int ( ( int ) namespace Exist Counter . get ( ) ) ; int i = - NUM_ ; while ( true ) { for ( Map . Entry < String , Read Write Lock > e : namespaces . entry Set ( ) ) { if ( namespace Exist Counter . get ( ) == NUM_ ) { throw new Runtime Exception ( STR_ + read Only ) ; } i ++ ; if ( i < k ) { continue ; } final String namespace = e . get Key ( ) ; final Read Write Lock lock = e . get Value ( ) ; final Lock taken Lock ; { if ( read Only ) taken Lock = lock . read Lock ( ) ; else taken Lock = lock . write Lock ( ) ; taken Lock . lock ( ) ; } if ( namespaces . get ( namespace ) != lock ) { taken Lock . unlock ( ) ; continue ; } return namespace ; } } }
public Shape Tile Box horizontal offset ( double p dist ) { if ( p dist == NUM_ || is empty ( ) ) { return this ; } int dist = ( int ) Math . round ( p dist ) ; Pla Point Int lower left = new Pla Point Int ( box ll . v x - dist , box ll . v y ) ; Pla Point Int upper right = new Pla Point Int ( box ur . v x + dist , box ur . v y ) ; return new Shape Tile Box ( lower left , upper right ) ; }
public boolean can Encode ( char ch ) { int index ; String the Chars ; index = index 1 [ ( ( ch & mask 1 ) > > shift ) ] + ( ch & mask 2 ) ; if ( index < NUM_ ) the Chars = index 2 ; else if ( index < NUM_ ) { index = index - NUM_ ; the Chars = index 2 a ; } else if ( index < NUM_ ) { index = index - NUM_ ; the Chars = index 2 b ; } else { index = index - NUM_ ; the Chars = index 2 c ; } if ( the Chars . char At ( NUM_ * index ) != STR_ || the Chars . char At ( NUM_ * index + NUM_ ) != STR_ ) return ( true ) ; return ( ch == STR_ ) ; }
public float compute Scale ( ) { double km Per Inch = NUM_ ; double km Per Deg = Position . EARTH RADIUS * Math . to Radians ( NUM_ ) ; return ( float ) ( dots Per Deg / dots Per Inch * km Per Inch / km Per Deg ) ; }
public byte [ ] encode ( boolean pad ) throws Stun Exception { int data Length = get Data Length ( ) ; if ( pad ) data Length = pad To 4 ( data Length ) ; byte bin Msg [ ] = new byte [ HEADER LENGTH + data Length ] ; int offset = NUM_ ; if ( ! validate Channel Number ( channel Number ) ) { throw new Stun Exception ( Stun Exception . ILLEGAL ARGUMENT , STR_ ) ; } bin Msg [ offset ++ ] = ( byte ) ( channel Number > > NUM_ ) ; bin Msg [ offset ++ ] = ( byte ) ( channel Number & NUM_ ) ; bin Msg [ offset ++ ] = ( byte ) ( ( data != null ) ? data . length > > NUM_ : NUM_ ) ; bin Msg [ offset ++ ] = ( byte ) ( ( data != null ) ? data . length & NUM_ : NUM_ ) ; if ( data != null ) { System . arraycopy ( data , NUM_ , bin Msg , offset , data . length ) ; } return bin Msg ; }
public boolean var Used In Filter Or Assignment ( I Variable < ? > var ) { if ( ! usage Map . contains Key ( var ) ) { return false ; } final List < I Query Node > var Occurrences = usage Map . get ( var ) ; for ( int i = NUM_ ; i < var Occurrences . size ( ) ; i ++ ) { final I Query Node n = var Occurrences . get ( i ) ; if ( n instanceof Filter Node || n instanceof Assignment Node ) { return true ; } } return false ; }
public int contents Size ( ) { return contents . size ( ) ; }
public static double logregularized Gamma P ( final double a , final double x ) { if ( Double . is Na N ( a ) || Double . is Na N ( x ) || ( a <= NUM_ ) || ( x < NUM_ ) ) { return Double . Na N ; } if ( x == NUM_ ) { return Double . NEGATIVE INFINITY ; } if ( x >= a + NUM_ ) { return Math . log ( NUM_ - regularized Gamma Q ( a , x ) ) ; } double del = NUM_ / a ; double sum = del ; for ( int n = NUM_ ; n < Integer . MAX VALUE ; n ++ ) { del *= x / ( a + n ) ; sum = sum + del ; if ( Math . abs ( del / sum ) < NUM PRECISION || sum >= Double . POSITIVE INFINITY ) { break ; } } if ( Double . is Infinite ( sum ) ) { return NUM_ ; } return - x + ( a * Math . log ( x ) ) - log Gamma ( a ) + Math . log ( sum ) ; }
public static Vector 3 rand ( ) { return new Vector 3 ( Math . random ( ) , Math . random ( ) , Math . random ( ) ) ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( get Class ( ) != obj . get Class ( ) ) { return false ; } Default Credentials other = ( Default Credentials ) obj ; if ( password == null ) { if ( other . password != null ) { return false ; } } else if ( ! password . equals ( other . password ) ) { return false ; } if ( token == null ) { if ( other . token != null ) { return false ; } } else if ( ! token . equals ( other . token ) ) { return false ; } if ( username == null ) { if ( other . username != null ) { return false ; } } else if ( ! username . equals ( other . username ) ) { return false ; } return true ; }
public static boolean is Static Attribute ( String attribute Name ) { return attribute Name != null && attribute Name . starts With ( STATIC QUOTE ) && attribute Name . ends With ( STATIC QUOTE ) ; }
public static String format Number ( double value ) { if ( Double . is Na N ( value ) ) { return STR_ ; } return format Number ( value , number Of Fraction Digits , false ) ; }
public String access String ( ) { String Buffer result ; if ( access String != null ) return access String ; result = new String Buffer ( ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; access String = result . to String ( ) ; return access String ; }
public void request Authentication Failure Times ( ) { operations . add ( Password Policy State Operation Type . GET AUTHENTICATION FAILURE TIMES ) ; }
public boolean is Incremental ( ) { return m Incremental ; }
public Connection next ( String method ) throws IO Exception { for ( Connection pooled ; ( pooled = pool . get ( address ) ) != null ; ) { if ( method . equals ( STR_ ) || pooled . is Readable ( ) ) return pooled ; pooled . close ( ) ; } if ( ! has Next Tls Mode ( ) ) { if ( ! has Next Inet Socket Address ( ) ) { if ( ! has Next Proxy ( ) ) { if ( ! has Next Postponed ( ) ) { throw new No Such Element Exception ( ) ; } return new Connection ( next Postponed ( ) ) ; } last Proxy = next Proxy ( ) ; reset Next Inet Socket Address ( last Proxy ) ; } last Inet Socket Address = next Inet Socket Address ( ) ; reset Next Tls Mode ( ) ; } boolean modern Tls = next Tls Mode ( ) == TLS MODE MODERN ; Route route = new Route ( address , last Proxy , last Inet Socket Address , modern Tls ) ; if ( route Database . should Postpone ( route ) ) { postponed Routes . add ( route ) ; return next ( method ) ; } return new Connection ( route ) ; }
public int size ( ) { if ( relations == null ) { return NUM_ ; } else { return relations . size ( ) ; } }
public static int next Poisson ( double xm ) { double em ; double t , y ; if ( xm < NUM_ ) { if ( xm != oldm ) { oldm = xm ; g = Math . exp ( - xm ) ; } em = - NUM_ ; t = NUM_ ; do { ++ em ; t *= Math Utils . next Double ( ) ; } while ( t > g ) ; } else { if ( xm != oldm ) { oldm = xm ; sq = Math . sqrt ( NUM_ * xm ) ; alxm = Math . log ( xm ) ; g = xm * alxm - gammln ( xm + NUM_ ) ; } do { do { y = Math . tan ( Math . PI * Math Utils . next Double ( ) ) ; em = sq * y + xm ; } while ( em < NUM_ ) ; em = Math . floor ( em ) ; t = NUM_ * ( NUM_ + y * y ) * Math . exp ( em * alxm - gammln ( em + NUM_ ) - g ) ; } while ( Math Utils . next Double ( ) > t ) ; } return ( int ) em ; }
public int end ( ) { return start + raw String . length ( ) ; }
public boolean equals ( Object other ) { if ( other == null ) return false ; if ( get Class ( ) != other . get Class ( ) ) { return false ; } Host Port that = ( Host Port ) other ; return port == that . port && host . equals ( that . host ) ; }
public static Set < String > subparts ( String word ) { return Utils . subparts ( word , NUM_ , NUM_ ) ; }
@ Override public Object clone ( ) { Object clone = null ; try { clone = super . clone ( ) ; } catch ( Clone Not Supported Exception e ) { e . print Stack Trace ( ) ; } return clone ; }
public static int write Byte Buffer To Stream ( Output Stream out , Byte Buffer out Buf , Byte Buffer in Buf ) throws IO Exception { int bytes To Write = in Buf . remaining ( ) ; if ( bytes To Write > NUM_ ) { if ( in Buf . has Array ( ) ) { flush Stream ( out , out Buf ) ; out . write ( in Buf . array ( ) , in Buf . array Offset ( ) + in Buf . position ( ) , bytes To Write ) ; in Buf . position ( in Buf . limit ( ) ) ; } else { int bytes To Write This Time = bytes To Write ; int OUT MAX = out Buf . remaining ( ) ; while ( bytes To Write This Time > OUT MAX ) { int old Limit = in Buf . limit ( ) ; in Buf . limit ( in Buf . position ( ) + OUT MAX ) ; out Buf . put ( in Buf ) ; in Buf . limit ( old Limit ) ; flush Stream ( out , out Buf ) ; bytes To Write This Time -= OUT MAX ; OUT MAX = out Buf . remaining ( ) ; } out Buf . put ( in Buf ) ; } } return bytes To Write ; }
private String to Hex ( int i ) { String result ; result = Integer . to Hex String ( i ) ; if ( result . length ( ) < NUM_ ) { result = STR_ + result ; } return result ; }
public static boolean is Valid Type Signature ( String sig , boolean allow Void ) { int len = sig . length ( ) ; return check Type Signature ( sig , NUM_ , len , allow Void ) == len ; }
public static String decode Endpoint Operation ( String endpoint , boolean stripped ) { int ind = endpoint . index Of ( STR_ ) ; if ( ind != - NUM_ ) { if ( stripped ) { return endpoint . substring ( ind + NUM_ , endpoint . length ( ) - NUM_ ) ; } return endpoint . substring ( ind ) ; } return null ; }
public long available ( ) throws IO Exception { if ( input Stream == null ) { throw new IO Exception ( STR_ ) ; } return input Stream . available ( ) ; }
public String namespace URI ( ) { if ( namespace Prefix == null || namespace Prefix . is Empty ( ) ) return STR_ ; String uri = namespace Tag Hints . get ( namespace Prefix ) ; return uri == null ? STR_ : uri ; }
public boolean is Paused ( ) { return paused ; }
public void readable To Indexed ( Char Sequence val , Bytes Ref Builder result ) { final String internal = readable To Indexed ( val . to String ( ) ) ; result . copy Chars ( internal ) ; }
public boolean uses Sorting ( ) { return ! sort . is Empty ( ) ; }
public Index Schema create ( String resource Name , Solr Config config ) { Solr Resource Loader loader = config . get Resource Loader ( ) ; Input Stream schema Input Stream = null ; if ( null == resource Name ) { resource Name = Index Schema . DEFAULT SCHEMA FILE ; } try { schema Input Stream = loader . open Schema ( resource Name ) ; } catch ( Exception e ) { final String msg = STR_ + resource Name ; log . error ( msg , e ) ; throw new Solr Exception ( Error Code . SERVER ERROR , msg , e ) ; } Input Source input Source = new Input Source ( schema Input Stream ) ; input Source . set System Id ( System Id Resolver . create System Id From Resource Name ( resource Name ) ) ; Index Schema schema = new Index Schema ( config , resource Name , input Source ) ; return schema ; }
private static boolean overflow In Parse ( long current , int digit ) { return overflow In Parse ( current , digit , NUM_ ) ; }
public static boolean is Null Or Empty ( String Builder text ) { return ( text == null ) || is Null Or Empty ( text . to String ( ) ) ; }
@ Bean public Client Details Service client Details Service ( ) throws Exception { return combined Service ; }
public boolean has Next ( ) { return index < desc . length ( ) ; }
public static byte [ ] copy Of Bytes ( final byte [ ] bytes ) { return Arrays . copy Of ( bytes , bytes . length ) ; }
@ Suppress Warnings ( STR_ ) static void murmurhash 3 x 64 128 ( byte [ ] key , int offset , int len , int seed , Long Pair out ) { long h 1 = seed & NUM_ ; long h 2 = seed & NUM_ ; final long c 1 = NUM_ ; final long c 2 = NUM_ ; int rounded End = offset + ( len & NUM_ ) ; for ( int i = offset ; i < rounded End ; i += NUM_ ) { long k 1 = get Long Little Endian ( key , i ) ; long k 2 = get Long Little Endian ( key , i + NUM_ ) ; k 1 *= c 1 ; k 1 = Long . rotate Left ( k 1 , NUM_ ) ; k 1 *= c 2 ; h 1 ^= k 1 ; h 1 = Long . rotate Left ( h 1 , NUM_ ) ; h 1 += h 2 ; h 1 = h 1 * NUM_ + NUM_ ; k 2 *= c 2 ; k 2 = Long . rotate Left ( k 2 , NUM_ ) ; k 2 *= c 1 ; h 2 ^= k 2 ; h 2 = Long . rotate Left ( h 2 , NUM_ ) ; h 2 += h 1 ; h 2 = h 2 * NUM_ + NUM_ ; } long k 1 = NUM_ ; long k 2 = NUM_ ; switch ( len & NUM_ ) { case NUM_ : k 2 = ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 2 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 2 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 2 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 2 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 2 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 2 |= ( key [ rounded End + NUM_ ] & NUM_ ) ; k 2 *= c 2 ; k 2 = Long . rotate Left ( k 2 , NUM_ ) ; k 2 *= c 1 ; h 2 ^= k 2 ; case NUM_ : k 1 = ( ( long ) key [ rounded End + NUM_ ] ) << NUM_ ; case NUM_ : k 1 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 1 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 1 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 1 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 1 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 1 |= ( key [ rounded End + NUM_ ] & NUM_ ) << NUM_ ; case NUM_ : k 1 |= ( key [ rounded End ] & NUM_ ) ; k 1 *= c 1 ; k 1 = Long . rotate Left ( k 1 , NUM_ ) ; k 1 *= c 2 ; h 1 ^= k 1 ; } h 1 ^= len ; h 2 ^= len ; h 1 += h 2 ; h 2 += h 1 ; h 1 = fmix 64 ( h 1 ) ; h 2 = fmix 64 ( h 2 ) ; h 1 += h 2 ; h 2 += h 1 ; out . val 1 = h 1 ; out . val 2 = h 2 ; }
protected static String drain Inbound Message Buffer ( String Builder builder , int index ) { String result = builder . substring ( NUM_ , index ) ; builder . delete ( NUM_ , index ) ; return result ; }
public static Number to Number ( String str , Number default Value ) { try { if ( str . index Of ( STR_ ) != - NUM_ ) { return new Big Decimal ( str ) ; } Big Integer bi = new Big Integer ( str ) ; int l = bi . bit Length ( ) ; if ( l < NUM_ ) return new Integer ( bi . int Value ( ) ) ; if ( l < NUM_ ) return new Long ( bi . long Value ( ) ) ; return bi ; } catch ( Throwable t ) { return default Value ; } }
public boolean is Show Imported Functions ( ) { return m imported Function Checkbox . is Selected ( ) ; }
protected Slim Exception ( final boolean talkback , final Throwable t , final Error Type type , final String ... args ) { super ( t != null ? t . to String ( ) : args . length > NUM_ ? args [ NUM_ ] : STR_ , t ) ; m Talkback = talkback ; m Error Type = type ; m Error Arguments = args . clone ( ) ; }
public Enumeration < String > header Keys ( ) { return m Header Keys . elements ( ) ; }
public Prototype with First Parameter ( Type param ) { String new Desc = STR_ + param . get Descriptor ( ) + descriptor . substring ( NUM_ ) ; Std Type List new Params = parameter Types . with First ( param ) ; new Params . set Immutable ( ) ; Prototype result = new Prototype ( new Desc , return Type , new Params ) ; return put Intern ( result ) ; }
public static boolean [ ] parse String ( String [ ] values ) { boolean [ ] result = new boolean [ values . length ] ; for ( int i = NUM_ ; i < result . length ; i ++ ) { result [ i ] = parse String ( values [ i ] ) ; } return result ; }
@ Override public byte [ ] encode ( ) { byte bin Value [ ] = new byte [ HEADER LENGTH + get Data Length ( ) + ( NUM_ - get Data Length ( ) % NUM_ ) % NUM_ ] ; bin Value [ NUM_ ] = ( byte ) ( get Attribute Type ( ) > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Attribute Type ( ) & NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) & NUM_ ) ; bin Value [ NUM_ ] = NUM_ ; bin Value [ NUM_ ] = NUM_ ; bin Value [ NUM_ ] = get Error Class ( ) ; bin Value [ NUM_ ] = get Error Number ( ) ; if ( reason Phrase != null ) System . arraycopy ( reason Phrase , NUM_ , bin Value , NUM_ , reason Phrase . length ) ; return bin Value ; }
public boolean contains ( String value ) { return m values . contains ( value ) ; }
public static long current Time Millis ( ) { if ( mock Time != null ) return mock Time . get Time ( ) ; else return System . current Time Millis ( ) ; }
private static float distance ( float event X , float start X , float event Y , float start Y ) { float dx = event X - start X ; float dy = event Y - start Y ; return ( float ) Math . sqrt ( dx * dx + dy * dy ) ; }
public static int comment Start ( String line ) { boolean insidequote = false ; for ( int i = NUM_ ; i < line . length ( ) ; i ++ ) { char current = line . char At ( i ) ; if ( current == STR_ ) { insidequote = ! insidequote ; } else if ( ! insidequote ) { if ( current == STR_ ) { return i ; } } } return - NUM_ ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public Virtual File resolve ( String relative Str ) { Virtual File f = get Virtual File ( ) ; return f == null ? null : f . resolve ( relative Str ) ; }
boolean boundary Approx Equals ( S 2 Polygon b , double max Error ) { if ( num Loops ( ) != b . num Loops ( ) ) { log . severe ( STR_ + Integer . to String ( num Loops ( ) ) + STR_ + Integer . to String ( b . num Loops ( ) ) ) ; return false ; } for ( int i = NUM_ ; i < num Loops ( ) ; ++ i ) { S 2 Loop a Loop = loop ( i ) ; boolean success = false ; for ( int j = NUM_ ; j < num Loops ( ) ; ++ j ) { S 2 Loop b Loop = b . loop ( j ) ; if ( b Loop . depth ( ) == a Loop . depth ( ) && b Loop . boundary Approx Equals ( a Loop , max Error ) ) { success = true ; break ; } } if ( ! success ) { return false ; } } return true ; }
public static double log Gamma ( double xx ) { double x = xx - NUM_ ; double tmp = x + NUM_ ; tmp -= ( x + NUM_ ) * Math . log ( tmp ) ; double ser = NUM_ ; double [ ] coeff = cof ; for ( int j = NUM_ ; j <= NUM_ ; j ++ ) { x ++ ; ser += coeff [ j ] / x ; } return - tmp + Math . log ( NUM_ * ser ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public boolean no Version Received From Server ( ) { return version Tag == null && region . concurrency Checks Enabled && region . get Server Proxy ( ) != null && ! op . is Local ( ) && ! is Origin Remote ( ) ; }
public Span trim ( Char Sequence src ) { if ( start < end ) while ( src . char At ( end - NUM_ ) == NUM_ ) { end -- ; if ( start == end ) break ; } if ( start < end ) while ( src . char At ( start ) == NUM_ ) { start ++ ; if ( start == end ) break ; } return this ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public int [ ] [ ] f 2 e ( ) { int f Dim = src End Exclusive - src Start Inclusive ; int [ ] [ ] f 2 e = new int [ f Dim ] [ ] ; for ( int i = src Start Inclusive ; i < src End Exclusive ; ++ i ) { int local Idx = i - src Start Inclusive ; int [ ] f 2 e I = sentence Pair . f 2 e ( i ) ; int tgt Align Dim = f 2 e I . length ; f 2 e [ local Idx ] = new int [ tgt Align Dim ] ; if ( tgt Align Dim > NUM_ ) { System . arraycopy ( f 2 e I , NUM_ , f 2 e [ local Idx ] , NUM_ , f 2 e [ local Idx ] . length ) ; for ( int j = NUM_ ; j < f 2 e [ local Idx ] . length ; ++ j ) { f 2 e [ local Idx ] [ j ] -= tgt Start Inclusive ; } } } return f 2 e ; }
public static File open File ( String path ) { try { return new File ( path ) ; } catch ( Error e ) { return null ; } }
public Buffered Image create Compatible Image ( int width , int height ) { Writable Raster wr = raster . create Compatible Writable Raster ( width , height ) ; return new Buffered Image ( model , wr , model . is Alpha Premultiplied ( ) , null ) ; }
public boolean is Modified ( ) { for ( int i = dependency List . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Dependency dependency = dependency List . get ( i ) ; if ( dependency . is Modified ( ) ) { return true ; } } return false ; }
public static int hash ( double value ) { return Double . hash Code ( value ) ; }
@ Safe Varargs public static < U > Simple React Stream < U > first Of ( final Simple React Stream < U > ... future Streams ) { return Eager Future Stream Functions . first Of ( future Streams ) ; }
public List < Challenge > challenges ( ) { String response Field ; if ( code == HTTP UNAUTHORIZED ) { response Field = STR_ ; } else if ( code == HTTP PROXY AUTH ) { response Field = STR_ ; } else { return Collections . empty List ( ) ; } return Ok Headers . parse Challenges ( headers ( ) , response Field ) ; }
public int length ( ) { return m Label . length ( ) + m Suffix . length ( ) ; }
public static String quote ( String s ) { if ( s == null ) { s = STR_ ; } return STR_ + s + STR_ ; }
public boolean is Verbose ( ) { return ( environment . get ( CLI Constants . ARGUMENT VERBOSE ) != null ) ; }
@ Override public int hash Code ( ) { if ( hash == NUM_ ) { int result = NUM_ ; result = NUM_ * result + range . hash Code ( ) ; long bits Weight = Double . double To Long Bits ( weight ) ; result = NUM_ * result + ( int ) ( bits Weight ^ ( bits Weight > > > NUM_ ) ) ; hash = result ; } return hash ; }
public static int hash Code ( int pre , String s ) { int h = ( s != null ? s . hash Code ( ) : NUM_ ) ; return NUM_ * pre + h ; }
public char char At ( int index ) { return to String . char At ( index ) ; }
public static final String to Bit String ( double d [ ] ) { String Builder sb = new String Builder ( d . length ) ; for ( double b : d ) { sb . append ( ( int ) Math . round ( b ) ) ; } return sb . to String ( ) ; }
private String generate Map Html ( Map map , User user ) throws IO Exception { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; Buffered Image image = map Generation Service . generate Map Image For User ( map , new Date ( ) , null , NUM_ , NUM_ , user ) ; Image IO . write ( image , STR_ , baos ) ; return upload Image ( map . get Uid ( ) , baos . to Byte Array ( ) ) ; }
public synchronized boolean is Newer Than Or Can Fill Exceptions For ( Region Version Holder < T > source ) { if ( source == null || get Version ( ) > source . get Version ( ) ) { return true ; } Region Version Holder < T > other = source . clone ( ) ; merge Bit Set ( ) ; other . merge Bit Set ( ) ; List < RVV Exception > mine = canonical Exceptions ( this . exceptions ) ; Iterator < RVV Exception > my Iterator = mine . iterator ( ) ; List < RVV Exception > his = canonical Exceptions ( other . exceptions ) ; Iterator < RVV Exception > other Iterator = his . iterator ( ) ; RVV Exception my Exception = my Iterator . has Next ( ) ? my Iterator . next ( ) : null ; RVV Exception other Exception = other Iterator . has Next ( ) ? other Iterator . next ( ) : null ; while ( ( other Exception != null && other Exception . previous Version > this . version ) || is Special Exception ( other Exception , other ) ) { other Exception = other Iterator . has Next ( ) ? other Iterator . next ( ) : null ; } while ( other Exception != null ) { if ( my Exception == null ) { return true ; } if ( is Special Exception ( my Exception , this ) ) { my Exception = my Iterator . has Next ( ) ? my Iterator . next ( ) : null ; continue ; } if ( is Special Exception ( other Exception , other ) ) { other Exception = other Iterator . has Next ( ) ? other Iterator . next ( ) : null ; continue ; } if ( my Exception . previous Version >= other Exception . next Version ) { my Exception = my Iterator . has Next ( ) ? my Iterator . next ( ) : null ; continue ; } if ( other Exception . previous Version >= my Exception . next Version ) { return true ; } if ( ( my Exception . previous Version == other Exception . previous Version ) && ( my Exception . next Version == other Exception . next Version ) ) { my Exception = my Iterator . has Next ( ) ? my Iterator . next ( ) : null ; other Exception = other Iterator . has Next ( ) ? other Iterator . next ( ) : null ; continue ; } if ( ( other Exception . previous Version < my Exception . previous Version ) || ( my Exception . next Version < other Exception . next Version ) ) { return true ; } other Exception = other Iterator . has Next ( ) ? other Iterator . next ( ) : null ; } return false ; }
@ Override public Object clone ( ) throws Clone Not Supported Exception { XY Series clone = ( XY Series ) super . clone ( ) ; clone . data = ( List ) Object Utilities . deep Clone ( this . data ) ; return clone ; }
@ Override final Node < K , V > find ( int h , Object k ) { if ( k != null ) { for ( Node < K , V > e = first ; e != null ; e = e . next ) { int s ; K ek ; if ( ( ( s = lock State ) & ( WAITER | WRITER ) ) != NUM_ ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; } else if ( U . compare And Swap Int ( this , LOCKSTATE , s , s + READER ) ) { Tree Node < K , V > r , p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k , null ) ) ; } finally { Thread w ; int ls ; do { } while ( ! U . compare And Swap Int ( this , LOCKSTATE , ls = lock State , ls - READER ) ) ; if ( ls == ( READER | WAITER ) && ( w = waiter ) != null ) Lock Support . unpark ( w ) ; } return p ; } } } return null ; }
private static boolean is Successful ( int response Code ) { return response Code == NUM_ || response Code == NUM_ || response Code == NUM_ ; }
public boolean is Member ( Principal p ) { if ( ( p . hash Code ( ) & super . hash Code ( ) ) == p . hash Code ( ) ) return true ; else return false ; }
public static int [ ] copy ( int [ ] array ) { if ( array != null ) { int [ ] copy = new int [ array . length ] ; System . arraycopy ( array , NUM_ , copy , NUM_ , array . length ) ; return copy ; } return null ; }
public static Data Row Reader create Data Row Reader ( double [ ] [ ] values ) { List < Data Row > data Rows = new Linked List < Data Row > ( ) ; for ( int i = NUM_ ; i < values . length ; i ++ ) { data Rows . add ( new Double Array Data Row ( values [ i ] ) ) ; } return new List Data Row Reader ( data Rows . iterator ( ) ) ; }
private static Set < Branch > collect Covered Branches ( Test Suite Chromosome suite ) { final Set < Branch > suite Covered Branches = new Hash Set < Branch > ( ) ; for ( Test Chromosome test : suite . get Test Chromosomes ( ) ) { final Set < Branch > test Covered Branches = get Covered Branches ( test ) ; suite Covered Branches . add All ( test Covered Branches ) ; } return suite Covered Branches ; }
private synchronized boolean is Painting Thread ( ) { return ( Thread . current Thread ( ) == paint Thread ) ; }
@ Override public String to Parsable String ( Type declaring Type , Type Tuple input Types , Type output Type ) { return declaring Type . get Name ( ) + STR_ + field . get Name ( ) + STR_ ; }
private static double acceptance Probability ( double old Cost , double new Cost , double temp ) { return new Cost < old Cost ? NUM_ : Math . exp ( - ( new Cost - old Cost ) / temp ) ; }
public boolean simulation Paused ( ) { return pause Button . is Selected ( ) ; }
public boolean has Next ( ) { if ( this . sam Iterator == null ) { iterator ( ) ; } while ( complete . is Empty ( ) && ( ( ! accumulator . is Empty ( ) ) || sam Has More ( ) || has Remaining Mask Bases ( ) ) ) { final Locus Info locus Info = next ( ) ; if ( locus Info != null ) { complete . add ( NUM_ , locus Info ) ; } } return ! complete . is Empty ( ) ; }
String serialize To String ( ) { final String Builder sb = new String Builder ( ) ; sb . append ( String . format ( STR_ , num Active , keys . length ) ) ; for ( int i = NUM_ ; i < keys . length ; i ++ ) { if ( states [ i ] != NUM_ ) { sb . append ( String . format ( STR_ , keys [ i ] , values [ i ] ) ) ; } } return sb . to String ( ) ; }
public Complex cos ( ) { return new Complex ( Math . cos ( re ) * Math . cosh ( im ) , - Math . sin ( re ) * Math . sinh ( im ) ) ; }
@ Override public < T > T [ ] to Array ( T [ ] array ) { return new Array ( array ) ; }
public boolean contains ( Node obj ) { final List < Node > l ; synchronized ( this ) { l = this . list ; } return l . contains ( obj ) ; }
public static < K , V > Map < K , V > of ( K k 1 , V v 1 , K k 2 , V v 2 , K k 3 , V v 3 , K k 4 , V v 4 , K k 5 , V v 5 , K k 6 , V v 6 ) { Map map = of ( ) ; map . put ( k 1 , v 1 ) ; map . put ( k 2 , v 2 ) ; map . put ( k 3 , v 3 ) ; map . put ( k 4 , v 4 ) ; map . put ( k 5 , v 5 ) ; map . put ( k 6 , v 6 ) ; return map ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private String validate Non Empty String ( String value , String default Value ) { return is Empty ( value ) ? default Value : value ; }
@ Visible For Testing Enum Set < Failure Reason > failure Reasons ( Context context ) { Enum Set < Failure Reason > reasons = Enum Set . none Of ( Failure Reason . class ) ; reasons . add All ( m Precache Launcher . failure Reasons ( ) ) ; if ( ! m Device State . is Power Connected ( context ) ) reasons . add ( Failure Reason . NO POWER ) ; if ( ! m Device State . is Wifi Available ( context ) ) reasons . add ( Failure Reason . NO WIFI ) ; if ( time Since Last Precache Ms ( context ) < WAIT UNTIL NEXT PRECACHE MS ) { reasons . add ( Failure Reason . NOT ENOUGH TIME SINCE LAST PRECACHE ) ; } if ( Precache Service . is Precaching ( ) ) reasons . add ( Failure Reason . CURRENTLY PRECACHING ) ; return reasons ; }
private static boolean is Valid Field Glob ( String name ) { if ( name . starts With ( STR_ ) || name . ends With ( STR_ ) ) { int count = NUM_ ; for ( int pos = NUM_ ; pos < name . length ( ) && - NUM_ != ( pos = name . index Of ( STR_ , pos ) ) ; ++ pos ) ++ count ; if ( NUM_ == count ) return true ; } return false ; }
public boolean is Sealed ( ) { if ( jar != null ) { init ( ) ; } return seal Base != null ; }
public String graph ( ) throws Exception { String Buffer text = new String Buffer ( ) ; assign I Ds ( - NUM_ ) ; assign Leaf Model Numbers ( NUM_ ) ; text . append ( STR_ ) ; if ( m is Leaf ) { text . append ( STR_ + m id + STR_ + m leaf Model Num + STR_ + get Model Parameters ( ) + STR_ + STR_ ) ; text . append ( STR_ ) ; } else { text . append ( STR_ + m id + STR_ + Utils . back Quote Chars ( m local Model . left Side ( m train ) ) + STR_ ) ; text . append ( STR_ ) ; graph Tree ( text ) ; } return text . to String ( ) + STR_ ; }
private static long sum ( long n ) { return n * ( n + NUM_ ) / NUM_ ; }
private boolean is Before End ( Concurrent Skip List Map . Node < K , V > n ) { if ( n == null ) return false ; if ( hi == null ) return true ; K k = n . key ; if ( k == null ) return true ; int c = m . compare ( k , hi ) ; if ( c > NUM_ || ( c == NUM_ && ! hi Inclusive ) ) return false ; return true ; }
public synchronized void close ( ) { if ( is Alive ) { is Alive = false ; task Queue . clear ( ) ; interrupt ( ) ; } }
@ Override public int hash Code ( ) { int code = super . hash Code ( ) ; if ( f Entity Name != null ) { code += f Entity Name . hash Code ( ) ; } return code ; }
public final int index Of ( char c , int from Index ) { if ( ( offset + from Index ) >= ( offset + length ) ) throw new Index Out Of Bounds Exception ( String . format ( STR_ , from Index ) ) ; for ( int i = offset + from Index , end = offset + length ; i < end ; i ++ ) { if ( array [ i ] == c ) return i - offset ; } return - NUM_ ; }
private static int index Of ( final String s , final char search Char , final int begin Index , final int end Index ) { for ( int i = begin Index ; i < end Index ; i ++ ) { if ( s . char At ( i ) == search Char ) { return i ; } } return - NUM_ ; }
private int month Length ( int month , int gregorian Year ) { return Calendar Utils . is Gregorian Leap Year ( gregorian Year ) ? Gregorian Calendar . LEAP MONTH LENGTH [ month ] : Gregorian Calendar . MONTH LENGTH [ month ] ; }
public List < Node > list Available Nodes ( Class < ? > type ) { List < Node > result = new Array List < Node > ( ) ; for ( Node node : available Nodes ) { if ( type . is Assignable From ( node . get Return Type ( ) ) ) { result . add ( node ) ; } } return result ; }
public static Byte Buffer from String ( String str , Charset charset ) { return Byte Buffer . wrap ( str . get Bytes ( charset ) ) ; }
public Enumeration < E > elements ( ) { return delegate . elements ( ) ; }
private boolean is Media Type Match ( Media Type media Type , Media Type range Pattern ) { String WILDCARD = STR_ ; String range Pattern Type = range Pattern . get Type ( ) ; String range Pattern Subtype = range Pattern . get Subtype ( ) ; return ( range Pattern Type . equals ( WILDCARD ) || range Pattern Type . equals ( media Type . get Type ( ) ) ) && ( range Pattern Subtype . equals ( WILDCARD ) || range Pattern Subtype . equals ( media Type . get Subtype ( ) ) ) ; }
public Optional Int min By Int ( Int Unary Operator key Extractor ) { int [ ] result = collect ( null , null , null ) ; return result [ NUM_ ] == NUM_ ? Optional Int . of ( result [ NUM_ ] ) : Optional Int . empty ( ) ; }
protected int x ( double x W ) { return ( int ) Math . round ( scale * ( x W + offset X ) + border Left ) ; }
public char char At ( int index ) { return internal . char At ( index ) ; }
public boolean is Coordinator ( ) { return this . is Coordinator ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result ; result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Nullable public File resolve Parent Directory ( @ Nullable Label label ) { return label != null ? resolve Parent Directory ( label . blaze Package ( ) , label . rule Name ( ) ) : null ; }
public boolean is Update Required ( ) { return this . update Required ; }
public Object [ ] to Array ( ) { return al . to Array ( ) ; }
private static boolean in King Section Like Hash ( String key , String value ) { String hash Value = ( String ) king Section Like Hash . get ( key ) ; if ( hash Value != null ) { return ( hash Value . equals ( value ) ) ; } else { return false ; } }
protected static boolean is Valid Field Glob ( String name ) { if ( name . starts With ( STR_ ) || name . ends With ( STR_ ) ) { int count = NUM_ ; for ( int pos = NUM_ ; pos < name . length ( ) && - NUM_ != ( pos = name . index Of ( STR_ , pos ) ) ; ++ pos ) ++ count ; if ( NUM_ == count ) return true ; } return false ; }
public To Hit Data los Modifiers ( I Game game ) { return los Modifiers ( game , NUM_ , false ) ; }
public static String fmt Nz ( double v ) { return v == Double . MAX VALUE || v == NUM_ ? null : FMT 2 . format ( v ) ; }
public static double dchisq ( double x , double ncp ) { if ( ncp == NUM_ ) return dchisq ( x ) ; double xh = Math . sqrt ( x ) ; double mean = Math . sqrt ( ncp ) ; return ( dnorm ( xh - mean ) + dnorm ( - xh - mean ) ) / ( NUM_ * xh ) ; }
private float min Scale ( ) { if ( minimum Scale Type == SCALE TYPE CENTER INSIDE ) { return Math . min ( NUM_ , Math . min ( get Width ( ) / ( float ) s Width ( ) , get Height ( ) / ( float ) s Height ( ) ) ) ; } else { return Math . max ( get Width ( ) / ( float ) s Width ( ) , get Height ( ) / ( float ) s Height ( ) ) ; } }
public Xml Dom child ( String tag , String attr , String value ) { List < Xml Dom > c = children ( tag , attr , value ) ; if ( c . size ( ) == NUM_ ) return null ; return c . get ( NUM_ ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public String summarize Comment ( ) { if ( comment == null ) return null ; String [ ] lines = comment . split ( STR_ ) ; return lines [ NUM_ ] ; }
public static Class check For Prim Type ( String class Name ) { return ( Class ) prim Types . get ( class Name ) ; }
public boolean has Next Line ( ) { save Current Status ( ) ; String result = find Within Horizon ( LINE PATTERN , NUM_ ) ; recover Previous Status ( ) ; return result != null ; }
private static Annotated Null Type create Bottom ( final Annotated Type Factory type Factory , final Set < ? extends Annotation Mirror > annos ) { return type Factory . get Annotated Null Type ( annos ) ; }
public int check Count ( ) { return files Per Keystore Counter ; }
private List < Volume > fetch Volume Details By Id ( List < String > volume Id List ) throws SOS Failure { final String method Name = STR_ ; final String VOLUME DETAIL URI = STR_ ; log . trace ( method Name + STR_ + volume Id List + STR_ ) ; List < Volume > volume Detail List = new Array List < Volume > ( ) ; try { if ( volume Id List != null ) { for ( String volume Id : volume Id List ) { Volume volume = client . query Object ( String . format ( VOLUME DETAIL URI , volume Id ) , Volume . class ) ; if ( volume != null ) { if ( ! volume . is Inactive ( ) && volume . get Id ( ) != null ) { volume Detail List . add ( volume ) ; log . trace ( method Name + volume ) ; } } } } } catch ( No Such Algorithm Exception e ) { log . error ( method Name + STR_ , e ) ; throw new SOS Failure ( e ) ; } catch ( Uniform Interface Exception e ) { log . error ( method Name + STR_ , e ) ; throw new SOS Failure ( e ) ; } log . trace ( method Name + STR_ + volume Detail List . size ( ) + STR_ ) ; return volume Detail List ; }
public Char Seq to Upper Case ( ) { return new Char Seq ( str . to Upper Case ( ) ) ; }
private static boolean equals Handles Nulls ( Local Item a , Local Item b ) { return ( a == b ) || ( ( a != null ) && a . equals ( b ) ) ; }
private Workflow . Method create Mirrors Method ( URI vplex URI , List < URI > vplex Mirror UR Is , String workflow Task Id ) { return new Workflow . Method ( CREATE MIRRORS METHOD NAME , vplex URI , vplex Mirror UR Is , workflow Task Id ) ; }
public final int size ( ) { return m Items . size ( ) ; }
private boolean is The Csrft Wrong ( Request And Response request And Response , String csrft ) { if ( csrft == null || csrft . is Empty ( ) || csrft . length ( ) > NUM_ ) { return true ; } return ! csrft . equals ( get Csrft ( request And Response ) ) ; }
public static String sha 256 Hash ( String string ) throws No Such Algorithm Exception { return sha 256 Hash ( string . get Bytes ( Standard Charsets . UTF 8 ) ) ; }
@ Override public int hash Code ( ) { int result = NUM_ ; result = Hash Utilities . hash Code ( result , this . format String ) ; result = Hash Utilities . hash Code ( result , this . x Format ) ; result = Hash Utilities . hash Code ( result , this . x Date Format ) ; result = Hash Utilities . hash Code ( result , this . y Format ) ; result = Hash Utilities . hash Code ( result , this . y Date Format ) ; return result ; }
protected Object process Key ( String key ) { return argmap . get ( key ) ; }
public int index X ( int k ) { int i = Arrays . binary Search ( this . x Index , k ) ; if ( i >= NUM_ ) { return i ; } else { return - NUM_ * i - NUM_ ; } }
public static Map < Unit , Unit > map Transports To Load Using Min Transports ( final Collection < Unit > units , final Collection < Unit > transports ) { final List < Unit > can Be Transported = sort By Transport Cost Descending ( units ) ; final List < Unit > can Transport = sort By Transport Capacity Descending Then Moves Descending ( transports ) ; final Map < Unit , Unit > mapping = new Hash Map < > ( ) ; Optional < Unit > final Transport = Optional . empty ( ) ; for ( final Unit current Transport : can Transport ) { final int capacity = Transport Tracker . get Available Capacity ( current Transport ) ; final int remaining Cost = get Transport Cost ( can Be Transported ) ; if ( remaining Cost <= capacity ) { if ( ! final Transport . is Present ( ) || capacity < Transport Tracker . get Available Capacity ( final Transport . get ( ) ) ) { final Transport = Optional . of ( current Transport ) ; } continue ; } if ( final Transport . is Present ( ) ) { break ; } load Max Units ( current Transport , can Be Transported , mapping ) ; } if ( final Transport . is Present ( ) ) { load Max Units ( final Transport . get ( ) , can Be Transported , mapping ) ; } return mapping ; }
private double sum Of Constraint Violations ( Solution solution ) { double result = NUM_ ; for ( int i = NUM_ ; i < solution . get Number Of Constraints ( ) ; i ++ ) { result += Math . abs ( solution . get Constraint ( i ) ) ; } return result ; }
static public Timestamp add Days ( Timestamp day , int offset ) { if ( day == null ) day = new Timestamp ( System . current Time Millis ( ) ) ; Gregorian Calendar cal = new Gregorian Calendar ( ) ; cal . set Time ( day ) ; cal . set ( Calendar . HOUR OF DAY , NUM_ ) ; cal . set ( Calendar . MINUTE , NUM_ ) ; cal . set ( Calendar . SECOND , NUM_ ) ; cal . set ( Calendar . MILLISECOND , NUM_ ) ; if ( offset != NUM_ ) cal . add ( Calendar . DAY OF YEAR , offset ) ; java . util . Date temp = cal . get Time ( ) ; return new Timestamp ( temp . get Time ( ) ) ; }
public Period plus Years ( long years To Add ) { if ( years To Add == NUM_ ) { return this ; } return create ( Math . to Int Exact ( Math . add Exact ( years , years To Add ) ) , months , days ) ; }
public boolean is Numerically Identical ( final Plane p ) { if ( Math . abs ( this . y * p . z - this . z * p . y ) >= MINIMUM RESOLUTION ) return false ; if ( Math . abs ( this . z * p . x - this . x * p . z ) >= MINIMUM RESOLUTION ) return false ; if ( Math . abs ( this . x * p . y - this . y * p . x ) >= MINIMUM RESOLUTION ) return false ; final double denom = NUM_ / ( p . x * p . x + p . y * p . y + p . z * p . z ) ; return evaluate Is Zero ( - p . x * p . D * denom , - p . y * p . D * denom , - p . z * p . D * denom ) ; }
public static String alpha Str To Hex Str ( String msg Str ) { String Buffer result = new String Buffer ( ) ; for ( int ofs = NUM_ ; ofs < msg Str . length ( ) ; ofs ++ ) { result . append ( String . format ( STR_ , msg Str . char At ( ofs ) ) ) ; } return ( result . to String ( ) ) ; }
public static List < Accessibility Node Info Compat > search All From Bfs ( Context context , Accessibility Node Info Compat node , Node Filter filter ) { if ( node == null ) { return null ; } final List < Accessibility Node Info Compat > to Return = new Array List < Accessibility Node Info Compat > ( ) ; final Linked List < Accessibility Node Info Compat > queue = new Linked List < Accessibility Node Info Compat > ( ) ; queue . add ( Accessibility Node Info Compat . obtain ( node ) ) ; while ( ! queue . is Empty ( ) ) { final Accessibility Node Info Compat item = queue . remove First ( ) ; if ( filter . accept ( context , item ) ) { to Return . add ( Accessibility Node Info Compat . obtain ( item ) ) ; } final int child Count = item . get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final Accessibility Node Info Compat child = item . get Child ( i ) ; if ( child != null ) { queue . add Last ( child ) ; } } } return to Return ; }
static public String safe Substring ( String text , int begin Index , int end Index Exclusive ) { if ( text == null ) { return null ; } int text Length = text . length ( ) ; if ( begin Index < NUM_ ) { begin Index = NUM_ ; } if ( end Index Exclusive < NUM_ ) { end Index Exclusive = NUM_ ; } if ( end Index Exclusive > text Length ) { end Index Exclusive = text Length ; } if ( begin Index > end Index Exclusive ) { begin Index = end Index Exclusive ; } if ( begin Index == end Index Exclusive ) { return STR_ ; } return text . substring ( begin Index , end Index Exclusive ) ; }
@ Override protected boolean accept ( String property Value ) { int major ; int minor ; Matcher matcher = MAJOR MINOR VERSION PATTERN . matcher ( property Value ) ; if ( matcher . matches ( ) ) { major = Integer . parse Int ( matcher . group ( NUM_ ) ) ; minor = Integer . parse Int ( matcher . group ( NUM_ ) ) ; } else { throw new Runtime Exception ( STR_ + property Value + STR_ ) ; } return unicode Version . major Version > major || ( unicode Version . major Version == major && unicode Version . minor Version >= minor ) ; }
public boolean equals ( Object other ) { if ( other == this ) { return true ; } if ( ! ( other instanceof X 509 CRL Entry ) ) { return false ; } X 509 CRL Entry obj = ( X 509 CRL Entry ) other ; try { return Arrays . equals ( get Encoded ( ) , obj . get Encoded ( ) ) ; } catch ( CRL Exception e ) { return false ; } }
@ Override public int size ( ) { return index To Symbol Map . size ( ) ; }
public boolean is Private ( ) { return Modifier . is Private ( method . get Modifiers ( ) ) ; }
public static Type from String ( String type String ) { for ( Type t : Type . values ( ) ) { if ( type String . equals ( t . value ) ) { return t ; } } return null ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ + STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ + Tag . to Option List ( TAGS RULES ) ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public boolean contains ( Filter Handle filter Callback ) { return callback Set . contains ( filter Callback ) ; }
private int current Depth ( ) { try { Integer one Based = ( ( Integer ) DEPTH FIELD . get ( this ) ) ; return one Based - NUM_ ; } catch ( Illegal Access Exception e ) { throw new Assertion Error ( e ) ; } }
public Band Width create Bandwidth ( String modifier , int value ) { Bandwidth Field band Width Impl = new Bandwidth Field ( ) ; try { band Width Impl . set Type ( modifier ) ; band Width Impl . set Value ( value ) ; } catch ( Sdp Exception s ) { s . print Stack Trace ( ) ; } return band Width Impl ; }
public double pdf ( double x ) { if ( x < NUM_ ) return NUM_ ; return lambda * Math . exp ( - x * lambda ) ; }
@ Deprecated public synchronized boolean is Host Set ( ) { return host != null ; }
public long max Rate ( ) { Long max = null ; for ( Sample s : samples ) { if ( max == null ) { max = new Long ( s . rate ( ) ) ; } max = Math . max ( max , s . rate ( ) ) ; } return max . long Value ( ) ; }
protected final boolean is X Embed Server Requested ( ) { return Access Controller . do Privileged ( new Get Boolean Action ( STR_ ) ) ; }
public static boolean is Monkey Running ( ) { return Activity Manager . is User A Monkey ( ) ; }
public static void validate Composite Data ( Composite Data cd ) { if ( cd == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( ! is Type Matched ( get Base Gc Info Composite Type ( ) , cd . get Composite Type ( ) ) ) { throw new Illegal Argument Exception ( STR_ ) ; } }
protected String double To String ( double d , int prec ) { String result ; int current Prec ; int i ; result = Utils . double To String ( d , prec ) ; if ( result . index Of ( STR_ ) == - NUM_ ) { result += STR_ ; } current Prec = result . length ( ) - result . index Of ( STR_ ) - NUM_ ; for ( i = current Prec ; i < prec ; i ++ ) { result += STR_ ; } return result ; }
public int hash Code ( ) { long v = double To Long Bits ( value ) ; return ( int ) ( v ^ ( v > > > NUM_ ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
@ Override public boolean is File ( ) { return exists ( ) ; }
private Http Entity params To Entity ( Request Params params , Response Handler Interface response Handler ) { Http Entity entity = null ; try { if ( params != null ) { entity = params . get Entity ( response Handler ) ; } } catch ( Throwable t ) { if ( response Handler != null ) response Handler . send Failure Message ( NUM_ , null , null , t ) ; else t . print Stack Trace ( ) ; } return entity ; }
public boolean is Distinct ( ) { return is Distinct ; }
public List < Json Value > values ( ) { return Collections . unmodifiable List ( values ) ; }
public static boolean ends With Char ( String s , char c ) { if ( s . length ( ) == NUM_ ) { return false ; } return s . char At ( s . length ( ) - NUM_ ) == c ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public void wait Until Free ( ) { while ( is Busy ( ) ) { send Empty Message ( BLANK ) ; lock . lock ( ) ; try { if ( is Busy ( ) ) { busy Condition . await ( ) ; } } catch ( Interrupted Exception e ) { throw new Runtime Exception ( e ) ; } finally { lock . unlock ( ) ; } } }
public static boolean valid System Name Config ( String system Name , char type ) { if ( ! valid System Name Format ( system Name , type ) ) { log . warn ( system Name + STR_ ) ; return false ; } Serial Node node = get Node From System Name ( system Name ) ; if ( node == null ) { log . warn ( system Name + STR_ ) ; return false ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STR_ ) || ( type == STR_ ) ) { if ( ( bit <= NUM_ ) || ( bit > Serial Node . output Bytes [ node . node Type ] * NUM_ ) ) { log . warn ( system Name + STR_ ) ; return false ; } } else if ( type == STR_ ) { if ( ( bit <= NUM_ ) || ( bit > Serial Node . input Bytes [ node . node Type ] * NUM_ ) ) { log . warn ( system Name + STR_ ) ; return false ; } } else { log . error ( STR_ ) ; return false ; } return true ; }
protected Map < Integer , List < Solution > > create Grid Map ( ) { Adaptive Grid Archive archive = get Archive ( ) ; Map < Integer , List < Solution > > result = new Hash Map < Integer , List < Solution > > ( ) ; for ( Solution solution : archive ) { int index = archive . find Index ( solution ) ; List < Solution > solutions = result . get ( index ) ; if ( solutions == null ) { solutions = new Array List < Solution > ( ) ; result . put ( index , solutions ) ; } solutions . add ( solution ) ; } return result ; }
@ Response Body @ Request Mapping ( value = STR_ , method = Request Method . GET ) public List < Container Unit > list Container ( @ Path Variable String application Name ) throws Service Exception , Check Exception { logger . debug ( STR_ + application Name ) ; return application Service . list Containers ( application Name ) ; }
int select Server ( int force Index ) { int index = force Index == - NUM_ ? get Less Saturated Index ( ) : force Index ; servers Counters . increment And Get ( index ) ; return index ; }
@ Override public Enumeration < String > enumerate Requests ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; if ( m build Thread != null ) { new Vector . add Element ( STR_ ) ; } return new Vector . elements ( ) ; }
private boolean is Registered For Sub Orgs ( String service Name ) throws SSO Exception { Map av Pair = new Hash Map ( ) ; Set value = new Hash Set ( ) ; value . add ( service Name ) ; av Pair . put ( SERVICE STATUS ATTRIBUTE , value ) ; Set sub Orgs = null ; try { sub Orgs = search Sub Organizational Units ( STR_ , av Pair , SCOPE SUB ) ; } catch ( AM Exception ae ) { } if ( ( sub Orgs != null ) && ( ! sub Orgs . is Empty ( ) ) && ( sub Orgs . size ( ) > NUM_ ) ) { return true ; } else { return false ; } }
private void maybe Throw Exception ( ) throws E { if ( exception != null ) { throw exception ; } }
Class Introspector build ( ) { if ( ( method Appearance Fine Tuner == null || method Appearance Fine Tuner instanceof Singleton Customizer ) && ( method Sorter == null || method Sorter instanceof Singleton Customizer ) ) { Class Introspector instance ; synchronized ( INSTANCE CACHE ) { Reference instance Ref = ( Reference ) INSTANCE CACHE . get ( this ) ; instance = instance Ref != null ? ( Class Introspector ) instance Ref . get ( ) : null ; if ( instance == null ) { Class Introspector Builder this Clone = ( Class Introspector Builder ) clone ( ) ; instance = new Class Introspector ( this Clone , new Object ( ) , true , true ) ; INSTANCE CACHE . put ( this Clone , new Weak Reference ( instance , INSTANCE CACHE REF QUEUE ) ) ; } } remove Cleared References From Instance Cache ( ) ; return instance ; } else { return new Class Introspector ( this , new Object ( ) , true , false ) ; } }
public static double cos ( double radians ) { return Math . cos ( radians ) ; }
public static String slurp URL No Exceptions ( URL u ) { try { return slurp URL ( u ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
private static boolean is Hex Digit ( char c ) { return ( c >= STR_ && c <= STR_ || c >= STR_ && c <= STR_ || c >= STR_ && c <= STR_ ) ; }
public static int Get Line Of P Cal Algorithm ( I Document document ) { try { final String module As String = document . get ( ) ; return Location To Line ( document , TL Ato P Cal Mapping . Get Line Of P Cal Algorithm ( module As String ) ) ; } catch ( Bad Location Exception e ) { e . print Stack Trace ( ) ; } return - NUM_ ; }
public static Constructor < ? > find Injected Ctor ( Class < ? > clazz ) { Constructor < ? > [ ] ctors = clazz . get Declared Constructors ( ) ; for ( Constructor < ? > ctor : ctors ) { if ( is Injected ( ctor ) ) { return ctor ; } } return null ; }
public long encode Coordinate ( double lat ) { return Math . round ( ( lat + NUM_ ) / factor ) ; }
private static String unqualify ( String path ) { path = path . replace ( STR_ , STR_ ) ; return path . substring ( path . last Index Of ( STR_ ) + NUM_ ) ; }
public boolean has Android Plugin ( ) { List < String > plugins = get Plugins ( ) ; return plugins . contains ( Gradle Detector . APP PLUGIN ID ) || plugins . contains ( Gradle Detector . OLD APP PLUGIN ID ) || plugins . contains ( Gradle Detector . LIB PLUGIN ID ) || plugins . contains ( Gradle Detector . OLD LIB PLUGIN ID ) ; }
public boolean empty ( ) { return first == last ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static double from SAX ( int levels , int sax , boolean random ) { SAX ( levels , NUM_ ) ; double [ ] bounds = INVNORM BOUNDS [ levels - NUM_ ] ; if ( sax < NUM_ || sax > bounds . length ) { throw new Runtime Exception ( STR_ ) ; } if ( sax > NUM_ && sax < bounds . length ) { if ( ! random ) { return NUM_ * ( bounds [ sax ] + bounds [ sax - NUM_ ] ) ; } else { double x = Math . random ( ) ; return x * bounds [ sax - NUM_ ] + ( NUM_ - x ) * bounds [ sax ] ; } } if ( NUM_ == sax ) { if ( ! random ) { return bounds [ NUM_ ] - NUM_ * ( bounds [ NUM_ ] - bounds [ NUM_ ] ) ; } else { return bounds [ NUM_ ] - Math . exp ( NUM_ / Math . random ( ) ) ; } } else { if ( ! random ) { return bounds [ bounds . length - NUM_ ] + NUM_ * ( bounds [ bounds . length - NUM_ ] - bounds [ bounds . length - NUM_ ] ) ; } else { return bounds [ bounds . length - NUM_ ] + Math . exp ( NUM_ / Math . random ( ) ) ; } } }
public static Text Line Component [ ] create Components On Run ( int run Start , int run Limit , char [ ] chars , int [ ] chars Lto V , byte [ ] levels , Text Label Factory factory , Font font , Core Metrics cm , Font Render Context frc , Decoration decorator , Text Line Component [ ] components , int num Components ) { int pos = run Start ; do { int chunk Limit = first Visual Chunk ( chars Lto V , levels , pos , run Limit ) ; do { int start Pos = pos ; int lm Count ; if ( cm == null ) { Line Metrics line Metrics = font . get Line Metrics ( chars , start Pos , chunk Limit , frc ) ; cm = Core Metrics . get ( line Metrics ) ; lm Count = line Metrics . get Num Chars ( ) ; } else { lm Count = ( chunk Limit - start Pos ) ; } Text Line Component next Component = factory . create Extended ( font , cm , decorator , start Pos , start Pos + lm Count ) ; ++ num Components ; if ( num Components >= components . length ) { components = expand Array ( components ) ; } components [ num Components - NUM_ ] = next Component ; pos += lm Count ; } while ( pos < chunk Limit ) ; } while ( pos < run Limit ) ; return components ; }
public static boolean is Primitive Type ( int type ) { return type != OBJECT && type != STRING ; }
@ Deprecated protected boolean has Input ( Class < ? extends IO Object > cls ) { try { get Input ( cls ) ; return true ; } catch ( Missing IO Object Exception e ) { return false ; } }
public boolean misbehaved ( ) { boolean is Well Behaved = type == Type . CONVERGE && steps . size ( ) <= NUM_ ; return ! is Well Behaved ; }
List < Named Range > remove Surrogates ( int start Code Point , int end Code Point ) { assert start Code Point <= end Code Point ; if ( start Code Point >= NUM_ && end Code Point <= NUM_ ) { return Collections . empty List ( ) ; } List < Named Range > ranges = new Array List < Named Range > ( ) ; if ( end Code Point < NUM_ || start Code Point > NUM_ ) { ranges . add ( new Named Range ( start Code Point , end Code Point ) ) ; return ranges ; } if ( start Code Point < NUM_ ) { ranges . add ( new Named Range ( start Code Point , NUM_ ) ) ; } if ( end Code Point > NUM_ ) { ranges . add ( new Named Range ( NUM_ , end Code Point ) ) ; } return ranges ; }
private double to Length ( IXML Element elem , String str , double percent Factor ) throws IO Exception { double scale Factor = NUM_ ; if ( str == null || str . length ( ) == NUM_ || str . equals ( STR_ ) ) { return NUM_ ; } if ( str . ends With ( STR_ ) ) { str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; scale Factor = percent Factor ; } else if ( str . ends With ( STR_ ) ) { str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; } else if ( str . ends With ( STR_ ) ) { str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; scale Factor = NUM_ ; } else if ( str . ends With ( STR_ ) ) { str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; scale Factor = NUM_ ; } else if ( str . ends With ( STR_ ) ) { str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; scale Factor = NUM_ ; } else if ( str . ends With ( STR_ ) ) { str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; scale Factor = NUM_ ; } else if ( str . ends With ( STR_ ) ) { str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; scale Factor = NUM_ ; } else if ( str . ends With ( STR_ ) ) { str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; scale Factor = to Length ( elem , read Attribute ( elem , STR_ , STR_ ) , percent Factor ) ; } else { scale Factor = NUM_ ; } return Double . parse Double ( str ) * scale Factor ; }
public CC Vertex 3 D original Vertex ( cc Grid Size pos ) { int index = ( pos . x * ( grid Size . y + NUM_ ) + pos . y ) * NUM_ ; CC Vertex 3 D vert = new CC Vertex 3 D ( original Vertices . get ( index + NUM_ ) , original Vertices . get ( index + NUM_ ) , original Vertices . get ( index + NUM_ ) ) ; return vert ; }
public static String change Case ( String element ) { if ( element == null ) { return null ; } if ( WWN Utility . is Valid WWN ( element ) ) { return element . to Upper Case ( ) ; } else { return element . to Lower Case ( ) ; } }
boolean is Viewable As ( Method Type new Type , boolean keep Interfaces ) { if ( ! Verify Type . is Null Conversion ( return Type ( ) , new Type . return Type ( ) , keep Interfaces ) ) return false ; return parameters Are Viewable As ( new Type , keep Interfaces ) ; }
private boolean is Angle At Back ( double angle ) { return ( Math . sin ( Math . to Radians ( angle ) ) > NUM_ ) ; }
public static void not Whitespace ( final String str , final String name , final int max Length ) { if ( String Utils . is Null Or Whitespace ( str ) || str . length ( ) > max Length ) { final String message = String . format ( STR_ , name , max Length ) ; throw new Illegal Argument Exception ( message ) ; } }
public static String read Ascii Line ( final Input Stream in ) throws IO Exception { final String Builder result = new String Builder ( NUM_ ) ; while ( true ) { final int c = in . read ( ) ; if ( c == - NUM_ ) { throw new EOF Exception ( ) ; } else if ( c == STR_ ) { break ; } result . append ( ( char ) c ) ; } final int length = result . length ( ) ; if ( length > NUM_ && result . char At ( length - NUM_ ) == STR_ ) { result . set Length ( length - NUM_ ) ; } return result . to String ( ) ; }
protected boolean on Send Partial Success ( Record Buffer < R > buffer , Buffer Send Result < R > result ) { send Partial Success . increment And Get ( ) ; logger . debug ( STR_ , name ( ) , buffer , result . sent Record Count ( ) , result . remaining Record Count ( ) ) ; return queue Buffer For Retry ( buffer ) ; }
public boolean should Update Alerts ( ) { if ( alerts last Updated == null ) { alerts last Updated = Calendar . get Instance ( ) ; return true ; } Calendar update Treshold = Calendar . get Instance ( ) ; update Treshold . add ( Calendar . MINUTE , - NUM_ ) ; return alerts last Updated . before ( update Treshold ) ; }
public Vector positive ( ) { return new Vector ( Math . abs ( x ) , Math . abs ( y ) , Math . abs ( z ) ) ; }
protected boolean is Event Disabled ( X Event e ) { if ( enable Log . is Loggable ( Platform Logger . Level . FINEST ) ) { enable Log . finest ( STR_ , e , ( is Enabled ( ) ? STR_ : STR_ ) ) ; } if ( ! is Enabled ( ) ) { switch ( e . get type ( ) ) { case X Constants . Button Press : case X Constants . Button Release : case X Constants . Key Press : case X Constants . Key Release : case X Constants . Enter Notify : case X Constants . Leave Notify : case X Constants . Motion Notify : if ( enable Log . is Loggable ( Platform Logger . Level . FINER ) ) { enable Log . finer ( STR_ , e ) ; } return true ; } } switch ( e . get type ( ) ) { case X Constants . Map Notify : case X Constants . Unmap Notify : return true ; } return super . is Event Disabled ( e ) ; }
public long to Millis ( ) { return time Unit . to Millis ( length ) ; }
public static List < String > deserialize Strings ( String raw Property Value ) { List < String > strings = new Array List < String > ( ) ; if ( raw Property Value != null && raw Property Value . length ( ) > NUM_ ) { return Arrays . as List ( raw Property Value . split ( STR_ ) ) ; } return strings ; }
@ Override public Tree < String > extract Best Max Rule Parse ( int start , int end , List < String > sentence ) { return extract Best Max Rule Parse 1 ( start , end , NUM_ , NUM_ , sentence ) ; }
public Optional < Double > median ( ) { if ( is Empty ( ) ) return Optional . empty ( ) ; return Optional . of ( percentile ( NUM_ ) ) ; }
@ Override public Example Set create Example Set ( Iterator < Attribute Role > new Special Attributes ) { Map < Attribute , String > special Attributes = new Linked Hash Map < > ( ) ; while ( new Special Attributes . has Next ( ) ) { Attribute Role role = new Special Attributes . next ( ) ; special Attributes . put ( role . get Attribute ( ) , role . get Special Name ( ) ) ; } return new Simple Example Set ( this , special Attributes ) ; }
public static boolean require Or Newer ( Version version , Version required ) { int compare = version . compare To ( required ) ; return compare == NUM_ || compare == NUM_ ; }
public static Analyzer Response contains Alert After Modified Message ( Tls Context tls Context ) { int position = get Modified Message Position ( tls Context ) ; if ( position == - NUM_ ) { return Analyzer Response . NO MODIFICATION ; } else { Protocol Message pm = get Next Protocol Message From Peer ( tls Context , position ) ; if ( pm != null && pm . get Protocol Message Type ( ) == Protocol Message Type . ALERT ) { return Analyzer Response . ALERT ; } else { return Analyzer Response . NO ALERT ; } } }
public static boolean equals With Null ( Object o 1 , Object o 2 ) { if ( o 1 == null ) { return o 2 == null ; } return o 2 != null && ( o 1 . equals ( o 2 ) ) ; }
public boolean equals ( Object o ) { return source . equals ( o ) ; }
public String access String ( ) { String Buffer result ; if ( access String != null ) return access String ; result = new String Buffer ( ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; if ( ( access flags & NUM_ ) != NUM_ ) result . append ( STR_ ) ; access String = result . to String ( ) ; return access String ; }
public boolean connected To At Least One Network ( Collection < URI > network Uris ) { if ( network Uris != null ) { if ( network Uris . contains ( id ) ) { return true ; } if ( routed Networks != null ) { List < URI > routed Netowrks = String Set Util . string Set To Uri List ( get Routed Networks ( ) ) ; return ! Collections . disjoint ( network Uris , routed Netowrks ) ; } } return false ; }
@ Override public Enumeration < String > enumerate Requests ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; if ( m visualize Data Set != null ) { new Vector . add Element ( STR_ ) ; } return new Vector . elements ( ) ; }
public static int execute Update Ex ( String sql , Object [ ] params , String trx Name , int time Out ) throws DB Exception { if ( sql == null || sql . length ( ) == NUM_ ) throw new Illegal Argument Exception ( STR_ + sql ) ; verify Trx ( trx Name , sql ) ; int no = - NUM_ ; C Prepared Statement cs = Proxy Factory . new C Prepared Statement ( Result Set . TYPE FORWARD ONLY , Result Set . CONCUR UPDATABLE , sql , trx Name ) ; try { set Parameters ( cs , params ) ; if ( time Out > NUM_ ) cs . set Query Timeout ( time Out ) ; no = cs . execute Update ( ) ; if ( trx Name == null ) { cs . commit ( ) ; } } catch ( Exception e ) { throw new DB Exception ( e ) ; } finally { DB . close ( cs ) ; } return no ; }
public int size ( ) { return arguments != null ? arguments . size ( ) : NUM_ ; }
public static Double Val create ( double d ) { return new Double Val ( d ) ; }
public static String whitespace ( int n ) { if ( n < WHITESPACE BUFFER LENGTH ) { return WHITESPACE BUFFER . substring ( NUM_ , n ) ; } char [ ] buf = new char [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { buf [ i ] = WHITESPACE BUFFER . char At ( NUM_ ) ; } return new String ( buf ) ; }
@ Override public int hash Code ( ) { int result ; long temp ; temp = Double . double To Long Bits ( this . x 0 ) ; result = ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . x 1 ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . y 0 ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . y 1 ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; return result ; }
@ Override public int size ( ) { return this . heap Size ; }
public static boolean is Url ( String resource Location ) { return ( resource Location != null && ( resource Location . starts With ( Resource Pattern Resolver . CLASSPATH ALL URL PREFIX ) || Resource Utils . is Url ( resource Location ) ) ) ; }
public boolean has Static Field Read ( String owner , String method Name , String target Class , String target Field ) { Static Field Read Entry read = new Static Field Read Entry ( owner , method Name , target Class , target Field ) ; return static Field Reads . contains ( read ) ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; new Vector . add ( STR_ ) ; return new Vector . elements ( ) ; }
boolean query Overwrite File ( I File target File , int policy ) { if ( policy != POLICY FORCE OVERWRITE ) { if ( this . overwrite State == OVERWRITE NOT SET && ! query Overwrite ( target File . get Full Path ( ) ) ) { return false ; } if ( this . overwrite State == OVERWRITE NONE ) { return false ; } } return true ; }
public static Element first Child Element ( Element element , String child Element Name ) { if ( element == null ) return null ; if ( Util Validate . is Empty ( child Element Name ) ) return null ; Node node = element . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE && ( child Element Name == null || child Element Name . equals ( node . get Local Name ( ) != null ? node . get Local Name ( ) : node . get Node Name ( ) ) ) ) { Element child Element = ( Element ) node ; return child Element ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return null ; }
private static < E extends F Type > boolean is User Defined Type ( F Type Ref type Ref , Class < E > clazz ) { if ( type Ref == null ) return false ; F Type type = get Actual Derived ( type Ref ) ; if ( type != null ) { if ( clazz . is Instance ( type ) ) { return true ; } } return false ; }
public Rect guaranteed Safe Crop ( int width , int height , @ Nullable Rect crop ) { if ( crop == null ) { return new Rect ( NUM_ , NUM_ , width , height ) ; } Rect safe Crop = new Rect ( crop ) ; if ( crop . top > crop . bottom || crop . left > crop . right || crop . width ( ) <= NUM_ || crop . height ( ) <= NUM_ ) { return new Rect ( NUM_ , NUM_ , NUM_ , NUM_ ) ; } safe Crop . left = Math . max ( safe Crop . left , NUM_ ) ; safe Crop . top = Math . max ( safe Crop . top , NUM_ ) ; safe Crop . right = Math . max ( Math . min ( safe Crop . right , width ) , safe Crop . left ) ; safe Crop . bottom = Math . max ( Math . min ( safe Crop . bottom , height ) , safe Crop . top ) ; if ( safe Crop . width ( ) <= NUM_ || safe Crop . height ( ) <= NUM_ ) { return new Rect ( NUM_ , NUM_ , NUM_ , NUM_ ) ; } return safe Crop ; }
public double [ ] to Euler Angles ( ) { double [ ] ret = new double [ NUM_ ] ; ret [ NUM_ ] = Math . atan 2 ( NUM_ * points [ NUM_ ] * get W ( ) - NUM_ * points [ NUM_ ] * points [ NUM_ ] , NUM_ - NUM_ * ( points [ NUM_ ] * points [ NUM_ ] ) - NUM_ * ( points [ NUM_ ] * points [ NUM_ ] ) ) ; ret [ NUM_ ] = Math . asin ( NUM_ * points [ NUM_ ] * points [ NUM_ ] + NUM_ * points [ NUM_ ] * get W ( ) ) ; ret [ NUM_ ] = Math . atan 2 ( NUM_ * points [ NUM_ ] * get W ( ) - NUM_ * points [ NUM_ ] * points [ NUM_ ] , NUM_ - NUM_ * ( points [ NUM_ ] * points [ NUM_ ] ) - NUM_ * ( points [ NUM_ ] * points [ NUM_ ] ) ) ; return ret ; }
public boolean exists ( ) { return in != null ; }
public static Search Pattern create Or Pattern ( Search Pattern left Pattern , Search Pattern right Pattern ) { return new Or Pattern ( left Pattern , right Pattern ) ; }
public boolean is Set Status ( ) { return isset bit vector . get ( STATUS ISSET ID ) ; }
@ Override public int hash Code ( ) { int hash = NUM_ ; hash = NUM_ * hash + month ; hash = NUM_ * hash + day ; hash = NUM_ * hash + year ; return hash ; }
public int hash Code ( ) { long v = Double . double To Long Bits ( value ) ; return ( int ) ( v ^ ( v > > > NUM_ ) ) ; }
public boolean is leaf ( ) { return children . is Empty ( ) ; }
public int hash Code ( ) { if ( handler == null ) return super . hash Code ( ) ; else return handler . hash Code ( ) ; }
public boolean is Empty ( ) { return resource List . is Empty ( ) ; }
public double next Double ( double degrees Of Freedom ) { if ( degrees Of Freedom <= NUM_ ) throw new Illegal Argument Exception ( ) ; double u , v , w ; do { u = NUM_ * random Generator . raw ( ) - NUM_ ; v = NUM_ * random Generator . raw ( ) - NUM_ ; } while ( ( w = u * u + v * v ) > NUM_ ) ; return ( u * Math . sqrt ( degrees Of Freedom * ( Math . exp ( - NUM_ / degrees Of Freedom * Math . log ( w ) ) - NUM_ ) / w ) ) ; }
private static int skip White Space ( String rawdata , int i ) { int length = rawdata . length ( ) ; if ( i < length ) { char c = rawdata . char At ( i ) ; while ( ( i < length ) && Character . is Whitespace ( c ) ) { ++ i ; c = rawdata . char At ( i ) ; } } return i ; }
protected boolean in Thread Group ( Thread thread ) { return in Thread Group ( thread . get Thread Group ( ) ) ; }
protected static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( NUM_ + r * r ) ; } else if ( b != NUM_ ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( NUM_ + r * r ) ; } else { r = NUM_ ; } return r ; }
public State Set complement ( State Set set ) { if ( set == null ) return null ; State Set result = new State Set ( ) ; result . bits = new long [ set . bits . length ] ; int i ; int m = Math . min ( bits . length , set . bits . length ) ; for ( i = NUM_ ; i < m ; i ++ ) { result . bits [ i ] = ~ bits [ i ] & set . bits [ i ] ; } if ( bits . length < set . bits . length ) System . arraycopy ( set . bits , m , result . bits , m , result . bits . length - m ) ; if ( DEBUG ) Out . dump ( STR_ + this + Out . NL + STR_ + set + Out . NL + STR_ + result ) ; return result ; }
public boolean remove Taxon ( Taxon taxon ) { boolean success = taxa . remove ( taxon ) ; if ( success ) { fire Taxon Removed ( taxon ) ; } return success ; }
public static double next Double ( ) { Random random = get Random ( ) ; double value = random . next Double ( ) ; if ( ! is Test ) free Random List . free ( random ) ; return value ; }
public String min Bucket Size Tip Text ( ) { return STR_ + STR_ ; }
public Enumeration < ? extends Principal > members ( ) { Vector < Principal > v = new Vector < Principal > ( NUM_ ) ; v . add Element ( this ) ; return v . elements ( ) ; }
public boolean is Primitive ( ) { char tcode = signature . char At ( NUM_ ) ; return ( ( tcode != STR_ ) && ( tcode != STR_ ) ) ; }
public static String hash SHA ( String str ) { byte [ ] b = str . get Bytes ( ) ; Message Digest md = null ; try { md = Message Digest . get Instance ( STR_ ) ; md . update ( b ) ; } catch ( No Such Algorithm Exception e ) { e . print Stack Trace ( ) ; } return to Hex String ( md . digest ( ) ) ; }
boolean is Last Position ( int position ) { return position == ( item List . size ( ) - NUM_ ) ; }
public int pixel For ( int rgb ) { return surface Type . pixel For ( rgb , color Model ) ; }
public boolean is Transaction Mapped ( ) { return this . is Mapped ; }
public CC Vertex 3 D vertex ( cc Grid Size pos ) { int index = ( pos . x * ( grid Size . y + NUM_ ) + pos . y ) * NUM_ ; CC Vertex 3 D vert = new CC Vertex 3 D ( vertices . get ( index + NUM_ ) , vertices . get ( index + NUM_ ) , vertices . get ( index + NUM_ ) ) ; return vert ; }
public boolean connected To Network ( URI network Uri ) { if ( network Uri != null ) { if ( network Uri . equals ( id ) ) { return true ; } if ( routed Networks != null ) { return routed Networks . contains ( network Uri . to String ( ) ) ; } } return false ; }
public static boolean parse Boolean ( String s ) { char ch = s . length ( ) > NUM_ ? s . char At ( NUM_ ) : NUM_ ; return ( ch == STR_ || ch == STR_ || ch == STR_ ) ; }
public boolean can Undo ( ) { return ( m Undo . size ( ) > NUM_ ) ; }
public static int [ ] expand ( int [ ] field , int new Size , boolean keep Data ) { if ( field == null || field . length < new Size ) { int [ ] new Array = new int [ new Size ] ; if ( keep Data && field != null ) { System . arraycopy ( field , NUM_ , new Array , NUM_ , field . length ) ; } return new Array ; } return field ; }
private boolean has Space To Draw ( int previous Position , int tick Label Position , String previous Tick Label , String tick Label ) { Dimension tick Label Size = Figure Utilities . get Text Extents ( tick Label , scale . get Font ( ) ) ; Dimension previous Tick Label Size = Figure Utilities . get Text Extents ( previous Tick Label , scale . get Font ( ) ) ; int interval = tick Label Position - previous Position ; int text Length = ( int ) ( scale . is Horizontal ( ) ? ( tick Label Size . width / NUM_ + previous Tick Label Size . width / NUM_ ) : tick Label Size . height ) ; boolean no Lap On Prevoius = true ; boolean no Lap On End = true ; if ( tick Label Position != tick Label Positions . get ( tick Label Positions . size ( ) - NUM_ ) ) { no Lap On Prevoius = interval > ( text Length + TICK LABEL GAP ) ; Dimension end Tick Label Size = Figure Utilities . get Text Extents ( tick Labels . get ( tick Labels . size ( ) - NUM_ ) , scale . get Font ( ) ) ; interval = tick Label Positions . get ( tick Label Positions . size ( ) - NUM_ ) - tick Label Position ; text Length = ( int ) ( scale . is Horizontal ( ) ? ( tick Label Size . width / NUM_ + end Tick Label Size . width / NUM_ ) : tick Label Size . height ) ; no Lap On End = interval > text Length + TICK LABEL GAP ; } return no Lap On Prevoius && no Lap On End ; }
public static Timestamp to Timestamp ( Date d ) { return new Timestamp ( d . get Time ( ) ) ; }
public Object clone ( ) throws Clone Not Supported Exception { return super . clone ( ) ; }
@ Suppress Warnings ( STR_ ) public static < K extends Throwable > void throw If Instance ( Throwable t , Class < K > clazz ) throws K { if ( ( t != null ) && clazz . is Assignable From ( t . get Class ( ) ) ) { K kt = ( K ) t ; throw kt ; } }
public void compute Package Fragment Roots ( I Classpath Entry [ ] resolved Classpath , Object Vector accumulated Roots , Hash Set root I Ds , I Classpath Entry referring Entry , boolean retrieve Exported Roots , Map root To Resolved Entries ) throws Java Model Exception { if ( referring Entry == null ) { root I Ds . add ( root ID ( ) ) ; } for ( int i = NUM_ , length = resolved Classpath . length ; i < length ; i ++ ) { compute Package Fragment Roots ( resolved Classpath [ i ] , accumulated Roots , root I Ds , referring Entry , retrieve Exported Roots , root To Resolved Entries ) ; } }
@ Override protected double evaluate ( int id 1 , int id 2 , Instance inst 1 ) throws Exception { if ( id 1 == id 2 ) { return NUM_ ; } else { double precalc 1 ; if ( id 1 == - NUM_ ) { precalc 1 = dot Prod ( inst 1 , inst 1 ) ; } else { precalc 1 = m kernel Precalc [ id 1 ] ; } Instance inst 2 = m data . instance ( id 2 ) ; double squared Difference = - NUM_ * dot Prod ( inst 1 , inst 2 ) + precalc 1 + m kernel Precalc [ id 2 ] ; double intermediate = m factor * Math . sqrt ( squared Difference ) ; double result = NUM_ / Math . pow ( NUM_ + intermediate * intermediate , get Omega ( ) ) ; return result ; } }
protected static Long min ( Long l 1 , Long l 2 ) { if ( l 1 == null && l 2 == null ) { return null ; } if ( l 2 == null ) { return l 1 ; } if ( l 1 == null ) { return l 2 ; } return Math . min ( l 1 , l 2 ) ; }
public static boolean contains Entry ( File file , String entry Path ) { if ( file . can Read ( ) ) { try { Jar File jar File = new Jar File ( file ) ; try { return jar File . get Entry ( entry Path ) != null ; } finally { jar File . close ( ) ; } } catch ( IO Exception ignored ) { } } return false ; }
public Header Iterator iterator ( ) { return new Basic List Header Iterator ( this . headers , null ) ; }
private Element create Single Log Out For Castle As SP ( String binding ) throws Exception { String entity ID = idm Client . get Entity ID ( tenant Name ) ; String sso Loc = convert To IPV 6 Short Form ( entity ID ) ; if ( sso Loc == null ) { sso Loc = tenant Name ; } String slo Loc = sso Loc . replace All ( STR_ , SAML Names . SP SINGLELOGOUTSERVICE PLACEHOLDER ) ; Element slos Ele = create End Point ( SAML Names . SLOS , binding , slo Loc , null ) ; return slos Ele ; }
public boolean is Interface ( ) { lazy Load ( ) ; return Modifier . is Interface ( access Flags ) ; }
public static Number max ( Number a , Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return Math . max ( a . double Value ( ) , b . double Value ( ) ) ; } else { return Math . max ( a . long Value ( ) , b . long Value ( ) ) ; } }
public boolean supports Params ( ) { return false ; }
public static double round ( double number , int n Digits ) { return ( double ) Math . round ( number * Math . pow ( NUM_ , n Digits ) ) / Math . pow ( NUM_ , n Digits ) ; }
@ Override public final void sample ( ) { long count = count . get ( ) ; long last Count = last Count . get And Set ( count ) ; value = count - last Count ; }
public Object [ ] to Array ( ) { return Arrays . copy Of ( element Data , size ) ; }
public static boolean is Vplex Initiator ( Initiator initiator , Db Client db Client ) { Storage Port port = Network Util . get Storage Port ( initiator . get Initiator Port ( ) , db Client ) ; if ( null != port ) { Storage System vplex = db Client . query Object ( Storage System . class , port . get Storage Device ( ) ) ; if ( null != vplex && VPLEX . equals ( vplex . get System Type ( ) ) ) { return true ; } } return false ; }
public String next Token ( ) { if ( current Position >= max Position ) { throw new No Such Element Exception ( ) ; } int start = current Position ; while ( ( current Position < max Position ) && Character . is Letter Or Digit ( str . char At ( current Position ) ) ) { current Position ++ ; } if ( ( start == current Position ) && ( ! Character . is Letter Or Digit ( str . char At ( current Position ) ) ) ) { current Position ++ ; } return str . substring ( start , current Position ) ; }
public boolean is Destroy Message ( ) { if ( message == null ) { throw new Illegal State Exception ( STR_ ) ; } return ! callee . equals ( STR_ ) && ( message . equals ( STR_ ) || message . starts With ( STR_ ) ) ; }
public int num Of Diff Objects ( ) { return ready To Use ? out List . size ( ) : table View . size ( ) ; }
private static boolean is Numeric Token ( String token ) { int token Len = token . length ( ) ; if ( token Len > NUM_ ) { char c = token . char At ( NUM_ ) ; switch ( c ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : return true ; case STR_ : if ( token Len <= NUM_ ) { return true ; } } } return false ; }
@ Override public int last Index Of ( Object o ) { if ( o == null ) { for ( int i = end - NUM_ ; i >= start ; i -- ) { if ( buffer [ i ] == null ) { return i - start ; } } } else { for ( int i = end - NUM_ ; i >= start ; i -- ) { if ( o . equals ( buffer [ i ] ) ) { return i - start ; } } } return - NUM_ ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static void close Silently ( Statement stat ) { if ( stat != null ) { try { stat . close ( ) ; } catch ( SQL Exception e ) { } } }
boolean configuring ( ) { return configuring > NUM_ ; }
public static List < Point 2 D > intersection ( final Shape s 1 , final Shape s 2 ) { List < Point 2 D > intersections = new Array List < Point 2 D > ( NUM_ ) ; Line 2 D [ ] lines 1 = shape To Lines ( s 1 , false ) ; Line 2 D [ ] lines 2 = shape To Lines ( s 2 , false ) ; for ( Line 2 D l 1 : lines 1 ) { for ( Line 2 D l 2 : lines 2 ) { Point 2 D intersection = intersection ( l 1 , l 2 ) ; if ( intersection != null ) { intersections . add ( intersection ) ; } } } return intersections ; }
public boolean has Current Topic ( ) { synchronized ( this . topics Queue ) { return ( this . current Topic != null ) ; } }
public Pla Point Float middle point ( Pla Point Float p to point ) { if ( p to point == this ) return this ; double middle x = NUM_ * ( v x + p to point . v x ) ; double middle y = NUM_ * ( v y + p to point . v y ) ; return new Pla Point Float ( middle x , middle y ) ; }
static URI uri For Class ( String type Name ) { try { return new URI ( STR_ + type Name . replace All ( STR_ , STR_ ) + STR_ ) ; } catch ( URI Syntax Exception e ) { throw Throwables . propagate ( e ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + get Stemmer List ( NUM_ , STR_ ) , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
@ Safe Varargs public static < T > List < T > as List ( final T ... array ) { List < T > array List = new Array List < T > ( array . length ) ; Collections . add All ( array List , array ) ; return array List ; }
@ Override public Segment Infos clone ( ) { try { final Segment Infos sis = ( Segment Infos ) super . clone ( ) ; sis . segments = new Array List < > ( size ( ) ) ; for ( final Segment Commit Info info : this ) { assert info . info . get Codec ( ) != null ; sis . add ( info . clone ( ) ) ; } sis . user Data = new Hash Map < > ( user Data ) ; return sis ; } catch ( Clone Not Supported Exception e ) { throw new Runtime Exception ( STR_ , e ) ; } }
static int inner New Vec Insert Pos ( int old Pos , int idx , Vector < Insertion > vec ) { if ( vec . size ( ) <= idx ) { return old Pos ; } else { return inner New Vec Insert Pos ( new Insert Pos ( old Pos , vec . element At ( idx ) ) , idx + NUM_ , vec ) ; } }
public boolean is Src Class ( Soot Class clz ) { return is Src Class ( clz . get Name ( ) ) ; }
public static boolean has Three Ten ( ) { try { Class . for Name ( STR_ ) ; return true ; } catch ( Class Not Found Exception e ) { return false ; } }
private boolean check Initial Image For Reliability ( Internal Distributed Member image Target , Cache Distribution Advisor . Initial Image Advice advice ) { return false ; }
public static List < URI > iterator To List ( URI Query Result List itr ) { List < URI > uris = new Array List < URI > ( ) ; for ( URI uri : itr ) { uris . add ( uri ) ; } return uris ; }
private static Help Node from Xml ( Input Source source ) throws Parser Configuration Exception , SAX Exception , IO Exception { SAX Parser Factory factory = SAX Parser Factory . new Instance ( ) ; SAX Parser parser = factory . new SAX Parser ( ) ; Help Reader reader = new Help Reader ( ) ; parser . parse ( source , reader ) ; return reader . root ; }
protected boolean is Any Member Running ( ) { return find First Running Member ( ) != null ; }
int pure Length ( ) { return length - delimiter . length ( ) ; }
public I Basic Option changed Option ( ) { return new Basic Option ( option . get Name ( ) , get Value ( ) ) ; }
public boolean verify Token ( String data , String signature ) { if ( signature . length ( ) == NUM_ ) { return false ; } try { return signing Key . verify ( data , signature ) ; } catch ( Keyczar Exception e ) { return false ; } }
public static Point 2 D intersection ( final Line 2 D l 1 , final Line 2 D l 2 ) { Point 2 D p 0 = l 1 . get P 1 ( ) ; Point 2 D d 0 = new Point 2 D . Double ( l 1 . get X 2 ( ) - p 0 . get X ( ) , l 1 . get Y 2 ( ) - p 0 . get Y ( ) ) ; Point 2 D p 1 = l 2 . get P 1 ( ) ; Point 2 D d 1 = new Point 2 D . Double ( l 2 . get X 2 ( ) - p 1 . get X ( ) , l 2 . get Y 2 ( ) - p 1 . get Y ( ) ) ; Point 2 D e = new Point 2 D . Double ( p 1 . get X ( ) - p 0 . get X ( ) , p 1 . get Y ( ) - p 0 . get Y ( ) ) ; double kross = d 0 . get X ( ) * d 1 . get Y ( ) - d 0 . get Y ( ) * d 1 . get X ( ) ; double sqr Kross = kross * kross ; double sqr Len 0 = d 0 . distance Sq ( NUM_ , NUM_ ) ; double sqr Len 1 = d 1 . distance Sq ( NUM_ , NUM_ ) ; if ( sqr Kross > EPSILON SQ * sqr Len 0 * sqr Len 1 ) { double s = ( e . get X ( ) * d 1 . get Y ( ) - e . get Y ( ) * d 1 . get X ( ) ) / kross ; if ( s < NUM_ || s > NUM_ ) { return null ; } double t = ( e . get X ( ) * d 0 . get Y ( ) - e . get Y ( ) * d 0 . get X ( ) ) / kross ; if ( t < NUM_ || t > NUM_ ) { return null ; } return new Point 2 D . Double ( p 0 . get X ( ) + s * d 0 . get X ( ) , p 0 . get Y ( ) + s * d 0 . get Y ( ) ) ; } return null ; }
protected int index Of Decimal Point ( String s ) { int i = s . last Index Of ( STR_ ) ; if ( i < NUM_ ) i = s . last Index Of ( STR_ ) ; if ( i < NUM_ ) i = s . last Index Of ( STR_ ) ; if ( i < NUM_ ) i = s . length ( ) ; return i ; }
public String param String ( ) { String type Str ; switch ( id ) { case INPUT METHOD TEXT CHANGED : type Str = STR_ ; break ; case CARET POSITION CHANGED : type Str = STR_ ; break ; default : type Str = STR_ ; } String text String ; if ( text == null ) { text String = STR_ ; } else { String Builder text Buffer = new String Builder ( STR_ ) ; int committed Character Count = this . committed Character Count ; char c = text . first ( ) ; while ( committed Character Count -- > NUM_ ) { text Buffer . append ( c ) ; c = text . next ( ) ; } text Buffer . append ( STR_ ) ; while ( c != Character Iterator . DONE ) { text Buffer . append ( c ) ; c = text . next ( ) ; } text Buffer . append ( STR_ ) ; text String = text Buffer . to String ( ) ; } String count String = committed Character Count + STR_ ; String caret String ; if ( caret == null ) { caret String = STR_ ; } else { caret String = STR_ + caret . to String ( ) ; } String visible Position String ; if ( visible Position == null ) { visible Position String = STR_ ; } else { visible Position String = STR_ + visible Position . to String ( ) ; } return type Str + STR_ + text String + STR_ + count String + STR_ + caret String + STR_ + visible Position String ; }
private int extend ( final int required ) { final int capacity = Math . max ( required , capacity ( ) * NUM_ ) ; if ( log . is Info Enabled ( ) ) log . info ( STR_ + capacity + STR_ ) ; return capacity ; }
public boolean check Root By Super User Apk ( ) { File su Apk = new File ( SU APK ) ; if ( su Apk . exists ( ) ) { if ( Constants . DEBUG MODE ENABLED ) { Log . d ( TAG , STR_ ) ; } return true ; } return false ; }
public Assignment remove Primes ( ) { Assignment a = new Assignment ( ) ; for ( String var : map . key Set ( ) ) { if ( ! map . contains Key ( var + STR_ ) ) { boolean has Prime = ( var . char At ( var . length ( ) - NUM_ ) == STR_ ) ; String new Var = ( has Prime ) ? var . substring ( NUM_ , var . length ( ) - NUM_ ) : var ; a . add Pair ( new Var , map . get ( var ) ) ; } } return a ; }
public I Point next ( ) { if ( stack . empty ( ) ) { throw new java . util . No Such Element Exception ( STR_ ) ; } Moment m = stack . peek ( ) ; advance ( ) ; return m . node . point ; }
private static int index Of ( int from Index , Char Sequence csq ) { if ( csq == null ) return NUM_ ; int length = csq . length ( ) ; int j = from Index ; int i = ( j < length ) ? Character . to Upper Case ( csq . char At ( j ++ ) ) : NUM_ ; i <<= NUM_ ; i |= ( j < length ) ? Character . to Upper Case ( csq . char At ( j ++ ) ) : NUM_ ; return i ; }
public static String name Of ( final Command Name name ) { if ( name instanceof Nested Command Name Impl ) { return name Of ( ( ( Nested Command Name Impl ) name ) . parent ) + STR_ + name . value ( ) ; } return name . value ( ) ; }
public boolean engine Can Resolve ( Element element , String base URI , Storage Resolver storage ) { return XML Utils . element Is In Signature Space ( element , Constants . TAG KEYNAME ) ; }
public static Mime Type from File ( final File file ) { final String file Name = file . get Name ( ) ; final Mime Type mime Type = from File Name ( file Name ) ; return mime Type ; }
private double manhattan Segmental Distance ( Number Vector o 1 , double [ ] o 2 , long [ ] dimensions ) { double result = NUM_ ; int card = NUM_ ; for ( int d = Bits Util . next Set Bit ( dimensions , NUM_ ) ; d >= NUM_ ; d = Bits Util . next Set Bit ( dimensions , d + NUM_ ) ) { result += Math . abs ( o 1 . double Value ( d ) - o 2 [ d ] ) ; ++ card ; } result /= card ; return result ; }
public static String map 2 OID ( String alg Name ) { check Cache Version ( ) ; String result = alg 2 Oid Map . get ( alg Name . to Upper Case ( Locale . US ) ) ; if ( result != null ) { return result ; } Alg Name Mapper Source s = source ; if ( s != null ) { return s . map Name To Oid ( alg Name ) ; } return null ; }
public boolean has Squidb Option ( String option ) { return squidb Options . contains ( option ) ; }
public static void sleep ( long ms ) { try { Thread . sleep ( ms ) ; } catch ( Interrupted Exception iex ) { } }
public Buffer Iterator big Endian Iterator ( ) { return new Nio Buffer Iterator ( address , ( int ) size , Byte Order . native Order ( ) != Byte Order . BIG ENDIAN ) ; }
public static Collection < Communication Summary Statistics > build Communication Summary Tree ( Collection < Communication Summary Statistics > nodes , Set < String > endpoints ) { Map < String , Communication Summary Statistics > node Map = new Hash Map < String , Communication Summary Statistics > ( ) ; for ( Communication Summary Statistics css : nodes ) { node Map . put ( css . get Id ( ) , css ) ; } List < Communication Summary Statistics > ret = new Array List < > ( ) ; for ( String endpoint : endpoints ) { Communication Summary Statistics n = node Map . get ( Endpoint Util . encode Client URI ( endpoint ) ) ; if ( n == null ) { n = node Map . get ( endpoint ) ; } if ( n != null ) { Communication Summary Statistics root Node = new Communication Summary Statistics ( n ) ; init Communication Summary Tree Node ( root Node , node Map , new Hash Set < > ( Collections . singleton ( root Node . get Id ( ) ) ) ) ; ret . add ( root Node ) ; } } return ret ; }
void return View To Pool ( V v ) { m View Creator . prepare View To Enter Pool ( v ) ; m Pool . push ( v ) ; }
public Iterator < Detector Factory > factory Iterator ( ) { return factory List . iterator ( ) ; }
private boolean fill Buffer ( ) { while ( buffer . count ( ) == NUM_ ) { if ( buffer Sink . cancellation Requested ( ) || ! pusher . get As Boolean ( ) ) { if ( finished ) return false ; else { buffer Sink . end ( ) ; finished = true ; } } } return true ; }
public static double euclidean Distance ( float [ ] p , float [ ] q ) { double ret = NUM_ ; for ( int i = NUM_ ; i < p . length ; i ++ ) { double diff = ( q [ i ] - p [ i ] ) ; double sq = Math . pow ( diff , NUM_ ) ; ret += sq ; } return ret ; }
private static Ade Exception ade Exception Of ( Throwable t ) { if ( t instanceof Ade Exception ) { return ( Ade Exception ) t ; } else { return new Ade Internal Exception ( STR_ + t . get Message ( ) + STR_ , t ) ; } }
private boolean is Circular No Side Effect ( int reg V , Bit Set set ) { if ( ( set != null ) && set . get ( reg V ) ) { return true ; } for ( Ssa Insn use : use List [ reg V ] ) { if ( has Side Effect ( use ) ) { return false ; } } if ( set == null ) { set = new Bit Set ( reg Count ) ; } set . set ( reg V ) ; for ( Ssa Insn use : use List [ reg V ] ) { Register Spec result = use . get Result ( ) ; if ( result == null || ! is Circular No Side Effect ( result . get Reg ( ) , set ) ) { return false ; } } return true ; }
public static final Vector 2 [ ] cleanse ( Vector 2 ... points ) { if ( points == null ) throw new Null Pointer Exception ( Messages . get String ( STR_ ) ) ; List < Vector 2 > point List = Arrays . as List ( points ) ; List < Vector 2 > result List = Geometry . cleanse ( point List ) ; Vector 2 [ ] result = new Vector 2 [ result List . size ( ) ] ; result List . to Array ( result ) ; return result ; }
public int size ( ) { return productions . size ( ) ; }
public boolean is Empty ( ) { return type String . length ( ) == NUM_ ; }
public boolean is In Auto Complete ( String word ) { synchronized ( auto Complete List ) { String lcw = word . to Lower Case ( ) ; return auto Complete List . contains Key ( lcw ) ; } }
public Set < String > known Classes ( ) { Set < String > r = new Hash Set < String > ( ) ; r . add All ( branch Map . key Set ( ) ) ; r . add All ( branchless Methods . key Set ( ) ) ; if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ + r ) ; } return r ; }
private void apply Lower Bounds ( final List < ? extends Annotation Mirror > annos ) { if ( ! annos . is Empty ( ) ) { final Annotated Type Mirror lower Bound = type Param . get Lower Bound ( ) ; for ( Annotation Mirror anno : annos ) { lower Bound . add Annotation ( anno ) ; } } }
public static double sin ( double radians ) { return Math . sin ( radians ) ; }
static String cos Name To Ins String ( Name Component [ ] cname ) { String Buffer str = new String Buffer ( ) ; for ( int i = NUM_ ; i < cname . length ; i ++ ) { if ( i > NUM_ ) { str . append ( comp Separator ) ; } str . append ( stringify Component ( cname [ i ] ) ) ; } return str . to String ( ) ; }
private static Invocation Constraint [ ] concat ( Invocation Constraint [ ] arr 1 , Invocation Constraint [ ] arr 2 ) { Invocation Constraint [ ] res = new Invocation Constraint [ arr 1 . length + arr 2 . length ] ; System . arraycopy ( arr 1 , NUM_ , res , NUM_ , arr 1 . length ) ; System . arraycopy ( arr 2 , NUM_ , res , arr 1 . length , arr 2 . length ) ; return res ; }
public Block block ( ) { return block ; }
private void send SMS ( String message , String contact Information ) { Resolved Contact rc = m Contacts Resolver . resolve Contact ( contact Information , Contacts Resolver . TYPE CELL ) ; if ( rc == null ) { send ( R . string . chat no match for , contact Information ) ; } else if ( rc . is Distinct ( ) ) { send SMS By Phone Number ( message , rc . get Number ( ) , rc . get Name ( ) ) ; } else { ask For More Details ( rc . get Candidates ( ) ) ; } }
public static Search Pattern create And Pattern ( Search Pattern left Pattern , Search Pattern right Pattern ) { return new And Pattern ( left Pattern , right Pattern ) ; }
public double negative Ratio ( ) { return ( double ) negatives / ( double ) occupied Bits ; }
public static Process Registry locate Registry ( int port ) throws Registry Exception { try { Registry registry = Locate Registry . get Registry ( port ) ; Process Registry process Registry = new Process Registry ( port , registry ) ; return process Registry ; } catch ( Remote Exception e ) { throw new Registry Exception ( STR_ + port + STR_ , e ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static double log Bin Coeff ( int n , int k ) { if ( k > n ) throw new Illegal Argument Exception ( STR_ + n + STR_ + k + STR_ ) ; else if ( k == NUM_ || k == n ) return Math . log ( NUM_ ) ; double r = NUM_ ; for ( int d = NUM_ ; d <= k ; d ++ ) r += Math . log ( n - ( k - d ) ) - Math . log ( d ) ; return r ; }
default void for Each Remaining ( Long Consumer action ) { Objects . require Non Null ( action ) ; while ( has Next ( ) ) action . accept ( next Long ( ) ) ; }
public static String create Path ( String ... elements ) { String Builder result = new String Builder ( ) ; for ( String element : elements ) { result . append ( File . path Separator ) ; result . append ( element ) ; } return result . to String ( ) ; }
public int hash Code ( ) { int rest = ( ( copies + from Page + max Page + min Page + pr First + pr Last + to Page ) * NUM_ ) << NUM_ ; if ( page Ranges != null ) { int sum = NUM_ ; for ( int i = NUM_ ; i < page Ranges . length ; i ++ ) { sum += page Ranges [ i ] [ NUM_ ] + page Ranges [ i ] [ NUM_ ] ; } rest ^= ( sum * NUM_ ) << NUM_ ; } if ( file Name != null ) { rest ^= file Name . hash Code ( ) ; } if ( printer != null ) { rest ^= printer . hash Code ( ) ; } return ( default Selection . hash Code ( ) << NUM_ ^ destination . hash Code ( ) << NUM_ ^ dialog . hash Code ( ) << NUM_ ^ multiple Document Handling . hash Code ( ) << NUM_ ^ sides . hash Code ( ) ^ rest ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static char [ ] copy ( final char [ ] array ) { char [ ] next = new char [ array . length ] ; System . arraycopy ( array , NUM_ , next , NUM_ , array . length ) ; return next ; }
@ Override synchronized public boolean is Inbound Done ( ) { return inbound Done ; }
public Set < String > key Names ( String prefix ) { Set < String > keys = key Names ( ) ; Hash Set < String > subset = new Hash Set < String > ( ) ; for ( String key : keys ) { if ( key != null && key . starts With ( prefix ) ) subset . add ( key ) ; } return subset ; }
private File session Store ( String ctx Path ) { String store Dir = System . get Property ( STR_ ) ; if ( store Dir == null || store Dir . is Empty ( ) ) { store Dir = System . get Property ( STR_ ) ; } else { store Dir += System . get Property ( STR_ ) + STR_ ; } File file = new File ( store Dir , ctx Path . replace All ( STR_ , STR_ ) + STR_ ) ; return ( file ) ; }
public int hash Code ( ) { return group . hash Code ( ) ; }
protected static Variable find Target Variable ( Variable Expression ve ) { final Variable accessed Variable = ve . get Accessed Variable ( ) != null ? ve . get Accessed Variable ( ) : ve ; if ( accessed Variable != ve ) { if ( accessed Variable instanceof Variable Expression ) return find Target Variable ( ( Variable Expression ) accessed Variable ) ; } return accessed Variable ; }
public final int count Data Paths ( ) { return m Data Paths != null ? m Data Paths . size ( ) : NUM_ ; }
public Set < String > keys ( ) { Set < String > keys = new Hash Set < String > ( ) ; keys . add All ( pmap . key Set ( ) ) ; return keys ; }
public boolean is Known ( ) { return index != - NUM_ ; }
public boolean is Public ( ) { return Modifier . is Public ( method . get Modifiers ( ) ) ; }
final boolean is Reflex ( Ear Clipping Vertex vertex ) { Vector 2 p = vertex . point ; Vector 2 p 0 = vertex . prev . point ; Vector 2 p 1 = vertex . next . point ; Vector 2 v 1 = p . to ( p 0 ) ; Vector 2 v 2 = p . to ( p 1 ) ; if ( v 1 . cross ( v 2 ) < NUM_ ) { return false ; } else { return true ; } }
public int size ( ) { return elements . size ( ) ; }
long next Connection Sequence ( ) { return connection Sequence . increment And Get ( ) ; }
public static synchronized boolean is Empty ( ) { return services . is Empty ( ) ; }
public static String gerund Form ( final String word ) { if ( word . length ( ) > NUM_ ) { char last = word . char At ( word . length ( ) - NUM_ ) ; if ( last == STR_ || last == STR_ ) { return word + STR_ ; } else if ( is Vowel ( last ) ) { return word . substring ( NUM_ , word . length ( ) - NUM_ ) + STR_ ; } else if ( is Vowel ( word . char At ( word . length ( ) - NUM_ ) ) ) { return word + word . char At ( word . length ( ) - NUM_ ) + STR_ ; } } return word + STR_ ; }
public boolean dominates ( Region Version Vector < T > other ) { return ! other . is Newer Than Or Can Fill Exceptions For ( this ) ; }
private String extract Boundary ( String line ) { int index = line . last Index Of ( STR_ ) ; if ( index == - NUM_ ) { return null ; } String boundary = line . substring ( index + NUM_ ) ; if ( boundary . char At ( NUM_ ) == STR_ ) { index = boundary . last Index Of ( STR_ ) ; boundary = boundary . substring ( NUM_ , index ) ; } boundary = STR_ + boundary ; return boundary ; }
private static boolean has Selection Handle ( final P Node node ) { for ( Iterator i = node . get Children Iterator ( ) ; i . has Next ( ) ; ) { P Node n = ( P Node ) i . next ( ) ; if ( n instanceof Source Handle ) { return true ; } } return false ; }
static String encode ( Byte Buffer Range range ) { String start = Hex . encode Hex String ( to Array ( range . get Start ( ) ) ) ; String end = Hex . encode Hex String ( to Array ( range . get End ( ) ) ) ; int prefix = get Common Prefix Length ( start , end ) ; return start . substring ( NUM_ , prefix ) + STR_ + start . substring ( prefix ) + STR_ + end . substring ( prefix ) ; }
public static List < String > expand Wildcards ( File dir , List < String > modules , Backend for Backend ) { List < File > dirs = new Array List < File > ( ) ; dirs . add ( dir ) ; return expand Wildcards ( dirs , modules , for Backend ) ; }
private Rect F calc Text Bounds ( String text , Paint text Paint , Rect F text Bounds ) { Rect text Bounds Tmp = new Rect ( ) ; text Paint . get Text Bounds ( text , NUM_ , text . length ( ) , text Bounds Tmp ) ; float width = text Bounds Tmp . left + text Bounds Tmp . width ( ) ; float height = text Bounds Tmp . bottom + text Bounds Tmp . height ( ) * NUM_ ; Rect F text Rect = new Rect F ( ) ; text Rect . left = ( text Bounds . left + ( ( text Bounds . width ( ) - width ) / NUM_ ) ) ; text Rect . top = text Bounds . top + ( ( text Bounds . height ( ) - height ) / NUM_ ) ; text Rect . right = text Rect . left + width ; text Rect . bottom = text Rect . top + height ; return text Rect ; }
public Shard Iterator primary Shard It ( ) { return new Plain Shard Iterator ( shard Id , primary As List ) ; }
public Text Character with Modifiers ( Collection < SGR > modifiers ) { Enum Set < SGR > new Set = Enum Set . copy Of ( modifiers ) ; if ( modifiers . equals ( new Set ) ) { return this ; } return new Text Character ( character , foreground Color , background Color , new Set ) ; }
public boolean is Autoscaled ( ) { return autoscaled ; }
public String dimensons To String ( ) { return dimensons To String ( STR_ ) ; }
public static List < String > local Text ( Element self ) { List < String > result = new Array List < String > ( ) ; if ( self . get Node Type ( ) == Node . TEXT NODE || self . get Node Type ( ) == Node . CDATA SECTION NODE ) { result . add ( self . get Node Value ( ) ) ; } else if ( self . has Child Nodes ( ) ) { Node List node List = self . get Child Nodes ( ) ; for ( int i = NUM_ ; i < node List . get Length ( ) ; i ++ ) { Node item = node List . item ( i ) ; if ( item . get Node Type ( ) == Node . TEXT NODE || item . get Node Type ( ) == Node . CDATA SECTION NODE ) { result . add ( item . get Node Value ( ) ) ; } } } return result ; }
public static String flatten To Classpath String ( List < I Runtime Classpath Entry > classpath Entries ) { String Builder sb = new String Builder ( ) ; boolean needs Separator = false ; for ( I Runtime Classpath Entry r : classpath Entries ) { if ( needs Separator ) { sb . append ( File . path Separator Char ) ; } needs Separator = true ; sb . append ( r . get Location ( ) ) ; } return sb . to String ( ) ; }
public String CV Parameters Tip Text ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; }
public boolean contains All ( Collection < Taxon > taxa ) { for ( Taxon taxon : taxa ) { if ( ! taxa . contains ( taxon ) ) { return false ; } } return true ; }
public static J Panel create Row With Top And Bottom Padding ( final J Panel content Row , final int top Padding , final int bottom Padding ) { final J Panel row Contents = new J Panel ( ) ; row Contents . set Layout ( new Box Layout ( row Contents , Box Layout . Y AXIS ) ) ; row Contents . add ( Box . create Vertical Strut ( top Padding ) ) ; row Contents . add ( content Row ) ; row Contents . add ( Box . create Vertical Strut ( bottom Padding ) ) ; return row Contents ; }
public boolean is Collection ( String target ) { return target . ends With ( STR_ ) ; }
private int parent Height ( ) { Container parent = get Parent ( ) ; if ( parent != null ) { return parent . get Height ( ) ; } return get Height ( ) ; }
public static URL url ( String path ) { URL url = CLS LDR . get Resource ( path ) ; if ( url == null ) throw new Runtime Exception ( STR_ + path ) ; return url ; }
public boolean is Reliable ( ) { return true ; }
public static Placeholder Fragment new Instance ( int section Number ) { Placeholder Fragment fragment = new Placeholder Fragment ( ) ; Bundle args = new Bundle ( ) ; args . put Int ( ARG SECTION NUMBER , section Number ) ; fragment . set Arguments ( args ) ; fragment . current Section = section Number ; return fragment ; }
public int search ( String txt ) { int m = pat . length ( ) ; int n = txt . length ( ) ; int i , j ; for ( i = NUM_ , j = NUM_ ; i < n && j < m ; i ++ ) { j = dfa [ txt . char At ( i ) ] [ j ] ; } if ( j == m ) return i - m ; return n ; }
public static boolean is Main Thread ( ) { return s Is Main Thread . get ( ) ; }
private static int col To Loc ( int col , Vector < Mapping Pair > vec ) { int loc = col ; for ( int i = NUM_ ; ( i < vec . size ( ) ) && ( vec . element At ( i ) . col <= col ) ; i ++ ) { loc = loc + vec . element At ( i ) . inc ; } return loc ; }
protected < T extends Key Spec > T engine Get Key Spec ( Key key , Class < T > key Spec ) throws Invalid Key Spec Exception { Big Integer p , q , g , x , y ; if ( key != null ) { if ( key Spec == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( key instanceof DSA Private Key ) { DSA Private Key private Key = ( DSA Private Key ) key ; if ( key Spec . equals ( DSA Private Key Spec . class ) ) { x = private Key . get X ( ) ; DSA Params params = private Key . get Params ( ) ; p = params . get P ( ) ; q = params . get Q ( ) ; g = params . get G ( ) ; return ( T ) ( new DSA Private Key Spec ( x , p , q , g ) ) ; } if ( key Spec . equals ( PKCS 8 Encoded Key Spec . class ) ) { return ( T ) ( new PKCS 8 Encoded Key Spec ( key . get Encoded ( ) ) ) ; } throw new Invalid Key Spec Exception ( STR_ ) ; } if ( key instanceof DSA Public Key ) { DSA Public Key public Key = ( DSA Public Key ) key ; if ( key Spec . equals ( DSA Public Key Spec . class ) ) { y = public Key . get Y ( ) ; DSA Params params = public Key . get Params ( ) ; p = params . get P ( ) ; q = params . get Q ( ) ; g = params . get G ( ) ; return ( T ) ( new DSA Public Key Spec ( y , p , q , g ) ) ; } if ( key Spec . equals ( X 509 Encoded Key Spec . class ) ) { return ( T ) ( new X 509 Encoded Key Spec ( key . get Encoded ( ) ) ) ; } throw new Invalid Key Spec Exception ( STR_ ) ; } } throw new Invalid Key Spec Exception ( STR_ ) ; }
public double downside Deviation ( ) { return Math . sqrt ( downside Variance ( ) ) ; }
protected int find Insert Index ( double value ) { if ( values . size ( ) > NUM_ ) { int start Index = values . size ( ) > > NUM_ ; double start Value = values . get ( start Index ) ; int insert At ; if ( value < start Value ) { insert At = find Insert Index ( NUM_ , start Index - NUM_ , value ) ; } else if ( value > start Value ) { insert At = find Insert Index ( start Index + NUM_ , values . size ( ) - NUM_ , value ) ; } else { insert At = start Index ; } if ( insert At == values . size ( ) ) { return - NUM_ ; } return insert At ; } if ( values . size ( ) == NUM_ ) { if ( value > values . get ( NUM_ ) ) { return - NUM_ ; } else if ( value <= values . get ( NUM_ ) ) { return NUM_ ; } else { return NUM_ ; } } if ( values . size ( ) == NUM_ ) { if ( value > values . get ( NUM_ ) ) { return - NUM_ ; } else { return NUM_ ; } } return - NUM_ ; }
@ Override public int hash Code ( ) { return NUM_ * super . hash Code ( ) + NUM_ * host . hash Code ( ) + port ; }
public Search Result current ( ) { return m reduced Results . is Empty ( ) ? null : m reduced Results . get ( m current Search Index ) ; }
final public List < V > values In Selection ( RT Edit Text editor ) { List < V > result = new Array List < V > ( ) ; Selection selection = get Selection ( editor ) ; List < RT Span < V > > spans = get Spans ( editor . get Text ( ) , selection , Span Collect Mode . SPAN FLAGS ) ; for ( RT Span < V > span : spans ) { result . add ( span . get Value ( ) ) ; } return result ; }
@ Deprecated public static boolean is Concrete ( X Method xmethod ) { int access Flags = xmethod . get Access Flags ( ) ; return ( access Flags & Constants . ACC ABSTRACT ) == NUM_ && ( access Flags & Constants . ACC NATIVE ) == NUM_ ; }
public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { return q . to Array ( ) ; } finally { lock . unlock ( ) ; } }
public static double sum Of Squares ( double [ ] vector ) { double ret = NUM_ ; for ( double d : vector ) ret += Math . pow ( d , NUM_ ) ; return ret ; }
@ Override public int hash Code ( ) { int hash = port + ( is Secure ? NUM_ : NUM_ ) ; byte [ ] uri = uri ; int length = uri Length ; for ( int i = length - NUM_ ; i >= NUM_ ; i -- ) { hash = NUM_ * hash + uri [ i ] ; } Char Sequence host = host ; if ( host != null ) { hash = NUM_ * hash + host . hash Code ( ) ; } return hash ; }
public boolean seen Tag Prefix ( @ Not Null String prefix ) { if ( my Tags != null ) { for ( String tag : my Tags . key Set ( ) ) { if ( tag . starts With ( prefix ) ) { return true ; } } } return false ; }
protected String form Navigation Stack Debug ( ) { if ( base Form Navigation Stack != null ) { return base Form Navigation Stack . to String ( ) ; } return STR_ ; }
public static boolean is Java 6 On Mac ( ) { return is Mac ( ) && is Java 6 ( ) ; }
private void save Selection ( ) { log . info ( STR_ ) ; mini Table . editing Stopped ( new Change Event ( this ) ) ; Array List < Integer > results = new Array List < Integer > ( ) ; selection = null ; int rows = mini Table . get Row Count ( ) ; for ( int i = NUM_ ; i < rows ; i ++ ) { ID Column id = ( ID Column ) mini Table . get Value At ( i , NUM_ ) ; if ( id != null && id . is Selected ( ) ) results . add ( id . get Record ID ( ) ) ; } if ( results . size ( ) == NUM_ ) return ; log . config ( STR_ + results . size ( ) ) ; selection = results ; }
public String print Queue ( ) { String Builder result = new String Builder ( ) ; result . append ( STR_ ) ; Lirs Entry e = queue Front ( ) ; if ( e != null ) { result . append ( e ) ; for ( e = e . next In Queue ; e != header ; e = e . next In Queue ) { result . append ( STR_ + e ) ; } } result . append ( STR_ ) ; return result . to String ( ) ; }
protected static List < String > expand Arg Files ( final List < File > files ) { final List < String > content = new Array List < String > ( ) ; for ( final File file : files ) { try { content . add All ( Plugin Util . read File ( file ) ) ; } catch ( final IO Exception exc ) { throw new Runtime Exception ( STR_ + file . get Absolute Path ( ) , exc ) ; } } return content ; }
@ Override public Grammar load Grammar ( XML Input Source source ) throws IO Exception , XNI Exception { reset ( ) ; String eid = XML Entity Manager . expand System Id ( source . get System Id ( ) , source . get Base System Id ( ) , f Strict URI ) ; XMLDTD Description desc = new XMLDTD Description ( source . get Public Id ( ) , source . get System Id ( ) , source . get Base System Id ( ) , eid , null ) ; if ( ! f Balance Syntax Trees ) { f DTD Grammar = new DTD Grammar ( f Symbol Table , desc ) ; } else { f DTD Grammar = new Balanced DTD Grammar ( f Symbol Table , desc ) ; } f Grammar Bucket = new DTD Grammar Bucket ( ) ; f Grammar Bucket . set Standalone ( false ) ; f Grammar Bucket . set Active Grammar ( f DTD Grammar ) ; try { f DTD Scanner . set Input Source ( source ) ; f DTD Scanner . scan DTD External Subset ( true ) ; } catch ( EOF Exception e ) { } finally { f Entity Manager . close Readers ( ) ; } if ( f DTD Grammar != null && f Grammar Pool != null ) { f Grammar Pool . cache Grammars ( XML Grammar Description . XML DTD , new Grammar [ ] { f DTD Grammar } ) ; } return f DTD Grammar ; }
public static final double next Double ( double value ) { if ( value == Double . POSITIVE INFINITY ) { return value ; } long bits ; if ( value == NUM_ ) { bits = NUM_ ; } else { bits = Double . double To Long Bits ( value ) ; } return Double . long Bits To Double ( value < NUM_ ? bits - NUM_ : bits + NUM_ ) ; }
@ Override protected void do Get ( Sling Http Servlet Request request , Sling Http Servlet Response response ) throws Servlet Exception , IO Exception { final Print Writer writer = response . get Writer ( ) ; response . set Character Encoding ( Char Encoding . UTF 8 ) ; response . set Content Type ( STR_ ) ; List < Jcr Package > packages = package Service . get Package List ( request ) ; try { JSON Array json Array = new JSON Array ( ) ; for ( Jcr Package jcr Package : packages ) { final JSON Object json = get Json From Jcr Package ( jcr Package ) ; json Array . put ( json ) ; } response . set Status ( Sling Http Servlet Response . SC OK ) ; writer . write ( json Array . to String ( ) ) ; } catch ( JSON Exception | Repository Exception e ) { LOGGER . error ( STR_ , e ) ; response . set Status ( Sling Http Servlet Response . SC INTERNAL SERVER ERROR ) ; } }
public Char Seq replace First ( String regex , String replacement ) { return Char Seq . of ( str . replace First ( regex , replacement ) ) ; }
public static String to Legacy Text ( Base Component ... components ) { String Builder builder = new String Builder ( ) ; for ( Base Component msg : components ) { builder . append ( msg . to Legacy Text ( ) ) ; } return builder . to String ( ) ; }
public static String file Name Clean ( String s ) { char [ ] chars = s . to Char Array ( ) ; String Buffer sb = new String Buffer ( ) ; for ( int i = NUM_ ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || ( c == STR_ ) ) { sb . append ( c ) ; } else { if ( c == STR_ || c == STR_ ) { sb . append ( STR_ ) ; } else { sb . append ( STR_ + ( int ) c + STR_ ) ; } } } return sb . to String ( ) ; }
@ Override public String graph ( ) throws Exception { String Buffer text = new String Buffer ( ) ; assign I Ds ( - NUM_ ) ; text . append ( STR_ ) ; if ( m is Leaf ) { text . append ( STR_ + m id + STR_ + Utils . back Quote Chars ( m local Model . dump Label ( NUM_ , m train ) ) + STR_ + STR_ ) ; if ( m train != null && m train . num Instances ( ) > NUM_ ) { text . append ( STR_ + m train + STR_ ) ; text . append ( STR_ ) ; } text . append ( STR_ ) ; } else { text . append ( STR_ + m id + STR_ + Utils . back Quote Chars ( m local Model . left Side ( m train ) ) + STR_ ) ; if ( m train != null && m train . num Instances ( ) > NUM_ ) { text . append ( STR_ + m train + STR_ ) ; text . append ( STR_ ) ; } text . append ( STR_ ) ; graph Tree ( text ) ; } return text . to String ( ) + STR_ ; }
public static Vector pad Left ( Collection strings ) { Vector v = new Vector ( ) ; int length = max Length ( strings ) ; for ( Iterator i = strings . iterator ( ) ; i . has Next ( ) ; ) { String string = ( String ) i . next ( ) ; v . add ( pad Left ( string , length ) ) ; } return v ; }
public Char Seq replace All ( String regex , String replacement ) { return Char Seq . of ( str . replace All ( regex , replacement ) ) ; }
public String from Base 64 ( String to Decode ) { try { byte [ ] bytes = Base 64 . decode Base 64 ( to Decode . trim ( ) ) ; return new String ( bytes , Charset . for Name ( STR_ ) ) ; } catch ( Exception e ) { LOG . error ( STR_ + to Decode + STR_ + e ) ; } return to Decode ; }
private int find Bin ( double value ) { return Fast Math . min ( Fast Math . max ( ( int ) Fast Math . ceil ( ( value - min ) / delta ) - NUM_ , NUM_ ) , bin Count - NUM_ ) ; }
public Local Variable visible Variable By Name ( String name ) throws Absent Information Exception { validate Stack Frame ( ) ; create Visible Variables ( ) ; return visible Variables . get ( name ) ; }
public boolean has Key Purpose Id ( Key Purpose Id key Purpose Id ) { return ( usage Table . get ( key Purpose Id ) != null ) ; }
@ Override public T next ( ) { if ( ! eol && uri List . is Empty ( ) ) { fetch ( ) ; } URI next = uri List . poll ( ) ; if ( next == null ) { eol = true ; throw new No Such Element Exception ( STR_ + field ) ; } return create ( session , next ) ; }
Collection < Mob Sim Vehicle Route > create Plans ( ) { List < Mob Sim Vehicle Route > vehicle Routes = new Array List < Mob Sim Vehicle Route > ( ) ; for ( Carrier Agent carrier Agent : carrier Agents ) { List < Mob Sim Vehicle Route > plans For Carrier = carrier Agent . create Freight Driver Plans ( ) ; vehicle Routes . add All ( plans For Carrier ) ; } return vehicle Routes ; }
public boolean contains Value ( Object value ) { return contains ( value ) ; }
public static Enumeration < String > list Stemmers ( ) { init Stemmers ( ) ; return m Stemmers . elements ( ) ; }
public boolean is Mine ( Wallet wallet ) { try { Script script = get Script Pub Key ( ) ; if ( script . is Sent To Raw Pub Key ( ) ) { byte [ ] pubkey = script . get Pub Key ( ) ; return wallet . is Pub Key Mine ( pubkey ) ; } else { byte [ ] pubkey Hash = script . get Pub Key Hash ( ) ; return wallet . is Pub Key Hash Mine ( pubkey Hash ) ; } } catch ( Script Exception e ) { log . debug ( STR_ , e . to String ( ) ) ; return false ; } }
public long first ( ) { return start Date . get Time ( ) ; }
String check String ( String s , int base ) { if ( s == null ) { throw new Null Pointer Exception ( STR_ ) ; } int char Count = s . length ( ) ; int i = NUM_ ; if ( char Count > NUM_ ) { char ch = s . char At ( NUM_ ) ; if ( ch == STR_ ) { s = s . substring ( NUM_ ) ; -- char Count ; } else if ( ch == STR_ ) { ++ i ; } } if ( char Count - i == NUM_ ) { throw invalid Big Integer ( s ) ; } boolean non Ascii = false ; for ( ; i < char Count ; ++ i ) { char ch = s . char At ( i ) ; if ( Character . digit ( ch , base ) == - NUM_ ) { throw invalid Big Integer ( s ) ; } if ( ch > NUM_ ) { non Ascii = true ; } } return non Ascii ? to Ascii ( s , base ) : s ; }
public final Http Request Factory create Request Factory ( ) { return create Request Factory ( null ) ; }
public Iterator iterator ( ) { return object List . iterator ( ) ; }
public long elapsed Time Millis ( ) { if ( this . stop Time == NUM_ ) { return System . current Time Millis ( ) - this . start Time ; } else { return this . stop Time - this . start Time ; } }
public synchronized Entry first Value ( ) { if ( array . is Empty ( ) ) return null ; else { return array . get ( NUM_ ) ; } }
public synchronized boolean contains ( Integer i ) { return value . contains ( i ) ; }
public static String format URL ( String url ) { if ( ! Strings . is Null Or Empty ( url ) ) { try { URI uri = URI . create ( url ) ; if ( uri . is Absolute ( ) ) { return url ; } else { return STR_ + url ; } } catch ( Illegal Argument Exception e ) { return null ; } } else { return null ; } }
public static long determine Ceiling From Max Value ( long number , int y Num Of Divs ) { long temp Int = number ; temp Int = temp Int / NUM_ + temp Int ; if ( temp Int < NUM_ ) { while ( temp Int % y Num Of Divs != NUM_ ) { temp Int ++ ; } return temp Int ; } else { int counter = NUM_ ; String num Str = STR_ + number ; for ( int i = NUM_ ; i < num Str . length ( ) - NUM_ ; i ++ ) { temp Int = temp Int / NUM_ ; counter ++ ; } temp Int ++ ; while ( temp Int % y Num Of Divs != NUM_ ) { temp Int ++ ; } return ( long ) Math . pow ( NUM_ , counter ) * temp Int ; } }
private String opt Node Digest ( Parse Tree Node node ) { String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; for ( Parse Tree Node child : node . children ( ) ) { node Digest ( child , sb ) ; if ( sb . length ( ) > longest Key Length ) { return null ; } } node Tail ( node , sb ) ; if ( sb . length ( ) > longest Key Length ) { return null ; } return sb . to String ( ) ; }
public static int geometric ( double p ) { return ( int ) Math . ceil ( Math . log ( uniform ( ) ) / Math . log ( NUM_ - p ) ) ; }
@ Override public Object clone ( ) throws Clone Not Supported Exception { Segmented Timeline clone = ( Segmented Timeline ) super . clone ( ) ; return clone ; }
public static double round ( double number ) { return ( double ) Math . round ( number * Math . pow ( NUM_ , NUM_ ) ) / Math . pow ( NUM_ , NUM_ ) ; }
protected static final void check Offset ( int offset , Character Iterator text ) { if ( offset < text . get Begin Index ( ) || offset > text . get End Index ( ) ) { throw new Illegal Argument Exception ( STR_ ) ; } }
@ Nullable private File [ ] list Files 0 ( Igfs Path path ) { File f = file For Path ( path ) ; if ( ! f . exists ( ) ) throw new Igfs Path Not Found Exception ( STR_ + path ) ; else return f . list Files ( ) ; }
public static long available Memory ( ) { return RUNTIME . free Memory ( ) + ( RUNTIME . max Memory ( ) - RUNTIME . total Memory ( ) ) ; }
protected boolean is Numeric Or Boxed ( Type Mirror type ) { if ( Types Utils . is Boxed Primitive ( type ) ) { type = types . unboxed Type ( type ) ; } return Types Utils . is Numeric ( type ) ; }
public static boolean is Letter Or Digit ( char c ) { return Character . is Letter Or Digit ( c ) ; }
public static Vector Store RAM read From File ( Flag Config flag Config , String vector File ) throws IO Exception { if ( vector File . is Empty ( ) ) { throw new Illegal Argument Exception ( STR_ ) ; } Vector Store RAM store = new Vector Store RAM ( flag Config ) ; store . init From File ( vector File ) ; return store ; }
public boolean is Subset Of ( Object obj ) { if ( ! ( obj instanceof Abstract Tag Frame Body ) ) { return false ; } Array List < Abstract Data Type > superset = ( ( Abstract Tag Frame Body ) obj ) . object List ; for ( Abstract Data Type an Object List : object List ) { if ( an Object List . get Value ( ) != null ) { if ( ! superset . contains ( an Object List ) ) { return false ; } } } return true ; }
@ Override public int hash Code ( ) { int result = NUM_ ; Iterator < ? > it = iterator ( ) ; while ( it . has Next ( ) ) { Object object = it . next ( ) ; result = ( NUM_ * result ) + ( object == null ? NUM_ : object . hash Code ( ) ) ; } return result ; }
public PM Element element At ( int i ) { return gr . element At ( i ) ; }
private boolean is Project Using Default Sdk ( T project Sdk ) { if ( ! is Default Sdk ( project Sdk ) ) { return false ; } try { I Classpath Entry entry = Classpath Utilities . find Classpath Entry Container ( java Project . get Raw Classpath ( ) , do Get Container Id ( ) ) ; if ( entry != null ) { if ( Sdk Classpath Container . is Default Container Path ( do Get Container Id ( ) , entry . get Path ( ) ) ) { return true ; } } } catch ( Core Exception ce ) { Core Plugin Log . log Error ( ce ) ; } return false ; }
private List < File Path > list Seqno Files ( ) { Linked List < File Path > children = new Linked List < File Path > ( ) ; for ( String file Name : list Seqno File Names ( ) ) { File Path fp = new File Path ( service Dir , file Name ) ; children . add ( fp ) ; } return children ; }
public static Annotated Type Mirror least Upper Bound ( Annotated Type Factory atype Factory , Annotated Type Mirror type 1 , Annotated Type Mirror type 2 ) { Type Mirror lub = Internal Utils . least Upper Bound ( atype Factory . get Processing Env ( ) , type 1 . get Underlying Type ( ) , type 2 . get Underlying Type ( ) ) ; return least Upper Bound ( atype Factory , type 1 , type 2 , lub ) ; }
static double svd dmax ( double a , double b ) { return Math . max ( a , b ) ; }
public int freq To Index ( float freq ) { if ( freq < get Band Width ( ) / NUM_ ) return NUM_ ; if ( freq > sample Rate / NUM_ - get Band Width ( ) / NUM_ ) return spectrum . length - NUM_ ; float fraction = freq / ( float ) sample Rate ; int i = Math . round ( time Size * fraction ) ; return i ; }
default String option String ( String name ) { List < String > all Strings = option Strings ( name ) ; if ( all Strings . size ( ) > NUM_ ) { throw new Runtime Exception ( STR_ + name ) ; } return all Strings . is Empty ( ) ? null : all Strings . get ( NUM_ ) ; }
boolean matches ( String selector , int s Current , int s Last , int this Current , int this Last ) { s Current = Math . max ( s Current , NUM_ ) ; this Current = Math . max ( this Current , NUM_ ) ; int this Dot Index = bounded Index Of ( name , STR_ , this Current , this Last ) ; int this Pound Index = bounded Index Of ( name , STR_ , this Current , this Last ) ; int s Dot Index = bounded Index Of ( selector , STR_ , s Current , s Last ) ; int s Pound Index = bounded Index Of ( selector , STR_ , s Current , s Last ) ; if ( s Dot Index != - NUM_ ) { if ( this Dot Index == - NUM_ ) { return false ; } if ( s Current == s Dot Index ) { if ( ( this Last - this Dot Index ) != ( s Last - s Dot Index ) || ! selector . region Matches ( s Current , name , this Dot Index , ( this Last - this Dot Index ) ) ) { return false ; } } else { if ( ( s Last - s Current ) != ( this Last - this Current ) || ! selector . region Matches ( s Current , name , this Current , ( this Last - this Current ) ) ) { return false ; } } return true ; } if ( s Pound Index != - NUM_ ) { if ( this Pound Index == - NUM_ ) { return false ; } if ( s Current == s Pound Index ) { if ( ( this Last - this Pound Index ) != ( s Last - s Pound Index ) || ! selector . region Matches ( s Current , name , this Pound Index , ( this Last - this Pound Index ) ) ) { return false ; } } else { if ( ( s Last - s Current ) != ( this Last - this Current ) || ! selector . region Matches ( s Current , name , this Current , ( this Last - this Current ) ) ) { return false ; } } return true ; } if ( this Dot Index != - NUM_ ) { return ( ( ( this Dot Index - this Current ) == ( s Last - s Current ) ) && selector . region Matches ( s Current , name , this Current , this Dot Index - this Current ) ) ; } if ( this Pound Index != - NUM_ ) { return ( ( ( this Pound Index - this Current ) == ( s Last - s Current ) ) && selector . region Matches ( s Current , name , this Current , this Pound Index - this Current ) ) ; } return ( ( ( this Last - this Current ) == ( s Last - s Current ) ) && selector . region Matches ( s Current , name , this Current , this Last - this Current ) ) ; }
public static Modifiable DBI Ds union ( DBI Ds ids 1 , DBI Ds ids 2 ) { Modifiable DBI Ds result = DBID Util . new Hash Set ( Math . max ( ids 1 . size ( ) , ids 2 . size ( ) ) ) ; result . add DBI Ds ( ids 1 ) ; result . add DBI Ds ( ids 2 ) ; return result ; }
public int size ( ) { return m map . size ( ) ; }
private static double min ( double d 1 , double d 2 ) { if ( Double . is Na N ( d 1 ) ) { return d 2 ; } if ( Double . is Na N ( d 2 ) ) { return d 1 ; } return Math . min ( d 1 , d 2 ) ; }
public String register Name ( final String name , final Operator operator ) { if ( operator Name Map . get ( name ) != null ) { String base Name = name ; int index = base Name . index Of ( STR_ ) ; if ( index >= NUM_ ) { base Name = base Name . substring ( NUM_ , index ) ; } int i = NUM_ ; while ( operator Name Map . get ( base Name + STR_ + i + STR_ ) != null ) { i ++ ; } String new Name = base Name + STR_ + i + STR_ ; operator Name Map . put ( new Name , operator ) ; return new Name ; } else { operator Name Map . put ( name , operator ) ; return name ; } }
public boolean has Ancestor ( Set < String > variables ) { Queue < B Node > nodes To Process = new Linked List < B Node > ( ) ; nodes To Process . add ( this ) ; while ( ! nodes To Process . is Empty ( ) ) { B Node current Node = nodes To Process . poll ( ) ; for ( B Node ancestor Node : current Node . get Input Nodes ( ) ) { if ( variables . contains ( ancestor Node . get Id ( ) ) ) { return true ; } if ( ! nodes To Process . contains ( ancestor Node ) ) { nodes To Process . add ( ancestor Node ) ; } } } return false ; }
public Response evaluate Compatibility ( ) { if ( ! ( info . get Sdk Version ( ) >= android . os . Build . VERSION CODES . ICE CREAM SANDWICH MR 1 ) && info . is Rooted ( ) ) { return Response . INCOMPATIBLE ; } else if ( info . get Sdk Version ( ) < android . os . Build . VERSION CODES . JELLY BEAN ) { return Response . INCOMPATIBLE OS ; } else if ( info . is Rooted ( ) ) { return Response . INCOMPATIBLE ROOT ; } return Response . COMPATIBLE ; }
public boolean has Next ( ) { try { switch ( modus ) { case INIT : return query Article ( ) ; case ITERATE WITH MAPPING : if ( chrono Iterator . has Next ( ) ) { return true ; } reset ( ) ; if ( result Articles . next ( ) ) { this . current Article ID = result Articles . get Int ( NUM_ ) ; return ( this . last Article ID == - NUM_ ) || ( this . current Article ID <= this . last Article ID ) ; } result Articles . close ( ) ; return query Article ( ) ; case ITERATE WITHOUT MAPPING : if ( revision Iterator . has Next ( ) ) { return true ; } reset ( ) ; if ( result Articles . next ( ) ) { this . current Article ID = result Articles . get Int ( NUM_ ) ; return ( this . last Article ID == - NUM_ ) || ( this . current Article ID <= this . last Article ID ) ; } result Articles . close ( ) ; return query Article ( ) ; default : throw new Runtime Exception ( STR_ ) ; } } catch ( SQL Exception e ) { throw new Runtime Exception ( e ) ; } }
private static boolean has Uncovered Branch ( Test Chromosome test , Set < Branch > uncovered Branches ) { Set < Branch > test Covered Branches = get Covered Branches ( test ) ; for ( Branch b : test Covered Branches ) { Branch negate = b . negate ( ) ; if ( uncovered Branches . contains ( negate ) ) { return true ; } } return false ; }
public boolean is Public ( ) { return Modifier . is Public ( class . get Modifiers ( ) ) ; }
@ Override public Boolean use Proxy ( ) { return Boolean . parse Boolean ( ( String ) properties . get ( STR_ ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( NUM_ ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private String crc ( Input Stream input ) { if ( input == null ) throw new Illegal Argument Exception ( STR_ ) ; CRC 32 crc = new CRC 32 ( ) ; byte [ ] buffer = new byte [ NUM_ ] ; try { while ( true ) { int length = input . read ( buffer ) ; if ( length == - NUM_ ) break ; crc . update ( buffer , NUM_ , length ) ; } } catch ( Exception ex ) { try { input . close ( ) ; } catch ( Exception ignored ) { } } return Long . to String ( crc . get Value ( ) ) ; }
public static boolean is All Whitespace ( Char Sequence self ) { for ( int i = NUM_ ; i < self . length ( ) ; i ++ ) { if ( ! Character . is Whitespace ( self . char At ( i ) ) ) return false ; } return true ; }
public static int fast Approximate Word Count ( String string ) { Matcher m = PATTERN . matcher ( string ) ; int count = NUM_ ; while ( m . find ( ) ) { count ++ ; } return count ; }
public static URI to Location ( String source , String table ) { URI source Uri = URI . create ( source ) ; return to Location ( source Uri , table ) ; }
public static boolean intersects ( Set a , Set b ) { Iterator it ; Set target ; if ( a . size ( ) <= b . size ( ) ) { it = a . iterator ( ) ; target = b ; } else { it = b . iterator ( ) ; target = a ; } while ( it . has Next ( ) ) { if ( target . contains ( it . next ( ) ) ) return true ; } return false ; }
@ Override public double predict Quantile ( double percentage ) { update Width ( ) ; double val = Statistics . normal Inverse ( NUM_ - ( NUM_ - NUM_ ) / NUM_ ) ; double min = m TM . first Key ( ) - val * m Width ; double max = m TM . last Key ( ) + val * m Width ; double delta = ( max - min ) / m Num Intervals ; double sum = NUM_ ; double left Val = Math . exp ( log Density ( min ) ) ; for ( int i = NUM_ ; i < m Num Intervals ; i ++ ) { if ( sum >= percentage ) { return min + i * delta ; } double right Val = Math . exp ( log Density ( min + ( i + NUM_ ) * delta ) ) ; sum += NUM_ * ( left Val + right Val ) * delta ; left Val = right Val ; } return max ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new Option ( STR_ + default Num Attributes ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Num Classes ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Max Rule Size ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Min Rule Size ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Num Irrelevant ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Num Numeric ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public int hash Code ( ) { int h = NUM_ ; if ( name != null ) { h += name . hash Code ( ) ; } if ( types != null ) { h += hash ( types ) ; } if ( constraints != null ) { h += constraints . hash Code ( ) ; } return h ; }
public boolean refresh Needed ( ) { return this . soft Ttl < System . current Time Millis ( ) ; }
@ Override public Inet Socket Address ip Remote ( ) { Socket s = get Socket ( ) ; if ( s != null ) { return ( Inet Socket Address ) s . get Remote Socket Address ( ) ; } else { return null ; } }
static byte [ ] combined Buffer To Byte Array ( Doubles Sketch sketch , boolean ordered , boolean compact ) { final int pre Longs = NUM_ ; final int extra = NUM_ ; int pre Bytes = ( pre Longs + extra ) << NUM_ ; int flags = ( ordered ? ORDERED FLAG MASK : NUM_ ) | ( compact ? COMPACT FLAG MASK : NUM_ ) ; int k = sketch . get K ( ) ; long n = sketch . get N ( ) ; double [ ] combined Buffer = sketch . get Combined Buffer ( ) ; double [ ] bb Items Arr = null ; final int bb Cnt = Util . compute Base Buffer Items ( k , n ) ; if ( bb Cnt > NUM_ ) { bb Items Arr = new double [ bb Cnt ] ; System . arraycopy ( combined Buffer , NUM_ , bb Items Arr , NUM_ , bb Cnt ) ; if ( ordered ) { Arrays . sort ( bb Items Arr ) ; } } byte [ ] out Byte Arr = null ; if ( compact ) { final int retained Items = sketch . get Retained Items ( ) ; int out Bytes = ( retained Items << NUM_ ) + pre Bytes ; out Byte Arr = new byte [ out Bytes ] ; Memory mem Out = new Native Memory ( out Byte Arr ) ; long cum Offset = mem Out . get Cumulative Offset ( NUM_ ) ; insert Pre 0 ( out Byte Arr , cum Offset , pre Longs , flags , k ) ; insert N ( out Byte Arr , cum Offset , n ) ; insert Min Double ( out Byte Arr , cum Offset , sketch . get Min Value ( ) ) ; insert Max Double ( out Byte Arr , cum Offset , sketch . get Max Value ( ) ) ; if ( bb Cnt > NUM_ ) { mem Out . put Double Array ( pre Bytes , bb Items Arr , NUM_ , bb Cnt ) ; } long bits = sketch . get Bit Pattern ( ) ; if ( bits != NUM_ ) { long mem Offset = pre Bytes + ( bb Cnt << NUM_ ) ; int comb Buf Offset = NUM_ * k ; while ( bits != NUM_ ) { if ( ( bits & NUM_ ) > NUM_ ) { mem Out . put Double Array ( mem Offset , combined Buffer , comb Buf Offset , k ) ; mem Offset += ( k << NUM_ ) ; } comb Buf Offset += k ; bits >>>= NUM_ ; } } } else { final int tot Levels = Util . compute Num Levels Needed ( k , n ) ; int out Bytes = ( tot Levels == NUM_ ) ? ( bb Cnt << NUM_ ) + pre Bytes : ( ( ( NUM_ + tot Levels ) * k ) << NUM_ ) + pre Bytes ; out Byte Arr = new byte [ out Bytes ] ; Memory mem Out = new Native Memory ( out Byte Arr ) ; long cum Offset = mem Out . get Cumulative Offset ( NUM_ ) ; insert Pre 0 ( out Byte Arr , cum Offset , pre Longs , flags , k ) ; insert N ( out Byte Arr , cum Offset , n ) ; insert Min Double ( out Byte Arr , cum Offset , sketch . get Min Value ( ) ) ; insert Max Double ( out Byte Arr , cum Offset , sketch . get Max Value ( ) ) ; if ( bb Cnt > NUM_ ) { mem Out . put Double Array ( pre Bytes , bb Items Arr , NUM_ , bb Cnt ) ; } if ( tot Levels > NUM_ ) { long mem Offset = pre Bytes + ( ( NUM_ * k ) << NUM_ ) ; int comb Buf Offset = NUM_ * k ; mem Out . put Double Array ( mem Offset , combined Buffer , comb Buf Offset , tot Levels * k ) ; } } return out Byte Arr ; }
private int next Free Id ( ) { int id = NUM_ ; Set < Integer > ids = solutions . key Set ( ) ; while ( ids . contains ( id ) ) { id ++ ; } return id ; }
public static boolean is Metric Units ( Context context ) { return STATS UNITS DEFAULT . equals ( get String ( context , R . string . stats units key , STATS UNITS DEFAULT ) ) ; }
@ Override public final int which Subset ( Instance instance ) throws Exception { return m c 45 S . which Subset ( instance ) ; }
public boolean is Empty ( ) { return size ( ) == NUM_ ; }
private static boolean valid Class ( String name ) { int len = name . length ( ) ; outer : for ( int i = NUM_ ; i < len && Character . is Java Identifier Start ( name . char At ( i ) ) ; i ++ ) { while ( ++ i < len ) { char c = name . char At ( i ) ; if ( c == STR_ ) { continue outer ; } if ( ! Character . is Java Identifier Part ( c ) ) { return false ; } } return true ; } return false ; }
public static Date days After ( Date date Inst , int num Days ) { if ( ( num Days <= NUM_ ) || ( date Inst == null ) ) { throw new Illegal Argument Exception ( ) ; } final Calendar cal = new Gregorian Calendar ( ) ; cal . set Time ( date Inst ) ; cal . add ( Calendar . DAY OF YEAR , num Days ) ; return cal . get Time ( ) ; }
public static byte [ ] to Bytes ( Byte Buffer bb ) { int length = bb . remaining ( ) ; byte [ ] result = new byte [ length ] ; System . arraycopy ( bb . array ( ) , bb . array Offset ( ) + bb . position ( ) , result , NUM_ , length ) ; return result ; }
@ Override protected Iterable < Form > search Impl ( Request Context context , long snapshot Time ) { return get Charts ( form Service ) ; }
public static boolean starts With Ignore Case ( String s , String prefix ) { final int pl = prefix . length ( ) ; if ( s . length ( ) < pl ) return false ; for ( int i = NUM_ ; i < pl ; i ++ ) { char sc = s . char At ( i ) ; char pc = prefix . char At ( i ) ; if ( sc != pc ) { sc = Character . to Upper Case ( sc ) ; pc = Character . to Upper Case ( pc ) ; if ( sc != pc ) { sc = Character . to Lower Case ( sc ) ; pc = Character . to Lower Case ( pc ) ; if ( sc != pc ) return false ; } } } return true ; }
private boolean is Default Classpath ( I Runtime Classpath Entry [ ] classpath , I Launch Configuration configuration ) { try { I Launch Configuration Working Copy wc = configuration . get Working Copy ( ) ; wc . set Attribute ( I Java Launch Configuration Constants . ATTR DEFAULT CLASSPATH , true ) ; I Runtime Classpath Entry [ ] entries = Java Runtime . compute Unresolved Runtime Classpath ( wc ) ; if ( classpath . length == entries . length ) { for ( int i = NUM_ ; i < entries . length ; i ++ ) { I Runtime Classpath Entry entry = entries [ i ] ; if ( ! entry . equals ( classpath [ i ] ) ) { return false ; } } return true ; } return false ; } catch ( Core Exception e ) { return false ; } }
public static List < ? extends Element > child Element List ( Element element ) { if ( element == null ) return null ; List < Element > elements = new Linked List < Element > ( ) ; Node node = element . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE ) { Element child Element = ( Element ) node ; elements . add ( child Element ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return elements ; }
public Date Time to Date Time ( double days ) { long utc = Math . round ( days * DAY MILLIS ) ; utc -= CF UNIX OFFSET ; utc -= get Local Time Zone Offset ( utc ) ; return new Date Time Impl ( utc , false ) ; }
public final synchronized int [ ] element At ( final int id ) { if ( id >= max size ) { return null ; } else { final int [ ] rect Params = new int [ NUM_ ] ; System . arraycopy ( items [ id ] , NUM_ , rect Params , NUM_ , rect Params . length ) ; return rect Params ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public synchronized int size ( ) { return this . count ; }
protected double inner Product ( double [ ] x , double [ ] y ) { double sum = NUM_ ; for ( int i = NUM_ ; i < x . length ; i ++ ) { sum += x [ i ] * y [ i ] ; } return sum ; }
public E current ( ) { if ( pos < NUM_ || pos >= data . size ( ) ) { return null ; } return data . get ( pos ) ; }
public static boolean intersects Circle ( Geo p 1 , Geo p 2 , Geo center , double radius ) { double d 1 = Geo . distance ( p 1 , center ) ; if ( d 1 < radius ) return true ; double d 2 = Geo . distance ( p 2 , center ) ; if ( d 2 < radius ) return true ; double dist = point Circle Distance ( p 1 , p 2 , center ) ; if ( dist > radius ) return false ; Geo g = p 1 . cross ( p 2 ) ; Geo f = center . cross ( g ) ; Geo i = f . cross Normalize ( g , g ) ; double d = Geo . distance ( p 1 , p 2 ) ; if ( center . distance ( i ) < radius ) { double d 11 = Geo . distance ( p 1 , i ) ; double d 12 = Geo . distance ( p 2 , i ) ; return ( d 11 <= d && d 12 <= d && Math . abs ( d 11 + d 12 - d ) < NUM_ ) ; } Geo i 2 = i . antipode ( i ) ; if ( center . distance ( i 2 ) < radius ) { double d 21 = Geo . distance ( p 1 , i 2 ) ; double d 22 = Geo . distance ( p 2 , i 2 ) ; return ( d 21 <= d && d 22 <= d && Math . abs ( d 21 + d 22 - d ) < NUM_ ) ; } return false ; }
private List < Quadrant > find Containing Quadrants ( Rect first Rect , Rect second Rect ) { List < Quadrant > quadrants = new Array List < > ( ) ; int radius X = ( first Rect . right - first Rect . left ) / NUM_ ; int radius Y = ( first Rect . bottom - first Rect . top ) / NUM_ ; for ( Quadrant quadrant : Quadrant . values ( ) ) { int x = first Rect . center X ( ) + quadrant . getx Sign ( ) * radius X ; int y = first Rect . center Y ( ) + quadrant . gety Sign ( ) * radius Y ; Rect quadrant Rect = new Rect ( Math . min ( x , first Rect . center X ( ) ) , Math . min ( y , first Rect . center Y ( ) ) , Math . max ( first Rect . center X ( ) , x ) , Math . max ( first Rect . center Y ( ) , y ) ) ; if ( second Rect . contains ( quadrant Rect ) ) { quadrants . add ( quadrant ) ; } } return quadrants ; }
String opcode To String ( char opcode ) { String ret = ( String ) hash Opcode . get ( new Integer ( opcode ) ) ; if ( ret == null ) { ret = STR_ ; } return ret ; }
@ Override public int hash Code ( ) { int result = NUM_ ; long l = Double . double To Long Bits ( this . top ) ; result = NUM_ * result + ( int ) ( l ^ ( l > > > NUM_ ) ) ; l = Double . double To Long Bits ( this . bottom ) ; result = NUM_ * result + ( int ) ( l ^ ( l > > > NUM_ ) ) ; l = Double . double To Long Bits ( this . left ) ; result = NUM_ * result + ( int ) ( l ^ ( l > > > NUM_ ) ) ; l = Double . double To Long Bits ( this . right ) ; result = NUM_ * result + ( int ) ( l ^ ( l > > > NUM_ ) ) ; return result ; }
public double [ ] log Joint Densities For Instance ( Instance inst ) throws Exception { double [ ] weights = log Density Per Cluster For Instance ( inst ) ; double [ ] priors = cluster Priors ( ) ; for ( int i = NUM_ ; i < weights . length ; i ++ ) { if ( priors [ i ] > NUM_ ) { weights [ i ] += Math . log ( priors [ i ] ) ; } else { throw new Illegal Argument Exception ( STR_ ) ; } } return weights ; }
public static void close Silently ( Writer writer ) { if ( writer != null ) { try { writer . flush ( ) ; writer . close ( ) ; } catch ( Exception e ) { } } }
protected void do Paeth Line ( byte [ ] cur Line , byte [ ] prev Line ) { int sub = ( int ) Math . ceil ( ( get Bits Per Component ( ) * get Colors ( ) ) / NUM_ ) ; for ( int i = NUM_ ; i < cur Line . length ; i ++ ) { int left = NUM_ ; int up = NUM_ ; int up Left = NUM_ ; int prev Idx = i - sub ; if ( prev Idx >= NUM_ ) { left = cur Line [ prev Idx ] & NUM_ ; } if ( prev Line != null ) { up = prev Line [ i ] & NUM_ ; } if ( prev Idx > NUM_ && prev Line != null ) { up Left = prev Line [ prev Idx ] & NUM_ ; } cur Line [ i ] += ( byte ) paeth ( left , up , up Left ) ; } }
public static String to Path ( Bezier Path [ ] paths ) { String Builder buf = new String Builder ( ) ; for ( int j = NUM_ ; j < paths . length ; j ++ ) { Bezier Path path = paths [ j ] ; if ( path . size ( ) == NUM_ ) { } else if ( path . size ( ) == NUM_ ) { Bezier Path . Node current = path . get ( NUM_ ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] + NUM_ ) ) ; } else { Bezier Path . Node previous ; Bezier Path . Node current ; previous = current = path . get ( NUM_ ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; char next Command = STR_ ; for ( int i = NUM_ , n = path . size ( ) ; i < n ; i ++ ) { previous = current ; current = path . get ( i ) ; if ( ( previous . mask & Bezier Path . C 2 MASK ) == NUM_ ) { if ( ( current . mask & Bezier Path . C 1 MASK ) == NUM_ ) { if ( next Command != STR_ ) { buf . append ( STR_ ) ; next Command = STR_ ; } else { buf . append ( STR_ ) ; } buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; } else { if ( next Command != STR_ ) { buf . append ( STR_ ) ; next Command = STR_ ; } else { buf . append ( STR_ ) ; } buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; } } else { if ( ( current . mask & Bezier Path . C 1 MASK ) == NUM_ ) { if ( next Command != STR_ ) { buf . append ( STR_ ) ; next Command = STR_ ; } else { buf . append ( STR_ ) ; } buf . append ( to Number ( previous . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( previous . y [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; } else { if ( next Command != STR_ ) { buf . append ( STR_ ) ; next Command = STR_ ; } else { buf . append ( STR_ ) ; } buf . append ( to Number ( previous . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( previous . y [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; } } } if ( path . is Closed ( ) ) { if ( path . size ( ) > NUM_ ) { previous = path . get ( path . size ( ) - NUM_ ) ; current = path . get ( NUM_ ) ; if ( ( previous . mask & Bezier Path . C 2 MASK ) == NUM_ ) { if ( ( current . mask & Bezier Path . C 1 MASK ) == NUM_ ) { if ( next Command != STR_ ) { buf . append ( STR_ ) ; next Command = STR_ ; } else { buf . append ( STR_ ) ; } buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; } else { if ( next Command != STR_ ) { buf . append ( STR_ ) ; next Command = STR_ ; } else { buf . append ( STR_ ) ; } buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; } } else { if ( ( current . mask & Bezier Path . C 1 MASK ) == NUM_ ) { if ( next Command != STR_ ) { buf . append ( STR_ ) ; next Command = STR_ ; } else { buf . append ( STR_ ) ; } buf . append ( to Number ( previous . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( previous . y [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; } else { if ( next Command != STR_ ) { buf . append ( STR_ ) ; next Command = STR_ ; } else { buf . append ( STR_ ) ; } buf . append ( to Number ( previous . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( previous . y [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . x [ NUM_ ] ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( current . y [ NUM_ ] ) ) ; } } } buf . append ( STR_ ) ; next Command = STR_ ; } } } return buf . to String ( ) ; }
public int size ( ) { if ( buffer != null ) return buffer . size ( ) ; else return offsets . size ( ) ; }
@ Override public String cipher Suite ( ) { if ( ! ( s instanceof SSL Socket ) ) { return super . cipher Suite ( ) ; } SSL Socket ssl Socket = ( SSL Socket ) s ; SSL Session ssl Session = ssl Socket . get Session ( ) ; if ( ssl Session != null ) { return ssl Session . get Cipher Suite ( ) ; } else { return null ; } }
@ Nullable public static < T > T first Not Null ( @ Nullable T ... vals ) { if ( vals == null ) return null ; for ( T val : vals ) { if ( val != null ) return val ; } return null ; }
public boolean is Pronounceable ( String word ) { String lower Case Word = word . to Lower Case ( ) ; if ( prefix FSM == null || suffix FSM == null ) { throw new Error ( STR_ ) ; } else { return ( prefix FSM . accept ( lower Case Word ) && suffix FSM . accept ( lower Case Word ) ) ; } }
private static final byte [ ] hash ( final byte [ ] value ) throws No Such Algorithm Exception { Message Digest md = Message Digest . get Instance ( STR_ ) ; md . reset ( ) ; md . update ( value ) ; return md . digest ( ) ; }
public static boolean is Right Mouse Button ( Mouse Event an Event ) { return ( ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 3 DOWN MASK ) != NUM_ || an Event . get Button ( ) == Mouse Event . BUTTON 3 ) ; }
private static Name Component parse Component ( String comp Str ) throws Invalid Name Exception { Name Component comp = new Name Component ( ) ; int kind Sep = - NUM_ ; int len = comp Str . length ( ) ; int j = NUM_ ; char [ ] new Str = new char [ len ] ; boolean escaped = false ; for ( int i = NUM_ ; i < len && kind Sep < NUM_ ; i ++ ) { if ( escaped ) { new Str [ j ++ ] = comp Str . char At ( i ) ; escaped = false ; } else if ( comp Str . char At ( i ) == escape Char ) { if ( i + NUM_ >= len ) { throw new Invalid Name Exception ( comp Str + STR_ ) ; } else if ( is Meta ( comp Str . char At ( i + NUM_ ) ) ) { escaped = true ; } else { throw new Invalid Name Exception ( comp Str + STR_ ) ; } } else if ( comp Str . char At ( i ) == kind Separator ) { kind Sep = i ; } else { new Str [ j ++ ] = comp Str . char At ( i ) ; } } comp . id = new String ( new Str , NUM_ , j ) ; if ( kind Sep < NUM_ ) { comp . kind = STR_ ; } else { j = NUM_ ; escaped = false ; for ( int i = kind Sep + NUM_ ; i < len ; i ++ ) { if ( escaped ) { new Str [ j ++ ] = comp Str . char At ( i ) ; escaped = false ; } else if ( comp Str . char At ( i ) == escape Char ) { if ( i + NUM_ >= len ) { throw new Invalid Name Exception ( comp Str + STR_ ) ; } else if ( is Meta ( comp Str . char At ( i + NUM_ ) ) ) { escaped = true ; } else { throw new Invalid Name Exception ( comp Str + STR_ ) ; } } else { new Str [ j ++ ] = comp Str . char At ( i ) ; } } comp . kind = new String ( new Str , NUM_ , j ) ; } return comp ; }
Optional < String > jar Root ( ) { return Optional . of Nullable ( jar Root ) ; }
public boolean contains File ( File file ) { return ( file == null ) ? false : xml Files . contains Key ( file . get Name ( ) ) ; }
public static boolean is Win 2 k User Defined File Ext Exist ( String file Ext ) { boolean win 2 k File Defined By User = false ; if ( os Name . equals Ignore Case ( WIN 2 KOS ) ) { String file Ext Key = USER FILE EXT KEY PREFIX + STR_ + file Ext ; win 2 k File Defined By User = is Sub Key Exist ( file Ext Key , USER LEVEL ) ; } return win 2 k File Defined By User ; }
public Boolean Condition Builder should ( Condition Builder < ? , ? > ... builders ) { should . add All ( Arrays . as List ( builders ) ) ; return this ; }
public static boolean matches Checker Or Subchecker From List ( final String processor String , List < String > fully Qualified Checker Names ) { if ( processor String . contains ( STR_ ) ) { return false ; } return fully Qualified Checker Names . contains ( unshorthand Processor Names ( processor String , fully Qualified Checker Names , true ) ) ; }
static Attribute Name name By Buffer ( @ No Length char [ ] buf , int offset , int length , boolean check Nc Name ) { int hash = Attribute Name . buf To Hash ( buf , length ) ; int index = Arrays . binary Search ( Attribute Name . ATTRIBUTE HASHES , hash ) ; if ( index < NUM_ ) { return Attribute Name . create Attribute Name ( Portability . new Local Name From Buffer ( buf , offset , length ) , check Nc Name ) ; } else { Attribute Name rv = Attribute Name . ATTRIBUTE NAMES [ index ] ; @ Local String name = rv . get Local ( Attribute Name . HTML ) ; if ( ! Portability . local Equals Buffer ( name , buf , offset , length ) ) { return Attribute Name . create Attribute Name ( Portability . new Local Name From Buffer ( buf , offset , length ) , check Nc Name ) ; } return rv ; } }
@ Override public Enumeration < Acl Entry > entries ( ) { return entry List . elements ( ) ; }
public void add ( Message Event e ) { m queue . add ( e ) ; Byte Buf buf = ( Byte Buf ) e . get Msg ( ) ; m buffer Size . add And Get ( buf . readable Bytes ( ) ) ; }
public static boolean same Proxy Class ( Object proxy 1 , Object proxy 2 ) { return ( proxy 1 . get Class ( ) == proxy 2 . get Class ( ) || ( Proxy . is Proxy Class ( proxy 2 . get Class ( ) ) && equal Interfaces ( proxy 1 , proxy 2 ) ) ) ; }
public String shortest Match ( String input ) { Trie Node node = root ; for ( int i = NUM_ ; i < input . length ( ) ; i ++ ) { node = node . get Child ( input . char At ( i ) ) ; if ( node == null ) return null ; if ( node . is Terminal ( ) ) return input . substring ( NUM_ , i + NUM_ ) ; } return null ; }
private static String to String Pretty ( Json Array json Array , int level ) { String Buffer buf = new String Buffer ( ) ; buf . append ( STR_ ) ; String indent = STR_ + VA Utils . indent ( level ) ; boolean first Elt = true ; for ( int i = NUM_ ; i < json Array . size ( ) ; i ++ ) { Json Element elt = json Array . get ( i ) ; if ( first Elt ) first Elt = false ; else buf . append ( STR_ ) ; buf . append ( indent ) ; buf . append ( to String Pretty ( elt , level + NUM_ ) ) ; } buf . append ( STR_ ) ; return buf . to String ( ) ; }
Map . Entry < K , V > do Remove First Entry ( ) { for ( ; ; ) { Node < K , V > b = head . node ; Node < K , V > n = b . next ; if ( n == null ) return null ; Node < K , V > f = n . next ; if ( n != b . next ) continue ; Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; continue ; } if ( ! n . cas Value ( v , null ) ) continue ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find First ( ) ; clear Index To First ( ) ; return new Abstract Map . Simple Immutable Entry < K , V > ( n . key , ( V ) v ) ; } }
public boolean is Detail ( ) { if ( m vo . Tab Level == NUM_ ) return false ; if ( m parents . size ( ) > NUM_ || m vo . AD Column ID != NUM_ ) return true ; return false ; }
public final void return Move List ( Array List < Move > move List ) { if ( moves In Cache + move List . size ( ) <= move Cache . length ) { int ml Size = move List . size ( ) ; for ( int mi = NUM_ ; mi < ml Size ; mi ++ ) { move Cache [ moves In Cache ++ ] = move List . get ( mi ) ; } } move List . clear ( ) ; if ( move Lists In Cache < move List Cache . length ) { move List Cache [ move Lists In Cache ++ ] = move List ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private static int Windows Reg Flush Key 1 ( int h Key ) { int result = Windows Reg Flush Key ( h Key ) ; if ( result == ERROR SUCCESS ) { return result ; } else { long sleep Time = INIT SLEEP TIME ; for ( int i = NUM_ ; i < MAX ATTEMPTS ; i ++ ) { try { Thread . sleep ( sleep Time ) ; } catch ( Interrupted Exception e ) { return result ; } sleep Time *= NUM_ ; result = Windows Reg Flush Key ( h Key ) ; if ( result == ERROR SUCCESS ) { return result ; } } } return result ; }
public boolean contains ( Data Source source ) { return data . contains ( source ) ; }
private Client Socket open Recycle ( ) { long now = Current Time . current Time ( ) ; Client Socket stream = null ; synchronized ( this ) { if ( idle Head != idle Tail ) { stream = idle [ idle Head ] ; long free Time = stream . get Idle Start Time ( ) ; idle [ idle Head ] = null ; idle Head = ( idle Head + idle . length - NUM_ ) % idle . length ; if ( now < free Time + load Balance Idle Time ) { active Count . increment And Get ( ) ; keepalive Count Total ++ ; stream . clear Idle Start Time ( ) ; stream . to Active ( ) ; return stream ; } } } if ( stream != null ) { if ( log . is Loggable ( Level . FINER ) ) log . finer ( this + STR_ + stream + STR_ + Q Date . format ISO 8601 ( stream . get Idle Start Time ( ) + load Balance Idle Time ) ) ; stream . close Impl ( ) ; } return null ; }
private Ok Http Client copy With Defaults ( ) { Ok Http Client result = new Ok Http Client ( this ) ; result . proxy = proxy ; result . proxy Selector = proxy Selector != null ? proxy Selector : Proxy Selector . get Default ( ) ; result . cookie Handler = cookie Handler != null ? cookie Handler : Cookie Handler . get Default ( ) ; result . response Cache = response Cache != null ? response Cache : Response Cache . get Default ( ) ; result . ssl Socket Factory = ssl Socket Factory != null ? ssl Socket Factory : Https URL Connection . get Default SSL Socket Factory ( ) ; result . hostname Verifier = hostname Verifier != null ? hostname Verifier : Ok Hostname Verifier . INSTANCE ; result . authenticator = authenticator != null ? authenticator : Http Authenticator . SYSTEM DEFAULT ; result . connection Pool = connection Pool != null ? connection Pool : Connection Pool . get Default ( ) ; result . follow Protocol Redirects = follow Protocol Redirects ; result . transports = transports != null ? transports : DEFAULT TRANSPORTS ; result . connect Timeout = connect Timeout ; result . read Timeout = read Timeout ; return result ; }
public static int as Int ( double datum , int n ) { double d = ( datum == NUM_ ) ? NUM_ : datum ; long [ ] data = { Double . double To Long Bits ( d ) } ; return as Integer ( data , n ) ; }
public static boolean are Mapped Objects ( Class < ? > d Class , Class < ? > s Class , XML xml ) { return is Mapped ( d Class , xml ) || is Mapped ( s Class , xml ) ; }
Map . Entry < K , V > do Remove Last Entry ( ) { for ( ; ; ) { Node < K , V > b = find Predecessor Of Last ( ) ; Node < K , V > n = b . next ; if ( n == null ) { if ( b . is Base Header ( ) ) return null ; else continue ; } for ( ; ; ) { Node < K , V > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; if ( f != null ) { b = n ; n = f ; continue ; } if ( ! n . cas Value ( v , null ) ) break ; K key = n . key ; Comparable < ? super K > ck = comparable ( key ) ; if ( ! n . append Marker ( f ) || ! b . cas Next ( n , f ) ) find Node ( ck ) ; else { find Predecessor ( ck ) ; if ( head . right == null ) try Reduce Level ( ) ; } return new Abstract Map . Simple Immutable Entry < K , V > ( key , ( V ) v ) ; } } }
public boolean is Cleared ( ) { sync . lock ( ) ; try { return state == Value State . CLEARED ; } finally { sync . unlock ( ) ; } }
public Address Impl parse Address ( String address ) throws Parse Exception { Address Parser address Parser = new Address Parser ( address ) ; return address Parser . address ( true ) ; }
public Script List Table script List ( ) { if ( script List Table . get ( ) == null ) { script List Table . compare And Set ( null , gsub . create Script List ( ) ) ; } return script List Table . get ( ) ; }
boolean is Automatic Dialog Support Enabled ( ) { return super . is Automatic Dialog Support Enabled ; }
public Boolean is Theme Constant ( String constant Name ) { String c = get Theme Constant ( constant Name , null ) ; if ( c == null ) { return null ; } if ( c . equals Ignore Case ( STR_ ) || c . equals ( STR_ ) ) { return Boolean . TRUE ; } return Boolean . FALSE ; }
public static String append XML Property ( String xml , String property XML ) { int idx = xml . last Index Of ( Property Template . SECTION END TAG ) ; if ( idx != - NUM_ ) { xml = xml . substring ( NUM_ , idx ) + property XML + xml . substring ( idx ) ; } return xml ; }
public char peek ( ) { return is Empty ( ) ? NUM_ : queue . char At ( pos ) ; }
static String path To Cookie Path ( String path ) { if ( path == null ) { return STR_ ; } int last Slash = path . last Index Of ( STR_ ) ; return path . substring ( NUM_ , last Slash + NUM_ ) ; }
public static void check Flags Argument ( final int requested Flags , final int allowed Flags ) { if ( ( requested Flags & allowed Flags ) != requested Flags ) { throw new Illegal Argument Exception ( STR_ + Integer . to Hex String ( requested Flags ) + STR_ + Integer . to Hex String ( allowed Flags ) + STR_ ) ; } }
private void validate Type Not In ( Type Mirror t , Set < Type Kind > invalid Kinds ) { if ( invalid Kinds . contains ( t . get Kind ( ) ) ) throw new Illegal Argument Exception ( t . to String ( ) ) ; }
static String join ( Char Sequence delimiter , Iterable tokens ) { String Builder sb = new String Builder ( ) ; boolean first Time = true ; for ( Object item : tokens ) { if ( first Time ) { first Time = false ; } else { sb . append ( delimiter ) ; } sb . append ( item ) ; } return sb . to String ( ) ; }
public static String strip Upto ( String value , char c ) { String result = null ; if ( value != null ) { int index = value . index Of ( c ) ; if ( index > NUM_ ) { result = value . substring ( index + NUM_ ) ; } } return result ; }
public double distance ( double x , double y ) { double dx = this . x - x ; double dy = this . y - y ; return Math . sqrt ( dx * dx + dy * dy ) ; }
public static < T extends Enum < T > > Set < String > names ( Class < T > enum Type ) { Set < String > set = NAMESETS . get ( enum Type ) ; if ( set == null ) { set = new Linked Hash Set < > ( ) ; for ( T constant : enum Type . get Enum Constants ( ) ) { set . add ( constant . to String ( ) ) ; } NAMESETS . put ( enum Type , Collections . unmodifiable Set ( set ) ) ; } return set ; }
public boolean verify Signature ( byte [ ] signature ) { if ( for Signing ) { throw new Illegal State Exception ( STR_ ) ; } byte [ ] hash = new byte [ digest . get Digest Size ( ) ] ; digest . do Final ( hash , NUM_ ) ; try { byte [ ] sig = engine . process Block ( signature , NUM_ , signature . length ) ; if ( sig . length < hash . length ) { byte [ ] tmp = new byte [ hash . length ] ; System . arraycopy ( sig , NUM_ , tmp , tmp . length - sig . length , sig . length ) ; sig = tmp ; } return Arrays . constant Time Are Equal ( sig , hash ) ; } catch ( Exception e ) { return false ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( NUM_ ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public String to Hex String ( ) { String Buffer buf = new String Buffer ( ) ; buf . append ( STR_ + Integer . to Hex String ( NUM_ & data Chars [ NUM_ ] ) ) ; for ( int i = NUM_ ; i < n Data Chars ; i ++ ) { buf . append ( STR_ + Integer . to Hex String ( NUM_ & data Chars [ i ] ) ) ; } return buf . to String ( ) ; }
private boolean has Extension ( final File the File , final String extension ) { return extension . equals ( get Extension ( the File ) ) ; }
public static long pop union ( long [ ] arr 1 , long [ ] arr 2 , int word Offset , int num Words ) { long pop Count = NUM_ ; for ( int i = word Offset , end = word Offset + num Words ; i < end ; ++ i ) { pop Count += Long . bit Count ( arr 1 [ i ] | arr 2 [ i ] ) ; } return pop Count ; }
protected static DNS Task Starter new DNS Task Starter ( Jm DNS Impl jm DNS Impl ) { DNS Task Starter instance = null ; Class Delegate delegate = database Class Delegate . get ( ) ; if ( delegate != null ) { instance = delegate . new DNS Task Starter ( jm DNS Impl ) ; } return ( instance != null ? instance : new DNS Task Starter Impl ( jm DNS Impl ) ) ; }
public static float [ ] close L La ( float [ ] lla ) { int l = lla . length ; int s = ( l / NUM_ ) - NUM_ ; if ( lla [ NUM_ ] == lla [ s * NUM_ ] && lla [ NUM_ ] == lla [ s * NUM_ + NUM_ ] ) { return lla ; } else { float [ ] llx = new float [ l + NUM_ ] ; System . arraycopy ( lla , NUM_ , llx , NUM_ , l ) ; llx [ l ] = lla [ NUM_ ] ; llx [ l + NUM_ ] = lla [ NUM_ ] ; return llx ; } }
private boolean actions Match ( Implicit Intent Model intent , Intent Filter intent Filter ) { Set < String > filter Actions = new Hash Set < String > ( ) ; filter Actions . add All ( intent Filter . actions ) ; for ( String action : filter Actions ) { logger . info ( STR_ , action ) ; } if ( filter Actions . size ( ) == NUM_ ) return false ; if ( ! intent . is Field Invalidated ( Implicit Intent Fields . ACTION ) ) { for ( String intent Action : intent . get Values ( Implicit Intent Fields . ACTION ) ) { logger . info ( STR_ , intent Action ) ; if ( filter Actions . contains ( intent Action ) ) return true ; } logger . info ( STR_ ) ; return false ; } else { logger . info ( STR_ ) ; return true ; } }
public static boolean has Class ( Maven Project project , String ... class Names ) { URL Class Loader compile Class Loader = get Compile Class Loader ( project ) ; for ( String class Name : class Names ) { try { compile Class Loader . load Class ( class Name ) ; return true ; } catch ( Throwable e ) { } } return false ; }
public Result filter Out ( List < String > sources ) { Result ret = new Result ( ) ; for ( Result Entry l : this . log ) { if ( ! sources . contains ( l . get Source ( ) ) ) { ret . add ( l ) ; } } return ret ; }
public static byte [ ] chars 2 utf ( char [ ] src , int sindex , int len ) { byte [ ] dst = new byte [ len * NUM_ ] ; int len 1 = chars 2 utf ( src , sindex , dst , NUM_ , len ) ; byte [ ] result = new byte [ len 1 ] ; System . arraycopy ( dst , NUM_ , result , NUM_ , len 1 ) ; return result ; }
private Worker Op next Op ( ) { if ( complete ) return Worker Op . NO OP ; if ( is Ready ( ) ) { if ( need Commit ) return Worker Op . COMMIT ; else if ( need Window ) return Worker Op . WINDOW ; else if ( end Of Stream ) return Worker Op . END OF STREAM ; else if ( ! pending Envelop Queue . is Empty ( ) ) return Worker Op . PROCESS ; } return Worker Op . NO OP ; }
public int size ( ) { if ( m Garbage ) { gc ( ) ; } return m Size ; }
private boolean before ( long a , long b ) { return a < b ^ a - b > ( MAXIMUM KEY / NUM_ ) ; }
public static boolean is False ( String key , boolean default Val ) { return ! is True ( key , default Val ) ; }
public static double entropy ( double [ ] vector ) { if ( vector == null ) return NUM_ ; else if ( vector . length < NUM_ ) return NUM_ ; else { double ret = NUM_ ; for ( double d : vector ) ret += d * Math . log ( d ) ; return ret ; } }
public float distance ( double x , double y ) { float dist = normalize Distance For Line Width ( super . distance ( x , y ) ) ; float tmp Dist ; tmp Dist = center Point . distance ( x , y ) ; if ( tmp Dist < dist ) { dist = tmp Dist ; } return dist ; }
private List < String > extract Interval Range ( Facet Member Interval interval ) { List < String > range = new Array List < > ( ) ; range . add ( interval . get Lower Bound ( ) ) ; range . add ( interval . get Upper Bound ( ) ) ; return range ; }
@ Override public Object [ ] to Array ( ) { Object [ ] copy = new Object [ size ] ; System . arraycopy ( buffer , start , copy , NUM_ , size ) ; return copy ; }
public String return Volume HLU ( URI volume URI ) { String hlu = Export Group . LUN UNASSIGNED DECIMAL STR ; if ( volumes != null ) { String temp = volumes . get ( volume URI . to String ( ) ) ; hlu = ( temp != null ) ? temp : Export Group . LUN UNASSIGNED DECIMAL STR ; } return hlu ; }
protected DBMS Event extract Event Statement Level ( String first Data ) throws Interrupted Exception , Extractor Exception { boolean do Commit ; boolean first = true ; if ( ! initialized ) throw new Extractor Exception ( STR_ ) ; Array List < DBMS Data > trx = new Array List < DBMS Data > ( NUM_ ) ; while ( true ) { DBMS Event dbms Event = null ; String query String ; if ( first ) query String = first Data ; else query String = get Next Op ( ) ; first = false ; if ( query String . compare To ( STR_ ) == NUM_ ) { do Commit = true ; } else { do Commit = false ; } if ( query String . index Of ( STR_ ) == NUM_ || query String . index Of ( STR_ ) == NUM_ ) { trx . add ( new Statement Data ( query String ) ) ; do Commit = true ; } if ( do Commit ) { dbms Event = new DBMS Event ( last Event ID , trx , new Timestamp ( System . current Time Millis ( ) ) ) ; } else { trx . add ( new Statement Data ( query String ) ) ; } if ( dbms Event != null ) { return dbms Event ; } } }
@ Deprecated public static double [ ] combine ( double [ ] x , double [ ] y ) { int len = NUM_ ; if ( x != null ) len += x . length ; if ( y != null ) len += y . length ; double [ ] z = null ; if ( len > NUM_ ) { z = new double [ len ] ; int current Pos = NUM_ ; if ( x != null ) { System . arraycopy ( x , NUM_ , z , current Pos , x . length ) ; current Pos = x . length ; } if ( y != null ) System . arraycopy ( y , NUM_ , z , current Pos , y . length ) ; } return z ; }
@ Override public boolean contains Symbol ( String symbol ) { int bucket = hash ( symbol ) % f Table Size ; int length = symbol . length ( ) ; OUTER : for ( SR Entry entry = f Buckets [ bucket ] ; entry != null ; entry = entry . next ) { SR Entry Data data = ( SR Entry Data ) entry . get ( ) ; if ( data == null ) { continue ; } if ( length == data . characters . length ) { for ( int i = NUM_ ; i < length ; i ++ ) { if ( symbol . char At ( i ) != data . characters [ i ] ) { continue OUTER ; } } return true ; } } return false ; }
public static Number add ( Number a , Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return a . double Value ( ) + b . double Value ( ) ; } else { return a . long Value ( ) + b . long Value ( ) ; } }
private List clone Sequence ( ) { if ( marker Sequence == null ) { return null ; } List retval = new Array List ( marker Sequence . size ( ) ) ; Iterator iter = marker Sequence . iterator ( ) ; while ( iter . has Next ( ) ) { Marker Segment seg = ( Marker Segment ) iter . next ( ) ; retval . add ( seg . clone ( ) ) ; } return retval ; }
public static String bitcoin Value To Friendly String ( Big Integer value ) { boolean negative = value . compare To ( Big Integer . ZERO ) < NUM_ ; if ( negative ) value = value . negate ( ) ; Big Decimal bd = new Big Decimal ( value , NUM_ ) ; String formatted = bd . to Plain String ( ) ; int decimal Point = formatted . index Of ( STR_ ) ; int to Delete = NUM_ ; for ( int i = formatted . length ( ) - NUM_ ; i > decimal Point + NUM_ ; i -- ) { if ( formatted . char At ( i ) == STR_ ) to Delete ++ ; else break ; } return ( negative ? STR_ : STR_ ) + formatted . substring ( NUM_ , formatted . length ( ) - to Delete ) ; }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ + STR_ ; }
int calculate Height ( int width , double ratio ) { if ( ratio == NUM_ ) { return NUM_ ; } return ( int ) Math . round ( width / ratio ) ; }
public boolean is Managing Component ( Control c ) { return scr Constr Map . contains Key ( c ) ; }
public static String now ( String date Format ) { Calendar cal = Calendar . get Instance ( ) ; Simple Date Format sdf = new Simple Date Format ( date Format ) ; return sdf . format ( cal . get Time ( ) ) ; }
public boolean is Match ( Inet Address inet Address ) { byte [ ] bytes = inet Address . get Address ( ) ; if ( bytes . length != address . length ) return false ; for ( int i = NUM_ ; i < bytes . length ; i ++ ) { if ( bytes [ i ] == address [ i ] ) { } else if ( subnet Byte < i ) { return true ; } else if ( i == subnet Byte ) { return ( bytes [ i ] & subnet Mask ) == ( address [ i ] & subnet Mask ) ; } else { return false ; } } return true ; }
static String generate Node Name ( final String host Name , final String host Port , final String host Context ) { try { return host Name + STR_ + host Port + STR_ + URL Encoder . encode ( trim Leading And Trailing Slashes ( host Context ) , STR_ ) ; } catch ( Unsupported Encoding Exception e ) { throw new Error ( STR_ , e ) ; } }
public int hash Code ( ) { return ( Float . float To Int Bits ( extra Alpha ) * NUM_ + rule ) ; }
protected boolean is Distorted ( ) { if ( ! is Transformed ( ) ) { return false ; } int type = transform . get Type ( ) ; int other But Translated Or Scaled = ~ ( Affine Transform . TYPE TRANSLATION | Affine Transform . TYPE MASK SCALE ) ; return ( type & other But Translated Or Scaled ) != NUM_ ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( ! event Name . equals ( STR_ ) && ! event Name . equals ( STR_ ) && ! event Name . equals ( STR_ ) && ! event Name . equals ( STR_ ) ) { return false ; } if ( m listenee != null ) { return false ; } return true ; }
public int hash Code ( ) { return id . hash Code ( ) ^ ( transport != null ? transport . hash Code ( ) : NUM_ ) ; }
public boolean has Cached Value ( ) { sync . lock ( ) ; try { return state == Value State . SET ; } finally { sync . unlock ( ) ; } }
public static File [ ] find Files ( String file Name ) { return find Files ( file Name , null ) ; }
private String lines ( int start Line , String s ) { String lines [ ] = s . split ( STR_ ) ; return lines To String ( start Line , lines ) ; }
public List < Snapshot > snapshots ( String repository Name ) { Set < Snapshot > snapshot Set = new Hash Set ( ) ; List < Snapshots In Progress . Entry > entries = current Snapshots ( repository Name , null ) ; for ( Snapshots In Progress . Entry entry : entries ) { snapshot Set . add ( in Progress Snapshot ( entry ) ) ; } Repository repository = repositories Service . repository ( repository Name ) ; List < Snapshot Id > snapshot Ids = repository . snapshots ( ) ; for ( Snapshot Id snapshot Id : snapshot Ids ) { snapshot Set . add ( repository . read Snapshot ( snapshot Id ) ) ; } Array List < Snapshot > snapshot List = new Array List < > ( snapshot Set ) ; Collection Util . tim Sort ( snapshot List ) ; return Collections . unmodifiable List ( snapshot List ) ; }
private int count ( Database conn ) throws SQL Exception { Statement stmt = null ; Result Set res = null ; int task Rows = NUM_ ; try { stmt = conn . create Statement ( ) ; res = stmt . execute Query ( all Seqno Query ) ; while ( res . next ( ) ) { task Rows ++ ; } } finally { connection Manager . close ( res ) ; connection Manager . close ( stmt ) ; } return task Rows ; }
public static List < ? extends Node > child Node List ( Node node ) { if ( node == null ) return null ; List < Node > nodes = new Linked List < Node > ( ) ; do { if ( node . get Node Type ( ) == Node . ELEMENT NODE || node . get Node Type ( ) == Node . COMMENT NODE ) { nodes . add ( node ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; return nodes ; }
public int size ( ) { return sorted Set . size ( ) ; }
private I Constant < ? > [ ] accept ( final I Binding Set bset ) { final I Constant < ? > [ ] r = new I Constant < ? > [ vars . length ] ; for ( int i = NUM_ ; i < vars . length ; i ++ ) { r [ i ] = bset . get ( vars [ i ] ) ; } final Solution s = new Solution ( r ) ; if ( log . is Trace Enabled ( ) ) log . trace ( STR_ + Arrays . to String ( r ) ) ; final boolean distinct = map . put If Absent ( s , s ) == null ; if ( distinct && log . is Debug Enabled ( ) ) log . debug ( STR_ + Arrays . to String ( r ) ) ; return distinct ? r : null ; }
public static boolean is Name Registration Cancelled ( Http Servlet Request request ) { String status = request . get Parameter ( IFS Constants . REGISTRATION STATUS ) ; if ( status != null && status . equals Ignore Case ( IFS Constants . CANCEL ) ) { return true ; } else { return false ; } }
public Iterator < String > list ( ) { final File store Dir = new File ( m base Directory . get Absolute Path ( ) ) ; final String [ ] names = store Dir . list ( m filter ) ; final List < String > list = new Array List < String > ( ) ; for ( String name : names ) { String decoded = decode ( name ) ; list . add ( decoded ) ; } return list . iterator ( ) ; }
public final double sample Min ( ) { long count = acquire Count . get ( ) - release Count . get ( ) ; long min = min . get And Set ( count ) ; return min ; }
public static boolean has Builtin Binding ( New Binding Key key ) { return has Builtin Binding ( key . get Type Name ( ) ) ; }
static URI without Fragment ( final String full Uri ) { int hashmark Idx = full Uri . index Of ( STR_ ) ; String rval ; if ( hashmark Idx == - NUM_ ) { rval = full Uri ; } else { rval = full Uri . substring ( NUM_ , hashmark Idx ) ; } try { return new URI ( rval ) ; } catch ( URI Syntax Exception e ) { throw new Runtime Exception ( e ) ; } }
protected Lat Lon Point assert Lat Lon Point ( Point 2 D p 2 d ) { if ( p 2 d instanceof Lat Lon Point ) { return ( Lat Lon Point ) p 2 d ; } else { return new Lat Lon Point . Double ( p 2 d . get Y ( ) , p 2 d . get X ( ) ) ; } }
public boolean is Incremental ( String var ) { return incremental Vars . contains ( var . replace ( STR_ , STR_ ) ) ; }
public static Byte Buf encode Fixed Length Content ( byte [ ] content ) { Byte Buf out = Unpooled . buffer ( NUM_ ) ; out . write Short ( content . length ) ; out . write Bytes ( content ) ; return out ; }
public double [ ] sample ( int num Samples , Random rand ) { double [ ] samples = new double [ num Samples ] ; for ( int i = NUM_ ; i < samples . length ; i ++ ) samples [ i ] = inv Cdf ( rand . next Double ( ) ) ; return samples ; }
public List < String > local Text ( ) { List < String > answer = new Array List < String > ( ) ; for ( Iterator iter = Invoker Helper . as Iterator ( value ) ; iter . has Next ( ) ; ) { Object child = iter . next ( ) ; if ( ! ( child instanceof Node ) ) { answer . add ( child . to String ( ) ) ; } } return answer ; }
static boolean verify Zip File ( File file ) { try { Zip File zip File = new Zip File ( file ) ; try { zip File . close ( ) ; return true ; } catch ( IO Exception e ) { Log . w ( TAG , STR_ + file . get Absolute Path ( ) ) ; } } catch ( Zip Exception ex ) { Log . w ( TAG , STR_ + file . get Absolute Path ( ) + STR_ , ex ) ; } catch ( IO Exception ex ) { Log . w ( TAG , STR_ + file . get Absolute Path ( ) , ex ) ; } return false ; }
public static boolean any Misbehave ( Formatter formatter , List < File > problem Files ) { long start = System . current Time Millis ( ) ; for ( File problem : problem Files ) { Padded Cell padded = Padded Cell . check ( formatter , problem ) ; if ( padded . misbehaved ( ) ) { return true ; } if ( System . current Time Millis ( ) - start > MAX MS DETERMINING MISBEHAVIOR ) { return false ; } } return false ; }
public Dimension maximum Layout Size ( Container target ) { Dimension rd , mbd ; Insets i = get Insets ( ) ; if ( menu Bar != null && menu Bar . is Visible ( ) ) { mbd = menu Bar . get Maximum Size ( ) ; } else { mbd = new Dimension ( NUM_ , NUM_ ) ; } if ( content Pane != null ) { rd = content Pane . get Maximum Size ( ) ; } else { rd = new Dimension ( Integer . MAX VALUE , Integer . MAX VALUE - i . top - i . bottom - mbd . height - NUM_ ) ; } return new Dimension ( Math . min ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + XRFF Loader . FILE EXTENSION COMPRESSED + STR_ + XRFF Loader . FILE EXTENSION + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public String prototype ( cp info constant pool [ ] ) { String access , rt , name , params ; Code attribute c = locate code attribute ( ) ; access = Class File . access string ( access flags , STR_ ) ; rt = Class File . parse Method Desc return ( cp info . get Type Descr ( constant pool , descriptor index ) ) ; name = to Name ( constant pool ) ; params = Class File . parse Method Desc params ( cp info . get Type Descr ( constant pool , descriptor index ) ) ; if ( access . length ( ) > NUM_ ) return access + STR_ + rt + STR_ + name + STR_ + params + STR_ ; return rt + STR_ + name + STR_ + params + STR_ ; }
public static Print Writer open Print Writer To File ( File file , boolean verbose ) throws Ade Usage Exception { try { if ( verbose ) { logger . info ( STR_ + file . get Path ( ) ) ; } return new Print Writer ( file , FILE ENCODING ) ; } catch ( File Not Found Exception e ) { throw new Ade Usage Exception ( STR_ + file . get Path ( ) , e ) ; } catch ( Unsupported Encoding Exception e ) { throw new Ade Usage Exception ( STR_ + FILE ENCODING , e ) ; } }
public static < K extends Throwable > void rewrap And Throw If Instance ( Throwable t , Class < K > clazz ) throws K { rewrap And Throw If Instance ( t == null ? STR_ : t . get Message ( ) , t , clazz ) ; }
@ Override public void run ( ) { while ( ! is Interrupted ( ) ) { try { Value Holder < K , V > ref = ( Value Holder < K , V > ) queue . remove ( ) ; table . remove ( ref . get Key ( ) ) ; } catch ( Interrupted Exception e ) { interrupt ( ) ; break ; } } }
private static boolean contains Or Extends ( @ Not Null Set < Psi Class > resolved Classes , @ Not Null Psi Class related Activity ) { if ( resolved Classes . contains ( related Activity ) ) { return true ; } for ( Psi Class resolved Class : resolved Classes ) { if ( related Activity . is Inheritor ( resolved Class , false ) ) { return true ; } } return false ; }
public Enumeration elements ( ) { return perms . elements ( ) ; }
public static Lat Lng translate Point ( Lat Lng point , double distance , double bearing ) { distance = distance / NUM_ ; double lat = Math . to Radians ( point . latitude ) ; double lng = Math . to Radians ( point . longitude ) ; bearing = Math . to Radians ( bearing ) ; double Lat 2 = Math . asin ( ( Math . sin ( lat ) * Math . cos ( distance / EARTH ) ) + ( Math . cos ( lat ) * Math . sin ( distance / EARTH ) * Math . cos ( bearing ) ) ) ; double Long 2 = lng + Math . atan 2 ( Math . sin ( bearing ) * Math . sin ( distance / EARTH ) * Math . cos ( lat ) , Math . cos ( distance / EARTH ) - ( Math . sin ( lat ) * Math . sin ( Lat 2 ) ) ) ; Lat 2 = Math . to Degrees ( Lat 2 ) ; Long 2 = Math . to Degrees ( Long 2 ) ; return new Lat Lng ( Lat 2 , Long 2 ) ; }
public int hash Code ( ) { return last Path Component . hash Code ( ) ; }
public String to Hex String ( ) { String Buffer buf = new String Buffer ( ) ; buf . append ( STR_ + Integer . to Hex String ( data Chars [ NUM_ ] ) ) ; for ( int i = NUM_ ; i < n Data Chars ; i ++ ) { buf . append ( STR_ + Integer . to Hex String ( data Chars [ i ] ) ) ; } return buf . to String ( ) ; }
private byte [ ] engine Digest ( byte [ ] in , int pos ) { if ( pos != NUM_ ) System . arraycopy ( in , NUM_ , tmp , NUM_ , pos ) ; tmp [ pos ++ ] = ( byte ) NUM_ ; if ( pos > DATA LENGTH - NUM_ ) { while ( pos < DATA LENGTH ) tmp [ pos ++ ] = NUM_ ; byte 2 int ( tmp , NUM_ , data , NUM_ , DATA LENGTH / NUM_ ) ; transform ( data ) ; pos = NUM_ ; } while ( pos < DATA LENGTH - NUM_ ) tmp [ pos ++ ] = NUM_ ; byte 2 int ( tmp , NUM_ , data , NUM_ , ( DATA LENGTH / NUM_ ) - NUM_ ) ; long bc = count * NUM_ ; data [ NUM_ ] = ( int ) ( bc > > > NUM_ ) ; data [ NUM_ ] = ( int ) bc ; transform ( data ) ; byte buf [ ] = new byte [ HASH LENGTH ] ; int off = NUM_ ; for ( int i = NUM_ ; i < HASH LENGTH / NUM_ ; ++ i ) { int d = digest [ i ] ; buf [ off ++ ] = ( byte ) ( d > > > NUM_ ) ; buf [ off ++ ] = ( byte ) ( d > > > NUM_ ) ; buf [ off ++ ] = ( byte ) ( d > > > NUM_ ) ; buf [ off ++ ] = ( byte ) d ; } engine Reset ( ) ; return buf ; }
public static Hashtable < String , Char Set > release Expression Cache ( ) { Hashtable < String , Char Set > result = expression Cache ; expression Cache = null ; return result ; }
static public double y 0 ( double x ) throws Arithmetic Exception { if ( x < NUM_ ) { double y = x * x ; double ans 1 = - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * NUM_ ) ) ) ) ; double ans 2 = NUM_ + y * ( NUM_ + y * ( NUM_ + y * ( NUM_ + y * ( NUM_ + y * NUM_ ) ) ) ) ; return ( ans 1 / ans 2 ) + NUM_ * j 0 ( x ) * Math . log ( x ) ; } else { double z = NUM_ / x ; double y = z * z ; double xx = x - NUM_ ; double ans 1 = NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * NUM_ ) ) ) ; double ans 2 = - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ ) ) ) ) ; return Math . sqrt ( NUM_ / x ) * ( Math . sin ( xx ) * ans 1 + z * Math . cos ( xx ) * ans 2 ) ; } }
public static String format Time ( long time Diff ) { String Builder buf = new String Builder ( ) ; long hours = time Diff / ( NUM_ * NUM_ * NUM_ ) ; long rem = ( time Diff % ( NUM_ * NUM_ * NUM_ ) ) ; long minutes = rem / ( NUM_ * NUM_ ) ; rem = rem % ( NUM_ * NUM_ ) ; long seconds = rem / NUM_ ; if ( hours != NUM_ ) { buf . append ( hours ) ; buf . append ( STR_ ) ; } if ( minutes != NUM_ ) { buf . append ( minutes ) ; buf . append ( STR_ ) ; } buf . append ( seconds ) ; buf . append ( STR_ ) ; return buf . to String ( ) ; }
public boolean can Connect ( ) { try { wake ( ) ; Client Socket stream = open ( ) ; if ( stream != null ) { stream . free ( stream . get Idle Start Time ( ) ) ; return true ; } return false ; } catch ( Exception e ) { log . log ( Level . FINER , e . to String ( ) , e ) ; return false ; } }
private static boolean is Boolean Property ( String property Name ) { return ( PROPERTY CHECKED . equals ( property Name ) || PROPERTY ENABLED . equals ( property Name ) || PROPERTY FULL SCREEN . equals ( property Name ) || PROPERTY SCROLLABLE . equals ( property Name ) || PROPERTY PASSWORD . equals ( property Name ) ) ; }
@ Uninterruptible Type Reference annotation Type ( ) { return type ; }
@ Override public String global Info ( ) { return STR_ + STR_ + STR_ ; }
public static boolean compare Dates ( final Date first Date , final Date second Date ) { return first Date == null || second Date == null ? true : first Date . before ( second Date ) ? false : true ; }
public static boolean is Authn Context Matching ( List requested AC Class Refs , String ac Class Ref , String comparison , Map ac Class Ref Level Map ) { Integer level Int = ( Integer ) ac Class Ref Level Map . get ( ac Class Ref ) ; if ( level Int == null ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + ac Class Ref + STR_ ) ; } return false ; } int level = level Int . int Value ( ) ; if ( ( comparison == null ) || ( comparison . length ( ) == NUM_ ) || ( comparison . equals ( STR_ ) ) ) { for ( Iterator iter = requested AC Class Refs . iterator ( ) ; iter . has Next ( ) ; ) { String requsted AC Class Ref = ( String ) iter . next ( ) ; if ( requsted AC Class Ref . equals ( ac Class Ref ) ) { return true ; } } return false ; } debug . message ( STR_ , ac Class Ref , level , comparison ) ; if ( comparison . equals ( STR_ ) ) { for ( Iterator iter = requested AC Class Refs . iterator ( ) ; iter . has Next ( ) ; ) { String requsted AC Class Ref = ( String ) iter . next ( ) ; Integer requested Level Int = ( Integer ) ac Class Ref Level Map . get ( requsted AC Class Ref ) ; int requested Level = ( requested Level Int == null ) ? NUM_ : requested Level Int . int Value ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + requsted AC Class Ref + STR_ + requested Level ) ; } if ( level >= requested Level ) { return true ; } } return false ; } else if ( comparison . equals ( STR_ ) ) { for ( Iterator iter = requested AC Class Refs . iterator ( ) ; iter . has Next ( ) ; ) { String requsted AC Class Ref = ( String ) iter . next ( ) ; Integer requested Level Int = ( Integer ) ac Class Ref Level Map . get ( requsted AC Class Ref ) ; int requested Level = ( requested Level Int == null ) ? NUM_ : requested Level Int . int Value ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + requsted AC Class Ref + STR_ + requested Level ) ; } if ( level <= requested Level ) { return false ; } } return true ; } else if ( comparison . equals ( STR_ ) ) { for ( Iterator iter = requested AC Class Refs . iterator ( ) ; iter . has Next ( ) ; ) { String requsted AC Class Ref = ( String ) iter . next ( ) ; Integer requested Level Int = ( Integer ) ac Class Ref Level Map . get ( requsted AC Class Ref ) ; int requested Level = ( requested Level Int == null ) ? NUM_ : requested Level Int . int Value ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + requsted AC Class Ref + STR_ + requested Level ) ; } if ( level <= requested Level ) { return true ; } } return false ; } return false ; }
public static boolean is Try Catch ( ) { return Boolean . get Boolean ( LOG ERROR PROPERTY ) ; }
public boolean is Expired ( ) { return System . current Time Millis ( ) >= creation Time + lifetime ; }
public boolean has Next ( ) { return current Position < content . length ( ) ; }
public Type lub ( List < Type > ts ) { return lub ( ts . to Array ( new Type [ ts . length ( ) ] ) ) ; }
public static int scalar Product ( final long [ ] x , final long [ ] y ) { int sum = NUM_ ; for ( int i = y . length ; i -- != NUM_ ; ) { final long high = x [ i ] & NUM_ ; final long low = x [ i ] & NUM_ ; final long high Shift = high > > > NUM_ ; final long t = ( y [ i ] ^ ( high | high Shift ) ) & ( x [ i ] | high Shift | low << NUM_ ) ; sum += Long . bit Count ( t & NUM_ ) * NUM_ + Long . bit Count ( t & NUM_ ) ; } return sum ; }
public Path remove First Segments ( int count ) { if ( count == NUM_ ) return this ; if ( count >= segments . length ) { return new Path ( device , NO SEGMENTS , NUM_ ) ; } check Argument ( count > NUM_ ) ; int new Size = segments . length - count ; String [ ] new Segments = new String [ new Size ] ; System . arraycopy ( this . segments , count , new Segments , NUM_ , new Size ) ; return new Path ( device , new Segments , separators & HAS TRAILING ) ; }
public Shape create Scroll Cap ( int x , int y , int w , int h ) { path . reset ( ) ; path . move To ( x , y ) ; path . line To ( x , y + h ) ; path . line To ( x + w , y + h ) ; add Scroll Gap Path ( x , y , w , h , true ) ; path . close Path ( ) ; return path ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public int size ( ) { return buffer List . size ( ) ; }
public static int hash Code ( Object o ) { return o != null ? o . hash Code ( ) : NUM_ ; }
public Collection < New Dependency Info > collect ( Collection < Type Element > modules , Collection < Type Element > member Injectors , List < String > all Errors ) { Set Multimap < New Binding Key , New Dependency Info > result = Hash Multimap . create ( ) ; modules = Utils . find All Modules Recursively ( modules ) ; for ( Type Element e : modules ) { Collection < New Dependency Info > dependencies = collect From Module ( e ) ; check Dependencies ( result , dependencies ) ; add Dependency Info ( result , dependencies ) ; } member Injectors = find All Members Injectors Recursively ( member Injectors ) ; Set < New Binding Key > required Keys = get Required Keys ( member Injectors , result ) ; add Dependencies For Required Keys ( result , required Keys ) ; all Errors . add All ( errors ) ; return result . values ( ) ; }
public int hash Code ( ) { return ( ref == null ) ? super . hash Code ( ) : ref . remote Hash Code ( ) ; }
protected Protected Properties create Metadata ( Element parent ) throws Exception { Protected Properties result ; Properties props ; Vector < Element > list ; Element node ; Element metanode ; int i ; result = null ; metanode = null ; list = get Child Tags ( parent , TAG METADATA ) ; if ( list . size ( ) > NUM_ ) { metanode = list . get ( NUM_ ) ; } if ( metanode != null ) { props = new Properties ( ) ; list = get Child Tags ( metanode , TAG PROPERTY ) ; for ( i = NUM_ ; i < list . size ( ) ; i ++ ) { node = list . get ( i ) ; props . set Property ( node . get Attribute ( ATT NAME ) , get Content ( node ) ) ; } result = new Protected Properties ( props ) ; } return result ; }
public int size ( ) { return queue . size ( ) ; }
public boolean is Alive ( ) { return ! socket . is Closed ( ) && ! socket . is Input Shutdown ( ) && ! socket . is Output Shutdown ( ) ; }
public final boolean is Editable ( ) { return editable ; }
static boolean is Group Sync Request Hack ( Manager manager , String identity , String servlet Path , String operation Name ) throws SQL Exception { Preconditions . check Not Null ( manager ) ; if ( identity == null ) { return false ; } if ( ! HACK ENDPOINT . equals ( servlet Path ) || ! HACK OPERATION . equals ( operation Name ) ) { return false ; } DB Identity requestor = DB Identity . get Identity For User Name ( manager , identity ) ; if ( requestor == null ) { return false ; } return true ; }
@ Override public boolean apply ( Type Mirror input ) { return input != null && input . accept ( this , null ) ; }
public String classifier Tip Text ( ) { return STR_ ; }
public Shape triangle down ( float x , float y , float height ) { m path . reset ( ) ; m path . move To ( x , y ) ; m path . line To ( x + height , y ) ; m path . line To ( x + height / NUM_ , ( y + height ) ) ; m path . close Path ( ) ; return m path ; }
int items Displayed ( ) { return ( Math . min ( items . size ( ) - vsb . get Value ( ) , items In Window ( ) ) ) ; }
private int [ ] randomize ( int [ ] array , Random generator ) { int index ; int temp ; int [ ] new Array = new int [ array . length ] ; System . arraycopy ( array , NUM_ , new Array , NUM_ , array . length ) ; for ( int j = new Array . length - NUM_ ; j > NUM_ ; j -- ) { index = ( int ) ( generator . next Double ( ) * ( double ) j ) ; temp = new Array [ j ] ; new Array [ j ] = new Array [ index ] ; new Array [ index ] = temp ; } return new Array ; }
public int hash Code ( ) { return Float . float To Int Bits ( value ) ; }
public boolean is Valid ( ) { return is Valid ( true ) ; }
@ Override public String next Element ( ) { return m Tokenizer . next Token ( ) ; }
public static byte [ ] copy Of ( byte [ ] arr , int offset , int new Length , int dst Offset ) { byte [ ] new Arr = new byte [ new Length ] ; int src Len = arr . length - offset ; int dst Len = new Length - dst Offset ; System . arraycopy ( arr , offset , new Arr , dst Offset , Math . min ( src Len , dst Len ) ) ; return new Arr ; }
public lalr item find ( lalr item itm ) { return ( lalr item ) all . get ( itm ) ; }
public static boolean is Mobile ( String phone Num ) { if ( phone Num != null ) { Pattern p = Pattern . compile ( STR_ ) ; Matcher m = p . matcher ( phone Num ) ; return m . matches ( ) ; } else { return false ; } }
public boolean is Visible ( String btn Name ) { Button btn = get Button ( btn Name ) ; if ( btn != null ) { return btn . is Visible ( ) ; } else { try { Messagebox . show ( STR_ + btn Name + STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return false ; } }
public Gender lookup Gender ( String text ) { return lookup ( exact Gender , starts With Gender , ends With Gender , text , Gender . UNKNOWN ) ; }
public Iterator < Capability > capabilities ( ) { return m Capabilities . iterator ( ) ; }
public static final XPATH Error Resources load Resource Bundle ( String class Name ) throws Missing Resource Exception { Locale locale = Locale . get Default ( ) ; String suffix = get Resource Suffix ( locale ) ; try { return ( XPATH Error Resources ) Resource Bundle . get Bundle ( class Name + suffix , locale ) ; } catch ( Missing Resource Exception e ) { try { return ( XPATH Error Resources ) Resource Bundle . get Bundle ( class Name , new Locale ( STR_ , STR_ ) ) ; } catch ( Missing Resource Exception e 2 ) { throw new Missing Resource Exception ( STR_ , class Name , STR_ ) ; } } }
private static void put New ( Map < Element , Annotated Type Mirror > m , Element key , Annotated Type Mirror value ) { if ( key == null ) { Error Reporter . error Abort ( STR_ ) ; return ; } if ( m . contains Key ( key ) ) { Annotated Type Mirror value 2 = m . get ( key ) ; Annotated Type Merger . merge ( value , value 2 ) ; m . put ( key , value 2 ) ; } else { m . put ( key , value ) ; } }
default boolean log Modified ( Logger log ) { if ( is Modified ( ) ) { log . finer ( this + STR_ ) ; return true ; } else { return false ; } }
public Object first Row ( ) throws SQL Exception { List rows = rows ( ) ; if ( rows . is Empty ( ) ) return null ; return ( rows . get ( NUM_ ) ) ; }
public static String to Comma Delimited String In Quotes ( Collection c ) { String Buffer result = new String Buffer ( ) ; for ( Iterator i = c . iterator ( ) ; i . has Next ( ) ; ) { Object o = i . next ( ) ; result . append ( STR_ + o . to String ( ) + STR_ ) ; } return result . substring ( NUM_ ) ; }
private static < T > T cast ( Class < T > clazz , Object o ) { if ( ! clazz . is Instance ( o ) ) throw new Illegal Argument Exception ( o . to String ( ) ) ; return clazz . cast ( o ) ; }
public static List reverse List ( List l ) { Linked List l Res = new Linked List ( ) ; int i List Size = l . size ( ) ; for ( int i Cnt = NUM_ ; i Cnt < i List Size ; i Cnt ++ ) { l Res . add ( l . get ( i List Size - i Cnt - NUM_ ) ) ; } return l Res ; }
public double distance ( I Multi Point imp ) { if ( imp . dimensionality ( ) != dimensionality ) { throw new Illegal Argument Exception ( STR_ ) ; } double sum = NUM_ ; if ( imp instanceof Hyperpoint ) { Hyperpoint other = ( Hyperpoint ) imp ; for ( int i = NUM_ ; i <= dimensionality ; i ++ ) { double d = other . values [ i - NUM_ ] - values [ i - NUM_ ] ; sum += d * d ; } } else { for ( int i = NUM_ ; i <= dimensionality ; i ++ ) { double v = imp . get Coordinate ( i ) ; sum += ( v - values [ i - NUM_ ] ) * ( v - values [ i - NUM_ ] ) ; } } return Math . sqrt ( sum ) ; }
public int size ( ) { return m Selected Widgets . size ( ) ; }
public boolean random Next Board ( int r ) { int sz = next Valid Row Positions . size ( ) ; if ( sz == NUM_ ) { return false ; } int c = ( int ) ( Math . random ( ) * sz ) ; board [ r ] [ next Valid Row Positions . get ( c ) ] = true ; return true ; }
private Automaton substitutions Of ( String s ) { List < Automaton > list = new Array List < > ( ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { Automaton a = Automata . make String ( s . substring ( NUM_ , i ) ) ; a = Operations . concatenate ( a , Automata . make Any Char ( ) ) ; a = Operations . concatenate ( a , Automata . make String ( s . substring ( i + NUM_ ) ) ) ; list . add ( a ) ; } Automaton a = Operations . union ( list ) ; a = Minimization Operations . minimize ( a , DEFAULT MAX DETERMINIZED STATES ) ; return a ; }
private String cannonical Page ( String url ) { String cannonical = STR_ ; if ( url . starts With ( HTTP PROTOCOL ) ) { url = url . substring ( HTTP PROTOCOL . length ( ) ) ; } else if ( url . starts With ( HTTPS PROTOCOL ) ) { url = url . substring ( HTTPS PROTOCOL . length ( ) ) ; } int url Length = url . length ( ) ; for ( int i = NUM_ ; i < url Length ; i ++ ) { if ( url . char At ( i ) != STR_ ) cannonical += url . char At ( i ) ; else break ; } return cannonical ; }
public static String of ( Ct Class type ) { String Buffer sbuf = new String Buffer ( ) ; to Descriptor ( sbuf , type ) ; return sbuf . to String ( ) ; }
public long to Nanos ( ) { return time Unit . to Nanos ( length ) ; }
public Flux Concat Array < T > concat Additional Source Last ( Publisher < ? extends T > source ) { int n = array . length ; @ Suppress Warnings ( STR_ ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM_ ] ; System . arraycopy ( array , NUM_ , new Array , NUM_ , n ) ; new Array [ n ] = source ; return new Flux Concat Array < > ( delay Error , new Array ) ; }
public Hash Map < String , String > properties For GID ( int GID ) { return tile Properties . get ( String . value Of ( GID ) ) ; }
public boolean has Draft ( long thread Id ) { synchronized ( m Draft Set Lock ) { return m Draft Set . contains ( thread Id ) ; } }
public Byte String file Key ( Key Bag key Bag , I Cloud . MBS File file ) { return file Key ( key Bag , file , aes Wraps . get ( ) , sha 256 s . get ( ) ) ; }
public int height ( ) { return height ; }
public static boolean is Numeric ( String number ) { if ( is Null Or Empty ( number ) ) { return false ; } try { Double . parse Double ( number ) ; return true ; } catch ( Number Format Exception ex ) { return false ; } }
public static mx Point intersection ( double x 0 , double y 0 , double x 1 , double y 1 , double x 2 , double y 2 , double x 3 , double y 3 ) { double denom = ( ( y 3 - y 2 ) * ( x 1 - x 0 ) ) - ( ( x 3 - x 2 ) * ( y 1 - y 0 ) ) ; double nume a = ( ( x 3 - x 2 ) * ( y 0 - y 2 ) ) - ( ( y 3 - y 2 ) * ( x 0 - x 2 ) ) ; double nume b = ( ( x 1 - x 0 ) * ( y 0 - y 2 ) ) - ( ( y 1 - y 0 ) * ( x 0 - x 2 ) ) ; double ua = nume a / denom ; double ub = nume b / denom ; if ( ua >= NUM_ && ua <= NUM_ && ub >= NUM_ && ub <= NUM_ ) { double intersection X = x 0 + ua * ( x 1 - x 0 ) ; double intersection Y = y 0 + ua * ( y 1 - y 0 ) ; return new mx Point ( intersection X , intersection Y ) ; } return null ; }
public final Iterator < Plugin Pattern Matcher > scheme Specific Parts Iterator ( ) { return m Data Scheme Specific Parts != null ? m Data Scheme Specific Parts . iterator ( ) : null ; }
protected boolean matches Type Reference ( char [ ] pattern , Type Reference type ) { if ( pattern == null ) return true ; if ( type == null ) return true ; char [ ] [ ] compound Name = type . get Type Name ( ) ; char [ ] simple Name = compound Name [ compound Name . length - NUM_ ] ; int dimensions = type . dimensions ( ) * NUM_ ; if ( dimensions > NUM_ ) { int length = simple Name . length ; char [ ] result = new char [ length + dimensions ] ; System . arraycopy ( simple Name , NUM_ , result , NUM_ , length ) ; for ( int i = length , l = result . length ; i < l ; ) { result [ i ++ ] = STR_ ; result [ i ++ ] = STR_ ; } simple Name = result ; } return matches Name ( pattern , simple Name ) ; }
void as Set ( ) { return Collections . empty Set ( ) ; }
public Shard Iterator active Initializing Shards It ( int seed ) { if ( all Initializing Shards . is Empty ( ) ) { return new Plain Shard Iterator ( shard Id , shuffler . shuffle ( active Shards , seed ) ) ; } Array List < Shard Routing > ordered = new Array List < > ( active Shards . size ( ) + all Initializing Shards . size ( ) ) ; ordered . add All ( shuffler . shuffle ( active Shards , seed ) ) ; ordered . add All ( all Initializing Shards ) ; return new Plain Shard Iterator ( shard Id , ordered ) ; }
public boolean is Stopped ( ) { return this . stopped ; }
public String build Os ( ) { return properties . get Property ( STR_ ) ; }
@ Override public int hash Code ( ) { return rule ID . hash Code ( ) ; }
public Table sort On ( String ... column Names ) { Sort key = null ; Sort . Order order ; List < String > names = new Array List < > ( ) ; for ( String name : column Names ( ) ) { names . add ( name . to Upper Case ( ) ) ; } for ( String column Name : column Names ) { if ( names . contains ( column Name . to Upper Case ( ) ) ) { order = Sort . Order . ASCEND ; } else { String prefix = column Name . substring ( NUM_ , NUM_ ) ; column Name = column Name . substring ( NUM_ , column Name . length ( ) ) ; switch ( prefix ) { case STR_ : order = Sort . Order . ASCEND ; break ; case STR_ : order = Sort . Order . DESCEND ; break ; default : throw new Illegal State Exception ( STR_ + prefix + STR_ ) ; } } if ( key == null ) { key = first ( column Name , order ) ; } else { key . next ( column Name , order ) ; } } return sort On ( key ) ; }
public static < E > Function < E , E > identity ( ) { return Function . identity ( ) ; }
static boolean is Plaintext ( Buffer buffer ) { try { Buffer prefix = new Buffer ( ) ; long byte Count = buffer . size ( ) < NUM_ ? buffer . size ( ) : NUM_ ; buffer . copy To ( prefix , NUM_ , byte Count ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int code Point = prefix . read Utf 8 Code Point ( ) ; if ( Character . is ISO Control ( code Point ) && ! Character . is Whitespace ( code Point ) ) { return false ; } } return true ; } catch ( EOF Exception e ) { return false ; } }
public boolean is Enabled ( ) { return ( ! port State Link Down && ! config . contains ( OF Port Config . OFPPC PORT DOWN ) ) ; }
public static String array To String ( String [ ] strs ) { if ( strs . length == NUM_ ) { return STR_ ; } String Builder sbuf = new String Builder ( ) ; sbuf . append ( strs [ NUM_ ] ) ; for ( int idx = NUM_ ; idx < strs . length ; idx ++ ) { sbuf . append ( STR_ ) ; sbuf . append ( strs [ idx ] ) ; } return sbuf . to String ( ) ; }
@ Override public void validate ( Map < String , Object > process Variables , Map < String , String > user Parameter ) throws Abort Exception { final Date due Date = ( Date ) process Variables . get ( I Generic Process . VAR DUEDATE ) ; final int reminder Days = ( Integer ) process Variables . get ( I Individual Process . VAR REMINDER DAYS ) ; final Date reminder Date = get Reminder Date ( due Date , reminder Days ) ; final Calendar now = Calendar . get Instance ( ) ; if ( reminder Date . after ( now . get Time ( ) ) ) { throw new Abort Exception ( STR_ ) ; } }
void add Lifetime Keepalive Count ( ) { keepalive Meter . start ( ) ; lifetime Keepalive Count . increment And Get ( ) ; }
public Edge find Equal Edge ( Edge e ) { Oriented Coordinate Array oca = new Oriented Coordinate Array ( e . get Coordinates ( ) ) ; Edge match Edge = ( Edge ) oca Map . get ( oca ) ; return match Edge ; }
protected String next Token ( ) throws IO Exception , Catalog Exception { String token = STR_ ; int ch , nextch ; if ( ! token Stack . empty ( ) ) { return ( String ) token Stack . pop ( ) ; } while ( true ) { ch = catfile . read ( ) ; while ( ch <= STR_ ) { ch = catfile . read ( ) ; if ( ch < NUM_ ) { return null ; } } nextch = catfile . read ( ) ; if ( nextch < NUM_ ) { return null ; } if ( ch == STR_ && nextch == STR_ ) { ch = STR_ ; nextch = next Char ( ) ; while ( ( ch != STR_ || nextch != STR_ ) && nextch > NUM_ ) { ch = nextch ; nextch = next Char ( ) ; } if ( nextch < NUM_ ) { throw new Catalog Exception ( Catalog Exception . UNENDED COMMENT , STR_ ) ; } } else { stack [ ++ top ] = nextch ; stack [ ++ top ] = ch ; break ; } } ch = next Char ( ) ; if ( ch == STR_ || ch == STR_ ) { int quote = ch ; while ( ( ch = next Char ( ) ) != quote ) { char [ ] chararr = new char [ NUM_ ] ; chararr [ NUM_ ] = ( char ) ch ; String s = new String ( chararr ) ; token = token . concat ( s ) ; } return token ; } else { while ( ch > STR_ ) { nextch = next Char ( ) ; if ( ch == STR_ && nextch == STR_ ) { stack [ ++ top ] = ch ; stack [ ++ top ] = nextch ; return token ; } else { char [ ] chararr = new char [ NUM_ ] ; chararr [ NUM_ ] = ( char ) ch ; String s = new String ( chararr ) ; token = token . concat ( s ) ; ch = nextch ; } } return token ; } }
public int heat Sinks ( ) { return heat Sinks ( true ) ; }
public boolean supports Pcm ( ) { return supported Encodings . contains ( Audio Format . ENCODING PCM 16 BIT ) ; }
@ Override public Object clone ( ) throws Clone Not Supported Exception { Key To Group Map result = ( Key To Group Map ) super . clone ( ) ; result . default Group = ( Comparable ) Key To Group Map . clone ( this . default Group ) ; result . groups = ( List ) Key To Group Map . clone ( this . groups ) ; result . key To Group Map = ( Map ) Key To Group Map . clone ( this . key To Group Map ) ; return result ; }
public Key max ( ) { if ( is Empty ( ) ) throw new No Such Element Exception ( STR_ ) ; return set . last ( ) ; }
public Attribute Info copy ( Const Pool new Cp , Map classnames ) { Copier copier = new Copier ( info , const Pool , new Cp , classnames ) ; try { copier . parameters ( ) ; return new Parameter Annotations Attribute ( new Cp , get Name ( ) , copier . close ( ) ) ; } catch ( Exception e ) { throw new Runtime Exception ( e . to String ( ) ) ; } }
@ Suppress Warnings ( STR_ ) public static < C extends Result > Array List < C > filter Results ( Result Hierarchy hier , Class < ? super C > restriction Class ) { Array List < C > res = new Array List < > ( ) ; for ( Hierarchy . Iter < Result > iter = hier . iter All ( ) ; iter . valid ( ) ; iter . advance ( ) ) { Result result = iter . get ( ) ; if ( restriction Class . is Instance ( result ) ) { res . add ( ( C ) restriction Class . cast ( result ) ) ; } } return res ; }
private String tree To String ( ) { String Buffer text = new String Buffer ( ) ; if ( m top Of Tree == null ) { return STR_ ; } text . append ( STR_ + ( ( m use Unpruned ) ? STR_ : STR_ ) + ( ( m regression Tree ) ? STR_ : STR_ ) + STR_ ) ; if ( m smooth Predictions == true ) { text . append ( STR_ ) ; } text . append ( m top Of Tree . tree To String ( NUM_ ) ) ; text . append ( m top Of Tree . print Leaf Models ( ) ) ; text . append ( STR_ + m top Of Tree . number Of Linear Models ( ) ) ; return text . to String ( ) ; }
public boolean is Protected ( ) { return Modifier . is Protected ( method . get Modifiers ( ) ) ; }
public static boolean is Letter ( char c ) { return Character . is Letter ( c ) ; }
public Optional Long max By Long ( Long Unary Operator key Extractor ) { long [ ] result = collect ( null , null , null ) ; return result [ NUM_ ] == NUM_ ? Optional Long . of ( result [ NUM_ ] ) : Optional Long . empty ( ) ; }
public boolean has All Cols ( ) { return all Columns ; }
public static boolean is Mime Type Image ( String mime Type ) { if ( mime Type . equals ( Const . Content Types . IMAGE GIF ) ) { return true ; } else if ( mime Type . equals ( Const . Content Types . IMAGE JPG ) ) { return true ; } else if ( mime Type . equals ( Const . Content Types . IMAGE PNG ) ) { return true ; } return false ; }
public boolean is Domain Crosshair Visible ( ) { return this . domain Crosshair Visible ; }
public Key engine Get Key ( String alias , char [ ] password ) throws No Such Algorithm Exception , Unrecoverable Key Exception { Key key = null ; Object entry = entries . get ( alias . to Lower Case ( Locale . ENGLISH ) ) ; if ( ! ( ( entry instanceof Private Key Entry ) || ( entry instanceof Secret Key Entry ) ) ) { return null ; } Key Protector key Protector = new Key Protector ( password ) ; if ( entry instanceof Private Key Entry ) { byte [ ] encr Bytes = ( ( Private Key Entry ) entry ) . protected Key ; Encrypted Private Key Info encr Info ; try { encr Info = new Encrypted Private Key Info ( encr Bytes ) ; } catch ( IO Exception ioe ) { throw new Unrecoverable Key Exception ( STR_ + STR_ + STR_ ) ; } key = key Protector . recover ( encr Info ) ; } else { key = key Protector . unseal ( ( ( Secret Key Entry ) entry ) . sealed Key ) ; } return key ; }
protected void do Average Line ( byte [ ] cur Line , byte [ ] prev Line ) { int sub = ( int ) Math . ceil ( ( get Bits Per Component ( ) * get Colors ( ) ) / NUM_ ) ; for ( int i = NUM_ ; i < cur Line . length ; i ++ ) { int raw = NUM_ ; int prior = NUM_ ; int prev Idx = i - sub ; if ( prev Idx >= NUM_ ) { raw = cur Line [ prev Idx ] & NUM_ ; } if ( prev Line != null ) { prior = prev Line [ i ] & NUM_ ; } cur Line [ i ] += ( byte ) Math . floor ( ( raw + prior ) / NUM_ ) ; } }
final Dialog Option show Yes No Cancel Message ( String message , Int Setting def Value ) { Dialog Option ret = Dialog Option . parse Int ( def Value . get Value ( ) ) ; if ( ret == Dialog Option . YES || ret == Dialog Option . NO ) return ret ; int option ; try { option = J Option Pane . show Confirm Dialog ( get Parent Component ( ) , always Use This Answer Label ( message , def Value ) , I 18 n . tr ( STR_ ) , J Option Pane . YES NO CANCEL OPTION ) ; } catch ( Array Index Out Of Bounds Exception aioobe ) { option = J Option Pane . CANCEL OPTION ; } catch ( Internal Error ie ) { option = J Option Pane . CANCEL OPTION ; } if ( option == J Option Pane . YES OPTION ) ret = Dialog Option . YES ; else if ( option == J Option Pane . NO OPTION ) ret = Dialog Option . NO ; else ret = Dialog Option . CANCEL ; if ( def Value . get Value ( ) == REMEMBER ANSWER && ret != Dialog Option . CANCEL ) def Value . set Value ( ret . to Int ( ) ) ; else def Value . set Value ( FORGET ANSWER ) ; return ret ; }
public static boolean has Token File ( File token File , String content ) throws IO Exception { return has Token ( token File . get Parent File ( ) , token File . get Name ( ) , content ) ; }
public boolean is Final ( ) { return Modifier . is Final ( method . get Modifiers ( ) ) ; }
@ Deprecated public boolean has Option ( String option ) { return has Squidb Option ( option ) ; }
public void query ( Collection < ? super Bounded Object > results , int px , int py ) { query ( results , px , py , root ) ; }
public DTM Axis Iterator clone Iterator ( ) { is Restartable = false ; try { final Preceding Iterator clone = ( Preceding Iterator ) super . clone ( ) ; final int [ ] stack Copy = new int [ stack . length ] ; System . arraycopy ( stack , NUM_ , stack Copy , NUM_ , stack . length ) ; clone . stack = stack Copy ; return clone ; } catch ( Clone Not Supported Exception e ) { throw new DTM Exception ( XML Messages . create XML Message ( XML Error Resources . ER ITERATOR CLONE NOT SUPPORTED , null ) ) ; } }
public static Task < Void > sleep ( final long time , final Time Unit time Unit ) { final Task < Void > t = new Task < > ( ) ; final Scheduled Future < ? > rr = scheduler Executor . schedule ( null , time , time Unit ) ; return t ; }
public static double dchisq Log ( double x ) { if ( x == NUM_ ) return Double . POSITIVE INFINITY ; double xh = Math . sqrt ( x ) ; return dnorm Log ( xh ) - Math . log ( xh ) ; }
public void wait For Active Locks ( ) throws Interrupted Exception { long now = - NUM_ ; while ( true ) { boolean nochange ; Set < Weak Lock Reference > before ; synchronized ( active Locks ) { if ( active Locks . is Empty ( ) ) return ; before = new Hash Set < Weak Lock Reference > ( active Locks ) ; if ( now < NUM_ ) { now = System . current Time Millis ( ) ; } active Locks . wait ( wait To Collect ) ; if ( active Locks . is Empty ( ) ) return ; nochange = before . equals ( active Locks ) ; } if ( nochange && System . current Time Millis ( ) - now >= wait To Collect / NUM_ ) { release Abandoned ( ) ; now = - NUM_ ; } } }
private boolean can Force Perform ( String permission Name ) { List < Permission Rule > access = access ( permission Name ) ; List < Permission Rule > overridden = relevant . get Overridden ( permission Name ) ; Set < Project Ref > allows = new Hash Set < > ( ) ; Set < Project Ref > blocks = new Hash Set < > ( ) ; for ( Permission Rule rule : access ) { if ( rule . is Block ( ) ) { blocks . add ( relevant . get Rule Props ( rule ) ) ; } else if ( rule . get Force ( ) ) { allows . add ( relevant . get Rule Props ( rule ) ) ; } } for ( Permission Rule rule : overridden ) { if ( rule . get Force ( ) ) { blocks . remove ( relevant . get Rule Props ( rule ) ) ; } } blocks . remove All ( allows ) ; return blocks . is Empty ( ) && ! allows . is Empty ( ) ; }
static double compute Final Sum ( double [ ] summands ) { double tmp = summands [ NUM_ ] + summands [ NUM_ ] ; double simple Sum = summands [ summands . length - NUM_ ] ; if ( Double . is Na N ( tmp ) && Double . is Infinite ( simple Sum ) ) return simple Sum ; else return tmp ; }
public final Array List < String > select Unique Steam Apps ( final Array List < String > given ) { final Array List < String > to Return = new Array List < > ( ) ; to Return . add All ( given ) ; String sql = STR_ ; for ( int i = NUM_ ; i < given . size ( ) ; i ++ ) { sql += STR_ ; sql += ( i + NUM_ == given . size ( ) ) ? STR_ : STR_ ; } if ( ! sql . ends With ( STR_ ) ) sql += STR_ ; try ( Prepared Statement statement = connection . prepare Statement ( sql ) ) { for ( int i = NUM_ ; i < given . size ( ) ; i ++ ) statement . set String ( i + NUM_ , given . get ( i ) ) ; final Result Set set = statement . execute Query ( ) ; while ( set . next ( ) ) to Return . remove ( set . get String ( STR_ ) ) ; set . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return to Return ; }
default Interface Declaration as Interface ( ) { throw new Unsupported Operation Exception ( String . format ( STR_ , this ) ) ; }
public static byte parse Byte ( java . lang . String s ) throws java . lang . Number Format Exception { return parse Byte ( s , NUM_ ) ; }
public byte [ ] unwrap ( byte [ ] incoming , int start , int len ) throws Sasl Exception { if ( len == NUM_ ) { return EMPTY BYTE ARRAY ; } byte [ ] mac = new byte [ NUM_ ] ; byte [ ] msg = new byte [ len - NUM_ ] ; byte [ ] msg Type = new byte [ NUM_ ] ; byte [ ] seq Num = new byte [ NUM_ ] ; System . arraycopy ( incoming , start , msg , NUM_ , msg . length ) ; System . arraycopy ( incoming , start + msg . length , mac , NUM_ , NUM_ ) ; System . arraycopy ( incoming , start + msg . length + NUM_ , msg Type , NUM_ , NUM_ ) ; System . arraycopy ( incoming , start + msg . length + NUM_ , seq Num , NUM_ , NUM_ ) ; byte [ ] expected Mac = get HMAC ( peer Ki , seq Num , msg , NUM_ , msg . length ) ; if ( logger . is Loggable ( Level . FINEST ) ) { trace Output ( DI CLASS NAME , STR_ , STR_ , msg ) ; trace Output ( DI CLASS NAME , STR_ , STR_ , mac ) ; trace Output ( DI CLASS NAME , STR_ , STR_ , msg Type ) ; trace Output ( DI CLASS NAME , STR_ , STR_ , seq Num ) ; trace Output ( DI CLASS NAME , STR_ , STR_ , expected Mac ) ; } if ( ! Arrays . equals ( mac , expected Mac ) ) { logger . log ( Level . INFO , STR_ ) ; return EMPTY BYTE ARRAY ; } if ( peer Seq Num != network Byte Order To Int ( seq Num , NUM_ , NUM_ ) ) { throw new Sasl Exception ( STR_ + STR_ + network Byte Order To Int ( seq Num , NUM_ , NUM_ ) + STR_ + peer Seq Num ) ; } if ( ! Arrays . equals ( message Type , msg Type ) ) { throw new Sasl Exception ( STR_ + network Byte Order To Int ( msg Type , NUM_ , NUM_ ) ) ; } peer Seq Num ++ ; return msg ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descending Iterator ( ) ; }
private static boolean is Null ( Smt Expr left , Smt Expr right , List < Smt Expr > others ) { if ( left == null || right == null ) { return true ; } for ( Smt Expr smt Expr : others ) { if ( smt Expr == null ) { return true ; } } return false ; }
private static final boolean has Notification ( final Model M Bean Info info , final String notif Name ) { try { if ( info == null ) return false ; else return ( info . get Notification ( notif Name ) != null ) ; } catch ( M Bean Exception x ) { return false ; } catch ( Runtime Operations Exception r ) { return false ; } }
public static String explode ( Collection < String > collection , String delimiter ) { String Builder sb = new String Builder ( ) ; if ( ! collection . is Empty ( ) ) { Iterator < String > i = collection . iterator ( ) ; sb . append ( i . next ( ) ) ; while ( i . has Next ( ) ) { sb . append ( delimiter ) ; sb . append ( i . next ( ) ) ; } } return sb . to String ( ) ; }
public static float cu Cabs ( cu Complex x ) { float p = cu Creal ( x ) ; float q = cu Cimag ( x ) ; float r ; if ( p == NUM_ ) return q ; if ( q == NUM_ ) return p ; p = ( float ) Math . sqrt ( p ) ; q = ( float ) Math . sqrt ( q ) ; if ( p < q ) { r = p ; p = q ; q = r ; } r = q / p ; return p * ( float ) Math . sqrt ( NUM_ + r * r ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private int evict To Recover Bytes ( int bytes To Recover ) { int entries To Evict = NUM_ ; if ( bytes To Recover > NUM_ ) { for ( int j = dynamic Table . length - NUM_ ; j >= next Header Index && bytes To Recover > NUM_ ; j -- ) { bytes To Recover -= dynamic Table [ j ] . hpack Size ; dynamic Table Byte Count -= dynamic Table [ j ] . hpack Size ; header Count -- ; entries To Evict ++ ; } System . arraycopy ( dynamic Table , next Header Index + NUM_ , dynamic Table , next Header Index + NUM_ + entries To Evict , header Count ) ; next Header Index += entries To Evict ; } return entries To Evict ; }
public int hash Code ( ) { return value . hash Code ( ) ; }
public boolean contains ( Group Category category ) { return f Content . contains ( category ) ; }
int size ( ) { return Integer . bit Count ( set ) ; }
public boolean is Watched ( Wallet wallet ) { try { Script script = get Script Pub Key ( ) ; return wallet . is Watched Script ( script ) ; } catch ( Script Exception e ) { log . debug ( STR_ , e . to String ( ) ) ; return false ; } }
private static String remove Last Newline ( String str ) { int strlen = str . length ( ) ; if ( strlen == NUM_ ) { return str ; } int last Newline = str . last Index Of ( STR_ ) ; if ( strlen == last Newline + NUM_ ) { return str . substring ( NUM_ , strlen - NUM_ ) ; } else { return str ; } }
protected Map < Cell , Long > detect Write Already Committed Internal ( Table Reference table Ref , Map < Cell , Long > keys To Load , @ Output Set < Cell Conflict > spanning Writes , @ Output Set < Cell Conflict > dominating Writes , Transaction Service transaction Service ) { Map < Cell , Long > raw Results = key Value Service . get Latest Timestamps ( table Ref , keys To Load ) ; Map < Long , Long > commit Timestamps = get Commit Timestamps ( table Ref , raw Results . values ( ) , false ) ; Map < Cell , Long > keys To Delete = Maps . new Hash Map With Expected Size ( NUM_ ) ; for ( Map . Entry < Cell , Long > e : raw Results . entry Set ( ) ) { Cell key = e . get Key ( ) ; long their Start Timestamp = e . get Value ( ) ; Assert Utils . assert And Log ( their Start Timestamp != get Start Timestamp ( ) , STR_ , get Start Timestamp ( ) ) ; Long their Commit Timestamp = commit Timestamps . get ( their Start Timestamp ) ; if ( their Commit Timestamp == null || their Commit Timestamp == Transaction Constants . FAILED COMMIT TS ) { keys To Delete . put ( key , their Start Timestamp ) ; continue ; } Assert Utils . assert And Log ( their Commit Timestamp != get Start Timestamp ( ) , STR_ , get Start Timestamp ( ) ) ; if ( their Start Timestamp > get Start Timestamp ( ) ) { dominating Writes . add ( Cells . create Conflict With Metadata ( key Value Service , table Ref , key , their Start Timestamp , their Commit Timestamp ) ) ; } else if ( their Commit Timestamp > get Start Timestamp ( ) ) { spanning Writes . add ( Cells . create Conflict With Metadata ( key Value Service , table Ref , key , their Start Timestamp , their Commit Timestamp ) ) ; } } if ( ! keys To Delete . is Empty ( ) ) { if ( ! rollback Failed Transactions ( table Ref , keys To Delete , commit Timestamps , transaction Service ) ) { return keys To Load ; } } return keys To Delete ; }
public String kernel Tip Text ( ) { return STR_ ; }
public static void assert Equals ( Buffered Image image 1 , Buffered Image image 2 ) { assert Equals ( STR_ , image 1 , image 2 ) ; }
public static byte [ ] hash ( byte [ ] body ) { if ( HASH DIGEST != null ) { return HASH DIGEST . digest ( body ) ; } else { throw new Evernote Util Exception ( EDAM HASH ALGORITHM + STR_ , new No Such Algorithm Exception ( EDAM HASH ALGORITHM ) ) ; } }
public final int count Categories ( ) { return m Categories != null ? m Categories . size ( ) : NUM_ ; }
private Dimension layout Size ( Container target , boolean preferred ) { synchronized ( target . get Tree Lock ( ) ) { int target Width = target . get Size ( ) . width ; Container container = target ; while ( container . get Size ( ) . width == NUM_ && container . get Parent ( ) != null ) { container = container . get Parent ( ) ; } target Width = container . get Size ( ) . width ; if ( target Width == NUM_ ) { target Width = Integer . MAX VALUE ; } int hgap = get Hgap ( ) ; int vgap = get Vgap ( ) ; Insets insets = target . get Insets ( ) ; int horizontal Insets And Gap = insets . left + insets . right + ( hgap * NUM_ ) ; int max Width = target Width - horizontal Insets And Gap ; Dimension dim = new Dimension ( NUM_ , NUM_ ) ; int row Width = NUM_ ; int row Height = NUM_ ; int nmembers = target . get Component Count ( ) ; for ( int i = NUM_ ; i < nmembers ; i ++ ) { Component m = target . get Component ( i ) ; if ( m . is Visible ( ) ) { Dimension d = preferred ? m . get Preferred Size ( ) : m . get Minimum Size ( ) ; if ( row Width + d . width > max Width ) { add Row ( dim , row Width , row Height ) ; row Width = NUM_ ; row Height = NUM_ ; } if ( row Width != NUM_ ) { row Width += hgap ; } row Width += d . width ; row Height = Math . max ( row Height , d . height ) ; } } add Row ( dim , row Width , row Height ) ; dim . width += horizontal Insets And Gap ; dim . height += insets . top + insets . bottom + vgap * NUM_ ; Container scroll Pane = Swing Utilities . get Ancestor Of Class ( J Scroll Pane . class , target ) ; if ( scroll Pane != null && target . is Valid ( ) ) { dim . width -= ( hgap + NUM_ ) ; } return dim ; } }
public long min Rate ( ) { Long min = null ; for ( Sample s : samples ) { if ( min == null ) { min = new Long ( s . rate ( ) ) ; } min = Math . min ( min , s . rate ( ) ) ; } return min . long Value ( ) ; }
public static boolean is Zero ( final Big Decimal amount ) { return amount . compare To ( Big Decimal . ZERO ) == NUM_ ? true : false ; }
public static String format ( Object obj ) { if ( obj instanceof Number ) { return format ( ( Number ) obj ) ; } else { return obj . to String ( ) ; } }
private Set < Pin Swappable > calculate swap pin infos ( ) { Tree Set < Pin Swappable > result = new Tree Set < Pin Swappable > ( ) ; if ( target set == null ) return result ; for ( Brd Item curr item : target set ) { if ( ! ( curr item instanceof Brd Abit Pin ) ) continue ; Brd Abit Pin a pin = ( Brd Abit Pin ) curr item ; Collection < Brd Abit Pin > curr swapppable pins = a pin . get swappable pins ( ) ; for ( Brd Abit Pin curr swappable pin : curr swapppable pins ) { result . add ( new Pin Swappable ( r board , curr swappable pin ) ) ; } } Item Selection Filter selection filter = new Item Selection Filter ( Item Selection Choice . PINS ) ; Collection < Brd Item > picked items = r board . pick items ( prev corner , layer active no , selection filter ) ; for ( Brd Item curr item : picked items ) { if ( ! ( curr item instanceof Brd Abit Pin ) ) continue ; Brd Abit Pin a pin = ( Brd Abit Pin ) curr item ; Collection < Brd Abit Pin > curr swapppable pins = a pin . get swappable pins ( ) ; for ( Brd Abit Pin curr swappable pin : curr swapppable pins ) { result . add ( new Pin Swappable ( r board , curr swappable pin ) ) ; } } return result ; }
@ Override public Iterator < I Module > iterator ( ) { return sub Modules . iterator ( ) ; }
public String lookup Prefix ( String uri ) { String found Prefix = null ; Enumeration prefixes = m namespaces . keys ( ) ; while ( prefixes . has More Elements ( ) ) { String prefix = ( String ) prefixes . next Element ( ) ; String uri 2 = lookup Namespace ( prefix ) ; if ( uri 2 != null && uri 2 . equals ( uri ) ) { found Prefix = prefix ; break ; } } return found Prefix ; }
public boolean is Modified ( ) { return is Digest Modified ; }
public Element copy Attrs Only ( ) { int alen = attr Length ( ) ; Element attrs = new Element ( alen ) ; Object [ ] attr Parts = attrs . parts ; assert ( attr Parts . length == NEED SLOP + alen ) ; System . arraycopy ( parts , parts . length - alen , attr Parts , NEED SLOP , alen ) ; return attrs ; }
private List < Entity > list Network ( int conn ID , Entity e , boolean planned ) { List < Entity > nova Network Members = new Linked List < Entity > ( ) ; List < Entity > nova Units = get My Nova Units ( conn ID ) ; for ( Entity ent : nova Units ) { if ( planned ) { if ( ent . get New Round Nova Network String ( ) == e . get New Round Nova Network String ( ) ) { nova Network Members . add ( ent ) ; } } else { if ( ent . get C 3 Net Id ( ) == e . get C 3 Net Id ( ) ) { nova Network Members . add ( ent ) ; } } } return nova Network Members ; }
public Ogg Page Header read Ogg Page Header ( Random Access File raf , int count ) throws Cannot Read Exception , IO Exception { Ogg Page Header page Header = Ogg Page Header . read ( raf ) ; while ( count > NUM_ ) { raf . seek ( raf . get File Pointer ( ) + page Header . get Page Length ( ) ) ; page Header = Ogg Page Header . read ( raf ) ; count -- ; } return page Header ; }
private static boolean same ( String [ ] s 1 , String [ ] s 2 ) { if ( s 1 == null ) { return s 2 == null ; } else if ( s 2 == null || s 1 . length != s 2 . length ) { return false ; } outer : for ( int i = s 2 . length ; i > NUM_ ; ) { String onm = s 2 [ -- i ] ; String ocls = s 2 [ -- i ] ; for ( int j = s 1 . length ; j > NUM_ ; ) { String nm = s 1 [ -- j ] ; String cls = s 1 [ -- j ] ; if ( cls . equals ( ocls ) && ( nm == null ? onm == null : nm . equals ( onm ) ) ) { continue outer ; } } return false ; } return true ; }
public synchronized boolean contains ( File file ) { return value . contains ( file ) ; }
@ Override public Void call ( ) throws Exception { try { Node Holder node Holder = process Data Rows ( data Rows ) ; int index In Node Holder Array = ( sequence Number - NUM_ ) % number Of Cores ; blocklet Data Holder . put ( node Holder , index In Node Holder Array ) ; return null ; } catch ( Throwable throwable ) { consumer Executor Service . shutdown Now ( ) ; reset Blocklet Processing Count ( ) ; throw new Carbon Data Writer Exception ( throwable . get Message ( ) ) ; } }
public boolean has Assignment ( Assignment a ) { return matrix . contains Key ( a ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public static String quoted String ( String str ) { if ( str == null ) { return null ; } String Builder sb = new String Builder ( ) ; sb . append ( STR_ ) ; for ( int i = NUM_ ; i < str . length ( ) ; i ++ ) { char ch = str . char At ( i ) ; if ( ( ch == STR_ ) || ( ch == STR_ ) ) { if ( ( i > NUM_ ) && ( str . char At ( i - NUM_ ) != STR_ ) ) { sb . append ( STR_ ) ; } else if ( i == NUM_ ) { sb . append ( STR_ ) ; } } sb . append ( ch ) ; } sb . append ( STR_ ) ; return sb . to String ( ) ; }
public boolean is Empty ( ) { synchronized ( contents ) { return ( contents . is Empty ( ) ) ; } }
public static String to Points ( Point 2 D . Double [ ] points ) throws IO Exception { String Builder buf = new String Builder ( ) ; for ( int i = NUM_ ; i < points . length ; i ++ ) { if ( i != NUM_ ) { buf . append ( STR_ ) ; } buf . append ( to Number ( points [ i ] . x ) ) ; buf . append ( STR_ ) ; buf . append ( to Number ( points [ i ] . y ) ) ; } return buf . to String ( ) ; }
public final String read Next Line ( ) throws IO Exception { String str = null ; if ( buf end - buf pos <= NUM_ ) { if ( fill Buffer ( ) < NUM_ ) { return null ; } } int lineend = - NUM_ ; for ( int i = buf pos ; i < buf end ; i ++ ) { if ( buffer [ i ] == STR_ ) { lineend = i ; break ; } } if ( lineend < NUM_ ) { final Byte Array Output Stream input = new Byte Array Output Stream ( NUM_ ) ; input . write ( buffer , buf pos , buf end - buf pos ) ; buf pos = buf end ; int c ; while ( ( c = read ( ) ) != - NUM_ && c != STR_ ) { input . write ( ( char ) c ) ; } if ( c == - NUM_ && input . size ( ) == NUM_ ) { return null ; } final byte [ ] bytes Input = input . to Byte Array ( ) ; if ( c == STR_ && bytes Input . length > NUM_ && bytes Input [ bytes Input . length - NUM_ ] == STR_ ) { return new String ( bytes Input , NUM_ , bytes Input . length - NUM_ , charset ) ; } else { return new String ( bytes Input , charset ) ; } } if ( lineend > NUM_ && buffer [ lineend - NUM_ ] == STR_ ) { str = new String ( buffer , buf pos , lineend - buf pos - NUM_ , charset ) ; } else { str = new String ( buffer , buf pos , lineend - buf pos , charset ) ; } buf pos = lineend + NUM_ ; return str ; }
public static String [ ] [ ] read ( final Input Stream is , final String delim ) throws IO Exception { String [ ] [ ] result = null ; List < String [ ] > list = new Array List < String [ ] > ( ) ; String input Line ; Buffered Reader reader = new Buffered Reader ( new Input Stream Reader ( is , STR_ ) ) ; while ( ( input Line = reader . read Line ( ) ) != null ) { try { String [ ] item ; if ( delim == null ) { item = parse Line ( input Line , DELIM CHAR ) ; } else { item = parse Line ( input Line , delim ) ; } if ( item != null ) { list . add ( item ) ; } } catch ( Exception e ) { } } reader . close ( ) ; if ( list . size ( ) > NUM_ ) { result = new String [ list . size ( ) ] [ ] ; list . to Array ( result ) ; } return result ; }
private boolean check Zoning Required ( String token , URI varray URI ) { if ( ! is Zoning Required ( varray URI ) ) { Workflow Step Completer . step Succeded ( token ) ; return false ; } else { Workflow Step Completer . step Executing ( token ) ; return true ; } }
public Workflow . Method zone Null Rollback Method ( ) { return new Workflow . Method ( STR_ ) ; }
private String build Table Name ( Database Meta Data dbmd , String catalog , String schema , String table ) throws SQL Exception { String cmd = STR_ ; catalog = catalog . trim ( ) ; schema = schema . trim ( ) ; table = table . trim ( ) ; if ( dbmd . is Catalog At Start ( ) == true ) { if ( catalog != null && catalog . length ( ) > NUM_ ) { cmd += catalog + dbmd . get Catalog Separator ( ) ; } if ( schema != null && schema . length ( ) > NUM_ ) { cmd += schema + STR_ ; } cmd += table ; } else { if ( schema != null && schema . length ( ) > NUM_ ) { cmd += schema + STR_ ; } cmd += table ; if ( catalog != null && catalog . length ( ) > NUM_ ) { cmd += dbmd . get Catalog Separator ( ) + catalog ; } } cmd += STR_ ; return cmd ; }
@ Override public Object Iterator iterator ( ) { return new Struct Iterator ( field Values Iterator ( ) ) ; }
public String primary Occupation Name ( ) { String primary Occupation = null ; if ( professional Experience != null && professional Experience . primary Company ( ) != null ) { Company company = professional Experience . primary Company ( ) ; primary Occupation = company . title ( ) ; } if ( primary Occupation == null || primary Occupation . is Empty ( ) ) { if ( education Background != null && education Background . primary School ( ) != null ) { School primary School = education Background . primary School ( ) ; primary Occupation = primary School . degree ( ) ; } } return primary Occupation ; }
public Iterator < Counter > iterate Group ( String grp Name ) { Collection < Counter > grp Counters = new Array List < > ( ) ; for ( Hadoop Long Counter counter : cntrs . values ( ) ) { if ( grp Name . equals ( counter . group ( ) ) ) grp Counters . add ( new Hadoop V 2 Counter ( counter ) ) ; } return grp Counters . iterator ( ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static boolean assert Cumulative ( final double [ ] da ) { final double tolerance = NUM_ ; Exam . assert True ( Utils . real Format Array ( da ) , da . length > NUM_ ) ; double prev = Double . NEGATIVE INFINITY ; for ( final double d : da ) { Exam . assert True ( Utils . real Format ( d ) , d >= NUM_ && d <= ( NUM_ + tolerance ) && ! Double . is Na N ( d ) ) ; Exam . assert True ( prev <= d ) ; prev = d ; } if ( check Equals ( NUM_ , prev , tolerance ) ) { return true ; } throw new Exam . Exam Exception ( Utils . real Format Array ( da ) ) ; }
@ Override public boolean is Cell Editable ( int row Index , int column Index ) { return ( column Index > NUM_ ) && ! is Read Only ( ) ; }
public int size ( ) { return nodes . size ( ) ; }
private boolean throws Exception ( Method method , Class < ? > exception ) { Class exs [ ] = method . get Exception Types ( ) ; for ( int i = NUM_ ; i < exs . length ; i ++ ) { if ( exs [ i ] == exception ) { return true ; } } return false ; }
public List < Shopping Cart Item > items ( ) { List < Shopping Cart Item > result = Fast List . new Instance ( ) ; result . add All ( cart Lines ) ; return result ; }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( true ) ; Log . d ( TAG , STR_ + data ) ; } else { return false ; } } return true ; }
protected double switched Log 10 ( double val ) { return this . small Log Flag ? Math . log ( val ) / LOG 10 VALUE : adjusted Log 10 ( val ) ; }
public int size ( ) { return selectors . size ( ) ; }
public static boolean is Binary Attribute ( String attribute Name ) { return attribute Name != null && attribute Name . ends With ( BINARY FLAG ) ; }
public boolean is Container Class ( String clz ) { return droid Safe Container Classes . contains ( clz ) ; }
@ Suppress Warnings ( { STR_ , STR_ } ) public static boolean is Regex ( final char c ) { return is Regex ( Character . to String ( c ) ) ; }
public Segment segment ( long index ) { assert Open ( ) ; if ( current Segment != null && current Segment . valid Index ( index ) ) return current Segment ; Map . Entry < Long , Segment > segment = segments . floor Entry ( index ) ; return segment != null ? segment . get Value ( ) : null ; }
default Class < ? > find Database Type ( ) { final String name = get Database Type ( ) ; try { return Class . for Name ( name ) ; } catch ( final Class Not Found Exception ex ) { throw new Speedment Config Exception ( STR_ + name + STR_ , ex ) ; } }
public static void true Value ( final boolean value , final String name ) { if ( ! value ) { final String message = String . format ( STR_ , name ) ; throw new Illegal Argument Exception ( message ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static List < Locale > available Locales ( ) { return Locale Holder . available Locale List ; }
public int size ( ) { return usage Table . size ( ) ; }
public static Number sign ( Number a ) { if ( is Floating Point ( a ) ) { return Math . signum ( a . double Value ( ) ) ; } else { return Long . signum ( a . long Value ( ) ) ; } }
public int hash Code ( ) { return NUM_ ; }
public static String byte Arr To Hex Bytes ( byte [ ] arr , String comment ) { Memory mem = new Native Memory ( arr ) ; return mem To Hex Bytes ( mem , comment ) ; }
public static final Geo Time Serie sub Cycle Serie ( Geo Time Serie gts , long lastbucket , int buckets per period , boolean overwrite , Geo Time Serie subgts ) throws Warp Script Exception { if ( ! is Bucketized ( gts ) ) { throw new Warp Script Exception ( STR_ ) ; } if ( NUM_ != ( gts . lastbucket - lastbucket ) % gts . bucketspan ) { throw new Warp Script Exception ( STR_ ) ; } if ( null == subgts ) { subgts = new Geo Time Serie ( lastbucket , ( gts . bucketcount - ( int ) ( ( gts . lastbucket - lastbucket ) / gts . bucketspan ) - NUM_ ) / buckets per period + NUM_ , gts . bucketspan * buckets per period , ( int ) Math . max ( NUM_ * gts . bucketcount , gts . sizehint ) / buckets per period ) ; } else { subgts . values = NUM_ ; subgts . type = TYPE . UNDEFINED ; subgts . lastbucket = lastbucket ; subgts . bucketcount = ( gts . bucketcount - ( int ) ( ( gts . lastbucket - lastbucket ) / gts . bucketspan ) - NUM_ ) / buckets per period + NUM_ ; subgts . bucketspan = gts . bucketspan * buckets per period ; } if ( null == gts . ticks || NUM_ == gts . values ) { return subgts ; } Iterator < Long > iter = tick Iterator ( subgts , true ) ; long tick ; sort ( gts ) ; int i = gts . values ; while ( iter . has Next ( ) ) { tick = iter . next ( ) ; i = Arrays . binary Search ( gts . ticks , NUM_ , i , tick ) ; if ( i >= NUM_ ) { set Value ( subgts , gts . ticks [ i ] , null != gts . locations ? gts . locations [ i ] : Geo Time Serie . NO LOCATION , null != gts . elevations ? gts . elevations [ i ] : Geo Time Serie . NO ELEVATION , value At Index ( gts , i ) , overwrite ) ; } } return subgts ; }
public Stack < Point 2 D > hull ( ) { Stack < Point 2 D > s = new Stack < Point 2 D > ( ) ; for ( Point 2 D p : hull ) s . push ( p ) ; return s ; }
public static Map < String , Mapped Class > mappings From SRG ( File file , Map < String , Class Node > nodes ) { Map < String , Mapped Class > base = mappings From Nodes ( nodes ) ; Mapping Loader loader = new SRG Loader ( nodes ) ; try { Map < String , Mapped Class > new Mappings = loader . read ( new File Reader ( file ) ) ; for ( Mapped Class mapped Class : new Mappings . values ( ) ) { new Mappings = link Mappings ( mapped Class , new Mappings ) ; } base = fix From Mappings Text ( base , new Mappings ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } return base ; }
public static List < Library Location > gather All Libraries ( String [ ] dir Paths ) { List < Library Location > libraries = new Array List < Library Location > ( ) ; for ( int i = NUM_ ; i < dir Paths . length ; i ++ ) { File ext Dir = new File ( dir Paths [ i ] ) ; if ( ext Dir . is Directory ( ) ) { String [ ] names = ext Dir . list ( fg Archive Filter ) ; if ( names != null ) { for ( int j = NUM_ ; j < names . length ; j ++ ) { File jar = new File ( ext Dir , names [ j ] ) ; if ( jar . is File ( ) ) { try { I Path lib Path = new Path ( jar . get Canonical Path ( ) ) ; I Path source Path = Path . EMPTY ; I Path package Root = Path . EMPTY ; URL javadoc Location = null ; URL index Location = null ; Library Location library = new Library Location ( lib Path , source Path , package Root , javadoc Location , index Location ) ; libraries . add ( library ) ; } catch ( IO Exception e ) { Launching . log ( e ) ; } } } } } } return libraries ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public boolean valid System Name Format ( String system Name ) { return ( get Bit From System Name ( system Name ) != NUM_ ) ; }
public final static boolean is Java Like File Name ( String name ) { if ( name == null ) return false ; return index Of Java Like Extension ( name ) != - NUM_ ; }
private int remaining Data ( ) { return buffer . remaining ( ) ; }
public static final int type Index ( Class type ) { Class [ ] list = primitive Types ; int n = list . length ; for ( int i = NUM_ ; i < n ; i ++ ) if ( list [ i ] == type ) return i ; throw new Runtime Exception ( STR_ + type . get Name ( ) ) ; }
private void send Error ( String status , String msg ) { try { if ( status == null ) throw new Error ( STR_ ) ; final Output Stream out = my Socket . get Output Stream ( ) ; Print Writer pw = new Print Writer ( out ) ; pw . print ( STR_ + status + STR_ ) ; pw . print ( STR_ ) ; pw . print ( STR_ + gmt Frmt . format ( new Date ( ) ) + STR_ ) ; pw . print ( STR_ ) ; pw . flush ( ) ; out . flush ( ) ; out . close ( ) ; my Socket . close ( ) ; } catch ( IO Exception ioe ) { try { my Socket . close ( ) ; } catch ( Throwable t ) { } } }
public boolean is Reserved ( ) { String prefix = get Prefix ( ) ; String name = get Name ( ) ; if ( prefix != null ) { return prefix . starts With ( RESERVED ) ; } return name . starts With ( RESERVED ) ; }
public final boolean is Registered ( ) { return ! canonical Name . starts With ( STR_ ) && ! canonical Name . starts With ( STR_ ) ; }
public boolean is Reflected Edge ( Stmt Edge < Soot Method > e ) { return reflected Edges . contains ( e ) ; }
private Object lookup ( String key , Class type ) throws SAX Exception { Object value ; if ( handler != null ) { if ( handler . has Variable ( key ) ) { return check Cast ( handler . get Variable ( key ) , type ) ; } } value = mapping . get ( key ) ; if ( value == null ) { throw new SAX Exception ( STR_ + key + STR_ ) ; } return check Cast ( value , type ) ; }
private boolean split wtrace other point ( Collection < Brd Tracep > p clean list , Pla Point Int p intersect , Brd Tracep other trace , int other line no , Pla Segment Int p my segment ) { if ( r board . debug ( Mdbg . TRACE SPLIT , Ldbg . DEBUG ) ) r board . user Println ( STR_ + ( other trace == this ) ) ; if ( other trace == this ) return false ; if ( ! p my segment . contains ( p intersect , NUM_ ) ) return false ; if ( r board . debug ( Mdbg . TRACE SPLIT , Ldbg . DEBUG ) ) r board . user Println ( STR_ + p intersect ) ; Array List < Brd Tracep > split traces = other trace . split with end point ( other line no , p intersect ) ; if ( split traces . size ( ) < NUM_ ) { r board . user Println ( STR_ ) ; p clean list . add ( other trace ) ; return false ; } p clean list . add All ( split traces ) ; return true ; }
@ Truffle Boundary public int push Back Length ( ) { return push Back == null ? NUM_ : push Back . size ( ) ; }
public Future < Recovery Info > apply Buffered Updates ( ) { version Info . block Updates ( ) ; try { cancel Apply Buffer Update = false ; if ( state != State . BUFFERING ) return null ; operation Flags &= ~ FLAG GAP ; if ( tlog == null ) { state = State . ACTIVE ; return null ; } tlog . incref ( ) ; state = State . APPLYING BUFFERED ; } finally { version Info . unblock Updates ( ) ; } if ( recovery Executor . is Shutdown ( ) ) { tlog . decref ( ) ; throw new Runtime Exception ( STR_ ) ; } Executor Completion Service < Recovery Info > cs = new Executor Completion Service < > ( recovery Executor ) ; Log Replayer replayer = new Log Replayer ( Arrays . as List ( new Transaction Log [ ] { tlog } ) , true ) ; return cs . submit ( replayer , recovery Info ) ; }
public boolean is Expired ( final Date now ) { return ( cookie Expiry Date != null && cookie Expiry Date . get Time ( ) <= now . get Time ( ) ) ; }
public int version Major Number ( ) { return Integer . value Of ( properties . get Property ( STR_ ) ) ; }
public static final boolean is Oracle JCE Provider ( String provider Name ) { return provider Name != null && ( provider Name . equals ( STR_ ) || provider Name . equals ( STR_ ) || provider Name . equals ( STR_ ) || provider Name . starts With ( STR_ ) ) ; }
@ Nullable public Block Entry find By Id ( String id ) { return id Map . get ( id ) ; }
protected Ct Member . Cache has Member Cache ( ) { if ( member Cache != null ) return ( Ct Member . Cache ) member Cache . get ( ) ; else return null ; }
public static String Builder whitespace ( String Builder buf , int n ) { while ( n >= WHITESPACE BUFFER LENGTH ) { buf . append ( WHITESPACE BUFFER ) ; n -= WHITESPACE BUFFER LENGTH ; } return n > NUM_ ? buf . append ( WHITESPACE BUFFER , NUM_ , n ) : buf ; }
public boolean has Pending ( ) { return ! queue . is Empty ( ) ; }
public static Integer parse Int ( String s ) { return ( s == null ) ? ( Integer ) null : Integer . parse Int ( s ) ; }
public static Timestamp to Timestamp ( String string ) { if ( string == null ) return null ; else try { return Timestamp . value Of ( string ) ; } catch ( Throwable t ) { return null ; } }
public static double gamma ( double x ) { double P [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; double Q [ ] = { - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; double p , z ; int i ; double q = Math . abs ( x ) ; if ( q > NUM_ ) { if ( x < NUM_ ) { p = Math . floor ( q ) ; if ( p == q ) throw new Arithmetic Exception ( STR_ ) ; i = ( int ) p ; z = q - p ; if ( z > NUM_ ) { p += NUM_ ; z = q - p ; } z = q * Math . sin ( Math . PI * z ) ; if ( z == NUM_ ) throw new Arithmetic Exception ( STR_ ) ; z = Math . abs ( z ) ; z = Math . PI / ( z * stirling Formula ( q ) ) ; return - z ; } else { return stirling Formula ( x ) ; } } z = NUM_ ; while ( x >= NUM_ ) { x -= NUM_ ; z *= x ; } while ( x < NUM_ ) { if ( x == NUM_ ) { throw new Arithmetic Exception ( STR_ ) ; } else if ( x > - NUM_ ) { return ( z / ( ( NUM_ + NUM_ * x ) * x ) ) ; } z /= x ; x += NUM_ ; } while ( x < NUM_ ) { if ( x == NUM_ ) { throw new Arithmetic Exception ( STR_ ) ; } else if ( x < NUM_ ) { return ( z / ( ( NUM_ + NUM_ * x ) * x ) ) ; } z /= x ; x += NUM_ ; } if ( ( x == NUM_ ) || ( x == NUM_ ) ) return z ; x -= NUM_ ; p = polevl ( x , P , NUM_ ) ; q = polevl ( x , Q , NUM_ ) ; return z * p / q ; }
static private long fac 1 ( int j ) { long i = j ; if ( j < NUM_ ) i = Math . abs ( j ) ; if ( i > long Factorials . length ) throw new Illegal Argument Exception ( STR_ ) ; long d = NUM_ ; while ( i > NUM_ ) d *= i -- ; if ( j < NUM_ ) return - d ; else return d ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public boolean is Locked ( ) throws IO Exception { try ( File Lock fl = file To Lock . try Lock ( ) ) { return fl != null ; } catch ( Overlapping File Lock Exception e ) { return true ; } }
public int index ( int position ) { return m indices . get ( position ) ; }
public static double cu Cabs ( cu Double Complex x ) { double p = cu Creal ( x ) ; double q = cu Cimag ( x ) ; double r ; if ( p == NUM_ ) return q ; if ( q == NUM_ ) return p ; p = Math . sqrt ( p ) ; q = Math . sqrt ( q ) ; if ( p < q ) { r = p ; p = q ; q = r ; } r = q / p ; return p * Math . sqrt ( NUM_ + r * r ) ; }
private String end Of Query ( boolean only Table Name ) { String table ; int begin Index , end Index ; begin Index = m query . index Of ( STR_ ) + NUM_ ; while ( m query . char At ( begin Index ) == STR_ ) { begin Index ++ ; } end Index = m query . index Of ( STR_ , begin Index ) ; if ( end Index != - NUM_ && only Table Name ) { table = m query . substring ( begin Index , end Index ) ; } else { table = m query . substring ( begin Index ) ; } if ( m Data Base Connection . get Upper Case ( ) ) { table = table . to Upper Case ( ) ; } return table ; }
private boolean is Canonical Equals ( Client Proxy Membership ID that ) { if ( this == that ) { return true ; } if ( this . unique Id != that . unique Id ) { return false ; } return Arrays . equals ( this . identity , that . identity ) ; }
public boolean is Valid ( ) { return ( min . x < max . x && min . y < max . y && min . z < max . z ) ; }
public static Color disable ( Color color ) { int alpha = color . get Alpha ( ) ; alpha /= NUM_ ; return new Color ( ( color . get RGB ( ) & NUM_ ) | ( alpha << NUM_ ) , true ) ; }
public static Dns Url [ ] from List ( String url List ) throws Malformed URL Exception { Dns Url [ ] urls = new Dns Url [ ( url List . length ( ) + NUM_ ) / NUM_ ] ; int i = NUM_ ; String Tokenizer st = new String Tokenizer ( url List , STR_ ) ; while ( st . has More Tokens ( ) ) { urls [ i ++ ] = new Dns Url ( st . next Token ( ) ) ; } Dns Url [ ] trimmed = new Dns Url [ i ] ; System . arraycopy ( urls , NUM_ , trimmed , NUM_ , i ) ; return trimmed ; }
private static IO Exception bad Host Name ( String hostname ) { return new IO Exception ( String . format ( BAD HOST , hostname ) ) ; }
public static boolean is Present ( ) { return m Present ; }
private int height Hint ( String text , int max Width , int max Height ) { Point font Point = gc . text Extent ( text ) ; int rows = ( font Point . x / ( max Width - NUM_ ) ) + NUM_ ; return Math . min ( rows * font Point . y , max Height ) ; }
@ Override public Object value For Search ( Object value ) { Long val = value ( value ) ; if ( val == null ) { return null ; } return long To Ip ( val ) ; }
static public final int random ( int range ) { return random . next Int ( range + NUM_ ) ; }
@ Override @ Suppress Warnings ( STR_ ) public Object [ ] to Array ( ) { final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { Object [ ] a = new Object [ count ] ; int k = NUM_ ; for ( Node < E > p = first ; p != null ; p = p . next ) a [ k ++ ] = p . item ; return a ; } finally { lock . unlock ( ) ; } }
protected boolean is Valid Format ( ) { boolean result ; result = false ; try { new Simple Date Format ( m Format Text . get Text ( ) ) ; result = true ; } catch ( Exception e ) { } return result ; }
@ Override public int hash Code ( ) { return is Present ? Integer . hash Code ( value ) : NUM_ ; }
public static Rectangle from Polygon ( Polygon [ ] polygons ) { double min Lat = Double . POSITIVE INFINITY ; double max Lat = Double . NEGATIVE INFINITY ; double min Lon = Double . POSITIVE INFINITY ; double max Lon = Double . NEGATIVE INFINITY ; for ( int i = NUM_ ; i < polygons . length ; i ++ ) { min Lat = Math . min ( polygons [ i ] . min Lat , min Lat ) ; max Lat = Math . max ( polygons [ i ] . max Lat , max Lat ) ; min Lon = Math . min ( polygons [ i ] . min Lon , min Lon ) ; max Lon = Math . max ( polygons [ i ] . max Lon , max Lon ) ; } return new Rectangle ( min Lat , max Lat , min Lon , max Lon ) ; }
private void invalid Byte ( int position , int count , int c ) throws UTF Data Format Exception { throw new UTF Data Format Exception ( Localizer . get Message ( STR_ , Integer . to String ( position ) , Integer . to String ( count ) ) ) ; }
private boolean is Label Type Exists In Storage ( Abstract Storage Label Type < ? > label Type , Set < Abstract Storage Label < ? > > labels In Storages ) { for ( Abstract Storage Label < ? > label : labels In Storages ) { if ( Object Utils . equals ( label . get Storage Label Type ( ) , label Type ) ) { return true ; } } return false ; }
public List < Named Bean > discover Pair Dest ( Named Bean source , Layout Editor editor , Class < ? > T , int path Method ) throws Jmri Exception { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + source . get Display Name ( ) ) ; } Layout Block Manager lbm = Instance Manager . get Default ( Layout Block Manager . class ) ; Layout Block l Facing = lbm . get Facing Block By Named Bean ( source , editor ) ; List < Layout Block > l Protecting = lbm . get Protecting Blocks By Named Bean ( source , editor ) ; Array List < Named Bean > ret = new Array List < Named Bean > ( ) ; Array List < Facing Protecting > bean List = generate Blocks With Beans ( editor , T ) ; try { for ( Layout Block lb : l Protecting ) { ret . add All ( discover Pair Dest ( source , lb , l Facing , bean List , path Method ) ) ; } } catch ( Jmri Exception e ) { throw e ; } return ret ; }
public boolean is Show Mixed Views ( ) { return m mixed Views Checkbox . is Selected ( ) ; }
public boolean is Final ( ) { return Modifier . is Final ( field . get Modifiers ( ) ) ; }
public Char Seq to Lower Case ( ) { return new Char Seq ( str . to Lower Case ( ) ) ; }
public Object [ ] to Array ( ) { Object [ ] a ; final Reentrant Lock lock = this . lock ; lock . lock ( ) ; try { final int count = this . count ; a = new Object [ count ] ; int n = items . length - take Index ; if ( count <= n ) System . arraycopy ( items , take Index , a , NUM_ , count ) ; else { System . arraycopy ( items , take Index , a , NUM_ , n ) ; System . arraycopy ( items , NUM_ , a , n , count - n ) ; } } finally { lock . unlock ( ) ; } return a ; }
protected boolean contains URL ( URL url ) { if ( urls != null ) { for ( URL test URL : urls ) { if ( url . equals ( test URL ) ) return true ; } } Class Loader parent = get Parent ( ) ; if ( parent instanceof Dynamic Class Loader ) { Dynamic Class Loader dyn Parent = ( Dynamic Class Loader ) parent ; if ( dyn Parent . contains URL ( url ) ) { return true ; } } for ( Dynamic Class Loader loader Import : import Loaders ) { if ( loader Import . contains URL ( url ) ) { return true ; } } return false ; }
public Shape Tile Octagon bounding octagon ( int p from corner no , int p to corner no ) { int from corner no = Math . max ( p from corner no , NUM_ ) ; int to corner no = Math . min ( p to corner no , plaline len ( - NUM_ ) ) ; double lx = Integer . MAX VALUE ; double ly = Integer . MAX VALUE ; double rx = Integer . MIN VALUE ; double uy = Integer . MIN VALUE ; double ulx = Integer . MAX VALUE ; double lrx = Integer . MIN VALUE ; double llx = Integer . MAX VALUE ; double urx = Integer . MIN VALUE ; for ( int index = from corner no ; index <= to corner no ; ++ index ) { Pla Point Float curr = corner approx ( index ) ; lx = Math . min ( lx , curr . v x ) ; ly = Math . min ( ly , curr . v y ) ; rx = Math . max ( rx , curr . v x ) ; uy = Math . max ( uy , curr . v y ) ; double tmp = curr . v x - curr . v y ; ulx = Math . min ( ulx , tmp ) ; lrx = Math . max ( lrx , tmp ) ; tmp = curr . v x + curr . v y ; llx = Math . min ( llx , tmp ) ; urx = Math . max ( urx , tmp ) ; } Shape Tile Octagon surrounding octagon = new Shape Tile Octagon ( Math . floor ( lx ) , Math . floor ( ly ) , Math . ceil ( rx ) , Math . ceil ( uy ) , Math . floor ( ulx ) , Math . ceil ( lrx ) , Math . floor ( llx ) , Math . ceil ( urx ) ) ; return surrounding octagon ; }
public boolean has Changes Since Initialization ( ) { return ( last Update Since Initialization != null ) ; }
public static boolean is For Name ( @ Nonnull String value ) { if ( value . equals ( STR_ ) ) return false ; for ( int i = NUM_ , len = value . length ( ) ; i < len ; i ++ ) { char c = value . char At ( i ) ; if ( c != STR_ && ! Character . is Java Identifier Part ( c ) ) return false ; } return true ; }
public static Class < ? > wrapper For ( Type primitive Type ) { return require Non Null ( WRAPPERS . get ( primitive Type . get Type Name ( ) ) , STR_ + primitive Type . get Type Name ( ) + STR_ ) ; }
public long time Since Start ( ) { long current Time = System . current Time Millis ( ) ; return current Time - start Time ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector ; if ( m Stats == null ) { new Vector = new Vector < String > ( NUM_ ) ; } else { new Vector = new Vector < String > ( ) ; Enumeration < String > en = m Stats . enumerate Measures ( ) ; new Vector . add All ( Collections . list ( en ) ) ; } return new Vector . elements ( ) ; }
public Pla Segment Float diagonal corner segment ( ) { if ( is empty ( ) ) return null ; Pla Point Float first corner = corner approx ( NUM_ ) ; Pla Point Float last corner = corner approx ( border line count ( ) / NUM_ ) ; return new Pla Segment Float ( first corner , last corner ) ; }
protected double [ ] empty Predictions ( int num Predictions ) { double [ ] predictions = new double [ num Predictions ] ; Arrays . fill ( predictions , Double . Na N ) ; return predictions ; }
public Set entry Set ( ) { return entries ( false ) ; }
public String consume Raw Attribute ( String name ) { if ( ! elem . has Attribute ( name ) ) { return null ; } String value = elem . get Attribute ( name ) ; elem . remove Attribute ( name ) ; return value . trim ( ) ; }
public String longest Match ( String input ) { Trie Node node = root ; String result = null ; for ( int i = input . length ( ) - NUM_ ; i >= NUM_ ; i -- ) { node = node . get Child ( input . char At ( i ) ) ; if ( node == null ) break ; if ( node . is Terminal ( ) ) result = input . substring ( i ) ; } return result ; }
default Node < T > truncate ( long from , long to , Int Function < T [ ] > generator ) { if ( from == NUM_ && to == count ( ) ) return this ; Spliterator < T > spliterator = spliterator ( ) ; long size = to - from ; Node . Builder < T > node Builder = Nodes . builder ( size , generator ) ; node Builder . begin ( size ) ; for ( int i = NUM_ ; i < from && spliterator . try Advance ( null ) ; i ++ ) { } for ( int i = NUM_ ; ( i < size ) && spliterator . try Advance ( node Builder ) ; i ++ ) { } node Builder . end ( ) ; return node Builder . build ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public Token next Token ( ) { int start Position = get Current Position In Input ( ) ; if ( look Ahead ( NUM_ ) == STR_ ) { consume ( ) ; return new Token ( Logic Token Types . LPAREN , STR_ , start Position ) ; } else if ( look Ahead ( NUM_ ) == STR_ ) { consume ( ) ; return new Token ( Logic Token Types . LSQRBRACKET , STR_ , start Position ) ; } else if ( look Ahead ( NUM_ ) == STR_ ) { consume ( ) ; return new Token ( Logic Token Types . RPAREN , STR_ , start Position ) ; } else if ( look Ahead ( NUM_ ) == STR_ ) { consume ( ) ; return new Token ( Logic Token Types . RSQRBRACKET , STR_ , start Position ) ; } else if ( Character . is Whitespace ( look Ahead ( NUM_ ) ) ) { consume ( ) ; return next Token ( ) ; } else if ( connective Detected ( look Ahead ( NUM_ ) ) ) { return connective ( ) ; } else if ( symbol Detected ( look Ahead ( NUM_ ) ) ) { return symbol ( ) ; } else if ( look Ahead ( NUM_ ) == ( char ) - NUM_ ) { return new Token ( Logic Token Types . EOI , STR_ , start Position ) ; } else { throw new Lexer Exception ( STR_ + look Ahead ( NUM_ ) + STR_ + get Current Position In Input ( ) , get Current Position In Input ( ) ) ; } }
@ Override public int hash Code ( ) { return Float . float To Int Bits ( get Boost ( ) ) ^ slop ^ term Arrays Hash Code ( ) ^ positions . hash Code ( ) ^ NUM_ ; }
public boolean is Time To Renew ( ) { return creation Time + ( lifetime * NUM_ ) / NUM_ < System . current Time Millis ( ) ; }
private static boolean is RP Or Vplex Protected ( Un Managed Volume un Managed Volume ) { return is Vplex Backend Volume ( un Managed Volume ) || check Un Managed Resource Is Recover Point Enabled ( un Managed Volume ) ; }
public static boolean addresses Are Equal ( String host 1 , String host 2 ) { try { Host Address host 1 Address = get By Name ( host 1 ) ; Host Address host 2 Address = get By Name ( host 2 ) ; byte [ ] host 1 Raw = host 1 Address . get Address ( ) ; byte [ ] host 2 Raw = host 2 Address . get Address ( ) ; for ( int octet = NUM_ ; octet < NUM_ ; octet ++ ) { if ( host 1 Raw [ octet ] != host 2 Raw [ octet ] ) return false ; } return true ; } catch ( Exception e ) { CL Utils . println ( String . format ( STR_ , host 1 , host 2 , e ) ) ; return false ; } }
public static Object from Address ( long address ) { Object [ ] array = new Object [ ] { null } ; long base Offset = unsafe . array Base Offset ( Object [ ] . class ) ; unsafe . put Long ( array , base Offset , address ) ; return array [ NUM_ ] ; }
private static URL file To URL ( File file ) throws Malformed URL Exception { String name ; try { name = file . get Canonical Path ( ) ; } catch ( IO Exception e ) { name = file . get Absolute Path ( ) ; } name = name . replace ( File . separator Char , STR_ ) ; if ( ! name . starts With ( STR_ ) ) { name = STR_ + name ; } if ( ! file . is File ( ) ) { name = name + STR_ ; } return new URL ( STR_ , STR_ , name ) ; }
public int num Alpha Levels ( ) { return impl . num Alpha Levels ( ) ; }
public Collection < Location > ordered Locations ( ) { Tree Set < Location > tree = new Tree Set < Location > ( ) ; for ( Iterator < Location > locs = location Iterator ( ) ; locs . has Next ( ) ; ) { Location loc = locs . next ( ) ; tree . add ( loc ) ; } return tree ; }
protected boolean is Known Type ( String type ) { if ( type . equals ( LINESTRING ) ) { return true ; } else if ( type . equals ( MULTILINESTRING ) ) { return true ; } else if ( type . equals ( POINT ) ) { return true ; } else { return false ; } }
private boolean has No Values ( ) { return values . is Empty ( ) ; }
public boolean is Directory ( String path ) { try { Zip Entry entry = get Zip Entry ( path ) ; return entry != null && entry . is Directory ( ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } return false ; }
protected static Action Result Info perform Action ( Generic Value product Promo Action , Shopping Cart cart , Delegator delegator , Local Dispatcher dispatcher , Timestamp now Timestamp ) throws Generic Entity Exception , Cart Item Modify Exception { Action Result Info action Result Info = new Action Result Info ( ) ; perform Action ( action Result Info , product Promo Action , cart , delegator , dispatcher , now Timestamp ) ; return action Result Info ; }
private static String node Name ( Class < ? > c ) { if ( c . is Array ( ) ) throw new Illegal Argument Exception ( STR_ ) ; String class Name = c . get Name ( ) ; int pkg End Index = class Name . last Index Of ( STR_ ) ; if ( pkg End Index < NUM_ ) return STR_ ; String package Name = class Name . substring ( NUM_ , pkg End Index ) ; return STR_ + package Name . replace ( STR_ , STR_ ) ; }
public boolean is Granted ( T tx ) { if ( tx == null ) { throw new Null Pointer Exception ( ) ; } return queue . peek ( ) == tx ; }
@ Override public String graph ( ) throws Exception { if ( m Tree == null ) { throw new Exception ( STR_ ) ; } String Buffer result Buff = new String Buffer ( ) ; m Tree . to Graph ( result Buff , NUM_ , null ) ; String result = STR_ + STR_ + result Buff . to String ( ) + STR_ ; return result ; }
@ Override public Inet Socket Address ip Local ( ) { if ( ip Local == null ) { try { ip Local = Inet Socket Address . create Unresolved ( get Local Host ( ) , port Local ( ) ) ; } catch ( Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } } return ip Local ; }
@ Layoutlib Delegate static float cos ( float angle ) { return ( float ) Math . cos ( angle ) ; }
protected String next Type ( ) throws IO Exception { String type = null ; while ( ! done && type == null ) { type = read Word ( reader ) ; if ( type . length ( ) < NUM_ ) { type = null ; continue ; } } return type ; }
public Response create Corresponding Error Response ( char request Type , char error Code , String reason Phrase , char ... unknown Attributes ) { if ( request Type == Message . BINDING REQUEST ) { if ( unknown Attributes != null ) { return Message Factory . create Binding Error Response ( error Code , reason Phrase , unknown Attributes ) ; } else { return Message Factory . create Binding Error Response ( error Code , reason Phrase ) ; } } else { return null ; } }
public Sasl Server create Sasl Server ( String mech , String protocol , String server Name , Map < String , ? > props , Callback Handler cbh ) throws Sasl Exception { if ( mech . equals ( my Mechs [ DIGEST MD 5 ] ) && Policy Utils . check Policy ( mech Policies [ DIGEST MD 5 ] , props ) ) { if ( cbh == null ) { throw new Sasl Exception ( STR_ + STR_ + STR_ ) ; } return new Digest MD 5 Server ( protocol , server Name , props , cbh ) ; } return null ; }
public static String from Byte Array ( byte [ ] ba ) { if ( ( ba != null ) && ( ba . length == NUM_ ) ) { String Builder result = new String Builder ( NUM_ ) ; for ( int i = NUM_ ; i < NUM_ ; ++ i ) { if ( ( i == NUM_ ) || ( i == NUM_ ) || ( i == NUM_ ) || ( i == NUM_ ) ) { result . append ( STR_ ) ; } result . append ( hex Chars . char At ( ( ( ba [ i ] & NUM_ ) > > > NUM_ ) ) ) ; result . append ( hex Chars . char At ( ( ba [ i ] & NUM_ ) ) ) ; } return result . to String ( ) ; } return null ; }
public static double log 2 ( final double x ) { return Math . log ( x ) / NUM_ ; }
@ Override public boolean equals ( Object obj ) { if ( this == obj ) { return true ; } if ( obj == null ) { return false ; } if ( get Class ( ) != obj . get Class ( ) ) { return false ; } Dummy Credentials other = ( Dummy Credentials ) obj ; if ( password == null ) { if ( other . password != null ) { return false ; } } else if ( ! password . equals ( other . password ) ) { return false ; } if ( token == null ) { if ( other . token != null ) { return false ; } } else if ( ! token . equals ( other . token ) ) { return false ; } if ( username == null ) { if ( other . username != null ) { return false ; } } else if ( ! username . equals ( other . username ) ) { return false ; } return true ; }
public final int count Actions ( ) { return m Actions . size ( ) ; }
public String name ( ) { return the Name ; }
private boolean token Starts With Prefix ( String token , String ... prefixes ) { String [ ] token Parts = token . split ( STR_ , NUM_ ) ; if ( token Parts . length == NUM_ ) { for ( String prefix : prefixes ) { if ( prefix . equals ( token Parts [ NUM_ ] ) ) { return true ; } } } return false ; }
public synchronized void leave ( ) throws Exception { leave ( - NUM_ , null ) ; }
public static Double translate Size ( Long size , String to ) { if ( size == null || size . long Value ( ) == NUM_ ) { return NUM_ ; } long multiplier = NUM_ ; if ( to . ends With ( SIZE TB ) ) { multiplier = NUM_ * NUM_ * NUM_ * NUM_ ; } else if ( to . ends With ( SIZE GB ) ) { multiplier = NUM_ * NUM_ * NUM_ ; } else if ( to . ends With ( SIZE MB ) ) { multiplier = NUM_ * NUM_ ; } else if ( to . ends With ( SIZE KB ) ) { multiplier = NUM_ ; } return ( double ) size / ( double ) multiplier ; }
final public byte [ ] to Byte Array ( ) { final byte [ ] tmp = new byte [ this . pos ] ; System . arraycopy ( buf , NUM_ , tmp , NUM_ , this . pos ) ; return tmp ; }
public Variable Value find Var ( String name ) { for ( int i = NUM_ ; i < get Row Count ( ) ; i ++ ) { if ( name . equals ( get Item ( i ) ) ) { return get Variable ( i ) ; } if ( name . equals ( get Label ( i ) ) ) { return get Variable ( i ) ; } } return null ; }
public Repository Meta Data repository ( String name ) { for ( Repository Meta Data repository : repositories ) { if ( name . equals ( repository . name ( ) ) ) { return repository ; } } return null ; }
protected final int internal Get ( int field ) { return fields [ field ] ; }
public double seconds Since Start ( ) { return ( time Since Start ( ) ) / NUM_ ; }
public String next ( ) { String uri = uri List . get ( index ++ ) ; if ( index >= uri List . size ( ) ) { index = NUM_ ; iterations ++ ; } return uri ; }
Completion Stage < Person > person Async ( Person p ) { return completed Future ( person Direct ( p ) ) ; }
public synchronized boolean is Locked ( ) { return ( lock != null && ! lock . is Shared ( ) ) ; }
public Repl DBMS Event peek ( ) { return queue . peek ( ) ; }
public Set < String > key Set ( ) { Hash Set < String > set = new Hash Set < String > ( ) ; set . add All ( container . key Set ( ) ) ; set . add All ( cache . key Set ( ) ) ; return set ; }
public static boolean is Cosmetic Rule ( String rule Text ) { return String Utils . is Empty ( rule Text ) || rule Text . contains ( MASK CSS RULE ) || rule Text . contains ( MASK CSS EXCEPTION RULE ) || rule Text . contains ( MASK CSS INJECT RULE ) || rule Text . contains ( MASK CSS INJECT EXCEPTION RULE ) || rule Text . contains ( MASK SCRIPT RULE ) || rule Text . contains ( MASK CONTENT RULE ) ; }
public boolean can Redo ( ) { return m n Current Edit Action < m undo Stack . size ( ) - NUM_ ; }
public static Number atan ( Number a ) { return Math . atan ( a . double Value ( ) ) ; }
public String next String ( char quote ) throws JSON Exception { char c ; String Buffer sb = new String Buffer ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case NUM_ : case STR_ : case STR_ : throw syntax Error ( STR_ ) ; case STR_ : c = next ( ) ; switch ( c ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( ( char ) Integer . parse Int ( next ( NUM_ ) , NUM_ ) ) ; break ; case STR_ : case STR_ : case STR_ : case STR_ : sb . append ( c ) ; break ; default : throw syntax Error ( STR_ ) ; } break ; default : if ( c == quote ) { return sb . to String ( ) ; } sb . append ( c ) ; } } }
private static double [ ] convert Confidence To Probability ( double y [ ] , double confidences [ ] ) { double p [ ] = new double [ confidences . length ] ; for ( int j = NUM_ ; j < confidences . length ; j ++ ) { p [ j ] = confidences [ j ] * y [ j ] + ( NUM_ - confidences [ j ] ) * Math . abs ( y [ j ] - NUM_ ) ; } return p ; }
public static List < URI > return Vplex Srdf Targets ( Db Client db Client , List < URI > vplex Volume UR Is ) { List < URI > returned Volumes = new Array List < URI > ( ) ; for ( URI vplex URI : vplex Volume UR Is ) { Volume vplex Volume = db Client . query Object ( Volume . class , vplex URI ) ; if ( vplex Volume == null ) { continue ; } Volume srdf Volume = get Srdf Volume From Vplex Volume ( db Client , vplex Volume ) ; if ( srdf Volume != null && ! Null Column Value Getter . is Null Named URI ( srdf Volume . get Srdf Parent ( ) ) ) { returned Volumes . add ( vplex Volume . get Id ( ) ) ; } } return returned Volumes ; }
private String to Ref Sect 2 ( String script Name , Sub Command sub Command ) { Map < String , Object > map = new Hash Map < > ( ) ; map . put ( STR_ , script Name + STR_ + sub Command . get Name ( ) ) ; final String name = script Name + STR_ + sub Command . get Name ( ) ; map . put ( STR_ , name ) ; map . put ( STR_ , eol To New Para ( sub Command . get Description ( ) ) ) ; map . put ( STR_ , REF TITLE OPTIONS . get ( ) ) ; map . put ( STR_ , REF INTRO OPTIONS . get ( name ) ) ; map . put ( STR_ , sub Command . get Doc Description Supplement ( ) ) ; set Sub Command Options Info ( map , sub Command ) ; String Builder sb = new String Builder ( ) ; apply Template ( sb , STR_ , map ) ; return sb . to String ( ) ; }
private boolean close Internal ( Error Code error Code ) { assert ( ! Thread . holds Lock ( this ) ) ; synchronized ( this ) { if ( this . error Code != null ) { return false ; } if ( source . finished && sink . finished ) { return false ; } this . error Code = error Code ; notify All ( ) ; } connection . remove Stream ( id ) ; return true ; }
public float distance To Center ( float x , float y ) { Point F c = get Center Offsets ( ) ; float dist ; float x Dist ; float y Dist ; if ( x > c . x ) { x Dist = x - c . x ; } else { x Dist = c . x - x ; } if ( y > c . y ) { y Dist = y - c . y ; } else { y Dist = c . y - y ; } dist = ( float ) Math . sqrt ( Math . pow ( x Dist , NUM_ ) + Math . pow ( y Dist , NUM_ ) ) ; return dist ; }
public String move Forward ( ) { Check . is True ( current Index < history . size ( ) - NUM_ , STR_ ) ; current Index ++ ; return history . get ( current Index ) ; }
@ Transient public boolean is Valid Debuggee ( ) { Sync Result result = check Sync Stash State ( ) ; return result . is Valid Debuggee ( ) ; }
public boolean is Inside ( Contour contour ) { return left ( ) >= contour . left ( ) && right ( ) <= contour . right ( ) && top ( ) >= contour . top ( ) && bottom ( ) <= contour . bottom ( ) ; }
private static void check Resource Class Declaration ( Class < ? extends Resource > resource ) { int modifiers = resource . get Modifiers ( ) ; if ( resource . is Local Class ( ) || ( resource . is Member Class ( ) && ! Modifier . is Static ( modifiers ) ) ) { throw new Illegal Argument Exception ( STR_ ) ; } }
public static boolean is Image ( File path , boolean jpg Only ) { if ( path == null ) return false ; return is Image ( path . get Name ( ) , jpg Only ) ; }
public static Number round ( Number a ) { if ( is Floating Point ( a ) ) { return Math . round ( a . double Value ( ) ) ; } else { return a . long Value ( ) ; } }
public Justification [ ] next Chunk ( ) { if ( ! has Next ( ) ) { throw new No Such Element Exception ( ) ; } if ( ft != null ) { await Reader ( ) ; } final int n = buffer . size ( ) ; final Justification [ ] stmts = new Justification [ n ] ; for ( int i = NUM_ ; i < n ; i ++ ) { stmts [ i ] = next ( ) ; } if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + n + STR_ + nchunks + STR_ + num Read By Caller + STR_ + num Buffered ) ; return stmts ; }
public boolean is Empty ( ) { return static Fields . is Empty ( ) && instance Fields . is Empty ( ) && direct Methods . is Empty ( ) && virtual Methods . is Empty ( ) ; }
@ Override public int hash Code ( ) { return Objects . hash Code ( value ) ; }
public Xml Dom tag ( String tag , String attr , String value ) { List < Xml Dom > tags = tags ( tag , attr , value ) ; if ( tags . size ( ) == NUM_ ) { return null ; } else { return tags . get ( NUM_ ) ; } }
public Bounded Object query One ( int px , int py ) { return query One ( px , py , root ) ; }
public static int sum From To ( int i Start , int i End ) { int i Res = NUM_ ; for ( int i Cnt = i Start ; i Cnt <= i End ; i Res += i Cnt ++ ) ; return i Res ; }
private String substitute Sub String ( String input , String find , String replace ) { int find length = find . length ( ) ; int replace length = replace . length ( ) ; String Builder output = new String Builder ( input ) ; int index = input . index Of ( find ) ; int output Offset = NUM_ ; while ( index > - NUM_ ) { output . replace ( index + output Offset , index + output Offset + find length , replace ) ; output Offset = output Offset + ( replace length - find length ) ; index = input . index Of ( find , index + find length ) ; } return output . to String ( ) ; }
private static int hash Code ( final I Variable < ? > [ ] join Vars , final I Binding Set bset , final boolean ignore Unbound Variables ) throws Join Variable Not Bound Exception { int h = ONE ; for ( I Variable < ? > v : join Vars ) { final I Constant < ? > c = bset . get ( v ) ; if ( c == null ) { if ( ignore Unbound Variables ) continue ; throw new Join Variable Not Bound Exception ( v . get Name ( ) ) ; } h = NUM_ * h + c . hash Code ( ) ; } if ( log . is Trace Enabled ( ) ) log . trace ( STR_ + h + STR_ + Arrays . to String ( join Vars ) + STR_ + bset ) ; return h ; }
public int hash Code ( ) { return session ID . hash Code ( ) ; }
public Collection < Alt Format > registered Formats ( ) { return Collections . unmodifiable Collection ( alt Handlers . key Set ( ) ) ; }
public static boolean is Control Or Meta Down ( Key Event e ) { if ( ! IS MAC ) { return e . is Control Down ( ) ; } else { return e . is Meta Down ( ) ; } }
private boolean would Loop ( Path dir , Object key ) { for ( Directory Node ancestor : stack ) { Object ancestor Key = ancestor . key ( ) ; if ( key != null && ancestor Key != null ) { if ( key . equals ( ancestor Key ) ) { return true ; } } else { try { if ( Files . is Same File ( dir , ancestor . directory ( ) ) ) { return true ; } } catch ( IO Exception | Security Exception x ) { } } } return false ; }
public static Charset to Charset ( final Charset charset ) { return charset == null ? Charset . default Charset ( ) : charset ; }
void build ( List < File > inputs , List < File > dependees , long youngest , Build Service build Service , Print Writer logger ) throws Build Exception { File output Time File ; if ( output . is Directory ( ) ) { output Time File = new File ( output , STR_ ) ; } else { output Time File = output ; } long output Modified = output Time File . last Modified ( ) ; boolean modified = ( output Modified == NUM_ || output Modified < youngest ) ; if ( modified ) { File output Dir = output . get Parent File ( ) ; if ( ! output Dir . exists ( ) ) { logger . println ( STR_ + output Dir ) ; output Dir . mkdirs ( ) ; } logger . println ( STR_ + inputs . size ( ) + STR_ + output ) ; Map < String , Object > options = get Options ( ) ; boolean success = false ; try { success = run ( build Service , logger , dependees , inputs , output , options ) ; if ( ! success ) { throw new Build Exception ( STR_ + output ) ; } } finally { if ( ! success ) { if ( output Time File . exists ( ) ) { output Time File . delete ( ) ; } } } } }
public boolean is Empty ( ) { return objects . is Empty ( ) ; }
public static double squared Loss ( double [ ] x , double [ ] y , double w 0 , double w 1 ) { double sum = NUM_ ; for ( int j = NUM_ ; j < x . length ; j ++ ) { sum += Math . pow ( ( y [ j ] - ( w 1 * x [ j ] + w 0 ) ) , NUM_ ) ; } return sum ; }
public String prefix ( ) throws Exception { String Buffer text ; text = new String Buffer ( ) ; if ( m is Leaf ) { text . append ( STR_ + m local Model . dump Label ( NUM_ , m train ) + STR_ ) ; } else { prefix Tree ( text ) ; } return text . to String ( ) ; }
public static String open Exchange File Name ( Chess Engine engine ) { String ret = STR_ ; if ( engine . get Package Name ( ) != null ) ret += sanitize String ( engine . get Package Name ( ) ) ; ret += STR_ ; if ( engine . get File Name ( ) != null ) ret += sanitize String ( engine . get File Name ( ) ) ; return ret ; }
public int match ( String s ) { String rep = new String ( data Chars , NUM_ , n Data Chars ) ; return rep . index Of ( s ) ; }
public boolean equals ( String password ) { if ( password == null ) { return false ; } if ( ! is Encrypted ( password ) ) { password = encrypt ( algorithm , password ) ; } if ( ! password . starts With ( algorithm + SEPERATOR ) ) { throw new Illegal Argument Exception ( STR_ ) ; } return value . equals Ignore Case ( password ) ; }
public static Data Row Reader create Data Row Reader ( Data Row Factory factory , Attribute [ ] attributes , String [ ] [ ] values ) { List < Data Row > data Rows = new Linked List < Data Row > ( ) ; for ( int i = NUM_ ; i < values . length ; i ++ ) { data Rows . add ( factory . create ( values [ i ] , attributes ) ) ; } return new List Data Row Reader ( data Rows . iterator ( ) ) ; }
@ Override public String to String No Weight ( int after Decimal Point ) { String Buffer text = new String Buffer ( ) ; for ( int i = NUM_ ; i < m Att Values . length ; i ++ ) { if ( i > NUM_ ) { text . append ( STR_ ) ; } text . append ( to String ( i , after Decimal Point ) ) ; } return text . to String ( ) ; }
public static List < String > to Label Path ( Node node ) { final Linked List < String > paths = new Linked List < String > ( ) ; Node current = node ; Node parent = first Parent ( node ) ; while ( parent != null ) { paths . add First ( current . get Label ( ) ) ; current = parent ; parent = first Parent ( current ) ; } return paths ; }
public boolean is Left To Right ( ) { return bidi Base . is Left To Right ( ) ; }
@ Override public Collection < T > visit Defined ( Defined Default Behavior Provider < T > provider , Void p ) { Sorted Set < T > values = new Tree Set < > ( ) ; for ( String string Value : provider . get Default Values ( ) ) { values . add ( property Def . decode Value ( string Value ) ) ; } return values ; }
public final double sample Sigma ( int n ) { synchronized ( lock ) { long count = total Count . get ( ) ; long last Count = last Std Total Count ; last Std Total Count = count ; double sum = sum . get ( ) ; double last Sum = last Std Sum ; last Std Sum = sum ; double sum Square = sum Square ; sum Square = NUM_ ; if ( count == last Count ) return NUM_ ; double avg = ( sum - last Sum ) / ( count - last Count ) ; double part = ( count - last Count ) * sum Square - sum * sum ; if ( part < NUM_ ) part = NUM_ ; double std = Math . sqrt ( part ) / ( count - last Count ) ; return scale * ( avg + n * std ) ; } }
public String diff ( ) throws IO Exception { try { String reference = read Reference ( ) ; return diff ( reference , m Output . to String ( ) ) ; } catch ( File Not Found Exception fnf ) { write As Reference ( ) ; return null ; } }
protected int y ( double y W ) { return ( int ) Math . round ( scale * ( y W + offset Y ) + border Top ) ; }
public static int hash ( double value ) { long bits = Double . double To Long Bits ( value ) ; return ( int ) ( bits ^ ( bits > > > NUM_ ) ) ; }
public double std Dev ( ) { double avg = avg Rate ( ) ; double sum = NUM_ ; for ( Sample s : samples ) { sum += Math . pow ( ( double ) s . rate ( ) - avg , NUM_ ) ; } double variance = sum / ( double ) samples . size ( ) ; return Math . sqrt ( variance ) ; }
private Annotation Invocation Handler as One Of Us ( Object o ) { if ( Proxy . is Proxy Class ( o . get Class ( ) ) ) { Invocation Handler handler = Proxy . get Invocation Handler ( o ) ; if ( handler instanceof Annotation Invocation Handler ) return ( Annotation Invocation Handler ) handler ; } return null ; }
private Token poll Next ( ) { Token result = current Token ; if ( matcher . find ( ) ) { if ( index < matcher . start ( ) ) { current Token = new Token ( Token Kind . TEXT , source . substring ( index , matcher . start ( ) ) , line Num ) ; index = matcher . start ( ) ; matcher . region ( index , matcher . region End ( ) ) ; } else { current Token = create Token From Matcher ( ) ; index = matcher . end ( ) ; } } else { if ( index < source . length ( ) ) { current Token = new Token ( Token Kind . TEXT , source . substring ( index ) , line Num ) ; index = source . length ( ) ; } else { current Token = null ; } } return result ; }
private static double distance ( Problem problem , Solution a , Solution b , double power ) { double distance = NUM_ ; for ( int i = NUM_ ; i < problem . get Number Of Objectives ( ) ; i ++ ) { distance += Math . pow ( Math . abs ( a . get Objective ( i ) - b . get Objective ( i ) ) , power ) ; } return Math . pow ( distance , NUM_ / power ) ; }
public Template find Template ( String name , String context Type Id ) { Assert . is Not Null ( name ) ; for ( Iterator it = f Templates . iterator ( ) ; it . has Next ( ) ; ) { Template Persistence Data data = ( Template Persistence Data ) it . next ( ) ; Template template = data . get Template ( ) ; if ( data . is Enabled ( ) && ! data . is Deleted ( ) && ( context Type Id == null || context Type Id . equals ( template . get Context Type Id ( ) ) ) && name . equals ( template . get Name ( ) ) ) return template ; } return null ; }
public boolean is Set Sequence Id ( ) { return isset bit vector . get ( SEQUENCEID ISSET ID ) ; }
public static Date days After Now ( int num Days ) { if ( num Days <= NUM_ ) { throw new Illegal Argument Exception ( ) ; } final Calendar cal = new Gregorian Calendar ( ) ; cal . set Time ( new Date ( ) ) ; cal . add ( Calendar . DAY OF YEAR , num Days ) ; return cal . get Time ( ) ; }
public synchronized Reference < ? extends T > remove ( long timeout Millis ) throws Interrupted Exception { if ( timeout Millis < NUM_ ) { throw new Illegal Argument Exception ( STR_ + timeout Millis ) ; } if ( head != null ) { return poll ( ) ; } if ( timeout Millis == NUM_ || ( timeout Millis > Long . MAX VALUE / NANOS PER MILLI ) ) { do { wait ( NUM_ ) ; } while ( head == null ) ; return poll ( ) ; } long nanos To Wait = timeout Millis * NANOS PER MILLI ; int timeout Nanos = NUM_ ; long start Time = System . nano Time ( ) ; while ( true ) { wait ( timeout Millis , timeout Nanos ) ; if ( head != null ) { break ; } long nanos Elapsed = System . nano Time ( ) - start Time ; long nanos Remaining = nanos To Wait - nanos Elapsed ; if ( nanos Remaining <= NUM_ ) { break ; } timeout Millis = nanos Remaining / NANOS PER MILLI ; timeout Nanos = ( int ) ( nanos Remaining - timeout Millis * NANOS PER MILLI ) ; } return poll ( ) ; }
private static String parse Phone Number For Mms ( String address ) { String Builder builder = new String Builder ( ) ; int len = address . length ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = address . char At ( i ) ; if ( c == STR_ && builder . length ( ) == NUM_ ) { builder . append ( c ) ; continue ; } if ( Character . is Digit ( c ) ) { builder . append ( c ) ; continue ; } if ( numeric Sugar Map . get ( c ) == null ) { return null ; } } return builder . to String ( ) ; }
@ Override public int hash Code ( ) { int hash = NUM_ ; hash = NUM_ * hash + ( int ) ( Double . double To Long Bits ( this . x ) ^ ( Double . double To Long Bits ( this . x ) > > > NUM_ ) ) ; hash = NUM_ * hash + ( int ) ( Double . double To Long Bits ( this . y ) ^ ( Double . double To Long Bits ( this . y ) > > > NUM_ ) ) ; hash = NUM_ * hash + ( int ) ( Double . double To Long Bits ( this . z ) ^ ( Double . double To Long Bits ( this . z ) > > > NUM_ ) ) ; return hash ; }
public boolean is Read Only ( ) { return ! ( is Data Persister ( ) || is Bulk Data Persister ( ) ) ; }
@ Override public String to Console String ( ) { return Photon . is Console Advanced ( ) ? to Colorfoul Console String ( ) : to Basic Console String ( ) ; }
public boolean exception Occurred ( ) { return this . exception Occurred ; }
static boolean is Ignored File ( File file ) { String name = file . get Name ( ) ; return name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . ends With ( STR_ ) && name . length ( ) > NUM_ ; }
private boolean should Append Charset Param ( String ... property Value List ) { if ( ! m Should Append Charset Param ) { return false ; } for ( String property Value : property Value List ) { if ( ! V Card Utils . contains Only Printable Ascii ( property Value ) ) { return true ; } } return false ; }
private static int next Partition Or Line End ( I Document document , I Text Selection line , int offset , String partitioning ) { final int doc Offset = offset + line . get Offset ( ) ; final int eol = line . get Offset ( ) + line . get Length ( ) ; int next Partition Pos = eol ; int valid Position = doc Offset ; try { I Typed Region partition = Text Utilities . get Partition ( document , partitioning , next Partition Pos , true ) ; valid Position = get Valid Position For Partition ( document , partition , eol ) ; while ( valid Position == - NUM_ ) { next Partition Pos = partition . get Offset ( ) - NUM_ ; if ( next Partition Pos < doc Offset ) { valid Position = doc Offset ; break ; } partition = Text Utilities . get Partition ( document , partitioning , next Partition Pos , false ) ; valid Position = get Valid Position For Partition ( document , partition , eol ) ; } } catch ( Bad Location Exception e ) { } valid Position = Math . max ( valid Position , doc Offset ) ; valid Position -= line . get Offset ( ) ; return valid Position ; }
public int size ( ) { return table . size ( ) ; }
public static Document load Document ( String uri ) { try { Document Builder Factory doc Builder Factory = Document Builder Factory . new Instance ( ) ; Document Builder doc Builder = doc Builder Factory . new Document Builder ( ) ; return doc Builder . parse ( uri ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } return null ; }
public static < E > List < E > of ( E e 1 ) { List < E > list = new Array List < > ( ) ; list . add ( e 1 ) ; return list ; }
private static boolean is Temp Path Secure ( ) { if ( ! was Temp Path Checked ) { synchronized ( Windows Attach Provider . class ) { if ( ! was Temp Path Checked ) { String temp = temp Path ( ) ; if ( ( temp != null ) && ( temp . length ( ) >= NUM_ ) && ( temp . char At ( NUM_ ) == STR_ ) && ( temp . char At ( NUM_ ) == STR_ ) ) { long flags = volume Flags ( temp . substring ( NUM_ , NUM_ ) ) ; is Temp Path Secure = ( ( flags & FS PERSISTENT ACLS ) != NUM_ ) ; } was Temp Path Checked = true ; } } } return is Temp Path Secure ; }
public static String quantityplnoun With Marker ( int quantity , String noun , char marker ) { final String full Noun = plnoun ( quantity , noun ) ; String prefix ; if ( quantity == NUM_ ) { prefix = a an ( full Noun ) ; } else { prefix = Integer . to String ( quantity ) + STR_ ; } final String Builder sb = new String Builder ( prefix ) ; if ( full Noun . index Of ( STR_ ) == - NUM_ ) { sb . append ( marker ) ; sb . append ( full Noun ) ; } else { sb . append ( marker ) ; sb . append ( STR_ + full Noun + STR_ ) ; } return sb . to String ( ) ; }
public void long Poll ( ) throws Interrupted Exception { final String dolphin Id = get Dolphin Id ( ) ; if ( dolphin Id == null ) { throw new Illegal State Exception ( STR_ ) ; } final Receiver receiver In Session = get Or Create Receiver In Session ( dolphin Id ) ; if ( ! receiver In Session . is Listening To Event Bus ( ) ) { receiver In Session . register ( event Bus ) ; } final Dataflow Queue receiver Queue = receiver In Session . get Receiver Queue ( ) ; boolean something Handled = false ; while ( ! something Handled ) { Object val = receiver Queue . get Val ( ) ; final long start Time = System . current Time Millis ( ) ; while ( val != null ) { if ( val == release Val ) { return ; } if ( val instanceof Message ) { final Message event = ( Message ) val ; something Handled |= receiver In Session . handle ( event ) ; } if ( System . current Time Millis ( ) - start Time <= MAX POLL DURATION ) { val = receiver Queue . get Val ( TIMEOUT , MILLISECONDS ) ; } else { val = null ; } } } }
private static void abort ( String message , Throwable exception , int code ) throws Core Exception { throw new Core Exception ( new Status ( I Status . ERROR , Type Script Core Plugin . PLUGIN ID , code , message , exception ) ) ; }
public static int floor Half ( int num ) { if ( ( num & NUM_ ) == NUM_ ) { return ( num - NUM_ ) / NUM_ ; } else { return num / NUM_ ; } }
private boolean is Field Value Default ( Object field Value ) { if ( field Value == null ) { return true ; } else { return field Value . equals ( get Java Default Value Default ( ) ) ; } }
private static List < String > generate Get Method Names ( final Field field ) { final List < String > prefix = new Linked List < String > ( ) ; prefix . add ( STR_ + Attribute Helper . get Attribute Name ( field ) ) ; if ( field . get Type ( ) == boolean . class || field . get Type ( ) == Boolean . class ) { prefix . add ( STR_ + Attribute Helper . get Attribute Name ( field ) ) ; String field Name = field . get Name ( ) ; if ( field Name . length ( ) > NUM_ && field Name . starts With ( STR_ ) && Character . is Upper Case ( field Name . char At ( NUM_ ) ) ) prefix . add ( field Name ) ; } return prefix ; }
public Shape cross ( float x , float y , float height ) { float h 14 = NUM_ * height / NUM_ , h 34 = NUM_ * height / NUM_ ; m path . reset ( ) ; m path . move To ( x + h 14 , y ) ; m path . line To ( x + h 34 , y ) ; m path . line To ( x + h 34 , y + h 14 ) ; m path . line To ( x + height , y + h 14 ) ; m path . line To ( x + height , y + h 34 ) ; m path . line To ( x + h 34 , y + h 34 ) ; m path . line To ( x + h 34 , y + height ) ; m path . line To ( x + h 14 , y + height ) ; m path . line To ( x + h 14 , y + h 34 ) ; m path . line To ( x , y + h 34 ) ; m path . line To ( x , y + h 14 ) ; m path . line To ( x + h 14 , y + h 14 ) ; m path . close Path ( ) ; return m path ; }
@ Override public Range find Range Bounds ( XY Dataset dataset ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; int series Count = dataset . get Series Count ( ) ; double lvalue ; double uvalue ; if ( dataset instanceof Vector XY Dataset ) { Vector XY Dataset vdataset = ( Vector XY Dataset ) dataset ; for ( int series = NUM_ ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM_ ; item < item Count ; item ++ ) { double delta = vdataset . get Vector Y Value ( series , item ) ; if ( delta < NUM_ ) { uvalue = vdataset . get Y Value ( series , item ) ; lvalue = uvalue + delta ; } else { lvalue = vdataset . get Y Value ( series , item ) ; uvalue = lvalue + delta ; } minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } else { for ( int series = NUM_ ; series < series Count ; series ++ ) { int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM_ ; item < item Count ; item ++ ) { lvalue = dataset . get Y Value ( series , item ) ; uvalue = lvalue ; minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } if ( minimum > maximum ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
public static void assert Diagonally Dominant ( I Double Matrix mat ) { assert Square ( mat ) ; for ( int i = NUM_ ; i < mat . get Row Num ( ) ; ++ i ) { final double d = mat . get ( i , i ) ; if ( Double . is Na N ( d ) ) { continue ; } for ( int j = NUM_ ; j < mat . get Row Num ( ) ; ++ j ) { double v ; v = mat . get ( i , j ) ; if ( ! Double . is Na N ( v ) && v > d ) { final String msg = String . format ( STR_ , i , j , v , i , i , d , d - v ) ; throw new Ade Core Illegal Argument Exception ( msg ) ; } v = mat . get ( j , i ) ; if ( ! Double . is Na N ( v ) && v > d ) { final String msg = String . format ( STR_ , j , i , v , i , i , d ) ; throw new Ade Core Illegal Argument Exception ( msg ) ; } } } }
public String stem ( String word ) { if ( word . length ( ) > NUM_ ) { return recode Ending ( remove Ending ( word . to Lower Case ( ) ) ) ; } else { return word . to Lower Case ( ) ; } }
public J Menu create Spacing Menu ( ) { J Menu space Sub Menu = new J Menu ( STR_ ) ; space Sub Menu . add ( action Manager . get Space Horizontal Action ( ) ) ; space Sub Menu . add ( action Manager . get Space Vertical Action ( ) ) ; return space Sub Menu ; }
public Image image For ( Entity entity ) { return image For ( entity , - NUM_ ) ; }
public boolean has Global Sub Schema ( ) { return ( global Sub Schema Names != null ) && ! global Sub Schema Names . is Empty ( ) ; }
SOAP Message to SOAP Message ( ) throws SOAP Binding Exception { return Utils . Document To SOAP Message ( to Document ( true ) ) ; }
public Shape triangle left ( float x , float y , float height ) { m path . reset ( ) ; m path . move To ( x + height , y ) ; m path . line To ( x + height , y + height ) ; m path . line To ( x , y + height / NUM_ ) ; m path . close Path ( ) ; return m path ; }
public boolean has Listeners ( ) { return listeners != null && listeners . size ( ) > NUM_ ; }
private static String to OSGI Compatible Version String ( String version String ) { return version String . replace First ( STR_ , STR_ ) ; }
public static boolean is Through Front Hex ( I Game game , Coords src , Entity t ) { Coords dest = t . get Position ( ) ; int fa = dest . degree ( src ) - ( t . get Facing ( ) * NUM_ ) ; if ( fa < NUM_ ) { fa += NUM_ ; } return ( fa > NUM_ ) || ( fa < NUM_ ) ; }
private int post Basic Category Index ( String category ) { boolean saw At Zero = false ; int i = NUM_ ; for ( int leng = category . length ( ) ; i < leng ; i ++ ) { char ch = category . char At ( i ) ; if ( is Label Annotation Introducing Character ( ch ) ) { if ( i == NUM_ ) { saw At Zero = true ; } else if ( saw At Zero ) { saw At Zero = false ; } else { break ; } } } return i ; }
public static long pop intersect ( long [ ] arr 1 , long [ ] arr 2 , int word Offset , int num Words ) { long pop Count = NUM_ ; for ( int i = word Offset , end = word Offset + num Words ; i < end ; ++ i ) { pop Count += Long . bit Count ( arr 1 [ i ] & arr 2 [ i ] ) ; } return pop Count ; }
public static String format Simple Decimal With Zeros ( double d ) { return simple Format Force Zero . format ( d ) ; }
public static boolean contains Any Uuid ( Parcel Uuid [ ] uuid A , Parcel Uuid [ ] uuid B ) { if ( uuid A == null && uuid B == null ) return true ; if ( uuid A == null ) { return uuid B . length == NUM_ ? true : false ; } if ( uuid B == null ) { return uuid A . length == NUM_ ? true : false ; } Hash Set < Parcel Uuid > uuid Set = new Hash Set < Parcel Uuid > ( Arrays . as List ( uuid A ) ) ; for ( Parcel Uuid uuid : uuid B ) { if ( uuid Set . contains ( uuid ) ) return true ; } return false ; }
public final boolean is Terminated ( ) { return done . get Count ( ) == NUM_ ; }
public byte [ ] take ( ) throws Keeper Exception , Interrupted Exception { Timer Context timer = stats . time ( dir + STR_ ) ; update Lock . lock Interruptibly ( ) ; try { while ( true ) { byte [ ] result = remove First ( ) ; if ( result != null ) { return result ; } changed . await ( ) ; } } finally { update Lock . unlock ( ) ; timer . stop ( ) ; } }
@ Override public int locations ( ) { return NUM_ ; }
public static boolean check For Forced Auth ( String xml Composite Advice ) { boolean return Forced Auth = false ; try { String decoded Advice XML = URL Decoder . decode ( xml Composite Advice ) ; Map advice Map = Policy Utils . parse Advices XML ( decoded Advice XML ) ; if ( util Debug . message Enabled ( ) ) { util Debug . message ( STR_ + STR_ + decoded Advice XML ) ; util Debug . message ( STR_ + advice Map ) ; } if ( advice Map != null ) { if ( advice Map . contains Key ( Auth Scheme Condition . FORCE AUTH ADVICE ) ) { return Forced Auth = true ; } } } catch ( com . sun . identity . policy . Policy Exception pol Exp ) { util Debug . error ( STR_ + STR_ , pol Exp ) ; } if ( util Debug . message Enabled ( ) ) { util Debug . message ( STR_ + STR_ + return Forced Auth ) ; } return return Forced Auth ; }
public boolean can Assign Service ( String realm Name , String id Type ) { boolean can = false ; try { AM Identity Repository repo = new AM Identity Repository ( admin SSO Token , realm Name ) ; Set allowed Operations = repo . get Allowed Id Operations ( Id Utils . get Type ( id Type ) ) ; can = allowed Operations . contains ( Id Operation . SERVICE ) ; } catch ( Id Repo Exception e ) { debug . warning ( STR_ , e ) ; } catch ( SSO Exception e ) { debug . warning ( STR_ , e ) ; } return can ; }
protected Expression Exception invalid Key ( String key ) { return new Expression Exception ( STR_ + key + STR_ ) ; }
public synchronized List < Call > queued Calls ( ) { List < Call > result = new Array List < > ( ) ; for ( Async Call async Call : ready Async Calls ) { result . add ( async Call . get ( ) ) ; } return Collections . unmodifiable List ( result ) ; }
public static String which Doctype Public ( Document doc ) { Document Type doctype ; doctype = doc . get Doctype ( ) ; if ( doctype != null ) { try { return doctype . get Public Id ( ) ; } catch ( Error except ) { } } if ( doc instanceof HTML Document ) return DTD . XHTML Public Id ; return null ; }
public final double error Estimate ( ) { calculate ( ) ; QL . require ( ! Double . is Na N ( this . error Estimate ) , STR_ ) ; return error Estimate ; }
private boolean is Positioned Correctly ( I Java Element element ) { List Item old List Item = get Old Position ( element ) ; if ( old List Item == null ) return false ; List Item new List Item = get New Position ( element ) ; if ( new List Item == null ) return false ; I Java Element old Previous = old List Item . previous ; I Java Element new Previous = new List Item . previous ; if ( old Previous == null ) { return new Previous == null ; } else { return old Previous . equals ( new Previous ) ; } }
@ Override void to XML ( String Builder xml , int level ) { indent ( xml , level ) ; xml . append ( STR_ ) ; xml . append ( NS Object . NEWLINE ) ; for ( NS Object o : set ) { o . to XML ( xml , level + NUM_ ) ; xml . append ( NS Object . NEWLINE ) ; } indent ( xml , level ) ; xml . append ( STR_ ) ; }
public static String now ( ) { Calendar cal = Calendar . get Instance ( ) ; Simple Date Format sdf = new Simple Date Format ( STR_ ) ; return sdf . format ( cal . get Time ( ) ) ; }
@ Synchronized ( STR_ ) public boolean is Connected ( ) { return socket != null && ! socket . is Closed ( ) ; }
public int [ ] num Vertices Detected ( Set < ? extends Sampled Vertex > vertices ) { int it = - NUM_ ; T Int Int Hash Map map = new T Int Int Hash Map ( ) ; for ( Sampled Vertex v : vertices ) { if ( v . is Detected ( ) ) { map . adjust Or Put Value ( v . get Iteration Detected ( ) , NUM_ , NUM_ ) ; it = Math . max ( it , v . get Iteration Detected ( ) ) ; } } int [ ] list = new int [ it + NUM_ ] ; for ( int i = NUM_ ; i <= it ; i ++ ) { list [ i ] = map . get ( i ) ; } list [ NUM_ ] += map . get ( - NUM_ ) ; return list ; }
public static char [ ] clone ( char [ ] array ) { char [ ] result = new char [ array . length ] ; System . arraycopy ( array , NUM_ , result , NUM_ , array . length ) ; return result ; }
private Object read Array ( boolean unshared ) throws IO Exception { if ( bin . read Byte ( ) != TC ARRAY ) { throw new Internal Error ( ) ; } Object Stream Class desc = read Class Desc ( false ) ; int len = bin . read Int ( ) ; Object array = null ; Class < ? > cl , ccl = null ; if ( ( cl = desc . for Class ( ) ) != null ) { ccl = cl . get Component Type ( ) ; array = Array . new Instance ( ccl , len ) ; } int array Handle = handles . assign ( unshared ? unshared Marker : array ) ; Class Not Found Exception resolve Ex = desc . get Resolve Exception ( ) ; if ( resolve Ex != null ) { handles . mark Exception ( array Handle , resolve Ex ) ; } if ( ccl == null ) { for ( int i = NUM_ ; i < len ; i ++ ) { read Object 0 ( false ) ; } } else if ( ccl . is Primitive ( ) ) { if ( ccl == Integer . TYPE ) { bin . read Ints ( ( int [ ] ) array , NUM_ , len ) ; } else if ( ccl == Byte . TYPE ) { bin . read Fully ( ( byte [ ] ) array , NUM_ , len , true ) ; } else if ( ccl == Long . TYPE ) { bin . read Longs ( ( long [ ] ) array , NUM_ , len ) ; } else if ( ccl == Float . TYPE ) { bin . read Floats ( ( float [ ] ) array , NUM_ , len ) ; } else if ( ccl == Double . TYPE ) { bin . read Doubles ( ( double [ ] ) array , NUM_ , len ) ; } else if ( ccl == Short . TYPE ) { bin . read Shorts ( ( short [ ] ) array , NUM_ , len ) ; } else if ( ccl == Character . TYPE ) { bin . read Chars ( ( char [ ] ) array , NUM_ , len ) ; } else if ( ccl == Boolean . TYPE ) { bin . read Booleans ( ( boolean [ ] ) array , NUM_ , len ) ; } else { throw new Internal Error ( ) ; } } else { Object [ ] oa = ( Object [ ] ) array ; for ( int i = NUM_ ; i < len ; i ++ ) { oa [ i ] = read Object 0 ( false ) ; handles . mark Dependency ( array Handle , pass Handle ) ; } } handles . finish ( array Handle ) ; pass Handle = array Handle ; return array ; }
public static String request Path ( URL url ) { String file Only = url . get File ( ) ; if ( file Only == null ) { return STR_ ; } else if ( ! file Only . starts With ( STR_ ) ) { return STR_ + file Only ; } else { return file Only ; } }
public static Double zing ( Number value ) { if ( value == null ) { return null ; } return Math . max ( NUM_ , value . double Value ( ) ) ; }
public final Timestamp add Second ( int amount ) { long delta = ( long ) amount * NUM_ ; return add Millis ( delta ) ; }
public static boolean has Java Nature ( I Project project ) { return true ; }
@ Override public boolean is Busy ( ) { return ( m filter Thread != null ) ; }
static Lua Value dump ( Lua Value arg ) { Lua Value f = arg . checkfunction ( ) ; Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; try { Dump State . dump ( ( ( Lua Closure ) f ) . p , baos , true ) ; return Lua String . value Of ( baos . to Byte Array ( ) ) ; } catch ( IO Exception e ) { return error ( e . get Message ( ) ) ; } }
@ Override public int hash Code ( ) { int result ; long temp ; temp = Double . double To Long Bits ( this . lower ) ; result = ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . upper ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; return result ; }
String binary To Internal Class Name ( String class Name ) { if ( class Name == null ) { return null ; } else { return class Name . replace ( STR_ , STR_ ) ; } }
public boolean has Source Node ( Value v ) { return v instanceof Resource && source Nodes . contains ( ( Resource ) v ) ; }
private Map < String , Object > extract Values ( Object object ) { final Map < String , Object > result = new Hash Map < > ( ) ; final Bean Wrapper wrapper = new Bean Wrapper Impl ( object ) ; for ( Property Descriptor descriptor : wrapper . get Property Descriptors ( ) ) { if ( descriptor . get Read Method ( ) == null || descriptor . get Write Method ( ) == null ) { continue ; } final String property Name = descriptor . get Name ( ) ; final Object value = Property Utils . get Property Value ( object , property Name ) ; if ( value == null ) { result . put ( property Name , null ) ; continue ; } if ( is Intractable ( descriptor , value ) ) { result . put ( property Name , value ) ; continue ; } final Map < String , Object > children = extract Values ( value ) ; for ( Map . Entry < String , Object > entry : children . entry Set ( ) ) { result . put ( property Name + STR_ + entry . get Key ( ) , entry . get Value ( ) ) ; } } return result ; }
public static String plural Creature ( final String noun ) { if ( noun . equals ( STR_ ) ) { return STR_ ; } return plural ( noun ) ; }
final public boolean ends With Ignore Case ( final Mutable String suffix ) { final int l = suffix . length ( ) ; int length = length ( ) ; if ( l > length ) return false ; int i = l ; final char [ ] a 1 = suffix . array ; final char [ ] a 2 = array ; char c , d ; while ( i -- != NUM_ ) { c = Character . to Lower Case ( Character . to Upper Case ( a 1 [ i ] ) ) ; d = Character . to Lower Case ( Character . to Upper Case ( a 2 [ -- length ] ) ) ; if ( c != d ) return false ; } return true ; }
public static boolean is PEM ( byte [ ] byte Array ) { try { String start PEM = STR_ ; int header Length = NUM_ ; byte [ ] preamble = new byte [ header Length ] ; System . arraycopy ( byte Array , NUM_ , preamble , NUM_ , header Length ) ; String start Array = new String ( preamble ) ; return start Array . starts With ( start PEM ) ; } catch ( Exception e ) { throw new DSS Exception ( STR_ ) ; } }
static boolean continue Evaluation On Deny Decision ( ) { return continue Evaluation On Deny Decision Flag ; }
public final int data Offset ( ) { return this . bound Offset ; }
public Stream < T > stream ( ) { return Stream Support . stream ( spliterator ( ) , false ) ; }
public static double compute Polygon Area 2 D ( List < Read Only Vector 3 > points ) { if ( points . size ( ) < NUM_ ) { return ( NUM_ ) ; } java . util . Iterator < Read Only Vector 3 > iter = points . iterator ( ) ; if ( ! iter . has Next ( ) ) { return NUM_ ; } double area = NUM_ ; Read Only Vector 3 first Point = iter . next ( ) ; Read Only Vector 3 point = first Point ; while ( iter . has Next ( ) ) { Read Only Vector 3 next Location = iter . next ( ) ; area += point . get X ( ) * next Location . get Y ( ) ; area -= next Location . get X ( ) * point . get Y ( ) ; point = next Location ; } if ( ! point . equals ( first Point ) ) { area += point . get X ( ) * first Point . get Y ( ) ; area -= first Point . get X ( ) * point . get Y ( ) ; } area /= NUM_ ; return area ; }
public String byte String No Comma ( ) { String Buffer retval = new String Buffer ( ) ; try { while ( true ) { char next = look Ahead ( NUM_ ) ; if ( next == STR_ || next == STR_ ) { break ; } else { consume ( NUM_ ) ; retval . append ( next ) ; } } } catch ( Parse Exception ex ) { } return retval . to String ( ) ; }
public static void empty ( final Collection < ? > collection , final String name ) { if ( ! collection . is Empty ( ) ) { final String message = String . format ( STR_ , name ) ; throw new Illegal Argument Exception ( message ) ; } }
@ Visible For Testing boolean is Difference Significant ( double old Average Moving Speed , double new Average Moving Speed ) { if ( old Average Moving Speed == NUM_ ) { return new Average Moving Speed != NUM_ ; } double max Value = Math . max ( old Average Moving Speed , new Average Moving Speed ) ; double difference Percentage = Math . abs ( old Average Moving Speed - new Average Moving Speed ) / max Value * NUM_ ; return difference Percentage >= CRITICAL DIFFERENCE PERCENTAGE ; }
protected boolean is Supported ( Method method ) { return ! method . get Request Streaming ( ) && ! method . get Response Streaming ( ) ; }
public Instance last Instance ( ) { return m Instances . get ( m Instances . size ( ) - NUM_ ) ; }
@ Nullable public T peek ( ) { return my Item Stack . peek ( ) ; }
private List < String > fetch Block Cos Id List ( ) throws SOS Failure { final String method Name = STR_ ; log . trace ( method Name + STR_ ) ; final String BLOCK COS URI = STR_ ; List < String > block Cos Id List = new Array List < String > ( ) ; try { Co S List cos Elem List = client . query Object ( BLOCK COS URI , Co S List . class ) ; if ( cos Elem List != null && cos Elem List . get Cos Elements ( ) != null ) { for ( Co S Element elem : cos Elem List . get Cos Elements ( ) ) { if ( elem != null ) { block Cos Id List . add ( elem . get Id ( ) ) ; } } } log . trace ( method Name + STR_ + block Cos Id List ) ; if ( cos Elem List != null && block Cos Id List != null ) { log . trace ( method Name + STR_ + block Cos Id List . size ( ) + STR_ ) ; return block Cos Id List ; } log . trace ( method Name + STR_ ) ; return new Array List < String > ( ) ; } catch ( No Such Algorithm Exception e ) { log . error ( method Name + STR_ , e ) ; throw new SOS Failure ( e ) ; } catch ( Uniform Interface Exception e ) { log . error ( method Name + STR_ , e ) ; throw new SOS Failure ( e ) ; } }
public boolean more Work Than ( Stored Block other ) { return chain Work . compare To ( other . chain Work ) > NUM_ ; }
public String next Token ( ) { skip Delimiters ( ) ; if ( current Position >= max Position ) { throw new No Such Element Exception ( ) ; } int start = current Position ; while ( ( current Position < max Position ) && ( delimiters . index Of ( str . char At ( current Position ) ) < NUM_ ) ) { current Position ++ ; } if ( ret Tokens && ( start == current Position ) && ( delimiters . index Of ( str . char At ( current Position ) ) >= NUM_ ) ) { current Position ++ ; } return str . substring ( start , current Position ) ; }
public static String encode For POST ( final String str ) { try { return Base 64 . encode ( str . get Bytes ( STR_ ) , true ) ; } catch ( Unsupported Encoding Exception uee ) { debug . error ( STR_ , uee ) ; return null ; } }
protected double distance ( Solution s 1 , Solution s 2 ) { double distance = NUM_ ; for ( int i = NUM_ ; i < s 1 . get Number Of Objectives ( ) ; i ++ ) { distance += Math . pow ( s 1 . get Objective ( i ) - s 2 . get Objective ( i ) , NUM_ ) ; } return Math . sqrt ( distance ) ; }
@ Override public boolean equals ( final Object obj ) { if ( obj instanceof Protocol ) { final Protocol p = ( Protocol ) obj ; return ( default Port == p . get Default Port ( ) && scheme . equals Ignore Case ( p . get Scheme ( ) ) && secure == p . is Secure ( ) && socket Factory . equals ( p . get Socket Factory ( ) ) ) ; } else { return false ; } }
public synchronized Visual Item find Item ( Point p ) { Point 2 D p 2 = ( m itransform == null ? p : m itransform . transform ( p , m tmp Point ) ) ; if ( ! m queue . psorted ) m queue . sort Picking Queue ( ) ; for ( int i = m queue . psize ; -- i >= NUM_ ; ) { Visual Item vi = m queue . pitems [ i ] ; if ( ! vi . is Valid ( ) ) continue ; Renderer r = vi . get Renderer ( ) ; if ( r != null && vi . is Interactive ( ) && r . locate Point ( p 2 , vi ) ) { return vi ; } } return null ; }
final Node < K > find ( int h , Object k ) { if ( k != null ) { for ( Node < K > e = first ; e != null ; ) { int s ; K ek ; if ( ( ( s = lock State ) & ( WAITER | WRITER ) ) != NUM_ ) { if ( e . hash == h && ( ( ek = e . key ) == k || ( ek != null && k . equals ( ek ) ) ) ) return e ; e = e . next ; } else if ( U . compare And Swap Int ( this , LOCKSTATE , s , s + READER ) ) { Tree Node < K > r , p ; try { p = ( ( r = root ) == null ? null : r . find Tree Node ( h , k , null ) ) ; } finally { Thread w ; int ls ; do { } while ( ! U . compare And Swap Int ( this , LOCKSTATE , ls = lock State , ls - READER ) ) ; if ( ls == ( READER | WAITER ) && ( w = waiter ) != null ) Lock Support . unpark ( w ) ; } return p ; } } } return null ; }
private List < Statement > new Bucket Statement ( Policy Type policy , String prefix ) { List < Statement > statements = new Array List < Statement > ( ) ; if ( policy == Policy Type . NONE || bucket Name == null || bucket Name . is Empty ( ) ) { return statements ; } Resources resources = new Resources ( Constants . AWS RESOURCE PREFIX + bucket Name ) ; Statement statement = new Statement ( ) ; statement . set Actions ( Constants . COMMON BUCKET ACTIONS ) ; statement . set Effect ( STR_ ) ; statement . set Principal ( new Principal ( STR_ ) ) ; statement . set Resources ( resources ) ; statement . set Sid ( STR_ ) ; statements . add ( statement ) ; if ( policy == Policy Type . READ ONLY || policy == Policy Type . READ WRITE ) { statement = new Statement ( ) ; statement . set Actions ( Constants . READ ONLY BUCKET ACTIONS ) ; statement . set Effect ( STR_ ) ; statement . set Principal ( new Principal ( STR_ ) ) ; statement . set Resources ( resources ) ; statement . set Sid ( STR_ ) ; if ( prefix != null && ! prefix . is Empty ( ) ) { statement . set Conditions ( new Condition Map ( STR_ , new Condition Key Map ( STR_ , prefix ) ) ) ; } statements . add ( statement ) ; } if ( policy == Policy Type . WRITE ONLY || policy == Policy Type . READ WRITE ) { statement = new Statement ( ) ; statement . set Actions ( Constants . WRITE ONLY BUCKET ACTIONS ) ; statement . set Effect ( STR_ ) ; statement . set Principal ( new Principal ( STR_ ) ) ; statement . set Resources ( resources ) ; statement . set Sid ( STR_ ) ; statements . add ( statement ) ; } return statements ; }
public boolean is Redirect ( ) { return is Redirect ; }
private static String [ ] compose List ( Message Format format , String [ ] list ) { if ( list . length <= NUM_ ) return list ; String [ ] list Items = { list [ NUM_ ] , list [ NUM_ ] } ; String new Item = format . format ( list Items ) ; String [ ] new List = new String [ list . length - NUM_ ] ; System . arraycopy ( list , NUM_ , new List , NUM_ , new List . length - NUM_ ) ; new List [ NUM_ ] = new Item ; return compose List ( format , new List ) ; }
public static String to Comma Separated Format ( Set set ) { String Builder buff = new String Builder ( ) ; boolean first Entry = true ; for ( Iterator iter = set . iterator ( ) ; iter . has Next ( ) ; ) { if ( ! first Entry ) { buff . append ( STR_ ) ; } else { first Entry = false ; } buff . append ( ( String ) iter . next ( ) ) ; } return buff . to String ( ) ; }
private static boolean earlier Line ( Location loc 1 , Location loc 2 ) { return loc 1 . begin Line ( ) < loc 2 . begin Line ( ) ; }
private List < Color > project ( final List < Entry < Color , Integer > > color List ) { final List < Color > colors = new Array List < Color > ( ) ; for ( final Entry < Color , Integer > entry : color List ) { colors . add ( entry . get Key ( ) ) ; } return colors ; }
public static Component UI create UI ( J Component c ) { if ( c == null || slider Class == null ) { return null ; } UI Defaults defaults = UI Manager . get Look And Feel Defaults ( ) ; try { Method m = ( Method ) defaults . get ( slider Class ) ; if ( m == null ) { m = slider Class . get Method ( STR_ , new Class < ? > [ ] { J Component . class } ) ; defaults . put ( slider Class , m ) ; } Component UI ui Object = ( Component UI ) m . invoke ( null , new Object [ ] { c } ) ; if ( ui Object instanceof Basic Slider UI ) { c . add Hierarchy Listener ( new Mouse Attacher ( ) ) ; } return ui Object ; } catch ( No Such Method Exception | Security Exception | Illegal Access Exception | Illegal Argument Exception | Invocation Target Exception e ) { throw new Runtime Exception ( e ) ; } }
public int size ( ) { return methods . size ( ) ; }
public boolean engine Can Resolve ( Element element , String Base URI , Storage Resolver storage ) { if ( XML Utils . element Is In Signature Space ( element , Constants . TAG X 509 DATA ) || XML Utils . element Is In Signature Space ( element , Constants . TAG KEYNAME ) ) { return true ; } return false ; }
private boolean should Ignore Input Event From Class ( String clz Name ) { for ( Pattern re : IGNORE INPUT EVENTS IN ) { Matcher matcher = re . matcher ( clz Name ) ; if ( matcher . matches ( ) ) return true ; } return false ; }
protected void handle IO Exception ( IO Exception err ) { handle Exception ( err ) ; }
Big Integer sum Coeffs ( ) { Big Integer sum = Constants . BIGINT ZERO ; for ( int i = NUM_ ; i < coeffs . length ; i ++ ) { sum = sum . add ( coeffs [ i ] ) ; } return sum ; }
default Feature Toggle < T > to Feature Toggle ( ) { final Optional < T > opt = to Optional ( ) ; return opt . is Present ( ) ? Feature Toggle . enable ( opt . get ( ) ) : Feature Toggle . disable ( null ) ; }
public static double float To Double Lower ( float f ) { if ( Float . is Na N ( f ) ) { return Double . Na N ; } if ( Float . is Infinite ( f ) ) { if ( f < NUM_ ) { return Double . NEGATIVE INFINITY ; } else { return Double . long Bits To Double ( NUM_ ) ; } } long bits = Double . double To Raw Long Bits ( ( double ) f ) ; if ( ( bits & NUM_ ) == NUM_ ) { if ( bits == NUM_ ) { return + NUM_ ; } if ( f == Float . MIN VALUE ) { return Double . long Bits To Double ( NUM_ ) ; } if ( Float . MIN NORMAL > f ) { final long bits 2 = Double . double To Raw Long Bits ( ( double ) - Math . next Up ( - f ) ) ; bits = ( bits > > > NUM_ ) + ( bits 2 > > > NUM_ ) + NUM_ ; } else { bits -= NUM_ ; } return Double . long Bits To Double ( bits ) ; } else { if ( bits == NUM_ ) { return Double . long Bits To Double ( NUM_ ) ; } if ( f == - Float . MIN VALUE ) { return Double . long Bits To Double ( NUM_ ) ; } if ( - Float . MIN NORMAL < f ) { final long bits 2 = Double . double To Raw Long Bits ( ( double ) - Math . next Up ( - f ) ) ; bits = ( bits > > > NUM_ ) + ( bits 2 > > > NUM_ ) - NUM_ ; } else { bits += NUM_ ; } return Double . long Bits To Double ( bits ) ; } }
@ Not Null public List < String > module Paths ( ) { List < String > result = Lists . new Array List ( ) ; result . add ( STR_ ) ; List < String > include Paths = my Gradle Dsl File . get List Property ( INCLUDE , String . class ) ; if ( include Paths == null ) { return result ; } for ( String include Path : include Paths ) { result . add ( standardise Module Path ( include Path ) ) ; } return result ; }
protected static double acosine ( double [ ] line , double [ ] point ) { return Math . acos ( cosine ( line , point ) ) ; }
public static String slurp File No Exceptions ( File file ) { try { return slurp Reader ( new File Reader ( file ) ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; return null ; } }
private long offset ( long offset ) { return this . offset + offset ; }
protected static String make Option String ( Data Generator generator ) { String Buffer result ; Enumeration < Option > enm ; Option option ; result = new String Buffer ( ) ; result . append ( STR_ ) ; enm = generator . list Options ( ) ; while ( enm . has More Elements ( ) ) { option = enm . next Element ( ) ; if ( is On Blacklist ( option . name ( ) ) ) { continue ; } result . append ( option . synopsis ( ) + STR_ + option . description ( ) + STR_ ) ; } return result . to String ( ) ; }
public Map < String , Plugin Descriptor > parse Plugin Folder ( String [ ] plugin Folders ) { Map < String , Plugin Descriptor > map = new Hash Map < String , Plugin Descriptor > ( ) ; if ( plugin Folders == null ) { throw new Illegal Argument Exception ( STR_ ) ; } for ( String name : plugin Folders ) { File directory = get Plugin Folder ( name ) ; if ( directory == null ) { continue ; } LOG . info ( STR_ + directory . get Absolute Path ( ) ) ; for ( File one Sub Folder : directory . list Files ( ) ) { if ( one Sub Folder . is Directory ( ) ) { String manifest Path = one Sub Folder . get Absolute Path ( ) + File . separator + STR_ ; try { LOG . debug ( STR_ + manifest Path ) ; Plugin Descriptor p = parse Manifest File ( manifest Path ) ; map . put ( p . get Plugin Id ( ) , p ) ; } catch ( Malformed URL Exception e ) { LOG . warn ( e . to String ( ) ) ; } catch ( SAX Exception e ) { LOG . warn ( e . to String ( ) ) ; } catch ( IO Exception e ) { LOG . warn ( e . to String ( ) ) ; } catch ( Parser Configuration Exception e ) { LOG . warn ( e . to String ( ) ) ; } } } } return map ; }
public Complex exp ( ) { return new Complex ( Math . exp ( re ) * Math . cos ( im ) , Math . exp ( re ) * Math . sin ( im ) ) ; }
public static boolean has Phone Number ( Content Resolver resolver , long contact ID ) { Cursor phone Cursor ; String [ ] selection Args = { String . value Of ( contact ID ) } ; Uri content Uri = Common Data Kinds . Phone . CONTENT URI ; phone Cursor = resolver . query ( content Uri , Data Type Query . PROJECTION , Data Type Query . SELECTION , selection Args , Data Type Query . SORTORDER + STR_ ) ; if ( phone Cursor == null ) { return false ; } try { return phone Cursor . get Count ( ) > NUM_ ; } catch ( Exception e ) { Error Tracker . track ( e ) ; } finally { if ( ! phone Cursor . is Closed ( ) ) { phone Cursor . close ( ) ; } } return false ; }
public int ref Count ( ) { return ref Counter . ref Count ( ) ; }
public String generate Pair Name ( Block Object source , Block Object target ) { String Builder pair Name = new String Builder ( ) ; pair Name . append ( source . get Native Id ( ) ) ; pair Name . append ( HDS Constants . UNDERSCORE OPERATOR ) ; pair Name . append ( target . get Native Id ( ) ) ; pair Name . append ( HDS Constants . UNDERSCORE OPERATOR ) ; pair Name . append ( HDS Constants . SI ) ; return pair Name . to String ( ) ; }
private final Sorted Map identify Candidate Delimiters ( String s Str , int i N Gram Size ) { String s Sub Str = null ; Integer [ ] i Res = null ; Array List al Res = new Array List ( ) ; Tree Map tm Res = new Tree Map ( ) ; for ( int i Cnt = NUM_ ; i Cnt <= s Str . length ( ) - i N Gram Size ; i Cnt ++ ) { if ( i Cnt + i N Gram Size > s Str . length ( ) ) continue ; s Sub Str = s Str . substring ( i Cnt , i Cnt + i N Gram Size ) ; if ( tm Res . contains Value ( s Sub Str ) ) continue ; Vertex v Str Node = cl Locator . locate Vertex In Graph ( sg Overall Graph , new Vertex Impl ( s Sub Str ) ) ; if ( v Str Node == null ) continue ; double d Entropy = get Entropy Of Next Char ( s Sub Str , false ) ; tm Res . put ( d Entropy , s Sub Str ) ; } return tm Res ; }
private final boolean weak Play Skip Move ( Position pos , Move m , int ply ) { long rnd L = pos . zobrist Hash ( ) ^ Position . ps Hash Keys [ NUM_ ] [ m . from ] ^ Position . ps Hash Keys [ NUM_ ] [ m . to ] ^ random Seed ; double rnd = ( ( rnd L & NUM_ ) % NUM_ ) / NUM_ ; double s = strength * NUM_ ; double offs = ( NUM_ - NUM_ * s ) / NUM_ ; double eff Ply = ply * Evaluate . interpolate ( pos . w Mtrl + pos . b Mtrl , NUM_ , NUM_ , Evaluate . q V * NUM_ , NUM_ ) * NUM_ ; double t = eff Ply + offs ; double p = NUM_ / ( NUM_ + Math . exp ( t ) ) ; boolean easy Move = ( ( pos . get Piece ( m . to ) != Piece . EMPTY ) || ( ply < NUM_ ) || ( search Tree Info [ ply - NUM_ ] . current Move . to == m . from ) ) ; if ( easy Move ) p = NUM_ - ( NUM_ - p ) * ( NUM_ - p ) ; if ( rnd > p ) return true ; return false ; }
public boolean is Class Subclass Of ( Soot Class child , Soot Class possible Parent ) { child . check Level ( Soot Class . HIERARCHY ) ; possible Parent . check Level ( Soot Class . HIERARCHY ) ; List < Soot Class > parent Classes = get Superclasses Of ( child ) ; if ( parent Classes . contains ( possible Parent ) ) return true ; for ( Soot Class sc : parent Classes ) if ( sc . is Phantom ( ) ) return true ; return false ; }
public static long prefix Coded To Long ( final Bytes Ref val ) { long sortable Bits = NUM_ ; for ( int i = val . offset + NUM_ , limit = val . offset + val . length ; i < limit ; i ++ ) { sortable Bits <<= NUM_ ; final byte b = val . bytes [ i ] ; if ( b < NUM_ ) { throw new Number Format Exception ( STR_ + Integer . to Hex String ( b & NUM_ ) + STR_ + ( i - val . offset ) + STR_ ) ; } sortable Bits |= b ; } return ( sortable Bits << get Prefix Coded Long Shift ( val ) ) ^ NUM_ ; }
private Map . Entry < List < String > , Map < String , Document > > generate Index Documents ( int ndocs , boolean requires Contexts ) { Map < String , Document > docs = new Hash Map < > ( ) ; List < String > invalid Doc Terms = new Array List < > ( ) ; for ( int i = NUM_ ; i < ndocs ; i ++ ) { Document doc = new Document ( ) ; boolean invalid Doc = false ; Field field = null ; if ( usually ( ) ) { field = new Text Field ( FIELD NAME , STR_ + i , Field . Store . YES ) ; doc . add ( field ) ; } else { invalid Doc = true ; } if ( usually ( ) ) { Field payload = new Stored Field ( PAYLOAD FIELD NAME , new Bytes Ref ( STR_ + i ) ) ; doc . add ( payload ) ; } if ( requires Contexts || usually ( ) ) { if ( usually ( ) ) { for ( int j = NUM_ ; j < at Least ( NUM_ ) ; j ++ ) { doc . add ( new Stored Field ( CONTEXT FIELD NAME , new Bytes Ref ( STR_ + i + STR_ + j ) ) ) ; } } } if ( usually ( ) ) { Field weight = ( rarely ( ) ) ? new Stored Field ( WEIGHT FIELD NAME , NUM_ + i ) : new Numeric Doc Values Field ( WEIGHT FIELD NAME , NUM_ + i ) ; doc . add ( weight ) ; } String term = null ; if ( invalid Doc ) { term = ( field != null ) ? field . string Value ( ) : STR_ + i ; invalid Doc Terms . add ( term ) ; } else { term = field . string Value ( ) ; } docs . put ( term , doc ) ; } return new Simple Entry < > ( invalid Doc Terms , docs ) ; }
@ Override public int hash Code ( ) { return groundings . hash Code ( ) ; }
public boolean has Receiver ( ) { return invoke Expr != null && invoke Expr instanceof Instance Invoke Expr ; }
public static Date Format to Time Format ( String time Format , Time Zone tz , Locale locale ) { Date Format df = null ; if ( Util Validate . is Empty ( time Format ) ) { df = Date Format . get Time Instance ( Date Format . MEDIUM , locale ) ; } else { df = new Simple Date Format ( time Format , locale == null ? Locale . get Default ( ) : locale ) ; } df . set Time Zone ( tz ) ; return df ; }
public static String format Name For Class Loading ( String name ) { if ( name == null ) { return STR_ ; } if ( name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) || name . equals ( STR_ ) ) { return name ; } if ( name . starts With ( STR_ ) ) { return name . replace ( STR_ , STR_ ) ; } if ( name . starts With ( STR_ ) ) { name = name . substring ( NUM_ ) ; if ( name . ends With ( STR_ ) ) { name = name . substring ( NUM_ , name . length ( ) - NUM_ ) ; } return name . replace ( STR_ , STR_ ) ; } String prefix = STR_ ; if ( name . ends With ( STR_ ) ) { prefix = STR_ ; name = name . substring ( NUM_ , name . length ( ) - NUM_ ) ; if ( name . equals ( STR_ ) ) { return prefix + STR_ ; } else if ( name . equals ( STR_ ) ) { return prefix + STR_ ; } else if ( name . equals ( STR_ ) ) { return prefix + STR_ ; } else if ( name . equals ( STR_ ) ) { return prefix + STR_ ; } else if ( name . equals ( STR_ ) ) { return prefix + STR_ ; } else if ( name . equals ( STR_ ) ) { return prefix + STR_ ; } else if ( name . equals ( STR_ ) ) { return prefix + STR_ ; } else if ( name . equals ( STR_ ) ) { return prefix + STR_ ; } else { return prefix + STR_ + name . replace ( STR_ , STR_ ) + STR_ ; } } return name . replace ( STR_ , STR_ ) ; }
public static API v ( ) { return v ; }
public boolean start Timeline Request ( ) { return request In Flight . compare And Set ( false , true ) ; }
@ Override public int hash Code ( ) { int result = NUM_ ; result = NUM_ * result + type ; result = NUM_ * result + Arrays . hash Code ( encoded ) ; return result ; }
public static long elevation At Tick ( Geo Time Serie gts , long tick ) { if ( null == gts . elevations ) { return Geo Time Serie . NO ELEVATION ; } sort ( gts , false ) ; int idx = Arrays . binary Search ( gts . ticks , NUM_ , gts . values , tick ) ; if ( idx < NUM_ ) { return Geo Time Serie . NO ELEVATION ; } else { return gts . elevations [ idx ] ; } }
private static String unique Algorithm ( List names , String base Name , String sep ) { String new Name = base Name ; int unique = NUM_ ; while ( names . contains ( new Name ) ) { String ins = ( sep == null ? STR_ : sep ) ; new Name = base Name + ins + String . value Of ( ++ unique ) ; } names . add ( new Name ) ; return new Name ; }
public int compute Naive LCA ( final int [ ] taxon Ids , final int length ) { if ( length == NUM_ ) return Id Mapper . NOHITS ID ; else if ( length == NUM_ ) return taxon Ids [ NUM_ ] ; if ( taxon Ids . length > addresses . length ) { addresses = new String [ taxon Ids . length ] ; weights = new int [ taxon Ids . length ] ; } int number Of Addresses = NUM_ ; for ( int i = NUM_ ; i < length ; i ++ ) { int taxon Id = taxon Ids [ i ] ; if ( ! Taxonomy Data . is Taxon Disabled ( taxon Id ) ) { String address = Taxonomy Data . get Address ( taxon Id ) ; if ( address != null ) { addresses [ number Of Addresses ++ ] = address ; } } } if ( number Of Addresses > NUM_ ) { final String address = LCA Addressing . get Common Prefix ( addresses , number Of Addresses , true ) ; return Taxonomy Data . get Address 2 Id ( address ) ; } return Id Mapper . UNASSIGNED ID ; }
public static String print Event ( Event Bean the Event ) { String Writer writer = new String Writer ( ) ; Print Writer buf = new Print Writer ( writer ) ; print Event ( buf , the Event ) ; return writer . to String ( ) ; }
public static String to String Never Null ( Object o ) { return o == null ? STR_ : o . to String ( ) ; }
public int capacity ( ) { return internal . capacity ( ) ; }
public Collection < String > files ( boolean include Segments File ) throws IO Exception { Hash Set < String > files = new Hash Set < > ( ) ; if ( include Segments File ) { final String segment File Name = get Segments File Name ( ) ; if ( segment File Name != null ) { files . add ( segment File Name ) ; } } final int size = size ( ) ; for ( int i = NUM_ ; i < size ; i ++ ) { final Segment Commit Info info = info ( i ) ; files . add All ( info . files ( ) ) ; } return files ; }
public Message Formatter remove Message Formatter ( String domain ) { return ( Message Formatter ) f Message Formatters . remove ( domain ) ; }
public byte [ ] encode ( ) { char type = get Attribute Type ( ) ; byte bin Value [ ] = new byte [ HEADER LENGTH + get Data Length ( ) + ( get Data Length ( ) % NUM_ ) ] ; bin Value [ NUM_ ] = ( byte ) ( type > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( type & NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) & NUM_ ) ; System . arraycopy ( nonce , NUM_ , bin Value , NUM_ , ( int ) get Data Length ( ) ) ; return bin Value ; }
Checksum File resolve Checksum File ( Path path ) throws Update Exception { try { return new Checksum File ( path . resolve ( CHECKSUMS FILE ) ) ; } catch ( IO Exception | No Such Algorithm Exception e ) { throw new Update Exception ( STR_ , e ) ; } catch ( Null Pointer Exception e ) { throw new Update Exception ( STR_ , e ) ; } }
public boolean was Broadcast By ( Peer Address address ) { return broadcast By . contains ( address ) ; }
public int length ( ) { return m Text . length ( ) ; }
public static boolean is Final ( int mod ) { return Modifier . is Final ( mod ) ; }
public boolean equals ( Object b ) { if ( ! ( b instanceof Invocation Key ) ) return false ; Invocation Key test = ( Invocation Key ) b ; if ( is Secure != test . is Secure ) return false ; if ( port != test . port ) return false ; int length = uri Length ; if ( length != test . uri Length ) return false ; byte [ ] uri A = uri ; byte [ ] uri B = test . uri ; for ( int i = length - NUM_ ; i >= NUM_ ; i -- ) if ( uri A [ i ] != uri B [ i ] ) return false ; if ( host == null ) return test . host == null ; else return host . equals ( test . host ) ; }
public String product Publication Date ( ) { return properties . get Property ( STR_ ) ; }
public static float parse String ( String value ) { return Float . parse Float ( value ) ; }
protected static String [ ] split String By Delimiter Points ( String s Str , Integer [ ] i Res ) { Array List al Res = new Array List ( ) ; for ( int i Cnt = NUM_ ; i Cnt < i Res . length ; i Cnt ++ ) { if ( i Cnt == NUM_ ) al Res . add ( s Str . substring ( NUM_ , i Res [ i Cnt ] ) ) ; else al Res . add ( s Str . substring ( i Res [ i Cnt - NUM_ ] , i Res [ i Cnt ] ) ) ; } if ( i Res . length > NUM_ ) al Res . add ( s Str . substring ( i Res [ i Res . length - NUM_ ] ) ) ; else al Res . add ( s Str ) ; String [ ] s Res = new String [ al Res . size ( ) ] ; al Res . to Array ( s Res ) ; return s Res ; }
public static boolean is Assignable From ( Class < ? > destination , Class < ? > source ) { return destination . is Assignable From ( source ) || is Boxing ( destination , source ) || is Un Boxing ( destination , source ) ; }
public int search ( byte [ ] text ) { int M = pattern . length ; int N = text . length ; int skip ; for ( int i = NUM_ ; i <= N - M ; i += skip ) { skip = NUM_ ; for ( int j = M - NUM_ ; j >= NUM_ ; j -- ) { if ( pattern [ j ] != text [ i + j ] ) { skip = Math . max ( NUM_ , j - right [ text [ i + j ] ] ) ; break ; } } if ( skip == NUM_ ) return i ; } return N ; }
public boolean user Has Given Role In Any Tenant ( Storage OS User user , Role ... roles ) { if ( user Has Given Role ( user , URI . create ( user . get Tenant Id ( ) ) , roles ) ) { return true ; } Map < String , Collection < String > > all Subtenant Roles = null ; for ( Role role : roles ) { if ( is Role Tenant Level ( role . to String ( ) ) ) { if ( all Subtenant Roles == null ) { all Subtenant Roles = get Subtenant Roles For User ( user ) ; } for ( Collection < String > subtenant Roles : all Subtenant Roles . values ( ) ) { if ( subtenant Roles . contains ( role . to String ( ) ) ) { return true ; } } } } return false ; }
public static String build Filter Clause ( final String sql , final Object value , final List < Object > prepared Args ) { if ( value != null ) { prepared Args . add ( value ) ; return sql ; } else { return null ; } }
public byte [ ] serialize ( ) throws IO Exception { Byte Array Output Stream bytes Out = new Byte Array Output Stream ( ) ; Data Output Stream data Out = new Data Output Stream ( bytes Out ) ; write ( data Out ) ; return bytes Out . to Byte Array ( ) ; }
public static Keyczar Reader export Public Keys ( Generic Keyczar private Key ) throws Keyczar Exception { Key Metadata kmd = private Key . get Metadata ( ) ; Key Metadata public Kmd = null ; if ( kmd . get Type ( ) == Default Key Type . DSA PRIV ) { if ( kmd . get Purpose ( ) == Key Purpose . SIGN AND VERIFY ) { public Kmd = new Key Metadata ( kmd . get Name ( ) , Key Purpose . VERIFY , Default Key Type . DSA PUB ) ; } } else if ( kmd . get Type ( ) == Default Key Type . RSA PRIV ) { switch ( kmd . get Purpose ( ) ) { case DECRYPT AND ENCRYPT : public Kmd = new Key Metadata ( kmd . get Name ( ) , Key Purpose . ENCRYPT , Default Key Type . RSA PUB ) ; break ; case SIGN AND VERIFY : public Kmd = new Key Metadata ( kmd . get Name ( ) , Key Purpose . VERIFY , Default Key Type . RSA PUB ) ; break ; default : throw new Illegal Argument Exception ( STR_ + kmd . get Purpose ( ) ) ; } } if ( public Kmd == null ) { throw new Keyczar Exception ( Messages . get String ( STR_ , kmd . get Type ( ) , kmd . get Purpose ( ) ) ) ; } Hash Map < Integer , Keyczar Key > keys = new Hash Map < Integer , Keyczar Key > ( ) ; for ( Key Version version : private Key . get Versions ( ) ) { try { Keyczar Key key = private Key . get Key ( version ) ; Keyczar Key public Key = ( Keyczar Key ) get Public Method . invoke ( key ) ; public Kmd . add Version ( version ) ; keys . put ( version . get Version Number ( ) , public Key ) ; } catch ( Illegal Access Exception e ) { throw new Runtime Exception ( e ) ; } catch ( Invocation Target Exception e ) { throw new Runtime Exception ( e ) ; } } return new Memory Key Reader ( public Kmd , keys ) ; }
public double availability ( ) { if ( ! honor Lease ) { return connection . availability ( ) ; } final long now = System . current Time Millis ( ) ; double available = NUM_ ; if ( number Of Remaining Requests > NUM_ && ( now < ttl Expiration ) ) { available = NUM_ ; } return available * connection . availability ( ) ; }
public int find Column ( String column Name ) { for ( int i = NUM_ ; i < m fields . size ( ) ; i ++ ) { Grid Field field = ( Grid Field ) m fields . get ( i ) ; if ( column Name . equals ( field . get Column Name ( ) ) ) return i ; } return - NUM_ ; }
Class find Class No Imports ( String name , int lineno , int override ) throws Configuration Exception { Class c = find Class Exact ( name , lineno , override ) ; if ( c != null ) { return c ; } int dot ; while ( ( dot = name . last Index Of ( STR_ ) ) >= NUM_ ) { name = name . substring ( NUM_ , dot ) + STR_ + name . substring ( dot + NUM_ ) ; c = find Class Exact ( name , lineno , override ) ; if ( c != null ) { return c ; } } return null ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public String [ ] preference Names ( ) { Set < String > set = properties . string Property Names ( ) ; return set . to Array ( new String [ set . size ( ) ] ) ; }
public < E extends T > E max ( Iterable < E > iterable ) { Iterator < E > iterator = iterable . iterator ( ) ; E max So Far = iterator . next ( ) ; while ( iterator . has Next ( ) ) { max So Far = max ( max So Far , iterator . next ( ) ) ; } return max So Far ; }
public int hash Code ( ) { return ( l Schema Type . hash Code ( ) ) ; }
public boolean contains ( String str ) { for ( String text : logs ) if ( text != null && text . contains ( str ) ) return true ; return false ; }
public static int prev Pow 2 ( int x ) { if ( x < NUM_ ) throw new Illegal Argument Exception ( STR_ ) ; return ( int ) Math . pow ( NUM_ , Math . floor ( Math . log ( x ) / Math . log ( NUM_ ) ) ) ; }
private int read Name Length ( Byte Buffer buffer ) { return Byte Util . get Unsigned Var Int ( buffer , get Format ( ) . SIZE NAME LENGTH ) ; }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ ; }
public static float [ ] from RGB ( Color Space color Space , int r , int g , int b ) { return color Space . from RGB ( new float [ ] { r / NUM_ , g / NUM_ , b / NUM_ } ) ; }
public final int last Index Of ( java . lang . Char Sequence csq , int from Index ) { if ( ( offset + from Index + csq . length ( ) - NUM_ ) >= ( offset + length ) ) throw new Index Out Of Bounds Exception ( String . format ( STR_ , from Index ) ) ; final char c = csq . char At ( NUM_ ) ; final int csq Length = csq . length ( ) ; for ( int i = length + offset - csq Length - from Index , end = offset ; i >= end ; i -- ) { if ( array [ i ] == c ) { boolean match = true ; for ( int j = NUM_ ; j < csq Length ; j ++ ) { if ( array [ i + j ] != csq . char At ( j ) ) { match = false ; break ; } } if ( match ) { return i - offset ; } } } return - NUM_ ; }
public int next Int ( double the Mean ) { Random Engine gen = this . random Generator ; double my = the Mean ; double t , g , my k ; double gx , gy , px , py , e , x , xx , delta , v ; int sign ; double u ; int k , i ; if ( my < SWITCH MEAN ) { if ( my != my old ) { my old = my ; llll = NUM_ ; p = Math . exp ( - my ) ; q = p ; p 0 = p ; } m = ( my > NUM_ ) ? ( int ) my : NUM_ ; for ( ; ; ) { u = gen . raw ( ) ; k = NUM_ ; if ( u <= p 0 ) return ( k ) ; if ( llll != NUM_ ) { i = ( u > NUM_ ) ? Math . min ( llll , m ) : NUM_ ; for ( k = i ; k <= llll ; k ++ ) if ( u <= pp [ k ] ) return ( k ) ; if ( llll == NUM_ ) continue ; } for ( k = llll + NUM_ ; k <= NUM_ ; k ++ ) { p *= my / ( double ) k ; q += p ; pp [ k ] = q ; if ( u <= q ) { llll = k ; return ( k ) ; } } llll = NUM_ ; } } else if ( my < MEAN MAX ) { int Dk , X , Y ; double Ds , U , V , W ; m = ( int ) my ; if ( my != my last ) { my last = my ; Ds = Math . sqrt ( my + NUM_ ) ; k 2 = ( int ) Math . ceil ( my - NUM_ - Ds ) ; k 4 = ( int ) ( my - NUM_ + Ds ) ; k 1 = k 2 + k 2 - m + NUM_ ; k 5 = k 4 + k 4 - m ; dl = ( double ) ( k 2 - k 1 ) ; dr = ( double ) ( k 5 - k 4 ) ; r 1 = my / ( double ) k 1 ; r 2 = my / ( double ) k 2 ; r 4 = my / ( double ) ( k 4 + NUM_ ) ; r 5 = my / ( double ) ( k 5 + NUM_ ) ; ll = Math . log ( r 1 ) ; lr = - Math . log ( r 5 ) ; l my = Math . log ( my ) ; c pm = m * l my - Arithmetic . log Factorial ( m ) ; f 2 = f ( k 2 , l my , c pm ) ; f 4 = f ( k 4 , l my , c pm ) ; f 1 = f ( k 1 , l my , c pm ) ; f 5 = f ( k 5 , l my , c pm ) ; p 1 = f 2 * ( dl + NUM_ ) ; p 2 = f 2 * dl + p 1 ; p 3 = f 4 * ( dr + NUM_ ) + p 2 ; p 4 = f 4 * dr + p 3 ; p 5 = f 1 / ll + p 4 ; p 6 = f 5 / lr + p 5 ; } for ( ; ; ) { if ( ( U = gen . raw ( ) * p 6 ) < p 2 ) { if ( ( V = U - p 1 ) < NUM_ ) return ( k 2 + ( int ) ( U / f 2 ) ) ; if ( ( W = V / dl ) < f 1 ) return ( k 1 + ( int ) ( V / f 1 ) ) ; Dk = ( int ) ( dl * gen . raw ( ) ) + NUM_ ; if ( W <= f 2 - Dk * ( f 2 - f 2 / r 2 ) ) { return ( k 2 - Dk ) ; } if ( ( V = f 2 + f 2 - W ) < NUM_ ) { Y = k 2 + Dk ; if ( V <= f 2 + Dk * ( NUM_ - f 2 ) / ( dl + NUM_ ) ) { return ( Y ) ; } if ( V <= f ( Y , l my , c pm ) ) return ( Y ) ; } X = k 2 - Dk ; } else if ( U < p 4 ) { if ( ( V = U - p 3 ) < NUM_ ) return ( k 4 - ( int ) ( ( U - p 2 ) / f 4 ) ) ; if ( ( W = V / dr ) < f 5 ) return ( k 5 - ( int ) ( V / f 5 ) ) ; Dk = ( int ) ( dr * gen . raw ( ) ) + NUM_ ; if ( W <= f 4 - Dk * ( f 4 - f 4 * r 4 ) ) { return ( k 4 + Dk ) ; } if ( ( V = f 4 + f 4 - W ) < NUM_ ) { Y = k 4 - Dk ; if ( V <= f 4 + Dk * ( NUM_ - f 4 ) / dr ) { return ( Y ) ; } if ( V <= f ( Y , l my , c pm ) ) return ( Y ) ; } X = k 4 + Dk ; } else { W = gen . raw ( ) ; if ( U < p 5 ) { Dk = ( int ) ( NUM_ - Math . log ( W ) / ll ) ; if ( ( X = k 1 - Dk ) < NUM_ ) continue ; W *= ( U - p 4 ) * ll ; if ( W <= f 1 - Dk * ( f 1 - f 1 / r 1 ) ) return ( X ) ; } else { Dk = ( int ) ( NUM_ - Math . log ( W ) / lr ) ; X = k 5 + Dk ; W *= ( U - p 5 ) * lr ; if ( W <= f 5 - Dk * ( f 5 - f 5 * r 5 ) ) return ( X ) ; } } if ( Math . log ( W ) <= X * l my - Arithmetic . log Factorial ( X ) - c pm ) return ( X ) ; } } else { return ( int ) my ; } }
public Search Builder query ( Condition Builder < ? , ? > ... builders ) { query . add All ( Arrays . as List ( builders ) ) ; return this ; }
public static final Geo Time Serie sub Serie ( Geo Time Serie gts , long starttimestamp , long stoptimestamp , boolean overwrite , boolean copy Labels , Geo Time Serie subgts ) { if ( null == subgts ) { subgts = new Geo Time Serie ( NUM_ ) ; subgts . set Name ( gts . get Name ( ) ) ; if ( copy Labels ) { subgts . set Labels ( gts . get Labels ( ) ) ; } } else { GTS Helper . reset ( subgts ) ; } if ( null == gts . ticks || NUM_ == gts . values ) { return subgts ; } GTS Helper . sort ( gts ) ; int lastidx = Arrays . binary Search ( gts . ticks , NUM_ , gts . values , stoptimestamp ) ; if ( - NUM_ == lastidx ) { return subgts ; } else if ( lastidx < NUM_ ) { lastidx = - lastidx - NUM_ ; if ( lastidx >= gts . values ) { lastidx = gts . values - NUM_ ; } } int firstidx = Arrays . binary Search ( gts . ticks , NUM_ , lastidx + NUM_ , starttimestamp ) ; if ( firstidx < NUM_ ) { firstidx = - firstidx - NUM_ ; } if ( firstidx >= gts . values ) { return subgts ; } for ( int i = firstidx ; i <= lastidx ; i ++ ) { if ( gts . ticks [ i ] >= starttimestamp && gts . ticks [ i ] <= stoptimestamp ) { set Value ( subgts , gts . ticks [ i ] , null != gts . locations ? gts . locations [ i ] : Geo Time Serie . NO LOCATION , null != gts . elevations ? gts . elevations [ i ] : Geo Time Serie . NO ELEVATION , value At Index ( gts , i ) , overwrite ) ; } } return subgts ; }
static int svd imin ( int a , int b ) { return Math . min ( a , b ) ; }
private Char Property char Property Node For ( String name ) { Char Property p = Char Property Names . char Property For ( name ) ; if ( p == null ) throw error ( STR_ + name + STR_ ) ; return p ; }
static public double j 0 ( double x ) throws Arithmetic Exception { double ax ; if ( ( ax = Math . abs ( x ) ) < NUM_ ) { double y = x * x ; double ans 1 = NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ ) ) ) ) ) ; double ans 2 = NUM_ + y * ( NUM_ + y * ( NUM_ + y * ( NUM_ + y * ( NUM_ + y * NUM_ ) ) ) ) ; return ans 1 / ans 2 ; } else { double z = NUM_ / ax ; double y = z * z ; double xx = ax - NUM_ ; double ans 1 = NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * NUM_ ) ) ) ; double ans 2 = - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * ( NUM_ - y * NUM_ ) ) ) ; return Math . sqrt ( NUM_ / ax ) * ( Math . cos ( xx ) * ans 1 - z * Math . sin ( xx ) * ans 2 ) ; } }
private static boolean Check For Conflicting Spec Options ( ) { if ( ( Pcal Params . Spec Option ? NUM_ : NUM_ ) + ( Pcal Params . Myspec Option ? NUM_ : NUM_ ) + ( Pcal Params . Spec 2 Option ? NUM_ : NUM_ ) + ( Pcal Params . Myspec 2 Option ? NUM_ : NUM_ ) + ( Pcal Params . Write AST Flag ? NUM_ : NUM_ ) > NUM_ ) { Command Line Error ( STR_ + STR_ ) ; return true ; } ; return false ; }
private boolean sample ( ) { Sampler [ ] samplers = cur Samplers ; for ( Sampler sampler : samplers ) { if ( sampler . next ( ) ) { return true ; } } return false ; }
public static Set < String > search ( SSO Token token , String dn , String filter , int num Of Entries , int time Limit , boolean sort Results , boolean ascending Order ) throws SMS Exception { try { return sms Object . search ( token , dn , filter , num Of Entries , time Limit , sort Results , ascending Order ) ; } catch ( SSO Exception ssoe ) { debug . error ( STR_ + filter , ssoe ) ; throw new SMS Exception ( bundle . get String ( STR_ ) , ssoe , STR_ ) ; } }
public String remainder ( ) { final String remainder = queue . substring ( pos , queue . length ( ) ) ; pos = queue . length ( ) ; return remainder ; }
private String clean Selector String ( String selector ) { Search Buffer sb = Search Buffer . obtain Search Buffer ( ) ; String Buffer buff = sb . get String Buffer ( ) ; boolean last Was Space = true ; int last Index = NUM_ ; char [ ] chars = selector . to Char Array ( ) ; int num Chars = chars . length ; String ret Value = null ; try { for ( int counter = NUM_ ; counter < num Chars ; counter ++ ) { switch ( chars [ counter ] ) { case STR_ : if ( ! last Was Space ) { last Was Space = true ; if ( last Index < counter ) { buff . append ( chars , last Index , NUM_ + counter - last Index ) ; } } last Index = counter + NUM_ ; break ; case STR_ : case STR_ : case STR_ : if ( ! last Was Space ) { last Was Space = true ; if ( last Index < counter ) { buff . append ( chars , last Index , counter - last Index ) ; buff . append ( STR_ ) ; } } last Index = counter + NUM_ ; break ; default : last Was Space = false ; break ; } } if ( last Was Space && buff . length ( ) > NUM_ ) { buff . set Length ( buff . length ( ) - NUM_ ) ; } else if ( last Index < num Chars ) { buff . append ( chars , last Index , num Chars - last Index ) ; } ret Value = buff . to String ( ) ; } finally { Search Buffer . release Search Buffer ( sb ) ; } return ret Value ; }
public List < Local Date > top ( int n ) { List < Local Date > top = new Array List < > ( ) ; int [ ] values = data . to Int Array ( ) ; Int Arrays . parallel Quick Sort ( values , Reverse Int Comparator . instance ( ) ) ; for ( int i = NUM_ ; i < n && i < values . length ; i ++ ) { top . add ( Packed Local Date . as Local Date ( values [ i ] ) ) ; } return top ; }
public long next ( long start Time , long from Time , long current Count ) { if ( start Time == NUM_ ) start Time = Recurrence Util . now ( ) ; if ( from Time == NUM_ ) from Time = start Time ; if ( get End Time ( ) != NUM_ && get End Time ( ) <= Recurrence Util . now ( ) ) return NUM_ ; Debug . log Verbose ( STR_ , module ) ; if ( get Count ( ) != - NUM_ && current Count >= get Count ( ) ) return NUM_ ; Debug . log Verbose ( STR_ , module ) ; boolean is Seeking = true ; long next Runtime = NUM_ ; long seek Time = from Time ; int loop Protection = NUM_ ; int max Loop = ( NUM_ * NUM_ * NUM_ * NUM_ * NUM_ ) ; while ( is Seeking && loop Protection < max Loop ) { Date next Run = get Next Freq ( start Time , seek Time ) ; seek Time = next Run . get Time ( ) ; if ( valid By Rule ( next Run ) ) { is Seeking = false ; next Runtime = next Run . get Time ( ) ; } loop Protection ++ ; } return next Runtime ; }
public static void on Restore State ( Bundle bundle , Activity activity ) { if ( bundle == null ) { return ; } Parcelable [ ] saved Array = bundle . get Parcelable Array ( BUNDLE TAG ) ; int i = NUM_ ; if ( saved Array != null ) { for ( Parcelable parcelable : saved Array ) { i ++ ; new Super Card Toast ( activity , ( Reference Holder ) parcelable , null , i ) ; } } }
public static Number cosh ( Number a ) { return Math . cosh ( a . double Value ( ) ) ; }
public R 1 Interval intersection ( R 1 Interval y ) { return new R 1 Interval ( Math . max ( lo ( ) , y . lo ( ) ) , Math . min ( hi ( ) , y . hi ( ) ) ) ; }
public static String left ( String str , int count ) { if ( str == null ) { return null ; } if ( str . length ( ) < count ) { return str ; } return str . substring ( NUM_ , count ) ; }
public static boolean verify Dex File Md 5 ( File file , String md 5 ) { if ( file == null || md 5 == null ) { return false ; } String file Md 5 ; if ( is Raw Dex File ( file . get Name ( ) ) ) { file Md 5 = get MD 5 ( file ) ; } else { Zip File dex Jar = null ; try { dex Jar = new Zip File ( file ) ; Zip Entry classes Dex = dex Jar . get Entry ( Share Constants . DEX IN JAR ) ; if ( null == classes Dex ) { return false ; } file Md 5 = get MD 5 ( dex Jar . get Input Stream ( classes Dex ) ) ; } catch ( IO Exception e ) { return false ; } finally { Share Patch File Util . close Zip ( dex Jar ) ; } } return md 5 . equals ( file Md 5 ) ; }
public int add Indx CV ( String cv Name , String pi Cv , int pi Val , String si Cv , int si Val , String i Cv , boolean read Only , boolean info Only , boolean write Only ) { int existing Row = get Cv By Name ( cv Name ) ; int row ; if ( existing Row == - NUM_ ) { row = num Rows ++ ; Cv Value indx Cv = new Cv Value ( cv Name , cv Name , pi Cv , pi Val , si Cv , si Val , i Cv , m Programmer ) ; indx Cv All Map . put ( cv Name , indx Cv ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + cv Name ) ; } indx Cv . set Read Only ( read Only ) ; indx Cv . set Info Only ( info Only ) ; indx Cv All Vector . set Element At ( indx Cv , row ) ; indx Cv Display Vector . add Element ( indx Cv ) ; indx Cv . add Property Change Listener ( this ) ; J Button bw = new J Button ( STR_ ) ; indx Write Buttons . add Element ( bw ) ; J Button br = new J Button ( STR_ ) ; indx Read Buttons . add Element ( br ) ; J Button bc = new J Button ( STR_ ) ; indx Compare Buttons . add Element ( bc ) ; if ( info Only || read Only ) { if ( write Only ) { bw . set Enabled ( true ) ; bw . set Action Command ( STR_ + row ) ; bw . add Action Listener ( this ) ; } else { bw . set Enabled ( false ) ; } if ( info Only ) { br . set Enabled ( false ) ; bc . set Enabled ( false ) ; } else { br . set Enabled ( true ) ; br . set Action Command ( STR_ + row ) ; br . add Action Listener ( this ) ; bc . set Enabled ( true ) ; bc . set Action Command ( STR_ + row ) ; bc . add Action Listener ( this ) ; } } else { bw . set Enabled ( true ) ; bw . set Action Command ( STR_ + row ) ; bw . add Action Listener ( this ) ; if ( write Only ) { br . set Enabled ( false ) ; bc . set Enabled ( false ) ; } else { br . set Enabled ( true ) ; br . set Action Command ( STR_ + row ) ; br . add Action Listener ( this ) ; bc . set Enabled ( true ) ; bc . set Action Command ( STR_ + row ) ; bc . add Action Listener ( this ) ; } } if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + row ) ; } fire Table Data Changed ( ) ; } else { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + existing Row + STR_ + num Rows ) ; } row = existing Row ; } if ( row > - NUM_ && row < indx Cv All Vector . size ( ) ) { Cv Value indxcv = indx Cv All Vector . element At ( row ) ; if ( read Only ) { indxcv . set Read Only ( read Only ) ; } if ( info Only ) { indxcv . set Read Only ( info Only ) ; indxcv . set Info Only ( info Only ) ; } if ( write Only ) { indxcv . set Write Only ( write Only ) ; } } return row ; }
private Automaton transpositions Of ( String s ) { if ( s . length ( ) < NUM_ ) { return Automata . make Empty ( ) ; } List < Automaton > list = new Array List < > ( ) ; for ( int i = NUM_ ; i < s . length ( ) - NUM_ ; i ++ ) { String Builder sb = new String Builder ( ) ; sb . append ( s . substring ( NUM_ , i ) ) ; sb . append ( s . char At ( i + NUM_ ) ) ; sb . append ( s . char At ( i ) ) ; sb . append ( s . substring ( i + NUM_ , s . length ( ) ) ) ; String st = sb . to String ( ) ; if ( ! st . equals ( s ) ) { list . add ( Automata . make String ( st ) ) ; } } Automaton a = Operations . union ( list ) ; a = Minimization Operations . minimize ( a , DEFAULT MAX DETERMINIZED STATES ) ; return a ; }
public static Map < Unit , Unit > map Transports To Load ( final Collection < Unit > units , final Collection < Unit > transports ) { final List < Unit > can Be Transported = sort By Transport Cost Descending ( units ) ; final List < Unit > can Transport = sort By Transport Capacity Descending Then Moves Descending ( transports ) ; final Map < Unit , Unit > mapping = new Hash Map < > ( ) ; final Integer Map < Unit > added Load = new Integer Map < > ( ) ; for ( final Unit unit : can Be Transported ) { final Optional < Unit > transport = load Unit Into First Available Transport ( unit , can Transport , mapping , added Load ) ; if ( transport . is Present ( ) ) { can Transport . remove ( transport . get ( ) ) ; can Transport . add ( transport . get ( ) ) ; } } return mapping ; }
public static double sqrt ( double x ) { return Math . sqrt ( x ) ; }
public static Optional < Notification > try Find ( @ Nonnull final Iterable < Notification > notifications , final long id ) { final com . google . common . base . Optional < Notification > result = Iterables . try Find ( notifications , null ) ; if ( result . is Present ( ) ) { return Optional . of ( result . get ( ) ) ; } return Optional . empty ( ) ; }
private boolean is CCCD ( final Bluetooth Gatt Descriptor descriptor ) { if ( descriptor == null ) return false ; return CLIENT CHARACTERISTIC CONFIG DESCRIPTOR UUID . equals ( descriptor . get Uuid ( ) ) ; }
@ Override public Enumeration < String > enumerate Requests ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; if ( m evaluate Thread != null ) { new Vector . add Element ( STR_ ) ; } return new Vector . elements ( ) ; }
private int dimension ( Geometry geom ) { if ( output Dimension != Ora Geom . NULL DIMENSION ) return output Dimension ; int d = Double . is Na N ( geom . get Coordinate ( ) . z ) ? NUM_ : NUM_ ; return d ; }
public String print Stack ( ) { String Builder result = new String Builder ( ) ; result . append ( STR_ ) ; Lirs Entry e = stack Top ( ) ; if ( e != null ) { result . append ( e ) ; for ( e = e . next In Stack ; e != header ; e = e . next In Stack ) { result . append ( STR_ + e ) ; } } result . append ( STR_ ) ; return result . to String ( ) ; }
protected final boolean has Option ( String opt Name ) { return options . contains ( opt Name ) ; }
@ Suppress Warnings ( { STR_ } ) private final void assert Not Released ( ) { if ( ! is Active ( ) ) { if ( LOGGER . is Loggable ( Level . SEVERE ) ) { LOGGER . log ( Level . SEVERE , STR_ ) ; } throw new Context Not Active Exception ( ) ; } }
boolean is Supported Platform ( String plugin ) { return ! unsupported Platform . contains ( plugin ) ; }
@ Override public double predict Quantile ( double percentage ) { update Boundaries And Or Weights ( ) ; double val = Statistics . normal Inverse ( NUM_ - ( NUM_ - NUM_ ) / NUM_ ) ; double min = m TM . first Key ( ) - val * m Width ; double max = m TM . last Key ( ) + val * m Width ; double delta = ( max - min ) / m Num Intervals ; double sum = NUM_ ; double left Val = Math . exp ( log Density ( min ) ) ; for ( int i = NUM_ ; i < m Num Intervals ; i ++ ) { if ( sum >= percentage ) { return min + i * delta ; } double right Val = Math . exp ( log Density ( min + ( i + NUM_ ) * delta ) ) ; sum += NUM_ * ( left Val + right Val ) * delta ; left Val = right Val ; } return max ; }
private boolean is Relevant ( Constraint < ? > constraint , Set < Variable Reference > targets ) { Set < Variable < ? > > variables = constraint . get Variables ( ) ; Set < String > target Names = new Hash Set < String > ( ) ; for ( Variable Reference v : targets ) { target Names . add ( v . get Name ( ) ) ; } for ( Variable < ? > var : variables ) { if ( target Names . contains ( var . get Name ( ) ) ) return true ; } return false ; }
public static Number acos ( Number a ) { return Math . acos ( a . double Value ( ) ) ; }
public void request Password Reset State ( ) { operations . add ( Password Policy State Operation Type . GET PASSWORD RESET STATE ) ; }
@ Override public String secure Protocol ( ) { SSL Socket ssl Socket = ssl Socket ; if ( ssl Socket == null ) { return super . secure Protocol ( ) ; } SSL Session ssl Session = ssl Socket . get Session ( ) ; if ( ssl Session != null ) { return ssl Session . get Protocol ( ) ; } else { return null ; } }
public boolean is Double Buffered ( ) { return false ; }
public static final String extract Ipl Identity Slave Frimware Rev ( Loco Net Message m ) { String Builder s = new String Builder ( ) ; s . append ( Integer . to String ( ( m . get Element ( NUM_ ) & NUM_ ) > > NUM_ ) + ( ( m . get Element ( NUM_ ) & NUM_ ) << NUM_ ) ) ; s . append ( STR_ ) ; s . append ( Integer . to String ( ( m . get Element ( NUM_ ) & NUM_ ) ) ) ; return s . to String ( ) ; }
public final void sample ( ) { synchronized ( lock ) { long count = total Count . get ( ) ; long last Count = last Avg Total Count ; last Avg Total Count = count ; long sum = sum . get ( ) ; double last Sum = last Avg Sum ; last Avg Sum = sum ; if ( count == last Count ) { avg = NUM_ ; } else { avg = scale * ( sum - last Sum ) / ( double ) ( count - last Count ) ; } } }
private static long now ( ) { return System . nano Time ( ) - NANO ORIGIN ; }
public final static boolean is Class File Name ( String name ) { int name Length = name == null ? NUM_ : name . length ( ) ; int suffix Length = SUFFIX CLASS . length ; if ( name Length < suffix Length ) return false ; for ( int i = NUM_ ; i < suffix Length ; i ++ ) { char c = name . char At ( name Length - i - NUM_ ) ; int suffix Index = suffix Length - i - NUM_ ; if ( c != SUFFIX class [ suffix Index ] && c != SUFFIX CLASS [ suffix Index ] ) return false ; } return true ; }
public boolean is Infinite ( ) { return is Infinite ( value ) ; }
public static String map Site To Server ( Session ID sid ) throws URL Not Found Exception { URL map Session Service Url = map Site To Server ( sid . get Session Server Protocol ( ) , sid . get Session Server ( ) , sid . get Session Server Port ( ) , sid . get Session Server URI ( ) ) ; if ( map Session Service Url == null ) { return sid . get Session Server URL ( ) ; } return map Session Service Url . to String ( ) ; }
public Char Sequence format ( Formatter formatter ) { Char Sequence input = format ( ) ; return formatter . format ( String . value Of ( input ) ) ; }
public int num Attributes ( ) { return m Attributes . size ( ) ; }
public final int count Data Authorities ( ) { return m Data Authorities != null ? m Data Authorities . size ( ) : NUM_ ; }
public final char char At ( int index ) { if ( index < NUM_ || index >= remaining ( ) ) { throw new Index Out Of Bounds Exception ( STR_ + index + STR_ + remaining ( ) ) ; } return get ( position + index ) ; }
public List < AVA > avas ( ) { List < AVA > list = ava List ; if ( list == null ) { list = Collections . unmodifiable List ( Arrays . as List ( assertion ) ) ; ava List = list ; } return list ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new Option ( STR_ + default Num Attributes ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Num Classes ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add ( new Option ( STR_ + default Num Centroids ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public Collection < Segment > segments ( ) { return segments . values ( ) ; }
public boolean has Output Node ( Set < String > variables ) { for ( String output Node : get Output Nodes Ids ( ) ) { if ( variables . contains ( output Node ) ) { return true ; } } return false ; }
private Automaton deletions Of ( String s ) { List < Automaton > list = new Array List < > ( ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { Automaton a = Automata . make String ( s . substring ( NUM_ , i ) ) ; a = Operations . concatenate ( a , Automata . make String ( s . substring ( i + NUM_ ) ) ) ; list . add ( a ) ; } Automaton a = Operations . union ( list ) ; a = Minimization Operations . minimize ( a , DEFAULT MAX DETERMINIZED STATES ) ; return a ; }
public Enumeration < Option > list Options ( ) { Vector < Option > opt Vector = new Vector < Option > ( NUM_ ) ; opt Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; opt Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; opt Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; opt Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return opt Vector . elements ( ) ; }
public int size ( ) { return shards . size ( ) ; }
public boolean is Inside ( Entity entity ) { for ( Axis Aligned BB bounding Box : this . bounding Boxes ) { if ( bounding Box . is Vec Inside ( entity . get Position Vector ( ) ) ) { return true ; } } return false ; }
public boolean verify Signature ( byte [ ] signature ) { content Digest . do Final ( m Dash , m Dash . length - h Len - s Len ) ; try { byte [ ] b = cipher . process Block ( signature , NUM_ , signature . length ) ; System . arraycopy ( b , NUM_ , block , block . length - b . length , b . length ) ; } catch ( Exception e ) { return false ; } if ( block [ block . length - NUM_ ] != trailer ) { clear Block ( block ) ; return false ; } byte [ ] db Mask = mask Generator Function 1 ( block , block . length - h Len - NUM_ , h Len , block . length - h Len - NUM_ ) ; for ( int i = NUM_ ; i != db Mask . length ; i ++ ) { block [ i ] ^= db Mask [ i ] ; } block [ NUM_ ] &= ( NUM_ > > ( ( block . length * NUM_ ) - em Bits ) ) ; for ( int i = NUM_ ; i != block . length - h Len - s Len - NUM_ ; i ++ ) { if ( block [ i ] != NUM_ ) { clear Block ( block ) ; return false ; } } if ( block [ block . length - h Len - s Len - NUM_ ] != NUM_ ) { clear Block ( block ) ; return false ; } System . arraycopy ( block , block . length - s Len - h Len - NUM_ , m Dash , m Dash . length - s Len , s Len ) ; content Digest . update ( m Dash , NUM_ , m Dash . length ) ; content Digest . do Final ( m Dash , m Dash . length - h Len ) ; for ( int i = block . length - h Len - NUM_ , j = m Dash . length - h Len ; j != m Dash . length ; i ++ , j ++ ) { if ( ( block [ i ] ^ m Dash [ j ] ) != NUM_ ) { clear Block ( m Dash ) ; clear Block ( block ) ; return false ; } } clear Block ( m Dash ) ; clear Block ( block ) ; return true ; }
public boolean has More Elements ( Instances structure ) { boolean result ; result = false ; if ( is Incremental ( ) ) { if ( m Incremental Buffer != null ) { result = true ; } else { try { m Incremental Buffer = m Loader . get Next Instance ( structure ) ; result = ( m Incremental Buffer != null ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; result = false ; } } } else { result = ( m Batch Counter < m Batch Buffer . num Instances ( ) ) ; } return result ; }
public String combination Rule Tip Text ( ) { return STR_ ; }
private static List < Block Node > clean Successors ( Block Node block ) { List < Block Node > suc List = block . get Successors ( ) ; if ( suc List . is Empty ( ) ) { return suc List ; } List < Block Node > to Remove = new Linked List < Block Node > ( ) ; for ( Block Node b : suc List ) { if ( Block Utils . is Block Must Be Cleared ( b ) ) { to Remove . add ( b ) ; } } if ( block . contains ( A Flag . LOOP END ) ) { List < Loop Info > loops = block . get All ( A Type . LOOP ) ; for ( Loop Info loop : loops ) { to Remove . add ( loop . get Start ( ) ) ; } } Ignore Edge Attr ignore Edge Attr = block . get ( A Type . IGNORE EDGE ) ; if ( ignore Edge Attr != null ) { to Remove . add All ( ignore Edge Attr . get Blocks ( ) ) ; } if ( to Remove . is Empty ( ) ) { return suc List ; } List < Block Node > result = new Array List < Block Node > ( suc List ) ; result . remove All ( to Remove ) ; return result ; }
public static Optional < String > read Token ( File dir , String name ) throws IO Exception { File token = new File ( dir , name ) ; if ( ! token . is File ( ) ) { return Optional . empty ( ) ; } else { return Optional . of ( File Utils . read File To String ( token , Standard Charsets . UTF 8 ) ) ; } }
public Enumeration < Permission > elements ( ) { synchronized ( this ) { return Collections . enumeration ( perms . values ( ) ) ; } }
private String convert Line Separators ( String string ) { return string . replace All ( System . line Separator ( ) , STR_ ) ; }
public < T > List < T > list Items ( Section Key < T , List Section < T > > key ) { List < T > result = Lists . new Array List ( ) ; for ( List Section < T > section : get Sections ( key ) ) { result . add All ( section . items ( ) ) ; } return result ; }
@ Override public Calendar next ( ) { if ( spot . equals ( end Final ) ) { throw new No Such Element Exception ( ) ; } spot . add ( Calendar . DATE , NUM_ ) ; return ( Calendar ) spot . clone ( ) ; }
public static void errms ( Stream Tokenizer tokenizer , String the Msg ) throws IO Exception { throw new IO Exception ( the Msg + STR_ + tokenizer . to String ( ) ) ; }
public Meta Data Info has Special ( String role ) { if ( attribute Meta Data == null ) { return Meta Data Info . UNKNOWN ; } if ( role . equals ( Attributes . CONFIDENCE NAME ) ) { for ( Attribute Meta Data amd : attribute Meta Data . values ( ) ) { String current Role = amd . get Role ( ) ; if ( current Role != null && current Role . starts With ( role ) ) { return Meta Data Info . YES ; } } } else { for ( Attribute Meta Data amd : attribute Meta Data . values ( ) ) { if ( role . equals ( amd . get Role ( ) ) ) { return Meta Data Info . YES ; } } } switch ( attributes Relation ) { case SUBSET : return Meta Data Info . UNKNOWN ; case SUPERSET : case EQUAL : return Meta Data Info . NO ; default : return Meta Data Info . UNKNOWN ; } }
public Virtual File resolve ( String relative Str ) { File relative File = null ; if ( File Utils . is Directory ( f ) ) { relative File = File Util . open File ( f , relative Str ) ; } else if ( File Utils . is File ( f ) ) { relative File = File Util . open File ( f . get Parent File ( ) , relative Str ) ; } Virtual File result = null ; if ( relative File != null && File Utils . exists ( relative File ) ) { result = new Local File ( relative File ) ; } if ( ( result != null ) && Trace . path Resolver ) { Trace . trace ( STR_ + relative Str + STR_ + result . get Name ( ) ) ; } return result ; }
public byte [ ] encode ( ) { char type = get Attribute Type ( ) ; byte bin Value [ ] = new byte [ HEADER LENGTH + attribute Value . length ] ; bin Value [ NUM_ ] = ( byte ) ( type > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( type & NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) & NUM_ ) ; System . arraycopy ( attribute Value , NUM_ , bin Value , HEADER LENGTH , attribute Value . length ) ; return bin Value ; }
public String to Generalized Time String ( ) { Calendar calendar = Calendar . get Instance ( Time Zone . get Time Zone ( STR_ ) ) ; calendar . clear ( ) ; calendar . set Time In Millis ( kerberos Time ) ; return String . format ( STR_ , calendar . get ( Calendar . YEAR ) , calendar . get ( Calendar . MONTH ) + NUM_ , calendar . get ( Calendar . DAY OF MONTH ) , calendar . get ( Calendar . HOUR OF DAY ) , calendar . get ( Calendar . MINUTE ) , calendar . get ( Calendar . SECOND ) ) ; }
public static Map new Context ( Index Searcher searcher ) { Map context = new Identity Hash Map ( ) ; context . put ( STR_ , searcher ) ; return context ; }
private List < Co S > fetch Details Of All Block Cos ( ) throws SOS Failure { final String method Name = STR_ ; log . trace ( method Name + STR_ ) ; final String BLOCK COS DETAIL URI = STR_ ; List < Co S > block Cos Id List = new Array List < Co S > ( ) ; try { for ( String cos Id : block Cos Id List ) { Co S . Block Co S cos = client . query Object ( String . format ( BLOCK COS DETAIL URI , cos Id ) , Co S . Block Co S . class ) ; if ( cos . is Inactive ( ) == false && cos . get Id ( ) != null ) { block Cos Id List . add ( cos ) ; log . trace ( method Name + cos ) ; } } log . trace ( method Name + STR_ + block Cos Id List . size ( ) + STR_ ) ; return block Cos Id List ; } catch ( No Such Algorithm Exception e ) { log . error ( method Name + STR_ , e ) ; throw new SOS Failure ( e ) ; } catch ( Uniform Interface Exception e ) { log . error ( method Name + STR_ , e ) ; throw new SOS Failure ( e ) ; } }
public int length ( ) { return steps . size ( ) ; }
public String to Simple String ( ) { String Builder buffer = new String Builder ( ) ; buffer . append ( STR_ + ( get Label ( ) == null ? STR_ : get Label ( ) ) + STR_ + m Y Vals . size ( ) + STR_ ) ; return buffer . to String ( ) ; }
public String num Folds Tip Text ( ) { return STR_ ; }
public static boolean valid System Name Config ( String system Name , char type , Serial Traffic Controller tc ) { if ( ! valid System Name Format ( system Name , type ) ) { return false ; } Serial Node node = ( Serial Node ) get Node From System Name ( system Name , tc ) ; if ( node == null ) { return false ; } int bit = get Bit From System Name ( system Name ) ; if ( ( type == STR_ ) || ( type == STR_ ) ) { if ( ( bit <= NUM_ ) || ( bit > ( node . num Output Cards ( ) * node . get Num Bits Per Card ( ) ) ) ) { return false ; } } else if ( type == STR_ ) { if ( ( bit <= NUM_ ) || ( bit > ( node . num Input Cards ( ) * node . get Num Bits Per Card ( ) ) ) ) { return false ; } } else { log . error ( STR_ ) ; return false ; } return true ; }
private boolean is Done ( ) { return last Comment Index >= comments . size ( ) ; }
protected Rectangle Constraint to Content Constraint ( Rectangle Constraint c ) { Param Checks . null Not Permitted ( c , STR_ ) ; if ( c . equals ( Rectangle Constraint . NONE ) ) { return c ; } double w = c . get Width ( ) ; Range wr = c . get Width Range ( ) ; double h = c . get Height ( ) ; Range hr = c . get Height Range ( ) ; double ww = trim To Content Width ( w ) ; double hh = trim To Content Height ( h ) ; Range wwr = trim To Content Width ( wr ) ; Range hhr = trim To Content Height ( hr ) ; return new Rectangle Constraint ( ww , wwr , c . get Width Constraint Type ( ) , hh , hhr , c . get Height Constraint Type ( ) ) ; }
public static Groovy Row Result to Row Result ( Result Set rs ) throws SQL Exception { Result Set Meta Data metadata = rs . get Meta Data ( ) ; Map < String , Object > lhm = new Linked Hash Map < String , Object > ( metadata . get Column Count ( ) , NUM_ ) ; for ( int i = NUM_ ; i <= metadata . get Column Count ( ) ; i ++ ) { lhm . put ( metadata . get Column Label ( i ) , rs . get Object ( i ) ) ; } return new Groovy Row Result ( lhm ) ; }
private static int array Index ( int i ) { return ( i > > SHIFT PER WORD ) ; }
private static int non Empty Lists ( List < ? > ... lists ) { int non Empty = NUM_ ; for ( List < ? > list : lists ) { if ( list != null && list . size ( ) > NUM_ ) { ++ non Empty ; } } return non Empty ; }
static double lg ( double x ) { return ( Math . log ( x ) / Math . log ( NUM_ ) ) ; }
boolean is Connected ( ) { if ( f Connected == null ) return false ; return ! f Connected . is Empty ( ) ; }
public static double ln Gamma ( double x ) { double p , q , w , z ; double A [ ] = { NUM_ , - NUM_ , NUM_ , - NUM_ , NUM_ } ; double B [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; double C [ ] = { - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ , - NUM_ } ; if ( x < - NUM_ ) { q = - x ; w = ln Gamma ( q ) ; p = Math . floor ( q ) ; if ( p == q ) { throw new Arithmetic Exception ( STR_ ) ; } z = q - p ; if ( z > NUM_ ) { p += NUM_ ; z = p - q ; } z = q * Math . sin ( Math . PI * z ) ; if ( z == NUM_ ) { throw new Arithmetic Exception ( STR_ ) ; } z = LOGPI - Math . log ( z ) - w ; return z ; } if ( x < NUM_ ) { z = NUM_ ; while ( x >= NUM_ ) { x -= NUM_ ; z *= x ; } while ( x < NUM_ ) { if ( x == NUM_ ) { throw new Arithmetic Exception ( STR_ ) ; } z /= x ; x += NUM_ ; } if ( z < NUM_ ) { z = - z ; } if ( x == NUM_ ) { return Math . log ( z ) ; } x -= NUM_ ; p = x * polevl ( x , B , NUM_ ) / p 1 evl ( x , C , NUM_ ) ; return ( Math . log ( z ) + p ) ; } if ( x > NUM_ ) { throw new Arithmetic Exception ( STR_ ) ; } q = ( x - NUM_ ) * Math . log ( x ) - x + NUM_ ; if ( x > NUM_ ) { return ( q ) ; } p = NUM_ / ( x * x ) ; if ( x >= NUM_ ) { q += ( ( NUM_ * p - NUM_ ) * p + NUM_ ) / x ; } else { q += polevl ( p , A , NUM_ ) / x ; } return q ; }
private static byte [ ] to Byte Array ( Big Integer bi , int len ) { byte [ ] b = bi . to Byte Array ( ) ; int n = b . length ; if ( n == len ) { return b ; } if ( ( n == len + NUM_ ) && ( b [ NUM_ ] == NUM_ ) ) { byte [ ] t = new byte [ len ] ; System . arraycopy ( b , NUM_ , t , NUM_ , len ) ; return t ; } assert ( n < len ) ; byte [ ] t = new byte [ len ] ; System . arraycopy ( b , NUM_ , t , ( len - n ) , n ) ; return t ; }
public static String penn String 2 Words ( String penn ) { return tree 2 Words ( penn String 2 Tree ( penn ) ) ; }
public Activity current Activity ( ) { if ( m Activity Stack == null ) return null ; return m Activity Stack . last Element ( ) ; }
private int start Of Week Offset ( int day , int dow ) { int week Start = Math . floor Mod ( day - dow , NUM_ ) ; int offset = - week Start ; if ( week Start + NUM_ > week Def . get Minimal Days In First Week ( ) ) { offset = NUM_ - week Start ; } return offset ; }
@ Override public int size ( ) { return total Number Of Records ; }
public static boolean is Defined NS Decl ( Serialization Handler serializer , int attr , DTM dtm ) { if ( DTM . NAMESPACE NODE == dtm . get Node Type ( attr ) ) { String prefix = dtm . get Node Name X ( attr ) ; String uri = serializer . get Namespace URI From Prefix ( prefix ) ; if ( ( null != uri ) && uri . equals ( dtm . get String Value ( attr ) ) ) return true ; } return false ; }
public static String sanitize App Identifier ( String app Identifier ) throws Illegal Argument Exception { if ( app Identifier == null ) { throw new Illegal Argument Exception ( STR_ ) ; } String s App Identifier = app Identifier . trim ( ) ; if ( s App Identifier . length ( ) != APP IDENTIFIER LENGTH ) { throw new Illegal Argument Exception ( STR_ + APP IDENTIFIER LENGTH + STR_ ) ; } return s App Identifier ; }
public boolean is Closed ( ) throws SQL Exception { return this . is Closed ; }
private String entry Annotation String ( Local List . Entry e ) { String Builder sb = new String Builder ( ) ; sb . append ( Register Spec . PREFIX ) ; sb . append ( e . get Register ( ) ) ; sb . append ( STR_ ) ; Cst String name = e . get Name ( ) ; if ( name == null ) { sb . append ( STR_ ) ; } else { sb . append ( name . to Human ( ) ) ; } sb . append ( STR_ ) ; Cst Type type = e . get Type ( ) ; if ( type == null ) { sb . append ( STR_ ) ; } else { sb . append ( type . to Human ( ) ) ; } Cst String signature = e . get Signature ( ) ; if ( signature != null ) { sb . append ( STR_ ) ; sb . append ( signature . to Human ( ) ) ; } return sb . to String ( ) ; }
@ Override public int hash Code ( ) { int result = NUM_ ; result = Hash Utilities . hash Code ( result , this . anchor ) ; result = Hash Utilities . hash Code ( result , this . coordinate Type ) ; result = Hash Utilities . hash Code ( result , this . x ) ; result = Hash Utilities . hash Code ( result , this . y ) ; result = Hash Utilities . hash Code ( result , this . max Width ) ; result = Hash Utilities . hash Code ( result , this . max Height ) ; result = Hash Utilities . hash Code ( result , this . title ) ; return result ; }
@ Override public boolean equals ( Object o ) { if ( o instanceof Graph . Node ) { Graph < ? , ? > . Node n = ( Graph < ? , ? > . Node ) o ; return content . equals ( n . content ) && children . equals ( n . children ) && attributes . equals ( n . attributes ) ; } return false ; }
public static Number find Minimum Stacked Range Value ( Category Dataset dataset ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; Number result = null ; boolean has Valid Data = false ; double minimum = NUM_ ; int category Count = dataset . get Column Count ( ) ; for ( int item = NUM_ ; item < category Count ; item ++ ) { double total = NUM_ ; int series Count = dataset . get Row Count ( ) ; for ( int series = NUM_ ; series < series Count ; series ++ ) { Number number = dataset . get Value ( series , item ) ; if ( number != null ) { has Valid Data = true ; double value = number . double Value ( ) ; if ( value < NUM_ ) { total = total + value ; } } } minimum = Math . min ( minimum , total ) ; } if ( has Valid Data ) { result = new Double ( minimum ) ; } return result ; }
protected static final int network Byte Order To Int ( byte [ ] buf , int start , int count ) { if ( count > NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } int answer = NUM_ ; for ( int i = NUM_ ; i < count ; i ++ ) { answer <<= NUM_ ; answer |= ( ( int ) buf [ start + i ] & NUM_ ) ; } return answer ; }
Set reduce ( Invocation Constraints constraints ) throws Unsupported Constraint Exception { Set reduced = reduce ( null , constraints . requirements ( ) , true ) ; reduced = reduce ( reduced , constraints . preferences ( ) , false ) ; return ( reduced != null ) ? reduced : Collections . EMPTY SET ; }
public synchronized boolean directory Exists ( ) { return directory . exists ( ) ; }
@ Override public int hash Code ( ) { return structural Class OID . hash Code ( ) ; }
public boolean is Set Timeout ( ) { return isset bit vector . get ( TIMEOUT ISSET ID ) ; }
public static List < Module Spec > expand Spec Wildcards ( List < File > dirs , List < Module Spec > modules , Backend for Backend ) { List < Module Spec > result = new Array List < Module Spec > ( modules . size ( ) ) ; for ( Module Spec spec : modules ) { List < String > names = new Array List < String > ( ) ; expand Wildcard ( names , dirs , spec . get Name ( ) , for Backend ) ; for ( String name : names ) { result . add ( new Module Spec ( name , spec . get Version ( ) ) ) ; } } return result ; }
private static String high Part ( final String text ) { return Media Type . sectors ( text ) [ NUM_ ] ; }
public Period Formatter with Locale ( Locale locale ) { if ( locale == get Locale ( ) || ( locale != null && locale . equals ( get Locale ( ) ) ) ) { return this ; } return new Period Formatter ( i Printer , i Parser , locale , i Parse Type ) ; }
public static List < String > extract Urls ( String text ) { String lines [ ] = text . split ( STR_ ) ; List < String > contained Urls = new Array List < String > ( ) ; String url Regex = STR_ ; Pattern pattern = Pattern . compile ( url Regex , Pattern . CASE INSENSITIVE ) ; for ( String line : lines ) { Matcher url Matcher = pattern . matcher ( line ) ; while ( url Matcher . find ( ) ) { contained Urls . add ( line . substring ( url Matcher . start ( NUM_ ) , url Matcher . end ( NUM_ ) ) ) ; } } return contained Urls ; }
public static int binary Search Floor ( long [ ] a , long key , boolean inclusive , boolean stay In Bounds ) { int index = Arrays . binary Search ( a , key ) ; index = index < NUM_ ? - ( index + NUM_ ) : ( inclusive ? index : ( index - NUM_ ) ) ; return stay In Bounds ? Math . max ( NUM_ , index ) : index ; }
public static boolean is Volume VMFS Datastore ( Block Object Rest Rep block Object ) { if ( block Object != null ) { Set < String > volume Tags = block Object . get Tags ( ) ; if ( volume Tags != null ) { Map < String , String > parsed Tags = Machine Tag Utils . parse Machine Tags ( volume Tags ) ; for ( String tag : parsed Tags . key Set ( ) ) { if ( tag != null && tag . starts With ( Known Machine Tags . get Vmfs Datastore Tag Name ( ) ) ) { return true ; } } } } return false ; }
public Object clone ( ) throws Clone Not Supported Exception { Node List cloned List = ( Node List ) super . clone ( ) ; cloned List . clone Nodes ( ) ; return cloned List ; }
private void throw Close Connection ( ) throws Closed Channel Exception { Closed Channel Exception close Ex = new Closed Channel Exception ( ) ; close Ex . init Cause ( new IO Exception ( STR_ ) ) ; throw close Ex ; }
private static Map < String , String > parse Env List ( List < String > list ) { Map < String , String > map = new Hash Map < > ( ) ; if ( ( list == null ) || ( list . is Empty ( ) ) ) { return map ; } for ( String val : list ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + val ) ; } if ( ( val == null ) || ( val . length ( ) == NUM_ ) ) { continue ; } int pos = val . index Of ( STR_ ) ; if ( pos == - NUM_ ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STR_ + val + STR_ ) ; } } else { map . put ( val . substring ( NUM_ , pos ) , val . substring ( pos + NUM_ ) ) ; } } return map ; }
public int hash Code ( XML Grammar Description desc ) { if ( desc instanceof XML Schema Description ) { final XML Schema Description sd = ( XML Schema Description ) desc ; final String target Namespace = sd . get Target Namespace ( ) ; final String expanded System Id = sd . get Expanded System Id ( ) ; int hash = ( target Namespace != null ) ? target Namespace . hash Code ( ) : NUM_ ; hash ^= ( expanded System Id != null ) ? expanded System Id . hash Code ( ) : NUM_ ; return hash ; } return desc . hash Code ( ) ; }
private String uniquify Internal ( String name Prefix , String orig Name ) { String name = orig Name ; int suffix Num = NUM_ ; while ( true ) { String candidate = build Name ( name Prefix , name ) ; if ( used Full Names . add ( candidate ) ) { return candidate ; } name = orig Name + suffix Num ++ ; } }
public boolean approx Equals ( final S 1 Interval y , double max Error ) { if ( is Empty ( ) ) { return y . get Length ( ) <= max Error ; } if ( y . is Empty ( ) ) { return get Length ( ) <= max Error ; } return ( Math . abs ( Math . IEE Eremainder ( y . lo ( ) - lo ( ) , NUM_ * S 2 . M PI ) ) + Math . abs ( Math . IEE Eremainder ( y . hi ( ) - hi ( ) , NUM_ * S 2 . M PI ) ) ) <= max Error ; }
public boolean has Removes ( ) { return ! removed Clusters . is Empty ( ) || ! removed Hosts . is Empty ( ) || ! removed Initiators . is Empty ( ) ; }
public Enumeration < String > enumerate Measures ( ) { if ( m Cross Validate ) { Enumeration < String > enm = m NN Search . enumerate Measures ( ) ; Vector < String > measures = new Vector < String > ( ) ; while ( enm . has More Elements ( ) ) measures . add ( enm . next Element ( ) ) ; measures . add ( STR_ ) ; return measures . elements ( ) ; } else { return m NN Search . enumerate Measures ( ) ; } }
public boolean has Fragment Builder ( ) { return builders . get ( ) != null ; }
public List < Entitlement > evaluate ( String realm , Subject subject , Set < String > resource Names , Map < String , Set < String > > environment ) throws Entitlement Exception { if ( ( resource Names == null ) || resource Names . is Empty ( ) ) { throw new Entitlement Exception ( NUM_ ) ; } List < Entitlement > results = new Array List < Entitlement > ( ) ; for ( String res : resource Names ) { List < Entitlement > r = evaluate ( realm , subject , res , environment , false ) ; if ( ( r != null ) && ! r . is Empty ( ) ) { results . add All ( r ) ; } } return results ; }
public Period normalized ( ) { long total Months = to Total Months ( ) ; long split Years = total Months / NUM_ ; int split Months = ( int ) ( total Months % NUM_ ) ; if ( split Years == years && split Months == months ) { return this ; } return create ( Math . to Int Exact ( split Years ) , split Months , days ) ; }
public boolean is Right To Left ( ) { return bidi Base . is Right To Left ( ) ; }
private boolean status OK ( O Block block ) { if ( engineer != null ) { if ( ( engineer . get Run State ( ) == WAIT FOR CLEAR || engineer . get Run State ( ) == HALT ) ) { log . warn ( STR_ + block . get Display Name ( ) ) ; message = Bundle . get Message ( STR_ , block . get Display Name ( ) ) ; return false ; } engineer . check Halt ( ) ; } return true ; }
public static int week Number ( Timestamp input ) { return week Number ( input , Time Zone . get Default ( ) , Locale . get Default ( ) ) ; }
public static void not Null ( final Object obj , final String name ) { if ( null == obj ) { final String message = String . format ( STR_ , name ) ; throw new Illegal Argument Exception ( message ) ; } }
public Shape create Arrow Down ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . move To ( x , y ) ; path . line To ( x + w / NUM_ , y + h ) ; path . line To ( x + w , y ) ; path . close Path ( ) ; return path ; }
private static boolean should Use Remote UI ( I Launch Configuration configuration ) throws Core Exception { return ! is Use Remote Ui Env Var False ( configuration ) && ! Gwt Launch Configuration Processor Utilities . is Super Dev Mode Code Server ( configuration ) ; }
public static double pchisq ( double x ) { double xh = Math . sqrt ( x ) ; return pnorm ( xh ) - pnorm ( - xh ) ; }
public static Optional < I Region > find Cell Region ( final I Document document , final boolean is Tsv , final int offset ) throws Bad Location Exception { final String prev = offset > NUM_ ? document . get ( offset - NUM_ , NUM_ ) : STR_ ; final String next = offset < document . get Length ( ) ? document . get ( offset , NUM_ ) : STR_ ; if ( is Inside Separator ( prev , next , is Tsv ) ) { return Optional . absent ( ) ; } final int begin Offset = offset - calculate Cell Region Begin ( document , is Tsv , offset ) ; final int end Offset = offset + calculate Cell Region End ( document , is Tsv , offset ) ; return Optional . < I Region > of ( new Region ( begin Offset , end Offset - begin Offset ) ) ; }
public byte [ ] to Byte Array ( ) { byte [ ] copy = new byte [ output Pos ] ; System . arraycopy ( bytes , NUM_ , copy , NUM_ , output Pos ) ; return copy ; }
private Workflow . Method create Meta Volumes Method ( URI system URI , URI pool URI , List < URI > volume UR Is , Virtual Pool Capability Values Wrapper capabilities ) { return new Workflow . Method ( STR_ , system URI , pool URI , volume UR Is , capabilities ) ; }
public static double distance ( double v 1 , double h 1 , double v 2 , double h 2 ) { double dv = v 2 - v 1 ; double dh = h 2 - h 1 ; return Math . sqrt ( ( dv * dv + dh * dh ) / NUM_ ) ; }
public static String quantityplnoun ( final int quantity , final String noun , final String one ) { final String word = plnoun ( quantity , noun ) ; if ( quantity == NUM_ ) { if ( one . equals ( STR_ ) ) { return a noun ( word ) ; } else if ( one . equals ( STR_ ) ) { return A noun ( word ) ; } else if ( one . equals ( STR_ ) ) { return word ; } else { return one + STR_ + word ; } } else { return Integer . to String ( quantity ) + STR_ + plural ( noun ) ; } }
private Instances define Dataset ( Random random ) throws Exception { boolean [ ] att List Irr ; int [ ] att List Num ; Array List < Attribute > attributes = new Array List < Attribute > ( ) ; Attribute attribute ; Array List < String > nominal Values = new Array List < String > ( NUM_ ) ; nominal Values . add ( STR_ ) ; nominal Values . add ( STR_ ) ; Array List < String > class Values = new Array List < String > ( get Num Classes ( ) ) ; Instances dataset ; att List Irr = define Irrelevant ( random ) ; set Att List Irr ( att List Irr ) ; att List Num = define Numeric ( random ) ; for ( int i = NUM_ ; i < get Num Attributes ( ) ; i ++ ) { if ( att List Num [ i ] == Attribute . NUMERIC ) { attribute = new Attribute ( STR_ + i ) ; } else { attribute = new Attribute ( STR_ + i , nominal Values ) ; } attributes . add ( attribute ) ; } for ( int i = NUM_ ; i < get Num Classes ( ) ; i ++ ) { class Values . add ( STR_ + i ) ; } attribute = new Attribute ( STR_ , class Values ) ; attributes . add ( attribute ) ; dataset = new Instances ( get Relation Name To Use ( ) , attributes , get Num Examples Act ( ) ) ; dataset . set Class Index ( get Num Attributes ( ) ) ; Instances format = new Instances ( dataset , NUM_ ) ; set Dataset Format ( format ) ; return dataset ; }
public static String escape ( String raw ) { check Not Null ( raw , STR_ ) ; String escaped = raw ; escaped = escaped . replace All ( UNESCAPED WILDCARD REGEX , WILDCARD ESCAPE ) ; escaped = escape Separators ( escaped ) ; return escaped ; }
public int int Value ( ) { return value ; }
public boolean is Visible ( Data Source source ) { return data Visible . contains ( source ) ; }
public boolean is Empty ( ) { return components . is Empty ( ) ; }
@ Override boolean is Paint Valid ( Sun Graphics 2 D sg 2 d ) { Multiple Gradient Paint paint = ( Multiple Gradient Paint ) sg 2 d . paint ; if ( paint . get Fractions ( ) . length > MULTI MAX FRACTIONS ) { return false ; } OGL Surface Data dst Data = ( OGL Surface Data ) sg 2 d . surface Data ; OGL Graphics Config gc = dst Data . get OGL Graphics Config ( ) ; if ( ! gc . is Cap Present ( CAPS EXT GRAD SHADER ) ) { return false ; } return true ; }
protected String full Message Of ( String message Key , String def Value ) { String key = message Key ; do { if ( messages . contains Key ( key ) ) { return messages . get Property ( key ) ; } int dot = key . index Of ( STR_ ) ; if ( dot < NUM_ ) { return def Value ; } key = key . substring ( dot + NUM_ ) ; } while ( true ) ; }
public int write UTF 8 ( final Char Sequence chars ) { return write UTF 8 ( chars , NUM_ , chars . length ( ) ) ; }
public static List < Action > failure ( ) { return Collections . empty List ( ) ; }
public static boolean is SQL 99 Reserved Keyword ( String identifier ) { if ( identifier == null ) { throw new Null Pointer Exception ( STR_ ) ; } return Arrays . binary Search ( SQL 99 RESERVED , identifier . to Upper Case ( ) ) >= NUM_ ; }
private Key make Key ( final I Binding Set bset ) { final I Constant < ? > [ ] vals = new I Constant < ? > [ key Vars . length ] ; for ( int i = NUM_ ; i < key Vars . length ; i ++ ) { final I Variable < ? > v = key Vars [ i ] ; vals [ i ] = bset . get ( v ) ; } int h = ONE ; for ( int i = NUM_ ; i < key Vars . length ; i ++ ) { final I Variable < ? > v = key Vars [ i ] ; final I Constant < ? > c = vals [ i ] ; if ( c == null ) { if ( ! index Solutions Having Unbound Join Vars ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + v + STR_ + bset ) ; return null ; } continue ; } h = NUM_ * h + c . hash Code ( ) ; } if ( log . is Trace Enabled ( ) ) log . trace ( STR_ + h + STR_ + Arrays . to String ( key Vars ) + STR_ + bset ) ; return new Key ( h , vals ) ; }
public Shape create Progress Bar Indeterminate Pattern ( int x , int y , int w , int h ) { final double w Half = w / NUM_ ; final double x Offset = NUM_ ; path . reset ( ) ; path . move To ( x Offset , NUM_ ) ; path . line To ( x Offset + w Half , NUM_ ) ; path . curve To ( x Offset + w Half - NUM_ , h / NUM_ - NUM_ , x Offset + w Half + NUM_ , h / NUM_ + NUM_ , x Offset + w Half , h ) ; path . line To ( x Offset , h ) ; path . curve To ( x Offset + NUM_ , h / NUM_ + NUM_ , x Offset - NUM_ , h / NUM_ - NUM_ , x Offset , NUM_ ) ; path . close Path ( ) ; return path ; }
public int hash Code ( ) { return table . hash Code ( ) ; }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ ; }
@ Visible For Testing File Change Set create File Change Set ( ) { List < File > latest = Collections . empty List ( ) ; if ( directory . is Directory ( ) ) { latest = new Array List < > ( as List ( directory . list Files ( json Files ( ) ) ) ) ; } Set < File > added = new Hash Set < > ( ) ; for ( File candidate : new Array List < > ( latest ) ) { if ( ! snapshot . contains Key ( candidate ) ) { added . add ( candidate ) ; latest . remove ( candidate ) ; } } Set < File > removed = new Hash Set < > ( ) ; for ( File candidate : new Array List < > ( snapshot . key Set ( ) ) ) { if ( ! latest . contains ( candidate ) ) { removed . add ( candidate ) ; snapshot . remove ( candidate ) ; } } Set < File > modified = new Hash Set < > ( ) ; for ( File candidate : latest ) { long last Modified = snapshot . get ( candidate ) ; if ( last Modified < candidate . last Modified ( ) ) { modified . add ( candidate ) ; snapshot . put ( candidate , candidate . last Modified ( ) ) ; } } for ( File file : added ) { snapshot . put ( file , file . last Modified ( ) ) ; } return new File Change Set ( directory , added , modified , removed ) ; }
public void request Remaining Authentication Failure Count ( ) { operations . add ( Password Policy State Operation Type . GET REMAINING AUTHENTICATION FAILURE COUNT ) ; }
String remove Extension ( String filename ) { int dot Index = filename . last Index Of ( STR_ ) ; return ( dot Index == - NUM_ ) ? filename : filename . substring ( NUM_ , dot Index ) ; }
public boolean is Signal Mast Assigned Anywhere ( Signal Mast signal Mast ) { for ( Positionable Point po : layout Editor . point List ) { if ( ( po . get East Bound Signal Mast ( ) != null ) && po . get East Bound Signal Mast ( ) == signal Mast ) { return true ; } if ( ( po . get West Bound Signal Mast ( ) != null ) && po . get West Bound Signal Mast ( ) == signal Mast ) { return true ; } } for ( Layout Turnout to : layout Editor . turnout List ) { if ( ( to . get Signal A Mast ( ) != null ) && to . get Signal D Mast ( ) == signal Mast ) { return true ; } if ( ( to . get Signal B Mast ( ) != null ) && to . get Signal D Mast ( ) == signal Mast ) { return true ; } if ( ( to . get Signal C Mast ( ) != null ) && to . get Signal D Mast ( ) == signal Mast ) { return true ; } if ( ( to . get Signal D Mast ( ) != null ) && to . get Signal D Mast ( ) == signal Mast ) { return true ; } } for ( Layout Slip to : layout Editor . slip List ) { if ( ( to . get Signal A Mast ( ) != null ) && to . get Signal D Mast ( ) == signal Mast ) { return true ; } if ( ( to . get Signal B Mast ( ) != null ) && to . get Signal D Mast ( ) == signal Mast ) { return true ; } if ( ( to . get Signal C Mast ( ) != null ) && to . get Signal D Mast ( ) == signal Mast ) { return true ; } if ( ( to . get Signal D Mast ( ) != null ) && to . get Signal D Mast ( ) == signal Mast ) { return true ; } } for ( Level Xing x : layout Editor . xing List ) { if ( ( x . get Signal A Mast ( ) != null ) && x . get Signal A Mast ( ) == signal Mast ) { return true ; } if ( ( x . get Signal B Mast ( ) != null ) && x . get Signal A Mast ( ) == signal Mast ) { return true ; } if ( ( x . get Signal C Mast ( ) != null ) && x . get Signal A Mast ( ) == signal Mast ) { return true ; } if ( ( x . get Signal D Mast ( ) != null ) && x . get Signal A Mast ( ) == signal Mast ) { return true ; } } return false ; }
public String to XML String ( boolean include NS , boolean declare NS ) throws FS Msg Exception { return to XML String ( include NS , declare NS , false ) ; }
protected boolean is Obsolete ( Snmp Cached Data cached ) { if ( cached == null ) return true ; if ( validity < NUM_ ) return false ; return ( ( System . current Time Millis ( ) - cached . last Updated ) > validity ) ; }
public Dimension string Size ( Font Metrics f ) { Dimension d = new Dimension ( ) ; int old = NUM_ ; String s ; int noa = NUM_ ; while ( ( s = get Line ( noa ) ) != null ) { noa ++ ; old = f . string Width ( s ) ; if ( old > d . width ) { d . width = old ; } } d . height = noa * f . get Height ( ) ; return d ; }
public String to Big String ( ) { String Builder result = new String Builder ( ) ; for ( int r = NUM_ ; r < rows ; r ++ ) { for ( int c = NUM_ ; c < columns ; c ++ ) { int value = get ( r , c ) ; if ( value < NUM_ ) { value += NUM_ ; } result . append ( String . format ( STR_ , value ) ) ; } result . append ( STR_ ) ; } return result . to String ( ) ; }
static public double k 1 ( double x ) throws Arithmetic Exception { double y , z ; z = NUM_ * x ; if ( z <= NUM_ ) throw new Arithmetic Exception ( ) ; if ( x <= NUM_ ) { y = x * x - NUM_ ; y = Math . log ( z ) * i 1 ( x ) + Arithmetic . chbevl ( y , A k 1 , NUM_ ) / x ; return ( y ) ; } return ( Math . exp ( - x ) * Arithmetic . chbevl ( NUM_ / x - NUM_ , B k 1 , NUM_ ) / Math . sqrt ( x ) ) ; }
public static String strip Extension ( String filename ) { int idx = filename . index Of ( STR_ ) ; if ( idx != - NUM_ ) { filename = filename . substring ( NUM_ , idx ) ; } return filename ; }
public String pretty Print ( ) { final String Buffer sb = new String Buffer ( short Summary ( ) ) ; sb . append ( STR_ ) ; if ( ! this . keep Task List ) { sb . append ( STR_ ) ; } else { final Task Info [ ] tasks = get Task Info ( ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; sb . append ( STR_ ) ; final Number Format nf = Number Format . get Number Instance ( ) ; nf . set Minimum Integer Digits ( NUM_ ) ; nf . set Grouping Used ( false ) ; final Number Format pf = Number Format . get Percent Instance ( ) ; pf . set Minimum Integer Digits ( NUM_ ) ; pf . set Grouping Used ( false ) ; for ( final Task Info task : tasks ) { sb . append ( nf . format ( task . get Time Millis ( ) ) + STR_ ) ; final double total Time Seconds = get Total Time Seconds ( ) ; final double percentage = total Time Seconds == NUM_ ? NUM_ : task . get Time Seconds ( ) / total Time Seconds ; sb . append ( pf . format ( percentage ) + STR_ ) ; sb . append ( task . get Task Name ( ) + STR_ ) ; } } return sb . to String ( ) ; }
private Node < E > find Predecessor ( Comparable < ? super E > key ) { if ( key == null ) throw new Null Pointer Exception ( ) ; for ( ; ; ) { Index < E > q = head ; Index < E > r = q . right ; for ( ; ; ) { if ( r != null ) { Node < E > n = r . node ; E k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( key . compare To ( k ) >= NUM_ ) { q = r ; r = r . right ; continue ; } } Index < E > d = q . down ; if ( d != null ) { q = d ; r = d . right ; } else return q . node ; } } }
static private String port Name ( Storage Port port ) { return Block Storage Scheduler . port Name ( port ) ; }
protected String do Get Text ( E Object source ) { String keyword = get Keyword Label ( source ) ; Qualified Name container Name = qualified Name Provider . get Fully Qualified Name ( source ) ; while ( container Name == null ) { source = source . e Container ( ) ; if ( source != null ) { container Name = qualified Name Provider . get Fully Qualified Name ( source ) ; } else { break ; } } if ( keyword != null && keyword . length ( ) > NUM_ ) { return keyword + STR_ + container Name ; } return String . value Of ( container Name ) ; }
public boolean is Discard Visible ( ) { return m Button Discard . is Visible ( ) ; }
@ Override public boolean execute ( @ Not Null Psi Element pe , @ Not Null Resolve State state ) { if ( pe instanceof Psi Variable ) { final Psi Variable pvar = ( Psi Variable ) pe ; final String pvar name = pvar . get Name ( ) ; if ( pvar name . starts With ( my Prefix ) ) { if ( ! my Static Sensitive Flag || ( ! my Static Scope Flag || pvar . has Modifier Property ( Psi Modifier . STATIC ) ) ) { my Result List . add ( pvar ) ; } } } return true ; }
public String to XML String ( ) throws SAML 2 Exception { return to XML String ( true , false ) ; }
@ Override public int hash Code ( ) { int hash = NUM_ ; hash = NUM_ * hash + ( scope != null ? scope . hash Code ( ) : NUM_ ) ; hash = NUM_ * hash + ( metric != null ? metric . hash Code ( ) : NUM_ ) ; hash = NUM_ * hash + ( tags != null ? tags . hash Code ( ) : NUM_ ) ; return hash ; }
private static Set parse Realm Data ( String data , String org DN ) { Set return Data = Collections . EMPTY SET ; String realm = DN Mapper . org Name To Realm Name ( org DN ) ; if ( data != null && data . length ( ) != NUM_ ) { String Tokenizer stz = new String Tokenizer ( data , IS Auth Constants . PIPE SEPARATOR ) ; return Data = new Hash Set ( ) ; while ( stz . has More Tokens ( ) ) { String realm Data = ( String ) stz . next Token ( ) ; if ( realm Data != null && realm Data . length ( ) != NUM_ ) { int index = realm Data . index Of ( IS Auth Constants . COLON ) ; if ( index == - NUM_ ) { realm Data = to Realm Qualified Authn Data ( realm , realm Data ) ; } return Data . add ( realm Data ) ; } } } if ( util Debug . message Enabled ( ) ) { util Debug . message ( STR_ + data ) ; util Debug . message ( STR_ + return Data ) ; } return return Data ; }
public long to Seconds ( ) { return time Unit . to Seconds ( length ) ; }
private boolean contains Rep Set UID ( List < Replication Set UID > rset Uids , Replication Set UID rep Set UID ) { for ( Replication Set UID rset Uid : rset Uids ) { if ( rset Uid . get Id ( ) == rep Set UID . get Id ( ) ) { return true ; } } return false ; }
public Iterator edge Iterator ( ) { return edges . iterator ( ) ; }
public static String top Level Type String ( String type Str ) { int dollar Index = type Str . index Of ( STR_ ) ; String top Level Type Str = dollar Index == - NUM_ ? type Str : type Str . substring ( NUM_ , dollar Index ) ; return top Level Type Str ; }
@ Override public boolean is Modified ( ) { long now = Current Time . current Time ( ) ; long last Check Time = last Check Time . get ( ) ; if ( now <= last Check Time + check Interval ) { return is Modified ; } if ( ! last Check Time . compare And Set ( last Check Time , now ) ) { return is Modified ; } if ( is Modified Impl ( ) ) { is Modified = true ; } else { is Modified = false ; } return is Modified ; }
public double gaussian Downside Deviation ( ) { return Math . sqrt ( gaussian Downside Variance ( ) ) ; }
@ Contract ( STR_ ) @ Nullable public static String prepend Resource Prefix ( @ Nullable Module module , @ Nullable String name ) { if ( module != null ) { Android Facet facet = Android Facet . get Instance ( module ) ; if ( facet != null ) { Android Gradle Model android Model = Android Gradle Model . get ( facet ) ; if ( android Model != null ) { String resource Prefix = Lint Utils . compute Resource Prefix ( android Model . get Android Project ( ) ) ; if ( resource Prefix != null ) { if ( name != null ) { return name . starts With ( resource Prefix ) ? name : Lint Utils . compute Resource Name ( resource Prefix , name ) ; } else { return resource Prefix ; } } } } } return name ; }
public boolean is Source Modified ( Resource resource ) { return false ; }
public boolean is Underlined ( ) { return modifiers . contains ( SGR . UNDERLINE ) ; }
public Object [ ] add All Edges ( Object [ ] cells ) { List < Object > all Cells = new Array List < Object > ( cells . length ) ; all Cells . add All ( Arrays . as List ( cells ) ) ; all Cells . add All ( Arrays . as List ( get All Edges ( cells ) ) ) ; return all Cells . to Array ( ) ; }
public static byte [ ] encode Gif ( Buffered Image image ) throws IO Exception { Byte Array Output Stream out = new Byte Array Output Stream ( ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + out ) ; } Acme . JPM . Encoders . Gif Encoder enc = new Acme . JPM . Encoders . Gif Encoder ( image , out ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } enc . encode ( ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } return out . to Byte Array ( ) ; }
public List < Column > columns ( String ... column Names ) { List < Column > columns = new Array List < > ( ) ; for ( String column Name : column Names ) { columns . add ( column ( column Name ) ) ; } return columns ; }
public boolean dec Ref Count ( ) { int rc = ref Count Updater . decrement And Get ( this ) ; if ( rc < NUM_ ) { throw new Illegal State Exception ( STR_ + rc ) ; } return rc == NUM_ ; }
public ELF Formatter ( ) { String timestamp Generator Class = lmanager . get Property ( Log Constants . SECURE TIMESTAMP GENERATOR ) ; try { Class clz = Class . for Name ( timestamp Generator Class ) ; secure Timestamp Generator = ( I Timestamp Generator ) clz . new Instance ( ) ; } catch ( Class Not Found Exception cnfe ) { Debug . error ( STR_ + STR_ , cnfe ) ; } catch ( Instantiation Exception ie ) { Debug . error ( STR_ + STR_ , ie ) ; } catch ( Illegal Access Exception iae ) { Debug . error ( STR_ + STR_ , iae ) ; } }
public String byte String No Comma ( ) { String Builder retval = new String Builder ( ) ; try { while ( true ) { char next = look Ahead ( NUM_ ) ; if ( next == STR_ || next == STR_ ) { break ; } else { consume ( NUM_ ) ; retval . append ( next ) ; } } } catch ( Parse Exception ex ) { } return retval . to String ( ) ; }
public static byte [ ] to Byte Array ( Sms Udh Element [ ] udh Elements ) { Byte Array Output Stream baos = new Byte Array Output Stream ( NUM_ ) ; if ( udh Elements == null ) { return new byte [ NUM_ ] ; } baos . write ( ( byte ) Sms Udh Util . get Total Size ( udh Elements ) ) ; try { for ( Sms Udh Element udh Element : udh Elements ) { udh Element . write To ( baos ) ; } } catch ( IO Exception ioe ) { throw new Runtime Exception ( ioe ) ; } return baos . to Byte Array ( ) ; }
public static boolean match Device ( final Bluetooth Gatt gatt ) { final Bluetooth Gatt Service service = gatt . get Service ( UART SERVICE UUID ) ; return service != null && service . get Characteristic ( UART TX CHARACTERISTIC UUID ) != null && service . get Characteristic ( UART RX CHARACTERISTIC UUID ) != null ; }
private String pick Codebase ( Entry Class eclass , Array List svcs , long now ) throws Class Not Found Exception { for ( int i = svcs . size ( ) ; -- i >= NUM_ ; ) { Svc Reg reg = ( Svc Reg ) svcs . get ( i ) ; if ( reg . lease Expiration <= now ) continue ; Entry Rep [ ] sets = reg . item . attribute Sets ; for ( int j = sets . length ; -- j >= NUM_ ; ) { if ( eclass . equals ( sets [ j ] . eclass ) ) return sets [ j ] . codebase ; } } throw new Class Not Found Exception ( ) ; }
public String next Token ( ) { int len = string . length ( ) ; int start = pos ; while ( start < len && del == string . char At ( start ) ) start ++ ; if ( start < len ) { pos = string . index Of ( del , start ) ; if ( start < pos && pos < len ) return string . substring ( start , pos ) ; else return string . substring ( start ) ; } throw new No Such Element Exception ( ) ; }
public Object clone ( ) { try { Live Ref new Ref = ( Live Ref ) super . clone ( ) ; return new Ref ; } catch ( Clone Not Supported Exception e ) { throw new Internal Error ( e . to String ( ) , e ) ; } }
public boolean is Variable List Equal ( int [ ] variables ) { return Arrays . equals ( variables , this . variables ) ; }
public static int option Length ( String option ) { if ( option . equals ( STR_ ) ) { return NUM_ ; } else { return NUM_ ; } }
public static boolean is Fedora ( ) { get Linux Release ( ) ; return linux Release != null && linux Release . contains ( STR_ ) ; }
public boolean is Final ( ) { return Modifier . is Final ( class . get Modifiers ( ) ) ; }
public boolean approx Equals ( S 2 Lat Lng Rect other , double max Error ) { return ( lat . approx Equals ( other . lat , max Error ) && lng . approx Equals ( other . lng , max Error ) ) ; }
public String format ( Calendar calendar ) { Calendar smsc Calendar = Calendar . get Instance ( ) ; return format ( calendar , smsc Calendar ) ; }
Module Marshal marshal ( Class < ? > source Type , Class < ? > target Type , Class < ? > declared Target Type ) { Import Key key = new Import Key ( source Type , target Type ) ; Module Marshal marshal = marshal Map . get ( key ) ; if ( marshal != null ) { return marshal ; } marshal = marshal Impl ( source Type , target Type , declared Target Type ) ; marshal Map . put If Absent ( key , marshal ) ; return marshal ; }
public boolean is Established ( ) { return established ; }
static Object resolve Toolbar Constraint ( J Tool Bar toolbar ) { if ( toolbar != null ) { Container parent = toolbar . get Parent ( ) ; if ( parent != null ) { Layout Manager m = parent . get Layout ( ) ; if ( m instanceof Border Layout ) { Border Layout b = ( Border Layout ) m ; Object con = b . get Constraints ( toolbar ) ; if ( con == SOUTH || con == EAST || con == WEST ) { return con ; } return NORTH ; } } } return NORTH ; }
private Workflow . Method detach Mirror Device Method ( URI vplex URI , URI vplex Mirror URI , URI promoted Volume URI , boolean discard ) { return new Workflow . Method ( DETACH MIRROR DEVICE METHOD NAME , vplex URI , vplex Mirror URI , promoted Volume URI , discard ) ; }
private String next ( Pattern pattern ) throws Decode Exception { Matcher matcher = pattern . matcher ( gser Value . substring ( pos , length ) ) ; if ( matcher . find ( ) && matcher . group Count ( ) >= NUM_ ) { pos += matcher . end ( NUM_ ) ; return matcher . group ( NUM_ ) ; } else { final Localizable Message msg = WARN GSER PATTERN NO MATCH . get ( pattern . pattern ( ) , gser Value . substring ( pos , length ) ) ; throw Decode Exception . error ( msg ) ; } }
public double next Double ( double mean , double gamma , double cut ) { double val , rval , displ ; if ( gamma == NUM_ ) return mean ; if ( cut == Double . NEGATIVE INFINITY ) { rval = NUM_ * random Generator . raw ( ) - NUM_ ; displ = NUM_ * gamma * Math . tan ( rval * ( Math . PI / NUM_ ) ) ; return mean + displ ; } else { val = Math . atan ( NUM_ * cut / gamma ) ; rval = NUM_ * random Generator . raw ( ) - NUM_ ; displ = NUM_ * gamma * Math . tan ( rval * val ) ; return mean + displ ; } }
public E sample ( Random rand ) { double total = total Count ( ) ; if ( total <= NUM_ ) { throw new Runtime Exception ( String . format ( STR_ , total ) ) ; } double sum = NUM_ ; double r = rand . next Double ( ) ; for ( Entry < E , Double > entry : entries . entry Set ( ) ) { double count = entry . get Value ( ) ; double frac = count / total ; sum += frac ; if ( r < sum ) { return entry . get Key ( ) ; } } throw new Illegal State Exception ( STR_ ) ; }
public Remote lookup ( String name ) throws Remote Exception , Not Bound Exception { if ( name . equals ( NAME ) ) { return system Stub ; } else { return super . lookup ( name ) ; } }
protected final String to String With Inline ( String extra ) { String Buffer sb = new String Buffer ( NUM_ ) ; sb . append ( STR_ ) ; sb . append ( position ) ; sb . append ( STR_ ) ; sb . append ( opcode ) ; if ( extra != null ) { sb . append ( STR_ ) ; sb . append ( extra ) ; } sb . append ( STR_ ) ; if ( result != null ) { sb . append ( result ) ; sb . append ( STR_ ) ; } sb . append ( sources ) ; sb . append ( STR_ ) ; return sb . to String ( ) ; }
private Unconditional Value Deref Set duplicate Fact ( Unconditional Value Deref Set fact ) { Unconditional Value Deref Set copy Of Fact = create Fact ( ) ; copy ( fact , copy Of Fact ) ; fact = copy Of Fact ; return fact ; }
@ Suppress Warnings ( { STR_ , STR_ } ) public static boolean is Regex ( String s , int groups ) { Pattern p ; try { p = Pattern . compile ( s ) ; } catch ( Pattern Syntax Exception e ) { return false ; } return get Group Count ( p ) >= groups ; }
private boolean can Access ( ) { if ( Binder . get Calling Pid ( ) == Process . my Pid ( ) ) { return true ; } else { return Preferences Utils . get Boolean ( get Context ( ) , R . string . allow access key , Preferences Utils . ALLOW ACCESS DEFAULT ) ; } }
public String pull Request Url ( String account , String collection , String project Name , String repository Name , String pull Request Id ) { Objects . require Non Null ( project Name , STR_ ) ; Objects . require Non Null ( repository Name , STR_ ) ; Objects . require Non Null ( pull Request Id , STR_ ) ; return get Team Base Url ( account , collection ) + format ( PROJECT REPO PULL REQUEST , project Name , repository Name , pull Request Id ) + get Api Version ( ) ; }
public static byte [ ] sha 256 ( byte [ ] data ) { try { Message Digest a = Message Digest . get Instance ( STR_ ) ; return a . digest ( data ) ; } catch ( No Such Algorithm Exception e ) { throw new Runtime Exception ( e ) ; } }
public boolean is Abstract ( ) { return Modifier . is Abstract ( method . get Modifiers ( ) ) ; }
public boolean empty ( ) { return ( position == input . length ( ) ) ; }
public static boolean has Cache ( ) { return HASH CACHE != null ; }
public boolean valid System Name Format ( String system Name ) { if ( tc . get Node From Name ( address From System Name ( system Name ) ) == null && tc . get Node From Address ( address From System Name ( system Name ) ) == null ) { try { if ( tc . get Node From Address ( Integer . parse Int ( address From System Name ( system Name ) ) ) == null ) { return false ; } else { return ( pin From System Name ( system Name ) >= NUM_ && pin From System Name ( system Name ) <= NUM_ ) ; } } catch ( java . lang . Number Format Exception nfe ) { return false ; } } else { return ( pin From System Name ( system Name ) >= NUM_ && pin From System Name ( system Name ) <= NUM_ ) ; } }
public static int [ ] topo Sort States ( Automaton a ) { if ( a . get Num States ( ) == NUM_ ) { return new int [ NUM_ ] ; } int num States = a . get Num States ( ) ; int [ ] states = new int [ num States ] ; final Bit Set visited = new Bit Set ( num States ) ; int upto = topo Sort States Recurse ( a , visited , states , NUM_ , NUM_ ) ; if ( upto < states . length ) { int [ ] new States = new int [ upto ] ; System . arraycopy ( states , NUM_ , new States , NUM_ , upto ) ; states = new States ; } for ( int i = NUM_ ; i < states . length / NUM_ ; i ++ ) { int s = states [ i ] ; states [ i ] = states [ states . length - NUM_ - i ] ; states [ states . length - NUM_ - i ] = s ; } return states ; }
public String [ ] parse For Header ( String string ) { if ( string . length ( ) >= NUM_ && string . starts With ( STR_ ) && string . ends With ( STR_ ) ) { int quote Index = string . index Of ( STR_ ) ; if ( quote Index != - NUM_ ) { int quote 2 Index = string . last Index Of ( STR_ ) ; if ( quote 2 Index > quote Index && Raptor String Utils . count ( string , STR_ ) == NUM_ && quote 2 Index + NUM_ == string . length ( ) ) { int space Index = string . index Of ( STR_ ) ; if ( space Index != - NUM_ && space Index < quote Index && space Index >= NUM_ ) { return new String [ ] { string . substring ( NUM_ , space Index ) , string . substring ( quote Index + NUM_ , quote 2 Index ) } ; } } } } return null ; }
final Segment < V > segment For ( int hash ) { return segments [ ( hash > > > segment Shift ) & segment Mask ] ; }
private static int hash ( Object x ) { int h = x . hash Code ( ) ; return ( ( h << NUM_ ) - h + ( h > > > NUM_ ) + ( h > > > NUM_ ) ) ; }
public static boolean is Bis Function ( String var Name ) { if ( ! var Name . starts With ( STR_ ) ) { return false ; } return Collections . binary Search ( LIST BIS FUNCTIONS , var Name ) >= NUM_ ; }
public static < K , V > Map < K , V > of ( K k 1 , V v 1 , K k 2 , V v 2 , K k 3 , V v 3 , K k 4 , V v 4 , K k 5 , V v 5 , K k 6 , V v 6 , K k 7 , V v 7 ) { Map map = of ( ) ; map . put ( k 1 , v 1 ) ; map . put ( k 2 , v 2 ) ; map . put ( k 3 , v 3 ) ; map . put ( k 4 , v 4 ) ; map . put ( k 5 , v 5 ) ; map . put ( k 6 , v 6 ) ; map . put ( k 7 , v 7 ) ; return map ; }
public static Type new Type ( AST ast , Variable Declaration declaration ) { return new Type ( ast , declaration , null , null ) ; }
public int size ( ) { if ( columns == null ) return NUM_ ; else return columns . size ( ) ; }
public static boolean is Unit Length ( S 2 Point p ) { return Math . abs ( p . norm 2 ( ) - NUM_ ) <= NUM_ ; }
public boolean should Merge ( Entity e 1 , Entity e 2 ) { return true ; }
public boolean is File ( String path ) { try { Zip Entry entry = get Zip Entry ( path ) ; return entry != null && ! entry . is Directory ( ) ; } catch ( IO Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } return false ; }
@ Override public int hash Code ( ) { return NUM_ + components . hash Code ( ) ; }
private String field Attribute Comment ( Field field ) { String comment = STR_ + field . get Simple Name ( ) + STR_ + STR_ + field Type Cardinality Comment ( field ) + STR_ ; String field Comment = Documentation Util . get Scoped Description ( field ) ; if ( ! Strings . is Null Or Empty ( field Comment ) ) { field Comment = R Doc Comment Fixer . rdocify ( field Comment ) ; comment += STR_ + field Comment . replace All ( STR_ , STR_ ) ; } return comment + STR_ ; }
static int index For ( int h , int length ) { return h & ( length - NUM_ ) ; }
private void wait For Start ( long timeout ) throws Communication Exception , Interrupted Exception { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINER ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINER , dbg Tag , STR_ , STR_ + timeout + STR_ + get State String ( ) ) ; } final long start Time = System . current Time Millis ( ) ; synchronized ( state Lock ) { while ( state == STARTING ) { final long elapsed = System . current Time Millis ( ) - start Time ; final long remaining Time = timeout - elapsed ; if ( remaining Time < NUM_ ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINER ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINER , dbg Tag , STR_ , STR_ ) ; } throw new Interrupted Exception ( STR_ ) ; } try { state Lock . wait ( remaining Time ) ; } catch ( Interrupted Exception e ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINER ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINER , dbg Tag , STR_ , STR_ ) ; } if ( state != ONLINE ) throw e ; } } if ( state == ONLINE ) { if ( SNMP ADAPTOR LOGGER . is Loggable ( Level . FINER ) ) { SNMP ADAPTOR LOGGER . logp ( Level . FINER , dbg Tag , STR_ , STR_ ) ; } return ; } else if ( start Exception instanceof Communication Exception ) { throw ( Communication Exception ) start Exception ; } else if ( start Exception instanceof Interrupted Exception ) { throw ( Interrupted Exception ) start Exception ; } else if ( start Exception != null ) { throw new Communication Exception ( start Exception , STR_ + start Exception ) ; } else { throw new Communication Exception ( STR_ + get String For State ( state ) ) ; } } }
public int size ( ) { return listeners . size ( ) ; }
public void validate Param ( ) throws Exception { Enumeration < Abstract Param Panel > en = table Panel . elements ( ) ; Abstract Param Panel panel = null ; while ( en . has More Elements ( ) ) { panel = en . next Element ( ) ; panel . validate Param ( param Object ) ; } }
@ Override public Axis Space reserve Space ( Graphics 2 D g 2 , Plot plot , Rectangle 2 D plot Area , Rectangle Edge edge , Axis Space space ) { if ( space == null ) { space = new Axis Space ( ) ; } if ( ! is Visible ( ) ) { return space ; } double dimension = get Fixed Dimension ( ) ; if ( dimension > NUM_ ) { space . add ( dimension , edge ) ; return space ; } double tick Label Height = NUM_ ; double tick Label Width = NUM_ ; if ( is Tick Labels Visible ( ) ) { g 2 . set Font ( get Tick Label Font ( ) ) ; List ticks = refresh Ticks ( g 2 , new Axis State ( ) , plot Area , edge ) ; if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { tick Label Height = find Maximum Tick Label Height ( ticks , g 2 , plot Area , is Vertical Tick Labels ( ) ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { tick Label Width = find Maximum Tick Label Width ( ticks , g 2 , plot Area , is Vertical Tick Labels ( ) ) ; } } Rectangle 2 D label Enclosure = get Label Enclosure ( g 2 , edge ) ; if ( Rectangle Edge . is Top Or Bottom ( edge ) ) { double label Height = label Enclosure . get Height ( ) ; space . add ( label Height + tick Label Height , edge ) ; } else if ( Rectangle Edge . is Left Or Right ( edge ) ) { double label Width = label Enclosure . get Width ( ) ; space . add ( label Width + tick Label Width , edge ) ; } return space ; }
public final double sample Count ( ) { long count = count . get ( ) ; long last Count = last Count . get And Set ( count ) ; return count - last Count ; }
static private byte [ ] class Name To Bytes ( String cn ) { return cn . get Bytes ( ) ; }
public static Workflow . Method rollback Expand Volume Method ( URI system URI , URI volume URI , String expand Step Id ) { return new Workflow . Method ( STR_ , system URI , volume URI , expand Step Id ) ; }
public byte to Ordinal ( ) { return this . ordinal ; }
public boolean is Namespaced Property ( String name ) { return name . starts With ( m prefix ) ; }
public double distance ( Vec x , List < Double > qi , int k ) { if ( k >= mean Sqrd Norms . length || k < NUM_ ) throw new Index Out Of Bounds Exception ( STR_ + mean Sqrd Norms . length + STR_ + k + STR_ ) ; return Math . sqrt ( Math . max ( kernel . eval ( NUM_ , NUM_ , Arrays . as List ( x ) , qi ) - NUM_ / ownes [ k ] * eval Sum K ( x , qi , k , new Designations ) + mean Sqrd Norms [ k ] * norm Consts [ k ] , NUM_ ) ) ; }
public Iterator dir Edge Iterator ( ) { return dir Edges . iterator ( ) ; }
public String min Threshold Tip Text ( ) { return STR_ ; }
protected Buffered Image create Image ( Color Model cm , Writable Raster raster , boolean is Raster Premultiplied , Hashtable properties ) { Buffered Image bi = new Buffered Image ( cm , raster , is Raster Premultiplied , null ) ; bi . set Acceleration Priority ( image . get Acceleration Priority ( ) ) ; return bi ; }
public static String plnoun Creature ( final int quantity , final String noun ) { if ( noun . equals ( STR_ ) ) { if ( quantity == NUM_ ) { return STR_ ; } else { return STR_ ; } } return plnoun ( quantity , noun ) ; }
private void update Peek Buffer ( int bytes Consumed ) { peek Buffer Length -= bytes Consumed ; peek Buffer Position = NUM_ ; System . arraycopy ( peek Buffer , bytes Consumed , peek Buffer , NUM_ , peek Buffer Length ) ; }
public boolean equals Ignoring Meta Data ( Shard Routing other ) { if ( primary != other . primary ) { return false ; } if ( shard Id != other . shard Id ) { return false ; } if ( current Node Id != null ? ! current Node Id . equals ( other . current Node Id ) : other . current Node Id != null ) { return false ; } if ( index != null ? ! index . equals ( other . index ) : other . index != null ) { return false ; } if ( relocating Node Id != null ? ! relocating Node Id . equals ( other . relocating Node Id ) : other . relocating Node Id != null ) { return false ; } if ( allocation Id != null ? ! allocation Id . equals ( other . allocation Id ) : other . allocation Id != null ) { return false ; } if ( state != other . state ) { return false ; } if ( restore Source != null ? ! restore Source . equals ( other . restore Source ) : other . restore Source != null ) { return false ; } return true ; }
protected Two Level Expandable Adapter ( List < T > data ) { full Data = data ; data List = new Array List < > ( ) ; is Open = new Array List < > ( ) ; for ( T item : full Data ) { data List . add ( new Data Holder ( item . get Data ( ) , Item Type . HEADER ) ) ; is Open . add ( false ) ; } }
protected boolean resource Exists ( File underlying Resource ) { return underlying Resource . exists ( ) ; }
public boolean is Running ( ) { return ( m Script Thread != null ) ; }
public static Object verify Credentials ( String authenticator Method , Properties credentials , Properties security Properties , Internal Log Writer log Writer , Internal Log Writer security Log Writer , Distributed Member member ) throws Authentication Required Exception , Authentication Failed Exception { if ( ! Acceptor Impl . is Authentication Required ( ) ) { return null ; } Authenticator auth = null ; try { if ( Acceptor Impl . is Integrated Security ( ) ) { return security Service . login ( credentials ) ; } else { Method instance Getter = Class Load Util . method From Name ( authenticator Method ) ; auth = ( Authenticator ) instance Getter . invoke ( null , ( Object [ ] ) null ) ; auth . init ( security Properties , log Writer , security Log Writer ) ; return auth . authenticate ( credentials , member ) ; } } catch ( Authentication Failed Exception ex ) { throw ex ; } catch ( Exception ex ) { throw new Authentication Failed Exception ( ex . get Message ( ) , ex ) ; } finally { if ( auth != null ) auth . close ( ) ; } }
public String product Short Name ( ) { return properties . get Property ( STR_ ) ; }
public int next Int ( ) throws Workload Exception { throw new Workload Exception ( STR_ ) ; }
public static List < Dimensional Item Object > as List ( Collection < ? extends Dimensional Item Object > collection ) { List < Dimensional Item Object > list = new Array List < > ( ) ; list . add All ( collection ) ; return list ; }
@ Override public boolean is Save As Allowed ( ) { return true ; }
public static synchronized Properties Support shared Instance ( ) { if ( INSTANCE == null ) INSTANCE = new Properties Support ( ) ; return INSTANCE ; }
static Work Queue common Submitter Queue ( ) { Fork Join Pool p = common ; int r = Thread Local Random . get Probe ( ) ; Work Queue [ ] ws ; int m ; return ( p != null && ( ws = p . work Queues ) != null && ( m = ws . length - NUM_ ) >= NUM_ ) ? ws [ m & r & SQMASK ] : null ; }
public static Cookie new Cookie ( String name , String value , int max Age , String path , String domain ) { Cookie cookie = null ; if ( cookie Encoding && value != null ) { cookie = new Cookie ( name , URL Enc Dec . encode ( value ) ) ; } else { cookie = new Cookie ( name , value ) ; } cookie . set Max Age ( max Age ) ; if ( ( path != null ) && ( path . length ( ) > NUM_ ) ) { cookie . set Path ( path ) ; } else { cookie . set Path ( STR_ ) ; } if ( ( domain != null ) && ( domain . length ( ) > NUM_ ) ) { cookie . set Domain ( domain ) ; } cookie . set Secure ( is Cookie Secure ( ) ) ; return cookie ; }
public Iterator iterator ( ) { return options . iterator ( ) ; }
public Token next Line ( ) { if ( ! has Next Line ( ) ) throw new Illegal State Exception ( STR_ ) ; int index Of Newline = remaining . index Of ( STR_ ) ; if ( index Of Newline == - NUM_ ) { index Of Newline = content . length ( ) - current Position ; } Token token = new Token ( this , current Position , current Position + index Of Newline ) ; step Forward ( index Of Newline + NUM_ ) ; return token ; }
public boolean is Data Flavor Supported ( Data Flavor flavor ) { return flavor . equals ( get Transfer Data Flavors ( ) [ NUM_ ] ) ; }
public static byte [ ] encode JPEG ( int w , int h , int [ ] pixels , float quality ) throws IO Exception { Buffered Image bi = new Buffered Image ( w , h , Buffered Image . TYPE INT RGB ) ; bi . set RGB ( NUM_ , NUM_ , w , h , pixels , NUM_ , w ) ; pixels = null ; return encode JPEG ( bi , quality ) ; }
public static boolean is Modifiable Variable Holder ( Object object ) { List < Field > fields = get All Modifiable Variable Fields ( object ) ; return ! fields . is Empty ( ) ; }
public static boolean is Valid Java Encoding ( String java Encoding ) { if ( java Encoding != null ) { int length = java Encoding . length ( ) ; if ( length > NUM_ ) { for ( int i = NUM_ ; i < length ; i ++ ) { char c = java Encoding . char At ( i ) ; if ( ( c < STR_ || c > STR_ ) && ( c < STR_ || c > STR_ ) && ( c < STR_ || c > STR_ ) && c != STR_ && c != STR_ && c != STR_ ) { return false ; } } return true ; } } return false ; }
private List < String > missingcloaks 2 ( final Player player , final boolean hash ) { String done Text 2 = player . get Quest ( QUEST SLOT ) ; final List < String > needed Copy 2 = new Linked List < String > ( NEEDEDCLOAKS 2 ) ; if ( done Text 2 == null ) { done Text 2 = STR_ ; } final List < String > done 2 = Arrays . as List ( done Text 2 . split ( STR_ ) ) ; needed Copy 2 . remove All ( done 2 ) ; if ( hash ) { final List < String > result 2 = new Linked List < String > ( ) ; for ( final String cloak : needed Copy 2 ) { result 2 . add ( STR_ + cloak ) ; } return result 2 ; } return needed Copy 2 ; }
public static Double Vector random ( int n ) { Double Vector v = new Double Vector ( n ) ; for ( int i = NUM_ ; i < n ; i ++ ) { v . V [ i ] = Math . random ( ) ; } return v ; }
public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public static String trim ( final String string ) { String result = null ; if ( string == null ) { result = BLANK ; } else { result = string . trim ( ) ; } return result ; }
public synchronized boolean is Connection Ok ( String port Name ) { String state Text = get Connection State ( port Name ) ; if ( state Text . equals ( CONNECTION DOWN ) ) { return false ; } else { return true ; } }
public void wait For Event ( long timeout ) { Thread thread = Thread . current Thread ( ) ; Semaphore semaphore = semaphores . get ( thread ) ; if ( semaphore == null ) { semaphore = new Semaphore ( NUM_ , true ) ; semaphore . drain Permits ( ) ; semaphores . put If Absent ( thread , semaphore ) ; } semaphore = semaphores . get ( thread ) ; try { semaphore . try Acquire ( timeout , Time Unit . MILLISECONDS ) ; } catch ( Interrupted Exception exception ) { logger . log ( Level . FINER , STR_ , exception ) ; } }
public char next Key Typed ( ) { synchronized ( key Lock ) { return keys Typed . remove Last ( ) ; } }
static private String substitute Sub String ( String input , String find , String replace ) { int find length = find . length ( ) ; int replace length = replace . length ( ) ; String Builder output = new String Builder ( input ) ; int index = input . index Of ( find ) ; int output Offset = NUM_ ; while ( index > - NUM_ ) { output . replace ( index + output Offset , index + output Offset + find length , replace ) ; output Offset = output Offset + ( replace length - find length ) ; index = input . index Of ( find , index + find length ) ; } String result = output . to String ( ) ; return result ; }
public boolean has Operator ( String operator ID ) { return adjacency List . contains Key ( operator ID ) ; }
public static String strip Before ( String value , char c ) { String result = value ; if ( value != null ) { int index = value . index Of ( c ) ; if ( index > NUM_ ) { result = value . substring ( NUM_ , index ) ; } } return result ; }
public static Collection < Tag > values ( ) { Root Cfg Defn . get Instance ( ) ; return Collections . unmodifiable Collection ( TAGS . values ( ) ) ; }
public Dimension maximum Layout Size ( Container target ) { Dimension rd , mbd ; Insets i = root Pane . get Insets ( ) ; Container content Pane = root Pane . get Content Pane ( ) ; J Menu Bar menu Bar = root Pane . get J Menu Bar ( ) ; if ( menu Bar != null && menu Bar . is Visible ( ) ) { mbd = menu Bar . get Maximum Size ( ) ; } else { mbd = new Dimension ( NUM_ , NUM_ ) ; } if ( content Pane != null && content Pane . is Visible ( ) ) { rd = content Pane . get Maximum Size ( ) ; } else { rd = new Dimension ( Integer . MAX VALUE , Integer . MAX VALUE - i . top - i . bottom - mbd . height - NUM_ ) ; } return new Dimension ( Math . min ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
public boolean is Weapon Valid For Phase ( int weap Num ) { return is Weapon Valid For Phase ( equipment List . get ( weap Num ) ) ; }
public static Locale random Locale ( Random random ) { return locale For Language Tag ( available Language Tags [ random . next Int ( available Language Tags . length ) ] ) ; }
public static boolean contains ( String string , String substring ) { return string . index Of ( substring ) > - NUM_ ; }
public static final String copy String ( String str , int copies ) { String result = STR_ ; String power Of 2 Copies = str ; int remaining = copies ; while ( remaining > NUM_ ) { if ( remaining % NUM_ != NUM_ ) { result = result + power Of 2 Copies ; } remaining = remaining / NUM_ ; if ( remaining != NUM_ ) { power Of 2 Copies = power Of 2 Copies + power Of 2 Copies ; } } return result ; }
public final void sample ( ) { long count = count . get ( ) ; long last Count = last Avg Count . get And Set ( count ) ; long time = time . get ( ) ; long last Time = last Avg Time . get And Set ( time ) ; if ( count == last Count ) value = NUM_ ; else value = scale * ( time - last Time ) / ( double ) ( count - last Count ) ; }
public List < Integer > expected token ids ( ) { List < Integer > ret = new Linked List < Integer > ( ) ; int parse state = ( ( Symbol ) stack . peek ( ) ) . parse state ; short [ ] row = action tab [ parse state ] ; for ( int i = NUM_ ; i < row . length ; i += NUM_ ) { if ( row [ i ] == - NUM_ ) continue ; if ( ! validate expected symbol ( row [ i ] ) ) continue ; ret . add ( new Integer ( row [ i ] ) ) ; } return ret ; }
public boolean is Empty ( ) { return hmap . is Empty ( ) ; }
private void there Can Be Only One ( String xpath , String section ) { Node List lst = config . get Node List ( xpath , false ) ; if ( NUM_ < lst . get Length ( ) ) throw new Solr Exception ( Solr Exception . Error Code . SERVER ERROR , lst . get Length ( ) + STR_ + section + STR_ ) ; }
public final Array List < Wifi Record > load Wifis Overview Within ( final int session , final Double min Lon , final Double max Lon , final Double min Lat , final Double max Lat ) { final Array List < Wifi Record > wifis = new Array List < > ( ) ; String selection = null ; String [ ] selection Args = null ; if ( min Lon != null && max Lon != null && min Lat != null && max Lat != null ) { selection = STR_ + Schema . COL LONGITUDE + STR_ + STR_ + Schema . COL LONGITUDE + STR_ + STR_ + Schema . COL LATITUDE + STR_ + STR_ + Schema . COL LATITUDE + STR_ ; selection Args = new String [ ] { String . value Of ( min Lon ) , String . value Of ( max Lon ) , String . value Of ( min Lat ) , String . value Of ( max Lat ) } ; } final Cursor cursor = content Resolver . query ( Content Uris . with Appended Id ( Uri . with Appended Path ( Content Provider . CONTENT URI WIFI , Content Provider . CONTENT URI OVERVIEW SUFFIX ) , session ) , null , selection , selection Args , null ) ; final int column Index = cursor . get Column Index ( Schema . COL BSSID ) ; final int column Index 2 = cursor . get Column Index ( Schema . COL SSID ) ; final int column Index 3 = cursor . get Column Index ( Schema . COL CAPABILITIES ) ; final int column Index 4 = cursor . get Column Index ( Schema . COL FREQUENCY ) ; final int column Index 5 = cursor . get Column Index ( Schema . COL MAX LEVEL ) ; final int column Index 6 = cursor . get Column Index ( Schema . COL TIMESTAMP ) ; final int column Index 7 = cursor . get Column Index ( Schema . COL BEGIN POSITION ID ) ; final int column Index 8 = cursor . get Column Index ( Schema . COL END POSITION ID ) ; final int column Index 9 = cursor . get Column Index ( Schema . COL KNOWN WIFI ) ; while ( cursor . move To Next ( ) ) { final Wifi Record wifi = new Wifi Record ( ) ; wifi . set Bssid ( cursor . get String ( column Index ) ) ; wifi . set Ssid ( cursor . get String ( column Index 2 ) ) ; wifi . set Capabilities ( cursor . get String ( column Index 3 ) ) ; wifi . set Frequency ( cursor . get Int ( column Index 4 ) ) ; wifi . set Level ( cursor . get Int ( column Index 5 ) ) ; wifi . set Open Bmap Timestamp ( cursor . get Long ( column Index 6 ) ) ; wifi . set Begin Position ( load Position By Id ( cursor . get String ( column Index 7 ) ) ) ; wifi . set End Position ( load Position By Id ( cursor . get String ( column Index 8 ) ) ) ; wifi . set Catalog Status ( Catalog Status . values ( ) [ cursor . get Int ( column Index 9 ) ] ) ; wifis . add ( wifi ) ; } cursor . close ( ) ; return wifis ; }
public Publisher Concat Array < T > concat Additional Source Last ( Publisher < ? extends T > source ) { int n = array . length ; @ Suppress Warnings ( STR_ ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM_ ] ; System . arraycopy ( array , NUM_ , new Array , NUM_ , n ) ; new Array [ n ] = source ; return new Publisher Concat Array < > ( delay Error , new Array ) ; }
@ Nullable public static Num Py Doc String for Function ( @ Not Null Py Function function , @ Nullable Psi Element reference ) { return for Function ( function , reference , null ) ; }
private static int next Hash Code ( ) { return next Hash Code . get And Add ( HASH INCREMENT ) ; }
public static String join ( String separator , float [ ] elements ) { if ( elements == null || elements . length == NUM_ ) { return STR_ ; } List < Float > list = new Array List < Float > ( elements . length ) ; for ( Float element : elements ) { list . add ( element ) ; } return join ( separator , list ) ; }
public static boolean starts With ( String column Path , String table Name ) { if ( table Name == null || column Path == null ) return false ; return column Path . starts With ( table Name + STR_ ) ; }
@ Override public boolean is Modified ( ) { if ( depend == null ) { return false ; } if ( depend . is Modified ( ) ) { if ( log . is Loggable ( Level . FINE ) ) log . fine ( STR_ + depend ) ; return reload Is Modified ( ) ; } else if ( source Path == null ) { return false ; } else if ( source Path . get Last Modified ( ) != source Last Modified ) { if ( log . is Loggable ( Level . FINE ) ) log . fine ( STR_ + source Path + STR_ + new Date ( source Last Modified ) + STR_ + new Date ( source Path . get Last Modified ( ) ) ) ; if ( ! compile Is Modified ( ) ) { return false ; } boolean is Modified = reload Is Modified ( ) ; return is Modified ; } else if ( source Path . length ( ) != source Length ) { if ( log . is Loggable ( Level . FINE ) ) log . fine ( STR_ + source Path + STR_ + source Length + STR_ + source Path . length ( ) ) ; if ( ! compile Is Modified ( ) ) { return false ; } return reload Is Modified ( ) ; } else { return false ; } }
public int index In ( Char Sequence csq , int from Index ) { for ( int i = from Index , n = csq . length ( ) ; i < n ; i ++ ) { if ( contains ( csq . char At ( i ) ) ) return i ; } return - NUM_ ; }
private static boolean is Token Char ( char c ) { return ( c > NUM_ ) && ( c < NUM_ ) && ( TSPECIALS . index Of ( c ) < NUM_ ) ; }
public static String after ( String line , String char Sequence ) { int pos = line . index Of ( char Sequence ) ; if ( pos != - NUM_ ) { line = line . substring ( pos + char Sequence . length ( ) ) ; } return line . trim ( ) ; }
@ Safe Varargs @ Suppress Warnings ( STR_ ) public static < T > Stream < T > of ( T ... values ) { return Arrays . stream ( values ) ; }
public static String current Date ( ) { Date Format DATE FORMAT = new Simple Date Format ( STR_ ) ; Calendar cal = Calendar . get Instance ( ) ; return DATE FORMAT . format ( cal . get Time ( ) ) ; }
public boolean has Vary All ( ) { return vary Fields . contains ( STR_ ) ; }
public static Color reduce Color Brightness ( Color color ) { int r , g , b ; float [ ] hsb = new float [ NUM_ ] ; r = color . get Red ( ) ; g = color . get Green ( ) ; b = color . get Blue ( ) ; Color . RG Bto HSB ( r , g , b , hsb ) ; hsb [ NUM_ ] *= NUM_ ; hsb [ NUM_ ] *= NUM_ ; return Color . get HSB Color ( hsb [ NUM_ ] , hsb [ NUM_ ] , hsb [ NUM_ ] ) ; }
private static int find First Dup Or Drop ( int [ ] reorder , int new Arity ) { final int BIT LIMIT = NUM_ ; if ( new Arity < BIT LIMIT ) { long mask = NUM_ ; for ( int i = NUM_ ; i < reorder . length ; i ++ ) { int arg = reorder [ i ] ; if ( arg >= new Arity ) { return reorder . length ; } long bit = NUM_ << arg ; if ( ( mask & bit ) != NUM_ ) { return i ; } mask |= bit ; } if ( mask == ( NUM_ << new Arity ) - NUM_ ) { assert ( Long . number Of Trailing Zeros ( Long . lowest One Bit ( ~ mask ) ) == new Arity ) ; return NUM_ ; } long zero Bit = Long . lowest One Bit ( ~ mask ) ; int zero Pos = Long . number Of Trailing Zeros ( zero Bit ) ; assert ( zero Pos <= new Arity ) ; if ( zero Pos == new Arity ) { return NUM_ ; } return ~ zero Pos ; } else { Bit Set mask = new Bit Set ( new Arity ) ; for ( int i = NUM_ ; i < reorder . length ; i ++ ) { int arg = reorder [ i ] ; if ( arg >= new Arity ) { return reorder . length ; } if ( mask . get ( arg ) ) { return i ; } mask . set ( arg ) ; } int zero Pos = mask . next Clear Bit ( NUM_ ) ; assert ( zero Pos <= new Arity ) ; if ( zero Pos == new Arity ) { return NUM_ ; } return ~ zero Pos ; } }
public static Properties load Tray Properties ( ) { Properties tray Props = new Properties ( ) ; String tray Props Path = Deploy Utilities . detect Properties Path ( ) ; log . info ( STR_ + tray Props Path ) ; File props File = new File ( tray Props Path ) ; try ( File Input Stream input Stream = new File Input Stream ( props File ) ) { tray Props . load ( input Stream ) ; return tray Props ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; log . warn ( STR_ ) ; return null ; } }
public static String last ( String list , char delimiter ) { int len = list . length ( ) ; if ( len == NUM_ ) return STR_ ; int index = NUM_ ; while ( true ) { index = list . last Index Of ( delimiter ) ; if ( index == - NUM_ ) { return list ; } else if ( index + NUM_ == len ) { list = list . substring ( NUM_ , len - NUM_ ) ; len -- ; } else { return list . substring ( index + NUM_ ) ; } } }
public String to Json ( ) { try { return Json Serializer . to String ( this ) ; } catch ( IO Exception e ) { throw new Index Exception ( e , STR_ , e . get Message ( ) ) ; } }
public String Builder encode Body ( String Builder retval ) { return retval . append ( option Tag ) ; }
public Linked List < Transaction Output > calculate All Spend Candidates ( boolean exclude Immature Coinbases ) { lock . lock ( ) ; try { Linked List < Transaction Output > candidates = Lists . new Linked List ( ) ; for ( Transaction tx : Iterables . concat ( unspent . values ( ) , pending . values ( ) ) ) { if ( exclude Immature Coinbases && ! tx . is Mature ( ) ) continue ; for ( Transaction Output output : tx . get Outputs ( ) ) { if ( ! output . is Available For Spending ( ) ) continue ; if ( ! output . is Mine ( this ) ) continue ; candidates . add ( output ) ; } } return candidates ; } finally { lock . unlock ( ) ; } }
public static String to Get Url ( String url , Bundle params ) { if ( params != null ) { if ( ! url . ends With ( STR_ ) ) { url = url + STR_ ; } for ( String key : params . key Set ( ) ) { url = url + key + STR_ + params . get String ( key ) + STR_ ; } } return url ; }
public static boolean is Email Address ( String address ) { Matcher matcher = VALID EMAIL . matcher ( address ) ; return matcher . matches ( ) ; }
public boolean is Icon For File Available ( File f ) { validate ( ) ; return file Controller . is Icon For File Available ( f ) ; }
public V unsafe Get ( final Class key ) { final Entry < V > [ ] tab ; Entry < V > e = ( tab = table ) [ key . hash Code ( ) & ( tab . length - NUM_ ) ] ; while ( e != null ) { if ( key == e . key ) { return e . value ; } e = e . next ; } return null ; }
public static boolean is Component Class ( String name ) { return CLASS NAMES . contains ( name ) ; }
public final int size ( ) { int count = NUM_ ; for ( E ignored : my Iterable ) { count ++ ; } return count ; }
public Rest Status status ( ) { if ( state == Snapshot State . FAILED ) { return Rest Status . INTERNAL SERVER ERROR ; } if ( shard Failures . size ( ) == NUM_ ) { return Rest Status . OK ; } return Rest Status . status ( successful Shards , total Shards , shard Failures . to Array ( new Shard Operation Failed Exception [ shard Failures . size ( ) ] ) ) ; }
public static boolean login ( String email , String password ) { Persistence Manager pm = pmf . get Persistence Manager ( ) ; try { User Record user = find User By Email ( pm , email ) ; return user != null && ! Strings . is Null Or Empty ( password ) && password . equals ( user . get Password ( ) ) ; } finally { pm . close ( ) ; } }
public List < File > generated Files ( ) { return Collections . unmodifiable List ( generated Files ) ; }
public static String bytes To Hex String ( byte [ ] bytes ) { String Buffer buf = new String Buffer ( bytes . length * NUM_ ) ; for ( byte b : bytes ) { String s = Integer . to String ( NUM_ & b , NUM_ ) ; if ( s . length ( ) < NUM_ ) buf . append ( STR_ ) ; buf . append ( s ) ; } return buf . to String ( ) ; }
@ Override public Inet Socket Address ip Local ( ) { Socket s = get Socket ( ) ; if ( s != null ) { return ( Inet Socket Address ) s . get Local Socket Address ( ) ; } else { return null ; } }
public I Binary Tree Node < T > next ( ) { if ( stack . empty ( ) ) { throw new java . util . No Such Element Exception ( STR_ ) ; } Moment m = stack . peek ( ) ; advance ( ) ; return m . node ; }
public Float Column neg ( ) { Float Column new Column = Float Column . create ( name ( ) + STR_ , size ( ) ) ; for ( float value : this ) { new Column . add ( value * - NUM_ ) ; } return new Column ; }
final public boolean starts With Ignore Case ( final Mutable String prefix ) { final int l = prefix . length ( ) ; if ( l > length ( ) ) return false ; int i = l ; final char [ ] a 1 = prefix . array ; final char [ ] a 2 = array ; char c , d ; while ( i -- != NUM_ ) { c = Character . to Lower Case ( Character . to Upper Case ( a 1 [ i ] ) ) ; d = Character . to Lower Case ( Character . to Upper Case ( a 2 [ i ] ) ) ; if ( c != d ) return false ; } return true ; }
public static Tick Unit Source create Integer Tick Units ( Locale locale ) { Number Format number Format = Number Format . get Number Instance ( locale ) ; return new Number Tick Unit Source ( true , number Format ) ; }
public int position ( ) { return buffer . position ( ) ; }
public boolean is POE Exists ( final String id , final Date control Time ) { List < Date > dates = poe . get ( id ) ; if ( dates != null ) { for ( Date date : dates ) { if ( date . compare To ( control Time ) < NUM_ ) { return true ; } } } return false ; }
@ Override public boolean is Open ( ) { return ( tl Tx . get ( ) != null ) ; }
public boolean is Released ( ) { return released . get ( ) ; }
public final double calculate Interval Likelihood ( Demographic Function demo Function , double width , double time Of Prev Coal , int lineage Count , int type ) { double time Of This Coal = width + time Of Prev Coal ; double interval Area = demo Function . get Integral ( time Of Prev Coal , time Of This Coal ) ; double like = NUM_ ; switch ( type ) { case COALESCENT : like = - Math . log ( demo Function . get Demographic ( time Of This Coal ) ) - ( Binomial . choose 2 ( lineage Count ) * interval Area ) ; break ; case NEW SAMPLE : like = - ( Binomial . choose 2 ( lineage Count ) * interval Area ) ; break ; } return like ; }
private static List < String > as Strings ( Class ... classes ) { List < String > strings = new Array List < > ( ) ; for ( Class c : classes ) { strings . add ( c . get Name ( ) ) ; } return strings ; }
@ Deprecated public String load MAT Sim 4 Urban Sim XSD String ( ) { try { File f = load MAT Sim 4 Urban Sim XSD ( ) ; return f . get Canonical Path ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return null ; }
public String font Reference ( Font font , boolean embed , String embed As ) { font = substitute Font ( font ) ; String key = get Key ( font ) ; Entry e = ( Entry ) table . get ( key ) ; if ( e == null ) { e = new Entry ( font , get Encoding Table ( font ) ) ; try { first Request ( e , embed , embed As ) ; } catch ( IO Exception exc ) { exc . print Stack Trace ( ) ; } table . put ( key , e ) ; } return e . ref ; }
@ Override protected int default Num Attributes ( ) { return NUM_ ; }
public int hash Code ( ) { if ( myhash == - NUM_ ) { myhash = NUM_ + ( party == null ? NUM_ : party . hash Code ( ) ) ; if ( assigner != null ) { myhash = NUM_ * myhash + assigner . hash Code ( ) ; } } return myhash ; }
@ Override public int size ( ) { return m Instances . size ( ) ; }
private boolean is Valid Geometry Path ( String path ) { return path . equals ( STR_ ) || path . equals ( STR_ ) || path . equals ( STR_ ) ; }
@ Override public String metric String ( ) { switch ( m metric Type ) { case LIFT : return STR_ ; case LEVERAGE : return STR_ ; case CONVICTION : return STR_ ; default : return STR_ ; } }
private Channel new Channel ( ) throws IO Exception { check State ( publisher Channel != null , STR_ ) ; Client Auth Interceptor interceptor = new Client Auth Interceptor ( credentials , Executors . new Single Thread Executor ( ) ) ; return Client Interceptors . intercept ( publisher Channel , interceptor ) ; }
@ Override public double max Impurity ( ) { return max Impurity ; }
public boolean is Empty ( ) { if ( m nodes == null ) return true ; return m nodes . size ( ) == NUM_ ; }
public static boolean is Static ( int mod ) { return Modifier . is Static ( mod ) ; }
public byte [ ] encode ( ) { char type = get Attribute Type ( ) ; byte bin Value [ ] = new byte [ HEADER LENGTH + get Data Length ( ) + ( get Data Length ( ) % NUM_ ) ] ; bin Value [ NUM_ ] = ( byte ) ( type > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( type & NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( get Data Length ( ) & NUM_ ) ; System . arraycopy ( realm , NUM_ , bin Value , NUM_ , get Data Length ( ) ) ; return bin Value ; }
private float snap ( float value ) { if ( snap Values == null ) { return value ; } for ( int i = NUM_ ; i < snap Values . length ; i ++ ) { if ( Math . abs ( value - snap Values [ i ] ) <= threshold ) { return snap Values [ i ] ; } } return value ; }
public final Bytes Ref bytes ( ) { return bytes ; }
private static boolean is Integer Property ( String property Name ) { return ( PROPERTY EVENT TYPE . equals ( property Name ) || PROPERTY ITEM COUNT . equals ( property Name ) || PROPERTY CURRENT ITEM INDEX . equals ( property Name ) || PROPERTY FROM INDEX . equals ( property Name ) || PROPERTY TO INDEX . equals ( property Name ) || PROPERTY SCROLL X . equals ( property Name ) || PROPERTY SCROLL Y . equals ( property Name ) || PROPERTY RECORD COUNT . equals ( property Name ) || PROPERTY ADDED COUNT . equals ( property Name ) || PROPERTY REMOVED COUNT . equals ( property Name ) || PROPERTY QUEUING . equals ( property Name ) ) || PROPERTY VERSION CODE . equals ( property Name ) || PROPERTY PLATFORM SDK . equals ( property Name ) ; }
public double pdf ( double x ) { if ( x <= NUM_ ) throw new Illegal Argument Exception ( ) ; double log Gamma = Fun . log Gamma ( freedom / NUM_ ) ; return Math . exp ( ( freedom / NUM_ - NUM_ ) * Math . log ( x / NUM_ ) - x / NUM_ - log Gamma ) / NUM_ ; }
public Map < String , Thrift Service Entry > entries ( ) { return entries ; }
protected boolean is Stopped ( ) { return stopped ; }
private Map < String , Function < Http Request Context , String > > create Substitution Map ( String [ ] permissions , Abstract Method am ) { Map < String , Function < Http Request Context , String > > map = Maps . new Linked Hash Map ( ) ; for ( String permission : permissions ) { Matcher matcher = SUBSTITUTION MATCHER . matcher ( permission ) ; while ( matcher . find ( ) ) { String match = matcher . group ( ) ; if ( map . contains Key ( match ) ) { continue ; } String param = matcher . group ( STR_ ) ; Function < Http Request Context , String > substitution ; if ( param . starts With ( STR_ ) ) { substitution = create Query Substitution ( param . substring ( NUM_ ) ) ; } else { substitution = create Path Substitution ( param , am ) ; } map . put ( match , substitution ) ; } } return map ; }
public static double max ( double [ ] a , int lo , int hi ) { if ( lo < NUM_ || hi >= a . length || lo > hi ) throw new Index Out Of Bounds Exception ( STR_ ) ; double max = Double . NEGATIVE INFINITY ; for ( int i = lo ; i <= hi ; i ++ ) { if ( Double . is Na N ( a [ i ] ) ) return Double . Na N ; if ( a [ i ] > max ) max = a [ i ] ; } return max ; }
public static double incomplete Gamma Complement ( double a , double x ) { double ans , ax , c , yc , r , t , y , z ; double pk , pkm 1 , pkm 2 , qk , qkm 1 , qkm 2 ; if ( x <= NUM_ || a <= NUM_ ) { return NUM_ ; } if ( x < NUM_ || x < a ) { return NUM_ - incomplete Gamma ( a , x ) ; } ax = a * Math . log ( x ) - x - ln Gamma ( a ) ; if ( ax < - MAXLOG ) { return NUM_ ; } ax = Math . exp ( ax ) ; y = NUM_ - a ; z = x + y + NUM_ ; c = NUM_ ; pkm 2 = NUM_ ; qkm 2 = x ; pkm 1 = x + NUM_ ; qkm 1 = z * x ; ans = pkm 1 / qkm 1 ; do { c += NUM_ ; y += NUM_ ; z += NUM_ ; yc = y * c ; pk = pkm 1 * z - pkm 2 * yc ; qk = qkm 1 * z - qkm 2 * yc ; if ( qk != NUM_ ) { r = pk / qk ; t = Math . abs ( ( ans - r ) / r ) ; ans = r ; } else { t = NUM_ ; } pkm 2 = pkm 1 ; pkm 1 = pk ; qkm 2 = qkm 1 ; qkm 1 = qk ; if ( Math . abs ( pk ) > big ) { pkm 2 *= biginv ; pkm 1 *= biginv ; qkm 2 *= biginv ; qkm 1 *= biginv ; } } while ( t > MACHEP ) ; return ans * ax ; }
static Map < String , List < String > > unmodifiable Copy Of Extra Properties ( final Map < String , List < String > > extra Properties ) { if ( extra Properties == null || extra Properties . is Empty ( ) ) { return Collections . empty Map ( ) ; } final Map < String , List < String > > tmp = new Linked Hash Map < > ( extra Properties . size ( ) ) ; for ( final Map . Entry < String , List < String > > e : extra Properties . entry Set ( ) ) { tmp . put ( e . get Key ( ) , unmodifiable Copy Of List ( e . get Value ( ) ) ) ; } return Collections . unmodifiable Map ( tmp ) ; }
public boolean has Entries ( ) { return ! f Entries . is Empty ( ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public String to String Summary ( ) { String result ; String titles ; int resultset Length ; int i ; int j ; String content ; if ( m Non Sig Wins == null ) return STR_ ; result = STR_ ; titles = STR_ ; resultset Length = NUM_ + Math . max ( ( int ) ( Math . log ( get Col Count ( ) ) / Math . log ( NUM_ ) ) , ( int ) ( Math . log ( get Row Count ( ) ) / Math . log ( NUM_ ) ) ) ; for ( i = NUM_ ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; titles += STR_ + get Summary Title ( i ) + STR_ ; } result += titles + STR_ ; for ( i = NUM_ ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; result += STR_ ; for ( j = NUM_ ; j < get Col Count ( ) ; j ++ ) { if ( get Col Hidden ( j ) ) continue ; if ( j == i ) content = Utils . pad Left ( STR_ , resultset Length * NUM_ + NUM_ ) ; else content = Utils . pad Left ( STR_ + m Non Sig Wins [ i ] [ j ] + STR_ + m Wins [ i ] [ j ] + STR_ , resultset Length * NUM_ + NUM_ ) ; result += STR_ + content . replace All ( STR_ , STR_ ) + STR_ ; } result += STR_ + get Summary Title ( i ) + STR_ + remove Filter Name ( m Col Names [ i ] ) + STR_ ; } result += STR_ ; return result ; }
public static double hypot ( double x , double y ) { if ( USE JDK MATH ) { return STRICT MATH ? Strict Math . hypot ( x , y ) : Math . hypot ( x , y ) ; } x = Math . abs ( x ) ; y = Math . abs ( y ) ; if ( y < x ) { double a = x ; x = y ; y = a ; } else if ( ! ( y >= x ) ) { if ( ( x == Double . POSITIVE INFINITY ) || ( y == Double . POSITIVE INFINITY ) ) { return Double . POSITIVE INFINITY ; } else { return Double . Na N ; } } if ( y - x == y ) { return y ; } else { double factor ; if ( x > TWO POW 450 ) { x *= TWO POW N 750 ; y *= TWO POW N 750 ; factor = TWO POW 750 ; } else if ( y < TWO POW N 450 ) { x *= TWO POW 750 ; y *= TWO POW 750 ; factor = TWO POW N 750 ; } else { factor = NUM_ ; } return factor * Fast Math . sqrt ( x * x + y * y ) ; } }
public Map < State , Double > thread State Percentages ( ) { final Map < State , Double > conditions = new Hash Map < State , Double > ( ) ; for ( State state : State . values ( ) ) { conditions . put ( state , NUM_ ) ; } final long [ ] all Thread Ids = threads . get All Thread Ids ( ) ; final Thread Info [ ] all Threads = threads . get Thread Info ( all Thread Ids ) ; int live Count = NUM_ ; for ( Thread Info info : all Threads ) { if ( info != null ) { final State state = info . get Thread State ( ) ; conditions . put ( state , conditions . get ( state ) + NUM_ ) ; live Count ++ ; } } for ( State state : new Array List < State > ( conditions . key Set ( ) ) ) { conditions . put ( state , conditions . get ( state ) / live Count ) ; } return Collections . unmodifiable Map ( conditions ) ; }
public Range visible Range ( Contour Dataset data , Range x , Range y ) { Range range = data . get Z Value Range ( x , y ) ; return range ; }
static public double k 0 e ( double x ) throws Arithmetic Exception { double y ; if ( x <= NUM_ ) throw new Arithmetic Exception ( ) ; if ( x <= NUM_ ) { y = x * x - NUM_ ; y = Arithmetic . chbevl ( y , A k 0 , NUM_ ) - Math . log ( NUM_ * x ) * i 0 ( x ) ; return ( y * Math . exp ( x ) ) ; } y = Arithmetic . chbevl ( NUM_ / x - NUM_ , B k 0 , NUM_ ) / Math . sqrt ( x ) ; return ( y ) ; }
public boolean is To Exist ( int to ) { return token Pair List Table . get ( Integer . value Of ( to ) ) != null ; }
public final int type ( ) { return m Type ; }
@ Nullable public Bitmap generate Icon For Url ( String url , boolean include Private Registries ) { if ( Text Utils . is Empty ( url ) ) return null ; String text = get Icon Text For Url ( url , include Private Registries ) ; if ( Text Utils . is Empty ( text ) ) return null ; return generate Icon For Text ( text ) ; }
public String convert To Lower Case ( String table ) { return table . to Lower Case ( ) ; }
private static Object try Call ( String method Name , Throwing . Supplier < Object > supplier ) { try { return supplier . get ( ) ; } catch ( Throwable error ) { return new Call Exception ( method Name , error ) ; } }
public boolean is Valid ( int pixel ) { return ( ( pixel >= NUM_ && pixel < map size ) && ( valid Bits == null || valid Bits . test Bit ( pixel ) ) ) ; }
private String ports To String ( Set < Storage Port > list ) { String Builder buf = new String Builder ( ) ; for ( Storage Port port : list ) { buf . append ( port . get Port Name ( ) + STR_ ) ; } return buf . to String ( ) ; }
public static boolean is Directory Name ( String file Name ) { for ( String suffix : directory Names ) { if ( file Name . equals ( suffix ) ) { return true ; } } return false ; }
public < X extends Throwable > long or Else Throw ( Supplier < X > exception Supplier ) throws X { if ( is Present ) { return value ; } else { throw exception Supplier . get ( ) ; } }
public static Optional < String > package Name ( String long Name ) { if ( long Name . contains ( STR_ ) ) { return Optional . of ( long Name . substring ( NUM_ , long Name . last Index Of ( STR_ ) ) ) ; } else { return Optional . empty ( ) ; } }
public static List < ? extends Element > child Element List ( Element element , Set < String > child Element Names ) { if ( element == null ) return null ; List < Element > elements = new Linked List < Element > ( ) ; if ( child Element Names == null ) return elements ; Node node = element . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE && child Element Names . contains ( node . get Node Name ( ) ) ) { Element child Element = ( Element ) node ; elements . add ( child Element ) ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return elements ; }
@ Override public int compare ( String l Key , String r Key ) { int l Cat = category Of ( l Key ) ; int cat Diff = l Cat - category Of ( r Key ) ; if ( cat Diff != NUM_ || l Cat != NUM_ ) { return cat Diff ; } return l Key . compare To ( r Key ) ; }
static public void assert Square ( I Double Matrix mat ) { if ( mat . get Row Num ( ) != mat . get Col Num ( ) ) { throw new Ade Core Illegal Argument Exception ( String . format ( STR_ , mat . get Row Num ( ) , mat . get Col Num ( ) ) ) ; } }
private final boolean use Sync Writes ( boolean force Async ) { if ( force Async ) { return false ; } if ( this . async Queuing In Progress ) { return true ; } if ( this . is Receiver ) { return true ; } if ( ! this . preserve Order ) { return true ; } if ( this . async Distribution Timeout == NUM_ ) { return true ; } return false ; }
public char next Char ( ) { if ( ! has Next Char ( ) ) throw new Illegal State Exception ( STR_ ) ; char c = content . char At ( current Position ) ; step Forward ( NUM_ ) ; return c ; }
private char lookahead ( ) { return cur Char Index < pattern . length ( ) - NUM_ ? pattern . char At ( cur Char Index + NUM_ ) : EOF ; }
Node Text Rep to Node Text Rep ( ) { Node Text Rep result = new Node Text Rep ( node Text , mapping ) ; if ( decomposition != null ) { result . renaming = decomposition . renaming ; } return result ; }
@ Override public Character next ( ) { if ( has Next == false ) { throw new No Such Element Exception ( ) ; } final char cur = current ; prepare Next ( ) ; return Character . value Of ( cur ) ; }
public synchronized void unregister ( Entity Creation Listener listener ) { listeners . remove ( listener ) ; }
@ Override public byte process ( Target target ) { Element syllable = navigator . get Element ( target ) ; if ( syllable == null ) return NUM_ ; String accent = syllable . get Attribute ( STR_ ) ; if ( accent . equals ( STR_ ) ) { return NUM_ ; } return values . get ( accent ) ; }
public static Number pow ( Number a , Number b ) { return Math . pow ( a . double Value ( ) , b . double Value ( ) ) ; }
public static char char From Properties ( Properties p , String prop Name , char default Value ) { char ret = default Value ; String char String = p . get Property ( prop Name ) ; if ( char String != null && char String . length ( ) > NUM_ ) { return char String . char At ( NUM_ ) ; } return ret ; }
public double longing ( F f , int N ) { return Math . pow ( NUM_ - p ( f ) , N ) ; }
public void await ( ) throws Interrupted Exception { await Semaphore . acquire ( ) ; await Semaphore . release ( ) ; }
protected void ensure Unsigned Signature Properties ( ) throws DSS Exception { final Node List unsigned Signature Properties Node List = current Signature Dom . get Elements By Tag Name NS ( X Ad ES Namespaces . X Ad ES , STR_ ) ; final int length = unsigned Signature Properties Node List . get Length ( ) ; if ( length == NUM_ ) { unsigned Signature Properties Dom = ( Element ) unsigned Signature Properties Node List . item ( NUM_ ) ; } else if ( length == NUM_ ) { unsigned Signature Properties Dom = DSSXML Utils . add Element ( document Dom , unsigned Properties Dom , X Ad ES Namespaces . X Ad ES , STR_ ) ; } else { throw new DSS Exception ( STR_ ) ; } }
private void oops No Such Entry ( String what ) throws Configuration Exception { Error Descriptor error = new Error Descriptor ( NUM_ , NUM_ , what , location ) ; throw Configuration Exception ( new No Such Entry Exception ( error . to String ( ) ) , Collections . singleton List ( error ) ) ; throw new Assertion Error ( STR_ + STR_ ) ; }
public static double calculate Row Total ( Values 2 D data , int row ) { Param Checks . null Not Permitted ( data , STR_ ) ; double total = NUM_ ; int column Count = data . get Column Count ( ) ; for ( int c = NUM_ ; c < column Count ; c ++ ) { Number n = data . get Value ( row , c ) ; if ( n != null ) { total += n . double Value ( ) ; } } return total ; }
public static String credential ( String access Key , Date Time date , String region ) { return access Key + STR_ + date . to String ( Date Format . SIGNER DATE FORMAT ) + STR_ + region + STR_ ; }
public static Map < String , Mapped Class > mappings From Proguard ( File file , Map < String , Class Node > nodes ) { Map < String , Mapped Class > base = mappings From Nodes ( nodes ) ; Mapping Loader loader = new Proguard Loader ( nodes ) ; try { Map < String , Mapped Class > new Mappings = loader . read ( new File Reader ( file ) ) ; for ( Mapped Class mapped Class : new Mappings . values ( ) ) { new Mappings = link Mappings ( mapped Class , new Mappings ) ; } base = fix From Mappings Text ( base , new Mappings ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; } return base ; }
public static boolean equal ( double a , double b , double distance ) { return ( Math . abs ( a - b ) < distance ) ; }
public void request Seconds Until Password Expiration Warning ( ) { operations . add ( Password Policy State Operation Type . GET SECONDS UNTIL PASSWORD EXPIRATION WARNING ) ; }
public String pull Request Html Url ( String account , String collection , String project Name , String repository Name , String pull Request Id ) { Objects . require Non Null ( project Name , STR_ ) ; Objects . require Non Null ( repository Name , STR_ ) ; Objects . require Non Null ( pull Request Id , STR_ ) ; String pull Request Url ; if ( project Name . equals ( repository Name ) ) { pull Request Url = get Team Base Url ( account , collection ) + format ( PROJECT HTML PULL REQUEST , project Name , pull Request Id ) ; } else { pull Request Url = get Team Base Url ( account , collection ) + format ( PROJECT REPO HTML PULL REQUEST , project Name , repository Name , pull Request Id ) ; } return pull Request Url ; }
public boolean should Notify Reachability Update Receivers ( String node Id , boolean is Reachable ) { Boolean current Reachability = node Reachabilities . get ( node Id ) ; if ( current Reachability == null ) { return true ; } return current Reachability . boolean Value ( ) != is Reachable ; }
public Enumeration keys ( ) throws Mqtt Persistence Exception { check Is Open ( ) ; Enumeration files = get Files ( ) ; Vector result = new Vector ( ) ; while ( files . has More Elements ( ) ) { String filename = ( String ) files . next Element ( ) ; String key = filename . substring ( NUM_ , filename . length ( ) - MESSAGE FILE EXTENSION . length ( ) ) ; result . add Element ( key ) ; } return result . elements ( ) ; }
public static Document create Html Document ( ) { Document document = create Document ( ) ; Element root = document . create Element ( STR_ ) ; document . append Child ( root ) ; Element head = document . create Element ( STR_ ) ; root . append Child ( head ) ; Element body = document . create Element ( STR_ ) ; root . append Child ( body ) ; return document ; }
public static boolean is V 6 ( String netspec ) { return netspec . contains ( STR_ ) ; }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Linked List < E > ( this ) ; return l . iterator ( ) ; }
@ Override public Instances transformed Header ( ) throws Exception { if ( m eigenvalues == null ) { throw new Exception ( STR_ ) ; } if ( m trans Back To Original ) { return m original Space Format ; } else { return m transformed Format ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public static boolean is Stdio ( File file ) { return is Stdio ( file . to String ( ) ) ; }
static Transport current Transport ( ) { return current Transport . get ( ) ; }
public boolean has Static Method Call ( String owner , String method Name , String target Class , String target Method ) { Static Method Call Entry call = new Static Method Call Entry ( owner , method Name , target Class , target Method ) ; return static Method Calls . contains ( call ) ; }
public boolean is Visited ( String uri ) { if ( uri == null ) return false ; uri = resolve URI ( uri ) ; return history . contains ( uri ) ; }
public static Esper EPL 2 Grammar Parser . Start Event Property Rule Context parse ( String property Name ) { Char Stream input ; try { input = new No Case Sensitive Stream ( new String Reader ( property Name ) ) ; } catch ( IO Exception ex ) { throw new Property Access Exception ( STR_ + property Name + STR_ , ex ) ; } Esper EPL 2 Grammar Lexer lex = Parse Helper . new Lexer ( input ) ; Common Token Stream tokens = new Common Token Stream ( lex ) ; try { tokens . fill ( ) ; } catch ( Runtime Exception e ) { if ( Parse Helper . has Control Characters ( property Name ) ) { throw new Property Access Exception ( STR_ ) ; } throw new Property Access Exception ( STR_ + e . get Message ( ) ) ; } Esper EPL 2 Grammar Parser g = Parse Helper . new Parser ( tokens ) ; Esper EPL 2 Grammar Parser . Start Event Property Rule Context r ; try { r = g . start Event Property Rule ( ) ; } catch ( Recognition Exception e ) { return handle Recognition Ex ( e , tokens , property Name , g ) ; } catch ( Runtime Exception e ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + property Name + STR_ , e ) ; } if ( e . get Cause ( ) instanceof Recognition Exception ) { return handle Recognition Ex ( ( Recognition Exception ) e . get Cause ( ) , tokens , property Name , g ) ; } else { throw e ; } } return r ; }
public final Char Sequence tail ( Char Sequence csq ) { return csq . sub Sequence ( index , csq . length ( ) ) ; }
@ Override public boolean is Inside ( Point point ) { return attack Poly . contains ( point . x - bounds . x , point . y - bounds . y ) ; }
public synchronized int size ( ) { return options . size ( ) ; }
private void expected Byte ( int position , int count ) throws Malformed Byte Sequence Exception { throw new Malformed Byte Sequence Exception ( f Formatter , f Locale , XML Message Formatter . XML DOMAIN , STR_ , new Object [ ] { Integer . to String ( position ) , Integer . to String ( count ) } ) ; }
@ Override public final byte [ ] array ( ) { return protected Array ( ) ; }
public boolean sphere In Frustum ( Vector 3 center , float radius ) { for ( int i = NUM_ ; i < NUM_ ; i ++ ) if ( ( planes [ i ] . normal . x * center . x + planes [ i ] . normal . y * center . y + planes [ i ] . normal . z * center . z ) < ( - radius - planes [ i ] . d ) ) return false ; return true ; }
private String to Ref Sect 1 ( String script Name , Collection < Sub Command > sub Commands ) { if ( sub Commands . is Empty ( ) ) { return STR_ ; } Map < String , Object > map = new Hash Map < > ( ) ; map . put ( STR_ , script Name ) ; map . put ( STR_ , REF TITLE SUBCOMMANDS . get ( ) ) ; map . put ( STR_ , get Doc Subcommands Description Supplement ( ) ) ; map . put ( STR_ , REF INTRO SUBCOMMANDS . get ( script Name ) ) ; if ( script Name . equals ( STR_ ) ) { map . put ( STR_ , true ) ; } List < String > sc Usage List = new Array List < > ( ) ; for ( Sub Command sub Command : sub Commands ) { if ( sub Command . is Hidden ( ) ) { continue ; } if ( script Name . equals ( STR_ ) ) { sc Usage List . add ( get Sub Command List Item ( script Name , sub Command ) ) ; } else { sc Usage List . add ( to Ref Sect 2 ( script Name , sub Command ) ) ; } } map . put ( STR_ , sc Usage List ) ; String Builder sb = new String Builder ( ) ; apply Template ( sb , STR_ , map ) ; return sb . to String ( ) ; }
private I Configuration Element select Configuration Element ( Set set ) { if ( set != null && ! set . is Empty ( ) ) { Iterator e = set . iterator ( ) ; return ( I Configuration Element ) e . next ( ) ; } return null ; }
protected boolean can Trigger Walking ( ) { return false ; }
public double next Double ( double lambda ) { return - Math . log ( random Generator . raw ( ) ) / lambda ; }
public static boolean is Empty ( Char Sequence str ) { return ( str == null || str . length ( ) == NUM_ ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public static Automaton random Automaton ( Random random ) { Automaton a 1 = random Single Automaton ( random ) ; Automaton a 2 = random Single Automaton ( random ) ; switch ( random . next Int ( NUM_ ) ) { case NUM_ : return Operations . concatenate ( a 1 , a 2 ) ; case NUM_ : return Operations . union ( a 1 , a 2 ) ; case NUM_ : return Operations . intersection ( a 1 , a 2 ) ; default : return Operations . minus ( a 1 , a 2 , DEFAULT MAX DETERMINIZED STATES ) ; } }
boolean can Append ( ) { return appending == NUM_ || ( appending < MAX APPENDS && System . nano Time ( ) - ( time Buffer . average ( ) / MAX APPENDS ) >= append Time ) ; }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ ; }
public static double static Next Double ( double mean , double gamma , double cut ) { synchronized ( shared ) { return shared . next Double ( mean , gamma , cut ) ; } }
private static Droid Model find One ( Droid Model model ) throws Droid Model Exception { return null ; }
@ Override public boolean equals ( Object object ) { if ( object == this ) { return true ; } if ( object instanceof Resizable Double Array == false ) { return false ; } boolean result = true ; final Resizable Double Array other = ( Resizable Double Array ) object ; result = result && ( other . contraction Criterion == contraction Criterion ) ; result = result && ( other . expansion Factor == expansion Factor ) ; result = result && ( other . expansion Mode == expansion Mode ) ; result = result && ( other . num Elements == num Elements ) ; result = result && ( other . start Index == start Index ) ; if ( ! result ) { return false ; } else { return Arrays . equals ( internal Array , other . internal Array ) ; } }
public int equiv Hash Code ( ) { return name . hash Code ( ) * NUM_ + type . hash Code ( ) * NUM_ ; }
public static byte [ ] to Utf ( String s ) throws UTF Data Format Exception { try { Optimized Byte Array Output Stream bout = new Optimized Byte Array Output Stream ( s . length ( ) ) ; Data Output dout = new Data Output Stream ( bout ) ; dout . write UTF ( s ) ; return bout . to Byte Array ( ) ; } catch ( UTF Data Format Exception e ) { throw e ; } catch ( IO Exception e ) { throw new Assertion Error ( e ) ; } }
public String more To String ( ) { String Builder sb = new String Builder ( STR_ ) ; sb . append ( ( index == - NUM_ ) ? STR_ : STR_ ) ; sb . append ( STR_ ) ; return sb . to String ( ) ; }
private Boolean valid Quota Directory Path ( String vol Name , String quota Dir Name ) { if ( vol Name == null && quota Dir Name == null ) { log . info ( STR_ ) ; return false ; } else { if ( quota Dir Name . length ( ) > QUOTA DIR MAX NAME ) { log . error ( STR_ , quota Dir Name . length ( ) , QUOTA DIR MAX NAME ) ; return false ; } String qtree Path = VOL ROOT + vol Name + STR_ + quota Dir Name ; if ( qtree Path . length ( ) > QUOTA DIR MAX PATH ) { log . error ( STR_ , qtree Path . length ( ) , QUOTA DIR MAX PATH ) ; return false ; } } return true ; }
public boolean approx Equals ( R 1 Interval y , double max Error ) { if ( is Empty ( ) ) { return y . get Length ( ) <= max Error ; } if ( y . is Empty ( ) ) { return get Length ( ) <= max Error ; } return Math . abs ( y . lo ( ) - lo ( ) ) + Math . abs ( y . hi ( ) - hi ( ) ) <= max Error ; }
public static String [ ] sha 256 md 5 Hashes ( String string ) throws No Such Algorithm Exception { return sha 256 md 5 Hashes ( string . get Bytes ( Standard Charsets . UTF 8 ) ) ; }
@ Override public synchronized void stop ( ) { if ( running ) { LOGGER . debug ( STR_ ) ; running = false ; shutdown Request Made = true ; while ( ! task Queue . is Empty ( ) ) { try { Thread . sleep ( NUM_ ) ; } catch ( Interrupted Exception ex ) { LOGGER . error ( STR_ , ex ) ; } } try { Thread . sleep ( THREAD SHUTDOWN CHECK INTERVAL ) ; } catch ( Interrupted Exception ex ) { LOGGER . error ( STR_ , ex ) ; } } }
static public Collection < Condition > replicate Conditions ( int nruns , Collection < Condition > conditions ) { List < Condition > ret = new Linked List < Condition > ( ) ; for ( Condition c : conditions ) { for ( int i = NUM_ ; i < nruns ; i ++ ) { ret . add ( c ) ; } } return ret ; }
public boolean is Header List ( ) { return false ; }
public static String slurp URL ( URL u ) throws IO Exception { String line Separator = System . get Property ( STR_ ) ; URL Connection uc = u . open Connection ( ) ; Input Stream is = uc . get Input Stream ( ) ; Buffered Reader br = new Buffered Reader ( new Input Stream Reader ( is ) ) ; String temp ; String Buffer buff = new String Buffer ( NUM_ ) ; while ( ( temp = br . read Line ( ) ) != null ) { buff . append ( temp ) ; buff . append ( line Separator ) ; } br . close ( ) ; return buff . to String ( ) ; }
private boolean service Has Sub Schema ( SSO Token token , String service Name , Schema Type schema Type ) throws SMS Exception , SSO Exception { boolean schema Type Flg = false ; try { Service Schema Manager ssm = new Service Schema Manager ( service Name , token ) ; Set types = ssm . get Schema Types ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + service Name + STR_ + types ) ; } schema Type Flg = types . contains ( schema Type ) ; } catch ( Service Not Found Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STR_ + STR_ + service Name ) ; } } return ( schema Type Flg ) ; }
public boolean has Descendant ( Set < String > variables ) { Queue < B Node > nodes To Process = new Linked List < B Node > ( ) ; nodes To Process . add ( this ) ; while ( ! nodes To Process . is Empty ( ) ) { B Node current Node = nodes To Process . poll ( ) ; for ( B Node descendant Node : current Node . get Output Nodes ( ) ) { if ( variables . contains ( descendant Node . get Id ( ) ) ) { return true ; } if ( ! nodes To Process . contains ( descendant Node ) ) { nodes To Process . add ( descendant Node ) ; } } } return false ; }
public long length ( ) throws IO Exception { if ( input Stream == null ) { throw new IO Exception ( STR_ ) ; } return input Stream Count + input Stream . available ( ) ; }
private int size ( ) { if ( is Leaf ( ) ) return points . size ( ) ; else return children . size ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public String global Info ( ) { return STR_ + STR_ + STR_ + STR_ + STR_ ; }
@ Override public Object clone ( ) throws Clone Not Supported Exception { Lookup Paint Scale clone = ( Lookup Paint Scale ) super . clone ( ) ; clone . lookup Table = new java . util . Array List ( this . lookup Table ) ; return clone ; }
private void bad Read ( int num Bytes ) throws Log Exception { throw new Log Exception ( STR_ + String . value Of ( length ) + STR_ + String . value Of ( num Bytes ) ) ; }
private void validate Group Acls ( DB Group target Group , List < DB Acl > acls ) throws Invalid Request Exception , SQL Exception { if ( acls . is Empty ( ) ) { throw new Invalid Request Exception ( STR_ ) ; } Hash Set < Integer > unique Member Identities = new Hash Set < > ( ) ; Hash Set < Integer > unique Member Groups = new Hash Set < > ( ) ; for ( DB Acl acl : acls ) { if ( acl . get Group Id ( ) . get Id ( ) != target Group . get Id ( ) ) { throw new Invalid Request Exception ( STR_ ) ; } boolean is Identity Acl = acl . get Member Identity Id ( ) != null ; boolean is Group Acl = acl . get Member Group Id ( ) != null ; if ( ! ( is Identity Acl ^ is Group Acl ) ) { throw new Invalid Request Exception ( STR_ + STR_ + is Identity Acl + STR_ + is Group Acl ) ; } if ( is Identity Acl ) { assert ! is Group Acl ; if ( ! unique Member Identities . add ( acl . get Member Identity Id ( ) . get Id ( ) ) ) { throw new Invalid Request Exception ( STR_ + acl . get Member Identity Id ( ) . get Id ( ) ) ; } } else { assert ! is Identity Acl ; if ( ! unique Member Groups . add ( acl . get Member Group Id ( ) . get Id ( ) ) ) { throw new Invalid Request Exception ( STR_ + acl . get Member Group Id ( ) . get Id ( ) ) ; } } } if ( ! unique Member Identities . is Empty ( ) ) { if ( DB Identity . get User Names From Ids ( manager , unique Member Identities ) . size ( ) != unique Member Identities . size ( ) ) { throw new Invalid Request Exception ( STR_ ) ; } } if ( ! unique Member Groups . is Empty ( ) ) { Query Builder < DB Group , Integer > group Query = get Directly Accessible Groups Query ( unique Member Groups ) ; if ( group Query . count Of ( ) != unique Member Groups . size ( ) ) { throw new Invalid Request Exception ( STR_ ) ; } } }
@ Override public boolean is Time Allowed ( Local Time time ) { return Picker Utilities . is Local Time In Range ( time , Local Time . of ( NUM_ , NUM_ ) , Local Time . of ( NUM_ , NUM_ ) , true ) ; }
public boolean is Zoomable ( ) { return zoomable ; }
public boolean is Account Grant Error ( ) { return ( error != null && error . equals Ignore Case ( ERROR INVALID GRANT ) ) ; }
private String read Name ( ) throws IO Exception , Xml Pull Parser Exception { if ( position >= limit && ! fill Buffer ( NUM_ ) ) { check Relaxed ( STR_ ) ; return STR_ ; } int start = position ; String Builder result = null ; char c = buffer [ position ] ; if ( ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || c == STR_ || c == STR_ || c >= STR_ || relaxed ) { position ++ ; } else { check Relaxed ( STR_ ) ; return STR_ ; } while ( true ) { if ( position >= limit ) { if ( result == null ) { result = new String Builder ( ) ; } result . append ( buffer , start , position - start ) ; if ( ! fill Buffer ( NUM_ ) ) { return result . to String ( ) ; } start = position ; } c = buffer [ position ] ; if ( ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || c == STR_ || c == STR_ || c == STR_ || c == STR_ || c >= STR_ ) { position ++ ; continue ; } if ( result == null ) { return string Pool . get ( buffer , start , position - start ) ; } else { result . append ( buffer , start , position - start ) ; return result . to String ( ) ; } } }
public static final String digits And Plus Only ( Matcher Compat matcher ) { String Builder buffer = new String Builder ( ) ; String matching Region = matcher . group ( ) ; for ( int i = NUM_ , size = matching Region . length ( ) ; i < size ; i ++ ) { char character = matching Region . char At ( i ) ; if ( character == STR_ || Character . is Digit ( character ) ) { buffer . append ( character ) ; } } return buffer . to String ( ) ; }
public Lattice < String > string Lattice ( ) { assert is Linear Chain ( ) ; return Lattice . create String Lattice From String ( source ( ) , config ) ; }
public static Unicode Script of ( int code Point ) { if ( ! is Valid Code Point ( code Point ) ) throw new Illegal Argument Exception ( ) ; int type = get Type ( code Point ) ; if ( type == UNASSIGNED ) return UNKNOWN ; int index = Arrays . binary Search ( script Starts , code Point ) ; if ( index < NUM_ ) index = - index - NUM_ ; return scripts [ index ] ; }
public char [ ] to Char Array ( ) { Entity e = root ; char [ ] chrs = new char [ size ( ) ] ; int off = NUM_ ; while ( e . next != null ) { e = e . next ; System . arraycopy ( e . data , NUM_ , chrs , off , e . data . length ) ; off += e . data . length ; } System . arraycopy ( buffer , NUM_ , chrs , off , pos ) ; return chrs ; }
public static String quote Replacement ( String s ) { String Builder result = new String Builder ( s . length ( ) ) ; for ( int i = NUM_ ; i < s . length ( ) ; i ++ ) { char c = s . char At ( i ) ; if ( c == STR_ || c == STR_ ) { result . append ( STR_ ) ; } result . append ( c ) ; } return result . to String ( ) ; }
public boolean contains ( String message ) { return get Message ( message , false ) != null ; }
public static String [ ] copy ( String [ ] array ) { if ( array != null ) { String [ ] copy = new String [ array . length ] ; System . arraycopy ( array , NUM_ , copy , NUM_ , array . length ) ; return copy ; } return null ; }
public Shape hexagon ( float x , float y , float height ) { float width = height / NUM_ ; m path . reset ( ) ; m path . move To ( x , y + NUM_ * height ) ; m path . line To ( x + NUM_ * width , y ) ; m path . line To ( x + NUM_ * width , y ) ; m path . line To ( x + NUM_ * width , y + NUM_ * height ) ; m path . line To ( x + NUM_ * width , y + height ) ; m path . line To ( x + NUM_ * width , y + height ) ; m path . close Path ( ) ; return m path ; }
public static void assert Empty ( Buffered Image image ) { assert Empty ( STR_ , image ) ; }
public static boolean is Stopword ( String str ) { return m Stopwords . is ( str . to Lower Case ( ) ) ; }
@ Override public boolean fire ( final Player player , final Sentence sentence , final Entity npc ) { String toadd = STR_ ; List < String > neededcreatures ; if ( allcreatures == null ) { neededcreatures = creatures ; } else { final String given Enemies = player . get Quest ( quest Slot , quest Group Index ) ; neededcreatures = allcreatures . get ( given Enemies ) ; } ; final String temp = player . get Quest ( quest Slot , quest Index ) ; if ( temp == null ) { return false ; } final List < String > tokens = Arrays . as List ( temp . split ( STR_ ) ) ; if ( ( tokens . size ( ) % NUM_ ) != NUM_ ) { logger . error ( STR_ + player . get Name ( ) + STR_ + quest Slot + STR_ + quest Index + STR_ + player . get Quest ( quest Slot ) + STR_ ) ; return true ; } Linked List < String > mycreatures = new Linked List < String > ( ) ; for ( int i = NUM_ ; i < tokens . size ( ) / NUM_ ; i ++ ) { mycreatures . add ( tokens . get ( i * NUM_ ) ) ; } for ( String monster : neededcreatures ) { if ( ! mycreatures . contains ( monster ) ) { if ( do update ) { toadd = toadd + STR_ + monster + STR_ ; logger . debug ( STR_ + monster + STR_ + player . get Name ( ) + STR_ + quest Slot + STR_ + Integer . to String ( quest Index ) + STR_ ) ; } else { return true ; } } } if ( do update && ! toadd . is Empty ( ) ) { String finalcreatures = temp + toadd ; logger . debug ( STR_ + player . get Name ( ) + STR_ + quest Slot + STR_ + Integer . to String ( quest Index ) + STR_ + finalcreatures + STR_ ) ; player . set Quest ( quest Slot , quest Index , finalcreatures ) ; } return false ; }
public boolean is Expired ( ) { return this . ttl == NUM_ ? false : this . ttl < System . current Time Millis ( ) ; }
public boolean is Started ( ) { return writer != null || nrt Replica Node != null || nrt Primary Node != null ; }
public float distance ( int x , int y ) { float distance = Float . POSITIVE INFINITY ; return distance ; }
static public Automaton concatenate ( List < Automaton > l ) { Automaton result = new Automaton ( ) ; for ( Automaton a : l ) { if ( a . get Num States ( ) == NUM_ ) { result . finish State ( ) ; return result ; } int num States = a . get Num States ( ) ; for ( int s = NUM_ ; s < num States ; s ++ ) { result . create State ( ) ; } } int state Offset = NUM_ ; Transition t = new Transition ( ) ; for ( int i = NUM_ ; i < l . size ( ) ; i ++ ) { Automaton a = l . get ( i ) ; int num States = a . get Num States ( ) ; Automaton next A = ( i == l . size ( ) - NUM_ ) ? null : l . get ( i + NUM_ ) ; for ( int s = NUM_ ; s < num States ; s ++ ) { int num Transitions = a . init Transition ( s , t ) ; for ( int j = NUM_ ; j < num Transitions ; j ++ ) { a . get Next Transition ( t ) ; result . add Transition ( state Offset + s , state Offset + t . dest , t . min , t . max ) ; } if ( a . is Accept ( s ) ) { Automaton follow A = next A ; int follow Offset = state Offset ; int upto = i + NUM_ ; while ( true ) { if ( follow A != null ) { num Transitions = follow A . init Transition ( NUM_ , t ) ; for ( int j = NUM_ ; j < num Transitions ; j ++ ) { follow A . get Next Transition ( t ) ; result . add Transition ( state Offset + s , follow Offset + num States + t . dest , t . min , t . max ) ; } if ( follow A . is Accept ( NUM_ ) ) { follow Offset += follow A . get Num States ( ) ; follow A = ( upto == l . size ( ) - NUM_ ) ? null : l . get ( upto + NUM_ ) ; upto ++ ; } else { break ; } } else { result . set Accept ( state Offset + s , true ) ; break ; } } } } state Offset += num States ; } if ( result . get Num States ( ) == NUM_ ) { result . create State ( ) ; } result . finish State ( ) ; return result ; }
public static String join ( Char Sequence delimiter , Iterable tokens ) { String Builder sb = new String Builder ( ) ; boolean first Time = true ; for ( Object token : tokens ) { if ( token == null || is Empty ( token . to String ( ) ) ) { continue ; } if ( first Time ) { first Time = false ; } else { sb . append ( delimiter ) ; } sb . append ( token . to String ( ) ) ; } if ( first Time ) { return null ; } return sb . to String ( ) ; }
static Permissions create Permissions ( Environment environment ) throws IO Exception { Permissions policy = new Permissions ( ) ; add Classpath Permissions ( policy ) ; add File Permissions ( policy , environment ) ; return policy ; }
public static Range find Stacked Range Bounds ( Table XY Dataset dataset , double base ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; double minimum = base ; double maximum = base ; for ( int item No = NUM_ ; item No < dataset . get Item Count ( ) ; item No ++ ) { double positive = base ; double negative = base ; int series Count = dataset . get Series Count ( ) ; for ( int series No = NUM_ ; series No < series Count ; series No ++ ) { double y = dataset . get Y Value ( series No , item No ) ; if ( ! Double . is Na N ( y ) ) { if ( y > NUM_ ) { positive += y ; } else { negative += y ; } } } if ( positive > maximum ) { maximum = positive ; } if ( negative < minimum ) { minimum = negative ; } } if ( minimum <= maximum ) { return new Range ( minimum , maximum ) ; } else { return null ; } }
public Char Sequence format ( ) { if ( pieces . is Empty ( ) ) { return input ; } String target ; for ( Piece piece : pieces ) { target = BRACE START + piece . get Key ( ) + BRACE END ; input = input . replace ( target , String . value Of ( piece . get Value ( ) ) ) ; } return input ; }
public Point Cloud Data update And Get Latest Point Cloud Render Buffer ( ) { synchronized ( Point Cloud Manager . m Point Cloud Lock ) { if ( m Swap Signal ) { Float Buffer temp = m Render Point Cloud Data . float Buffer ; int temp Count = m Render Point Cloud Data . point Count ; m Render Point Cloud Data . float Buffer = m Shared Point Cloud Data . float Buffer ; m Render Point Cloud Data . point Count = m Shared Point Cloud Data . point Count ; m Shared Point Cloud Data . float Buffer = temp ; m Shared Point Cloud Data . point Count = temp Count ; m Swap Signal = false ; } } return m Render Point Cloud Data ; }
public boolean is Gen Class ( String clz ) { return gen Classes . contains ( clz ) ; }
public boolean allow Trailing Edges ( ) { return pattern Element . allow Trailing Edges ( ) ; }
public static Verb normalize Regular Verb ( final String word ) { Verb verb = null ; if ( ( word . length ( ) > NUM_ ) && ( word . ends With ( STR_ ) || word . ends With ( STR_ ) ) ) { if ( word . char At ( word . length ( ) - NUM_ ) == word . char At ( word . length ( ) - NUM_ ) ) { verb = new Verb ( word . substring ( NUM_ , word . length ( ) - NUM_ ) ) ; } else { verb = new Verb ( word . substring ( NUM_ , word . length ( ) - NUM_ ) ) ; } if ( word . ends With ( STR_ ) ) { verb . is Past = true ; } } else if ( word . length ( ) > NUM_ && word . ends With ( STR_ ) && ! Grammar . is Vowel ( word . char At ( word . length ( ) - NUM_ ) ) ) { verb = new Verb ( word . substring ( NUM_ , word . length ( ) - NUM_ ) ) ; } else if ( is Gerund ( word ) ) { verb = new Verb ( word . substring ( NUM_ , word . length ( ) - NUM_ ) ) ; verb . is Gerund = true ; } return verb ; }
public Info Bar Transition Info find Last Transition For Info Bar ( Info Bar to Find ) { Iterator < Info Bar Transition Info > iterator = m Info Bar Transitions . descending Iterator ( ) ; while ( iterator . has Next ( ) ) { Info Bar Transition Info info = iterator . next ( ) ; if ( info . target == to Find ) return info ; } return null ; }
public boolean is Completed ( ) { for ( Aborting Runnable ar : tasks ) { synchronized ( ar ) { if ( ! ar . done ) { return false ; } } } return true ; }
public boolean is Match ( Path Impl path , String prefix ) { String suffix = STR_ ; String full Path = path . get Path ( ) ; if ( prefix . length ( ) < full Path . length ( ) ) { suffix = full Path . substring ( prefix . length ( ) ) ; } for ( int i = NUM_ ; i < exclude List . size ( ) ; i ++ ) { Path Pattern Type pattern = exclude List . get ( i ) ; if ( pattern . is Match ( suffix ) ) return false ; } if ( include List == null ) return true ; for ( int i = NUM_ ; i < include List . size ( ) ; i ++ ) { Path Pattern Type pattern = include List . get ( i ) ; if ( pattern . is Match ( suffix ) ) { return true ; } } return false ; }
public Revision next ( ) { try { Revision revision = new Revision ( result . get Int ( NUM_ ) ) ; this . primary Key = result . get Int ( NUM_ ) ; revision . set Primary Key ( this . primary Key ) ; revision . set Revision ID ( result . get Int ( NUM_ ) ) ; revision . set Article ID ( result . get Int ( NUM_ ) ) ; revision . set Time Stamp ( new Timestamp ( result . get Long ( NUM_ ) ) ) ; revision . set Full Revision ID ( result . get Int ( NUM_ ) ) ; return revision ; } catch ( Exception e ) { e . print Stack Trace ( ) ; throw new Runtime Exception ( e ) ; } }
protected Snmp Cached Data update Cached Datas ( Object user Data ) { final String [ ] args = Jvm Runtime Impl . get Input Arguments ( user Data ) ; final long time = System . current Time Millis ( ) ; Snmp Oid indexes [ ] = new Snmp Oid [ args . length ] ; for ( int i = NUM_ ; i < args . length ; i ++ ) { indexes [ i ] = new Snmp Oid ( i + NUM_ ) ; } return new Snmp Cached Data ( time , indexes , args ) ; }
static int compute Retained Items ( int k , long n ) { int bb Cnt = compute Base Buffer Items ( k , n ) ; long bit Pattern = compute Bit Pattern ( k , n ) ; int valid Levels = Long . bit Count ( bit Pattern ) ; return bb Cnt + valid Levels * k ; }
public static double pchisq ( double x , double ncp ) { double mean = Math . sqrt ( ncp ) ; double xh = Math . sqrt ( x ) ; return pnorm ( xh - mean ) - pnorm ( - xh - mean ) ; }
public Char Seq trim ( ) { return Char Seq . of ( str . trim ( ) ) ; }
public static boolean is Left Mouse Button ( Mouse Event an Event ) { return ( ( an Event . get Modifiers Ex ( ) & Input Event . BUTTON 1 DOWN MASK ) != NUM_ || an Event . get Button ( ) == Mouse Event . BUTTON 1 ) ; }
public static Int Stream of ( int ... values ) { return Arrays . stream ( values ) ; }
public String models To String ( ) { String Buffer text = new String Buffer ( ) ; if ( m is Leaf ) { text . append ( STR_ + m leaf Model Num + STR_ + super . to String ( ) ) ; } else { for ( LMT Node m son : m sons ) { text . append ( STR_ + m son . models To String ( ) ) ; } } return text . to String ( ) ; }
public static String class Name Only ( String cname ) { String s = STR_ ; if ( cname != null ) { s = cname . substring ( cname . last Index Of ( STR_ ) + NUM_ ) ; } return s ; }
private static int st To IJ ( double s ) { final int m = MAX SIZE / NUM_ ; return ( int ) Math . max ( NUM_ , Math . min ( NUM_ * m - NUM_ , Math . round ( m * s + ( m - NUM_ ) ) ) ) ; }
private Rectangle 2 D view To Frame ( Rectangle 2 D view ) { double width = view . get Width ( ) / this . view W ; double height = view . get Height ( ) / this . view H ; double x = view . get X ( ) - ( width * this . view X ) ; double y = view . get Y ( ) - ( height * this . view Y ) ; return new Rectangle 2 D . Double ( x , y , width , height ) ; }
private static boolean edge Intersects Cell Boundary ( S 2 Point a , S 2 Point b , S 2 Cell cell ) { S 2 Point [ ] vertices = new S 2 Point [ NUM_ ] ; for ( int i = NUM_ ; i < NUM_ ; ++ i ) { vertices [ i ] = cell . get Vertex ( i ) ; } for ( int i = NUM_ ; i < NUM_ ; ++ i ) { S 2 Point from Point = vertices [ i ] ; S 2 Point to Point = vertices [ ( i + NUM_ ) % NUM_ ] ; if ( lenient Crossing ( a , b , from Point , to Point ) ) { return true ; } } return false ; }
protected List create Stacked Value List ( Category Dataset dataset , Comparable category , int [ ] included Rows , double base , boolean as Percentages ) { List result = new Array List ( ) ; double pos Base = base ; double neg Base = base ; double total = NUM_ ; if ( as Percentages ) { total = Data Utilities . calculate Column Total ( dataset , dataset . get Column Index ( category ) , included Rows ) ; } int base Index = - NUM_ ; int row Count = included Rows . length ; for ( int i = NUM_ ; i < row Count ; i ++ ) { int r = included Rows [ i ] ; Number n = dataset . get Value ( dataset . get Row Key ( r ) , category ) ; if ( n == null ) { continue ; } double v = n . double Value ( ) ; if ( as Percentages ) { v = v / total ; } if ( ( v > NUM_ ) || ( ! this . ignore Zero Values && v >= NUM_ ) ) { if ( base Index < NUM_ ) { result . add ( new Object [ ] { null , new Double ( base ) } ) ; base Index = NUM_ ; } pos Base = pos Base + v ; result . add ( new Object [ ] { new Integer ( r ) , new Double ( pos Base ) } ) ; } else if ( v < NUM_ ) { if ( base Index < NUM_ ) { result . add ( new Object [ ] { null , new Double ( base ) } ) ; base Index = NUM_ ; } neg Base = neg Base + v ; result . add ( NUM_ , new Object [ ] { new Integer ( - r - NUM_ ) , new Double ( neg Base ) } ) ; base Index ++ ; } } return result ; }
@ Not Null public List < ? extends Module Level Builder > create Module Level Builders ( ) { return Collections . empty List ( ) ; }
public Input Stream read ( ) { return new Byte Array Input Stream ( data ) ; }
private static String parse Percentage ( String text ) { Matcher m = percentage Pattern . matcher ( text ) ; return m . matches ( ) ? m . group ( NUM_ ) + STR_ : null ; }
public Array Deque < E > clone ( ) { try { @ Suppress Warnings ( STR_ ) Array Deque < E > result = ( Array Deque < E > ) super . clone ( ) ; result . elements = Arrays . copy Of ( elements , elements . length ) ; return result ; } catch ( Clone Not Supported Exception e ) { throw new Assertion Error ( ) ; } }
public static java . lang . String value Of ( int i ) { return Integer . to String ( i ) ; }
public double range Scan ( final long range Count , final int m , final int h , final int leaf Utilization ) { if ( range Count == NUM_ ) return NUM_ ; final double average Seek Time = Math . max ( NUM_ , ( h - NUM_ ) ) * disk Cost Model . seek Time ; final double leaf Fill Rate = ( ( double ) leaf Utilization ) / NUM_ ; final double expected Leaf Count = Math . ceil ( ( ( ( double ) range Count ) / m ) * Math . min ( NUM_ , ( NUM_ / leaf Fill Rate ) ) ) ; final double estimated Cost = average Seek Time * expected Leaf Count ; return estimated Cost ; }
public URL Connection open Connection ( Proxy proxy ) throws IO Exception { if ( proxy == null ) { throw new Illegal Argument Exception ( STR_ ) ; } return stream Handler . open Connection ( this , proxy ) ; }
public static Accessibility Node Info Compat search From Bfs ( Context context , Accessibility Node Info Compat node , Node Filter filter ) { if ( node == null ) { return null ; } final Linked List < Accessibility Node Info Compat > queue = new Linked List < Accessibility Node Info Compat > ( ) ; queue . add ( Accessibility Node Info Compat . obtain ( node ) ) ; while ( ! queue . is Empty ( ) ) { final Accessibility Node Info Compat item = queue . remove First ( ) ; if ( filter . accept ( context , item ) ) { return Accessibility Node Info Compat . obtain ( item ) ; } final int child Count = item . get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final Accessibility Node Info Compat child = item . get Child ( i ) ; if ( child != null ) { queue . add Last ( child ) ; } } } return null ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public static Named List read From Resource Loader ( Solr Resource Loader loader , String name ) { Input Stream Reader reader ; try { reader = new Input Stream Reader ( loader . open Resource ( name ) , Standard Charsets . UTF 8 ) ; } catch ( Solr Resource Not Found Exception ex ) { log . debug ( STR_ + ex . get Message ( ) ) ; return null ; } catch ( Exception ex ) { throw new Solr Exception ( Error Code . SERVER ERROR , STR_ + name , ex ) ; } try { return read From Input Stream ( reader ) ; } finally { IO Utils . close Quietly ( reader ) ; } }
protected int [ ] determine Indices ( int num Attributes ) throws Exception { int [ ] result ; Vector < Integer > list ; int i ; String Tokenizer tok ; String token ; String [ ] range ; int from ; int to ; list = new Vector < Integer > ( ) ; tok = new String Tokenizer ( m New Order Cols , STR_ ) ; while ( tok . has More Tokens ( ) ) { token = tok . next Token ( ) ; if ( token . index Of ( STR_ ) > - NUM_ ) { range = token . split ( STR_ ) ; if ( range . length != NUM_ ) { throw new Illegal Argument Exception ( STR_ + token + STR_ ) ; } from = determine Index ( range [ NUM_ ] , num Attributes ) ; to = determine Index ( range [ NUM_ ] , num Attributes ) ; if ( from <= to ) { for ( i = from ; i <= to ; i ++ ) { list . add ( i ) ; } } else { for ( i = from ; i >= to ; i -- ) { list . add ( i ) ; } } } else { list . add ( determine Index ( token , num Attributes ) ) ; } } result = new int [ list . size ( ) ] ; for ( i = NUM_ ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
@ Nullable public Rule Type matching Rule ( Proto Element elem ) { Rule Type result = rule Map . get ( elem ) ; if ( result != null ) { return result ; } for ( int i = rules . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Rule Wrapper < Rule Type > rule Wrapper = rules . get ( i ) ; String matched Selector = rule Wrapper . get Matched Selector ( elem ) ; if ( matched Selector != null ) { rule Map . put ( elem , rule Wrapper . rule ) ; if ( unmatched Rules . contains Key ( rule Wrapper ) ) { Set < String > unmatched Selectors = unmatched Rules . get ( rule Wrapper ) ; unmatched Selectors . remove ( matched Selector ) ; if ( unmatched Selectors . is Empty ( ) ) { unmatched Rules . remove ( rule Wrapper ) ; } } return rule Wrapper . rule ; } } return null ; }
public JSON Object to JSON Object ( ) throws JSON Exception { JSON Object jo = new JSON Object ( ) ; jo . put ( STR_ , property Name ) ; jo . put ( STR_ , property Values ) ; jo . put ( STR_ , p Response Provider Name ) ; return jo ; }
public boolean has Node ( String node Id ) { return nodes . contains Key ( node Id ) ; }
public static byte [ ] expand ( byte [ ] field , int new Size , boolean keep Data ) { if ( field == null || field . length < new Size ) { byte [ ] new Array = new byte [ new Size ] ; if ( keep Data && field != null ) { System . arraycopy ( field , NUM_ , new Array , NUM_ , field . length ) ; } return new Array ; } return field ; }
public boolean is Assignable ( @ Nullable Object value ) { if ( value == null ) { return is Null Value Allowed ( ) ; } return clazz . is Instance ( value ) ; }
public static String no Quote ( String input ) { if ( input . contains ( STR_ ) ) { throw new Illegal Argument Exception ( STR_ + input + STR_ ) ; } else { return input ; } }
public static String [ ] from List ( String url List ) throws Naming Exception { String [ ] urls = new String [ ( url List . length ( ) + NUM_ ) / NUM_ ] ; int i = NUM_ ; String Tokenizer st = new String Tokenizer ( url List , STR_ ) ; while ( st . has More Tokens ( ) ) { urls [ i ++ ] = st . next Token ( ) ; } String [ ] trimmed = new String [ i ] ; System . arraycopy ( urls , NUM_ , trimmed , NUM_ , i ) ; return trimmed ; }
final Dialog Option show Yes No Cancel Message ( String message ) { int option ; try { option = J Option Pane . show Confirm Dialog ( get Parent Component ( ) , get Label ( message ) , I 18 n . tr ( STR_ ) , J Option Pane . YES NO CANCEL OPTION ) ; } catch ( Internal Error ie ) { option = J Option Pane . NO OPTION ; } if ( option == J Option Pane . YES OPTION ) return Dialog Option . YES ; else if ( option == J Option Pane . NO OPTION ) return Dialog Option . NO ; return Dialog Option . CANCEL ; }
public String tail File ( File file , boolean problems Only ) throws IO Exception { byte buffer [ ] = new byte [ NUM_ ] ; int read Size = buffer . length ; Random Access File f = new Random Access File ( file , STR_ ) ; long length = f . length ( ) ; if ( length < read Size ) { read Size = ( int ) length ; } long seek Offset = length - read Size ; f . seek ( seek Offset ) ; if ( read Size != f . read ( buffer , NUM_ , read Size ) ) { throw new EOF Exception ( STR_ + read Size + STR_ + file . get Absolute Path ( ) ) ; } f . close ( ) ; int msg Start = - NUM_ ; int msg End = read Size ; for ( int i = read Size - NUM_ ; i >= NUM_ ; i -- ) { if ( buffer [ i ] == STR_ && ( buffer [ i + NUM_ ] == STR_ || buffer [ i + NUM_ ] == STR_ || buffer [ i + NUM_ ] == STR_ ) && i > NUM_ && ( buffer [ i - NUM_ ] == STR_ || buffer [ i - NUM_ ] == STR_ ) ) { msg Start = i ; break ; } } if ( msg Start == - NUM_ ) { if ( problems Only ) { return null ; } for ( int i = read Size - NUM_ ; i >= NUM_ ; i -- ) { if ( buffer [ i ] == STR_ || buffer [ i ] == STR_ ) { msg Start = ( buffer [ i ] == STR_ ) ? ( i + NUM_ ) : ( i + NUM_ ) ; break ; } } if ( msg Start == - NUM_ ) { msg Start = NUM_ ; } } else { for ( int i = msg Start + NUM_ ; i < read Size ; i ++ ) { if ( buffer [ i ] == STR_ && ( buffer [ i - NUM_ ] == STR_ || buffer [ i - NUM_ ] == STR_ ) ) { msg End = i ; break ; } } } for ( int i = msg Start ; i < msg End ; i ++ ) { if ( buffer [ i ] == STR_ || buffer [ i ] == STR_ ) { buffer [ i ] = STR_ ; } } return new String ( buffer , msg Start , msg End - msg Start ) ; }
public boolean belongs ( I Package Fragment fragment ) { if ( fragment == null ) return false ; if ( f Java Project . equals ( fragment . get Java Project ( ) ) ) { return f Name . equals ( fragment . get Element Name ( ) ) ; } return false ; }
public static int [ ] rand Permute ( int floor , int ceil ) { int [ ] permute = new int [ ceil - floor ] ; Random randi = new Random ( ) ; for ( int i = floor ; i < ceil ; i ++ ) { int j = randi . next Int ( i - floor + NUM_ ) ; if ( j != i - floor ) { permute [ i - floor ] = permute [ j ] ; } permute [ j ] = i ; } return permute ; }
public boolean contains ( byte [ ] bytes ) { int [ ] hashes = create Hashes ( bytes , k , get New Digest Function ( ) ) ; for ( int hash : hashes ) { if ( ! bitset . get ( Math . abs ( hash % bit Set Size ) ) ) { return false ; } } return true ; }
public static boolean is Project Style ( @ Not Null String style Resource Url ) { return ! style Resource Url . starts With ( ANDROID STYLE RESOURCE PREFIX ) ; }
public static String internal Stock Fish Name ( ) { String abi = Build . CPU ABI ; boolean no PIE = Build . VERSION . SDK INT < NUM_ ; if ( abi . equals ( STR_ ) ) { } else if ( abi . equals ( STR_ ) ) { no PIE = false ; } else if ( abi . equals ( STR_ ) ) { } else if ( abi . equals ( STR_ ) ) { no PIE = false ; } else if ( abi . equals ( STR_ ) ) { } else if ( abi . equals ( STR_ ) ) { no PIE = false ; } else { abi = STR_ ; } return STR_ + abi + ( no PIE ? STR_ : STR_ ) ; }
public static double two Pow ( final int power ) { if ( power <= - MAX DOUBLE EXPONENT ) { if ( power >= MIN DOUBLE EXPONENT ) { return Double . long Bits To Double ( NUM_ > > - ( power + MAX DOUBLE EXPONENT ) ) ; } else { return NUM_ ; } } else if ( power > MAX DOUBLE EXPONENT ) { return Double . POSITIVE INFINITY ; } else { return Double . long Bits To Double ( ( long ) ( power + MAX DOUBLE EXPONENT ) << NUM_ ) ; } }
public boolean has Resources ( ) { return ( disco Data != null ) && ! disco Data . is Empty ( ) ; }
public String print Configuration ( Custom Configuration config ) { return config . to String Multi Line ( true ) ; }
public boolean has Unsupported Critical Extension ( ) { Set extns = get Critical Extension OI Ds ( ) ; if ( extns == null ) { return false ; } extns . remove ( RFC 3280 Cert Path Utilities . ISSUING DISTRIBUTION POINT ) ; extns . remove ( RFC 3280 Cert Path Utilities . DELTA CRL INDICATOR ) ; return ! extns . is Empty ( ) ; }
public void run ( Paragraph paragraph , String app Id ) { executor . execute ( new Run Application ( paragraph , app Id ) ) ; }
public static int match ( String buf , String [ ] regexs , String [ ] groups , int flags ) { int index = NUM_ ; for ( String regex : regexs ) { Pattern p = Pattern . compile ( regex , flags ) ; Matcher m = p . matcher ( buf ) ; if ( m . matches ( ) ) { int ngroups = m . group Count ( ) ; for ( int j = NUM_ ; j <= ngroups ; j ++ ) { groups [ j - NUM_ ] = m . group ( j ) ; } return index ; } index ++ ; } return - NUM_ ; }
static void handle Exception ( final Throwable e ) { if ( e instanceof Error && ! ( e instanceof Linkage Error || e instanceof Out Of Memory Error || e instanceof Stack Overflow Error ) ) { throw ( Error ) e ; } logger . log ( Level . INFO , STR_ , e ) ; }
private int find Closest Chunk ( int chunk Size ) { int x = NUM_ ; for ( ; x <= chunk Size ; x = x * NUM_ ) ; return x ; }
@ Override public int hash Code ( ) { int result ; long temp ; temp = Double . double To Long Bits ( this . x ) ; result = ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . y ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . display Width ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . display Height ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; return result ; }
public boolean check Pending Deletions ( ) throws IO Exception { delete Pending Files ( ) ; return pending Deletes . is Empty ( ) == false ; }
public String to HTML ( ) { List < Test Case > failed = get Failed Test Cases ( ) ; List < Test Case > passed = get Passed Test Cases ( ) ; List < Test Case > skipped = get Skipped Test Cases ( ) ; String Buffer buff = new String Buffer ( ) ; for ( Test Case tc : failed ) { buff . append ( tc . to HTML ( ) ) ; } for ( Test Case tc : passed ) { buff . append ( tc . to HTML ( ) ) ; } for ( Test Case tc : skipped ) { buff . append ( tc . to HTML ( ) ) ; } Object [ ] params = { name , buff . to String ( ) } ; return Message Format . format ( HTML Constants . TEST TABLE , params ) ; }
public static List < String > format Date List ( List < Date > date List ) { List < String > new List = new Array List < String > ( ) ; for ( Date date : date List ) new List . add ( format Date ( date ) ) ; return new List ; }
public boolean verify Signature ( byte [ ] signature ) { byte [ ] block = null ; if ( pre Sig == null ) { try { block = cipher . process Block ( signature , NUM_ , signature . length ) ; } catch ( Exception e ) { return false ; } } else { if ( ! Arrays . are Equal ( pre Sig , signature ) ) { throw new Illegal State Exception ( STR_ ) ; } block = pre Block ; pre Sig = null ; pre Block = null ; } if ( ( ( block [ NUM_ ] & NUM_ ) ^ NUM_ ) != NUM_ ) { return return False ( block ) ; } if ( ( ( block [ block . length - NUM_ ] & NUM_ ) ^ NUM_ ) != NUM_ ) { return return False ( block ) ; } int delta = NUM_ ; if ( ( ( block [ block . length - NUM_ ] & NUM_ ) ^ NUM_ ) == NUM_ ) { delta = NUM_ ; } else { int sig Trail = ( ( block [ block . length - NUM_ ] & NUM_ ) << NUM_ ) | ( block [ block . length - NUM_ ] & NUM_ ) ; Integer trailer Obj = ( Integer ) trailer Map . get ( digest . get Algorithm Name ( ) ) ; if ( trailer Obj != null ) { if ( sig Trail != trailer Obj . int Value ( ) ) { throw new Illegal State Exception ( STR_ + sig Trail ) ; } } else { throw new Illegal Argument Exception ( STR_ ) ; } delta = NUM_ ; } int m Start = NUM_ ; for ( m Start = NUM_ ; m Start != block . length ; m Start ++ ) { if ( ( ( block [ m Start ] & NUM_ ) ^ NUM_ ) == NUM_ ) { break ; } } m Start ++ ; byte [ ] hash = new byte [ digest . get Digest Size ( ) ] ; int off = block . length - delta - hash . length ; if ( ( off - m Start ) <= NUM_ ) { return return False ( block ) ; } if ( ( block [ NUM_ ] & NUM_ ) == NUM_ ) { full Message = true ; if ( message Length > off - m Start ) { return return False ( block ) ; } digest . reset ( ) ; digest . update ( block , m Start , off - m Start ) ; digest . do Final ( hash , NUM_ ) ; boolean is Okay = true ; for ( int i = NUM_ ; i != hash . length ; i ++ ) { block [ off + i ] ^= hash [ i ] ; if ( block [ off + i ] != NUM_ ) { is Okay = false ; } } if ( ! is Okay ) { return return False ( block ) ; } recovered Message = new byte [ off - m Start ] ; System . arraycopy ( block , m Start , recovered Message , NUM_ , recovered Message . length ) ; } else { full Message = false ; digest . do Final ( hash , NUM_ ) ; boolean is Okay = true ; for ( int i = NUM_ ; i != hash . length ; i ++ ) { block [ off + i ] ^= hash [ i ] ; if ( block [ off + i ] != NUM_ ) { is Okay = false ; } } if ( ! is Okay ) { return return False ( block ) ; } recovered Message = new byte [ off - m Start ] ; System . arraycopy ( block , m Start , recovered Message , NUM_ , recovered Message . length ) ; } if ( message Length != NUM_ ) { if ( ! is Same As ( m Buf , recovered Message ) ) { return return False ( block ) ; } } clear Block ( m Buf ) ; clear Block ( block ) ; return true ; }
public boolean toggle ( Long key ) { if ( contains ( key ) ) { remove ( key ) ; return false ; } else { add ( key ) ; return true ; } }
public Collection values ( ) { process Queue ( ) ; return map . values ( ) ; }
public Iterator < Tree Node > find Children ( String name ) { List < Tree Node > results ; if ( children == null ) results = Collections . empty List ( ) ; else { results = new Array List < Tree Node > ( ) ; for ( Tree Node item : children ) { if ( name . equals ( item . get Name ( ) ) ) results . add ( item ) ; } } return results . iterator ( ) ; }
public Iterator < Drawable > iterator ( ) { return components . iterator ( ) ; }
public static boolean has Err Found ( ) { synchronized ( worker Lock ) { return ( err Found By Thread != - NUM_ ) ; } }
public String Set clone ( ) { String Set result = new String Set ( ) ; for ( int i = NUM_ ; i < contents . size ( ) ; i ++ ) { result . add ( contents . element At ( i ) ) ; } return result ; }
private String generate Query ( ) { final String Buffer query = new String Buffer ( NUM_ ) ; final String columns To Show = STR_ + STR_ + STR_ + Works Constants . NEW + STR_ + Works Constants . CANCELLED STATUS + STR_ + STR_ + Works Constants . NEW + STR_ + Works Constants . CANCELLED STATUS + STR_ + STR_ + Works Constants . TENDER DOCUMENT RELEASED + STR_ + STR_ ; final String columns To Show When WOE Is Joined = STR_ + STR_ + STR_ + Works Constants . NEW + STR_ + Works Constants . CANCELLED STATUS + STR_ + STR_ + Works Constants . NEW + STR_ + Works Constants . CANCELLED STATUS + STR_ + STR_ + Works Constants . TENDER DOCUMENT RELEASED + STR_ + STR_ + STR_ + STR_ + STR_ + Works Constants . WO STATUS WOCOMMENCED + STR_ ; if ( contractor Id != null && contractor Id != - NUM_ ) { query . append ( STR_ + columns To Show When WOE Is Joined + STR_ ) ; query . append ( STR_ + contractor Id ) ; query . append ( STR_ ) ; } else { query . append ( STR_ + columns To Show + STR_ ) ; query . append ( STR_ ) ; } query . append ( STR_ + Works Constants . NEW + STR_ + Works Constants . CANCELLED STATUS + STR_ ) ; if ( zone Id != null && zone Id != - NUM_ ) query . append ( STR_ + zone Id ) ; if ( ward Id != null && ward Id != - NUM_ ) query . append ( STR_ + ward Id ) ; if ( category != null && category != - NUM_ ) query . append ( STR_ + category ) ; else if ( parent Category != null && parent Category != - NUM_ ) query . append ( STR_ + parent Category ) ; if ( expenditure Type != null && expenditure Type != - NUM_ ) query . append ( STR_ + expenditure Type ) ; if ( String Utils . is Not Blank ( estimatenumber ) ) query . append ( STR_ + estimatenumber . to Upper Case ( ) + STR_ ) ; query . append ( STR_ ) ; return query . to String ( ) ; }
public static < T > Completable Future < T > wait For All ( List < Completable Future < T > > futures ) { if ( futures . is Empty ( ) ) { return Completable Future . completed Future ( null ) ; } final Completable Future < T > composite Future = new Completable Future < > ( ) ; final Atomic Integer count = new Atomic Integer ( futures . size ( ) ) ; final Atomic Reference < Throwable > exception = new Atomic Reference < > ( ) ; for ( Completable Future < T > future : futures ) { future . when Complete ( null ) ; } return composite Future ; }
public String read System Stat ( ) { Random Access File reader = null ; String load = null ; try { reader = new Random Access File ( STR_ , STR_ ) ; load = reader . read Line ( ) ; } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; } finally { } return load ; }
public static boolean is Maven Module ( String name ) { return name != null && name . index Of ( STR_ ) != - NUM_ ; }
@ Override public Node item ( int index ) { Node this Node ; if ( root Node . changes ( ) != changes ) { nodes = new Array List ( ) ; changes = root Node . changes ( ) ; } final int current Size = nodes . size ( ) ; if ( index < current Size ) { return ( Node ) nodes . get ( index ) ; } else { if ( current Size == NUM_ ) { this Node = root Node ; } else { this Node = ( Node Impl ) ( nodes . get ( current Size - NUM_ ) ) ; } while ( this Node != null && index >= nodes . size ( ) ) { this Node = next Matching Element After ( this Node ) ; if ( this Node != null ) { nodes . add ( this Node ) ; } } return this Node ; } }
public static int length ( Reg Exp re ) { Reg Exp 2 r ; switch ( re . type ) { case sym . BAR : { r = ( Reg Exp 2 ) re ; int l 1 = length ( r . r 1 ) ; if ( l 1 < NUM_ ) return - NUM_ ; int l 2 = length ( r . r 2 ) ; if ( l 1 == l 2 ) return l 1 ; else return - NUM_ ; } case sym . CONCAT : { r = ( Reg Exp 2 ) re ; int l 1 = length ( r . r 1 ) ; if ( l 1 < NUM_ ) return - NUM_ ; int l 2 = length ( r . r 2 ) ; if ( l 2 < NUM_ ) return - NUM_ ; return l 1 + l 2 ; } case sym . STAR : case sym . PLUS : case sym . QUESTION : return - NUM_ ; case sym . CCLASS : case sym . CCLASSNOT : case sym . CHAR : case sym . CHAR I : return NUM_ ; case sym . STRING : case sym . STRING I : { String content = ( String ) ( ( Reg Exp 1 ) re ) . content ; return content . length ( ) ; } case sym . TILDE : case sym . BANG : return - NUM_ ; case sym . MACROUSE : return length ( macros . get Definition ( ( String ) ( ( Reg Exp 1 ) re ) . content ) ) ; } throw new Error ( STR_ + re . type + STR_ + re ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ + STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private boolean is Sort Order Ascending ( final Optional < String > sort By ) { if ( sort By . is Present ( ) ) { String sort Column = sort By . get ( ) ; return ! sort Column . starts With ( SORT ORDER DESC ) ; } else { return false ; } }
static String Builder new String Builder For Collection ( int size ) { check Nonnegative ( size , STR_ ) ; return new String Builder ( ( int ) Math . min ( size * NUM_ , Ints . MAX POWER OF TWO ) ) ; }
public static boolean is Network Available ( Context context ) { Connectivity Manager connectivity Manager = ( Connectivity Manager ) context . get System Service ( Context . CONNECTIVITY SERVICE ) ; Network Info info = connectivity Manager . get Active Network Info ( ) ; return ( info != null && info . is Connected ( ) ) ; }
public int selectors Count ( ) { return selectors . size ( ) ; }
public static Collection < String > names ( Flags flags ) { final Collection < String > results = new Array List < String > ( ) ; if ( flags . contains ( Flags . Flag . ANSWERED ) ) { results . add ( ANSWERED OUTPUT CAPITALISED ) ; } if ( flags . contains ( Flags . Flag . DELETED ) ) { results . add ( DELETED OUTPUT CAPITALISED ) ; } if ( flags . contains ( Flags . Flag . DRAFT ) ) { results . add ( DRAFT OUTPUT CAPITALISED ) ; } if ( flags . contains ( Flags . Flag . FLAGGED ) ) { results . add ( FLAGGED OUTPUT CAPITALISED ) ; } if ( flags . contains ( Flags . Flag . RECENT ) ) { results . add ( RECENT OUTPUT CAPITALISED ) ; } if ( flags . contains ( Flags . Flag . SEEN ) ) { results . add ( SEEN OUTPUT CAPITALISED ) ; } String [ ] user Flags = flags . get User Flags ( ) ; Collections . add All ( results , user Flags ) ; if ( flags . contains ( Flags . Flag . USER ) ) { results . add ( USER OUTPUT CAPITALISED ) ; } return results ; }
public static double log 2 ( double a ) { if ( a == NUM_ ) return NUM_ ; return Math . log ( a ) / log 2 ; }
final public void halted ( ) { if ( halt ) { throw new Runtime Exception ( first Cause . get ( ) ) ; } }
@ Override public boolean is Running ( ) { return ! paused ; }
@ Not Null public List < Gradle Coordinate > find Missing Dependencies ( @ Not Null Module module , @ Not Null Iterable < Gradle Coordinate > dependencies ) { Gradle Build Model build Model = Gradle Build Model . get ( module ) ; if ( build Model == null ) { return Collections . empty List ( ) ; } return find Missing Libraries From Gradle Build File ( build Model , dependencies ) ; }
@ Override public double [ ] [ ] predict Intervals ( double conf ) { update Width ( ) ; double val = Statistics . normal Inverse ( NUM_ - ( NUM_ - conf ) / NUM_ ) ; double min = m TM . first Key ( ) - val * m Width ; double max = m TM . last Key ( ) + val * m Width ; double delta = ( max - min ) / m Num Intervals ; double [ ] probabilities = new double [ m Num Intervals ] ; double left Val = Math . exp ( log Density ( min ) ) ; for ( int i = NUM_ ; i < m Num Intervals ; i ++ ) { double right Val = Math . exp ( log Density ( min + ( i + NUM_ ) * delta ) ) ; probabilities [ i ] = NUM_ * ( left Val + right Val ) * delta ; left Val = right Val ; } int [ ] sorted Indices = Utils . sort ( probabilities ) ; double sum = NUM_ ; boolean [ ] to Use = new boolean [ probabilities . length ] ; int k = NUM_ ; while ( ( sum < conf ) && ( k < to Use . length ) ) { to Use [ sorted Indices [ to Use . length - ( k + NUM_ ) ] ] = true ; sum += probabilities [ sorted Indices [ to Use . length - ( k + NUM_ ) ] ] ; k ++ ; } probabilities = null ; Array List < double [ ] > intervals = new Array List < double [ ] > ( ) ; double [ ] interval = null ; boolean have Started Interval = false ; for ( int i = NUM_ ; i < m Num Intervals ; i ++ ) { if ( to Use [ i ] ) { if ( have Started Interval == false ) { have Started Interval = true ; interval = new double [ NUM_ ] ; interval [ NUM_ ] = min + i * delta ; } interval [ NUM_ ] = min + ( i + NUM_ ) * delta ; } else { if ( have Started Interval ) { have Started Interval = false ; intervals . add ( interval ) ; } } } if ( have Started Interval ) { intervals . add ( interval ) ; } return intervals . to Array ( new double [ NUM_ ] [ NUM_ ] ) ; }
public boolean is Store Alive ( Bit Set fact , int local ) { return fact . get ( local ) ; }
public boolean has Video Data ( Video v ) { Path source = get Video Path ( v ) ; return Files . exists ( source ) ; }
final public static int len ( byte [ ] b ) { return b == null ? NUM_ : b . length ; }
static String ds Element ( String name ) { return PREFIX DS + name ; }
public String invert Selection Tip Text ( ) { return STR_ + STR_ + STR_ ; }
public boolean is Position Selected ( int position ) { return m Selected Items . contains ( position ) ; }
@ Override public Kernel Density Function copy ( ) { Kernel Density Function copy = new Kernel Density Function ( points ) ; return copy ; }
public boolean has Receiver ( ) { return ! receiver Nodes . is Empty ( ) ; }
public final char current Char ( Char Sequence csq ) { return csq . char At ( index ) ; }
public static char [ ] bytes To Char ( byte [ ] bytes , String encoding ) throws IO Exception { return get Input Stream As Char Array ( new Byte Array Input Stream ( bytes ) , bytes . length , encoding ) ; }
public boolean has Values ( ) { return values != null && values . size ( ) > NUM_ ; }
public static long to Address ( Object obj ) { Object [ ] array = new Object [ ] { obj } ; long base Offset = unsafe . array Base Offset ( Object [ ] . class ) ; return normalize ( unsafe . get Int ( array , base Offset ) ) ; }
private int in Range ( int number , int min , int max ) { int result ; result = Math . min ( number , max ) ; result = Math . max ( result , min ) ; return result ; }
@ Deprecated public boolean is Fill Below Line ( ) { return m Fill Below Line . size ( ) > NUM_ ; }
public synchronized Native Tcp pull Tcp Connection ( String local Address , int local Port ) { End Point Info local = new End Point Info ( local Address , local Port , Connection Type . TCP ) ; Queue < Native Tcp > queue = incoming Connections . get ( local ) ; if ( queue == null || queue . is Empty ( ) ) { return null ; } Native Tcp connection = queue . poll ( ) ; opened Tcp Connections . add ( connection ) ; return connection ; }
public boolean is Empty ( ) { return attr Map . is Empty ( ) ; }
public static Rectangle 2 D calc Aligned String Bounds ( String text , Graphics 2 D g 2 , float x , float y , Text Anchor anchor ) { Rectangle 2 D text Bounds = new Rectangle 2 D . Double ( ) ; float [ ] adjust = derive Text Bounds Anchor Offsets ( g 2 , text , anchor , text Bounds ) ; text Bounds . set Rect ( x + adjust [ NUM_ ] , y + adjust [ NUM_ ] + adjust [ NUM_ ] , text Bounds . get Width ( ) , text Bounds . get Height ( ) ) ; return text Bounds ; }
private boolean should Cancel Phonetic Letter ( Accessibility Event event ) { return event . get Event Type ( ) != Accessibility Event . TYPE WINDOW CONTENT CHANGED && event . get Event Type ( ) != Accessibility Event . TYPE NOTIFICATION STATE CHANGED && event . get Event Type ( ) != Accessibility Event . TYPE VIEW LONG CLICKED && event . get Event Type ( ) != Accessibility Event . TYPE ANNOUNCEMENT ; }
@ Override public int hash Code ( ) { int hash = raw URI . hash Code ( ) ; if ( raw Host != null ) { hash = hash * NUM_ + raw Host . hash Code ( ) ; } hash = hash * NUM_ + port ; return hash ; }
private boolean is legal class name ( String p string ) { if ( p string . equals ( STR_ ) ) return false ; for ( int i = NUM_ ; i < reserved name chars . length ; ++ i ) { if ( p string . contains ( reserved name chars [ i ] ) ) { return false ; } } return true ; }
public static boolean contains Server Finished Message ( Tls Context tls Context ) { return ( get Server Finished Message Position ( tls Context ) != - NUM_ ) ; }
Node < E > find Node ( Comparable < ? super E > key ) { for ( ; ; ) { Node < E > b = find Predecessor ( key ) ; Node < E > n = b . next ; for ( ; ; ) { if ( n == null ) return null ; Node < E > f = n . next ; if ( n != b . next ) break ; Object v = n . value ; if ( v == null ) { n . help Delete ( b , f ) ; break ; } if ( v == n || b . value == null ) break ; int c = key . compare To ( n . key ) ; if ( c == NUM_ ) { if ( key . equals ( n . key ) ) return n ; } else if ( c < NUM_ ) return null ; b = n ; n = f ; } } }
protected Buffered Image create Buffered Image ( int width , int height ) { Buffered Image image = Image Util . create Compatible Buffered Image ( width , height , Buffered Image . TYPE INT RGB ) ; Image Util . clear Image ( image ) ; return image ; }
public static double log 10 ( double x ) { return Math . log ( x ) / LOG 10 ; }
public boolean is Match ( ) { return Edge Type . LINK == edge Type && ! property Types . is Empty ( ) ; }
public static boolean is Supported Output Format ( String format ) { if ( format == Thumbnail Parameter . ORIGINAL FORMAT ) { return true ; } for ( String supported Format : get Supported Output Formats ( ) ) { if ( supported Format . equals ( format ) ) { return true ; } } return false ; }
@ Override public final long ram Bytes Used ( ) { ensure Open ( ) ; return size In Bytes . get ( ) ; }
@ Override public boolean is End Element ( ) { log . log ( Level . FINE , STR_ , event == END ELEMENT ) ; return event == END ELEMENT ; }
public final Live Set Enumerator enumerator ( ) { return new Live Set Enumerator ( first ) ; }
public static String read ( Reader a Reader ) { String Buffer sb = new String Buffer ( ) ; try { Buffered Reader b Reader = new Buffered Reader ( a Reader ) ; char [ ] data = new char [ NUM_ ] ; int count = NUM_ ; while ( ( count = b Reader . read ( data ) ) != - NUM_ ) { sb . append ( data , NUM_ , count ) ; } b Reader . close ( ) ; a Reader . close ( ) ; } catch ( IO Exception e ) { } return sb . to String ( ) ; }
public final String encode ( ) { String Buffer buffer = new String Buffer ( ) ; Default Alignment alignment Default = is Horizontal ( ) ? Column Spec . DEFAULT : Row Spec . DEFAULT ; if ( ! alignment Default . equals ( default Alignment ) ) { buffer . append ( default Alignment . abbreviation ( ) ) ; buffer . append ( STR_ ) ; } buffer . append ( size . encode ( ) ) ; if ( resize Weight == NO GROW ) { } else if ( resize Weight == DEFAULT GROW ) { buffer . append ( STR_ ) ; buffer . append ( STR_ ) ; } else { buffer . append ( STR_ ) ; buffer . append ( STR_ ) ; buffer . append ( resize Weight ) ; buffer . append ( STR_ ) ; } return buffer . to String ( ) ; }
public void request Password Changed By Required Time ( ) { operations . add ( Password Policy State Operation Type . GET PASSWORD CHANGED BY REQUIRED TIME ) ; }
protected String add Whitespace ( String string ) { return String . format ( STR_ , string ) ; }
public Disk Request add New Request ( Disk Request request ) throws Interrupted Exception { if ( ! is Active ( request . time ) ) set Starting Weight ( request . time ) ; limiter . acquire ( request . estimated Cost ) ; pending . add ( request ) ; return request ; }
public static String pad ( String str , int total Chars ) { if ( str == null ) str = STR_ ; int slen = str . length ( ) ; String Builder sb = new String Builder ( str ) ; for ( int i = NUM_ ; i < total Chars - slen ; i ++ ) { sb . append ( STR_ ) ; } return sb . to String ( ) ; }
public int [ ] to Integer Array ( ) { int [ ] values = new int [ m Size ] ; for ( int i = next Set Bit ( NUM_ ) ; i >= NUM_ && i < m Size ; i = next Set Bit ( i + NUM_ ) ) { values [ i ] = NUM_ ; } return values ; }
public Key create Key ( String method , String key ) { Key Field key Impl = new Key Field ( ) ; try { key Impl . set Method ( method ) ; key Impl . set Key ( key ) ; } catch ( Sdp Exception s ) { s . print Stack Trace ( ) ; return null ; } return key Impl ; }
boolean is Missing Required Roles ( ) { return this . is Missing Required Roles ; }
private static Pair < String , byte [ ] > parse Esds From Parent ( Parsable Byte Array parent , int position ) { parent . set Position ( position + Atom . HEADER SIZE + NUM_ ) ; parent . skip Bytes ( NUM_ ) ; int var Int Byte = parent . read Unsigned Byte ( ) ; while ( var Int Byte > NUM_ ) { var Int Byte = parent . read Unsigned Byte ( ) ; } parent . skip Bytes ( NUM_ ) ; int flags = parent . read Unsigned Byte ( ) ; if ( ( flags & NUM_ ) != NUM_ ) { parent . skip Bytes ( NUM_ ) ; } if ( ( flags & NUM_ ) != NUM_ ) { parent . skip Bytes ( parent . read Unsigned Short ( ) ) ; } if ( ( flags & NUM_ ) != NUM_ ) { parent . skip Bytes ( NUM_ ) ; } parent . skip Bytes ( NUM_ ) ; var Int Byte = parent . read Unsigned Byte ( ) ; while ( var Int Byte > NUM_ ) { var Int Byte = parent . read Unsigned Byte ( ) ; } int object Type Indication = parent . read Unsigned Byte ( ) ; String mime Type ; switch ( object Type Indication ) { case NUM_ : mime Type = Mime Types . AUDIO MPEG ; return Pair . create ( mime Type , null ) ; case NUM_ : mime Type = Mime Types . VIDEO MP 4 V ; break ; case NUM_ : mime Type = Mime Types . VIDEO H 264 ; break ; case NUM_ : mime Type = Mime Types . VIDEO H 265 ; break ; case NUM_ : case NUM_ : case NUM_ : case NUM_ : mime Type = Mime Types . AUDIO AAC ; break ; case NUM_ : mime Type = Mime Types . AUDIO AC 3 ; break ; case NUM_ : mime Type = Mime Types . AUDIO EC 3 ; break ; case NUM_ : case NUM_ : mime Type = Mime Types . AUDIO DTS ; return Pair . create ( mime Type , null ) ; case NUM_ : case NUM_ : mime Type = Mime Types . AUDIO DTS HD ; return Pair . create ( mime Type , null ) ; default : mime Type = null ; break ; } parent . skip Bytes ( NUM_ ) ; parent . skip Bytes ( NUM_ ) ; var Int Byte = parent . read Unsigned Byte ( ) ; int var Int = var Int Byte & NUM_ ; while ( var Int Byte > NUM_ ) { var Int Byte = parent . read Unsigned Byte ( ) ; var Int = var Int << NUM_ ; var Int |= var Int Byte & NUM_ ; } byte [ ] initialization Data = new byte [ var Int ] ; parent . read Bytes ( initialization Data , NUM_ , var Int ) ; return Pair . create ( mime Type , initialization Data ) ; }
public static String strip String ( String string , int begin Length , int end Length ) { if ( string == null || string . is Empty ( ) ) { return STR_ ; } if ( begin Length < NUM_ ) { begin Length = NUM_ ; } if ( end Length < NUM_ ) { end Length = NUM_ ; } if ( string . length ( ) > begin Length + end Length ) { return string . substring ( NUM_ , begin Length ) + SEPARATOR + string . substring ( string . length ( ) - end Length ) ; } else { return string ; } }
protected Array List < String > create Labels ( Element parent ) throws Exception { Array List < String > result ; Vector < Element > list ; Element node ; Element labelsnode ; int i ; result = new Array List < String > ( ) ; labelsnode = null ; list = get Child Tags ( parent , TAG LABELS ) ; if ( list . size ( ) > NUM_ ) { labelsnode = list . get ( NUM_ ) ; } if ( labelsnode != null ) { list = get Child Tags ( labelsnode , TAG LABEL ) ; for ( i = NUM_ ; i < list . size ( ) ; i ++ ) { node = list . get ( i ) ; result . add ( get Content ( node ) ) ; } } return result ; }
public boolean contains ( Element element ) { if ( this == element ) { return true ; } if ( children != null ) { int i = NUM_ ; while ( i < children . size ( ) ) { Element child = ( Element ) children . get ( i ) ; if ( child . contains ( element ) ) { return true ; } i ++ ; } } return false ; }
public static double regularized Gamma Q ( final double a , final double x ) { if ( Double . is Na N ( a ) || Double . is Na N ( x ) || ( a <= NUM_ ) || ( x < NUM_ ) ) { return Double . Na N ; } if ( x == NUM_ ) { return NUM_ ; } if ( x < a + NUM_ ) { return NUM_ - regularized Gamma P ( a , x ) ; } final double FPMIN = Double . MIN VALUE / NUM PRECISION ; double b = x + NUM_ - a ; double c = NUM_ / FPMIN ; double d = NUM_ / b ; double fac = d ; for ( int i = NUM_ ; i < MAX ITERATIONS ; i ++ ) { double an = i * ( a - i ) ; b += NUM_ ; d = an * d + b ; if ( Math . abs ( d ) < FPMIN ) { d = FPMIN ; } c = b + an / c ; if ( Math . abs ( c ) < FPMIN ) { c = FPMIN ; } d = NUM_ / d ; double del = d * c ; fac *= del ; if ( Math . abs ( del - NUM_ ) <= NUM PRECISION ) { break ; } } return fac * Math . exp ( - x + a * Math . log ( x ) - log Gamma ( a ) ) ; }
public static float length ( Vector 3 a ) { return ( float ) Math . sqrt ( length Squared ( a ) ) ; }
private static Permission [ ] grantable Permissions ( Permission [ ] permissions ) { Security Manager sm = System . get Security Manager ( ) ; if ( sm == null || permissions . length == NUM_ ) { return permissions ; } try { sm . check Permission ( new Grant Permission ( permissions ) ) ; return permissions ; } catch ( Security Exception e ) { } Array List list = new Array List ( permissions . length ) ; for ( int i = NUM_ ; i < permissions . length ; i ++ ) { try { Permission p = permissions [ i ] ; sm . check Permission ( new Grant Permission ( p ) ) ; list . add ( p ) ; } catch ( Security Exception e ) { } } return ( Permission [ ] ) list . to Array ( new Permission [ list . size ( ) ] ) ; }
static String hex ( final byte [ ] input ) { final String Buffer sb = new String Buffer ( input . length * NUM_ ) ; for ( final byte element : input ) { sb . append ( Collection Constants . AXIS HEX TABLE [ element > > NUM_ & NUM_ ] ) ; sb . append ( Collection Constants . AXIS HEX TABLE [ element & NUM_ ] ) ; } return sb . to String ( ) ; }
public static < T > List < T > ro Copy List ( Collection < T > l ) { return Collections . unmodifiable List ( new Array List < > ( l ) ) ; }
public static List < String > to List ( String [ ] array ) { List < String > list = new Array List < String > ( ) ; if ( ( array != null ) && ( array . length > NUM_ ) ) { for ( int i = NUM_ ; i < array . length ; i ++ ) { list . add ( array [ i ] ) ; } } return list ; }
public static Number find Maximum Stacked Range Value ( Category Dataset dataset ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; Number result = null ; boolean has Valid Data = false ; double maximum = NUM_ ; int category Count = dataset . get Column Count ( ) ; for ( int item = NUM_ ; item < category Count ; item ++ ) { double total = NUM_ ; int series Count = dataset . get Row Count ( ) ; for ( int series = NUM_ ; series < series Count ; series ++ ) { Number number = dataset . get Value ( series , item ) ; if ( number != null ) { has Valid Data = true ; double value = number . double Value ( ) ; if ( value > NUM_ ) { total = total + value ; } } } maximum = Math . max ( maximum , total ) ; } if ( has Valid Data ) { result = new Double ( maximum ) ; } return result ; }
public void select Parameters ( List < Parameter > parameters ) { get Parameter ( STR_ ) ; get Parameter ( STR_ ) ; get Parameter ( STR_ ) ; Parameter root Height Parameter = get Parameter ( STR_ ) ; if ( root Height Parameter . prior Type == Prior Type . NONE TREE PRIOR || ! root Height Parameter . is Prior Edited ( ) ) { root Height Parameter . set Initial ( get Initial Root Height ( ) ) ; root Height Parameter . truncation Lower = options . maximum Tip Height ; root Height Parameter . uniform Lower = options . maximum Tip Height ; root Height Parameter . is Truncated = true ; } if ( options . use Star BEAST ) { root Height Parameter . is Calibrated Yule = tree Prior . get Node Height Prior ( ) == Tree Prior Type . SPECIES YULE CALIBRATION ; } else { root Height Parameter . is Calibrated Yule = tree Prior . get Node Height Prior ( ) == Tree Prior Type . YULE CALIBRATION ; parameters . add ( root Height Parameter ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public Case Statement innermost Switch Case ( ) { Scope scope = this ; do { if ( scope instanceof Block Scope ) return ( ( Block Scope ) scope ) . enclosing Case ; scope = scope . parent ; } while ( scope != null ) ; return null ; }
private static final String to Xml ( int categories ) { String Builder sb = new String Builder ( ) ; if ( ( categories & Integer . MAX VALUE ) == Integer . MAX VALUE ) { sb . append ( STR_ + STR_ + Integer . MAX VALUE + STR_ ) ; } else { int mask = NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( ( categories & mask ) == mask ) { sb . append ( STR_ + i + STR_ + mask + STR_ ) ; } mask *= NUM_ ; } } return sb . to String ( ) ; }
public Map < Method Descriptor , int [ ] > find Linked Methods ( Set < Method Parameter > inputs ) { Map < Method Descriptor , int [ ] > result = new Hash Map < > ( ) ; for ( Method Parameter found : find Linked ( inputs ) ) { int [ ] params = result . get ( found . get Method Descriptor ( ) ) ; if ( params == null ) { params = new int [ ] { found . get Parameter Number ( ) } ; result . put ( found . get Method Descriptor ( ) , params ) ; } else { int [ ] new Params = new int [ params . length + NUM_ ] ; System . arraycopy ( params , NUM_ , new Params , NUM_ , params . length ) ; new Params [ params . length ] = found . get Parameter Number ( ) ; result . put ( found . get Method Descriptor ( ) , new Params ) ; } } return result ; }
public static final void validate ( Key key ) throws Invalid Key Exception { if ( key == null ) { throw new Null Pointer Exception ( STR_ ) ; } if ( key instanceof DH Public Key ) { validate DH Public Key ( ( DH Public Key ) key ) ; } }
public String business Object Format Key To String ( String namespace , String business Object Definition Name , String business Object Format Usage , String business Object Format File Type , Integer business Object Format Version ) { return String . format ( STR_ + STR_ , namespace , business Object Definition Name , business Object Format Usage , business Object Format File Type , business Object Format Version ) ; }
public static Real Vector fft Convolution ( Real Vector first , Real Vector second ) { Incompatible Vectors Exception . check Vectors Compatible ( first , second ) ; Dense Float Matrix 1 D colt Vec 1 = new Dense Float Matrix 1 D ( first . get Coordinates ( ) ) ; Dense Float Matrix 1 D colt Vec 2 = new Dense Float Matrix 1 D ( second . get Coordinates ( ) ) ; int dimension = first . get Dimension ( ) ; Dense F Complex Matrix 1 D fft 1 = colt Vec 1 . get Fft ( ) ; Dense F Complex Matrix 1 D fft 2 = colt Vec 2 . get Fft ( ) ; for ( int i = NUM_ ; i < dimension ; i ++ ) { fft 1 . set Quick ( i , F Complex . mult ( fft 1 . get Quick ( i ) , fft 2 . get Quick ( i ) ) ) ; } fft 1 . ifft ( true ) ; Dense Float Matrix 1 D colt Result = ( ( Dense Float Matrix 1 D ) ( fft 1 . get Real Part ( ) ) ) ; float [ ] coordinates = colt Result . elements ( ) ; Real Vector result = new Real Vector ( coordinates ) ; return result ; }
public static boolean is Url ( String resource Location ) { if ( resource Location == null ) { return false ; } if ( resource Location . starts With ( CLASSPATH URL PREFIX ) ) { return true ; } try { new URL ( resource Location ) ; return true ; } catch ( Malformed URL Exception ex ) { return false ; } }
static boolean class Loadable ( Class clazz ) { return ! clazz . is Annotation Present ( No Load . class ) ; }
@ Override public boolean can Open Warm ( ) { State state = state ; if ( state == State . ACTIVE ) { return true ; } else if ( state . is Enabled ( ) ) { long now = Current Time . current Time ( ) ; if ( is Failed ( now ) ) { return false ; } long first Success Time = first Success Time ; int warmup State = NUM_ ; if ( first Success Time > NUM_ ) { warmup State = ( int ) ( ( now - first Success Time ) / warmup Chunk Time ) ; } warmup State -= current Fail Count ; if ( warmup State < NUM_ ) { return ( fail Time - warmup State * fail Chunk Time < now ) ; } else if ( WARMUP MAX <= warmup State ) { return true ; } int connection Max = WARMUP CONNECTION MAX [ warmup State ] ; int idle Count = get Idle Count ( ) ; int active Count = active Count . get ( ) + starting Count . get ( ) ; int total Count = active Count + idle Count ; return total Count < connection Max ; } else { return false ; } }
public String equations To String ( String prefix , int fraction Digits ) { Decimal Format nf = new Decimal Format ( ) ; nf . set Minimum Fraction Digits ( fraction Digits ) ; nf . set Maximum Fraction Digits ( fraction Digits ) ; nf . set Decimal Format Symbols ( new Decimal Format Symbols ( Locale . US ) ) ; nf . set Negative Prefix ( STR_ ) ; nf . set Positive Prefix ( STR_ ) ; return equations To String ( prefix , nf ) ; }
private boolean is Comment Line ( I Document document , int line ) throws Bad Location Exception { if ( document . get Number Of Lines ( ) < line ) return false ; int offset = document . get Line Offset ( line ) ; int length = document . get Line Length ( line ) ; int first Char = find End Of White Space ( document , offset , offset + length ) ; length -= first Char - offset ; String line Contents = document . get ( first Char , length ) ; String prefix = line Contents . trim ( ) ; if ( ! prefix . starts With ( STR_ ) || prefix . starts With ( STR_ ) ) { return false ; } return true ; }
public static String human Readable Int ( long number ) { long abs Number = Math . abs ( number ) ; double result = number ; String suffix = STR_ ; if ( abs Number < NUM_ ) { } else if ( abs Number < NUM_ * NUM_ ) { result = number / NUM_ ; suffix = STR_ ; } else if ( abs Number < NUM_ * NUM_ * NUM_ ) { result = number / ( NUM_ * NUM_ ) ; suffix = STR_ ; } else { result = number / ( NUM_ * NUM_ * NUM_ ) ; suffix = STR_ ; } return one Decimal . format ( result ) + suffix ; }
public boolean has Incompatible Super Type ( Reference Binding other Type ) { if ( this == other Type ) return false ; Reference Binding [ ] interfaces To Visit = null ; int next Position = NUM_ ; Reference Binding current Type = this ; Type Binding match ; do { match = other Type . find Super Type Originating From ( current Type ) ; if ( match != null && match . is Provably Distinct ( current Type ) ) return true ; Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces != Binding . NO SUPERINTERFACES ) { if ( interfaces To Visit == null ) { interfaces To Visit = its Interfaces ; next Position = interfaces To Visit . length ; } else { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length ) System . arraycopy ( interfaces To Visit , NUM_ , interfaces To Visit = new Reference Binding [ next Position + its Length + NUM_ ] , NUM_ , next Position ) ; next Interface : for ( int a = NUM_ ; a < its Length ; a ++ ) { Reference Binding next = its Interfaces [ a ] ; for ( int b = NUM_ ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } } while ( ( current Type = current Type . superclass ( ) ) != null ) ; for ( int i = NUM_ ; i < next Position ; i ++ ) { current Type = interfaces To Visit [ i ] ; if ( current Type == other Type ) return false ; match = other Type . find Super Type Originating From ( current Type ) ; if ( match != null && match . is Provably Distinct ( current Type ) ) return true ; Reference Binding [ ] its Interfaces = current Type . super Interfaces ( ) ; if ( its Interfaces != null && its Interfaces != Binding . NO SUPERINTERFACES ) { int its Length = its Interfaces . length ; if ( next Position + its Length >= interfaces To Visit . length ) System . arraycopy ( interfaces To Visit , NUM_ , interfaces To Visit = new Reference Binding [ next Position + its Length + NUM_ ] , NUM_ , next Position ) ; next Interface : for ( int a = NUM_ ; a < its Length ; a ++ ) { Reference Binding next = its Interfaces [ a ] ; for ( int b = NUM_ ; b < next Position ; b ++ ) if ( next == interfaces To Visit [ b ] ) continue next Interface ; interfaces To Visit [ next Position ++ ] = next ; } } } return false ; }
public String stemmer Tip Text ( ) { return STR_ + get Stemmer List ( NUM_ , STR_ ) ; }
public Enumeration list Options ( ) { Vector new Vector = new Vector ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public boolean has Protocol Name ( String url ) { int index = url . index Of ( STR_ ) ; if ( index <= NUM_ ) { return false ; } for ( int i = NUM_ ; i < index ; i ++ ) { char c = url . char At ( i ) ; if ( ( c >= STR_ && c <= STR_ ) || ( c >= STR_ && c <= STR_ ) || ( c == STR_ ) ) { continue ; } return false ; } return true ; }
public static String lower First ( String s ) { if ( s . is Empty ( ) ) { return s ; } char c = s . char At ( NUM_ ) ; if ( Character . is Lower Case ( c ) ) { return s ; } c = Character . to Lower Case ( c ) ; return c + s . substring ( NUM_ ) ; }
public final int count Data Schemes ( ) { return m Data Schemes != null ? m Data Schemes . size ( ) : NUM_ ; }
public static byte [ ] as Byte Array ( final List < Byte > l ) { final byte [ ] a = new byte [ l . size ( ) ] ; for ( int i = NUM_ ; i < a . length ; i ++ ) { a [ i ] = l . get ( i ) ; } return a ; }
public static void assert Not Empty ( Buffered Image image ) { assert Not Empty ( STR_ , image ) ; }
public static int [ ] create Normalized Map ( int [ ] values , byte [ ] levels , int start , int limit ) { if ( values != null ) { if ( start != NUM_ || limit != values . length ) { boolean copy Range , canonical ; byte primary Level ; if ( levels == null ) { primary Level = ( byte ) NUM_ ; copy Range = true ; canonical = true ; } else { if ( levels [ start ] == levels [ limit - NUM_ ] ) { primary Level = levels [ start ] ; canonical = ( primary Level & ( byte ) NUM_ ) == NUM_ ; int i ; for ( i = start ; i < limit ; i ++ ) { if ( levels [ i ] < primary Level ) { break ; } if ( canonical ) { canonical = levels [ i ] == primary Level ; } } copy Range = ( i == limit ) ; } else { copy Range = false ; primary Level = ( byte ) NUM_ ; canonical = false ; } } if ( copy Range ) { if ( canonical ) { return null ; } int [ ] result = new int [ limit - start ] ; int base Value ; if ( ( primary Level & ( byte ) NUM_ ) != NUM_ ) { base Value = values [ limit - NUM_ ] ; } else { base Value = values [ start ] ; } if ( base Value == NUM_ ) { System . arraycopy ( values , start , result , NUM_ , limit - start ) ; } else { for ( int j = NUM_ ; j < result . length ; j ++ ) { result [ j ] = values [ j + start ] - base Value ; } } return result ; } else { return compute Contiguous Order ( values , start , limit ) ; } } else { return values ; } } return null ; }
public double p Norm ( double p ) { if ( p <= NUM_ ) throw new Illegal Argument Exception ( STR_ + p ) ; double result = NUM_ ; if ( p == NUM_ ) { for ( Index Value iv : this ) result += abs ( iv . get Value ( ) ) ; } else if ( p == NUM_ ) { for ( Index Value iv : this ) result += iv . get Value ( ) * iv . get Value ( ) ; result = Math . sqrt ( result ) ; } else if ( Double . is Infinite ( p ) ) { for ( Index Value iv : this ) result = Math . max ( result , abs ( iv . get Value ( ) ) ) ; } else { for ( Index Value iv : this ) result += pow ( abs ( iv . get Value ( ) ) , p ) ; result = pow ( result , NUM_ / p ) ; } return result ; }
private void shrink Value Set ( int max Size ) { if ( value Set != null ) { if ( value Set . size ( ) > max Size ) { Set < String > new Set = new Tree Set < String > ( ) ; Iterator < String > i = value Set . iterator ( ) ; int count = NUM_ ; while ( i . has Next ( ) && count < max Size ) { new Set . add ( i . next ( ) ) ; count ++ ; } this . value Set = new Set ; value Set Relation = value Set Relation . merge ( Set Relation . SUPERSET ) ; if ( owner != null ) { owner . set Nominal Data Was Shrinked ( true ) ; } } } }
public boolean kind Is One Of ( Kind ... kinds ) { return kind Is One Of ( Arrays . as List ( kinds ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public boolean is Empty ( ) { return changes . is Empty ( ) ; }
@ Override public default Spliterator < Time Series Collection > spliterator ( ) { return Spliterators . spliterator Unknown Size ( iterator ( ) , NONNULL | IMMUTABLE | ORDERED | DISTINCT | SORTED ) ; }
public static void delete Files Ignoring Exceptions ( Path ... files ) { delete Files Ignoring Exceptions ( Arrays . as List ( files ) ) ; }
public static Capabilities for Instances ( Instances data ) throws Exception { return for Instances ( data , false ) ; }
public static boolean is Video ( String mime Type ) { if ( mime Type != null ) { if ( mime Type . starts With ( STR_ ) ) return true ; else return false ; } else { return false ; } }
@ Override public List < Evaluation Statistics > evaluate ( Multi Label Classifier classifier , Instances dataset ) { List < Evaluation Statistics > result ; m Actual Num Threads = Thread Utils . get Actual Num Threads ( m Num Threads , m Upper Runs - m Lower Runs + NUM_ ) ; log ( STR_ + Thread Utils . SEQUENTIAL + STR_ + m Actual Num Threads ) ; if ( m Actual Num Threads == Thread Utils . SEQUENTIAL ) result = evaluate Sequential ( classifier , dataset ) ; else result = evaluate Parallel ( classifier , dataset ) ; if ( m Stopped ) result . clear ( ) ; return result ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static String Set declared Symbols In Scope Set ( Module Node module , Location loc ) { String Set result = new String Set ( ) ; add Declared Symbols In Scope Set ( result , module , loc ) ; return result ; }
public static boolean is Not Empty ( final Node xml Node , final String x Path String ) { Node List node List = get Node List ( xml Node , x Path String + STR_ ) ; if ( ( node List != null ) && ( node List . get Length ( ) > NUM_ ) ) { return true ; } return false ; }
public static String to Map String ( Map arg ) { return to Map String ( arg , - NUM_ ) ; }
public Business Object Data Create Request create Business Object Data Create Request ( String namespace Code , String business Object Definition Name , String business Object Format Usage , String business Object Format File Type , Integer business Object Format Version , String partition Key , String partition Value , String business Object Data Status Code , String storage Name , String storage Directory Path , List < Storage File > storage Files ) { Business Object Data Create Request business Object Data Create Request = new Business Object Data Create Request ( ) ; business Object Data Create Request . set Namespace ( namespace Code ) ; business Object Data Create Request . set Business Object Definition Name ( business Object Definition Name ) ; business Object Data Create Request . set Business Object Format Usage ( business Object Format Usage ) ; business Object Data Create Request . set Business Object Format File Type ( business Object Format File Type ) ; business Object Data Create Request . set Business Object Format Version ( business Object Format Version ) ; business Object Data Create Request . set Partition Key ( partition Key ) ; business Object Data Create Request . set Partition Value ( partition Value ) ; business Object Data Create Request . set Status ( business Object Data Status Code ) ; List < Storage Unit Create Request > storage Units = new Array List < > ( ) ; business Object Data Create Request . set Storage Units ( storage Units ) ; Storage Unit Create Request storage Unit = new Storage Unit Create Request ( ) ; storage Units . add ( storage Unit ) ; storage Unit . set Storage Name ( storage Name ) ; if ( storage Directory Path != null ) { Storage Directory storage Directory = new Storage Directory ( ) ; storage Unit . set Storage Directory ( storage Directory ) ; storage Directory . set Directory Path ( storage Directory Path ) ; } storage Unit . set Storage Files ( storage Files ) ; return business Object Data Create Request ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private boolean is Freshness Lifetime Heuristic ( ) { return max Age Seconds == - NUM_ && expires == null ; }
public static Version from String ( String version ) { if ( ! Strings . has Length ( version ) ) { return Version . CURRENT ; } final boolean snapshot ; if ( snapshot = version . ends With ( STR_ ) ) { version = version . substring ( NUM_ , version . length ( ) - NUM_ ) ; } String [ ] parts = version . split ( STR_ ) ; if ( parts . length < NUM_ || parts . length > NUM_ ) { throw new Illegal Argument Exception ( STR_ + version ) ; } try { final int major = Integer . parse Int ( parts [ NUM_ ] ) * NUM_ ; final int minor = Integer . parse Int ( parts [ NUM_ ] ) * NUM_ ; final int revision = Integer . parse Int ( parts [ NUM_ ] ) * NUM_ ; int build = NUM_ ; if ( parts . length == NUM_ ) { String build Str = parts [ NUM_ ] ; if ( build Str . starts With ( STR_ ) || build Str . starts With ( STR_ ) ) { build = Integer . parse Int ( build Str . substring ( NUM_ ) ) ; } if ( build Str . starts With ( STR_ ) || build Str . starts With ( STR_ ) ) { build = Integer . parse Int ( build Str . substring ( NUM_ ) ) + NUM_ ; } } final Version version From Id = from Id ( major + minor + revision + build ) ; if ( snapshot != version From Id . snapshot ( ) ) { return new Version ( version From Id . id , snapshot , version From Id . lucene Version ) ; } return version From Id ; } catch ( Number Format Exception e ) { throw new Illegal Argument Exception ( STR_ + version , e ) ; } }
private String character Iterator To String ( Character Iterator iterator ) { int end Index = iterator . get End Index ( ) ; int begin Index = iterator . get Begin Index ( ) ; int count = end Index - begin Index ; if ( count <= NUM_ ) { return STR_ ; } char [ ] chars = new char [ count ] ; int i = NUM_ ; char c = iterator . first ( ) ; while ( c != Character Iterator . DONE ) { chars [ i ] = c ; i ++ ; c = iterator . next ( ) ; } return new String ( chars ) ; }
public int index Of ( final B Op bop ) { return args . index Of ( bop ) ; }
public static String format ( double [ ] [ ] m , int w , int d , String pre , String pos , String csep ) { Decimal Format format = new Decimal Format ( ) ; format . set Decimal Format Symbols ( new Decimal Format Symbols ( Locale . US ) ) ; format . set Minimum Integer Digits ( NUM_ ) ; format . set Maximum Fraction Digits ( d ) ; format . set Minimum Fraction Digits ( d ) ; format . set Grouping Used ( false ) ; String Builder msg = new String Builder ( ) ; for ( int i = NUM_ ; i < m . length ; i ++ ) { double [ ] row = m [ i ] ; msg . append ( pre ) ; for ( int j = NUM_ ; j < row . length ; j ++ ) { if ( j > NUM_ ) { msg . append ( csep ) ; } String s = format . format ( row [ j ] ) ; whitespace ( msg , w - s . length ( ) ) ; msg . append ( s ) ; } msg . append ( pos ) ; } return msg . to String ( ) ; }
public boolean is Set Debug ( ) { return isset bit vector . get ( DEBUG ISSET ID ) ; }
public static < K , V > List < Key Value < K , V > > read Key Values ( String topic , Properties consumer Config ) { return read Key Values ( topic , consumer Config , UNLIMITED MESSAGES ) ; }
public boolean file Exists ( String url ) { File file = new File ( url ) ; return file . exists ( ) ; }
public String storage Policy Key And Version To String ( Storage Policy Key storage Policy Key , Integer storage Policy Version ) { return String . format ( STR_ , storage Policy Key . get Namespace ( ) , storage Policy Key . get Storage Policy Name ( ) , storage Policy Version ) ; }
public boolean has Same Value ( Constant other Constant ) { if ( this == other Constant ) return true ; int type ID ; if ( ( type ID = type ID ( ) ) != other Constant . type ID ( ) ) return false ; switch ( type ID ) { case Type Ids . T boolean : return boolean Value ( ) == other Constant . boolean Value ( ) ; case Type Ids . T byte : return byte Value ( ) == other Constant . byte Value ( ) ; case Type Ids . T char : return char Value ( ) == other Constant . char Value ( ) ; case Type Ids . T double : return double Value ( ) == other Constant . double Value ( ) ; case Type Ids . T float : return float Value ( ) == other Constant . float Value ( ) ; case Type Ids . T int : return int Value ( ) == other Constant . int Value ( ) ; case Type Ids . T short : return short Value ( ) == other Constant . short Value ( ) ; case Type Ids . T long : return long Value ( ) == other Constant . long Value ( ) ; case Type Ids . T Java Lang String : String value = string Value ( ) ; return value == null ? other Constant . string Value ( ) == null : value . equals ( other Constant . string Value ( ) ) ; } return false ; }
@ Override public double [ ] distribution For Instance ( Instance instance ) throws Exception { instance = ( Instance ) instance . copy ( ) ; instance . set Dataset ( m numeric Data Header ) ; return probs ( get Fs ( instance ) ) ; }
private Date penaly Date With Three Months ( final Date date ) { final Calendar penaly Date = Calendar . get Instance ( ) ; penaly Date . set Time ( date ) ; penaly Date . add ( Calendar . MONTH , NUM_ ) ; penaly Date . set ( Calendar . DAY OF MONTH , NUM_ ) ; return penaly Date . get Time ( ) ; }
public static long memory Usage Of ( Instrumentation inst , final Object obj ) { return inst . get Object Size ( obj ) ; }
public Revision next ( ) { try { switch ( modus ) { case INIT : return init ( ) ; case ITERATE WITH MAPPING : return chrono Iterator . next ( ) ; case ITERATE WITHOUT MAPPING : return revision Iterator . next ( ) ; default : throw new Runtime Exception ( STR_ ) ; } } catch ( Exception e ) { throw new Runtime Exception ( e ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
@ Override public Object clone ( ) throws Clone Not Supported Exception { Sampling XY Line Renderer clone = ( Sampling XY Line Renderer ) super . clone ( ) ; if ( this . legend Line != null ) { clone . legend Line = Shape Utilities . clone ( this . legend Line ) ; } return clone ; }
public final boolean yymore Streams ( ) { return ! zz Streams . is Empty ( ) ; }
public static Test suite ( ) { return suite ( Test Mode . triples ) ; }
public static java . lang . Integer value Of ( java . lang . String s ) throws java . lang . Number Format Exception { return new Integer ( parse Int ( s ) ) ; }
public int num Leaf Keys Issued ( ) { lock . lock ( ) ; try { return issued External Keys + issued Internal Keys ; } finally { lock . unlock ( ) ; } }
public static double deriv ( double pred , double y ) { return Math . signum ( pred - y ) ; }
private Object timed Get ( long nanos ) throws Timeout Exception { if ( Thread . interrupted ( ) ) return null ; if ( nanos <= NUM_ ) throw new Timeout Exception ( ) ; long d = System . nano Time ( ) + nanos ; Signaller q = new Signaller ( true , nanos , d == NUM_ ? NUM_ : d ) ; boolean queued = false ; Object r ; while ( ( r = result ) == null ) { if ( ! queued ) queued = try Push Stack ( q ) ; else if ( q . interrupt Control < NUM_ || q . nanos <= NUM_ ) { q . thread = null ; clean Stack ( ) ; if ( q . interrupt Control < NUM_ ) return null ; throw new Timeout Exception ( ) ; } else if ( q . thread != null && result == null ) { try { Fork Join Pool . managed Block ( q ) ; } catch ( Interrupted Exception ie ) { q . interrupt Control = - NUM_ ; } } } if ( q . interrupt Control < NUM_ ) r = null ; q . thread = null ; post Complete ( ) ; return r ; }
protected Thread new Started Thread ( Runnable runnable ) { Thread t = new Thread ( runnable ) ; t . set Daemon ( true ) ; t . start ( ) ; return t ; }
@ Override public boolean run After ( List tasks , int size ) { for ( int i = NUM_ ; i < size ; i ++ ) { Cache Task t = ( Cache Task ) tasks . get ( i ) ; if ( t instanceof Register Listener Task || t instanceof Lookup Task || t instanceof Notify Event Task ) { Proxy Reg other Reg = t . get Proxy Reg ( ) ; if ( reg . equals ( other Reg ) ) { if ( this Task Seq N > t . get Seq N ( ) ) return true ; } } } return super . run After ( tasks , size ) ; }
public String to Simple String ( ) { String Buffer buffer = new String Buffer ( ) ; buffer . append ( STR_ + ( get Label ( ) == null ? STR_ : get Label ( ) ) + STR_ + m Values . size ( ) + STR_ ) ; return buffer . to String ( ) ; }
public static void fail ( int error Code , Throwable cause ) { throw new Runtime Exception ( MP . get Message ( error Code , cause . get Message ( ) ) , cause ) ; }
private GV Congruence Class create Congruence Class ( Object label ) { int index = B . size ( ) ; GV Congruence Class result = new GV Congruence Class ( index , label ) ; B . add ( result ) ; return result ; }
@ Deprecated public static Collection < String > one Or Many ( final Named List args , final String key ) { List < String > result = new Array List < > ( args . size ( ) / NUM_ ) ; final String err = STR_ + key + STR_ + STR_ ; for ( Object o = args . remove ( key ) ; null != o ; o = args . remove ( key ) ) { if ( o instanceof String ) { result . add ( ( String ) o ) ; continue ; } if ( o instanceof Object [ ] ) { o = Arrays . as List ( ( Object [ ] ) o ) ; } if ( o instanceof Collection ) { for ( Object item : ( Collection ) o ) { if ( ! ( item instanceof String ) ) { throw new Solr Exception ( Solr Exception . Error Code . SERVER ERROR , err + item . get Class ( ) ) ; } result . add ( ( String ) item ) ; } continue ; } throw new Solr Exception ( Solr Exception . Error Code . SERVER ERROR , err + o . get Class ( ) ) ; } return result ; }
private int allowed Threads ( ) { if ( m Speed == - NUM_ ) { Log . d ( TAG , STR_ ) ; return NUM_ ; } else if ( m Speed < NUM_ ) { Log . d ( TAG , STR_ ) ; return NUM_ ; } else { Log . d ( TAG , STR_ + MAX THREADS + STR_ ) ; return MAX THREADS ; } }
public Object next ( ) { if ( files Index == files . size ( ) ) return null ; File current = files . get ( files Index ++ ) ; String label = current . get Absolute Path ( ) ; int last Separator = label . last Index Of ( File . separator Char ) ; label = label . substring ( label . last Index Of ( File . separator Char , last Separator - NUM_ ) + NUM_ , last Separator ) ; return file To Array ( current , label ) ; }
public static Map < String , Set < String > > clone Map ( Map < String , Set < String > > map ) { Map < String , Set < String > > clone = new Hash Map < String , Set < String > > ( ) ; for ( String key : map . key Set ( ) ) { Set < String > set = new Hash Set < String > ( ) ; Set < String > orig = ( Set < String > ) map . get ( key ) ; set . add All ( orig ) ; clone . put ( key , set ) ; } return clone ; }
public String attribute Type Tip Text ( ) { return STR_ ; }
public int size ( ) { return attributes . size ( ) ; }
static private int [ ] worst Indices ( double [ ] x , double prop Kept ) { if ( prop Kept == NUM_ ) return null ; int n = x . length ; int num Neg = NUM_ ; for ( double a X 1 : x ) if ( a X 1 < NUM_ ) num Neg ++ ; if ( num Neg == NUM_ ) return null ; double [ ] xcopy = new double [ num Neg ] ; int j = NUM_ ; for ( double a X : x ) if ( a X < NUM_ ) xcopy [ j ++ ] = a X ; Arrays . sort ( xcopy ) ; int nkept = ( int ) Math . ceil ( prop Kept * num Neg ) ; double cutoff = xcopy [ nkept - NUM_ ] ; int [ ] result = new int [ nkept ] ; int front = NUM_ , back = nkept - NUM_ ; for ( int i = NUM_ ; i < n ; i ++ ) { if ( x [ i ] < cutoff ) result [ front ++ ] = i ; else if ( x [ i ] == cutoff ) { if ( back >= front ) result [ back -- ] = i ; } } return result ; }
public boolean has Delay ( ) { return delay != - NUM_ ; }
private Dimension layout Size ( Container target , boolean preferred ) { synchronized ( target . get Tree Lock ( ) ) { int target Width = target . get Size ( ) . width ; if ( target Width == NUM_ ) target Width = Integer . MAX VALUE ; int hgap = get Hgap ( ) ; int vgap = get Vgap ( ) ; Insets insets = target . get Insets ( ) ; int horizontal Insets And Gap = insets . left + insets . right + ( hgap * NUM_ ) ; int max Width = target Width - horizontal Insets And Gap ; Dimension dim = new Dimension ( NUM_ , NUM_ ) ; int row Width = NUM_ ; int row Height = NUM_ ; int nmembers = target . get Component Count ( ) ; for ( int i = NUM_ ; i < nmembers ; i ++ ) { Component m = target . get Component ( i ) ; if ( m . is Visible ( ) ) { Dimension d = preferred ? m . get Preferred Size ( ) : m . get Minimum Size ( ) ; if ( row Width + d . width > max Width ) { add Row ( dim , row Width , row Height ) ; row Width = NUM_ ; row Height = NUM_ ; } if ( row Width != NUM_ ) { row Width += hgap ; } row Width += d . width ; row Height = Math . max ( row Height , d . height ) ; } } add Row ( dim , row Width , row Height ) ; dim . width += horizontal Insets And Gap ; dim . height += insets . top + insets . bottom + vgap * NUM_ ; Container scroll Pane = Swing Utilities . get Ancestor Of Class ( J Scroll Pane . class , target ) ; if ( scroll Pane != null && target . is Valid ( ) ) { dim . width -= ( hgap + NUM_ ) ; } return dim ; } }
public boolean may Alias ( Value v 1 , Value v 2 , Unit u ) { Set < Set < Value > > res = get Flow Before ( u ) ; for ( Set < Value > set : res ) { if ( set . contains ( v 1 ) && set . contains ( v 2 ) ) return true ; } return false ; }
public Pin Later Client ( Command Line cmd Line ) { this ( cmd Line . get Option Value ( STR_ ) , Integer . parse Int ( cmd Line . get Option Value ( STR_ ) ) , Integer . parse Int ( cmd Line . get Option Value ( STR_ , STR_ ) ) ) ; }
public boolean is Koblitz ( ) { return order != null && cofactor != null && b . is One ( ) && ( a . is Zero ( ) || a . is One ( ) ) ; }
private boolean is obstacle clearance ( Brd Item curr item ) { boolean is obstacle = curr item . is obstacle ( this ) ; if ( ! is obstacle ) return false ; if ( ! ( this instanceof Brd Tracep && curr item instanceof Brd Tracep ) ) return true ; Brd Tracep this trace = ( Brd Tracep ) this ; boolean contact found = false ; Pla Point contact point = this trace . corner first ( ) ; Collection < Brd Item > curr contacts = this trace . get normal contacts ( contact point , true ) ; if ( curr contacts . contains ( curr item ) ) contact found = true ; if ( ! contact found ) { contact point = this trace . corner last ( ) ; curr contacts = this trace . get normal contacts ( contact point , true ) ; if ( curr contacts . contains ( curr item ) ) contact found = true ; } if ( ! contact found ) return true ; for ( Brd Item curr contact : curr contacts ) { if ( ! ( curr contact instanceof Brd Abit Pin ) ) continue ; if ( curr contact . shares net ( this ) && curr contact . shares net ( curr item ) ) return false ; } return true ; }
public void fill Assigned Keys ( Set < String > keys ) { keys . clear ( ) ; }
public static double next Erlang ( double variance , double mean , Random Engine random Generator ) { int k = ( int ) ( ( mean * mean ) / variance + NUM_ ) ; k = ( k > NUM_ ) ? k : NUM_ ; double a = k / mean ; double prod = NUM_ ; for ( int i = NUM_ ; i < k ; i ++ ) prod *= random Generator . raw ( ) ; return - Math . log ( prod ) / a ; }
public static String strip Version From Rest Name ( String rest Name ) { Preconditions . check Not Null ( rest Name ) ; String version = extract Default Major Version From Rest Name ( rest Name ) ; String [ ] segs = rest Name . split ( STR_ ) ; if ( segs . length > NUM_ ) { version = version + STR_ ; } return rest Name . starts With ( version ) ? rest Name . substring ( version . length ( ) ) : rest Name ; }
final boolean is Copy On Read ( ) { return this . copy On Read ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public int size ( ) { return rules . size ( ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static String android Cmd Name ( ) { String os = System . get Property ( STR_ ) ; String cmd = STR_ ; if ( os . starts With ( STR_ ) ) { cmd += STR_ ; } return cmd ; }
private long floor To Bucket ( long logical Position ) { long d = ( long ) Math . floor ( logical Position / bckt Capacity ) ; return bckt Capacity * d ; }
private List < Locale Provider Adapter . Type > find Providers ( Locale locale ) { List < Locale Provider Adapter . Type > providers List = providers Cache . get ( locale ) ; if ( providers List == null ) { for ( Locale Provider Adapter . Type type : Locale Provider Adapter . get Adapter Preference ( ) ) { Locale Service Provider lsp = providers . get ( type ) ; if ( lsp != null ) { if ( lsp . is Supported Locale ( locale ) ) { if ( providers List == null ) { providers List = new Array List < > ( NUM_ ) ; } providers List . add ( type ) ; } } } if ( providers List == null ) { providers List = NULL LIST ; } List < Locale Provider Adapter . Type > val = providers Cache . put If Absent ( locale , providers List ) ; if ( val != null ) { providers List = val ; } } return providers List ; }
public static boolean is Empty ( String string ) { return string == null || string . is Empty ( ) ; }
public boolean is For Project ( String project Dir ) { return my Project Directory == null || my Project Directory . equals ( project Dir ) ; }
@ Override public final int size ( ) { return stack Top . get ( ) ; }
private static Pattern anchored ( String regex ) { return Pattern . compile ( STR_ + regex + STR_ ) ; }
public long next Long ( ) { return ( ( long ) next ( NUM_ ) << NUM_ ) + next ( NUM_ ) ; }
@ Override public String next ( ) { String result ; result = m Current Leaf . get String ( ) ; result = result . substring ( NUM_ , result . length ( ) - NUM_ ) ; if ( m Current Leaf != m Last Leaf ) { m Current Leaf = ( Trie Node ) m Current Leaf . get Next Leaf ( ) ; } else { m Current Leaf = null ; } return result ; }
public static float [ ] expand ( float [ ] field , int new Size , boolean keep Data ) { if ( field == null || field . length < new Size ) { float [ ] new Array = new float [ new Size ] ; if ( keep Data && field != null ) { System . arraycopy ( field , NUM_ , new Array , NUM_ , field . length ) ; } return new Array ; } return field ; }
public static String after ( String s , String token ) { if ( s == null ) { return null ; } int i = s . index Of ( token ) ; if ( i == - NUM_ ) { return s ; } return s . substring ( i + token . length ( ) ) ; }
public static String to Escape ( Date date ) { if ( date == null ) return null ; Date Format df = null ; try { df = new Simple Date Format ( ESCAPE DATE PATTERN ) ; } catch ( Throwable t ) { return null ; } df . set Lenient ( false ) ; return df . format ( date ) ; }
private int digit Count ( String text , int position , int amount ) { int limit = Math . min ( text . length ( ) - position , amount ) ; amount = NUM_ ; for ( ; limit > NUM_ ; limit -- ) { char c = text . char At ( position + amount ) ; if ( c < STR_ || c > STR_ ) { break ; } amount ++ ; } return amount ; }
public static Hash Provider best ( Hash Parameters params , Enum Set < Hash Support > required ) { Hash Provider result = null ; Enum Set < Hash Support > result Support = null ; for ( final Hash Provider provider : ALL PROVIDERS ) { final Enum Set < Hash Support > support = provider . query Support ( params ) ; if ( support . contains All ( required ) && ( result == null || Hash Support . compare ( support , result Support ) < NUM_ ) ) { result = provider ; result Support = support ; } } if ( result == null ) throw new Unsupported Operation Exception ( ) ; return result ; }
public boolean will Expire ( ) { return will Expire Flag ; }
@ Layoutlib Delegate static float sqrt ( float value ) { return ( float ) Math . sqrt ( value ) ; }
private static String create Lib Extension ( ) { OS Type os Type = calculate OS ( ) ; switch ( os Type ) { case APPLE : return STR_ ; case LINUX : return STR_ ; case SUN : return STR_ ; case WINDOWS : return STR_ ; } return STR_ ; }
public static String to Pinyin ( char c ) { if ( is Chinese ( c ) ) { if ( c == Pinyin Data . CHAR 12295 ) { return Pinyin Data . PINYIN 12295 ; } else { return Pinyin Data . PINYIN TABLE [ get Pinyin Code ( c ) ] ; } } else { return String . value Of ( c ) ; } }
public static < T > int binary Search Ceil ( List < ? extends Comparable < ? super T > > list , T key , boolean inclusive , boolean stay In Bounds ) { int index = Collections . binary Search ( list , key ) ; index = index < NUM_ ? ~ index : ( inclusive ? index : ( index + NUM_ ) ) ; return stay In Bounds ? Math . min ( list . size ( ) - NUM_ , index ) : index ; }
public int length ( ) { return to String . length ( ) ; }
public boolean match Id ( ) { return tok . ttype == Stream Tokenizer . TT WORD && ! keywords . contains ( tok . sval ) ; }
public int find In Content ( String content ) { int n = content . length ( ) ; int m = pattern . length ( ) ; int skip ; char val ; for ( int i = NUM_ ; i <= n - m ; i = i + skip ) { skip = NUM_ ; for ( int j = m - NUM_ ; j >= NUM_ ; j -- ) { if ( pattern . char At ( j ) != content . char At ( i + j ) ) { val = content . char At ( i + j ) ; skip = ( occurrence . get ( val ) != null ) ? Math . max ( NUM_ , j - occurrence . get ( val ) ) : j + NUM_ ; break ; } } if ( skip == NUM_ ) { return i ; } } return - NUM_ ; }
public static double pow ( double x , double y ) { return Math . pow ( x , y ) ; }
public static synchronized Explorer Support shared Instance ( ) { if ( shared Instance == null ) shared Instance = new Explorer Support ( ) ; return shared Instance ; }
private static String contents Of File ( Weak Reference < Context > weak Context , String filename ) { Context context = null ; if ( weak Context != null ) { context = weak Context . get ( ) ; if ( context != null ) { String Builder contents = new String Builder ( ) ; Buffered Reader reader = null ; try { File file = new File ( filename ) ; reader = new Buffered Reader ( new File Reader ( file ) ) ; String line = null ; while ( ( line = reader . read Line ( ) ) != null ) { contents . append ( line ) ; contents . append ( System . get Property ( STR_ ) ) ; } } catch ( File Not Found Exception e ) { } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } finally { IO Utils . close Quietly ( reader ) ; } return contents . to String ( ) ; } } return null ; }
default Ior < ? , T > to Ior ( ) { if ( this instanceof Ior ) return ( Ior ) this ; final Optional < T > o = to Optional ( ) ; return o . is Present ( ) ? Ior . primary ( o . get ( ) ) : Ior . secondary ( new No Such Element Exception ( ) ) ; }
public static String clean Virtual Host ( String host ) { host = substring Before ( host , STR_ ) ; if ( host . ends With ( STR_ ) ) { host = host . substring ( NUM_ , host . length ( ) - NUM_ ) ; } return host ; }
public synchronized List < Call > running Calls ( ) { List < Call > result = new Array List < > ( ) ; result . add All ( running Sync Calls ) ; for ( Async Call async Call : running Async Calls ) { result . add ( async Call . get ( ) ) ; } return Collections . unmodifiable List ( result ) ; }
public final double root Mean Prior Squared Error ( ) { if ( m No Priors ) { return Double . Na N ; } return Math . sqrt ( m Sum Prior Sqr Err / m With Class ) ; }
private JSON Object to JSON Object ( ) throws JSON Exception { JSON Object jo = new JSON Object ( ) ; jo . put ( STR_ , property Name ) ; jo . put ( STR_ , property Values ) ; jo . put ( STR_ , p Response Provider Name ) ; return jo ; }
public double log ( ) { return i E * ( double ) i Log Range + Math . log ( i F ) ; }
String make Thread Name ( ) { String result ; if ( object Name == null ) result = STR_ ; else result = object Name . to String ( ) ; return result ; }
public static final double label Cardinality ( Instances D ) { return label Cardinality ( D , D . class Index ( ) ) ; }
public String to Safe String ( ) { String scheme = get Scheme ( ) ; String ssp = get Scheme Specific Part ( ) ; if ( scheme != null ) { if ( scheme . equals Ignore Case ( STR_ ) || scheme . equals Ignore Case ( STR_ ) || scheme . equals Ignore Case ( STR_ ) || scheme . equals Ignore Case ( STR_ ) || scheme . equals Ignore Case ( STR_ ) ) { String Builder builder = new String Builder ( NUM_ ) ; builder . append ( scheme ) ; builder . append ( STR_ ) ; if ( ssp != null ) { for ( int i = NUM_ ; i < ssp . length ( ) ; i ++ ) { char c = ssp . char At ( i ) ; if ( c == STR_ || c == STR_ || c == STR_ ) { builder . append ( c ) ; } else { builder . append ( STR_ ) ; } } } return builder . to String ( ) ; } } String Builder builder = new String Builder ( NUM_ ) ; if ( scheme != null ) { builder . append ( scheme ) ; builder . append ( STR_ ) ; } if ( ssp != null ) { builder . append ( ssp ) ; } return builder . to String ( ) ; }
@ Override public Shape Tile Simplex intersection ( Shape Tile Simplex p other ) { if ( is empty ( ) || p other . is empty ( ) ) return EMPTY ; Array List < Pla Line Int > new arr = new Array List < Pla Line Int > ( lines size ( ) + p other . lines size ( ) ) ; new arr . add All ( lines list ) ; new arr . add All ( p other . lines list ) ; Shape Tile Simplex result = new Shape Tile Simplex ( new arr ) ; return result . remove redundant lines ( ) ; }
public boolean accept ( File f ) { boolean shown = true ; if ( f != null && file Filter != null ) { shown = file Filter . accept ( f ) ; } return shown ; }
public boolean is Set Sample ( ) { return isset bit vector . get ( SAMPLE ISSET ID ) ; }
public final Char Sequence next Token ( Char Sequence csq , char c ) { int n = csq . length ( ) ; for ( int i = index ; i < n ; i ++ ) { if ( csq . char At ( i ) != c ) { int j = i ; for ( ; ( ++ j < n ) && ( csq . char At ( j ) != c ) ; ) { } index = j ; return csq . sub Sequence ( i , j ) ; } } index = n ; return null ; }
public static boolean is In Disabled List ( String classname ) { return DISABLED . contains ( classname ) ; }
protected static Jmm DNS new Jmm DNS ( ) { Jmm DNS dns = null ; Class Delegate delegate = database Class Delegate . get ( ) ; if ( delegate != null ) { dns = delegate . new Jmm DNS ( ) ; } return ( dns != null ? dns : new Jmm DNS Impl ( ) ) ; }
public static String role Value To String ( List < Object Name > role Value ) throws Illegal Argument Exception { if ( role Value == null ) { String exc Msg = STR_ ; throw new Illegal Argument Exception ( exc Msg ) ; } String Builder result = new String Builder ( ) ; for ( Object Name curr Obj Name : role Value ) { if ( result . length ( ) > NUM_ ) result . append ( STR_ ) ; result . append ( curr Obj Name . to String ( ) ) ; } return result . to String ( ) ; }
public static String format Integer If Possible ( double value , int number Of Digits , boolean grouping Character ) { if ( Double . is Na N ( value ) ) { return STR_ ; } if ( Double . is Infinite ( value ) ) { if ( value < NUM_ ) { return STR_ + FORMAT SYMBOLS . get Infinity ( ) ; } else { return FORMAT SYMBOLS . get Infinity ( ) ; } } long long Value = Math . round ( value ) ; if ( Math . abs ( long Value - value ) < epsilon Display Value ) { INTEGER FORMAT . set Grouping Used ( grouping Character ) ; return INTEGER FORMAT . format ( value ) ; } return format Number ( value , number Of Digits , grouping Character ) ; }
private Object legal Or Illegal ( Metadata < Optional > metadata ) { Type type = metadata . get Type ( ) ; if ( type . equals ( String . class ) ) { return safety Cast . with ( STR_ , type ) ; } for ( Type numeric Type : Supported Types . NUMERIC ) { if ( type . equals ( numeric Type ) ) { return safety Cast . with ( NUM_ , type ) ; } } return null ; }
public long file Size ( String path ) throws Illegal State Exception , IO Exception , FTP Illegal Reply Exception , FTP Exception { synchronized ( lock ) { if ( ! connected ) { throw new Illegal State Exception ( STR_ ) ; } if ( ! authenticated ) { throw new Illegal State Exception ( STR_ ) ; } communication . send FTP Command ( STR_ ) ; FTP Reply r = communication . read FTP Reply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new FTP Exception ( r ) ; } communication . send FTP Command ( STR_ + path ) ; r = communication . read FTP Reply ( ) ; touch Auto Noop Timer ( ) ; if ( ! r . is Success Code ( ) ) { throw new FTP Exception ( r ) ; } String [ ] messages = r . get Messages ( ) ; if ( messages . length != NUM_ ) { throw new FTP Illegal Reply Exception ( ) ; } else { try { return Long . parse Long ( messages [ NUM_ ] ) ; } catch ( Throwable t ) { throw new FTP Illegal Reply Exception ( ) ; } } } }
private boolean is In Transit ( Response response ) { Type type = response . get Type ( ) ; boolean acked = response . is Acknowledged ( ) ; boolean timeout = response . is Timed Out ( ) ; boolean result = type == Type . CON && ! acked && ! timeout ; return result ; }
public static List < String > filter Tags ( List < Language Range > priority List , Collection < String > tags , Filtering Mode mode ) { return Locale Matcher . filter Tags ( priority List , tags , mode ) ; }
public static String join ( String separator , Object ... elements ) { if ( elements == null || elements . length == NUM_ ) { return STR_ ; } return join ( separator , Arrays . as List ( elements ) ) ; }
public Set < String > names ( ) { Tree Set < String > result = new Tree Set < String > ( String . CASE INSENSITIVE ORDER ) ; for ( int i = NUM_ ; i < length ( ) ; i ++ ) { result . add ( get Field Name ( i ) ) ; } return Collections . unmodifiable Set ( result ) ; }
public synchronized Iterator < E > iterator ( ) { Array List < E > v = new Array List < E > ( this ) ; return v . iterator ( ) ; }
private static Service Type Base to Service Type Base ( Class cls , boolean need Codebase ) throws Marshal Exception { if ( cls == null ) return null ; Soft Reference cref = ( Soft Reference ) service Map . get ( cls ) ; Service Type Base stype = null ; if ( cref != null ) stype = ( Service Type Base ) cref . get ( ) ; if ( stype == null ) { stype = new Service Type Base ( new Service Type ( cls , to Service Type ( cls . get Superclass ( ) ) , to Service Type ( cls . get Interfaces ( ) ) ) , null ) ; service Map . put ( cls , new Soft Reference ( stype ) ) ; } if ( need Codebase && stype . codebase == null ) stype . set Codebase ( cls ) ; return stype ; }
public String read File ( String file Path ) { String Builder buf = new String Builder ( ) ; String command = String . format ( Image Server Dialog Properties . get String ( STR_ ) , file Path ) ; send Wait For ( command , default Timeout , prompts , buf ) ; log . debug ( buf . to String ( ) ) ; int from = command . length ( ) + NUM_ ; int to = buf . index Of ( PROMPT ) - NUM_ ; if ( to <= from ) { return STR_ ; } return buf . substring ( from , to ) ; }
public static boolean is Primitive ( Type Mirror type ) { switch ( type . get Kind ( ) ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : return true ; default : return false ; } }
public static void close Silently ( Reader reader ) { if ( reader != null ) { try { reader . close ( ) ; } catch ( Exception e ) { } } }
public boolean is Sync Enabled ( ) { return sync Enabled ; }
public boolean is Same As ( Unconditional Value Deref Set other Fact ) { return value Numbers Unconditionally Dereferenced . equals ( other Fact . value Numbers Unconditionally Dereferenced ) && deref Location Set Map . equals ( other Fact . deref Location Set Map ) ; }
protected boolean should Use Post ( String full Query Url ) { return full Query Url . length ( ) > maximum Url Length ; }
public synchronized THL Event next ( ) throws Replicator Exception , Interrupted Exception { return next ( true ) ; }
@ Override public boolean connection Allowed ( String event Name ) { return event Name . equals ( STR_ ) || event Name . equals ( STR_ ) || event Name . equals ( STR_ ) ; }
public static boolean logging Enabled ( ) { return perf Logging On ; }
public static Text value Of ( Char Sequence csq ) { if ( csq instanceof Text ) return ( Text ) csq ; return Text . value Of ( csq . to String ( ) ) ; }
public static long file Length ( File file ) { long length = NUM_ ; if ( file . is File ( ) ) length = file . length ( ) ; else if ( file . is Directory ( ) ) { File [ ] files = file . list Files ( ) ; if ( files != null ) { for ( File f : files ) length += file Length ( f ) ; } } return length ; }
private Modifier system Modifier ( ) { String os = System . get Property ( STR_ ) ; Modifier key Modifier OS ; if ( os != null && os . starts With ( STR_ ) ) key Modifier OS = Key Code Combination . META DOWN ; else key Modifier OS = Key Code Combination . CONTROL DOWN ; return key Modifier OS ; }
private static String descriptor From Proto Array ( String [ ] protos , String return Type ) { String Builder builder = new String Builder ( ) ; builder . append ( STR_ ) ; for ( int i = NUM_ ; i < protos . length ; i ++ ) { builder . append ( protos [ i ] ) ; } builder . append ( STR_ ) ; builder . append ( return Type ) ; return builder . to String ( ) ; }
public R 1 Interval union ( R 1 Interval y ) { if ( is Empty ( ) ) { return y ; } if ( y . is Empty ( ) ) { return this ; } return new R 1 Interval ( Math . min ( lo ( ) , y . lo ( ) ) , Math . max ( hi ( ) , y . hi ( ) ) ) ; }
public boolean valid System Name Format ( String system Name ) { return ( Serial Address . valid System Name Format ( system Name , STR_ ) ) ; }
public Route copy Route ( Route route , String route Name , boolean invert ) { Route new Route = new Route ( route Name ) ; List < Route Location > route List = route . get Locations By Sequence List ( ) ; if ( ! invert ) { for ( Route Location rl : route List ) { copy Route Location ( new Route , rl , null , invert ) ; } } else { for ( int i = route List . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { int y = i - NUM_ ; if ( y < NUM_ ) { y = NUM_ ; } copy Route Location ( new Route , route List . get ( i ) , route List . get ( y ) , invert ) ; } } new Route . set Comment ( route . get Comment ( ) ) ; return new Route ; }
public static Map < String , D Lock Service > snapshot All Services ( ) { Map snapshot = null ; synchronized ( services ) { snapshot = new Hash Map ( services ) ; } return snapshot ; }
public String to XML String ( ) throws SAML 2 Exception { return xml String ; }
public static I Model Meta Data read Default Null ( SQL table ) throws Ade Exception { final String sql = String . format ( STR_ , table ) ; final List < Integer > ids = Special Sql Queries . execute Int List Query ( sql ) ; if ( ids . size ( ) != NUM_ ) { if ( ids . is Empty ( ) ) { return null ; } if ( ids . size ( ) > NUM_ ) { throw new Ade Internal Exception ( STR_ ) ; } } return read Meta Data ( table , ids . get ( NUM_ ) ) ; }
public void testis Auto Increment ( ) { try { assert False ( rsmd . is Auto Increment ( NUM_ ) ) ; } catch ( SQL Exception e 1 ) { fail ( STR_ + e 1 . get Message ( ) ) ; e 1 . print Stack Trace ( ) ; } try { conn . close ( ) ; rsmd . get Schema Name ( NUM_ ) ; fail ( STR_ ) ; } catch ( SQL Exception e ) { } }
public String Buffer format ( double number , String Buffer to Append To , Field Position status ) { int i ; for ( i = NUM_ ; i < choice Limits . length ; ++ i ) { if ( ! ( number >= choice Limits [ i ] ) ) { break ; } } -- i ; if ( i < NUM_ ) i = NUM_ ; return to Append To . append ( choice Formats [ i ] ) ; }
public long size ( ) { return queue Database . count ( ) ; }
@ Suppress Warnings ( STR_ ) @ Override public boolean contains Key ( Object key ) { net . sourceforge . retroweaver . harmony . runtime . java . lang . Comparable < K > object = comparator == null ? to Comparable ( ( K ) key ) : null ; K key K = ( K ) key ; Node < K , V > node = root ; while ( node != null ) { K [ ] keys = node . keys ; int left idx = node . left idx ; int result = object != null ? object . compare To ( keys [ left idx ] ) : - comparator . compare ( keys [ left idx ] , key K ) ; if ( result < NUM_ ) { node = node . left ; } else if ( result == NUM_ ) { return true ; } else { int right idx = node . right idx ; if ( left idx != right idx ) { result = cmp ( object , key K , keys [ right idx ] ) ; } if ( result > NUM_ ) { node = node . right ; } else if ( result == NUM_ ) { return true ; } else { int low = left idx + NUM_ , mid = NUM_ , high = right idx - NUM_ ; while ( low <= high ) { mid = ( low + high ) > > > NUM_ ; result = cmp ( object , key K , keys [ mid ] ) ; if ( result > NUM_ ) { low = mid + NUM_ ; } else if ( result == NUM_ ) { return true ; } else { high = mid - NUM_ ; } } return false ; } } } return false ; }
public static boolean replication Group Has No Other Snapshot ( Db Client db Client , String rg Name , Collection < URI > snapshots , URI storage ) { List < Block Snapshot > snapshots In RG = get Snapshots Part Of Replication Group ( rg Name , storage , db Client ) ; List < URI > snapshot U Rs In RG = new Array List ( transform ( snapshots In RG , fctn Data Object To ID ( ) ) ) ; s logger . info ( STR_ , snapshots In RG . size ( ) , snapshots . size ( ) ) ; snapshot U Rs In RG . remove All ( snapshots ) ; return snapshot U Rs In RG . is Empty ( ) ; }
public static Big Decimal parse Big Decimal For Entity ( String big Decimal String ) throws Number Format Exception { if ( big Decimal String == null ) { return null ; } big Decimal String = big Decimal String . trim ( ) ; big Decimal String = big Decimal String . replace All ( STR_ , STR_ ) ; if ( big Decimal String . length ( ) < NUM_ ) { return null ; } return new Big Decimal ( big Decimal String ) ; }
public boolean do Mouse Pressed ( Mouse Event event , Positionable pos ) { if ( draw Frame instanceof Draw Polygon ) { Draw Polygon f = ( Draw Polygon ) draw Frame ; f . anchor Point ( event . get X ( ) , event . get Y ( ) ) ; } if ( pos instanceof Positionable Shape && editor . is Editable ( ) ) { if ( ! pos . equals ( current Selection ) ) { if ( current Selection != null ) { current Selection . remove Handles ( ) ; } current Selection = ( Positionable Shape ) pos ; current Selection . draw Handles ( ) ; } return true ; } if ( current Selection != null ) { current Selection . remove Handles ( ) ; current Selection = null ; } return false ; }
private static String to Unicode Lower Case ( String s ) { int n = s . length ( ) ; char [ ] result = new char [ n ] ; for ( int i = NUM_ ; i < n ; ++ i ) { result [ i ] = Character . to Lower Case ( s . char At ( i ) ) ; } return new String ( result ) ; }
public Instance next Element ( Instances dataset ) { Instance result ; result = null ; if ( is Incremental ( ) ) { if ( m Incremental Buffer != null ) { result = m Incremental Buffer ; m Incremental Buffer = null ; } else { try { result = m Loader . get Next Instance ( dataset ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; result = null ; } } } else { if ( m Batch Counter < m Batch Buffer . num Instances ( ) ) { result = m Batch Buffer . instance ( m Batch Counter ) ; m Batch Counter ++ ; } } if ( result != null ) { result . set Dataset ( dataset ) ; } return result ; }
public static boolean is Trait ( final Class clazz ) { return clazz != null && clazz . get Annotation ( Trait . class ) != null ; }
void insert ( V val , K key ) { Array List < K > list = map . get ( val ) ; if ( list == null ) { list = new Array List < K > ( NUM_ ) ; map . put ( clone Value ( val ) , list ) ; } list . add ( key ) ; }
public String to Display String ( ) { if ( origin server != null ) resolve Weak ( ) ; if ( domain Name != null ) { String str ; if ( type == SID TYPE DOMAIN ) { str = domain Name ; } else if ( type == SID TYPE WKN GRP || domain Name . equals ( STR_ ) ) { if ( type == SID TYPE UNKNOWN ) { str = to String ( ) ; } else { str = acct Name ; } } else { str = domain Name + STR_ + acct Name ; } return str ; } return to String ( ) ; }
public Iterator < E > snapshot Iterator ( ) { List < E > l = new Array List < E > ( ) ; l . add All ( this ) ; return l . iterator ( ) ; }
@ Override public Table summary ( ) { Table table = Table . create ( STR_ + name ( ) ) ; Category Column measure = Category Column . create ( STR_ ) ; Category Column value = Category Column . create ( STR_ ) ; table . add Column ( measure ) ; table . add Column ( value ) ; measure . add ( STR_ ) ; value . add ( String . value Of ( size ( ) ) ) ; measure . add ( STR_ ) ; value . add ( String . value Of ( count Missing ( ) ) ) ; measure . add ( STR_ ) ; value . add ( String . value Of ( min ( ) ) ) ; measure . add ( STR_ ) ; value . add ( String . value Of ( max ( ) ) ) ; return table ; }
public static Color update Brightness ( Color color , float factor ) { float [ ] hsb = new float [ NUM_ ] ; Color . RG Bto HSB ( color . get Red ( ) , color . get Green ( ) , color . get Blue ( ) , hsb ) ; return new Color ( Color . HS Bto RGB ( hsb [ NUM_ ] , hsb [ NUM_ ] , Math . min ( NUM_ , hsb [ NUM_ ] * factor ) ) ) ; }
public static int SAX ( int levels , double value ) { if ( levels > SAX MAX LEVELS || levels < NUM_ ) { throw new Runtime Exception ( ) ; } if ( null == INVNORM BOUNDS [ levels - NUM_ ] ) { synchronized ( INVNORM BOUNDS ) { if ( null == INVNORM BOUNDS [ levels - NUM_ ] ) { INVNORM BOUNDS [ levels - NUM_ ] = get Bounds ( NUM_ << levels ) ; } } } int idx = Arrays . binary Search ( INVNORM BOUNDS [ levels - NUM_ ] , value ) ; if ( idx >= NUM_ ) { return idx ; } else { return - idx - NUM_ ; } }
public void await ( ) throws Interrupted Exception { connection Factory . join ( ) ; }
private int is Head Assigned Here ( Signal Head head , Layout Turnout l Turnout ) { String sys Name = head . get System Name ( ) ; String u Name = head . get User Name ( ) ; String name = l Turnout . get Signal A 1 Name ( ) ; if ( ( name != null ) && ( name . length ( ) > NUM_ ) && ( ( name . equals ( u Name ) ) || ( name . equals ( sys Name ) ) ) ) { return A 1 ; } name = l Turnout . get Signal A 2 Name ( ) ; if ( ( name != null ) && ( name . length ( ) > NUM_ ) && ( ( name . equals ( u Name ) ) || ( name . equals ( sys Name ) ) ) ) { return A 2 ; } name = l Turnout . get Signal A 3 Name ( ) ; if ( ( name != null ) && ( name . length ( ) > NUM_ ) && ( ( name . equals ( u Name ) ) || ( name . equals ( sys Name ) ) ) ) { return A 3 ; } name = l Turnout . get Signal B 1 Name ( ) ; if ( ( name != null ) && ( name . length ( ) > NUM_ ) && ( ( name . equals ( u Name ) ) || ( name . equals ( sys Name ) ) ) ) { return B 1 ; } name = l Turnout . get Signal B 2 Name ( ) ; if ( ( name != null ) && ( name . length ( ) > NUM_ ) && ( ( name . equals ( u Name ) ) || ( name . equals ( sys Name ) ) ) ) { return B 2 ; } name = l Turnout . get Signal C 1 Name ( ) ; if ( ( name != null ) && ( name . length ( ) > NUM_ ) && ( ( name . equals ( u Name ) ) || ( name . equals ( sys Name ) ) ) ) { return C 1 ; } name = l Turnout . get Signal C 2 Name ( ) ; if ( ( name != null ) && ( name . length ( ) > NUM_ ) && ( ( name . equals ( u Name ) ) || ( name . equals ( sys Name ) ) ) ) { return C 2 ; } name = l Turnout . get Signal D 1 Name ( ) ; if ( ( name != null ) && ( name . length ( ) > NUM_ ) && ( ( name . equals ( u Name ) ) || ( name . equals ( sys Name ) ) ) ) { return D 1 ; } name = l Turnout . get Signal D 2 Name ( ) ; if ( ( name != null ) && ( name . length ( ) > NUM_ ) && ( ( name . equals ( u Name ) ) || ( name . equals ( sys Name ) ) ) ) { return D 2 ; } return NONE ; }
private void copy To Buffer ( Buffer b Dest ) { if ( reassembled Data Full Size <= MAX H 264 FRAME SIZE ) { byte [ ] final Data = new byte [ reassembled Data Full Size + NUM_ ] ; int final Data Pos = NUM_ ; final Data [ final Data Pos ] = reassembled Data NAL Header ; final Data Pos += NUM_ ; int pos Current = reassembled Data Pos Seq Start ; int pos Seq = NUM_ ; while ( ( pos Current & VIDEO DECODER MAX PAYLOADS CHUNKS MASK ) != reassembled Data Pos Seq End ) { pos Seq = pos Current & VIDEO DECODER MAX PAYLOADS CHUNKS MASK ; System . arraycopy ( reassembled Data [ pos Seq ] , NUM_ , final Data , final Data Pos , reassembled Data Size [ pos Seq ] ) ; final Data Pos += reassembled Data Size [ pos Seq ] ; pos Current ++ ; } System . arraycopy ( reassembled Data [ reassembled Data Pos Seq End ] , NUM_ , final Data , final Data Pos , reassembled Data Size [ reassembled Data Pos Seq End ] ) ; b Dest . set Data ( final Data ) ; b Dest . set Length ( reassembled Data Size [ reassembled Data Pos Seq End ] ) ; b Dest . set Offset ( NUM_ ) ; b Dest . set Timestamp ( timestamp ) ; b Dest . set Format ( format ) ; b Dest . set Flags ( Buffer . FLAG RTP MARKER | Buffer . FLAG RTP TIME ) ; b Dest . set Video Orientation ( video Orientation ) ; b Dest . set Sequence Number ( seq Number ) ; } reassembled Data = null ; }
public int random Index Choice ( List < Integer > weights , Set < Integer > omit Indices ) { int result = NUM_ , index ; double max Key = NUM_ ; double u , key ; int weight ; for ( List Iterator < Integer > it = weights . list Iterator ( ) ; it . has Next ( ) ; ) { index = it . next Index ( ) ; weight = it . next ( ) ; if ( omit Indices . contains ( index ) ) continue ; u = random . next Double ( ) ; key = Math . pow ( u , ( NUM_ / weight ) ) ; if ( key > max Key ) { max Key = key ; result = index ; } } return result ; }
protected boolean is Wrapped Algorithm ( ) { return ( m weka Algo Name != null && m weka Algo Name . length ( ) > NUM_ ) ; }
public boolean has Adds ( ) { return ! added Clusters . is Empty ( ) || ! added Hosts . is Empty ( ) || ! added Initiators . is Empty ( ) ; }
public static double remainder ( double dividend , double divisor ) { if ( USE JDK MATH ) { } if ( Double . is Infinite ( divisor ) ) { if ( Double . is Infinite ( dividend ) ) { return Double . Na N ; } else { return dividend ; } } double value = dividend % divisor ; if ( Math . abs ( value + value ) > Math . abs ( divisor ) ) { return value + ( ( value > NUM_ ) ? - Math . abs ( divisor ) : Math . abs ( divisor ) ) ; } else { return value ; } }
private static File find Our Jar ( ) { return new File ( Class Root Finder . find Class Root Of Class ( Public Api Creator App . class ) ) ; }
public static String current Platform Name ( ) { String os = System . get Property ( STR_ ) ; if ( os . starts With ( STR_ ) ) { return STR_ ; } else if ( os . starts With ( STR_ ) ) { return STR_ ; } else if ( os . starts With ( STR_ ) ) { return STR_ ; } return STR_ ; }
@ Override public Transfer Result < V , S > visit Ternary Expression ( Ternary Expression Node n , Transfer Input < V , S > p ) { Transfer Result < V , S > result = super . visit Ternary Expression ( n , p ) ; S store = result . get Regular Store ( ) ; V then Value = p . get Value Of Sub Node ( n . get Then Operand ( ) ) ; V else Value = p . get Value Of Sub Node ( n . get Else Operand ( ) ) ; V result Value = null ; if ( then Value != null && else Value != null ) { result Value = then Value . least Upper Bound ( else Value ) ; } return new Regular Transfer Result < > ( finish Value ( result Value , store ) , store ) ; }
static private B Op Filter Base new Distinct Filter ( final AST 2 B Op Context ctx , final Predicate < ? > pred , final Data Set Summary summary , final boolean hash Join ) { boolean native Distinct = hash Join && ctx . native Distinct SPO ; if ( native Distinct ) { final Long range Count = ( Long ) pred . get Property ( Annotations . ESTIMATED CARDINALITY ) ; if ( range Count != null ) { if ( range Count . long Value ( ) < ctx . native Distinct SPO Threshold ) { native Distinct = false ; } } else { log . warn ( STR_ + pred ) ; } } if ( false && native Distinct && summary != null ) { if ( summary . nknown < ctx . native Distinct SPO Threshold ) { native Distinct = false ; } } if ( native Distinct ) { @ Suppress Warnings ( { STR_ , STR_ } ) final SPO Key Order index Key Order = SPO Key Order . get Key Order ( ( I Predicate ) pred , NUM_ ) ; return Native Distinct Filter . new Instance ( index Key Order ) ; } else { return Distinct Filter . new Instance ( ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
static public final float random ( float start , float end ) { return start + random . next Float ( ) * ( end - start ) ; }
public static short parse Short ( java . lang . String s ) throws java . lang . Number Format Exception { return ( short ) Integer . parse Int ( s ) ; }
static public double gamma ( double x ) throws Arithmetic Exception { double P [ ] = { NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ , NUM_ } ; double Q [ ] = { - NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ , - NUM_ , NUM_ , NUM_ } ; double p , z ; int i ; double q = Math . abs ( x ) ; if ( q > NUM_ ) { if ( x < NUM_ ) { p = Math . floor ( q ) ; if ( p == q ) throw new Arithmetic Exception ( STR_ ) ; i = ( int ) p ; z = q - p ; if ( z > NUM_ ) { p += NUM_ ; z = q - p ; } z = q * Math . sin ( Math . PI * z ) ; if ( z == NUM_ ) throw new Arithmetic Exception ( STR_ ) ; z = Math . abs ( z ) ; z = Math . PI / ( z * stirling Formula ( q ) ) ; return - z ; } else { return stirling Formula ( x ) ; } } z = NUM_ ; while ( x >= NUM_ ) { x -= NUM_ ; z *= x ; } while ( x < NUM_ ) { if ( x == NUM_ ) { throw new Arithmetic Exception ( STR_ ) ; } else if ( x > - NUM_ ) { return ( z / ( ( NUM_ + NUM_ * x ) * x ) ) ; } z /= x ; x += NUM_ ; } while ( x < NUM_ ) { if ( x == NUM_ ) { throw new Arithmetic Exception ( STR_ ) ; } else if ( x < NUM_ ) { return ( z / ( ( NUM_ + NUM_ * x ) * x ) ) ; } z /= x ; x += NUM_ ; } if ( ( x == NUM_ ) || ( x == NUM_ ) ) return z ; x -= NUM_ ; p = Polynomial . polevl ( x , P , NUM_ ) ; q = Polynomial . polevl ( x , Q , NUM_ ) ; return z * p / q ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; new Vector . add Element ( STR_ ) ; return new Vector . elements ( ) ; }
private static int count Run And Make Ascending ( Object [ ] a , int lo , int hi , Comparator c ) { assert lo < hi ; int run Hi = lo + NUM_ ; if ( run Hi == hi ) return NUM_ ; if ( c . compare ( a [ run Hi ++ ] , a [ lo ] ) < NUM_ ) { while ( run Hi < hi && c . compare ( a [ run Hi ] , a [ run Hi - NUM_ ] ) < NUM_ ) run Hi ++ ; reverse Range ( a , lo , run Hi ) ; } else { while ( run Hi < hi && c . compare ( a [ run Hi ] , a [ run Hi - NUM_ ] ) >= NUM_ ) run Hi ++ ; } return run Hi - lo ; }
public final Sequence extend ( Typed Operation operation , Variable ... inputs ) { return extend ( operation , Arrays . as List ( inputs ) ) ; }
public boolean is Disable Custom Meta Class Lookup ( ) { return disable Custom Meta Class Lookup ; }
public boolean is External File ( Proto File file ) { String file Path = file . get Simple Name ( ) ; for ( String common Path : COMMON PROTO PATHS ) { if ( file Path . starts With ( common Path ) ) { return true ; } } return false ; }
private static int spins For ( Node pred , boolean have Data ) { if ( MP && pred != null ) { if ( pred . is Data != have Data ) return FRONT SPINS + CHAINED SPINS ; if ( pred . is Matched ( ) ) return FRONT SPINS ; if ( pred . waiter == null ) return CHAINED SPINS ; } return NUM_ ; }
public Event Point min ( ) { return events . poll ( ) ; }
public static String crypt ( final String text , final String salt ) { try { final Message Digest md = Message Digest . get Instance ( SHA 512 ) ; md . update ( salt . get Bytes ( Standard Charsets . UTF 8 ) ) ; final byte [ ] digest = md . digest ( text . get Bytes ( Standard Charsets . UTF 8 ) ) ; return String . format ( STR_ , new Big Integer ( NUM_ , digest ) ) ; } catch ( final No Such Algorithm Exception e ) { throw new Illegal State Exception ( STR_ , e ) ; } }
public static You Tube Video match URL ( String url , String text ) { Matcher m = URL PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return new You Tube Video ( m . group ( NUM_ ) , text ) ; } else { return null ; } }
private boolean backtrack For Swap With Previous ( Featurizable < I String , String > f ) { if ( f . prior == null ) return false ; if ( f Start ( f . prior ) < f Start ( f ) ) return false ; int index Right Current Phrase = f End ( f ) + NUM_ ; int index Left Previous Phrase = f Start ( f . prior ) - NUM_ ; if ( index Left Previous Phrase + NUM_ == index Right Current Phrase ) return true ; Coverage Set f Coverage = f . derivation . source Coverage ; for ( int i = index Right Current Phrase ; i <= index Left Previous Phrase ; ++ i ) { if ( ! f Coverage . get ( i ) ) return false ; } Featurizable < I String , String > tmp f = f . prior ; tmp Coverage . clear ( ) ; boolean found Adj Phrase = false ; while ( true ) { if ( f Start ( tmp f ) == index Right Current Phrase ) found Adj Phrase = true ; int f Start = f Start ( tmp f ) ; int f End = f End ( tmp f ) ; tmp Coverage . set ( f Start , f End + NUM_ ) ; if ( found Adj Phrase && contiguous ( tmp Coverage ) ) break ; if ( f End < index Right Current Phrase ) return false ; tmp f = tmp f . prior ; if ( tmp f == null ) return false ; } return true ; }
public static Excluded Refs . Builder create App Defaults ( ) { Excluded Refs . Builder excluded = create Android Defaults ( ) ; if ( SDK INT >= KITKAT && SDK INT <= LOLLIPOP ) { excluded . instance Field ( STR_ , STR_ ) ; } if ( SDK INT <= KITKAT ) { excluded . instance Field ( STR_ , STR_ ) ; excluded . instance Field ( STR_ , STR_ ) ; } if ( SDK INT == LOLLIPOP ) { excluded . static Field ( STR_ , STR_ ) ; } if ( SDK INT < LOLLIPOP MR 1 ) { excluded . static Field ( STR_ , STR_ ) ; } if ( SDK INT < LOLLIPOP ) { excluded . instance Field ( STR_ , STR_ ) ; excluded . instance Field ( STR_ , STR_ ) ; excluded . instance Field ( STR_ , STR_ ) ; } if ( SDK INT >= KITKAT && SDK INT <= LOLLIPOP MR 1 ) { excluded . instance Field ( STR_ , STR_ ) ; excluded . instance Field ( STR_ , STR_ ) ; excluded . instance Field ( STR_ , STR_ ) ; } if ( SDK INT >= ICE CREAM SANDWICH MR 1 && SDK INT <= LOLLIPOP MR 1 ) { excluded . instance Field ( STR_ , STR_ ) ; } if ( SDK INT >= ICE CREAM SANDWICH && SDK INT <= LOLLIPOP MR 1 ) { excluded . instance Field ( STR_ , STR_ ) ; } if ( SDK INT >= JELLY BEAN || SDK INT <= LOLLIPOP MR 1 ) { excluded . instance Field ( STR_ , STR_ ) ; } if ( MOTOROLA . equals ( MANUFACTURER ) && SDK INT == KITKAT ) { excluded . instance Field ( STR_ , STR_ ) ; } if ( SAMSUNG . equals ( MANUFACTURER ) && SDK INT == KITKAT ) { excluded . static Field ( STR_ , STR_ ) ; } if ( SAMSUNG . equals ( MANUFACTURER ) && SDK INT >= KITKAT && SDK INT <= LOLLIPOP ) { excluded . static Field ( STR_ , STR_ ) ; } if ( LG . equals ( MANUFACTURER ) && SDK INT >= KITKAT && SDK INT <= LOLLIPOP ) { excluded . static Field ( STR_ , STR_ ) ; } if ( SAMSUNG . equals ( MANUFACTURER ) && SDK INT == KITKAT ) { excluded . static Field ( STR_ , STR_ ) ; } if ( NVIDIA . equals ( MANUFACTURER ) && SDK INT == KITKAT ) { excluded . instance Field ( STR_ , STR_ ) ; } if ( SAMSUNG . equals ( MANUFACTURER ) && SDK INT == KITKAT ) { excluded . static Field ( STR_ , STR_ ) ; } if ( SAMSUNG . equals ( MANUFACTURER ) && SDK INT == KITKAT ) { excluded . instance Field ( STR_ , STR_ ) ; } if ( SAMSUNG . equals ( MANUFACTURER ) && SDK INT == KITKAT ) { excluded . instance Field ( STR_ , STR_ ) ; } if ( SAMSUNG . equals ( MANUFACTURER ) && SDK INT == KITKAT ) { excluded . instance Field ( STR_ , STR_ ) ; } if ( SAMSUNG . equals ( MANUFACTURER ) && SDK INT == KITKAT ) { excluded . static Field ( STR_ , STR_ ) ; } return excluded ; }
public static String to Base 64 ( long value ) { int low = ( int ) ( value & NUM_ ) ; int high = ( int ) ( value > > NUM_ ) ; String Builder sb = new String Builder ( ) ; boolean have Non Zero = base 64 Append ( sb , ( high > > NUM_ ) & NUM_ , false ) ; have Non Zero = base 64 Append ( sb , ( high > > NUM_ ) & NUM_ , have Non Zero ) ; have Non Zero = base 64 Append ( sb , ( high > > NUM_ ) & NUM_ , have Non Zero ) ; have Non Zero = base 64 Append ( sb , ( high > > NUM_ ) & NUM_ , have Non Zero ) ; have Non Zero = base 64 Append ( sb , ( high > > NUM_ ) & NUM_ , have Non Zero ) ; int v = ( ( high & NUM_ ) << NUM_ ) | ( ( low > > NUM_ ) & NUM_ ) ; have Non Zero = base 64 Append ( sb , v , have Non Zero ) ; have Non Zero = base 64 Append ( sb , ( low > > NUM_ ) & NUM_ , have Non Zero ) ; have Non Zero = base 64 Append ( sb , ( low > > NUM_ ) & NUM_ , have Non Zero ) ; have Non Zero = base 64 Append ( sb , ( low > > NUM_ ) & NUM_ , have Non Zero ) ; base 64 Append ( sb , ( low > > NUM_ ) & NUM_ , have Non Zero ) ; base 64 Append ( sb , low & NUM_ , true ) ; return sb . to String ( ) ; }
public static Boolean value Of ( String value ) { return value != null ? Boolean . value Of ( value ) : null ; }
public static Set < String > uri List To Set ( List < URI > uris ) { Set < String > set = new Hash Set < String > ( ) ; if ( uris != null && ! uris . is Empty ( ) ) { for ( URI uri : uris ) { set . add ( uri . to String ( ) ) ; } } return set ; }
public String end Tbl Data Action Default Href Display ( Child Content Display Event event ) { String lbl = ( String ) tbl Model . get Value ( TBL DATA ACTION DEFAULT LABEL ) ; return ( ( lbl != null ) && ( lbl . length ( ) > NUM_ ) ) ? event . get Content ( ) : STR_ ; }
@ Override public boolean is Secure ( ) { if ( s == null || ssl Socket Class == null ) return false ; else return ssl Socket Class . is Assignable From ( s . get Class ( ) ) ; }
public String read Until ( char c ) { int ix = data . index Of ( c , pos ) ; if ( ix == - NUM_ ) throw new Runtime Exception ( STR_ + c + STR_ ) ; return read N ( data . index Of ( c , pos ) - pos ) ; }
public boolean is Closed ( ) { return this . closed ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
@ Override public Multivariate Table to Discrete ( ) { if ( discrete Cache == null ) { Multivariate Table . Builder probs = new Multivariate Table . Builder ( ) ; double incr = NUM_ / samples . size ( ) ; for ( Assignment sample : samples ) { Assignment trimmed = sample . get Trimmed ( variables ) ; probs . increment Row ( trimmed , incr ) ; } discrete Cache = probs . build ( ) ; } return discrete Cache ; }
public Query like ( int doc Num ) throws IO Exception { if ( field Names == null ) { Collection < String > fields = Multi Fields . get Indexed Fields ( ir ) ; field Names = fields . to Array ( new String [ fields . size ( ) ] ) ; } return create Query ( retrieve Terms ( doc Num ) ) ; }
public boolean is Crossed Out ( ) { return modifiers . contains ( SGR . CROSSED OUT ) ; }
public static int binary Search Ceil ( long [ ] a , long key , boolean inclusive , boolean stay In Bounds ) { int index = Arrays . binary Search ( a , key ) ; index = index < NUM_ ? ~ index : ( inclusive ? index : ( index + NUM_ ) ) ; return stay In Bounds ? Math . min ( a . length - NUM_ , index ) : index ; }
public Object next Object ( Random rnd , boolean allow Null ) { int [ ] types = random Type ; int range = types . length ; if ( ! allow Null ) range -- ; int type = types [ rnd . next Int ( range ) ] ; return next Object ( rnd , type , allow Null ) ; }
private boolean is Output Dir Available ( ) { return output Dir != null && ( output Dir . exists ( ) && output Dir . is Directory ( ) || output Dir . mkdirs ( ) ) ; }
public static Response parse XML ( Input Stream is ) throws SAML Exception { Document doc = XML Utils . to DOM Document ( is , SAML Utils . debug ) ; Element root = doc . get Document Element ( ) ; return new Response ( root ) ; }
protected DBMS Event extract Event Row Level ( String first Data ) throws Interrupted Exception , Extractor Exception { DBMS Event dbms Event = null ; Row Change Data row Change Data = new Row Change Data ( ) ; One Row Change one Row Change = null ; boolean first = true ; if ( ! initialized ) throw new Extractor Exception ( STR_ ) ; Array List < DBMS Data > trx = new Array List < DBMS Data > ( NUM_ ) ; while ( true ) { String data ; if ( first ) data = first Data ; else data = get Next Op ( ) ; first = false ; one Row Change = parser . parse ( data , last SCN ) ; if ( one Row Change == null ) { trx . add ( row Change Data ) ; dbms Event = new DBMS Event ( last Event ID , trx , new Timestamp ( System . current Time Millis ( ) ) ) ; break ; } else { row Change Data . append One Row Change ( one Row Change ) ; } } return dbms Event ; }
public static int byte Length Unicode ( final String s ) { return Bytes . SIZEOF INT + s . length ( ) ; }
public Shape rectangle ( double x , double y , double width , double height ) { m rect . set Frame ( x , y , width , height ) ; return m rect ; }
private Dimension layout Size ( Container target , boolean preferred ) { synchronized ( target . get Tree Lock ( ) ) { int target Width = target . get Size ( ) . width ; if ( target Width == NUM_ ) target Width = Integer . MAX VALUE ; int hgap = get Hgap ( ) ; int vgap = get Vgap ( ) ; Insets insets = target . get Insets ( ) ; int horizontal Insets And Gap = insets . left + insets . right + ( hgap * NUM_ ) ; int max Width = target Width - horizontal Insets And Gap ; Dimension dim = new Dimension ( NUM_ , NUM_ ) ; int row Width = NUM_ ; int row Height = NUM_ ; int nmembers = target . get Component Count ( ) ; for ( int i = NUM_ ; i < nmembers ; i ++ ) { Component m = target . get Component ( i ) ; if ( m . is Visible ( ) ) { Dimension d = preferred ? m . get Preferred Size ( ) : m . get Minimum Size ( ) ; if ( row Width + d . width > max Width ) { add Row ( dim , row Width , row Height ) ; row Width = NUM_ ; row Height = NUM_ ; } if ( row Width != NUM_ ) { row Width += hgap ; } row Width += d . width ; row Height = Math . max ( row Height , d . height ) ; } } add Row ( dim , row Width , row Height ) ; dim . width += horizontal Insets And Gap ; dim . height += insets . top + insets . bottom + vgap * NUM_ ; Container scroll Pane = Swing Utilities . get Ancestor Of Class ( J Scroll Pane . class , target ) ; if ( scroll Pane != null ) { dim . width -= ( hgap + NUM_ ) ; } return dim ; } }
public boolean is Has Variables ( ) { return variable References != null && ! variable References . is Empty ( ) ; }
public final List < V > values In Selection ( RT Edit Text editor ) { List < V > result = new Array List < > ( ) ; Selection selection = get Selection ( editor ) ; List < RT Span < V > > spans = get Spans ( editor . get Text ( ) , selection , Span Collect Mode . SPAN FLAGS ) ; for ( RT Span < V > span : spans ) { result . add ( span . get Value ( ) ) ; } return result ; }
static int resize Stamp ( int n ) { return Integer . number Of Leading Zeros ( n ) | ( NUM_ << ( RESIZE STAMP BITS - NUM_ ) ) ; }
public static Number acosh ( Number a ) { return Fast Math . acosh ( a . double Value ( ) ) ; }
private void init Auth Config ( ) { if ( options != null ) { debug . message ( STR_ ) ; gateway List = ( Set ) options . get ( TRUSTED GATEWAY LIST ) ; if ( ( gateway List != null ) && ( ! gateway List . is Empty ( ) ) && ( gateway List . contains ( STR_ ) ) ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ ) ; } error Msg Key = STR_ ; } else { parameter Name List = ( Set ) options . get ( MSISDN PARAMETER NAME ) ; search Header List = ( Set ) options . get ( MSISDN HEADER SEARCH ) ; if ( ( search Header List == null ) || ( search Header List . is Empty ( ) ) ) { search All Headers = true ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + search All Headers ) ; } } set MSISDN Auth Level ( ) ; } } else { debug . error ( STR_ ) ; error Msg Key = STR_ ; } return ; }
@ Override public Match Result match ( String str ) { String input = str . trim ( ) ; if ( input . equals Ignore Case ( string ) ) { return new Match Result ( NUM_ , string . length ( ) ) ; } else { return new Match Result ( false ) ; } }
public boolean is Dirty ( Entity entity , String ... attributes ) { Set < String > dirty Fields = get Dirty Fields ( entity ) ; for ( String attribute : attributes ) { if ( dirty Fields . contains ( attribute ) ) return true ; } return false ; }
private String create Table ( int row Count , Tree Map < String , String > fact Table Col 2 Lookup Col , Tree Map < String , String > lookup Col 2 Fact Table Col , Tree Set < String > used Cols ) throws Exception { try { Tree Set < String > default Columns = new Tree Set < > ( String . CASE INSENSITIVE ORDER ) ; String Buffer sb = new String Buffer ( ) ; for ( int i = NUM_ ; i < row Count ; ) { Linked List < String > column Values = create Row ( fact Table Col 2 Lookup Col , used Cols , default Columns ) ; if ( ! match All Composite Keys ( lookup Col 2 Fact Table Col , column Values ) ) { if ( unlinkable Row Count < unlinkable Row Count Max ) { unlinkable Row Count ++ ; } else { continue ; } } for ( String c : column Values ) sb . append ( c + STR_ ) ; sb . delete Char At ( sb . length ( ) - NUM_ ) ; sb . append ( System . get Property ( STR_ ) ) ; i ++ ; } print Column Mappings ( fact Table Col 2 Lookup Col , used Cols , default Columns ) ; return sb . to String ( ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; System . exit ( NUM_ ) ; } return null ; }
public Iterator < Data Point > iterator ( ) { return list . iterator ( ) ; }
public Input Stream allocate Stream ( String key ) { Raw Byte Allocator alloc = find Raw Byte Allocator ( key ) ; Input Stream input = new Raw Byte Input Stream ( alloc ) ; return input ; }
@ Override public Enumeration < Option > list Options ( ) { Enumeration < Option > super Opts = super . list Options ( ) ; Vector < Option > new Vector = new Vector < Option > ( ) ; while ( super Opts . has More Elements ( ) ) { new Vector . add Element ( super Opts . next Element ( ) ) ; } new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
@ Override public Promise < Auth Status , Authentication Exception > secure Response ( Message Info Context message Info , Subject service Subject ) { return new Result Promise ( SEND SUCCESS ) ; }
private Set < Unit Calculation Detail > clone Unit Calculation Details ( ) { final Set < Unit Calculation Detail > unit Calculation Detail Clones = new Hash Set < Unit Calculation Detail > ( ) ; for ( final Unit Calculation Detail unit Calc Detail : get Unit Calculation Details ( ) ) unit Calculation Detail Clones . add ( new Unit Calculation Detail ( unit Calc Detail ) ) ; return unit Calculation Detail Clones ; }
private static int find Esds Position ( Parsable Byte Array parent , int position , int size ) { int child Atom Position = parent . get Position ( ) ; while ( child Atom Position - position < size ) { parent . set Position ( child Atom Position ) ; int child Atom Size = parent . read Int ( ) ; Assertions . check Argument ( child Atom Size > NUM_ , STR_ ) ; int child Type = parent . read Int ( ) ; if ( child Type == Atom . TYPE esds ) { return child Atom Position ; } child Atom Position += child Atom Size ; } return - NUM_ ; }
public final boolean is Secure ( ) { return is Secure ; }
public int size ( ) { return is Null ( ) ? NUM_ : this . end - this . start + NUM_ ; }
public List < String > build ( final String tool Location ) { final List < String > command Line Parts = new Array List < String > ( arguments ) ; command Line Parts . add ( NUM_ , tool Location ) ; return Collections . unmodifiable List ( command Line Parts ) ; }
private int find Insert Position ( String new Tab Name ) { if ( order == Tab Order . ALPHABETIC ) { for ( int i = NUM_ ; i < tabs . get Tab Count ( ) ; i ++ ) { if ( new Tab Name . compare To Ignore Case ( tabs . get Title At ( i ) ) < NUM_ ) { return i ; } } } return tabs . get Tab Count ( ) ; }
@ Override public boolean contains Value ( Object value ) { poll ( ) ; if ( value != null ) { for ( int i = element Data . length ; -- i >= NUM_ ; ) { Entry < K , V > entry = element Data [ i ] ; while ( entry != null ) { K key = entry . get ( ) ; if ( ( key != null || entry . is Null ) && value . equals ( entry . value ) ) { return true ; } entry = entry . next ; } } } else { for ( int i = element Data . length ; -- i >= NUM_ ; ) { Entry < K , V > entry = element Data [ i ] ; while ( entry != null ) { K key = entry . get ( ) ; if ( ( key != null || entry . is Null ) && entry . value == null ) { return true ; } entry = entry . next ; } } } return false ; }
private static boolean valid Method ( String name ) { int len = name . length ( ) ; if ( len == NUM_ ) { return false ; } char c = name . char At ( NUM_ ) ; if ( ! Character . is Java Identifier Start ( c ) && ! ( c == STR_ && len > NUM_ ) ) { return false ; } if ( c != STR_ && name . char At ( len - NUM_ ) == STR_ ) { len -- ; } while ( -- len >= NUM_ ) { if ( ! Character . is Java Identifier Part ( name . char At ( len ) ) ) { return false ; } } return true ; }
public boolean is Cancelled ( ) { return m Is Cancelled ; }
public Coord clone ( ) { Coord clone = null ; try { clone = ( Coord ) super . clone ( ) ; } catch ( Clone Not Supported Exception e ) { e . print Stack Trace ( ) ; System . exit ( - NUM_ ) ; } return clone ; }
public boolean is Mixed ( ) { return bidi Base . is Mixed ( ) ; }
private Immutable Set < Cassandra Jmx Compaction Client > create Compaction Clients ( Cassandra Jmx Compaction Config jmx Config ) { Set < Cassandra Jmx Compaction Client > clients = Sets . new Hash Set ( ) ; Set < Inet Socket Address > servers = config . servers ( ) ; int jmx Port = jmx Config . port ( ) ; for ( Inet Socket Address addr : servers ) { Cassandra Jmx Compaction Client client = create Compaction Client ( addr . get Host String ( ) , jmx Port , jmx Config . username ( ) , jmx Config . password ( ) ) ; clients . add ( client ) ; } return Immutable Set . copy Of ( clients ) ; }
public synchronized boolean has Custom Properties ( ) { Properties prop = get Custom Properties ( false ) ; return prop != null && ! prop . is Empty ( ) ; }
protected Color desaturate ( Color color ) { float [ ] tmp = Color . RG Bto HSB ( color . get Red ( ) , color . get Green ( ) , color . get Blue ( ) , null ) ; tmp [ NUM_ ] /= NUM_ ; tmp [ NUM_ ] = clamp ( NUM_ - ( NUM_ - tmp [ NUM_ ] ) / NUM_ ) ; return new Color ( ( Color . HS Bto RGB ( tmp [ NUM_ ] , tmp [ NUM_ ] , tmp [ NUM_ ] ) & NUM_ ) ) ; }
public static Number min ( Number a , Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return Math . min ( a . double Value ( ) , b . double Value ( ) ) ; } else { return Math . min ( a . long Value ( ) , b . long Value ( ) ) ; } }
public static Iterable < Element > children ( Element parent ) { return null ; }
public long to Hours ( ) { return time Unit . to Hours ( length ) ; }
@ Override public boolean select ( Viewer viewer , Object parent Element , Object element ) { return element instanceof Risiko Massnahmen Umsetzung ; }
public static Expr Node [ ] validate ( String view Name , Event Type event Type , Statement Context statement Context , List < Expr Node > expressions , boolean allow Constant Result ) throws View Parameter Exception { List < Expr Node > results = new Array List < Expr Node > ( ) ; int expression Number = NUM_ ; Stream Type Service stream Type Service = new Stream Type Service Impl ( event Type , null , false , statement Context . get Engine URI ( ) ) ; for ( Expr Node expr : expressions ) { Expr Node validated = validate Expr ( view Name , statement Context , expr , stream Type Service , expression Number ) ; results . add ( validated ) ; if ( ( ! allow Constant Result ) && ( validated . is Constant Result ( ) ) ) { String message = STR_ + expression Number + get View Desc ( view Name ) + STR_ ; log . error ( message ) ; throw new View Parameter Exception ( message ) ; } expression Number ++ ; } return results . to Array ( new Expr Node [ results . size ( ) ] ) ; }
public Search Builder filter ( Condition Builder < ? , ? > ... builders ) { filter . add All ( Arrays . as List ( builders ) ) ; return this ; }
protected final void buffer ( char [ ] buffer ) { Objects . require Non Null ( buffer ) ; buffer = buffer ; }
public static Property Container find ( Object src , Path path ) { Property Container result ; Property Descriptor desc ; Object new Src ; Path Element part ; Method method ; Object method Result ; part = path . get ( NUM_ ) ; try { desc = new Property Descriptor ( part . get Name ( ) , src . get Class ( ) ) ; } catch ( Exception e ) { desc = null ; e . print Stack Trace ( ) ; } if ( desc == null ) return null ; if ( path . size ( ) == NUM_ ) { result = new Property Container ( desc , src ) ; } else { try { method = desc . get Read Method ( ) ; method Result = method . invoke ( src , ( Object [ ] ) null ) ; if ( part . has Index ( ) ) new Src = Array . get ( method Result , part . get Index ( ) ) ; else new Src = method Result ; result = find ( new Src , path . subpath ( NUM_ ) ) ; } catch ( Exception e ) { result = null ; e . print Stack Trace ( ) ; } } return result ; }
public static boolean is Password Valid ( String value ) { return value != null && value . length ( ) >= NUM_ && value . length ( ) <= NUM_ && String Utils . is Ascii Printable ( value ) ; }
public static Element first Child Element ( Element element , Set < String > child Element Names ) { if ( element == null ) return null ; Node node = element . get First Child ( ) ; if ( node != null ) { do { if ( node . get Node Type ( ) == Node . ELEMENT NODE && child Element Names . contains ( node . get Node Name ( ) ) ) { Element child Element = ( Element ) node ; return child Element ; } } while ( ( node = node . get Next Sibling ( ) ) != null ) ; } return null ; }
public boolean match ( String string ) { return strings . contains ( string . trim ( ) ) ; }
private String lookahead Word ( ) throws IO Exception , Parse Exception { String next Word = get Next Word ( ) ; tokenizer . push Back ( ) ; return next Word ; }
public static String unescape Special Characters ( String text ) { text = text . replace All ( STR_ , STR_ ) ; text = text . replace All ( STR_ , STR_ ) ; text = text . replace All ( STR_ , STR_ ) ; text = text . replace All ( STR_ , STR_ ) ; text = text . replace All ( STR_ , STR_ ) ; text = text . replace All ( STR_ , STR_ ) ; text = text . replace All ( STR_ , STR_ ) ; return text ; }
public double distance To ( Point 2 D that ) { double dx = this . x - that . x ; double dy = this . y - that . y ; return Math . sqrt ( dx * dx + dy * dy ) ; }
public void request Seconds Until Required Change Time ( ) { operations . add ( Password Policy State Operation Type . GET SECONDS UNTIL REQUIRED CHANGE TIME ) ; }
public boolean is Sealed ( URL url ) { if ( jar != null ) { init ( ) ; } return url . equals ( seal Base ) ; }
private String strip Tags ( String string ) { return string . replace All ( STR_ , STR_ ) ; }
public List < Pdf Object > sub List ( int from Index , int to Index ) { return list . sub List ( from Index , to Index ) ; }
private void calcoffset ( int index , boolean do Extend , Point 2 D result ) { double bx = data [ index - NUM_ ] ; double by = data [ index - NUM_ ] ; double px = result . get X ( ) - bx ; double py = result . get Y ( ) - by ; double dx = data [ index ] - bx ; double dy = data [ index + NUM_ ] - by ; double l = data [ index + NUM_ ] - data [ index - NUM_ ] ; double rx = ( px * dx + py * dy ) / l ; double ry = ( px * - dy + py * dx ) / l ; if ( ! do Extend ) { if ( rx < NUM_ ) rx = NUM_ ; else if ( rx > l ) rx = l ; } rx += data [ index - NUM_ ] ; result . set Location ( rx , ry ) ; }
public Set < ? extends Annotation Mirror > greatest Lower Bounds Type Variable ( Collection < ? extends Annotation Mirror > annos 1 , Collection < ? extends Annotation Mirror > annos 2 ) { Set < Annotation Mirror > result = Annotation Utils . create Annotation Set ( ) ; for ( Annotation Mirror top : get Top Annotations ( ) ) { Annotation Mirror anno 1 For Top = null ; for ( Annotation Mirror anno 1 : annos 1 ) { if ( is Subtype Type Variable ( anno 1 , top ) ) { anno 1 For Top = anno 1 ; } } Annotation Mirror anno 2 For Top = null ; for ( Annotation Mirror anno 2 : annos 2 ) { if ( is Subtype Type Variable ( anno 2 , top ) ) { anno 2 For Top = anno 2 ; } } Annotation Mirror t = greatest Lower Bound Type Variable ( anno 1 For Top , anno 2 For Top ) ; if ( t != null ) { result . add ( t ) ; } } return result ; }
public double signed area ( Pla Point Int p 1 , Pla Point Int p 2 ) { Pla Vector Int d 21 = p 2 . difference by ( p 1 ) ; Pla Vector Int d 01 = difference by ( p 1 ) ; return d 21 . determinant ( d 01 ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public Object [ ] to Array ( ) { return list . to Array ( ) ; }
@ Override @ Deprecated public Condition duplicate ( ) { return this ; }
public Name join ( Name rhs ) { List < Name Piece > new Piece List = new Array List < > ( ) ; new Piece List . add All ( name Pieces ) ; new Piece List . add All ( rhs . name Pieces ) ; return new Name ( new Piece List ) ; }
boolean is Finished ( ) { return finished ; }
public int hash Code ( ) { int hash = Float . float To Int Bits ( width ) ; hash = hash * NUM_ + join ; hash = hash * NUM_ + cap ; hash = hash * NUM_ + Float . float To Int Bits ( miterlimit ) ; if ( dash != null ) { hash = hash * NUM_ + Float . float To Int Bits ( dash phase ) ; for ( int i = NUM_ ; i < dash . length ; i ++ ) { hash = hash * NUM_ + Float . float To Int Bits ( dash [ i ] ) ; } } return hash ; }
public int size ( ) { return event Queue . size ( ) ; }
private static boolean wait Till Page Alive ( String url , int timeout Secs ) throws IO Exception { int tries = NUM_ ; int secs Between Tries = NUM_ ; while ( true ) { boolean alive = is URL Alive ( url ) ; tries ++ ; if ( alive ) break ; out . println ( STR_ + tries + STR_ ) ; try { Thread . sleep ( secs Between Tries * NUM_ ) ; } catch ( Interrupted Exception ie ) { } if ( tries * secs Between Tries > timeout Secs ) { out . println ( STR_ + tries + STR_ ) ; return false ; } } out . println ( STR_ + tries + STR_ ) ; return true ; }
private static Integer parse Int ( final String value ) { try { return Integer . parse Int ( value ) ; } catch ( Number Format Exception e ) { return null ; } }
public static Snapshot Directory from ( Snapshot snapshot , File Config config ) { return Snapshot Directory . from ( config . base ( ) , snapshot . backup UDID ( ) , Integer . to String ( snapshot . snapshot ID ( ) ) , config . is Flat ( ) , config . is Combined ( ) , config . combined Directory ( ) ) ; }
public final Tree Set < Brd Item > find overlap items with clearance ( Shape Tile p shape , int p layer , Net Nos List p ignore net nos , int p clearance class ) { Tree Set < Brd Item > result = new Tree Set < Brd Item > ( ) ; Collection < Awtree Find Entry > overlaps = find overlap tree entries with clearance ( p shape , p layer , p ignore net nos , p clearance class ) ; for ( Awtree Find Entry curr tentry : overlaps ) { Awtree Object curr object = curr tentry . object ; if ( ! ( curr object instanceof Brd Item ) ) continue ; result . add ( ( Brd Item ) curr object ) ; } return result ; }
public static char value As Char ( String key , char default Val ) { String val = value For ( key ) ; if ( val == null ) { return default Val ; } if ( val . length ( ) > NUM_ ) { XR Log . exception ( STR_ + key + STR_ + val + STR_ ) ; } return val . char At ( NUM_ ) ; }
public int hash Code ( ) { int hash 1 = x . hash Code ( ) ; int hash 2 = y . hash Code ( ) ; return NUM_ * hash 1 + hash 2 ; }
private Map < Integer , Fraction > generate Absent ( ) { Map < Integer , Fraction > generated = new Hash Map < Integer , Fraction > ( ) ; do { generated . put All ( generate ( ) ) ; for ( Integer key : java Map . key Set ( ) ) generated . remove ( key ) ; } while ( generated . size ( ) < NUM_ ) ; return generated ; }
public static String main Args ( Monitored Vm vm ) throws Monitor Exception { String command Line = command Line ( vm ) ; int first Space = command Line . index Of ( STR_ ) ; if ( first Space > NUM_ ) { return command Line . substring ( first Space + NUM_ ) ; } else if ( command Line . compare To ( STR_ ) == NUM_ ) { return command Line ; } else { return null ; } }
public static String format Time Stamp ( long epoch Time ) { return TIME FORMAT . format ( new Date ( epoch Time ) ) ; }
private static Template Variable [ ] copy ( Template Variable [ ] array ) { if ( array != null ) { Template Variable [ ] copy = new Template Variable [ array . length ] ; System . arraycopy ( array , NUM_ , copy , NUM_ , array . length ) ; return copy ; } return null ; }
public static Map < String , Mapped Class > mappings From Jar ( File file ) { Map < String , Class Node > nodes = null ; try { nodes = Jar Utils . load Classes ( file ) ; } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } return mappings From Nodes ( nodes ) ; }
public int length ( ) { return internal . length ( ) ; }
public boolean is Fully Downloaded ( Storage Data storage Data ) { for ( Local Storage Data lsd : downloaded Storages ) { if ( Object Utils . equals ( lsd . get Id ( ) , storage Data . get Id ( ) ) ) { return lsd . is Fully Downloaded ( ) ; } } return false ; }
protected Range find Domain Bounds ( XY Dataset dataset , boolean include Interval ) { if ( dataset == null ) { return null ; } if ( get Data Bounds Includes Visible Series Only ( ) ) { List visible Series Keys = new Array List ( ) ; int series Count = dataset . get Series Count ( ) ; for ( int s = NUM_ ; s < series Count ; s ++ ) { if ( is Series Visible ( s ) ) { visible Series Keys . add ( dataset . get Series Key ( s ) ) ; } } return Dataset Utilities . find Domain Bounds ( dataset , visible Series Keys , include Interval ) ; } return Dataset Utilities . find Domain Bounds ( dataset , include Interval ) ; }
public static Date max ( Date date 1 , Date date 2 ) { if ( date 1 == null ) { return date 2 ; } return date 2 != null ? ( date 1 . after ( date 2 ) ? date 1 : date 2 ) : date 1 ; }
private static List retrieve Loggers ( ) { List logger Names = XR Log . list Registered Loggers ( ) ; List loggers = new Array List ( logger Names . size ( ) ) ; Iterator it = logger Names . iterator ( ) ; while ( it . has Next ( ) ) { final String ln = ( String ) it . next ( ) ; loggers . add ( Logger . get Logger ( ln ) ) ; } return loggers ; }
static int bytes Needed ( long v ) { if ( v < NUM_ ) { v = ~ v ; } return ( ( NUM_ - Long . number Of Leading Zeros ( v ) ) / NUM_ ) + NUM_ ; }
private boolean more ( ) { if ( next Offset < NUM_ ) { return false ; } int skipped WS = NUM_ ; char c = NUM_ ; while ( next Offset + skipped WS < next Fence Post ) { c = s . char At ( next Offset + skipped WS ) ; if ( Character . is Whitespace ( c ) ) { skipped WS ++ ; } else { break ; } } if ( next Offset + NUM_ + skipped WS < next Fence Post && c == STR_ && s . char At ( skipped WS + next Offset + NUM_ ) == STR_ ) { next Offset = - NUM_ ; return false ; } if ( next Offset + skipped WS < next Fence Post ) { return true ; } next Offset = - NUM_ ; return false ; }
public static long parse Xs Duration ( String value ) { Matcher matcher = XS DURATION PATTERN . matcher ( value ) ; if ( matcher . matches ( ) ) { boolean negated = ! Text Utils . is Empty ( matcher . group ( NUM_ ) ) ; String years = matcher . group ( NUM_ ) ; double duration Seconds = ( years != null ) ? Double . parse Double ( years ) * NUM_ : NUM_ ; String months = matcher . group ( NUM_ ) ; duration Seconds += ( months != null ) ? Double . parse Double ( months ) * NUM_ : NUM_ ; String days = matcher . group ( NUM_ ) ; duration Seconds += ( days != null ) ? Double . parse Double ( days ) * NUM_ : NUM_ ; String hours = matcher . group ( NUM_ ) ; duration Seconds += ( hours != null ) ? Double . parse Double ( hours ) * NUM_ : NUM_ ; String minutes = matcher . group ( NUM_ ) ; duration Seconds += ( minutes != null ) ? Double . parse Double ( minutes ) * NUM_ : NUM_ ; String seconds = matcher . group ( NUM_ ) ; duration Seconds += ( seconds != null ) ? Double . parse Double ( seconds ) : NUM_ ; long duration Millis = ( long ) ( duration Seconds * NUM_ ) ; return negated ? - duration Millis : duration Millis ; } else { return ( long ) ( Double . parse Double ( value ) * NUM_ * NUM_ ) ; } }
public int max net no ( ) { return net list . size ( ) ; }
public int size ( ) { return m snapshot List . size ( ) ; }
public boolean contains ( Taxon taxon ) { return taxa . contains ( taxon ) ; }
public boolean is Running ( ) { return this . start Time > NUM_ && this . stop Time == NUM_ ; }
public void put ( Repl DBMS Event event ) throws Interrupted Exception , Replicator Exception { queue . put ( event ) ; transaction Count ++ ; if ( logger . is Debug Enabled ( ) ) { if ( transaction Count % NUM_ == NUM_ ) logger . debug ( STR_ + transaction Count + STR_ + queue . size ( ) ) ; } }
public Enum Set < Failure Reason > failure Reasons ( ) { Thread Utils . assert On Ui Thread ( ) ; Enum Set < Failure Reason > reasons = Enum Set . none Of ( Failure Reason . class ) ; if ( ! m Called ) reasons . add ( Failure Reason . UPDATE PRECACHING ENABLED NEVER CALLED ) ; if ( ! m Sync Initialized ) reasons . add ( Failure Reason . SYNC NOT INITIALIZED ) ; if ( ! m Network Predictions Allowed ) { reasons . add ( Failure Reason . PRERENDER PRIVACY PREFERENCE NOT ENABLED ) ; } if ( ! m Should Run ) reasons . add ( Failure Reason . NATIVE SHOULD RUN IS FALSE ) ; return reasons ; }
public T last ( ) { return elements . get ( length - NUM_ ) ; }
public Trie Node find ( String suffix ) { Trie Node result ; Character c ; String new Suffix ; Trie Node child ; c = suffix . char At ( NUM_ ) ; new Suffix = suffix . substring ( NUM_ ) ; child = m Children . get ( c ) ; if ( child == null ) { result = null ; } else if ( new Suffix . length ( ) == NUM_ ) { result = child ; } else { result = child . find ( new Suffix ) ; } return result ; }
public static boolean is Number ( String string ) { final String Digits = STR_ ; final String Hex Digits = STR_ ; final String Exp = STR_ + Digits ; final String fp Regex = ( STR_ + STR_ + STR_ + STR_ + STR_ + Digits + STR_ + Digits + STR_ + Exp + STR_ + STR_ + Digits + STR_ + Exp + STR_ + STR_ + STR_ + Hex Digits + STR_ + STR_ + Hex Digits + STR_ + Hex Digits + STR_ + STR_ + Digits + STR_ + STR_ + STR_ ) ; return Pattern . matches ( fp Regex , string ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + pool Size Tip Text ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + num Threads Tip Text ( ) + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static double next After ( final double start , final double direction ) { if ( direction < start ) { if ( start == NUM_ ) { return - Double . MIN VALUE ; } final long bits = Double . double To Raw Long Bits ( start ) ; return Double . long Bits To Double ( bits + ( bits > NUM_ ? - NUM_ : NUM_ ) ) ; } else if ( direction > start ) { final long bits = Double . double To Raw Long Bits ( start + NUM_ ) ; return Double . long Bits To Double ( bits + ( bits >= NUM_ ? NUM_ : - NUM_ ) ) ; } else if ( start == direction ) { return direction ; } else { return start + direction ; } }
public int hash Code ( ) { if ( myhash == - NUM_ ) { myhash = timestamp . hash Code ( ) + signer Cert Path . hash Code ( ) ; } return myhash ; }
public Iterable < Element > elements ( ) { if ( level != NUM_ ) { throw new Illegal State Exception ( log Id ( ) + STR_ + dump Elements ( ) ) ; } if ( elements . is Empty ( ) ) { throw new Illegal State Exception ( log Id ( ) + STR_ ) ; } return Iterables . transform ( this . elements , null ) ; }
private static String limit ( int lower , int upper ) { if ( ( lower < NUM_ ) || ( upper <= NUM_ ) || ( upper < lower ) ) { throw new Illegal Argument Exception ( ) ; } return STR_ + lower + STR_ + upper + STR_ ; }
private Preference find Preference By Res Id ( int res Id ) { return find Preference ( get String ( res Id ) ) ; }
@ Not Null public List < ? extends X Line Breakpoint Variant > compute Variants ( @ Not Null Project project , @ Not Null X Source Position position ) { return Collections . empty List ( ) ; }
protected Shape stroke ( Shape line ) { if ( line == null ) { return null ; } Stroke stroke = get Stroke ( ) ; Shape line Shape = stroke . create Stroked Shape ( line ) ; return line Shape ; }
private Part last Part ( ) { return parts . get ( parts . size ( ) - NUM_ ) ; }
public String to String Summary ( ) { String result ; String titles ; int i ; int j ; String line ; if ( m Non Sig Wins == null ) return STR_ ; result = STR_ ; titles = STR_ ; for ( i = NUM_ ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; if ( ! titles . equals ( STR_ ) ) titles += STR_ ; titles += get Summary Title ( i ) ; } result += titles + STR_ ; for ( i = NUM_ ; i < get Col Count ( ) ; i ++ ) { if ( get Col Hidden ( i ) ) continue ; line = STR_ ; for ( j = NUM_ ; j < get Col Count ( ) ; j ++ ) { if ( get Col Hidden ( j ) ) continue ; if ( ! line . equals ( STR_ ) ) line += STR_ ; if ( j == i ) line += STR_ ; else line += m Non Sig Wins [ i ] [ j ] + STR_ + m Wins [ i ] [ j ] + STR_ ; } result += line + STR_ + get Summary Title ( i ) + STR_ + remove Filter Name ( m Col Names [ i ] ) + STR_ ; } return result ; }
public long content Length Sent ( ) { Out Http App stream = response Stream ; if ( stream != null ) { return stream . content Length ( ) ; } else { return Math . max ( content Length Out , NUM_ ) ; } }
static public final boolean random Boolean ( ) { return random . next Boolean ( ) ; }
public int next Int ( ) { return next ( NUM_ ) ; }
@ Override public Inet Socket Address ip Remote ( ) { if ( ip Remote == null ) { try { ip Remote = Inet Socket Address . create Unresolved ( get Local Host ( ) , port Local ( ) ) ; } catch ( Exception e ) { log . log ( Level . FINE , e . to String ( ) , e ) ; } } return ip Local ; }
public static double [ ] [ ] clone ( double [ ] [ ] source ) { Param Checks . null Not Permitted ( source , STR_ ) ; double [ ] [ ] clone = new double [ source . length ] [ ] ; for ( int i = NUM_ ; i < source . length ; i ++ ) { if ( source [ i ] != null ) { double [ ] row = new double [ source [ i ] . length ] ; System . arraycopy ( source [ i ] , NUM_ , row , NUM_ , source [ i ] . length ) ; clone [ i ] = row ; } } return clone ; }
public String read Until Either ( String s ) { int ix = Integer . MAX VALUE ; for ( char c : s . to Char Array ( ) ) { int ixx = data . index Of ( c , pos ) ; if ( ixx >= NUM_ && ixx < ix ) ix = ixx ; } if ( ix == - NUM_ ) throw new Runtime Exception ( STR_ + s + STR_ ) ; return read N ( ix - pos ) ; }
protected String build Xml ( ) { return Objects . require Non Null ( build Xml ) ; }
public boolean manifest Resource Changed ( @ Not Null I Device device ) { Installed Patch Cache cache = my Instant Run Context . get Installed Patch Cache ( ) ; Hash Code current Hash = my Instant Run Context . get Manifest Resources Hash ( ) ; Hash Code installed Hash = cache . get Installed Manifest Resources Hash ( device , my Instant Run Context . get Application Id ( ) ) ; if ( installed Hash != null && ! installed Hash . equals ( current Hash ) ) { return true ; } return false ; }
public < X extends Throwable > double or Else Throw ( Supplier < X > exception Supplier ) throws X { if ( is Present ) { return value ; } else { throw exception Supplier . get ( ) ; } }
public static double max ( double [ ] a ) { double max = Double . NEGATIVE INFINITY ; for ( int i = NUM_ ; i < a . length ; i ++ ) { if ( Double . is Na N ( a [ i ] ) ) return Double . Na N ; if ( a [ i ] > max ) max = a [ i ] ; } return max ; }
public static String pad Left ( String s , int len , char pad ch ) { if ( s . length ( ) >= len ) { return s ; } else { String Builder sb = new String Builder ( ) ; int n = len - s . length ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { sb . append ( pad ch ) ; } sb . append ( s ) ; return sb . to String ( ) ; } }
public boolean has Incoming Batch Instances ( ) { if ( m listenees . size ( ) == NUM_ ) { return false ; } if ( m listenees . contains Key ( STR_ ) || m listenees . contains Key ( STR_ ) || m listenees . contains Key ( STR_ ) ) { return true ; } return false ; }
public static boolean is Non Variant Gt ( String gt ) { final int gtlen = gt . length ( ) ; for ( int i = NUM_ ; i < gtlen ; i ++ ) { final char c = gt . char At ( i ) ; switch ( c ) { case PHASED SEPARATOR : case UNPHASED SEPARATOR : case STR_ : case MISSING VALUE : continue ; default : return false ; } } return true ; }
public int attributes Size ( ) { return attributes . size ( ) ; }
protected static String literal Bits String ( Cst Literal Bits value ) { String Buffer sb = new String Buffer ( NUM_ ) ; sb . append ( STR_ ) ; if ( value instanceof Cst Known Null ) { sb . append ( STR_ ) ; } else { sb . append ( value . type Name ( ) ) ; sb . append ( STR_ ) ; sb . append ( value . to Human ( ) ) ; } return sb . to String ( ) ; }
@ Override public String format ( double value , int format Number ) { return format . format ( value ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public static java . lang . String value Of ( double value ) { return Double . to String ( value ) ; }
public Text Character with Modifier ( SGR modifier ) { if ( modifiers . contains ( modifier ) ) { return this ; } Enum Set < SGR > new Set = Enum Set . copy Of ( this . modifiers ) ; new Set . add ( modifier ) ; return new Text Character ( character , foreground Color , background Color , new Set ) ; }
public static String empty If Equal ( String string , String test ) { return test != null && test . equals ( string ) ? EMPTY : string ; }
public static float length ( Vector 2 a ) { return ( float ) Math . sqrt ( length Squared ( a ) ) ; }
public static List to List ( Chain c ) { Iterator it = c . iterator ( ) ; List list = new Array List ( ) ; while ( it . has Next ( ) ) { list . add ( it . next ( ) ) ; } return list ; }
private static boolean has Thrown Initializer Error ( Execution Result exec Result ) { for ( Throwable t : exec Result . get All Thrown Exceptions ( ) ) { if ( t instanceof Exception In Initializer Error ) { return true ; } } return false ; }
public char current Char ( ) { return desc . char At ( cur Pos ) ; }
public String read Config Name ( Solr Zk Client zk Client , String collection ) throws Keeper Exception , Interrupted Exception { if ( collection == null ) { throw new Illegal Argument Exception ( STR_ ) ; } String config Name = null ; byte [ ] alias Data = zk Client . get Data ( Zk State Reader . ALIASES , null , null , true ) ; Aliases aliases = Cluster State . load ( alias Data ) ; String alias = aliases . get Collection Alias ( collection ) ; if ( alias != null ) { List < String > alias List = Str Utils . split Smart ( alias , STR_ , true ) ; if ( alias List . size ( ) > NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } collection = alias List . get ( NUM_ ) ; } String path = Zk State Reader . COLLECTIONS ZKNODE + STR_ + collection ; if ( LOG . is Info Enabled ( ) ) { LOG . info ( STR_ + path ) ; } byte [ ] data = zk Client . get Data ( path , null , null , true ) ; if ( data != null ) { Zk Node Props props = Zk Node Props . load ( data ) ; config Name = props . get Str ( Zk Controller . CONFIGNAME PROP ) ; } if ( config Name != null && ! zk Client . exists ( Zk Config Manager . CONFIGS ZKNODE + STR_ + config Name , true ) ) { LOG . error ( STR_ + config Name ) ; throw new Illegal Argument Exception ( STR_ + config Name ) ; } return config Name ; }
public static final int number Of Prover Status ( int prover Number , String status Name ) throws Illegal Argument Exception { if ( prover Number > NUMBER OF PROVERS || prover Number < NUM_ ) { throw new Illegal Argument Exception ( STR_ + prover Number ) ; } for ( int i = NUM_ ; i < PROVER STATUSES [ prover Number ] . length ; i ++ ) { if ( status Name . equals ( PROVER STATUSES [ prover Number ] [ i ] ) ) { return i ; } } throw new Illegal Argument Exception ( STR_ + PROVER NAMES [ prover Number ] + STR_ + status Name ) ; }
protected static double regularized Inc Beta Quadrature ( double alpha , double beta , double x ) { final double alphapbeta = alpha + beta ; final double a 1 = alpha - NUM_ ; final double b 1 = beta - NUM_ ; final double mu = alpha / alphapbeta ; final double lnmu = Math . log ( mu ) ; final double lnmuc = Math . log 1 p ( - mu ) ; double t = Math . sqrt ( alpha * beta / ( alphapbeta * alphapbeta * ( alphapbeta + NUM_ ) ) ) ; final double xu ; if ( x > alpha / alphapbeta ) { if ( x >= NUM_ ) { return NUM_ ; } xu = Math . min ( NUM_ , Math . max ( mu + NUM_ * t , x + NUM_ * t ) ) ; } else { if ( x <= NUM_ ) { return NUM_ ; } xu = Math . max ( NUM_ , Math . min ( mu - NUM_ * t , x - NUM_ * t ) ) ; } double sum = NUM_ ; for ( int i = NUM_ ; i < GAUSSLEGENDRE Y . length ; i ++ ) { t = x + ( xu - x ) * GAUSSLEGENDRE Y [ i ] ; sum += GAUSSLEGENDRE W [ i ] * Math . exp ( a 1 * ( Math . log ( t ) - lnmu ) + b 1 * ( Math . log 1 p ( - t ) - lnmuc ) ) ; } double ans = sum * ( xu - x ) * Math . exp ( a 1 * lnmu - Gamma Distribution . log Gamma ( alpha ) + b 1 * lnmuc - Gamma Distribution . log Gamma ( beta ) + Gamma Distribution . log Gamma ( alphapbeta ) ) ; return ans > NUM_ ? NUM_ - ans : - ans ; }
public static boolean is Blank ( Integer key ) { return ( ( null == key ) || ( NUM_ == key . int Value ( ) ) ) ; }
public synchronized int size ( ) { return m History . size ( ) ; }
public int [ ] to Integer Array ( ) { int [ ] result ; result = new int [ blocks ] ; System . arraycopy ( value , NUM_ , result , NUM_ , blocks ) ; return result ; }
public static boolean snapshot Exists ( Solr Zk Client zk Client , String collection Name , String commit Name ) throws Keeper Exception , Interrupted Exception { String zk Path = get Snapshot Meta Data Zk Path ( collection Name , Optional . of Nullable ( commit Name ) ) ; return zk Client . exists ( zk Path , true ) ; }
private boolean has Unexpected Italian Leading Zero ( Phone Number number ) { return number . is Italian Leading Zero ( ) && ! is Leading Zero Possible ( number . get Country Code ( ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + default Seed ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public static Dense Vector to Dense Vec ( double ... array ) { return new Dense Vector ( array ) ; }
public static Type Kind from Primitive Or Void Type Char ( char ch ) { switch ( ch ) { case STR_ : return Type Kind . BOOLEAN ; case STR_ : return Type Kind . CHAR ; case STR_ : return Type Kind . FLOAT ; case STR_ : return Type Kind . DOUBLE ; case STR_ : return Type Kind . BYTE ; case STR_ : return Type Kind . SHORT ; case STR_ : return Type Kind . INT ; case STR_ : return Type Kind . LONG ; case STR_ : return Type Kind . VOID ; } throw new Illegal Argument Exception ( STR_ + ch ) ; }
public boolean is Significant ( double dx , double dy ) { return Math . abs ( dx ) > tolerance || Math . abs ( dy ) > tolerance ; }
public Enumeration < Option > list Options ( ) { Vector < Option > vec = new Vector < Option > ( NUM_ ) ; vec . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; vec . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; vec . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; vec . add All ( Collections . list ( super . list Options ( ) ) ) ; return vec . elements ( ) ; }
public static Preferences user Root ( ) { Security Manager security = System . get Security Manager ( ) ; if ( security != null ) security . check Permission ( prefs Perm ) ; return factory . user Root ( ) ; }
public Class < ? > load Class ( String name ) throws Class Not Found Exception { if ( best Candidate != null ) { try { return best Candidate . load Class ( name ) ; } catch ( Throwable t ) { best Candidate = null ; } } Throwable throwable = null ; Class < ? > clazz = null ; Class Load Helper load Helper = null ; Iterator < Class Load Helper > iter = load Helpers . iterator ( ) ; while ( iter . has Next ( ) ) { load Helper = iter . next ( ) ; try { clazz = load Helper . load Class ( name ) ; break ; } catch ( Throwable t ) { throwable = t ; } } if ( clazz == null ) { if ( throwable instanceof Class Not Found Exception ) { throw ( Class Not Found Exception ) throwable ; } else { throw new Class Not Found Exception ( String . format ( STR_ , name ) , throwable ) ; } } best Candidate = load Helper ; return clazz ; }
public boolean is Super User ( String uuid ) { boolean is Super User = false ; try { AM Identity admin User Id = null ; String admin User = System Properties . get ( Constants . AUTHENTICATION SUPER USER ) ; if ( admin User != null ) { admin User Id = new AM Identity ( dsame Admin Token Provider . get Admin Token ( ) , admin User , Id Type . USER , STR_ , null ) ; } AM Identity user = Id Utils . get Identity ( dsame Admin Token Provider . get Admin Token ( ) , uuid ) ; is Super User = admin User Id . equals ( user ) ; } catch ( SSO Exception ssoe ) { session Debug . error ( STR_ ) ; } catch ( Id Repo Exception idme ) { session Debug . error ( STR_ ) ; } if ( session Debug . message Enabled ( ) ) { session Debug . message ( STR_ + is Super User ) ; } return is Super User ; }
public Workflow . Method zone Export Remove Volumes Method ( List < Network Zoning Param > zoning Params , Collection < URI > volume UR Is ) { return new Workflow . Method ( STR_ , zoning Params , volume UR Is ) ; }
private boolean dominates ( Bit Set bs 1 , Bit Set bs 2 ) { Bit Set copy = new Bit Set ( ) ; copy . or ( bs 2 ) ; copy . and Not ( bs 1 ) ; return copy . is Empty ( ) ; }
public static String slurp URL ( URL u ) throws IO Exception { String line Separator = System . get Property ( STR_ ) ; URL Connection uc = u . open Connection ( ) ; Input Stream is = uc . get Input Stream ( ) ; Buffered Reader br = new Buffered Reader ( new Input Stream Reader ( is ) ) ; String temp ; String Builder buff = new String Builder ( NUM_ ) ; while ( ( temp = br . read Line ( ) ) != null ) { buff . append ( temp ) ; buff . append ( line Separator ) ; } br . close ( ) ; return buff . to String ( ) ; }
private boolean is Unary Function ( char tok ) { if ( UNARY FUNCTIONS . index Of ( tok ) == - NUM_ ) { return false ; } return true ; }
public static boolean is Volume Mounted ( Block Object Rest Rep block Object ) { if ( block Object != null ) { Set < String > volume Tags = block Object . get Tags ( ) ; if ( volume Tags != null ) { Map < String , String > parsed Tags = Machine Tag Utils . parse Machine Tags ( volume Tags ) ; for ( String tag : parsed Tags . key Set ( ) ) { if ( tag != null && tag . starts With ( Known Machine Tags . get Host Mount Point Tag Name ( ) ) ) { return true ; } } } } return false ; }
protected void rethrow ( SQL Exception cause , String sql , Object [ ] params ) throws SQL Exception { String Builder msg = new String Builder ( cause . get Message ( ) ) ; msg . append ( STR_ ) ; msg . append ( sql ) ; msg . append ( STR_ ) ; if ( params == null ) { msg . append ( STR_ ) ; } else { msg . append ( Arrays . as List ( params ) ) ; } SQL Exception e = new SQL Exception ( msg . to String ( ) , cause . get SQL State ( ) , cause . get Error Code ( ) ) ; e . set Next Exception ( cause ) ; throw e ; }
public static Vector 2 max ( Vector 2 o 1 , Vector 2 o 2 ) { return new Vector 2 ( Math . max ( o 1 . x , o 2 . x ) , Math . max ( o 1 . z , o 2 . z ) ) ; }
public Download Task resume ( String task Id ) { Download Task download Task = get Current Task By Id ( task Id ) ; if ( download Task != null ) { if ( download Task . get Download Status ( ) != Download Status . DOWNLOAD STATUS COMPLETED ) { download Task . set Download Status ( Download Status . DOWNLOAD STATUS PREPARE ) ; download Task . setdown File Store ( down File Store ) ; download Task . set Http Client ( client ) ; Future future = executor Service . submit ( download Task ) ; future Map . put ( download Task . get Id ( ) , future ) ; } } else { download Task = get DB Task By Id ( task Id ) ; if ( download Task != null ) { current Task List . put ( task Id , download Task ) ; download Task . set Download Status ( Download Status . DOWNLOAD STATUS PREPARE ) ; download Task . setdown File Store ( down File Store ) ; download Task . set Http Client ( client ) ; Future future = executor Service . submit ( download Task ) ; future Map . put ( download Task . get Id ( ) , future ) ; } } return download Task ; }
public static String html Escape ( String input ) { Param Checks . null Not Permitted ( input , STR_ ) ; String Builder result = new String Builder ( ) ; int length = input . length ( ) ; for ( int i = NUM_ ; i < length ; i ++ ) { char c = input . char At ( i ) ; if ( c == STR_ ) { result . append ( STR_ ) ; } else if ( c == STR_ ) { result . append ( STR_ ) ; } else if ( c == STR_ ) { result . append ( STR_ ) ; } else if ( c == STR_ ) { result . append ( STR_ ) ; } else if ( c == STR_ ) { result . append ( STR_ ) ; } else if ( c == STR_ ) { result . append ( STR_ ) ; } else { result . append ( c ) ; } } return result . to String ( ) ; }
public void select Operators ( List < Operator > ops ) { if ( node Height Prior == Tree Prior Type . CONSTANT ) { ops . add ( get Operator ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . EXPONENTIAL ) { ops . add ( get Operator ( STR_ ) ) ; if ( parameterization == Tree Prior Parameterization Type . GROWTH RATE ) { ops . add ( get Operator ( STR_ ) ) ; } else { ops . add ( get Operator ( STR_ ) ) ; } } else if ( node Height Prior == Tree Prior Type . LOGISTIC ) { ops . add ( get Operator ( STR_ ) ) ; if ( parameterization == Tree Prior Parameterization Type . GROWTH RATE ) { ops . add ( get Operator ( STR_ ) ) ; } else { ops . add ( get Operator ( STR_ ) ) ; } ops . add ( get Operator ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . EXPANSION ) { ops . add ( get Operator ( STR_ ) ) ; if ( parameterization == Tree Prior Parameterization Type . GROWTH RATE ) { ops . add ( get Operator ( STR_ ) ) ; } else { ops . add ( get Operator ( STR_ ) ) ; } ops . add ( get Operator ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . SKYLINE ) { ops . add ( get Operator ( STR_ ) ) ; ops . add ( get Operator ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . GMRF SKYRIDE ) { ops . add ( get Operator ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . SKYGRID ) { ops . add ( get Operator ( STR_ ) ) ; ops . add ( get Operator ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . EXTENDED SKYLINE ) { ops . add ( get Operator ( STR_ ) ) ; ops . add ( get Operator ( STR_ ) ) ; ops . add ( get Operator ( STR_ ) ) ; ops . add ( get Operator ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . YULE || node Height Prior == Tree Prior Type . YULE CALIBRATION ) { ops . add ( get Operator ( STR_ ) ) ; } else if ( node Height Prior == Tree Prior Type . BIRTH DEATH || node Height Prior == Tree Prior Type . BIRTH DEATH INCOMPLETE SAMPLING ) { ops . add ( get Operator ( Birth Death Model Parser . MEAN GROWTH RATE PARAM NAME ) ) ; ops . add ( get Operator ( Birth Death Model Parser . RELATIVE DEATH RATE PARAM NAME ) ) ; if ( node Height Prior == Tree Prior Type . BIRTH DEATH INCOMPLETE SAMPLING ) ops . add ( get Operator ( Birth Death Model Parser . BIRTH DEATH + STR_ + Birth Death Model Parser . SAMPLE PROB ) ) ; } else if ( node Height Prior == Tree Prior Type . BIRTH DEATH SERIAL SAMPLING ) { ops . add ( get Operator ( Birth Death Serial Sampling Model Parser . BDSS + STR_ + Birth Death Serial Sampling Model Parser . LAMBDA ) ) ; ops . add ( get Operator ( Birth Death Serial Sampling Model Parser . BDSS + STR_ + Birth Death Serial Sampling Model Parser . RELATIVE MU ) ) ; ops . add ( get Operator ( Birth Death Serial Sampling Model Parser . BDSS + STR_ + Birth Death Serial Sampling Model Parser . PSI ) ) ; ops . add ( get Operator ( Birth Death Serial Sampling Model Parser . BDSS + STR_ + Birth Death Serial Sampling Model Parser . ORIGIN ) ) ; } else if ( node Height Prior == Tree Prior Type . BIRTH DEATH BASIC REPRODUCTIVE NUMBER ) { ops . add ( get Operator ( Birth Death Epidemiology Model Parser . ORIGIN ) ) ; ops . add ( get Operator ( Birth Death Epidemiology Model Parser . R 0 ) ) ; ops . add ( get Operator ( Birth Death Epidemiology Model Parser . RECOVERY RATE ) ) ; ops . add ( get Operator ( Birth Death Epidemiology Model Parser . SAMPLING PROBABILITY ) ) ; } }
private Japanese Date with Year ( int year ) { return with Year ( get Era ( ) , year ) ; }
public boolean has On Disk ( final String key ) { synchronized ( m Entries ) { return m Entries . contains ( sanitize Key ( key ) ) ; } }
public Payment Response create Payment Response ( final Service Details payment Service Details , final String response ) { final Payment Gateway Adaptor payment Gateway Adaptor = get Payment Gateway Adaptor ( payment Service Details . get Code ( ) ) ; final Payment Response payment Response = payment Gateway Adaptor . parse Payment Response ( response ) ; return payment Response ; }
private List < Statement > new Object Statement ( Policy Type policy , String prefix ) { List < Statement > statements = new Array List < Statement > ( ) ; if ( policy == Policy Type . NONE || bucket Name == null || bucket Name . is Empty ( ) ) { return statements ; } Resources resources = new Resources ( Constants . AWS RESOURCE PREFIX + bucket Name + STR_ + prefix + STR_ ) ; Statement statement = new Statement ( ) ; statement . set Effect ( STR_ ) ; statement . set Principal ( new Principal ( STR_ ) ) ; statement . set Resources ( resources ) ; statement . set Sid ( STR_ ) ; if ( policy == Policy Type . READ ONLY ) { statement . set Actions ( Constants . READ ONLY OBJECT ACTIONS ) ; } else if ( policy == Policy Type . WRITE ONLY ) { statement . set Actions ( Constants . WRITE ONLY OBJECT ACTIONS ) ; } else if ( policy == Policy Type . READ WRITE ) { statement . set Actions ( Constants . READ WRITE OBJECT ACTIONS ) ; } statements . add ( statement ) ; return statements ; }
public static String normalize Derived Adjective ( final String word ) { if ( is Derived Adjective ( word ) ) { return word . substring ( NUM_ , word . length ( ) - NUM_ ) ; } else { return null ; } }
private void run ( ) { try { Thread current = Thread . current Thread ( ) ; char [ ] buf = new char [ NUM_ ] ; for ( int len = in . read ( buf ) ; len != - NUM_ ; len = in . read ( buf ) ) { append ( buf , NUM_ , len ) ; if ( current != thread ) { break ; } } } catch ( IO Exception e ) { logger . error ( e . get Message ( ) , e ) ; } trace ( STR_ ) ; }
public static double tile 2 lon ( int x , int z ) { return x / Math . pow ( NUM_ , z ) * NUM_ - NUM_ ; }
public double time To Hit ( Particle that ) { if ( this == that ) return INFINITY ; double dx = that . rx - this . rx ; double dy = that . ry - this . ry ; double dvx = that . vx - this . vx ; double dvy = that . vy - this . vy ; double dvdr = dx * dvx + dy * dvy ; if ( dvdr > NUM_ ) return INFINITY ; double dvdv = dvx * dvx + dvy * dvy ; double drdr = dx * dx + dy * dy ; double sigma = this . radius + that . radius ; double d = ( dvdr * dvdr ) - dvdv * ( drdr - sigma * sigma ) ; if ( d < NUM_ ) return INFINITY ; return - ( dvdr + Math . sqrt ( d ) ) / dvdv ; }
public Vector plus ( Vector that ) { if ( this . d != that . d ) throw new Illegal Argument Exception ( STR_ ) ; Vector c = new Vector ( d ) ; for ( int i = NUM_ ; i < d ; i ++ ) c . data [ i ] = this . data [ i ] + that . data [ i ] ; return c ; }
@ Override public int hash Code ( ) { int code = NUM_ ; if ( name != null ) { code += name . hash Code ( ) ; } if ( entitlement != null ) { code += entitlement . hash Code ( ) ; } if ( e Subject != null ) { code += e Subject . hash Code ( ) ; } if ( e Condition != null ) { code += e Condition . hash Code ( ) ; } if ( e Resource Attributes != null ) { code += e Resource Attributes . hash Code ( ) ; } return code ; }
public final boolean is Removed ( ) { Token o = get Value As Token ( ) ; return ( o == Token . REMOVED PHASE 1 ) || ( o == Token . REMOVED PHASE 2 ) || ( o == Token . TOMBSTONE ) ; }
public Iterator < Json Element > iterator ( ) { return elements . iterator ( ) ; }
static final int resize Stamp ( int n ) { return Integer . number Of Leading Zeros ( n ) | ( NUM_ << ( RESIZE STAMP BITS - NUM_ ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( NUM_ ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public synchronized static Registered Snapshot Categories shared Instance ( ) { if ( shared Instance == null ) shared Instance = new Registered Snapshot Categories ( ) ; return shared Instance ; }
int available ( ) { return num Available . get ( ) ; }
protected static List < Property Value Expression > to Property Expressions ( String ... properties ) { List < Property Value Expression > expr = new Array List < Property Value Expression > ( ) ; for ( String property : properties ) { expr . add ( get Prop Expr ( property ) ) ; } return expr ; }
public boolean do Clear All Registers ( ) { return m clear Register Checkbox . is Selected ( ) ; }
public static int parse IO Threads ( Integer threads ) { final int result = threads == null ? Math . min ( Constants . MAX IO THREADS , Environment . default Threads ( ) ) : threads ; return Math . max ( NUM_ , result - NUM_ ) ; }
public static int hash Code ( int pre , Stroke s ) { int h = ( s != null ? s . hash Code ( ) : NUM_ ) ; return NUM_ * pre + h ; }
public static boolean is Dialog Created ( String method ) { return dialog Creating Methods . contains ( method ) ; }
public String [ ] args ( ) { int size = m Selection Args . size ( ) ; if ( size == NUM_ ) return null ; return m Selection Args . to Array ( new String [ size ] ) ; }
public static Referenced Envelope tile 2 bounding Box ( final int x , final int y , final int zoom , int srid ) { Referenced Envelope referenced Envelope ; switch ( srid ) { case NUM_ : referenced Envelope = new Referenced Envelope ( tile 2 lon ( x , zoom ) , tile 2 lon ( x + NUM_ , zoom ) , tile 2 lat ( y + NUM_ , zoom ) , tile 2 lat ( y , zoom ) , CRS 4326 ) ; break ; case NUM_ : case NUM_ : referenced Envelope = new Referenced Envelope ( tile 2 x Mercator ( x , zoom ) , tile 2 x Mercator ( x + NUM_ , zoom ) , tile 2 y Mercator ( y + NUM_ , zoom ) , tile 2 y Mercator ( y , zoom ) , CRS 3857 ) ; break ; default : throw new Illegal Argument Exception ( srid + STR_ ) ; } return referenced Envelope ; }
private int case Of ( char word [ ] , int length ) { if ( dictionary . ignore Case || length == NUM_ || ! Character . is Upper Case ( word [ NUM_ ] ) ) { return EXACT CASE ; } boolean seen Upper = false ; boolean seen Lower = false ; for ( int i = NUM_ ; i < length ; i ++ ) { boolean v = Character . is Upper Case ( word [ i ] ) ; seen Upper |= v ; seen Lower |= ! v ; } if ( ! seen Lower ) { return UPPER CASE ; } else if ( ! seen Upper ) { return TITLE CASE ; } else { return EXACT CASE ; } }
boolean is Global Region Initializing ( String full Path ) { stopper . check Cancel In Progress ( null ) ; int old Level = Local Region . set Thread Init Level Requirement ( Local Region . ANY INIT ) ; try { return is Global Region Initializing ( ( Local Region ) get Region ( full Path ) ) ; } finally { Local Region . set Thread Init Level Requirement ( old Level ) ; } }
public static boolean is Visible ( Projection source Map Projection , Point 2 D llp ) { boolean ret = false ; if ( source Map Projection != null ) { if ( source Map Projection . is Plotable ( llp ) ) { Point 2 D p = source Map Projection . forward ( llp ) ; double x = p . get X ( ) ; double y = p . get Y ( ) ; if ( x >= NUM_ && x <= source Map Projection . get Width ( ) && y >= NUM_ && y <= source Map Projection . get Width ( ) ) { ret = true ; } } } return ret ; }
public Iterator < Soot Method > method Iterator ( ) { check Level ( SIGNATURES ) ; return method List . iterator ( ) ; }
public static String find ( Char Sequence self , Char Sequence regex , @ Closure Params ( value = Simple Type . class , options = STR_ ) Closure closure ) { return find ( self , Pattern . compile ( regex . to String ( ) ) , closure ) ; }
public boolean is Any ( ) { return m any Tag Box . is Selected ( ) ; }
public boolean is Idle Expire ( ) { if ( ! lifecycle . is Active ( ) ) { return true ; } long now = get Current Time Actual ( ) ; long idle Expire = thread Idle Expire Time . get ( ) ; int idle Count = idle Count . get ( ) ; if ( idle Min < idle Count ) { long next Idle Expire = now + idle Timeout ; if ( idle Max < idle Count && idle Min < idle Max ) { thread Idle Expire Time . compare And Set ( idle Expire , next Idle Expire ) ; return true ; } else if ( idle Expire < now && thread Idle Expire Time . compare And Set ( idle Expire , next Idle Expire ) ) { return true ; } } return false ; }
public static boolean wrap Off Heap Reference ( Object o ) { if ( o instanceof Stored Object ) { Stored Object so = ( Stored Object ) o ; if ( so . has Ref Count ( ) ) { return true ; } } return false ; }
private String new Request ID ( ) { String request ID String = null ; synchronized ( REQUEST ID LOCK ) { request ID String = String . value Of ( request ID ++ ) ; } return request ID String ; }
public boolean empty ( ) { return text . length ( ) == NUM_ && links . size ( ) == NUM_ && templates . size ( ) == NUM_ && tags . size ( ) == NUM_ && math Spans . size ( ) == NUM_ ; }
public boolean is Editable ( ) { return m Text Code . is Editable ( ) ; }
public static boolean is Empty ( Char Sequence str ) { if ( str == null || str . length ( ) == NUM_ ) { return true ; } else { return false ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public static byte [ ] encode JPEG ( Buffered Image image , float quality ) throws IO Exception { Byte Array Output Stream out = new Byte Array Output Stream ( ) ; Image Output Stream iosout = new Memory Cache Image Output Stream ( out ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ + out ) ; } Iterator < Image Writer > iter = Image IO . get Image Writers By Format Name ( STR_ ) ; Image Writer writer = iter . next ( ) ; Image Write Param iwp = writer . get Default Write Param ( ) ; iwp . set Compression Mode ( Image Write Param . MODE EXPLICIT ) ; iwp . set Compression Quality ( quality ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } writer . set Output ( iosout ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } IIO Image iioi = new IIO Image ( image , null , null ) ; writer . write ( null , iioi , iwp ) ; writer . dispose ( ) ; if ( Debug . debugging ( STR_ ) ) { Debug . output ( STR_ ) ; } return out . to Byte Array ( ) ; }
public boolean is Empty ( ) { return nodes . is Empty ( ) ; }
@ Override public byte [ ] encode ( ) { char type = get Attribute Type ( ) ; byte bin Value [ ] = new byte [ HEADER LENGTH + NUM_ ] ; bin Value [ NUM_ ] = ( byte ) ( type > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( type & NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( NUM_ > > NUM_ ) ; bin Value [ NUM_ ] = ( byte ) ( NUM_ & NUM_ ) ; System . arraycopy ( reservation Token , NUM_ , bin Value , NUM_ , NUM_ ) ; return bin Value ; }
public static boolean bool Value ( String prop Name , boolean dflt ) { String sys Prop = get Property ( prop Name ) ; return ( sys Prop != null && ! sys Prop . is Empty ( ) ) ? Boolean . get Boolean ( sys Prop ) : dflt ; }
public Tungsten Properties subset ( String prefix , boolean remove Prefix , boolean remove Props ) { Tungsten Properties tp = new Tungsten Properties ( ) ; Set < String > prefix Keys = key Names ( prefix ) ; int name Index = NUM_ ; if ( remove Prefix ) name Index = prefix . length ( ) ; for ( String key : prefix Keys ) { String new Key = key . substring ( name Index ) ; if ( new Key . length ( ) > NUM_ ) tp . set Object ( new Key , get Object ( key ) ) ; if ( remove Props ) remove ( key ) ; } return tp ; }
public static double min ( double [ ] a , int lo , int hi ) { if ( lo < NUM_ || hi >= a . length || lo > hi ) throw new Index Out Of Bounds Exception ( STR_ ) ; double min = Double . POSITIVE INFINITY ; for ( int i = lo ; i <= hi ; i ++ ) { if ( Double . is Na N ( a [ i ] ) ) return Double . Na N ; if ( a [ i ] < min ) min = a [ i ] ; } return min ; }
public final double sample Max ( ) { long max = time Max . get And Set ( NUM_ ) ; return scale * max ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private static boolean single Day Event ( long start Millis , long end Millis , long local Gmt Offset ) { if ( start Millis == end Millis ) { return true ; } int start Day = Time . get Julian Day ( start Millis , local Gmt Offset ) ; int end Day = Time . get Julian Day ( end Millis - NUM_ , local Gmt Offset ) ; return start Day == end Day ; }
public void throw Exception ( ) throws Exception { throw new Exception ( STR_ ) ; }
public String next String ( char quote ) throws JSON Exception { char c ; String Buffer sb = new String Buffer ( ) ; for ( ; ; ) { c = next ( ) ; switch ( c ) { case NUM_ : case STR_ : case STR_ : throw syntax Error ( STR_ ) ; case STR_ : c = next ( ) ; switch ( c ) { case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( STR_ ) ; break ; case STR_ : sb . append ( ( char ) Integer . parse Int ( next ( NUM_ ) , NUM_ ) ) ; break ; case STR_ : sb . append ( ( char ) Integer . parse Int ( next ( NUM_ ) , NUM_ ) ) ; break ; default : sb . append ( c ) ; } break ; default : if ( c == quote ) { return sb . to String ( ) ; } sb . append ( c ) ; } } }
public String encoding ( ) { if ( read Encoding != null ) return read Encoding ; Char Segment value = get Header Buffer ( STR_ ) ; if ( value == null ) return null ; int i = value . index Of ( STR_ ) ; if ( i < NUM_ ) return null ; int len = value . length ( ) ; for ( i += NUM_ ; i < len && Character . is Whitespace ( value . char At ( i ) ) ; i ++ ) { } if ( i >= len || value . char At ( i ) != STR_ ) return null ; for ( i ++ ; i < len && Character . is Whitespace ( value . char At ( i ) ) ; i ++ ) { } if ( i >= len ) return null ; char end = value . char At ( i ) ; if ( end == STR_ ) { int tail ; for ( tail = ++ i ; tail < len ; tail ++ ) { if ( value . char At ( tail ) == end ) break ; } read Encoding = Encoding . get Mime Name ( value . substring ( i , tail ) ) ; return read Encoding ; } int tail ; for ( tail = i ; tail < len ; tail ++ ) { if ( Character . is Whitespace ( value . char At ( tail ) ) || value . char At ( tail ) == STR_ ) break ; } read Encoding = Encoding . get Mime Name ( value . substring ( i , tail ) ) ; return read Encoding ; }
static public double y 1 ( double x ) throws Arithmetic Exception { if ( x < NUM_ ) { double y = x * x ; double ans 1 = x * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * NUM_ ) ) ) ) ) ; double ans 2 = NUM_ + y * ( NUM_ + y * ( NUM_ + y * ( NUM_ + y * ( NUM_ + y * ( NUM_ + y ) ) ) ) ) ; return ( ans 1 / ans 2 ) + NUM_ * ( j 1 ( x ) * Math . log ( x ) - NUM_ / x ) ; } else { double z = NUM_ / x ; double y = z * z ; double xx = x - NUM_ ; double ans 1 = NUM_ + y * ( NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ ) ) ) ) ; double ans 2 = NUM_ + y * ( - NUM_ + y * ( NUM_ + y * ( - NUM_ + y * NUM_ ) ) ) ; return Math . sqrt ( NUM_ / x ) * ( Math . sin ( xx ) * ans 1 + z * Math . cos ( xx ) * ans 2 ) ; } }
public static Chest chest ( String name ) { if ( name . equals ( DEFAULT DB NAME ) ) throw new Iron Exception ( DEFAULT DB NAME + STR_ ) ; return get Chest ( name ) ; }
public File tmp Dir ( ) { String random = String . value Of ( RANDOM . next Long ( ) ) ; File dir = tmp File ( STR_ + random ) ; assure Dir Exists ( dir ) ; return dir ; }
String char To String ( char c ) { if ( c < STR_ || c > NUM_ ) { return STR_ + ( int ) c ; } return String . value Of ( c ) ; }
private boolean service Has Ingress Rule ( List < Ingress > ingresses , Service service ) { String service Name = Kubernetes Helper . get Name ( service ) ; for ( Ingress ingress : ingresses ) { Ingress Spec spec = ingress . get Spec ( ) ; if ( spec == null ) { break ; } List < Ingress Rule > rules = spec . get Rules ( ) ; if ( rules == null ) { break ; } for ( Ingress Rule rule : rules ) { HTTP Ingress Rule Value http = rule . get Http ( ) ; if ( http == null ) { break ; } List < HTTP Ingress Path > paths = http . get Paths ( ) ; if ( paths == null ) { break ; } for ( HTTP Ingress Path path : paths ) { Ingress Backend backend = path . get Backend ( ) ; if ( backend == null ) { break ; } if ( Objects . equals ( service Name , backend . get Service Name ( ) ) ) { return true ; } } } } return false ; }
private boolean has Next Inet Socket Address ( ) { return next Inet Socket Address Index < inet Socket Addresses . size ( ) ; }
public static Driver driver ( URI uri , Auth Token auth Token , Config config ) { String scheme = uri . get Scheme ( ) ; Bolt Server Address address = Bolt Server Address . from ( uri ) ; Connection Settings connection Settings = new Connection Settings ( auth Token == null ? Auth Tokens . none ( ) : auth Token ) ; if ( config == null ) { config = Config . default Config ( ) ; } Security Plan security Plan ; try { security Plan = create Security Plan ( address , config ) ; } catch ( General Security Exception | IO Exception ex ) { throw new Client Exception ( STR_ , ex ) ; } Driver Contract driver Contract = new Driver Contract ( config . retry Logic ( ) ) ; Pool Settings pool Settings = new Pool Settings ( config . max Idle Connection Pool Size ( ) , config . idle Time Before Connection Test ( ) ) ; Connection Pool connection Pool = new Socket Connection Pool ( connection Settings , security Plan , pool Settings , config . logging ( ) ) ; switch ( scheme . to Lower Case ( ) ) { case STR_ : return new Direct Driver ( address , driver Contract , connection Pool , security Plan , config . logging ( ) ) ; case STR_ : return new Routing Driver ( config . routing Settings ( ) , address , driver Contract , connection Pool , security Plan , Clock . SYSTEM , config . logging ( ) ) ; default : throw new Client Exception ( format ( STR_ , scheme ) ) ; } }
private static boolean is Null Or Empty ( final String s ) { return s == null || s . is Empty ( ) ; }
private List < Co S > fetch Details Of All File Cos ( ) throws SOS Failure { final String method Name = STR_ ; log . trace ( method Name + STR_ ) ; final String FILE COS DETAIL URI = STR_ ; List < Co S > file Cos Id List = new Array List < Co S > ( ) ; try { for ( String cos Id : file Cos Id List ) { Co S . File Co S cos = client . query Object ( String . format ( FILE COS DETAIL URI , cos Id ) , Co S . File Co S . class ) ; if ( cos . is Inactive ( ) == false && cos . get Id ( ) != null ) { file Cos Id List . add ( cos ) ; log . trace ( method Name + cos ) ; } } log . trace ( method Name + STR_ + file Cos Id List . size ( ) + STR_ ) ; return file Cos Id List ; } catch ( No Such Algorithm Exception e ) { log . error ( method Name + STR_ , e ) ; throw new SOS Failure ( e ) ; } catch ( Uniform Interface Exception e ) { log . error ( method Name + STR_ , e ) ; throw new SOS Failure ( e ) ; } }
public static long component Size ( Class < ? > type ) { if ( ! type . is Primitive ( ) ) { switch ( JVM ARCH ) { case NUM_ : return NUM_ ; case NUM_ : return NUM_ ; } } int component Size ; if ( type == boolean . class || type == byte . class ) { component Size = NUM_ ; } else if ( type == char . class || type == short . class ) { component Size = NUM_ ; } else if ( type == int . class || type == float . class ) { component Size = NUM_ ; } else if ( type == long . class || type == double . class ) { component Size = NUM_ ; } else { component Size = - NUM_ ; } return component Size ; }
public static Test suite ( ) { return new Test Suite ( Add Values Test . class ) ; }
public boolean field Is Single Value Enum ( ) { Class < ? > type = field . get Type ( ) ; return type . is Enum ( ) && type . get Enum Constants ( ) . length == NUM_ ; }
@ Override public < T > Provider < T > provider ( Key < T > key ) { Objects . require Non Null ( key ) ; Provider < T > provider = ( Provider ) provider Map . get ( key ) ; if ( provider == null ) { provider = lookup Provider ( key ) ; if ( provider == null ) { provider = auto Provider ( key ) ; } provider Map . put If Absent ( key , provider ) ; provider = ( Provider ) provider Map . get ( key ) ; } return provider ; }
@ Override public double [ ] to Double Array ( ) { double [ ] new Values = new double [ m Att Values . length ] ; System . arraycopy ( m Att Values , NUM_ , new Values , NUM_ , m Att Values . length ) ; return new Values ; }
public String [ ] arguments ( ) { return arguments ; }
public int index Of ( Object key ) { return key == null ? index Of Null ( ) : index Of ( key , key . hash Code ( ) ) ; }
public final static boolean is Main Context ( App Context ctx ) { return ( ctx != null && ctx == main App Context ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public static boolean contains All Uuids ( Parcel Uuid [ ] uuid A , Parcel Uuid [ ] uuid B ) { if ( uuid A == null && uuid B == null ) return true ; if ( uuid A == null ) { return uuid B . length == NUM_ ? true : false ; } if ( uuid B == null ) return true ; Hash Set < Parcel Uuid > uuid Set = new Hash Set < Parcel Uuid > ( Arrays . as List ( uuid A ) ) ; for ( Parcel Uuid uuid : uuid B ) { if ( ! uuid Set . contains ( uuid ) ) return false ; } return true ; }
public static boolean is Not Modified ( Http Servlet Request request , Http Servlet Response response , Identifiable Object object ) { String tag = Identifiable Object Utils . get Last Updated Tag ( object ) ; response . set Header ( HEADER ETAG , tag ) ; String input Tag = request . get Header ( HEADER IF NONE MATCH ) ; if ( object != null && input Tag != null && tag != null && input Tag . equals ( tag ) ) { response . set Status ( Http Servlet Response . SC NOT MODIFIED ) ; return true ; } return false ; }
public static float color To Float ( final Color clr ) { return Color . RG Bto HSB ( clr . get Red ( ) , clr . get Green ( ) , clr . get Blue ( ) , null ) [ NUM_ ] ; }
public static boolean equals Ignore Case ( char ch 1 , char ch 2 ) { if ( ch 1 == ch 2 ) return true ; ch 1 = Character . to Upper Case ( ch 1 ) ; ch 2 = Character . to Upper Case ( ch 2 ) ; if ( ch 1 == ch 2 ) return true ; return Character . to Lower Case ( ch 1 ) == Character . to Lower Case ( ch 2 ) ; }
@ GET @ Produces ( Media Type . APPLICATION JSON ) @ Path ( STR_ ) public Map < String , List < ? extends Object > > help ( ) { Map < String , List < ? > > result = new Linked Hash Map < > ( ) ; List < Endpoint Help Dto > endpoints = describe Endpoints ( get Endpoints ( ) ) ; if ( endpoints != null && ! endpoints . is Empty ( ) ) { result . put ( STR_ , endpoints ) ; } List < Method Help Dto > methods = describe Methods ( ) ; if ( methods != null && ! methods . is Empty ( ) ) { result . put ( STR_ , methods ) ; } return result ; }
public int zoom Level For Scale ( float scale , int scale Type ) { if ( scale == NUM_ ) { return NUM_ ; } else if ( scale < NUM_ ) { return Math . round ( scale * NUM_ ) ; } double scale From 0 x 10 = Math . round ( scale * NUM_ ) - NUM_ ; double exact Value = Math . log ( scale From 0 x 10 ) / Math . log ( NUM_ ) ; int rounded Value = ( int ) ( scale Type == SCALE TYPE FLOOR ? Math . floor ( exact Value ) : scale Type == SCALE TYPE CEIL ? Math . ceil ( exact Value ) : Math . round ( exact Value ) ) ; return ( int ) ( NUM_ + Math . pow ( NUM_ , rounded Value ) ) ; }
@ Override public int clamp View Position Horizontal ( View child , int left , int dx ) { int left Bound = NUM_ ; int right Bound = NUM_ ; switch ( dragger View . get Drag Position ( ) ) { case RIGHT : if ( left > NUM_ ) { left Bound = dragger View . get Padding Left ( ) ; right Bound = ( int ) dragger Listener . drag Horizontal Drag Range ( ) ; } break ; case LEFT : if ( left < NUM_ ) { left Bound = ( int ) - dragger Listener . drag Horizontal Drag Range ( ) ; right Bound = dragger View . get Padding Left ( ) ; } break ; default : break ; } return Math . min ( Math . max ( left , left Bound ) , right Bound ) ; }
public static boolean is AMSDK Configured ( String realm ) { if ( Service Manager . is Coexistence Mode ( ) ) { return ( true ) ; } realm = DN Utils . normalize DN ( realm ) ; Boolean answer = ( Boolean ) amsdk Configured Realms . get ( realm ) ; if ( answer == null ) { try { SSO Token token = ( SSO Token ) Access Controller . do Privileged ( Admin Token Action . get Instance ( ) ) ; Organization Config Manager Impl ocm = Organization Config Manager Impl . get Instance ( token , realm ) ; String orgname = get Amsdkdn ( token , ocm ) ; answer = Boolean . value Of ( orgname != null ) ; } catch ( SSO Exception ssoe ) { answer = Boolean . FALSE ; } catch ( SMS Exception smse ) { answer = Boolean . FALSE ; } amsdk Configured Realms . put ( realm , answer ) ; } return ( answer . boolean Value ( ) ) ; }
@ Suppress Warnings ( STR_ ) private T [ ] combined Buffer To Items Array ( boolean ordered ) { T [ ] out Arr = null ; final int extra = NUM_ ; final int out Arr Cap = get Retained Items ( ) ; out Arr = ( T [ ] ) Array . new Instance ( min Value . get Class ( ) , out Arr Cap + extra ) ; out Arr [ NUM_ ] = min Value ; out Arr [ NUM_ ] = max Value ; System . arraycopy ( combined Buffer , NUM_ , out Arr , extra , base Buffer Count ) ; long bits = bit Pattern ; if ( bits > NUM_ ) { int index = extra + base Buffer Count ; for ( int level = NUM_ ; bits != NUM_ ; level ++ , bits >>>= NUM_ ) { if ( ( bits & NUM_ ) > NUM_ ) { System . arraycopy ( combined Buffer , ( NUM_ + level ) * k , out Arr , index , k ) ; index += k ; } } } if ( ordered ) { Arrays . sort ( out Arr , extra , base Buffer Count + extra , comparator ) ; } return out Arr ; }
public final double radian ( Coords d ) { final Ideal Hex src = Ideal Hex . get ( this ) ; final Ideal Hex dst = Ideal Hex . get ( d ) ; if ( src . cy == dst . cy ) { return ( src . cx < dst . cx ) ? Math . PI / NUM_ : Math . PI * NUM_ ; } double r = Math . atan ( ( dst . cx - src . cx ) / ( src . cy - dst . cy ) ) ; if ( src . cy < dst . cy ) { r = ( r + Math . PI ) % ( Math . PI * NUM_ ) ; } if ( r < NUM_ ) { r += Math . PI * NUM_ ; } return r ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
@ Deprecated public static Collection < String > id 8 s ( @ Nullable Collection < UUID > ids ) { if ( ids == null || ids . is Empty ( ) ) return Collections . empty List ( ) ; return F . view Read Only ( ids , ID 2 ID 8 ) ; }
public Integer integer attribute ( String name ) throws Invalid Properties Format Exception { String val = get attr ( name ) ; if ( val == null ) return null ; try { return Integer . parse Int ( val ) ; } catch ( Number Format Exception e ) { throw new Invalid Properties Format Exception ( e ) ; } }
public static Q Name value Of ( String s ) { if ( ( s == null ) || s . equals ( STR_ ) ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( s . char At ( NUM_ ) == STR_ ) { int i = s . index Of ( STR_ ) ; if ( i == - NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( i == s . length ( ) - NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } else { return new Q Name ( s . substring ( NUM_ , i ) , s . substring ( i + NUM_ ) ) ; } } else { return new Q Name ( s ) ; } }
@ Override public String cipher Suite ( ) { SSL Socket ssl Socket = ssl Socket ; if ( ssl Socket == null ) { return super . cipher Suite ( ) ; } SSL Session ssl Session = ssl Socket . get Session ( ) ; if ( ssl Session != null ) { return ssl Session . get Cipher Suite ( ) ; } else { return null ; } }
@ Override public boolean contains ( Value subvalue ) { return set . contains ( subvalue ) ; }
public boolean engine Is On ( ) { return ( start button . is Selected ( ) ) ; }
private int last Doc ( int i 4096 ) { long index ; while ( i 4096 >= NUM_ ) { index = indices [ i 4096 ] ; if ( index != NUM_ ) { final int i 64 = NUM_ - Long . number Of Leading Zeros ( index ) ; final long bits = this . bits [ i 4096 ] [ Long . bit Count ( index ) - NUM_ ] ; return ( i 4096 << NUM_ ) | ( i 64 << NUM_ ) | ( NUM_ - Long . number Of Leading Zeros ( bits ) ) ; } i 4096 -= NUM_ ; } return - NUM_ ; }
default void for Each Remaining ( Double Consumer action ) { Objects . require Non Null ( action ) ; while ( has Next ( ) ) action . accept ( next Double ( ) ) ; }
public static String utf 8 Encode ( String str , String defult Return ) { if ( ! is Empty ( str ) && str . get Bytes ( ) . length != str . length ( ) ) { try { return URL Encoder . encode ( str , STR_ ) ; } catch ( Unsupported Encoding Exception e ) { return defult Return ; } } return str ; }
@ Override public List < Map < String , String > > task Configs ( int max Tasks ) { Array List < Map < String , String > > configs = new Array List < > ( ) ; List < String > dbs = Arrays . as List ( databases . split ( STR_ ) ) ; int num Groups = Math . min ( dbs . size ( ) , max Tasks ) ; List < List < String > > dbs Grouped = Connector Utils . group Partitions ( dbs , num Groups ) ; for ( int i = NUM_ ; i < num Groups ; i ++ ) { Map < String , String > config = new Hash Map < > ( ) ; config . put ( PORT , port ) ; config . put ( HOST , host ) ; config . put ( SCHEMA NAME , schema Name ) ; config . put ( BATCH SIZE , batch Size ) ; config . put ( TOPIC PREFIX , topic Prefix ) ; config . put ( DATABASES , String Utils . join ( dbs Grouped . get ( i ) , STR_ ) ) ; configs . add ( config ) ; } return configs ; }
@ Override public boolean connection Allowed ( String event Name ) { return event Name . equals ( STR_ ) || event Name . equals ( STR_ ) ; }
private static double [ ] next Point Around Line ( double lat 1 , double lon 1 , double lat 2 , double lon 2 ) { double x 1 = lon 1 ; double x 2 = lon 2 ; double y 1 = lat 1 ; double y 2 = lat 2 ; double min X = Math . min ( x 1 , x 2 ) ; double max X = Math . max ( x 1 , x 2 ) ; double min Y = Math . min ( y 1 , y 2 ) ; double max Y = Math . max ( y 1 , y 2 ) ; if ( min X == max X ) { return new double [ ] { next Latitude Between ( min Y , max Y ) , next Longitude Near ( min X , NUM_ * ( max Y - min Y ) ) } ; } else if ( min Y == max Y ) { return new double [ ] { next Latitude Near ( min Y , NUM_ * ( max X - min X ) ) , next Longitude Between ( min X , max X ) } ; } else { double x = next Longitude Between ( min X , max X ) ; double y = ( y 1 - y 2 ) / ( x 1 - x 2 ) * ( x - x 1 ) + y 1 ; if ( Double . is Finite ( y ) == false ) { y = Math . copy Sign ( NUM_ , x 1 ) ; } double delta = ( max Y - min Y ) * NUM_ ; y = Math . min ( NUM_ , y ) ; y = Math . max ( - NUM_ , y ) ; return new double [ ] { next Latitude Near ( y , delta ) , x } ; } }
public static float explain Tolerance Delta ( float f 1 , float f 2 ) { return Math . max ( EXPLAIN SCORE TOLERANCE MINIMUM , Math . max ( Math . abs ( f 1 ) , Math . abs ( f 2 ) ) * EXPLAIN SCORE TOLERANCE DELTA ) ; }
public double norm ( ) { if ( m Elements != null ) { int n = m Elements . length ; double sum = NUM_ ; for ( int i = NUM_ ; i < n ; i ++ ) { sum += m Elements [ i ] * m Elements [ i ] ; } return Math . pow ( sum , NUM_ ) ; } else return NUM_ ; }
public static List < I Path > deserialize Paths ( String raw Property Value ) { List < I Path > paths = new Array List < I Path > ( ) ; if ( raw Property Value != null && raw Property Value . length ( ) > NUM_ ) { String [ ] pattern Strings = raw Property Value . split ( STR_ ) ; for ( String pattern String : pattern Strings ) { paths . add ( new Path ( pattern String ) ) ; } } return paths ; }
static boolean is Bound To Any Group ( ) { return my Group And Invoke Count . get ( ) != null ; }
public Set < String > schema Sub Entries ( SSO Token token , String obj Name , String filter , String sid Filter , int num Of Entries , boolean sort Results , boolean ascending Order ) throws SMS Exception , SSO Exception { if ( obj Name == null || obj Name . length ( ) == NUM_ || filter == null || filter . length ( ) == NUM_ || sid Filter == null || sid Filter . length ( ) == NUM_ ) { throw new Illegal Argument Exception ( STR_ + STR_ ) ; } Set < String > subentries = null ; try { subentries = get Sub Entries ( obj Name , filter , sid Filter , num Of Entries , sort Results , ascending Order ) ; } catch ( Service Not Found Exception e ) { subentries = new Case Insensitive Hash Set < > ( ) ; } if ( m Debug . message Enabled ( ) ) { m Debug . message ( STR_ + STR_ + filter + STR_ + obj Name + STR_ + subentries . size ( ) + STR_ ) ; } return ( subentries ) ; }
public static String remove Static Attribute Flag ( String attribute Name ) { if ( is Static Attribute ( attribute Name ) ) { return attribute Name . substring ( STATIC QUOTE . length ( ) , attribute Name . length ( ) - STATIC QUOTE . length ( ) ) ; } else { return attribute Name ; } }
@ Override public boolean equals ( Object o ) { if ( o == null ) return false ; if ( o == this ) return true ; if ( ! ( o instanceof Attribute ) ) return false ; final Attribute attribute = ( Attribute ) o ; if ( name != null ? ! name . equals ( attribute . name ) : attribute . name != null ) return false ; if ( compare Value ) if ( value != null ? ! value . equals ( attribute . value ) : attribute . value != null ) return false ; return true ; }
private String Buffer prefix As String Buffer ( int col ) { String Buffer val = new String Buffer ( ) ; if ( prefix != null && prefix . size ( ) > NUM_ ) { for ( int i = NUM_ ; i < prefix . size ( ) ; i ++ ) { String line = ( String ) prefix . element At ( i ) ; if ( i != NUM_ ) { val . append ( N Spaces ( col ) ) ; } val . append ( line ) ; if ( i != prefix . size ( ) - NUM_ ) { val . append ( STR_ ) ; } } } return val ; }
private Jedis Pool jedis Pool From Server And Port ( final String host And Port ) { Matcher matcher = SERVER FORMAT . matcher ( host And Port ) ; if ( ! matcher . matches ( ) ) { throw new Invalid Server Format Exception ( host And Port ) ; } return new Jedis Pool ( matcher . group ( NUM_ ) , Integer . value Of ( matcher . group ( NUM_ ) ) ) ; }
public static boolean is Fragmentable Type ( Class property Type ) { if ( property Type == null ) { return false ; } if ( property Type . is Array ( ) ) { return is Fragmentable Type ( property Type . get Component Type ( ) ) ; } if ( Java Class Helper . is Java Builtin Data Type ( property Type ) ) { return false ; } if ( property Type . is Enum ( ) ) { return false ; } if ( Java Class Helper . is Implements Interface ( property Type , Map . class ) ) { return false ; } if ( property Type == Node . class ) { return false ; } if ( property Type == Node List . class ) { return false ; } if ( property Type == Object . class ) { return false ; } if ( property Type == Calendar . class ) { return false ; } if ( property Type == Date . class ) { return false ; } if ( property Type == Local Date Time . class ) { return false ; } if ( property Type == Zoned Date Time . class ) { return false ; } if ( property Type == Local Date . class ) { return false ; } if ( property Type == Local Time . class ) { return false ; } if ( property Type == java . sql . Date . class ) { return false ; } if ( property Type == java . sql . Time . class ) { return false ; } if ( property Type == java . sql . Timestamp . class ) { return false ; } return true ; }
public static String right Pad ( final String value , String pad , final int length ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; if ( value . length ( ) > length ) { return value ; } return append ( value , repeat ( pad , length - value . length ( ) ) ) ; }
public boolean contains ( String key ) { Assert . is True ( allowed Keys . contains ( key . to Lower Case ( ) ) ) ; return hashtable . contains Key ( key . to Lower Case ( ) ) ; }
public static boolean is Available ( ) { return proxy != null ; }
public int is Match ( char [ ] buffer , int pos , int buffer Start , int buffer End ) { return Arrays . binary Search ( chars , buffer [ pos ] ) >= NUM_ ? NUM_ : NUM_ ; }
public Element create Xml Element ( Document doc , String id ) throws Exception { Element manifest Element = doc . create Element ( Helper . PREFIX DS + Constants . TAG MANIFEST ) ; manifest Element . set Attribute ( Constants . ATT ID , id ) ; for ( Message Part r : references ) { manifest Element . append Child ( create Reference ( doc , r ) ) ; } return manifest Element ; }
public static boolean is Federation Cancelled ( Http Servlet Request request ) { String status = request . get Parameter ( IFS Constants . TERMINATION STATUS ) ; if ( status != null && status . equals Ignore Case ( IFS Constants . CANCEL ) ) { return true ; } else { return false ; } }
static public final float cos Deg ( float degrees ) { return Sin . table [ ( int ) ( ( degrees + NUM_ ) * deg To Index ) & SIN MASK ] ; }
public static Long to Millisec ( String datestring ) { Date date = parse ( datestring ) ; if ( date == null ) { return null ; } return date . get Time ( ) ; }
public final boolean equals Ignore Case ( Char Segment b ) { int length = length ; if ( length != b . length ) return false ; char [ ] buffer = buffer ; char [ ] b Buffer = b . buffer ; int offset = offset ; int b Offset = b . offset ; for ( int i = length - NUM_ ; i >= NUM_ ; i -- ) { char ca = buffer [ offset + i ] ; char cb = b Buffer [ b Offset + i ] ; if ( ca != cb && Character . to Lower Case ( ca ) != Character . to Lower Case ( cb ) ) return false ; } return true ; }
protected static boolean is Client Type Valid ( String user Agent ) { boolean valid = true ; for ( int i = NUM_ ; ( i < invalid Characters . length ) && valid ; i ++ ) { valid = ( user Agent . index Of ( invalid Characters [ i ] ) == - NUM_ ) ; } return valid ; }
public static boolean is Drawable Image ( String image Path ) { return image Path . starts With ( STR_ ) ; }
public List < Order > fetch Orders ( int start Index ) { try { Thread . sleep ( NUM_ ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } return fetch Orders ( start Index , NUM_ ) ; }
@ Override public boolean is Start Element ( ) { log . log ( Level . FINE , STR_ , event == START ELEMENT ) ; return event == START ELEMENT ; }
public Enumeration < PM Element > elements ( ) { return gr . elements ( ) ; }
public static String signature Method Name ( String sig ) { int pos 1 = sig . index Of ( STR_ ) + NUM_ ; int pos 2 = sig . index Of ( STR_ , pos 1 ) ; pos 1 = sig . last Index Of ( STR_ , pos 2 ) + NUM_ ; return sig . substring ( pos 1 , pos 2 ) ; }
public static double stddev ( double [ ] a , int lo , int hi ) { return Math . sqrt ( var ( a , lo , hi ) ) ; }
public List < Module Wizard Step > create Wizard Steps ( Project From Sources Builder builder , Project Descriptor project Descriptor , Icon step Icon ) { return Collections . empty List ( ) ; }
@ Override public boolean is Outbound Done ( ) { return writer . is Outbound Done ( ) ; }
public static List parse Values ( String file Name ) throws CLI Exception { Buffered Reader in = null ; List values = new Array List ( ) ; try { in = new Buffered Reader ( new File Reader ( file Name ) ) ; String line = in . read Line ( ) ; while ( line != null ) { line = line . trim ( ) ; if ( line . length ( ) > NUM_ ) { values . add ( line ) ; } line = in . read Line ( ) ; } } catch ( IO Exception e ) { throw new CLI Exception ( e , Exit Codes . IO EXCEPTION ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IO Exception e ) { } } } return values ; }
public static boolean requires Bidi ( char [ ] text , int start , int limit ) { final int RTL Mask = ( NUM_ << Bidi . DIRECTION RIGHT TO LEFT | NUM_ << AL | NUM_ << RLE | NUM_ << RLO | NUM_ << AN ) ; if ( NUM_ > start || start > limit || limit > text . length ) { throw new Illegal Argument Exception ( STR_ + start + STR_ + limit ) ; } for ( int i = start ; i < limit ; ++ i ) { if ( Character . is High Surrogate ( text [ i ] ) && i < ( limit - NUM_ ) && Character . is Low Surrogate ( text [ i + NUM_ ] ) ) { if ( ( ( NUM_ << U Character . get Direction ( Character . code Point At ( text , i ) ) ) & RTL Mask ) != NUM_ ) { return true ; } } else if ( ( ( NUM_ << U Character . get Direction ( text [ i ] ) ) & RTL Mask ) != NUM_ ) { return true ; } } return false ; }
protected float distance ( double x , double y ) { float distance = Float . POSITIVE INFINITY ; General Path shape = get Shape ( ) ; if ( get Need To Regenerate ( ) || shape == null ) { return distance ; } if ( shape . contains ( x , y ) ) { return NUM_ ; } else { return distance To Edge ( x , y ) ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private static byte [ ] read One Block ( Input Stream is ) throws IO Exception { int c = is . read ( ) ; if ( c == - NUM_ ) { return null ; } if ( c == Der Value . tag Sequence ) { Byte Array Output Stream bout = new Byte Array Output Stream ( NUM_ ) ; bout . write ( c ) ; read BER Internal ( is , bout , c ) ; return bout . to Byte Array ( ) ; } else { char [ ] data = new char [ NUM_ ] ; int pos = NUM_ ; int hyphen = ( c == STR_ ) ? NUM_ : NUM_ ; int last = ( c == STR_ ) ? - NUM_ : c ; while ( true ) { int next = is . read ( ) ; if ( next == - NUM_ ) { return null ; } if ( next == STR_ ) { hyphen ++ ; } else { hyphen = NUM_ ; last = next ; } if ( hyphen == NUM_ && ( last == - NUM_ || last == STR_ || last == STR_ ) ) { break ; } } int end ; String Builder header = new String Builder ( STR_ ) ; while ( true ) { int next = is . read ( ) ; if ( next == - NUM_ ) { throw new IO Exception ( STR_ ) ; } if ( next == STR_ ) { end = STR_ ; break ; } if ( next == STR_ ) { next = is . read ( ) ; if ( next == - NUM_ ) { throw new IO Exception ( STR_ ) ; } if ( next == STR_ ) { end = STR_ ; } else { end = STR_ ; data [ pos ++ ] = ( char ) next ; } break ; } header . append ( ( char ) next ) ; } while ( true ) { int next = is . read ( ) ; if ( next == - NUM_ ) { throw new IO Exception ( STR_ ) ; } if ( next != STR_ ) { data [ pos ++ ] = ( char ) next ; if ( pos >= data . length ) { data = Arrays . copy Of ( data , data . length + NUM_ ) ; } } else { break ; } } String Builder footer = new String Builder ( STR_ ) ; while ( true ) { int next = is . read ( ) ; if ( next == - NUM_ || next == end || next == STR_ ) { break ; } if ( next != STR_ ) footer . append ( ( char ) next ) ; } check Header Footer ( header . to String ( ) , footer . to String ( ) ) ; return Pem . decode ( new String ( data , NUM_ , pos ) ) ; } }
private static boolean is Symbolic ( Smt Expr left , Smt Expr right , List < Smt Expr > others ) { if ( left . is Symbolic ( ) || right . is Symbolic ( ) ) { return true ; } for ( Smt Expr smt Expr : others ) { if ( smt Expr . is Symbolic ( ) ) { return true ; } } return false ; }
public static double next Weibull ( double alpha , double beta , Random Engine random Generator ) { return Math . pow ( beta * ( - Math . log ( NUM_ - random Generator . raw ( ) ) ) , NUM_ / alpha ) ; }
public static boolean is Integral ( Type type ) { if ( type == null ) { return false ; } switch ( type . get Kind ( ) ) { case BYTE : case SHORT : case INT : case LONG : return true ; default : return false ; } }
private static double v 2 Distance Between 2 Points ( Point 2 D . Double a , Point 2 D . Double b ) { return Math . sqrt ( v 2 Squared Distance Between 2 Points ( a , b ) ) ; }
static public final float sin ( float radians ) { return Sin . table [ ( int ) ( radians * rad To Index ) & SIN MASK ] ; }
public static Automaton union ( Automaton a 1 , Automaton a 2 ) { return union ( Arrays . as List ( a 1 , a 2 ) ) ; }
public boolean is Complete ( ) { return complete ; }
public Sorted Set < String > fields ( ) { if ( my Field Set == null ) my Field Set = new Tree Set < String > ( fields . key Set ( ) ) ; return my Field Set ; }
public static int [ ] rand Permute With Exclusion ( int floor , int ceil , int excluded ) { int [ ] permute = new int [ ceil - floor - NUM_ ] ; Random randi = new Random ( ) ; int k = floor - NUM_ ; for ( int i = floor ; i < ceil ; i ++ ) { if ( i == excluded ) { continue ; } else { k ++ ; } int j = randi . next Int ( k - floor + NUM_ ) ; if ( j != k - floor ) { permute [ k - floor ] = permute [ j ] ; } permute [ j ] = i ; } return permute ; }
public static Document new Document ( ) { return document Builder . new Document ( ) ; }
public boolean has Property ( String key ) throws Ade Internal Exception { return get Raw Property Value ( key ) != null ; }
public static Issuer create Issuer ( String entity ID ) throws SAML 2 Exception { String method = STR_ ; Issuer issuer = assertion Factory . create Issuer ( ) ; issuer . set Value ( entity ID ) ; if ( debug . message Enabled ( ) ) { debug . message ( method + STR_ + issuer . to XML String ( ) ) ; } return issuer ; }
public static Object read Property ( Object bean , Property Descriptor descriptor ) { try { Method read Method = descriptor . get Read Method ( ) ; if ( read Method == null ) { throw new Illegal Argument Exception ( String . format ( STR_ , descriptor . get Name ( ) ) ) ; } if ( ! read Method . is Accessible ( ) ) { read Method . set Accessible ( true ) ; } return read Method . invoke ( bean ) ; } catch ( Invocation Target Exception e ) { throw new Runtime Exception ( e . get Cause ( ) ) ; } catch ( Exception e ) { } return null ; }
public String business Object Format Key To String ( Business Object Format Key business Object Format Key ) { return business Object Format Key To String ( business Object Format Key . get Namespace ( ) , business Object Format Key . get Business Object Definition Name ( ) , business Object Format Key . get Business Object Format Usage ( ) , business Object Format Key . get Business Object Format File Type ( ) , business Object Format Key . get Business Object Format Version ( ) ) ; }
private static boolean check Loader Ancestry ( Class Loader child , Class Loader ancestor ) { if ( ancestor == null ) { return true ; } else if ( child == null ) { return false ; } else { for ( Class Loader parent = child ; parent != null ; parent = parent . get Parent ( ) ) { if ( parent == ancestor ) { return true ; } } return false ; } }
private static boolean stub Class Exists ( Class < ? > remote Class ) { if ( ! without Stubs . contains Key ( remote Class ) ) { try { Class . for Name ( remote Class . get Name ( ) + STR_ , false , remote Class . get Class Loader ( ) ) ; return true ; } catch ( Class Not Found Exception cnfe ) { without Stubs . put ( remote Class , null ) ; } } return false ; }
public I Java Element create Element ( Class Scope scope , I Compilation Unit unit , Hash Set existing Elements , Hash Map known Scopes ) { return create Element ( scope , scope . reference Context . source Start , unit , existing Elements , known Scopes ) ; }
private static final int month Length ( int year , int month ) { return MONTH LENGTH [ month + ( is Leap Year ( year ) ? NUM_ : NUM_ ) ] ; }
private Date max Date ( @ Nullable Date d 1 , @ Nullable Date d 2 ) { if ( d 1 == null ) return d 2 ; if ( d 2 == null ) return d 1 ; return d 1 . before ( d 2 ) ? d 2 : d 1 ; }
public final boolean is Crypto Allowed ( Key key ) throws Exemption Mechanism Exception { boolean ret = false ; if ( done && ( key != null ) ) { ret = key Stored . equals ( key ) ; } return ret ; }
public String to String For Quest State ( ) { final String Builder sb = new String Builder ( ) ; boolean first = true ; for ( final Map . Entry < String , Integer > e : entry Set ( ) ) { if ( first ) { first = false ; } else { sb . append ( STR_ ) ; } sb . append ( e . get Key ( ) ) ; sb . append ( STR_ ) ; sb . append ( e . get Value ( ) ) ; } return sb . to String ( ) ; }
public int random Index Choice ( List < Integer > weights ) { int result = NUM_ , index ; double max Key = NUM_ ; double u , key ; int weight ; for ( List Iterator < Integer > it = weights . list Iterator ( ) ; it . has Next ( ) ; ) { index = it . next Index ( ) ; weight = it . next ( ) ; u = random . next Double ( ) ; key = Math . pow ( u , ( NUM_ / weight ) ) ; if ( key > max Key ) { max Key = key ; result = index ; } } return result ; }
public final static byte [ ] to Byte Array ( String uid ) { byte [ ] result = new byte [ NUM_ ] ; char [ ] chars = uid . to Char Array ( ) ; int r = NUM_ ; for ( int i = NUM_ ; i < chars . length ; ++ i ) { if ( chars [ i ] == STR_ ) { continue ; } int h 1 = Character . digit ( chars [ i ] , NUM_ ) ; ++ i ; int h 2 = Character . digit ( chars [ i ] , NUM_ ) ; result [ ( r ++ ) ] = ( byte ) ( ( h 1 << NUM_ | h 2 ) & NUM_ ) ; } return result ; }
public static Map < String , Set < String > > parse ( Command Manager mgr , String file Name , List list Attribute Values ) throws CLI Exception { Map < String , Set < String > > results = null ; if ( file Name != null ) { results = parse ( mgr , file Name ) ; } if ( ( list Attribute Values != null ) && ! list Attribute Values . is Empty ( ) ) { if ( results != null ) { results . put All ( parse ( mgr , list Attribute Values ) ) ; } else { results = parse ( mgr , list Attribute Values ) ; } } return ( results == null ) ? new Hash Map < String , Set < String > > ( ) : results ; }
public static Workflow Annotations lookup Operator Annotations ( Operator operator ) { return ( Workflow Annotations ) operator . get User Data ( KEY OPERATOR ANNOTATION ) ; }
public boolean is Selected ( ) { return check Box . is Selected ( ) ; }
public boolean is Same Shard ( Shard Routing other ) { return index . equals ( other . index ) && shard Id == other . shard Id ; }
public List < Node > list Available Terminals ( Class < ? > type ) { List < Node > result = new Array List < Node > ( ) ; for ( Node node : available Nodes ) { if ( ( node . get Number Of Arguments ( ) == NUM_ ) && type . is Assignable From ( node . get Return Type ( ) ) ) { result . add ( node ) ; } } return result ; }
private static String new Unique Path ( File location ) { if ( ! location . exists ( ) ) { return location . get Absolute Path ( ) ; } String name = location . get Name ( ) ; File directory = location . get Parent File ( ) ; int tries = NUM_ ; while ( true ) { String candidate Name = String . format ( STR_ , name , tries ) ; File candidate File = new File ( directory , candidate Name ) ; if ( ! candidate File . exists ( ) ) { return candidate File . get Absolute Path ( ) ; } tries ++ ; } }
private < T > int find Tree Node Depth ( Map < T , T > tree , T node ) { int result = NUM_ ; T parent = tree . get ( node ) ; while ( parent != null ) { result ++ ; node = parent ; parent = tree . get ( node ) ; } return result ; }
public int size ( ) { return map . size ( ) ; }
public static String lcs ( String s , String t ) { Suffix Array suffix 1 = new Suffix Array ( s ) ; Suffix Array suffix 2 = new Suffix Array ( t ) ; String lcs = STR_ ; int i = NUM_ , j = NUM_ ; while ( i < s . length ( ) && j < t . length ( ) ) { int p = suffix 1 . index ( i ) ; int q = suffix 2 . index ( j ) ; String x = lcp ( s , p , t , q ) ; if ( x . length ( ) > lcs . length ( ) ) lcs = x ; if ( compare ( s , p , t , q ) < NUM_ ) i ++ ; else j ++ ; } return lcs ; }
private static Spannable String Builder from Html ( String subject , String source , Theme Colors colors , Image Getter image Getter , boolean open Spoilers ) { Parser parser = new Parser ( ) ; try { parser . set Property ( Parser . schema Property , Html Parser Holder . schema ) ; } catch ( org . xml . sax . SAX Not Recognized Exception e ) { throw new Runtime Exception ( e ) ; } catch ( org . xml . sax . SAX Not Supported Exception e ) { throw new Runtime Exception ( e ) ; } Html To Spanned Converter converter = new Html To Spanned Converter ( subject , source , colors , image Getter , open Spoilers , parser ) ; return converter . convert ( ) ; }
public Tree < String > extract Best Max Rule Parse 1 ( int start , int end , int state , List < String > sentence ) { int c State = maxc Child [ start ] [ end ] [ state ] ; if ( c State == - NUM_ ) { return extract Best Max Rule Parse 2 ( start , end , state , sentence ) ; } else { List < Tree < String > > child = new Array List < Tree < String > > ( ) ; child . add ( extract Best Max Rule Parse 2 ( start , end , c State , sentence ) ) ; String state Str = ( String ) tag Numberer . object ( state ) ; if ( state Str . ends With ( STR_ ) ) state Str = state Str . substring ( NUM_ , state Str . length ( ) - NUM_ ) ; total Used Unaries ++ ; int intermediate Node = grammar . get Unary Intermediate ( ( short ) state , ( short ) c State ) ; if ( intermediate Node > NUM_ ) { List < Tree < String > > restored Child = new Array List < Tree < String > > ( ) ; n Times Restored Unaries ++ ; String state Str 2 = ( String ) tag Numberer . object ( intermediate Node ) ; if ( state Str 2 . ends With ( STR_ ) ) state Str 2 = state Str 2 . substring ( NUM_ , state Str 2 . length ( ) - NUM_ ) ; restored Child . add ( new Tree < String > ( state Str 2 , child ) ) ; return new Tree < String > ( state Str , restored Child ) ; } return new Tree < String > ( state Str , child ) ; } }
@ Override public byte [ ] first Token ( ) { return one Token ; }
public static String strip Comments ( String src , String string Opens , String string Closes , boolean slash Star Comments , boolean slash Slash Comments , boolean hash Comments , boolean dash Dash Comments ) { if ( src == null ) { return null ; } String Builder str Builder = new String Builder ( src . length ( ) ) ; String Reader source Reader = new String Reader ( src ) ; int context Marker = Character . MIN VALUE ; boolean escaped = false ; int marker Type Found = - NUM_ ; int ind = NUM_ ; int current Char = NUM_ ; try { while ( ( current Char = source Reader . read ( ) ) != - NUM_ ) { if ( marker Type Found != - NUM_ && current Char == string Closes . char At ( marker Type Found ) && ! escaped ) { context Marker = Character . MIN VALUE ; marker Type Found = - NUM_ ; } else if ( ( ind = string Opens . index Of ( current Char ) ) != - NUM_ && ! escaped && context Marker == Character . MIN VALUE ) { marker Type Found = ind ; context Marker = current Char ; } if ( context Marker == Character . MIN VALUE && current Char == STR_ && ( slash Slash Comments || slash Star Comments ) ) { current Char = source Reader . read ( ) ; if ( current Char == STR_ && slash Star Comments ) { int prev Char = NUM_ ; while ( ( current Char = source Reader . read ( ) ) != STR_ || prev Char != STR_ ) { if ( current Char == STR_ ) { current Char = source Reader . read ( ) ; if ( current Char == STR_ ) { current Char = source Reader . read ( ) ; } } else { if ( current Char == STR_ ) { current Char = source Reader . read ( ) ; } } if ( current Char < NUM_ ) { break ; } prev Char = current Char ; } continue ; } else if ( current Char == STR_ && slash Slash Comments ) { while ( ( current Char = source Reader . read ( ) ) != STR_ && current Char != STR_ && current Char >= NUM_ ) { } } } else if ( context Marker == Character . MIN VALUE && current Char == STR_ && hash Comments ) { while ( ( current Char = source Reader . read ( ) ) != STR_ && current Char != STR_ && current Char >= NUM_ ) { } } else if ( context Marker == Character . MIN VALUE && current Char == STR_ && dash Dash Comments ) { current Char = source Reader . read ( ) ; if ( current Char == - NUM_ || current Char != STR_ ) { str Builder . append ( STR_ ) ; if ( current Char != - NUM_ ) { str Builder . append ( current Char ) ; } continue ; } while ( ( current Char = source Reader . read ( ) ) != STR_ && current Char != STR_ && current Char >= NUM_ ) { } } if ( current Char != - NUM_ ) { str Builder . append ( ( char ) current Char ) ; } } } catch ( IO Exception io Ex ) { } return str Builder . to String ( ) ; }
public static String random Regexpish String ( Random r , int max Length ) { final String Builder regexp = new String Builder ( max Length ) ; for ( int i = next Int ( r , NUM_ , max Length ) ; i > NUM_ ; i -- ) { if ( r . next Boolean ( ) ) { regexp . append ( ( char ) Random Numbers . random Int Between ( r , STR_ , STR_ ) ) ; } else { regexp . append ( Random Picks . random From ( r , ops ) ) ; } } return regexp . to String ( ) ; }
private boolean override Has Pending Data ( ) { boolean has Pending Passthrough Data = needs Passthrough Workarounds ( ) && ( audio Track . get Play State ( ) == android . media . Audio Track . PLAYSTATE PAUSED ) && ( audio Track . get Playback Head Position ( ) == NUM_ ) ; if ( has Pending Passthrough Data ) { return true ; } boolean has Pending Data Quirk = Amazon Quirks . is Latency Quirk Enabled ( ) && ( audio Track . get Play State ( ) == android . media . Audio Track . PLAYSTATE PLAYING ) && ( ( ( System . nano Time ( ) / NUM_ ) - resume System Time Us ) < C . MICROS PER SECOND ) ; return has Pending Data Quirk ; }
public static boolean is Url Valid ( String value ) { return value == null || value . length ( ) < NUM_ * NUM_ ; }
public int size ( ) { return world Maps == null ? NUM_ : world Maps . size ( ) ; }
public String to URI ( ) { final String Buffer buffer = new String Buffer ( NUM_ ) ; buffer . append ( protocol . get Scheme ( ) ) ; buffer . append ( STR_ ) ; buffer . append ( hostname ) ; if ( port != protocol . get Default Port ( ) ) { buffer . append ( STR_ ) ; buffer . append ( port ) ; } return buffer . to String ( ) ; }
public float distance To Center ( float x , float y ) { Point F c = get Center ( ) ; float dist = NUM_ ; float x Dist = NUM_ ; float y Dist = NUM_ ; if ( x > c . x ) { x Dist = x - c . x ; } else { x Dist = c . x - x ; } if ( y > c . y ) { y Dist = y - c . y ; } else { y Dist = c . y - y ; } dist = ( float ) Math . sqrt ( Math . pow ( x Dist , NUM_ ) + Math . pow ( y Dist , NUM_ ) ) ; return dist ; }
@ Suppress Warnings ( STR_ ) public static Map create Map ( Object ... args ) { Map result = new Linked Hash Map ( ) ; if ( args == null || args . length == NUM_ ) return result ; for ( int i = NUM_ ; i < args . length - NUM_ ; i += NUM_ ) result . put ( args [ i ] , args [ i + NUM_ ] ) ; return result ; }
static boolean view Matches Selector ( View view , List < Integer > filtering Scope ) { if ( filtering Scope . is Empty ( ) ) { return true ; } if ( filtering Scope . size ( ) == NUM_ ) { return view . get Id ( ) == filtering Scope . get ( NUM_ ) ; } List < Integer > new Scope = new Array List < > ( filtering Scope ) ; new Scope . remove ( new Scope . get ( new Scope . size ( ) - NUM_ ) ) ; return view . get Parent ( ) != null && view Matches Selector ( ( View ) view . get Parent ( ) , new Scope ) ; }
public static Enum cast To Enum ( Object object , Class < ? extends Enum > type ) { if ( object == null ) return null ; if ( type . is Instance ( object ) ) return ( Enum ) object ; if ( object instanceof String || object instanceof G String ) { return Enum . value Of ( type , object . to String ( ) ) ; } throw new Groovy Cast Exception ( object , type ) ; }
public String scheme ( ) { return is Secure ( ) ? STR_ : STR_ ; }
public String num Attributes Tip Text ( ) { return STR_ ; }
public Iterable < Function Import > build ( Factory Lookup lookup ) { List < Function Import > builder = new Array List < > ( ) ; for ( Function Import Impl . Builder function Import Builder : function Import Builders ) { Entity Set entity Set = lookup . get Entity Set ( function Import Builder . get Entity Set Name ( ) ) ; Function function = lookup . get Function ( function Import Builder . get Function Name ( ) ) ; if ( entity Set == null && function . is Bound ( ) ) { throw new Illegal Argument Exception ( STR_ + function Import Builder . get Entity Set Name ( ) ) ; } function Import Builder . set Entity Set ( entity Set ) ; function Import Builder . set Function ( function ) ; builder . add ( function Import Builder . build ( ) ) ; } return Collections . unmodifiable List ( builder ) ; }
protected Point 2 D calculate Label Location ( Rectangle 2 D label Bounds , double ascent , Rectangle 2 D plot Area , double start Angle ) { Arc 2 D arc 1 = new Arc 2 D . Double ( plot Area , start Angle , NUM_ , Arc 2 D . OPEN ) ; Point 2 D point 1 = arc 1 . get End Point ( ) ; double delta X = - ( point 1 . get X ( ) - plot Area . get Center X ( ) ) * this . axis Label Gap ; double delta Y = - ( point 1 . get Y ( ) - plot Area . get Center Y ( ) ) * this . axis Label Gap ; double label X = point 1 . get X ( ) - delta X ; double label Y = point 1 . get Y ( ) - delta Y ; if ( label X < plot Area . get Center X ( ) ) { label X -= label Bounds . get Width ( ) ; } if ( label X == plot Area . get Center X ( ) ) { label X -= label Bounds . get Width ( ) / NUM_ ; } if ( label Y > plot Area . get Center Y ( ) ) { label Y += ascent ; } return new Point 2 D . Double ( label X , label Y ) ; }
@ Override public String model Name ( ) { return STR_ ; }
public Object rotate ( Object image , int degrees ) { int width = get Image Width ( image ) ; int height = get Image Height ( image ) ; int [ ] arr = new int [ width * height ] ; int [ ] dest = new int [ arr . length ] ; get RGB ( image , arr , NUM_ , NUM_ , NUM_ , width , height ) ; int center X = width / NUM_ ; int center Y = height / NUM_ ; double radians = Math . to Radians ( - degrees ) ; double cos Deg = Math . cos ( radians ) ; double sin Deg = Math . sin ( radians ) ; for ( int x = NUM_ ; x < width ; x ++ ) { for ( int y = NUM_ ; y < height ; y ++ ) { int x 2 = round ( cos Deg * ( x - center X ) - sin Deg * ( y - center Y ) + center X ) ; int y 2 = round ( sin Deg * ( x - center X ) + cos Deg * ( y - center Y ) + center Y ) ; if ( ! ( x 2 < NUM_ || y 2 < NUM_ || x 2 >= width || y 2 >= height ) ) { int dest Offset = x 2 + y 2 * width ; if ( dest Offset >= NUM_ && dest Offset < dest . length ) { dest [ x + y * width ] = arr [ dest Offset ] ; } } } } return create Image ( dest , width , height ) ; }
public Set entry Set ( ) { Set entries = super . entry Set ( ) ; Hash Set set = new Hash Set ( ) ; Iterator iter = entries . iterator ( ) ; while ( iter . has Next ( ) ) { Map . Entry entry = ( Map . Entry ) iter . next ( ) ; set . add ( new Entry ( entry ) ) ; } return set ; }
private static int annotated Fields Number ( Class < ? > a Class ) { int count = NUM_ ; for ( Field it : a Class . get Declared Fields ( ) ) if ( it . get Annotation ( J Map . class ) != null ) count ++ ; return count ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public Boolean Condition Builder must ( Condition Builder < ? , ? > ... builders ) { must . add All ( Arrays . as List ( builders ) ) ; return this ; }
static double area ( S 2 Point a , S 2 Point b , S 2 Point c ) { final double sa = b . angle ( c ) ; final double sb = c . angle ( a ) ; final double sc = a . angle ( b ) ; final double s = NUM_ * ( sa + sb + sc ) ; if ( s >= NUM_ ) { double s 2 = s * s ; double dmin = s - Math . max ( sa , Math . max ( sb , sc ) ) ; if ( dmin < NUM_ * s * s 2 * s 2 ) { double area = girard Area ( a , b , c ) ; if ( dmin < s * ( NUM_ * area ) ) { return area ; } } } return NUM_ * Math . atan ( Math . sqrt ( Math . max ( NUM_ , Math . tan ( NUM_ * s ) * Math . tan ( NUM_ * ( s - sa ) ) * Math . tan ( NUM_ * ( s - sb ) ) * Math . tan ( NUM_ * ( s - sc ) ) ) ) ) ; }
public int index Of ( final Artist a ) { synchronized ( m Artists ) { return m Artists . index Of ( a ) ; } }
public Accessibility Event dequeue ( ) { if ( m Event Queue . is Empty ( ) ) { return null ; } final Accessibility Event event = m Event Queue . remove ( NUM_ ) ; if ( event != null && Accessibility Event Utils . event Matches Any Type ( event , MASK LIMITED EVENT TYPES ) ) { final int event Type = event . get Event Type ( ) ; final int event Count Of Type = m Qualifying Events . get ( event Type , NUM_ ) ; m Qualifying Events . put ( event Type , ( event Count Of Type - NUM_ ) ) ; } return event ; }
public String evaluation Metric Tip Text ( ) { return STR_ ; }
public boolean contains ( Mention mention ) { return mentions . contains ( mention ) ; }
final boolean claim ( ) { Executor e = executor ; if ( compare And Set Fork Join Task Tag ( ( short ) NUM_ , ( short ) NUM_ ) ) { if ( e == null ) return true ; executor = null ; e . execute ( this ) ; } return false ; }
@ Override public boolean equals ( Object other ) { if ( ! ( other instanceof Matrix ) ) { return false ; } for ( int r = NUM_ ; r < rows ; r ++ ) { if ( ! Arrays . equals ( data [ r ] , ( ( Matrix ) other ) . data [ r ] ) ) { return false ; } } return true ; }
static Node Text Rep append To Node Text ( Node Text Rep node Rep , String str ) { Node Text Rep result = node Rep . clone ( ) ; result . node Text [ result . node Text . length - NUM_ ] = result . node Text [ result . node Text . length - NUM_ ] + str ; return result ; }
public static String flag Names ( long flags ) { String Builder sbuf = new String Builder ( ) ; int i = NUM_ ; long f = flags & Standard Flags ; while ( f != NUM_ ) { if ( ( f & NUM_ ) != NUM_ ) { sbuf . append ( STR_ ) ; sbuf . append ( flag Name [ i ] ) ; } f = f > > NUM_ ; i ++ ; } return sbuf . to String ( ) ; }
protected void error ( String message , int position , String context ) { throw new Illegal Argument Exception ( STR_ + position + STR_ + message + STR_ + context . substring ( NUM_ , position ) + STR_ + context . substring ( position ) ) ; }
private boolean is Number And Punctuation ( String string ) { int length = string . length ( ) ; for ( int i = NUM_ ; i < length ; ++ i ) { char c = string . char At ( i ) ; if ( ! ( Character . is Digit ( c ) || Characters . is Punctuation ( c ) ) ) { return false ; } } return true ; }
public synchronized byte [ ] generate Log Entry MAC ( String Log Entry ) throws Exception { byte [ ] key = null ; last Mac = current MAC ; key = read From Secret Store ( log File Name , current Key , logger Pass ) ; if ( ( current Logger Key != null ) && ( equal Byte Arrays ( current Logger Key , key ) == false ) ) { throw new Exception ( STR_ + STR_ ) ; } current Logger Key = key ; current MAC = get Digest ( Log Entry , current Logger Key ) ; Message Digest md = Message Digest . get Instance ( STR_ ) ; md . update ( current Logger Key ) ; current Logger Key = md . digest ( ) ; write To Secret Store ( current Logger Key , log File Name , logger Pass , current Key ) ; return current MAC ; }
protected String add Slash ( String string ) { return String . format ( STR_ , string ) ; }
public boolean is Visible By Registered Users ( ) { List < Permission Rule > access = relevant . get Permission ( Permission . READ ) ; List < Permission Rule > overridden = relevant . get Overridden ( Permission . READ ) ; Set < Project Ref > allows = new Hash Set < > ( ) ; Set < Project Ref > blocks = new Hash Set < > ( ) ; for ( Permission Rule rule : access ) { if ( rule . is Block ( ) ) { blocks . add ( relevant . get Rule Props ( rule ) ) ; } else if ( System Group Backend . is Anonymous Or Registered ( rule . get Group ( ) ) ) { allows . add ( relevant . get Rule Props ( rule ) ) ; } } for ( Permission Rule rule : overridden ) { if ( System Group Backend . is Anonymous Or Registered ( rule . get Group ( ) ) ) { blocks . remove ( relevant . get Rule Props ( rule ) ) ; } } blocks . remove All ( allows ) ; return blocks . is Empty ( ) && ! allows . is Empty ( ) ; }
public boolean is Valid ( ) { return ( Math . abs ( lat . lo ( ) ) <= S 2 . M PI 2 && Math . abs ( lat . hi ( ) ) <= S 2 . M PI 2 && lng . is Valid ( ) && lat . is Empty ( ) == lng . is Empty ( ) ) ; }
public Template find Template ( String name ) { return find Template ( name , null ) ; }
public void wait For ( int state ) throws IO Exception , Interrupted Exception { while ( ! file . exists ( ) || ( get ( ) != state ) ) { Thread . sleep ( poll Rate ) ; } }
@ Override public String graph ( ) throws Exception { String Buffer text = new String Buffer ( ) ; text . append ( STR_ ) ; if ( m is Leaf ) { text . append ( STR_ + m id + STR_ + STR_ + STR_ + STR_ ) ; if ( m train != null && m train . num Instances ( ) > NUM_ ) { text . append ( STR_ + m train + STR_ ) ; text . append ( STR_ ) ; } text . append ( STR_ ) ; } else { text . append ( STR_ + m id + STR_ + Utils . back Quote Chars ( m local Model . left Side ( m train ) ) + STR_ ) ; if ( m train != null && m train . num Instances ( ) > NUM_ ) { text . append ( STR_ + m train + STR_ ) ; text . append ( STR_ ) ; } text . append ( STR_ ) ; graph Tree ( text ) ; } return text . to String ( ) + STR_ ; }
private Object create Sip Factory ( String object Class Name ) throws Peer Unavailable Exception { if ( object Class Name == null ) { throw new Null Pointer Exception ( ) ; } try { Class peer Object Class = Class . for Name ( get Path Name ( ) + STR_ + object Class Name ) ; Object new Peer Object = peer Object Class . new Instance ( ) ; return ( new Peer Object ) ; } catch ( Exception e ) { String errmsg = STR_ + get Path Name ( ) + STR_ + object Class Name + STR_ ; throw new Peer Unavailable Exception ( errmsg , e ) ; } }
public Iterator < F > filter Iterator ( ) { return new Iterator Wrapper ( m Filters . iterator ( ) ) ; }
@ Override public byte [ ] to Byte Array ( ) { byte [ ] p = priv . to Byte Array ( ) ; if ( p . length != NUM_ ) { byte [ ] tmp = new byte [ NUM_ ] ; System . arraycopy ( p , Math . max ( NUM_ , p . length - NUM_ ) , tmp , Math . max ( NUM_ , NUM_ - p . length ) , Math . min ( NUM_ , p . length ) ) ; p = tmp ; } return p ; }
public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public boolean is Jumping ( ) { if ( steps . size ( ) > NUM_ ) { boolean jump = false ; for ( Move Step step : steps ) { if ( step . get Type ( ) == Move Path . Move Step Type . START JUMP ) { jump = true ; } } return jump ; } return false ; }
private boolean is Authorized ( Application User application User , String namespace , Namespace Permission Enum ... permissions ) { if ( application User != null && application User . get Namespace Authorizations ( ) != null ) { for ( Namespace Authorization current User Authorization : application User . get Namespace Authorizations ( ) ) { List < Namespace Permission Enum > current User Namespace Permissions = current User Authorization . get Namespace Permissions ( ) ; if ( current User Namespace Permissions == null ) { current User Namespace Permissions = Collections . empty List ( ) ; } if ( String Utils . equals Ignore Case ( current User Authorization . get Namespace ( ) , namespace ) && current User Namespace Permissions . contains All ( Arrays . as List ( permissions ) ) ) { return true ; } } } return false ; }
public static String return Id ( Set servers , String server ) { String server Id = null ; Iterator iter = servers . iterator ( ) ; while ( iter . has Next ( ) ) { String server Entry = ( String ) iter . next ( ) ; if ( ! server Entry . starts With ( server ) ) { continue ; } int index = server Entry . index Of ( delimiter ) ; if ( index != - NUM_ ) { server Id = server Entry . substring ( index + NUM_ , server Entry . length ( ) ) ; return server Id ; } } return server Id ; }
protected boolean use NIO ( ) { return this . use NIO ; }
static boolean contains ( Object [ ] arr , int i , Object obj ) { while ( -- i >= NUM_ ) { if ( obj . equals ( arr [ i ] ) ) { return true ; } } return false ; }
private Iterator < Object To Fragment > new Value Iterator ( E Structural Feature feature ) { if ( feature . is Many ( ) ) { result . append ( STR_ ) ; return new Many Value Iterator ( ( List < ? > ) current . e Get ( feature ) ) ; } else { return new Single Value Iterator ( ( E Object ) current . e Get ( feature ) ) ; } }
Date delayed Date ( long delay Millis ) { return new Date ( System . current Time Millis ( ) + delay Millis + NUM_ ) ; }
public Class < ? > load Class ( String class Name ) throws Exception { Loaded Class loaded Class = null ; synchronized ( loaded Classes ) { loaded Class = loaded Classes . get ( class Name ) ; } if ( loaded Class == null ) { String resource = class Name . replace ( STR_ , STR_ ) + STR_ ; Source Dir src = locate Resource ( resource ) ; if ( src == null ) { throw new Class Not Found Exception ( STR_ + class Name ) ; } synchronized ( this ) { loaded Class = new Loaded Class ( class Name , src ) ; synchronized ( loaded Classes ) { loaded Classes . put ( class Name , loaded Class ) ; } } return loaded Class . clazz ; } if ( loaded Class . is Changed ( ) ) { unload ( loaded Class . src Dir ) ; return load Class ( class Name ) ; } return loaded Class . clazz ; }
protected final void ensure Open ( ) throws Already Closed Exception { if ( ref Count . get ( ) <= NUM_ ) { throw new Already Closed Exception ( STR_ ) ; } if ( closed By Child ) { throw new Already Closed Exception ( STR_ ) ; } }
public static String md 5 Hash ( String string ) throws No Such Algorithm Exception { return md 5 Hash ( string . get Bytes ( Standard Charsets . UTF 8 ) ) ; }
public static Long translate Size To Bytes ( Long size , String unit ) { long multiplier = NUM_ ; String size Substr ; if ( unit . equals ( SIZE TB ) ) { multiplier = NUM_ * NUM_ * NUM_ * NUM_ ; } else if ( unit . equals ( SIZE GB ) ) { multiplier = NUM_ * NUM_ * NUM_ ; } else if ( unit . equals ( SIZE MB ) ) { multiplier = NUM_ * NUM_ ; } else if ( unit . equals ( SIZE KB ) ) { multiplier = NUM_ ; } return size * multiplier ; }
public static Throwable should Fail ( Class clazz , String script ) { Throwable th = null ; try { Groovy Shell shell = new Groovy Shell ( ) ; shell . evaluate ( script , generic Script Name ( ) ) ; } catch ( Groovy Runtime Exception gre ) { th = Script Bytecode Adapter . unwrap ( gre ) ; } catch ( Throwable e ) { th = e ; } if ( th == null ) { fail ( STR_ + clazz . get Name ( ) ) ; } else if ( ! clazz . is Instance ( th ) ) { fail ( STR_ + clazz . get Name ( ) + STR_ + th ) ; } return th ; }
@ Override @ Side Effect Free public Immutable Collection < V > values ( ) { Immutable Collection < V > result = values ; return ( result == null ) ? ( values = new Values < V > ( this ) ) : result ; }
public final double sample Max ( ) { synchronized ( lock ) { long max = max . get And Set ( NUM_ ) ; return scale * max ; } }
protected static int find Next New Line Char Compat ( Char Sequence s , int start ) { int position = find Next New Line Char ( s , start ) ; if ( position == - NUM_ ) { return s . length ( ) ; } return position ; }
private String participants To String ( ) { String Builder sb = new String Builder ( ) ; for ( String participant By Url : participants By Url . key Set ( ) ) { Session Participant sp = participants By Url . get ( participant By Url ) ; if ( sb . length ( ) > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( sp . to String ( ) ) ; } return sb . to String ( ) ; }
public static Set < String > subparts ( String word , int n Min , int n Max ) { Set < String > subparts = new Hash Set < String > ( ) ; for ( int n = n Min ; n <= n Max ; n ++ ) { for ( int i = NUM_ ; i < word . length ( ) ; i ++ ) { String Builder builder = new String Builder ( ) ; String w = word . substring ( i , Math . min ( i + n , word . length ( ) ) ) ; for ( char c : w . to Char Array ( ) ) { builder . append ( escape ( c ) ) ; } subparts . add ( builder . to String ( ) ) ; } } return subparts ; }
public static double calculate Column Total ( Values 2 D data , int column ) { Param Checks . null Not Permitted ( data , STR_ ) ; double total = NUM_ ; int row Count = data . get Row Count ( ) ; for ( int r = NUM_ ; r < row Count ; r ++ ) { Number n = data . get Value ( r , column ) ; if ( n != null ) { total += n . double Value ( ) ; } } return total ; }
public boolean is Instance Of ( Object Name name , String class Name ) throws Instance Not Found Exception { return mbs Interceptor . is Instance Of ( clone Object Name ( name ) , class Name ) ; }
public boolean is Cache External DB ( ) { return is Cache External DB ; }
public static long scalar Product ( final long [ ] bits , final long [ ] values ) { long sum = NUM_ ; for ( int i = bits . length ; i -- != NUM_ ; ) { final int offset = i * NUM_ ; long word = bits [ i ] ; while ( word != NUM_ ) { final int lsb = Long . number Of Trailing Zeros ( word ) ; sum ^= values [ offset + lsb ] ; word &= word - NUM_ ; } } return sum ; }
private void basic Invalidate ( final Entry Event Impl event , boolean invoke Callbacks ) throws Entry Not Found Exception { basic Invalidate ( event , invoke Callbacks , false ) ; }
private double evaluate Predictions ( Example Set example Set ) { Iterator < Example > reader = example Set . iterator ( ) ; int count = NUM_ ; int correct = NUM_ ; while ( reader . has Next ( ) ) { count ++ ; Example example = reader . next ( ) ; if ( example . get Label ( ) == example . get Predicted Label ( ) ) { correct ++ ; } } return ( double ) correct / count ; }
public boolean is Abstract ( ) { return Modifier . is Abstract ( raw Class . get Modifiers ( ) ) ; }
public static String [ ] string Array From String ( String string ) { return string Array From String ( string , STR_ ) ; }
@ Override public int hash Code ( ) { int hash ; if ( normalized . length ( ) > NUM_ ) { hash = normalized . hash Code ( ) ; } else { hash = original . hash Code ( ) ; } if ( matcher != null ) { hash ^= matcher . hash Code ( ) ; } return hash ; }
@ Override public boolean accept ( final File file ) { if ( file != null ) { if ( file . is Directory ( ) ) { return true ; } final String extension = get Extension ( file ) ; if ( extension != null && filters . contains Key ( extension ) ) { return true ; } } return false ; }
public static String mk Sd Card Cmd Name ( ) { String os = System . get Property ( STR_ ) ; String cmd = STR_ ; if ( os . starts With ( STR_ ) ) { cmd += STR_ ; } return cmd ; }
public static Map < String , Set < String > > parse ( Command Manager mgr , List list Attribute Values ) throws CLI Exception { Map < String , Set < String > > attr Values = new Hash Map < > ( ) ; if ( ( list Attribute Values != null ) && ! list Attribute Values . is Empty ( ) ) { for ( Iterator i = list Attribute Values . iterator ( ) ; i . has Next ( ) ; ) { String s = ( String ) i . next ( ) ; boolean retry = true ; int idx = NUM_ ; while ( retry ) { idx = s . index Of ( STR_ , idx + NUM_ ) ; if ( idx == - NUM_ ) { throw create Incorrect Format Exception ( mgr , s ) ; } retry = ( s . char At ( idx - NUM_ ) == STR_ ) ; } String attr Name = s . substring ( NUM_ , idx ) ; String attr Value = s . substring ( idx + NUM_ ) ; if ( ! attr Name . starts With ( STR_ ) ) { attr Name = attr Name . trim ( ) ; attr Value = attr Value . trim ( ) ; attr Name = strip Escape Chars ( attr Name ) ; Set < String > set = attr Values . get ( attr Name ) ; if ( set == null ) { set = new Hash Set < > ( ) ; attr Values . put ( attr Name , set ) ; } set . add ( attr Value ) ; } } } return attr Values ; }
public static boolean cancel Potential Work ( Object data , Image View image View ) { final Bitmap Worker Task bitmap Worker Task = get Bitmap Worker Task ( image View ) ; if ( bitmap Worker Task != null ) { final Object bitmap Data = bitmap Worker Task . m Data ; if ( bitmap Data == null || ! bitmap Data . equals ( data ) ) { bitmap Worker Task . cancel ( true ) ; } else { return false ; } } return true ; }
public void do Mouse Clicked ( java . awt . event . Mouse Event e ) { if ( ! editor . get Flag ( Editor . OPTION CONTROLS , is Controlling ( ) ) ) { return ; } if ( e . is Meta Down ( ) || e . is Alt Down ( ) ) { return ; } if ( ( named Turnout West == null ) || ( named Turnout East == null ) ) { log . error ( STR_ ) ; return ; } switch ( turnout Type ) { case DOUBLESLIP : do Double Slip Mouse Click ( ) ; break ; case SINGLESLIP : do Single Slip Mouse Click ( ) ; break ; case THREEWAY : do 3 Way Mouse Click ( ) ; break ; case SCISSOR : do Scissor Mouse Click ( ) ; break ; default : log . error ( STR_ , turnout Type ) ; } }
private List < Statistics > remove Succeeded ( List < Statistics > statistics ) { List < Statistics > result = new Array List < > ( ) ; for ( Statistics statistic : statistics ) { if ( ! statistic . get Succeeded ( ) ) result . add ( statistic ) ; } return result ; }
boolean vsb Is Visible ( boolean hsb Visible ) { return ( items . size ( ) > items In Window ( hsb Visible ) ) ; }
public boolean contains One Var ( Set < String > vars ) { return ! Collections . disjoint ( map . key Set ( ) , vars ) ; }
public Object [ ] read Value ( Connection connection , Object [ ] keys ) { Prepared Statement statement = null ; try { if ( ( Execution Path Debug Log . is Debug Enabled ) && ( log . is Debug Enabled ( ) ) ) { log . debug ( STR_ + read SQL + STR_ + print ( keys ) + STR_ ) ; } statement = connection . prepare Statement ( read SQL ) ; for ( int i = NUM_ ; i < keys . length ; i ++ ) { statement . set Object ( i + NUM_ , keys [ i ] ) ; } Result Set rs = statement . execute Query ( ) ; if ( ! rs . next ( ) ) { return null ; } Object [ ] row = new Object [ value Field Names . length ] ; for ( int i = NUM_ ; i < value Field Names . length ; i ++ ) { row [ i ] = DB Util . get Value ( rs , i + NUM_ , value Types [ i ] ) ; } return row ; } catch ( SQL Exception ex ) { String message = STR_ + read SQL + STR_ + ex . get Message ( ) ; log . error ( message , ex ) ; store Exception Handler . handle ( message , ex ) ; throw new Store Exception DB Rel ( message , ex ) ; } finally { try { if ( statement != null ) statement . close ( ) ; } catch ( SQL Exception e ) { } } }
public boolean is Empty ( ) { return ( intervals . length == NUM_ ) ; }
public String pickup Car ( Car car , boolean is Manifest , boolean is Two Column Track ) { String Buffer buf = new String Buffer ( ) ; String [ ] format ; if ( is Manifest && ! is Two Column Track ) { format = Setup . get Pickup Manifest Message Format ( ) ; } else if ( ! is Manifest && ! is Two Column Track ) { format = Setup . get Pickup Switch List Message Format ( ) ; } else if ( is Manifest && is Two Column Track ) { format = Setup . get Pickup Two Column By Track Manifest Message Format ( ) ; } else { format = Setup . get Pickup Two Column By Track Switch List Message Format ( ) ; } for ( String attribute : format ) { String s = get Car Attribute ( car , attribute , PICKUP , ! LOCAL ) ; buf . append ( s ) ; } return buf . to String ( ) ; }
List < Bytes Ref > expand Terms If Rewrite ( Bytes Ref [ ] terms , Map < Bytes Ref , Spans > strict Phrases Term To Spans ) { if ( will Rewrite ( ) ) { Set < Bytes Ref > all Term Set = new Linked Hash Set < > ( terms . length + strict Phrases Term To Spans . size ( ) ) ; Collections . add All ( all Term Set , terms ) ; if ( all Term Set . add All ( strict Phrases Term To Spans . key Set ( ) ) ) { List < Bytes Ref > source Terms = Arrays . as List ( all Term Set . to Array ( new Bytes Ref [ all Term Set . size ( ) ] ) ) ; source Terms . sort ( Comparator . natural Order ( ) ) ; return source Terms ; } } return Arrays . as List ( terms ) ; }
private Work Queue find Non Empty Steal Queue ( ) { Work Queue [ ] ws ; int m ; int r = Thread Local Random . next Secondary Seed ( ) ; if ( ( ws = work Queues ) != null && ( m = ws . length - NUM_ ) >= NUM_ ) { for ( int origin = r & m , k = origin , old Sum = NUM_ , check Sum = NUM_ ; ; ) { Work Queue q ; int b ; if ( ( q = ws [ k ] ) != null ) { if ( ( b = q . base ) - q . top < NUM_ ) return q ; check Sum += b ; } if ( ( k = ( k + NUM_ ) & m ) == origin ) { if ( old Sum == ( old Sum = check Sum ) ) break ; check Sum = NUM_ ; } } } return null ; }
public static List < Emoji > data ( ) { return emoji Data ; }
public byte [ ] to Array ( ) { return ( Arrays . copy Of ( buffer , position ) ) ; }
protected boolean has Result ( Map < String , String > results , String result ) { if ( results != null ) { for ( String str : results . values ( ) ) { if ( str . starts With ( result ) ) { return true ; } } } return false ; }
public boolean is Sealed ( URL url ) { return url . equals ( seal Base ) ; }
protected boolean need To Reverse ( int x 1 , int y 1 , int x 2 , int y 2 ) { boolean reverse = false ; switch ( get Orientation ( ) & ~ FOLLOW POLY ) { case FORWARD : break ; case BACKWARD : reverse = true ; break ; case LEFT TO RIGHT : reverse = x 1 > x 2 ; break ; case RIGHT TO LEFT : reverse = x 1 < x 2 ; break ; case TOP TO BOTTOM : reverse = y 1 > y 2 ; break ; case BOTTOM TO TOP : reverse = y 1 < y 2 ; break ; case MOST READABLE : reverse = x 2 < x 1 || y 1 > y 2 ; break ; } return reverse ; }
private static byte [ ] add Head Byte ( byte [ ] array , byte b ) { byte [ ] ret = new byte [ array . length + NUM_ ] ; ret [ NUM_ ] = b ; System . arraycopy ( array , NUM_ , ret , NUM_ , array . length ) ; return ret ; }
public int next Int ( ) { int ret = counter . get And Increment ( ) ; set Last Int ( ret ) ; return ret ; }
private void using Or Else Throw ( ) throws Exception { Optional < Student > student Optional = null ; student Optional . or Else Throw ( null ) ; }
public final double sample Max ( ) { long count = acquire Count . get ( ) - release Count . get ( ) ; long max = max . get And Set ( count ) ; return max ; }
public boolean is Animation ( Object native Image ) { return false ; }
public Tag use ( String class Name , String tag Bundle Name , String tag Bundle Version , Identification id ) throws Page Exception { Queue < Tag > queue = get Queue ( to Id ( class Name , tag Bundle Name , tag Bundle Version ) ) ; Tag tag = queue . poll ( ) ; if ( tag != null ) return tag ; return load Tag ( class Name , tag Bundle Name , tag Bundle Version , id ) ; }
public Boolean can Execute ( String url ) { if ( url . starts With ( STR_ ) || url . starts With ( STR_ ) ) { return Boolean . TRUE ; } return null ; }
public boolean is Watched Script ( Script script ) { lock . lock ( ) ; try { return watched Scripts . contains ( script ) ; } finally { lock . unlock ( ) ; } }
public boolean is Approve Visible ( ) { return m Button Approve . is Visible ( ) ; }
public int next Seed ( ) { return Random Seed Table . get Seed At Row Column ( row ++ , column ) ; }
public boolean contains Value ( double value ) { boolean result = false ; switch ( m closure ) { case OPENCLOSED : if ( value > m left Margin && value <= m right Margin ) { result = true ; } break ; case OPENOPEN : if ( value > m left Margin && value < m right Margin ) { result = true ; } break ; case CLOSEDOPEN : if ( value >= m left Margin && value < m right Margin ) { result = true ; } break ; case CLOSEDCLOSED : if ( value >= m left Margin && value <= m right Margin ) { result = true ; } break ; default : result = false ; break ; } return result ; }
boolean is Host Name Argument ( final Argument a ) { return HOST LONG IDENTIFIERS . contains ( a . get Long Identifier ( ) ) ; }
public boolean at End ( ) { return buf == null && pos . get Index ( ) == text . length ( ) ; }
protected int next Int Slow ( ) { final double bound = Math . exp ( - mean ) ; int count = NUM_ ; double product ; for ( product = NUM_ ; product >= bound && product > NUM_ ; count ++ ) { product *= random Generator . raw ( ) ; } if ( product <= NUM_ && bound > NUM_ ) return ( int ) Math . round ( mean ) ; return count - NUM_ ; }
public static String short Signature ( String sig ) { sig = sig . substring ( NUM_ , sig . length ( ) - NUM_ ) ; return sig . replace All ( STR_ , STR_ ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public List < Node > generate ( int pop Size ) { List < Node > population = new Array List < > ( ) ; for ( int i = NUM_ ; i < pop Size ; ) { Node candidate = full ( NUM_ ) ; if ( candidate . is Valid ( ) ) { population . add ( candidate ) ; i ++ ; } } return population ; }
public int count ( ) { return class list . size ( ) ; }
@ Suppress Warnings ( { STR_ , STR_ } ) public Result page Result ( int start Count , int end Count , String step ) { List < String > fields = new Array List < String > ( ) ; List values = new Array List < String > ( ) ; fields . add ( RESULT FLAG ) ; values . add ( operation Completed Successfully ) ; fields . add ( QUERY PAGE START ) ; values . add ( start Count ) ; fields . add ( QUERY PAGE END ) ; values . add ( end Count ) ; if ( error String != null ) { fields . add ( STR_ ) ; values . add ( error String ) ; return create Banner Result ( fields , values , step ) ; } else { if ( info String != null ) { fields . add ( STR_ ) ; values . add ( info String ) ; } if ( select Result != null ) { try { Tabular Result Data table = Result Builder . create Tabular Result Data ( ) ; String [ ] headers = null ; Object [ ] [ ] rows = null ; int row Count = build Table ( table , start Count , end Count ) ; Gf Json Array array = table . get Headers ( ) ; headers = new String [ array . size ( ) ] ; rows = new Object [ row Count ] [ array . size ( ) ] ; for ( int i = NUM_ ; i < array . size ( ) ; i ++ ) { headers [ i ] = ( String ) array . get ( i ) ; List < String > list = table . retrieve All Values ( headers [ i ] ) ; for ( int j = NUM_ ; j < list . size ( ) ; j ++ ) { rows [ j ] [ i ] = list . get ( j ) ; } } fields . add ( NUM ROWS ) ; values . add ( ( select Result == null ) ? NUM_ : select Result . size ( ) ) ; if ( query Trace String != null ) { fields . add ( QUERY TRACE ) ; values . add ( query Trace String ) ; } return create Page Result ( fields , values , step , headers , rows ) ; } catch ( Gf Json Exception e ) { String [ ] headers = new String [ ] { STR_ } ; Object [ ] [ ] rows = { { e . get Message ( ) } } ; String fields Array [ ] = { QUERY PAGE START , QUERY PAGE END } ; Object values Array [ ] = { start Count , end Count } ; return create Page Result ( fields Array , values Array , step , headers , rows ) ; } } else return create Banner Result ( fields , values , step ) ; } }
public double max ( ) { if ( is Sparse ( ) && nnz ( ) < length ( ) ) { double max = NUM_ ; for ( Index Value iv : this ) max = Math . max ( max , iv . get Value ( ) ) ; return max ; } else { double max = get ( NUM_ ) ; for ( int i = NUM_ ; i < length ( ) ; i ++ ) max = Math . max ( max , get ( i ) ) ; return max ; } }
@ Override public int cipher Bits ( ) { if ( ! ( s instanceof SSL Socket ) ) return super . cipher Bits ( ) ; SSL Socket ssl Socket = ( SSL Socket ) s ; SSL Session ssl Session = ssl Socket . get Session ( ) ; if ( ssl Session != null ) return ssl Key Sizes . get ( ssl Session . get Cipher Suite ( ) ) ; else return NUM_ ; }
public int count ( ) { return incomplete list . size ( ) ; }
@ Override public boolean contains Value ( Object value ) { Hash Map Entry [ ] tab = table ; int len = tab . length ; if ( value == null ) { for ( int i = NUM_ ; i < len ; i ++ ) { for ( Hash Map Entry e = tab [ i ] ; e != null ; e = e . next ) { if ( e . value == null ) { return true ; } } } return entry For Null Key != null && entry For Null Key . value == null ; } for ( int i = NUM_ ; i < len ; i ++ ) { for ( Hash Map Entry e = tab [ i ] ; e != null ; e = e . next ) { if ( value . equals ( e . value ) ) { return true ; } } } return entry For Null Key != null && value . equals ( entry For Null Key . value ) ; }
public boolean supports Save As ( ) { return false ; }
@ Override public boolean can Undo ( ) { return ! m Undo List . is Empty ( ) ; }
public boolean has Local Filter Info ( ) { return this . local Filter Info != null ; }
private static int joint ( Collection < ? > c 1 , Collection < ? > c 2 ) { if ( c 1 . size ( ) < c 2 . size ( ) ) { return - NUM_ ; } else if ( c 2 . size ( ) < c 1 . size ( ) ) { return NUM_ ; } Collection < Object > c 3 = new Array List < Object > ( ) ; c 3 . add All ( c 1 ) ; c 3 . remove All ( c 2 ) ; if ( c 3 . size ( ) > NUM_ ) { return - NUM_ ; } c 3 . add All ( c 2 ) ; c 3 . remove All ( c 1 ) ; if ( c 3 . size ( ) > NUM_ ) { return NUM_ ; } return NUM_ ; }
void checkin Command ( Command command ) { pool . add ( command ) ; }
public MLT Result like ( List < Integer > doc Nums ) throws IO Exception { Map < String , Map < String , Flt > > field Term Freq = new Hash Map < String , Map < String , Flt > > ( ) ; Map < String , Map < String , Flt > > must Match Terms = new Hash Map < String , Map < String , Flt > > ( ) ; Map < String , Map < String , Flt > > must NOT Match Terms = new Hash Map < String , Map < String , Flt > > ( ) ; for ( Integer doc Num : new Hash Set < Integer > ( doc Nums ) ) { retrieve Terms ( doc Num , get Field Names ( ) , field Term Freq ) ; retrieve Terms ( doc Num , get Match Field Names ( ) , must Match Terms ) ; retrieve Terms ( doc Num , get Different Field Names ( ) , must NOT Match Terms ) ; } MLT Result mlt Result = build Query From Field Term Frequencies ( field Term Freq , false ) ; if ( must Match Terms . size ( ) > NUM_ ) { mlt Result . set Must Match Query ( build Must Match Query ( must Match Terms , true ) ) ; } if ( must NOT Match Terms . size ( ) > NUM_ ) { mlt Result . set Must NOT Match Query ( build Must Match Query ( must NOT Match Terms , false ) ) ; } return mlt Result ; }
public static boolean is Likely Channel ( String word ) { boolean result = false ; if ( word != null ) { Raptor String Tokenizer tok = new Raptor String Tokenizer ( word , CHANNEL STRIP CHARS , true ) ; if ( tok . has More Tokens ( ) ) { String current = tok . next Token ( ) ; try { int channel = Integer . parse Int ( current ) ; return channel >= NUM_ && channel <= NUM_ ; } catch ( Number Format Exception nfe ) { if ( tok . has More Tokens ( ) ) { try { current = tok . next Token ( ) ; int channel = Integer . parse Int ( current ) ; return channel >= NUM_ && channel <= NUM_ ; } catch ( Number Format Exception nfe 2 ) { if ( tok . has More Tokens ( ) ) { try { current = tok . next Token ( ) ; int channel = Integer . parse Int ( current ) ; return channel >= NUM_ && channel <= NUM_ ; } catch ( Number Format Exception nfe 3 ) { if ( tok . has More Tokens ( ) ) { try { current = tok . next Token ( ) ; int channel = Integer . parse Int ( current ) ; return channel >= NUM_ && channel <= NUM_ ; } catch ( Number Format Exception nfe 4 ) { } } } } } } } } } return result ; }
public int size ( ) { return work Queue . size ( ) ; }
Optional < String > hostname ( ) { return Optional . of Nullable ( hostname ) ; }
public Hash Map < String , String > current ( ) { return this . cr ; }
public static double log 2 ( double x ) { return Math . log ( x ) / LOG 2 ; }
@ Override public boolean event Generatable ( String event Name ) { if ( m listenee == null ) { return false ; } if ( ! event Name . equals ( STR_ ) && ! event Name . equals ( STR_ ) ) { return false ; } if ( m listenee instanceof Data Source ) { if ( m listenee instanceof Event Constraints ) { Event Constraints ec = ( Event Constraints ) m listenee ; return ec . event Generatable ( event Name ) ; } } if ( m listenee instanceof Training Set Producer ) { if ( m listenee instanceof Event Constraints ) { Event Constraints ec = ( Event Constraints ) m listenee ; if ( ! event Name . equals ( STR_ ) ) { return false ; } if ( ! ec . event Generatable ( STR_ ) ) { return false ; } } } if ( m listenee instanceof Test Set Producer ) { if ( m listenee instanceof Event Constraints ) { Event Constraints ec = ( Event Constraints ) m listenee ; if ( ! event Name . equals ( STR_ ) ) { return false ; } if ( ! ec . event Generatable ( STR_ ) ) { return false ; } } } return true ; }
public static float [ ] [ ] random Init ( int rows , int cols , Random random ) { float [ ] [ ] output = new float [ rows ] [ cols ] ; for ( int i = NUM_ ; i < rows ; ++ i ) { for ( int j = NUM_ ; j < cols ; ++ j ) { output [ i ] [ j ] = ( NUM_ * random . next Float ( ) ) - NUM_ ; } } return output ; }
public String attribute Case Fix ( String column Name ) { if ( m check For Upper Case Names ) { String ucname = column Name . to Upper Case ( ) ; if ( ucname . equals ( EXP TYPE COL . to Upper Case ( ) ) ) { return EXP TYPE COL ; } else if ( ucname . equals ( EXP SETUP COL . to Upper Case ( ) ) ) { return EXP SETUP COL ; } else if ( ucname . equals ( EXP RESULT COL . to Upper Case ( ) ) ) { return EXP RESULT COL ; } else { return column Name ; } } else if ( m check For Lower Case Names ) { String ucname = column Name . to Lower Case ( ) ; if ( ucname . equals ( EXP TYPE COL . to Lower Case ( ) ) ) { return EXP TYPE COL ; } else if ( ucname . equals ( EXP SETUP COL . to Lower Case ( ) ) ) { return EXP SETUP COL ; } else if ( ucname . equals ( EXP RESULT COL . to Lower Case ( ) ) ) { return EXP RESULT COL ; } else { return column Name ; } } else { return column Name ; } }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = enum To Vector ( super . list Options ( ) ) ; result . add Element ( new Option ( STR_ + STR_ + default Expression ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public static float [ ] find Range ( Function 1 D f , float [ ] minmax ) { if ( minmax == null ) minmax = new float [ NUM_ ] ; float min = NUM_ , max = NUM_ ; for ( float x = - NUM_ ; x < NUM_ ; x += NUM_ ) { float n = f . evaluate ( x ) ; min = Math . min ( min , n ) ; max = Math . max ( max , n ) ; } minmax [ NUM_ ] = min ; minmax [ NUM_ ] = max ; return minmax ; }
private Tree Map < Long , String > ordered Children ( Watcher watcher ) throws Keeper Exception , Interrupted Exception { Tree Map < Long , String > ordered Children = new Tree Map < > ( ) ; List < String > child Names = zookeeper . get Children ( dir , watcher , true ) ; for ( String child Name : child Names ) { try { if ( ! child Name . region Matches ( NUM_ , prefix , NUM_ , prefix . length ( ) ) ) { LOG . debug ( STR_ + child Name ) ; continue ; } String suffix = child Name . substring ( prefix . length ( ) ) ; Long child Id = new Long ( suffix ) ; ordered Children . put ( child Id , child Name ) ; } catch ( Number Format Exception e ) { LOG . warn ( STR_ + child Name + STR_ + e , e ) ; } } return ordered Children ; }
public static List < Block Node > filter Predecessors ( Block Node block ) { List < Block Node > predecessors = block . get Predecessors ( ) ; List < Block Node > list = new Array List < Block Node > ( predecessors . size ( ) ) ; for ( Block Node pred : predecessors ) { Ignore Edge Attr edge Attr = pred . get ( A Type . IGNORE EDGE ) ; if ( edge Attr == null ) { list . add ( pred ) ; } else if ( ! edge Attr . contains ( block ) ) { list . add ( pred ) ; } } return list ; }
public static Vector pad Right ( Collection strings ) { Vector v = new Vector ( ) ; int length = max Length ( strings ) ; for ( Iterator i = strings . iterator ( ) ; i . has Next ( ) ; ) { String string = ( String ) i . next ( ) ; v . add ( pad Right ( string , length ) ) ; } return v ; }
@ Nullable public EC Key find Oldest Key After ( long time Secs ) { lock . lock ( ) ; try { EC Key oldest = null ; for ( EC Key key : hash To Keys . values ( ) ) { final long key Time = key . get Creation Time Seconds ( ) ; if ( key Time > time Secs ) { if ( oldest == null || oldest . get Creation Time Seconds ( ) > key Time ) oldest = key ; } } return oldest ; } finally { lock . unlock ( ) ; } }
public boolean is Show Adjustor Functions ( ) { return m adjustor Function Checkbox . is Selected ( ) ; }
final private long physical Address ( final int addr , final boolean nocheck ) { final Lock lock = m allocation Read Lock ; lock . lock ( ) ; try { if ( addr >= NUM_ ) { return addr & NUM_ ; } else { final Fixed Allocator allocator = get Block ( addr ) ; final int offset = get Offset ( addr ) ; final long laddr = allocator . get Physical Address ( offset , nocheck ) ; return laddr ; } } finally { lock . unlock ( ) ; } }
@ Nullable public static Network Parameters from Pmt Protocol ID ( String pmt Protocol Id ) { if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID MAINNET ) ) { return Main Net Params . get ( ) ; } else if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID TESTNET ) ) { return Test Net 3 Params . get ( ) ; } else if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID UNIT TESTS ) ) { return Unit Test Params . get ( ) ; } else if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID REGTEST ) ) { return Reg Test Params . get ( ) ; } else if ( pmt Protocol Id . equals ( PAYMENT PROTOCOL ID ALPHANET ) ) { return Alpha Net Params . get ( ) ; } else { return null ; } }
protected int next Char ( ) throws IO Exception { f Read From Buffer = ( f Buffer . length ( ) > NUM_ ) ; if ( f Read From Buffer ) { char ch = f Buffer . char At ( f Index ++ ) ; if ( f Index >= f Buffer . length ( ) ) { f Buffer . set Length ( NUM_ ) ; f Index = NUM_ ; } return ch ; } int ch = f Char After White Space ; if ( ch == - NUM_ ) { ch = f Reader . read ( ) ; } if ( f Skip White Space && Character . is Whitespace ( ( char ) ch ) ) { do { ch = f Reader . read ( ) ; } while ( Character . is Whitespace ( ( char ) ch ) ) ; if ( ch != - NUM_ ) { f Char After White Space = ch ; return STR_ ; } } else { f Char After White Space = - NUM_ ; } return ch ; }
public static Settings Group Manager instance ( ) { return INSTANCE ; }
public boolean ignore User Profile ( ) { String profile = null ; try { profile = sso Token . get Property ( IS Auth Constants . USER PROFILE ) ; } catch ( SSO Exception e ) { debug . warning ( STR_ , e ) ; } return ( ( profile != null ) && profile . equals ( IS Auth Constants . IGNORE ) ) ; }
public static String ge Server Base URL ( Http Servlet Request request ) { String uri = request . get Request URI ( ) ; int index = uri . index Of ( STR_ , NUM_ ) ; if ( index != - NUM_ ) { uri = uri . substring ( NUM_ , index ) ; } return request . get Scheme ( ) + STR_ + request . get Server Name ( ) + STR_ + request . get Server Port ( ) + uri ; }
private boolean remove Mapping ( Object key , Object value ) { if ( key == null ) { Hash Map Entry < K , V > e = entry For Null Key ; if ( e == null || ! Objects . equals ( value , e . value ) ) { return false ; } entry For Null Key = null ; mod Count ++ ; size -- ; post Remove ( e ) ; return true ; } int hash = secondary Hash ( key ) ; Hash Map Entry < K , V > [ ] tab = table ; int index = hash & ( tab . length - NUM_ ) ; for ( Hash Map Entry < K , V > e = tab [ index ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( e . hash == hash && key . equals ( e . key ) ) { if ( ! Objects . equals ( value , e . value ) ) { return false ; } if ( prev == null ) { tab [ index ] = e . next ; } else { prev . next = e . next ; } mod Count ++ ; size -- ; post Remove ( e ) ; return true ; } } return false ; }
public boolean update Stats And Return Whether Allowed ( ) { long now = System Clock . elapsed Realtime ( ) ; long delta Ms = now - m Last Request Ms ; if ( delta Ms < m Delay Ms ) return false ; m Last Request Ms = now ; if ( delta Ms < NUM_ * m Delay Ms ) { m Delay Ms = Math . min ( MAX DELAY , m Delay Ms * NUM_ ) ; } else { m Delay Ms = MIN DELAY ; } return true ; }
public Dimension minimum Layout Size ( Container parent ) { Dimension rd , mbd ; Insets i = root Pane . get Insets ( ) ; Container content Pane = root Pane . get Content Pane ( ) ; J Menu Bar menu Bar = root Pane . get J Menu Bar ( ) ; if ( content Pane != null && content Pane . is Visible ( ) ) { rd = content Pane . get Minimum Size ( ) ; } else if ( content Pane != null ) { rd = new Dimension ( NUM_ , content Pane . get Preferred Size ( ) . height ) ; } else { rd = new Dimension ( NUM_ , NUM_ ) ; } if ( menu Bar != null && menu Bar . is Visible ( ) ) { mbd = menu Bar . get Minimum Size ( ) ; } else { mbd = new Dimension ( NUM_ , NUM_ ) ; } return new Dimension ( Math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
@ HLE Function ( nid = NUM_ , version = NUM_ ) public int sce Rtc Get Day Of Week ( int year , int month , int day ) { Calendar cal = Calendar . get Instance ( ) ; cal . set ( year , month - NUM_ , day ) ; int day Of Week Number = cal . get ( Calendar . DAY OF WEEK ) ; day Of Week Number = ( day Of Week Number - NUM_ + NUM_ ) % NUM_ ; if ( log . is Debug Enabled ( ) ) { log . debug ( String . format ( STR_ , day Of Week Number ) ) ; } return day Of Week Number ; }
private static void validate DH Public Key ( DH Public Key public Key ) throws Invalid Key Exception { DH Parameter Spec param Spec = public Key . get Params ( ) ; Big Integer p = param Spec . get P ( ) ; Big Integer g = param Spec . get G ( ) ; Big Integer y = public Key . get Y ( ) ; validate DH Public Key ( p , g , y ) ; }
public boolean is Tag Present ( int tag ) { return field Index . contains Key ( new Integer ( tag ) ) ; }
@ Override public Node next ( ) { Node cur = next ; next = next . get Next Sibling ( ) ; return cur ; }
public boolean is Static ( ) { return Modifier . is Static ( method . get Modifiers ( ) ) ; }
private void throw Username Password Style Exception ( final Throwable cause ) throws Invalid Option Value Exception { final char preferred Prefix = Options Map . get Preferred Option Prefix ( ) ; final String cause Message = ( cause != null ) ? cause . get Localized Message ( ) : STR_ ; final String message Format = Messages . get String ( STR_ ) ; final String message = Message Format . format ( message Format , cause Message , get Matched Alias ( ) , preferred Prefix ) ; throw new Invalid Option Value Exception ( message ) ; }
public String to XML String ( ) throws XACML Exception { return to XML String ( true , true ) ; }
public Enumeration < String > elements ( ) { Vector < String > list = new Vector < String > ( ) ; list . add All ( m Words ) ; Collections . sort ( list ) ; return list . elements ( ) ; }
public String do Consent To Intro ( Http Servlet Request request ) throws FS Post Login Exception { String meta Alias = request . get Parameter ( IFS Constants . META ALIAS ) ; String target URL = request . get Parameter ( IFS Constants . LRURL ) ; String cot Selected = request . get Parameter ( IFS Constants . COTKEY ) ; return do Consent To Intro ( meta Alias , target URL , cot Selected ) ; }
public double max ( ) { int size = values . size ( ) ; double max = - Double . MAX VALUE ; for ( int i = NUM_ ; i < size ; i ++ ) max = Math . max ( max , values . get ( i ) ) ; return max ; }
public static String do Ignore ( Throwable t , String m ) { if ( ignore Patterns == null || m == null ) return null ; if ( t != null && t instanceof Assertion Error ) return null ; for ( String regex : ignore Patterns ) { Pattern pattern = Pattern . compile ( regex ) ; Matcher matcher = pattern . matcher ( m ) ; if ( matcher . find ( ) ) return STR_ + regex ; } return null ; }
public boolean has Key ( EC Key key ) { lock . lock ( ) ; try { return keychain . contains ( key ) ; } finally { lock . unlock ( ) ; } }
public int size ( ) { return this . size ; }
@ Override public Insn to Rop Insn ( ) { throw new Illegal Argument Exception ( STR_ ) ; }
private Raw Byte Allocator find Raw Byte Allocator ( String key ) { Raw Byte Allocator alloc = raw Byte Allocator Cache . get ( key ) ; if ( alloc == null ) { throw new Runtime Exception ( STR_ + key ) ; } return alloc ; }
@ Override public int pending Count ( ) { return get Pending Count ( ) ; }
public int length ( ) { return str . length ( ) ; }
Big Integer copy ( ) { prepare Java Representation ( ) ; int [ ] copy Digits = new int [ number Length ] ; System . arraycopy ( digits , NUM_ , copy Digits , NUM_ , number Length ) ; return new Big Integer ( sign , number Length , copy Digits ) ; }
static private Service Template copy Service Template ( Service Template tmpl ) { Class [ ] service Types = null ; Entry [ ] attribute Set Templates = null ; if ( tmpl . service Types != null ) { int len = tmpl . service Types . length ; service Types = new Class [ len ] ; System . arraycopy ( tmpl . service Types , NUM_ , service Types , NUM_ , len ) ; } if ( tmpl . attribute Set Templates != null ) { int len = tmpl . attribute Set Templates . length ; attribute Set Templates = new Entry [ len ] ; System . arraycopy ( tmpl . attribute Set Templates , NUM_ , attribute Set Templates , NUM_ , len ) ; } return new Service Template ( tmpl . service ID , service Types , attribute Set Templates ) ; }
private int hash Code ( double key ) { long bits = Double . double To Long Bits ( key ) ; return ( int ) ( bits ^ ( bits > > NUM_ ) ) ; }
public final void parse Error ( String message ) throws IO Exception { final String m = STR_ + m Source Name + STR_ + m Input Reader . get Line Number ( ) + STR_ + message ; throw new IO Exception ( m ) ; }
static Protocol Version value Of ( String name ) { if ( name == null ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( FIPS && ( name . equals ( SSL 30 . name ) || name . equals ( SSL 20 Hello . name ) ) ) { throw new Illegal Argument Exception ( STR_ ) ; } if ( name . equals ( SSL 30 . name ) ) { return SSL 30 ; } else if ( name . equals ( TLS 10 . name ) ) { return TLS 10 ; } else if ( name . equals ( TLS 11 . name ) ) { return TLS 11 ; } else if ( name . equals ( TLS 12 . name ) ) { return TLS 12 ; } else if ( name . equals ( SSL 20 Hello . name ) ) { return SSL 20 Hello ; } else { throw new Illegal Argument Exception ( name ) ; } }
public static final String trim End ( String str ) { int position = str . length ( ) ; while ( ( position > NUM_ ) && Character . is Whitespace ( str . char At ( position - NUM_ ) ) ) { position -- ; } return str . substring ( NUM_ , position ) ; }
public static Number sin ( Number a ) { return Math . sin ( a . double Value ( ) ) ; }
public Properties read Backup Properties ( URI backup Loc , String backup Id ) throws IO Exception { Preconditions . check Not Null ( backup Loc ) ; Preconditions . check Not Null ( backup Id ) ; URI backup Path = repository . resolve ( backup Loc , backup Id ) ; if ( ! repository . exists ( backup Path ) ) { throw new Solr Exception ( Error Code . SERVER ERROR , STR_ + backup Path ) ; } Properties props = new Properties ( ) ; try ( Reader is = new Input Stream Reader ( new Properties Input Stream ( repository . open Input ( backup Path , BACKUP PROPS FILE , IO Context . DEFAULT ) ) , Standard Charsets . UTF 8 ) ) { props . load ( is ) ; return props ; } }
private boolean urls Match Loader Annotation ( URL [ ] urls , Class Loader loader ) { try { return Arrays . equals ( urls , get Loader Annotation UR Ls ( loader ) ) ; } catch ( Malformed URL Exception e ) { return false ; } }
@ Override public boolean equals ( Object obj ) { return obj != null && ( ( obj instanceof Proxy Invocation Handler && this == obj ) || ( Proxy . is Proxy Class ( obj . get Class ( ) ) && this == Proxy . get Invocation Handler ( obj ) ) ) ; }
@ Override public int hash Code ( ) { int result = NUM_ ; long temp = Double . double To Long Bits ( this . lower Bound ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . upper Bound ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . start Angle ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . extent ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = Double . double To Long Bits ( this . tick Radius ) ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; return result ; }
@ Exception Handler ( Object Not Found Exception . class ) @ Response Status ( value = Http Status . NOT FOUND ) public @ Response Body Error Response resolve Document Not Found Exception ( Object Not Found Exception e ) throws IO Exception { if ( logger . is Loggable ( Level . FINE ) ) logger . fine ( STR_ + e . get Message ( ) ) ; return new Error Response ( new Error Message ( e . get Message ( ) ) ) ; }
public Iterator < Detector Ordering Constraint > intra Pass Constraint Iterator ( ) { return intra Pass Constraint List . iterator ( ) ; }
public final double sample Count ( ) { long last Acquire Count = last Acquire Count ; last Acquire Count = acquire Count . get ( ) ; return last Acquire Count - last Acquire Count ; }
protected int level Offset ( Context context ) { int level Offset ; switch ( context . position ) { case DOCUMENT BEFORE : case DOCUMENT AFTER : level Offset = NUM_ ; break ; case DOCUMENT BEGIN : case DOCUMENT END : case OPERATION BEFORE : case OPERATION AFTER : level Offset = NUM_ ; break ; case OPERATION BEGIN : case OPERATION END : level Offset = increase Level Offset ( NUM_ ) ; break ; case OPERATION DESCRIPTION BEFORE : case OPERATION DESCRIPTION AFTER : case OPERATION PARAMETERS BEFORE : case OPERATION PARAMETERS AFTER : case OPERATION RESPONSES BEFORE : case OPERATION RESPONSES AFTER : case OPERATION SECURITY BEFORE : case OPERATION SECURITY AFTER : level Offset = increase Level Offset ( NUM_ ) ; break ; case OPERATION DESCRIPTION BEGIN : case OPERATION DESCRIPTION END : case OPERATION PARAMETERS BEGIN : case OPERATION PARAMETERS END : case OPERATION RESPONSES BEGIN : case OPERATION RESPONSES END : case OPERATION SECURITY BEGIN : case OPERATION SECURITY END : level Offset = NUM_ ; break ; default : throw new Runtime Exception ( String . format ( STR_ , context . position ) ) ; } return level Offset ; }
public String class Name Tip Text ( ) { return STR_ ; }
public void request Password Policy DN ( ) { operations . add ( Password Policy State Operation Type . GET PASSWORD POLICY DN ) ; }
public static String hex Str To Alpha Str ( String msg Str ) { String Buffer result = new String Buffer ( ) ; for ( int ofs = NUM_ ; ofs < msg Str . length ( ) ; ofs += NUM_ ) { result . append ( String . format ( STR_ , Integer . parse Int ( msg Str . substring ( ofs , ofs + NUM_ ) , NUM_ ) ) ) ; } return ( result . to String ( ) ) ; }
public Map < String , Plugin Descriptor > parse Plugin Folder ( String [ ] plugin Folders ) { Map < String , Plugin Descriptor > map = new Hash Map < String , Plugin Descriptor > ( ) ; if ( plugin Folders == null ) { throw new Illegal Argument Exception ( STR_ ) ; } for ( String name : plugin Folders ) { File directory = get Plugin Folder ( name ) ; if ( directory == null ) { continue ; } LOG . info ( STR_ + directory . get Absolute Path ( ) ) ; for ( File one Sub Folder : directory . list Files ( ) ) { if ( one Sub Folder . is Directory ( ) ) { String manifest Path = one Sub Folder . get Absolute Path ( ) + File . separator + STR_ ; try { LOG . debug ( STR_ + manifest Path ) ; Plugin Descriptor p = parse Manifest File ( manifest Path ) ; map . put ( p . get Plugin Id ( ) , p ) ; } catch ( Exception e ) { LOG . warn ( STR_ + manifest Path + STR_ + e . to String ( ) ) ; } } } } return map ; }
public static Cached Date Time Zone for Zone ( Date Time Zone zone ) { if ( zone instanceof Cached Date Time Zone ) { return ( Cached Date Time Zone ) zone ; } return new Cached Date Time Zone ( zone ) ; }
@ Override public int available ( ) throws IO Exception { return m Input Stream . available ( ) ; }
public Int Bidirectional Iterator iterator ( final int from ) { if ( this == EMPTY INTERVAL ) return Int Iterators . EMPTY ITERATOR ; final Int Bidirectional Iterator i = Int Iterators . from To ( left , right + NUM_ ) ; if ( from > left ) i . skip ( Math . min ( length ( ) , from - left ) ) ; return i ; }
public static < T > List < T > satisfy ( List < T > input , Function < ? super T , ? extends Ordering Constraints < T > > constraint Supplier ) { return satisfy ( input , Function . identity ( ) , constraint Supplier ) ; }
public static double chi Squared ( double [ ] [ ] matrix , boolean yates ) { int df = ( matrix . length - NUM_ ) * ( matrix [ NUM_ ] . length - NUM_ ) ; return Statistics . chi Squared Probability ( chi Val ( matrix , yates ) , df ) ; }
public String end Tbl Data Action Delete Href Display ( Child Content Display Event event ) { String lbl = ( String ) tbl Model . get Value ( TBL DATA ACTION DELETE LABEL ) ; return ( ( lbl != null ) && ( lbl . length ( ) > NUM_ ) ) ? event . get Content ( ) : STR_ ; }
private static Set < Branch > collect Uncovered Branches ( Set < Branch > covered Branches ) { Set < Branch > uncovered Branches = new Hash Set < Branch > ( ) ; for ( Branch b : covered Branches ) { final Branch negate = b . negate ( ) ; if ( ! covered Branches . contains ( negate ) ) { uncovered Branches . add ( negate ) ; } } return uncovered Branches ; }
double almost Equals ( Point 2 D p 1 , Point 2 D p 2 , double tol ) { double sep X = p 1 . get X ( ) - p 2 . get X ( ) ; double sep Y = p 1 . get Y ( ) - p 2 . get Y ( ) ; double sep = Math . sqrt ( sep X * sep X + sep Y * sep Y ) ; if ( sep <= tol ) return sep ; else return Double . MAX VALUE ; }
public static boolean is Rp Vplex Volume ( Un Managed Volume un Managed Volume ) { return is Vplex Volume ( un Managed Volume ) && check Un Managed Resource Is Recover Point Enabled ( un Managed Volume ) ; }
private boolean await Work ( Work Queue w , int r ) { if ( w == null || w . qlock < NUM_ ) return false ; for ( int pred = w . stack Pred , spins = SPINS , ss ; ; ) { if ( ( ss = w . scan State ) >= NUM_ ) break ; else if ( spins > NUM_ ) { r ^= r << NUM_ ; r ^= r > > > NUM_ ; r ^= r << NUM_ ; if ( r >= NUM_ && -- spins == NUM_ ) { Work Queue v ; Work Queue [ ] ws ; int s , j ; Atomic Long sc ; if ( pred != NUM_ && ( ws = work Queues ) != null && ( j = pred & SMASK ) < ws . length && ( v = ws [ j ] ) != null && ( v . parker == null || v . scan State >= NUM_ ) ) spins = SPINS ; } } else if ( w . qlock < NUM_ ) return false ; else if ( ! Thread . interrupted ( ) ) { long c , prevctl , park Time , deadline ; int ac = ( int ) ( ( c = ctl ) > > AC SHIFT ) + ( config & SMASK ) ; if ( ( ac <= NUM_ && try Terminate ( false , false ) ) || ( run State & STOP ) != NUM_ ) return false ; if ( ac <= NUM_ && ss == ( int ) c ) { prevctl = ( UC MASK & ( c + AC UNIT ) ) | ( SP MASK & pred ) ; int t = ( short ) ( c > > > TC SHIFT ) ; if ( t > NUM_ && U . compare And Swap Long ( this , CTL , c , prevctl ) ) return false ; park Time = IDLE TIMEOUT * ( ( t >= NUM_ ) ? NUM_ : NUM_ - t ) ; deadline = System . nano Time ( ) + park Time - TIMEOUT SLOP ; } else prevctl = park Time = deadline = NUM_ ; Thread wt = Thread . current Thread ( ) ; U . put Object ( wt , PARKBLOCKER , this ) ; w . parker = wt ; if ( w . scan State < NUM_ && ctl == c ) U . park ( false , park Time ) ; U . put Ordered Object ( w , QPARKER , null ) ; U . put Object ( wt , PARKBLOCKER , null ) ; if ( w . scan State >= NUM_ ) break ; if ( park Time != NUM_ && ctl == c && deadline - System . nano Time ( ) <= NUM_ && U . compare And Swap Long ( this , CTL , c , prevctl ) ) return false ; } } return true ; }
boolean threshold Exceeded ( final Set < I Binding Set > distinct Projection Buffer , final int distinct Projection Buffer Threshold , final List < I Binding Set > incoming Bindings Buffer , final int incoming Bindings Buffer Threshold ) { return distinct Projection Buffer . size ( ) >= distinct Projection Buffer Threshold || incoming Bindings Buffer . size ( ) >= incoming Bindings Buffer Threshold ; }
public Pla Segment Float segment projection ( Pla Segment Float p line segment ) { if ( point b . scalar product ( point a , p line segment . point a ) < NUM_ ) { return null ; } if ( point a . scalar product ( point b , p line segment . point b ) < NUM_ ) { return null ; } Pla Point Float projected a ; if ( point a . scalar product ( point b , p line segment . point a ) < NUM_ ) { projected a = point a ; } else { projected a = perpendicular projection ( p line segment . point a ) ; if ( projected a . is Na N ( ) ) return null ; if ( Math . abs ( projected a . v x ) >= Pla Limits . CRIT INT || Math . abs ( projected a . v y ) >= Pla Limits . CRIT INT ) return null ; } Pla Point Float projected b ; if ( point b . scalar product ( point a , p line segment . point b ) < NUM_ ) { projected b = point b ; } else { projected b = perpendicular projection ( p line segment . point b ) ; } if ( projected b . is Na N ( ) ) return null ; if ( Math . abs ( projected b . v x ) >= Pla Limits . CRIT INT || Math . abs ( projected b . v y ) >= Pla Limits . CRIT INT ) return null ; return new Pla Segment Float ( projected a , projected b ) ; }
private Script Engine new Script Engine ( String name ) throws Script Exception { Script Engine Manager manager = new Script Engine Manager ( ) ; Script Engine engine = manager . get Engine By Name ( name ) ; if ( engine == null ) { throw new Script Exception ( STR_ + name ) ; } return engine ; }
@ Override public < T > List < Binding < T > > bindings ( Key < T > key ) { Binding Set < T > set = ( Binding Set ) binding Set Map . get ( key . raw Class ( ) ) ; if ( set != null ) { return set . bindings ( key ) ; } else { return Collections . EMPTY LIST ; } }
public static int random Int ( int a , int b , boolean exclude Zero ) { double rand Val = rand . next Double ( ) * ( b - a ) ; int rand Num = a + ( int ) Math . round ( rand Val ) ; if ( a < NUM_ && b > NUM_ && exclude Zero ) { while ( rand Num == NUM_ ) { rand Num = ( ( int ) ( a + rand . next Double ( ) * ( b - a ) ) ) ; } } return rand Num ; }
public boolean has More Elements ( ) { prep ( ) ; return root Value != null || other Value != null || ( sub Map Values != null && sub Map Values . has More Elements ( ) ) ; }
private static String require Non Null ( String required , String message ) throws Configuration Runtime Exception { if ( required == null ) throw new Configuration Runtime Exception ( message ) ; return required ; }
public boolean is Overlay Visible ( ) { return overlay Visible ; }
public static String add Luhn Digit ( String number ) { char [ ] digits = { STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ } ; int c = number . length ( ) ; String Buffer try Number = new String Buffer ( number + digits [ NUM_ ] ) ; int i ; for ( i = NUM_ ; i < NUM_ ; i ++ ) { try Number . set Char At ( c , digits [ i ] ) ; if ( luhn Check ( try Number . to String ( ) ) ) break ; } return try Number . to String ( ) ; }
public boolean separates ( Bit Set H ) { return A . intersects ( H ) && B . intersects ( H ) ; }
public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; return new Vector . elements ( ) ; }
public static < S , K > Collector < S , ? , Linked Hash Map < K , S > > to Linked Dictionary ( Function < ? super S , ? extends K > key Mapper ) { return Collectors . to Map ( key Mapper , Function . identity ( ) , Stream Utils . throwing Merger ( ) , null ) ; }
public static < T , K , L extends List < T > > Bi Function < Partition < T , K , L > , T , Boolean > always Insert ( ) { return null ; }
@ Override public void write ( byte [ ] buffer , int offset , int length ) throws IO Exception { int to Send = length ; int sent ; long start = System . current Time Millis ( ) ; while ( to Send > NUM_ ) { synchronized ( pseudo Tcp ) { sent = pseudo Tcp . send ( buffer , offset + length - to Send , to Send ) ; } if ( sent > NUM_ ) { to Send -= sent ; } else { try { logger . log ( Level . FINER , STR_ ) ; synchronized ( write notify ) { if ( write Timeout > NUM_ ) { long elapsed = System . current Time Millis ( ) - start ; long left = write Timeout - elapsed ; if ( left <= NUM_ ) { IO Exception exc = new IO Exception ( STR_ ) ; pseudo Tcp . closedown ( exc ) ; throw exc ; } write notify . wait ( left ) ; } else { write notify . wait ( ) ; } } logger . log ( Level . FINER , STR_ + pseudo Tcp . get Available Send Buffer ( ) ) ; if ( exception != null ) { throw exception ; } } catch ( Interrupted Exception ex ) { if ( exception != null ) { throw new IO Exception ( STR_ , exception ) ; } else { throw new IO Exception ( STR_ , ex ) ; } } } } }
public static Double Vector pchisq ( double x , Double Vector ncp ) { int n = ncp . size ( ) ; Double Vector p = new Double Vector ( n ) ; double mean ; double xh = Math . sqrt ( x ) ; for ( int i = NUM_ ; i < n ; i ++ ) { mean = Math . sqrt ( ncp . get ( i ) ) ; p . set ( i , pnorm ( xh - mean ) - pnorm ( - xh - mean ) ) ; } return p ; }
public boolean contains ( Bound Entity ent ) { Search Entry compare = new Search Entry ( ent . get Ref ( ) , ent . get Provider ( ) ) ; if ( ent instanceof Song ) { return m All Songs . contains ( compare ) ; } else if ( ent instanceof Artist ) { return m All Artists . contains ( compare ) ; } else if ( ent instanceof Album ) { return m All Albums . contains ( compare ) ; } else if ( ent instanceof Playlist ) { return m All Playlists . contains ( compare ) ; } return false ; }
private boolean all Contents Unchanged ( ) { Map < Form Index , I Answer Data > answers = get Answers ( ) ; for ( Map . Entry < Form Index , I Answer Data > entry : answers . entry Set ( ) ) { if ( ! m Original Answer Data . contains Key ( entry . get Key ( ) ) ) { return false ; } String new Text = get Display Text ( entry . get Value ( ) ) ; String old Text = get Display Text ( m Original Answer Data . get ( entry . get Key ( ) ) ) ; if ( ! equal Or Both Null ( new Text , old Text ) ) { return false ; } } return true ; }
public static Throwable should Fail ( Class clazz , Closure code ) { Throwable th = null ; try { code . call ( ) ; } catch ( Groovy Runtime Exception gre ) { th = Script Bytecode Adapter . unwrap ( gre ) ; } catch ( Throwable e ) { th = e ; } if ( th == null ) { fail ( STR_ + code + STR_ + clazz . get Name ( ) ) ; } else if ( ! clazz . is Instance ( th ) ) { fail ( STR_ + code + STR_ + clazz . get Name ( ) + STR_ + th ) ; } return th ; }
public int size ( ) { return averages List . size ( ) ; }
private char [ ] inline Tag Completion ( char [ ] completion Name , char [ ] inline Tag ) { int tag Length = inline Tag . length ; int completion Length = completion Name . length ; int inline Length = NUM_ + tag Length + NUM_ + completion Length + NUM_ ; char [ ] inline Completion = new char [ inline Length ] ; inline Completion [ NUM_ ] = STR_ ; inline Completion [ NUM_ ] = STR_ ; System . arraycopy ( inline Tag , NUM_ , inline Completion , NUM_ , tag Length ) ; inline Completion [ tag Length + NUM_ ] = STR_ ; System . arraycopy ( completion Name , NUM_ , inline Completion , tag Length + NUM_ , completion Length ) ; inline Completion [ inline Length - NUM_ ] = STR_ ; return inline Completion ; }
public int find Index Of Value ( String value ) { final Char Sequence [ ] entry Values = get Entry Values ( ) ; if ( value != null && entry Values != null ) { for ( int i = entry Values . length - NUM_ ; i >= NUM_ ; -- i ) { if ( value . equals ( entry Values [ i ] ) ) { return i ; } } } return - NUM_ ; }
@ Override public Array List < String > list ( String path ) { Array List < String > file Name List = new Array List < String > ( ) ; Dropbox API . Entry files = null ; try { files = m DB Api . metadata ( path , NUM_ , null , true , null ) ; for ( Entry e : files . contents ) { file Name List . add ( e . file Name ( ) ) ; } } catch ( Dropbox Exception e ) { e . print Stack Trace ( ) ; } return file Name List ; }
public static Collection < File > collect Files ( final Collection < File > in , final File Filter filter ) { if ( in == null ) throw new Illegal Argument Exception ( ) ; if ( filter == null ) throw new Illegal Argument Exception ( ) ; final Collection < File > out = new Linked List < File > ( ) ; for ( File file : in ) { if ( file . is Directory ( ) ) { if ( log . is Info Enabled ( ) ) log . info ( STR_ + file ) ; final File [ ] files = file . list Files ( filter ) ; out . add All ( collect Files ( Arrays . as List ( files ) , filter ) ) ; } else { if ( filter . accept ( file ) ) { out . add ( file ) ; } } } return out ; }
public static String type To String ( Attribute att ) { return type To String ( att . type ( ) ) ; }
private static Buffered Image expand Gray Thumb ( Buffered Image thumb ) { Buffered Image ret = new Buffered Image ( thumb . get Width ( ) , thumb . get Height ( ) , Buffered Image . TYPE INT RGB ) ; Graphics g = ret . get Graphics ( ) ; g . draw Image ( thumb , NUM_ , NUM_ , null ) ; return ret ; }
private Chrono Local Date of Week Based Year ( Chronology chrono , int yowby , int wowby , int dow ) { Chrono Local Date date = chrono . date ( yowby , NUM_ , NUM_ ) ; int ldow = localized Day Of Week ( date ) ; int offset = start Of Week Offset ( NUM_ , ldow ) ; int year Len = date . length Of Year ( ) ; int new Year Week = compute Week ( offset , year Len + week Def . get Minimal Days In First Week ( ) ) ; wowby = Math . min ( wowby , new Year Week - NUM_ ) ; int days = - offset + ( dow - NUM_ ) + ( wowby - NUM_ ) * NUM_ ; return date . plus ( days , DAYS ) ; }
public static byte [ ] hex String To Byte ( String hex ) { byte [ ] bts = new byte [ hex . length ( ) / NUM_ ] ; for ( int i = NUM_ ; i < bts . length ; i ++ ) { bts [ i ] = ( byte ) Integer . parse Int ( hex . substring ( NUM_ * i , NUM_ * i + NUM_ ) , NUM_ ) ; } return bts ; }
public List < String > local Text ( ) { final List < String > result = new Array List < String > ( ) ; for ( Object child : this . children ) { if ( ! ( child instanceof Node ) ) { result . add ( child . to String ( ) ) ; } } return result ; }
public double next Double ( ) { return ( ( ( ( long ) next ( NUM_ ) << NUM_ ) + next ( NUM_ ) ) / ( double ) ( NUM_ << NUM_ ) ) ; }
@ Override public int read ( byte [ ] buffer , int offset , int length ) throws IO Exception { long start = System . current Time Millis ( ) ; int read ; while ( true ) { logger . log ( Level . FINER , STR_ ) ; try { read = pseudo Tcp . recv ( buffer , offset , length ) ; if ( logger . is Loggable ( Level . FINER ) ) { logger . log ( Level . FINER , STR_ + read ) ; } if ( read > NUM_ ) { return read ; } logger . log ( Level . FINER , STR_ ) ; if ( read Timeout > NUM_ ) { long elapsed = System . current Time Millis ( ) - start ; long left = read Timeout - elapsed ; if ( left <= NUM_ ) { IO Exception exc = new IO Exception ( STR_ ) ; pseudo Tcp . closedown ( exc ) ; throw exc ; } synchronized ( read notify ) { if ( pseudo Tcp . get Available ( ) == NUM_ ) { read notify . wait ( left ) ; } } } else { synchronized ( read notify ) { if ( pseudo Tcp . get Available ( ) == NUM_ ) { read notify . wait ( ) ; } } } if ( logger . is Loggable ( Level . FINER ) ) { logger . log ( Level . FINER , STR_ + pseudo Tcp . get Available ( ) ) ; } if ( exception != null ) { throw exception ; } } catch ( Interrupted Exception ex ) { if ( exception != null ) { throw new IO Exception ( STR_ , exception ) ; } else { throw new IO Exception ( STR_ ) ; } } } }
public String byte String No Semicolon ( ) { String Buffer retval = new String Buffer ( ) ; try { while ( true ) { char next = look Ahead ( NUM_ ) ; if ( next == STR_ || next == STR_ || next == STR_ || next == STR_ ) { break ; } else { consume ( NUM_ ) ; retval . append ( next ) ; } } } catch ( Parse Exception ex ) { return retval . to String ( ) ; } return retval . to String ( ) ; }
public void request Seconds Until Password Reset Lockout ( ) { operations . add ( Password Policy State Operation Type . GET SECONDS UNTIL PASSWORD RESET LOCKOUT ) ; }
public boolean is Unconditionally Dereferenced ( Value Number vn ) { return value Numbers Unconditionally Dereferenced . get ( vn . get Number ( ) ) ; }
public final boolean is Dead ( ) { return ! is Active ( ) ; }
private static synchronized boolean is Xrandr Extension Supported ( ) { if ( xrandr Ext Supported == null ) { xrandr Ext Supported = Boolean . value Of ( init Xrandr Extension ( ) ) ; } return xrandr Ext Supported . boolean Value ( ) ; }
public long time ( ) { return System . current Time Millis ( ) ; }
public String to String By Value ( ) { Double Array List the Keys = new Double Array List ( ) ; keys Sorted By Value ( the Keys ) ; String Buffer buf = new String Buffer ( ) ; buf . append ( STR_ ) ; int max Index = the Keys . size ( ) - NUM_ ; for ( int i = NUM_ ; i <= max Index ; i ++ ) { double key = the Keys . get ( i ) ; buf . append ( String . value Of ( key ) ) ; buf . append ( STR_ ) ; buf . append ( String . value Of ( get ( key ) ) ) ; if ( i < max Index ) buf . append ( STR_ ) ; } buf . append ( STR_ ) ; return buf . to String ( ) ; }
@ Nullable public static String find File In Provided Path ( String provided Path , String ... file Names ) { if ( String Util . is Empty ( provided Path ) ) { return STR_ ; } File provided File = new File ( provided Path ) ; if ( provided File . exists ( ) ) { String name = provided File . get Name ( ) ; for ( String file Name : file Names ) { if ( name . equals ( file Name ) ) { return to System Dependent Name ( provided File . get Path ( ) ) ; } } } if ( provided File . is Directory ( ) ) { for ( String file Name : file Names ) { File file = new File ( provided File , file Name ) ; if ( file Name . equals ( file . get Name ( ) ) && file . exists ( ) ) { return to System Dependent Name ( file . get Path ( ) ) ; } } } provided File = provided File . get Parent File ( ) ; if ( provided File != null && provided File . exists ( ) ) { for ( String file Name : file Names ) { File file = new File ( provided File , file Name ) ; if ( file Name . equals ( file . get Name ( ) ) && file . exists ( ) ) { return to System Dependent Name ( file . get Path ( ) ) ; } } } return null ; }
public int size ( ) { return samples . size ( ) ; }
public double switched Pow 10 ( double val ) { return this . small Log Flag ? Math . pow ( NUM_ , val ) : adjusted Pow 10 ( val ) ; }
protected void init Model ( ) throws Exception { if ( m Model == null ) { m Model = ( Classifier ) Serialization Helper . read ( m Model File . get Absolute Path ( ) ) ; } }
private static int index Of Non Digit ( String string , int offset ) { for ( int i = offset ; i < string . length ( ) ; i ++ ) { char c = string . char At ( i ) ; if ( c < STR_ || c > STR_ ) return i ; } return string . length ( ) ; }
public boolean is Set Old GC ( ) { return isset bit vector . get ( OLDGC ISSET ID ) ; }
public List < Object > parse Row ( ) throws Format Exception { List < Object > retval = new Array List < Object > ( get Column Count ( ) ) ; return parse Row ( retval ) ? retval : null ; }
public static boolean is Unlikely To Be Renamed ( String pkg ) { return pkg . starts With ( STR_ ) ; }
public static boolean is Empty ( Char Sequence str ) { if ( str == null || str . length ( ) == NUM_ ) { return true ; } return false ; }
public static Charset default Charset ( ) { if ( default Charset == null ) { synchronized ( Charset . class ) { String csn = Access Controller . do Privileged ( new Get Property Action ( STR_ ) ) ; Charset cs = lookup ( csn ) ; if ( cs != null ) default Charset = cs ; else default Charset = for Name ( STR_ ) ; } } return default Charset ; }
public static boolean is FFA ( final Game Data data , final Player ID player ) { final Relationship Tracker relationship Tracker = data . get Relationship Tracker ( ) ; final Set < Player ID > enemies = relationship Tracker . get Enemies ( player ) ; for ( final Player ID enemy : enemies ) { if ( relationship Tracker . is At War With Any Of These Players ( enemy , enemies ) ) { return true ; } } return false ; }
public static void si Wait ( Object o , long time ) { try { if ( time == - NUM_ ) o . wait ( ) ; else o . wait ( time ) ; } catch ( Interrupted Exception e ) { throw new SI Exception ( ) ; } abort Or Pause If Necessary ( ) ; }
public static String before ( String s , String token ) { if ( s == null ) { return null ; } int i = s . index Of ( token ) ; if ( i == - NUM_ ) { return s ; } return s . substring ( NUM_ , i ) ; }
public boolean has Name Value ( String name ) { return hmap . contains Key ( name . to Lower Case ( ) ) ; }
protected boolean need Thread ( ) { int bound = ( int ) ( load Factor * threads . size ( ) ) ; int max = tasks . size ( ) ; if ( max < bound ) return false ; max -- ; if ( run After ( tasks . get ( max ) , max ) ) return false ; int ready = first Pending + NUM_ ; if ( ready > bound ) return true ; for ( int i = first Pending ; i < max ; i ++ ) { if ( ! run After ( tasks . get ( i ) , i ) ) { ready ++ ; if ( ready > bound ) return true ; } } return false ; }
private static boolean match All Wildcards ( String name , String template ) { name = name . to Lower Case ( Locale . ENGLISH ) ; template = template . to Lower Case ( Locale . ENGLISH ) ; String Tokenizer name St = new String Tokenizer ( name , STR_ ) ; String Tokenizer template St = new String Tokenizer ( template , STR_ ) ; if ( name St . count Tokens ( ) != template St . count Tokens ( ) ) { return false ; } while ( name St . has More Tokens ( ) ) { if ( ! match Wild Cards ( name St . next Token ( ) , template St . next Token ( ) ) ) { return false ; } } return true ; }
protected String template String ( ) { String result = STR_ ; String temp Result = STR_ ; for ( int m Resultset Key Column : m Resultset Key Columns ) { temp Result = m Template . to String ( m Resultset Key Column ) + STR_ ; temp Result = Utils . remove Substring ( temp Result , STR_ ) ; temp Result = Utils . remove Substring ( temp Result , STR_ ) ; temp Result = Utils . remove Substring ( temp Result , STR_ ) ; result += temp Result ; } return result . trim ( ) ; }
@ Override public boolean log Modified ( Logger log ) { if ( depend . log Modified ( log ) ) { return true ; } else if ( source Path == null ) return false ; else if ( source Path . get Last Modified ( ) != source Last Modified ) { log . info ( STR_ + source Path + STR_ + new Date ( source Last Modified ) + STR_ + new Date ( source Path . get Last Modified ( ) ) ) ; return true ; } else if ( source Path . length ( ) != source Length ) { log . info ( STR_ + source Path + STR_ + source Length + STR_ + source Path . length ( ) ) ; return true ; } else { return false ; } }
@ Override public int hash Code ( ) { int result ; long temp ; temp = m != NUM_ ? Double . double To Long Bits ( m ) : NUM_ ; result = ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; temp = t != NUM_ ? Double . double To Long Bits ( t ) : NUM_ ; result = NUM_ * result + ( int ) ( temp ^ ( temp > > > NUM_ ) ) ; return result ; }
@ Override public int hash Code ( ) { return ( class Hash ( ) + sub Query . hash Code ( ) + Arrays . hash Code ( scoring Queries ) ) ; }
public Attribute Description with Option ( final String option ) { Reject . if Null ( option ) ; final String normalized Option = to Lower Case ( option ) ; if ( options Pimpl . has Option ( normalized Option ) ) { return this ; } final String new Attribute Description = append Option ( attribute Description , option ) ; final Impl impl = options Pimpl ; if ( impl instanceof Zero Option Impl ) { return new Attribute Description ( new Attribute Description , name Or Oid , attribute Type , new Single Option Impl ( option , normalized Option ) ) ; } else if ( impl instanceof Single Option Impl ) { final Single Option Impl simpl = ( Single Option Impl ) impl ; final String [ ] new Options = new String [ NUM_ ] ; new Options [ NUM_ ] = simpl . option ; new Options [ NUM_ ] = option ; final String [ ] new Normalized Options = new String [ NUM_ ] ; if ( normalized Option . compare To ( simpl . normalized Option ) < NUM_ ) { new Normalized Options [ NUM_ ] = normalized Option ; new Normalized Options [ NUM_ ] = simpl . normalized Option ; } else { new Normalized Options [ NUM_ ] = simpl . normalized Option ; new Normalized Options [ NUM_ ] = normalized Option ; } return new Attribute Description ( new Attribute Description , name Or Oid , attribute Type , new Multi Option Impl ( new Options , new Normalized Options ) ) ; } else { final Multi Option Impl mimpl = ( Multi Option Impl ) impl ; final int sz 1 = mimpl . options . length ; final String [ ] new Options = Arrays . copy Of ( mimpl . options , sz 1 + NUM_ ) ; new Options [ sz 1 ] = option ; final int sz 2 = mimpl . normalized Options . length ; final String [ ] new Normalized Options = new String [ sz 2 + NUM_ ] ; boolean inserted = false ; for ( int i = NUM_ ; i < sz 2 ; i ++ ) { if ( ! inserted ) { final String s = mimpl . normalized Options [ i ] ; if ( normalized Option . compare To ( s ) < NUM_ ) { new Normalized Options [ i ] = normalized Option ; new Normalized Options [ i + NUM_ ] = s ; inserted = true ; } else { new Normalized Options [ i ] = s ; } } else { new Normalized Options [ i + NUM_ ] = mimpl . normalized Options [ i ] ; } } if ( ! inserted ) { new Normalized Options [ sz 2 ] = normalized Option ; } return new Attribute Description ( new Attribute Description , name Or Oid , attribute Type , new Multi Option Impl ( new Options , new Normalized Options ) ) ; } }
public final double sample Count ( ) { synchronized ( lock ) { long count = count . get ( ) ; long last Count = last Count ; last Count = count ; return count - last Count ; } }
protected boolean fail If Region Missing ( ) { return true ; }
protected void check Boundary Compatibility ( ) { if ( from instanceof String && to instanceof String ) { final String start = from . to String ( ) ; final String end = to . to String ( ) ; if ( start . length ( ) != end . length ( ) ) { throw new Illegal Argument Exception ( STR_ ) ; } final int length = start . length ( ) ; int i ; for ( i = NUM_ ; i < length ; i ++ ) { if ( start . char At ( i ) != end . char At ( i ) ) { break ; } } if ( i < length - NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } } }
public int search ( String txt ) { int n = txt . length ( ) ; if ( n < m ) return n ; long txt Hash = hash ( txt , m ) ; if ( ( pat Hash == txt Hash ) && check ( txt , NUM_ ) ) return NUM_ ; for ( int i = m ; i < n ; i ++ ) { txt Hash = ( txt Hash + q - RM * txt . char At ( i - m ) % q ) % q ; txt Hash = ( txt Hash * R + txt . char At ( i ) ) % q ; int offset = i - m + NUM_ ; if ( ( pat Hash == txt Hash ) && check ( txt , offset ) ) return offset ; } return n ; }
private int count Scan Bands ( ) { List ids = new Array List ( ) ; Iterator iter = marker Sequence . iterator ( ) ; while ( iter . has Next ( ) ) { Marker Segment seg = ( Marker Segment ) iter . next ( ) ; if ( seg instanceof SOS Marker Segment ) { SOS Marker Segment sos = ( SOS Marker Segment ) seg ; SOS Marker Segment . Scan Component Spec [ ] specs = sos . component Specs ; for ( int i = NUM_ ; i < specs . length ; i ++ ) { Integer id = new Integer ( specs [ i ] . component Selector ) ; if ( ! ids . contains ( id ) ) { ids . add ( id ) ; } } } } return ids . size ( ) ; }
public static boolean is In Eastern Eight Zones ( ) { return Time Zone . get Default ( ) == Time Zone . get Time Zone ( STR_ ) ; }
public < T > List < T > init Plugins ( List < Plugin Info > plugin Infos , Class < T > type , String def Class Name ) { if ( plugin Infos . is Empty ( ) ) return Collections . empty List ( ) ; List < T > result = new Array List < > ( ) ; for ( Plugin Info info : plugin Infos ) result . add ( create Init Instance ( info , type , type . get Simple Name ( ) , def Class Name ) ) ; return result ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
protected int position For Mouse Event ( Mouse Event e ) { int new Y = ( e . get Source ( ) == Basic Split Pane Divider . this ) ? ( e . get Y ( ) + get Location ( ) . y ) : e . get Y ( ) ; new Y = Math . min ( max X , Math . max ( min X , new Y - offset ) ) ; return new Y ; }
protected Population truncate ( Population offspring , int size ) { Population survivors = new Population ( ) ; Iterator < Solution > iterator = offspring . iterator ( ) ; while ( iterator . has Next ( ) ) { Solution solution = iterator . next ( ) ; double fitness = ( Double ) solution . get Attribute ( Fitness Evaluator . FITNESS ATTRIBUTE ) ; if ( fitness < NUM_ ) { survivors . add ( solution ) ; iterator . remove ( ) ; } } if ( survivors . size ( ) < size ) { offspring . sort ( fitness Comparator ) ; while ( survivors . size ( ) < size ) { survivors . add ( offspring . get ( NUM_ ) ) ; offspring . remove ( NUM_ ) ; } } else if ( survivors . size ( ) > size ) { Mutable Distance Map map = new Mutable Distance Map ( compute Distance Matrix ( survivors ) ) ; while ( survivors . size ( ) > size ) { int index = map . find Most Crowded Point ( ) ; map . remove Point ( index ) ; survivors . remove ( index ) ; } } return survivors ; }
public static boolean is Image ( String mime Type ) { if ( mime Type != null ) { if ( mime Type . starts With ( STR_ ) ) return true ; else return false ; } else return false ; }
public static boolean is Basic ( Class < ? > a Class ) { return basic Types . contains ( a Class . get Name ( ) ) ; }
@ Override public boolean has Text ( ) { log . log ( Level . FINE , STR_ ) ; return event == CHARACTERS || event == ENTITY REFERENCE ; }
private void required ( String attribute Name , Resource attribut Value , boolean exists ) throws Application Exception { if ( attribut Value == null ) throw new Application Exception ( STR_ , STR_ + attribute Name + STR_ + action + STR_ ) ; if ( exists && ! attribut Value . exists ( ) ) throw new Application Exception ( attribute Name + STR_ + attribut Value + STR_ ) ; else if ( exists && ! attribut Value . can Read ( ) ) throw new Application Exception ( STR_ + attribute Name + STR_ + attribut Value + STR_ ) ; }
public static void delete Files Ignoring Exceptions ( Collection < ? extends Path > files ) { for ( Path name : files ) { if ( name != null ) { try { Files . delete ( name ) ; } catch ( Throwable ignored ) { } } } }
public static < K , V > Map < K , V > of ( K k 1 , V v 1 , K k 2 , V v 2 , K k 3 , V v 3 , K k 4 , V v 4 ) { Map map = of ( ) ; map . put ( k 1 , v 1 ) ; map . put ( k 2 , v 2 ) ; map . put ( k 3 , v 3 ) ; map . put ( k 4 , v 4 ) ; return map ; }
@ Suppress Warnings ( STR_ ) @ Override public boolean contains Key ( Object key ) { if ( comparator == null && Number Comparator . is Number ( key ) ) { comparator = Number Comparator . create Comparator ( key . get Class ( ) ) ; } java . lang . Comparable < K > object = comparator == null ? to Comparable ( ( K ) key ) : null ; K key K = ( K ) key ; Node < K , V > node = root ; while ( node != null ) { K [ ] keys = node . keys ; int left idx = node . left idx ; int result = object != null ? object . compare To ( keys [ left idx ] ) : - comparator . compare ( keys [ left idx ] , key K ) ; if ( result < NUM_ ) { node = node . left ; } else if ( result == NUM_ ) { return true ; } else { int right idx = node . right idx ; if ( left idx != right idx ) { result = cmp ( object , key K , keys [ right idx ] ) ; } if ( result > NUM_ ) { node = node . right ; } else if ( result == NUM_ ) { return true ; } else { int low = left idx + NUM_ , mid = NUM_ , high = right idx - NUM_ ; while ( low <= high ) { mid = ( low + high ) > > > NUM_ ; result = cmp ( object , key K , keys [ mid ] ) ; if ( result > NUM_ ) { low = mid + NUM_ ; } else if ( result == NUM_ ) { return true ; } else { high = mid - NUM_ ; } } return false ; } } } return false ; }
public static B Float exp ( float i X ) { int i N = ( int ) Math . round ( i X / i Log Range ) ; return new B Float ( ( float ) Math . exp ( i X - i N * i Log Range ) , i N ) ; }
@ Visible For Testing public static boolean is Plaintext ( Buffer buffer ) throws EOF Exception { try { Buffer prefix = new Buffer ( ) ; long byte Count = buffer . size ( ) < NUM_ ? buffer . size ( ) : NUM_ ; buffer . copy To ( prefix , NUM_ , byte Count ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( prefix . exhausted ( ) ) { break ; } int code Point = prefix . read Utf 8 Code Point ( ) ; if ( Character . is ISO Control ( code Point ) && ! Character . is Whitespace ( code Point ) ) { return false ; } } return true ; } catch ( EOF Exception e ) { return false ; } }
public static String strip Meta From Name ( String file Name ) { int end = file Name . index Of ( STR_ ) ; if ( end == - NUM_ ) end = file Name . index Of ( STR_ ) ; if ( end == - NUM_ ) return file Name ; return file Name . substring ( NUM_ , end ) ; }
public Collection < String > simple Match To Index Names ( String pattern ) { if ( Regex . is Simple Match Pattern ( pattern ) == false ) { return Collections . singleton List ( pattern ) ; } return field Types . simple Match To Index Names ( pattern ) ; }
public static Color fade To Color ( Color source , Color target , float ratio ) { int r = ( int ) ( ( NUM_ - ratio ) * source . get Red ( ) + ratio * target . get Red ( ) ) ; int g = ( int ) ( ( NUM_ - ratio ) * source . get Green ( ) + ratio * target . get Green ( ) ) ; int b = ( int ) ( ( NUM_ - ratio ) * source . get Blue ( ) + ratio * target . get Blue ( ) ) ; int a = ( int ) ( ( NUM_ - ratio ) * source . get Alpha ( ) + ratio * target . get Alpha ( ) ) ; return new Color ( r , g , b , a ) ; }
public static Set find Protocols For Entity ( String entity Id , String realm ) { try { Set ret Set = new Hash Set ( ) ; Circle Of Trust Manager manager = new Circle Of Trust Manager ( ) ; Set idff Set = manager . get All Entities ( realm , COT Constants . IDFF ) ; if ( idff Set . contains ( entity Id ) ) { ret Set . add ( COT Constants . IDFF ) ; } Set saml 2 Set = manager . get All Entities ( realm , COT Constants . SAML 2 ) ; if ( ( saml 2 Set != null ) && saml 2 Set . contains ( entity Id ) ) { ret Set . add ( COT Constants . SAML 2 ) ; } return ret Set ; } catch ( COT Exception e ) { debug . error ( STR_ , e ) ; return null ; } }
public Object [ ] to Array ( ) { Object [ ] elements = get Array ( ) ; return Arrays . copy Of ( elements , elements . length ) ; }
private static int compute Max Flow ( ) { int sum ; for ( int i = NUM_ ; i < n - NUM_ ; i ++ ) { sum = NUM_ ; for ( int j = NUM_ ; j < n ; j ++ ) { sum = sum + outgoing [ j ] [ i ] - outgoing [ i ] [ j ] ; } if ( sum != NUM_ ) { return - NUM_ ; } } sum = NUM_ ; for ( int j = NUM_ ; j < n ; j ++ ) { sum = sum + outgoing [ NUM_ ] [ j ] ; } return sum ; }
private Object Stream Class read Class Desc ( boolean unshared ) throws IO Exception { byte tc = bin . peek Byte ( ) ; Object Stream Class descriptor ; switch ( tc ) { case TC NULL : descriptor = ( Object Stream Class ) read Null ( ) ; break ; case TC REFERENCE : descriptor = ( Object Stream Class ) read Handle ( unshared ) ; break ; case TC PROXYCLASSDESC : descriptor = read Proxy Desc ( unshared ) ; break ; case TC CLASSDESC : descriptor = read Non Proxy Desc ( unshared ) ; break ; default : throw new Stream Corrupted Exception ( String . format ( STR_ , tc ) ) ; } if ( descriptor != null ) { validate Descriptor ( descriptor ) ; } return descriptor ; }
public String error String ( String err , Object arg 0 , Object arg 1 , Object arg 2 ) { if ( err . starts With ( STR_ ) || err . starts With ( STR_ ) ) { String result = Main . get Text ( err , ( arg 0 != null ? arg 0 . to String ( ) : null ) , ( arg 1 != null ? arg 1 . to String ( ) : null ) , ( arg 2 != null ? arg 2 . to String ( ) : null ) ) ; if ( err . starts With ( STR_ ) ) { result = STR_ + result ; } return result ; } else { return super . error String ( err , arg 0 , arg 1 , arg 2 ) ; } }
public boolean can Undo ( ) { return m n Current Edit Action >= NUM_ ; }
public Memory Index Store Entry next ( ) { if ( values Iterator == null ) { current Entry . set Memory Index Store Entry ( curr Key , ( Region Entry ) curr Value ) ; return current Entry ; } Region Entry re = ( Region Entry ) values Iterator . next ( ) ; if ( re == null ) throw new No Such Element Exception ( ) ; current Entry . set Memory Index Store Entry ( curr Key , re ) ; return current Entry ; }
public Query like ( int doc Num ) throws IO Exception { Map < String , Map < String , Flt > > field Term Freq = retrieve Terms ( doc Num ) ; Boolean Query query = new Boolean Query ( ) ; for ( String field Name : field Term Freq . key Set ( ) ) { Map < String , Flt > words = field Term Freq . get ( field Name ) ; Priority Queue < US Field > queue = create Queue ( field Name , words ) ; build Query For Field ( field Name , queue , query ) ; } return query ; }
protected boolean is Root Key Prefix ( String s 3 Key Prefix ) { return String Utils . is Blank ( s 3 Key Prefix ) || s 3 Key Prefix . equals ( STR_ ) ; }
@ Nullable private static Pair < String , String > parse Packed Refs Line ( @ Not Null String line ) { line = line . trim ( ) ; if ( line . is Empty ( ) ) { return null ; } char first Char = line . char At ( NUM_ ) ; if ( first Char == STR_ ) { return null ; } if ( first Char == STR_ ) { return null ; } String hash = null ; int i ; for ( i = NUM_ ; i < line . length ( ) ; i ++ ) { char c = line . char At ( i ) ; if ( ! Character . is Letter Or Digit ( c ) ) { hash = line . substring ( NUM_ , i ) ; break ; } } if ( hash == null ) { LOG . warn ( STR_ + line + STR_ ) ; return null ; } String branch = null ; int start = i ; if ( start < line . length ( ) && line . char At ( start ++ ) == STR_ ) { for ( i = start ; i < line . length ( ) ; i ++ ) { char c = line . char At ( i ) ; if ( Character . is Whitespace ( c ) ) { break ; } } branch = line . substring ( start , i ) ; } if ( branch == null || ! branch . starts With ( REFS HEADS PREFIX ) && ! branch . starts With ( REFS REMOTES PREFIX ) ) { return null ; } return Pair . create ( short Buffer ( branch ) , short Buffer ( hash . trim ( ) ) ) ; }
public static cu Double Complex cu Cdiv ( cu Double Complex x , cu Double Complex y ) { cu Double Complex quot ; double s = Math . abs ( cu Creal ( y ) ) + Math . abs ( cu Cimag ( y ) ) ; double oos = NUM_ / s ; double ars = cu Creal ( x ) * oos ; double ais = cu Cimag ( x ) * oos ; double brs = cu Creal ( y ) * oos ; double bis = cu Cimag ( y ) * oos ; s = ( brs * brs ) + ( bis * bis ) ; oos = NUM_ / s ; quot = cu Cmplx ( ( ( ars * brs ) + ( ais * bis ) ) * oos , ( ( ais * brs ) - ( ars * bis ) ) * oos ) ; return quot ; }
synchronized void release ( Allocation Impl allocation ) { byte [ ] [ ] buffers = allocation . get Buffers ( ) ; allocated Buffer Count -= buffers . length ; int new Recycled Buffer Count = recycled Buffer Count + buffers . length ; ensure Recycled Buffer Capacity ( new Recycled Buffer Count ) ; System . arraycopy ( buffers , NUM_ , recycled Buffers , recycled Buffer Count , buffers . length ) ; recycled Buffer Count = new Recycled Buffer Count ; }
public Big Decimal balance ( ) { return cr Amount . subtract ( dr Amount ) ; }
public String parse ( ) throws Query Exception { return ( parse ( true ) ) ; }
private List < T > as List ( ) { if ( as List == null ) { List < T > smallest First List = Lists . new Array List With Capacity ( as Queue . size ( ) ) ; while ( ! as Queue . is Empty ( ) ) { smallest First List . add ( as Queue . poll ( ) ) ; } as List = Lists . reverse ( smallest First List ) ; as Queue = null ; } return as List ; }
@ Suppress Warnings ( STR_ ) public T next ( ) { if ( has Next ( ) == false ) { throw new No Such Element Exception ( ) ; } return ( T ) Array . get ( array , index ++ ) ; }
public static Set services Assigned By Default ( ) { if ( ! loaded Auth Services ) { Authentication Service Name Provider provider = Authentication Service Name Provider Factory . get Provider ( ) ; default Services To Load . add All ( provider . get Authentication Service Names ( ) ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + default Services To Load ) ; } loaded Auth Services = true ; default Services To Load = Collections . unmodifiable Set ( default Services To Load ) ; } return ( default Services To Load ) ; }
public static boolean is Keyboard Showing ( ) { return show VKB || ( System . current Time Millis ( ) - closed Time ) < NUM_ ; }
public Frontier Query build Frontier Query ( Bytes Ref Hash collector Terms , Integer frontier Size ) { if ( collector Terms == null || collector Terms . size ( ) == NUM_ ) { return null ; } else { Query q = null ; if ( use Autn ) { Automaton autn = build Automaton ( collector Terms ) ; Automaton Query autn Query = new Automaton Query ( new Term ( from Field ) , autn ) ; q = autn Query ; } else { List < Bytes Ref > term List = new Array List < > ( collector Terms . size ( ) ) ; for ( int i = NUM_ ; i < collector Terms . size ( ) ; i ++ ) { Bytes Ref ref = new Bytes Ref ( ) ; collector Terms . get ( i , ref ) ; term List . add ( ref ) ; } q = new Terms Query ( from Field , term List ) ; } if ( traversal Filter != null ) { Boolean Query . Builder builder = new Boolean Query . Builder ( ) ; builder . add ( q , Occur . MUST ) ; builder . add ( traversal Filter , Occur . MUST ) ; q = builder . build ( ) ; } Frontier Query frontier = new Frontier Query ( q , frontier Size ) ; return frontier ; } }
public static < K , V > List < Key Value < K , V > > read Key Values ( String topic , Properties consumer Config , int max Messages ) { Kafka Consumer < K , V > consumer = new Kafka Consumer < > ( consumer Config ) ; consumer . subscribe ( Collections . singleton List ( topic ) ) ; int poll Interval Ms = NUM_ ; int max Total Poll Time Ms = NUM_ ; int total Poll Time Ms = NUM_ ; List < Key Value < K , V > > consumed Values = new Array List < > ( ) ; while ( total Poll Time Ms < max Total Poll Time Ms && continue Consuming ( consumed Values . size ( ) , max Messages ) ) { total Poll Time Ms += poll Interval Ms ; Consumer Records < K , V > records = consumer . poll ( poll Interval Ms ) ; for ( Consumer Record < K , V > record : records ) { consumed Values . add ( new Key Value < > ( record . key ( ) , record . value ( ) ) ) ; } } consumer . close ( ) ; return consumed Values ; }
@ Override public boolean has Name ( ) { log . log ( Level . FINE , STR_ , event == START ELEMENT || event == END ELEMENT ) ; return event == START ELEMENT || event == END ELEMENT ; }
public int size ( ) { int a ; for ( a = arrays . length ( ) - NUM_ ; a >= NUM_ ; a -- ) { Atomic Long Array array = arrays . get ( a ) ; if ( array != null ) break ; } return ( ( NUM_ << a + NUM_ ) - NUM_ ) * BITS PER WORD ; }
public String url Encode ( ) { String Builder sb = new String Builder ( ) ; for ( String key : map . key Set ( ) ) { if ( sb . length ( ) > NUM_ ) { sb . append ( STR_ ) ; } sb . append ( key ) ; String value = map . get ( key ) ; if ( value != null ) { sb . append ( STR_ ) ; try { sb . append ( URL Encoder . encode ( value , Request Handler . UTF 8 ) ) ; } catch ( Unsupported Encoding Exception e ) { e . print Stack Trace ( ) ; } } } return sb . to String ( ) ; }
public String to HTML ( ) { String html ID = STR_ ; String status = STR_ ; if ( failed ( ) ) { html ID = STR_ ; status = STR_ ; } else if ( skipped ( ) ) { html ID = STR_ ; status = STR_ ; } String Buffer buff = new String Buffer ( ) ; buff . append ( STR_ ) ; Object [ ] params = { html ID , name } ; buff . append ( Message Format . format ( HTML Constants . TBL ENTRY , params ) ) ; params [ NUM_ ] = status ; buff . append ( Message Format . format ( HTML Constants . TBL ENTRY , params ) ) ; params [ NUM_ ] = Float . to String ( time Taken ) ; buff . append ( Message Format . format ( HTML Constants . TBL NUM ENTRY , params ) ) ; params [ NUM_ ] = ( failure != null ) ? STR_ + failure . get Stack Trace ( ) + STR_ : STR_ ; buff . append ( Message Format . format ( HTML Constants . TBL ENTRY , params ) ) ; buff . append ( STR_ ) ; return buff . to String ( ) ; }
@ Safe Varargs protected final List < Feature Flag > collect Feature Flags ( final Class < ? extends Feature Flag > ... enumerations ) { return collect Feature Flags ( Arrays . as List ( enumerations ) ) ; }
public GF 2 Polynomial shift Right ( ) { GF 2 Polynomial result = new GF 2 Polynomial ( len - NUM_ ) ; int i ; System . arraycopy ( value , NUM_ , result . value , NUM_ , result . blocks ) ; for ( i = NUM_ ; i <= result . blocks - NUM_ ; i ++ ) { result . value [ i ] >>>= NUM_ ; result . value [ i ] |= result . value [ i + NUM_ ] << NUM_ ; } result . value [ result . blocks - NUM_ ] >>>= NUM_ ; if ( result . blocks < blocks ) { result . value [ result . blocks - NUM_ ] |= value [ result . blocks ] << NUM_ ; } return result ; }
public int hash Code ( ) { return delegate . hash Code ( ) ; }
boolean opposite Turn ( Move Step turn 2 ) { switch ( type ) { case TURN LEFT : return turn 2 . get Type ( ) == Move Step Type . TURN RIGHT ; case TURN RIGHT : return turn 2 . get Type ( ) == Move Step Type . TURN LEFT ; default : return false ; } }
public Type lub ( Type t 1 , Type t 2 ) { return lub ( List . of ( t 1 , t 2 ) ) ; }
private static String as Http Date ( long date ) { Simple Date Format date Format = new Simple Date Format ( STR_ , Locale . US ) ; return date Format . format ( new Date ( date ) ) ; }
private static int line Wrap Index ( String line , int max Width ) { for ( int i = max Width ; i > NUM_ ; i -- ) { if ( is Line Wrap Char ( line . char At ( i ) ) ) { return i ; } } for ( int i = max Width + NUM_ ; i < line . length ( ) ; i ++ ) { if ( is Line Wrap Char ( line . char At ( i ) ) ) { return i ; } } return line . length ( ) ; }
public static < T > boolean some Match ( final Collection < T > collection , final Match < T > a Match ) { if ( collection . is Empty ( ) ) { return false ; } for ( final T current : collection ) { if ( a Match . match ( current ) ) { return true ; } } return false ; }
public static String droidsafe Output File ( I Project project , String file Name ) { String output Dir = get Project Output Dir ( project ) ; String full Path = output Dir + File . separator + file Name ; return full Path ; }
private static double v 2 Length ( Point 2 D . Double a ) { return Math . sqrt ( v 2 Squared Length ( a ) ) ; }
private static int calc Max Page Entry Size ( Jet Format format ) { int page Data Size = ( format . PAGE SIZE - ( format . OFFSET INDEX ENTRY MASK + format . SIZE INDEX ENTRY MASK ) ) ; int entry Mask Size = ( format . SIZE INDEX ENTRY MASK * NUM_ ) ; return Math . min ( page Data Size , entry Mask Size ) ; }
public int length ( ) { return results . size ( ) ; }
public static File savepoint File ( File instance Path ) { File temp Dir = new File ( Collect . CACHE PATH ) ; return new File ( temp Dir , instance Path . get Name ( ) + STR_ ) ; }
@ Override public final boolean enabled ( ) { return book File . can Read ( ) ; }
public boolean is Coverage Complete ( ) { return coverage . cardinality ( ) == sequence Length ; }
public static String diag Prefix ( String aspect Name ) { return String . format ( STR_ , aspect Name ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static Rotate Stream create ( String path ) throws Config Exception { synchronized ( format Streams ) { Weak Reference < Rotate Stream > ref = format Streams . get ( path ) ; Rotate Stream stream = ref != null ? ref . get ( ) : null ; if ( stream == null ) { stream = new Rotate Stream ( path ) ; format Streams . put ( path , new Weak Reference < Rotate Stream > ( stream ) ) ; } return stream ; } }
public boolean is Pure JAAS Module Present ( final String config Name , final Configuration configuration ) throws Auth Login Exception { if ( enforce JAAS Thread ) { return true ; } if ( null == configuration ) { return true ; } final App Configuration Entry [ ] entries = configuration . get App Configuration Entry ( config Name ) ; if ( entries == null ) { throw new Auth Login Exception ( STR_ , AM Auth Error Code . AUTH CONFIG NOT FOUND , null ) ; } for ( App Configuration Entry entry : entries ) { String class Name = entry . get Login Module Name ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + class Name ) ; } if ( is Pure JAAS Module ( class Name ) ) { return true ; } else if ( ! is IS Module ( class Name ) ) { categorise Module Class From Classname ( class Name ) ; if ( is Pure JAAS Module ( class Name ) ) { return true ; } } } return false ; }
private static boolean add Constants To Generator ( String Argument constants , Entry Generator generator , final Console Application app ) { for ( final String constant : constants . get Values ( ) ) { final String [ ] chunks = constant . split ( STR_ ) ; if ( chunks . length != NUM_ ) { app . err Println ( ERR CONSTANT ARG CANNOT DECODE . get ( constant ) ) ; return false ; } generator . set Constant ( chunks [ NUM_ ] , chunks [ NUM_ ] ) ; } return true ; }
protected Date next Standard Date ( Date date , Date Tick Unit unit ) { Date previous = previous Standard Date ( date , unit ) ; Calendar calendar = Calendar . get Instance ( this . time Zone , this . locale ) ; calendar . set Time ( previous ) ; calendar . add ( unit . get Calendar Field ( ) , unit . get Multiple ( ) ) ; return calendar . get Time ( ) ; }
String clean Selector String ( String selector ) { boolean last Was Space = true ; for ( int counter = NUM_ , max Counter = selector . length ( ) ; counter < max Counter ; counter ++ ) { switch ( selector . char At ( counter ) ) { case STR_ : if ( last Was Space ) { return clean Selector String ( selector ) ; } last Was Space = true ; break ; case STR_ : case STR_ : case STR_ : return clean Selector String ( selector ) ; default : last Was Space = false ; } } if ( last Was Space ) { return clean Selector String ( selector ) ; } return selector ; }
private Integer guess Format ( byte [ ] file Data ) { Integer result = Sync Parameter . EXPORT FORMAT VERINICE ARCHIV ; if ( file Data != null ) { String content = new String ( file Data ) ; content = content . trim ( ) ; if ( content . ends With ( SYNC REQUEST ) ) { result = Sync Parameter . EXPORT FORMAT XML PURE ; } } return result ; }
public boolean is First Day After Yesterday ( int position ) { int header Pos = get Header Position ( position ) ; Row Info row = m Row Info . get ( header Pos ) ; if ( row != null ) { return row . m First Day After Yesterday ; } return false ; }
public boolean has Node ( final Node node ) { return nodes . contains ( node ) ; }
public static String milliseconds To String ( long milliseconds , Simple Date Format date Format ) { return date Format . format ( new Date ( milliseconds ) ) ; }
public < T > List < T > init Plugins ( List < Plugin Info > plugin Infos , Class < T > type , String def Class Name ) { if ( plugin Infos . is Empty ( ) ) return Collections . empty List ( ) ; List < T > result = new Array List < > ( plugin Infos . size ( ) ) ; for ( Plugin Info info : plugin Infos ) result . add ( create Init Instance ( info , type , type . get Simple Name ( ) , def Class Name ) ) ; return result ; }
public boolean has Arg Name ( ) { return arg Name != null && arg Name . length ( ) > NUM_ ; }
public void mark Tokens ( int line Index , Token Handler token Handler ) { Segment seg = new Segment ( ) ; if ( line Index < NUM_ || line Index >= line Mgr . get Line Count ( ) ) throw new Array Index Out Of Bounds Exception ( STR_ + line Mgr . get Line Count ( ) + STR_ + line Index ) ; int first Invalid Line Context = line Mgr . get First Invalid Line Context ( ) ; int start ; if ( first Invalid Line Context == - NUM_ ) { start = line Index ; } else { start = Math . min ( first Invalid Line Context , line Index ) ; } Token Marker . Line Context old Context = null ; Token Marker . Line Context context = null ; for ( int i = start ; i <= line Index ; i ++ ) { get Line Text ( i , seg ) ; old Context = line Mgr . get Line Context ( i ) ; Token Marker . Line Context prev Context = ( ( i == NUM_ ) ? null : line Mgr . get Line Context ( i - NUM_ ) ) ; Token Handler token Handler = i == line Index ? token Handler : Dummy Token Handler . INSTANCE ; context = mark Tokens ( seg , prev Context , token Handler ) ; line Mgr . set Line Context ( i , context ) ; } int line Count = line Mgr . get Line Count ( ) ; if ( line Count - NUM_ == line Index ) line Mgr . set First Invalid Line Context ( - NUM_ ) ; else if ( old Context != context ) line Mgr . set First Invalid Line Context ( line Index + NUM_ ) ; else if ( first Invalid Line Context == - NUM_ ) ; else { line Mgr . set First Invalid Line Context ( Math . max ( first Invalid Line Context , line Index + NUM_ ) ) ; } }
public boolean check Personality ( Volume . Personality Types personality ) { return check Personality ( personality . name ( ) ) ; }
@ Override public int hash Code ( ) { return NUM_ * ( NUM_ + Math Utils . hash ( get Result ( ) ) ) + Math Utils . hash ( get N ( ) ) ; }
public static String read ( final String filename ) { try { return as String ( new File Input Stream ( new File ( filename ) ) , Charset . default Charset ( ) ) ; } catch ( IO Exception e ) { logger . warn ( STR_ , filename , e ) ; return null ; } }
@ Override public boolean is Busy ( ) { return m busy ; }
public static boolean is Contained By ( @ Not Null Source Provider provider , @ Not Null File target Folder ) { Collection < File > src Directories = get All Source Folders ( provider ) ; for ( File container : src Directories ) { if ( is Ancestor ( target Folder , container , false ) ) { return true ; } if ( ! container . exists ( ) ) { continue ; } if ( is Ancestor ( target Folder , container , false ) ) { return true ; } } return false ; }
public static String android Build Version ( ) { String Buffer buf = new String Buffer ( ) ; buf . append ( STR_ + Build . VERSION . RELEASE ) ; buf . append ( STR_ + Build . VERSION . INCREMENTAL ) ; buf . append ( STR_ + Build . VERSION . CODENAME ) ; buf . append ( STR_ + Build . VERSION . SDK INT ) ; buf . append ( STR_ + Build . MODEL ) ; buf . append ( STR_ + Build . MANUFACTURER ) ; buf . append ( STR_ + Build . BOARD ) ; buf . append ( STR_ + Build . BRAND ) ; buf . append ( STR_ + Build . DEVICE ) ; buf . append ( STR_ + Build . PRODUCT ) ; buf . append ( STR_ + Build . HARDWARE ) ; buf . append ( STR_ + Build . CPU ABI ) ; buf . append ( STR_ + Build . CPU ABI 2 ) ; buf . append ( STR_ + Build . DISPLAY ) ; buf . append ( STR_ + Build . HOST ) ; buf . append ( STR_ + Build . USER ) ; buf . append ( STR_ + Build . ID ) ; buf . append ( STR_ + Build . TYPE ) ; buf . append ( STR_ + Build . TAGS ) ; buf . append ( STR_ + Build . FINGERPRINT ) ; buf . append ( STR_ ) ; return buf . to String ( ) ; }
public static Set < I Client Config Key > keys ( ) { return keys ; }
private boolean has Overflow ( N node ) { if ( node . is Leaf ( ) ) { return node . get Num Entries ( ) == leaf Capacity ; } return node . get Num Entries ( ) == dir Capacity ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static Variant identifier To Game Type ( String identifier ) { Variant result = null ; if ( identifier . index Of ( SUICIDE IDENTIFIER ) != - NUM_ ) { result = Variant . suicide ; } else if ( identifier . index Of ( BUGHOUSE IDENTIFIER ) != - NUM_ ) { result = Variant . bughouse ; } else if ( identifier . index Of ( CRAZYHOUSE IDENTIFIER ) != - NUM_ ) { result = Variant . crazyhouse ; } else if ( identifier . index Of ( STANDARD IDENTIFIER ) != - NUM_ ) { result = Variant . standard ; } else if ( identifier . index Of ( FISCHER RANDOM IDENTIFIER ) != - NUM_ ) { result = Variant . fischer Random ; } else if ( identifier . index Of ( WILD IDENTIFIER ) != - NUM_ ) { result = Variant . wild ; } else if ( identifier . index Of ( LIGHTNING IDENTIFIER ) != - NUM_ ) { result = Variant . lightning ; } else if ( identifier . index Of ( BLITZ IDENTIFIER ) != - NUM_ ) { result = Variant . blitz ; } else if ( identifier . index Of ( ATOMIC IDENTIFIER ) != - NUM_ ) { result = Variant . atomic ; } else if ( identifier . index Of ( LOSERS IDENTIFIER ) != - NUM_ ) { result = Variant . losers ; } else if ( identifier . index Of ( UNTIMED IDENTIFIER ) != - NUM_ ) { result = Variant . classic ; } else { LOG . warn ( STR_ + identifier + STR_ ) ; result = Variant . classic ; } return result ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + default Filter String ( ) + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
private boolean is Pretty Printing Enabled ( ) { return flags . contains ( Writer Flags . PRETTY PRINT ) && ! current Element ( ) . unformatted Children ; }
public Tree < String > extract Best Max Rule Parse 1 ( int start , int end , int state , int substate , List < String > sentence ) { int c State = maxc Child [ start ] [ end ] [ state ] [ substate ] ; int c Sub State = maxc Child Sub [ start ] [ end ] [ state ] [ substate ] ; if ( c State == - NUM_ ) { return extract Best Max Rule Parse 2 ( start , end , state , substate , sentence ) ; } else { List < Tree < String > > child = new Array List < Tree < String > > ( ) ; child . add ( extract Best Max Rule Parse 2 ( start , end , c State , c Sub State , sentence ) ) ; String state Str = ( String ) tag Numberer . object ( state ) ; if ( state Str . ends With ( STR_ ) ) state Str = state Str . substring ( NUM_ , state Str . length ( ) - NUM_ ) ; total Used Unaries ++ ; int intermediate Node = grammar . get Unary Intermediate ( ( short ) state , ( short ) c State ) ; if ( intermediate Node > NUM_ ) { List < Tree < String > > restored Child = new Array List < Tree < String > > ( ) ; n Times Restored Unaries ++ ; String state Str 2 = ( String ) tag Numberer . object ( intermediate Node ) ; if ( state Str 2 . ends With ( STR_ ) ) state Str 2 = state Str 2 . substring ( NUM_ , state Str 2 . length ( ) - NUM_ ) ; restored Child . add ( new Tree < String > ( state Str 2 , child ) ) ; return new Tree < String > ( state Str , restored Child ) ; } return new Tree < String > ( state Str , child ) ; } }
public boolean is Active Lock ( ) { synchronized ( active Locks ) { return ! active Locks . is Empty ( ) ; } }
private boolean exposed ( int modifiers ) { return NUM_ != ( modifiers & ( Modifier . PUBLIC | Modifier . PROTECTED ) ) ; }
@ Not Null public static Token Set and Set ( @ Not Null Token Set a , @ Not Null Token Set b ) { final Token Set new Set = new Token Set ( ( short ) Math . min ( a . my Shift , b . my Shift ) , ( short ) Math . max ( a . my Max , b . my Max ) ) ; for ( int i = NUM_ ; i < new Set . my Words . length ; i ++ ) { final int ai = new Set . my Shift - a . my Shift + i ; final int bi = new Set . my Shift - b . my Shift + i ; new Set . my Words [ i ] = ( NUM_ <= ai && ai < a . my Words . length ? a . my Words [ ai ] : NUM_ ) & ( NUM_ <= bi && bi < b . my Words . length ? b . my Words [ bi ] : NUM_ ) ; } return new Set ; }
@ Override public Headers Request Condition combine ( Headers Request Condition other ) { Set < Header Expression > set = new Linked Hash Set < > ( this . expressions ) ; set . add All ( other . expressions ) ; return new Headers Request Condition ( set ) ; }
public static List < Long > tick List ( Geo Time Serie gts ) { List < Long > ticks = new Array List < Long > ( gts . values ) ; ticks . add All ( Arrays . as List ( Array Utils . to Object ( Arrays . copy Of ( gts . ticks , gts . values ) ) ) ) ; return ticks ; }
public boolean run ( String s ) { int p = NUM_ ; int l = s . length ( ) ; for ( int i = NUM_ , cp = NUM_ ; i < l ; i += Character . char Count ( cp ) ) { p = step ( p , cp = s . code Point At ( i ) ) ; if ( p == - NUM_ ) return false ; } return accept [ p ] ; }
public Map < Network Lite , List < Storage Port > > select Storage Ports In Networks ( URI storage System URI , Collection < Network Lite > networks , URI varray URI , Export Path Params path Params ) { List < Storage Port > storage Ports = Export Utils . get Storage System Assignable Ports ( db Client , storage System URI , varray URI , path Params ) ; return select Storage Ports In Networks ( storage Ports , networks , varray URI , path Params ) ; }
protected Create Simple Lexer source Decorator ( Map < String , Object > options ) throws Exception { List < List < Object > > shortcut Style Patterns = new Array List < List < Object > > ( ) ; List < List < Object > > fallthrough Style Patterns = new Array List < List < Object > > ( ) ; if ( Util . get Variable Value As Boolean ( options . get ( STR_ ) ) ) { shortcut Style Patterns . add ( Arrays . as List ( new Object [ ] { PR STRING , Pattern . compile ( STR_ ) , null , STR_ } ) ) ; } else if ( Util . get Variable Value As Boolean ( options . get ( STR_ ) ) ) { shortcut Style Patterns . add ( Arrays . as List ( new Object [ ] { PR STRING , Pattern . compile ( STR_ ) , null , STR_ } ) ) ; } else { shortcut Style Patterns . add ( Arrays . as List ( new Object [ ] { PR STRING , Pattern . compile ( STR_ ) , null , STR_ } ) ) ; } if ( Util . get Variable Value As Boolean ( options . get ( STR_ ) ) ) { fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR STRING , Pattern . compile ( STR_ ) , null } ) ) ; } Object hc = options . get ( STR_ ) ; if ( Util . get Variable Value As Boolean ( hc ) ) { if ( Util . get Variable Value As Boolean ( options . get ( STR_ ) ) ) { if ( ( hc instanceof Integer ) && ( Integer ) hc > NUM_ ) { shortcut Style Patterns . add ( Arrays . as List ( new Object [ ] { PR COMMENT , Pattern . compile ( STR_ ) , null , STR_ } ) ) ; } else { shortcut Style Patterns . add ( Arrays . as List ( new Object [ ] { PR COMMENT , Pattern . compile ( STR_ ) , null , STR_ } ) ) ; } fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR STRING , Pattern . compile ( STR_ ) , null } ) ) ; } else { shortcut Style Patterns . add ( Arrays . as List ( new Object [ ] { PR COMMENT , Pattern . compile ( STR_ ) , null , STR_ } ) ) ; } } if ( Util . get Variable Value As Boolean ( options . get ( STR_ ) ) ) { fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR COMMENT , Pattern . compile ( STR_ ) , null } ) ) ; fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR COMMENT , Pattern . compile ( STR_ ) , null } ) ) ; } Object regex Literals = options . get ( STR_ ) ; if ( Util . get Variable Value As Boolean ( regex Literals ) ) { String regex Excls = Util . get Variable Value As Integer ( regex Literals ) > NUM_ ? STR_ : STR_ ; String regex Any = ! regex Excls . is Empty ( ) ? STR_ : STR_ ; String REGEX LITERAL = STR_ + regex Excls + STR_ + STR_ + regex Excls + STR_ + STR_ + regex Any + STR_ + regex Excls + STR_ + STR_ + regex Any + STR_ + STR_ ; fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { STR_ , Pattern . compile ( STR_ + REGEXP PRECEDER PATTERN + STR_ + REGEX LITERAL + STR_ ) } ) ) ; } Pattern types = ( Pattern ) options . get ( STR_ ) ; if ( Util . get Variable Value As Boolean ( types ) ) { fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR TYPE , types } ) ) ; } String keywords = ( String ) options . get ( STR_ ) ; if ( keywords != null ) { keywords = keywords . replace All ( STR_ , STR_ ) ; if ( keywords . length ( ) != NUM_ ) { fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR KEYWORD , Pattern . compile ( STR_ + keywords . replace All ( STR_ , STR_ ) + STR_ ) , null } ) ) ; } } shortcut Style Patterns . add ( Arrays . as List ( new Object [ ] { PR PLAIN , Pattern . compile ( STR_ ) , null , STR_ + Character . to String ( ( char ) NUM_ ) } ) ) ; fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR LITERAL , Pattern . compile ( STR_ , Pattern . CASE INSENSITIVE ) , null } ) ) ; fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR TYPE , Pattern . compile ( STR_ ) , null } ) ) ; fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR PLAIN , Pattern . compile ( STR_ , Pattern . CASE INSENSITIVE ) , null } ) ) ; fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR LITERAL , Pattern . compile ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , Pattern . CASE INSENSITIVE ) , null , STR_ } ) ) ; fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR PLAIN , Pattern . compile ( STR_ ) , null } ) ) ; String punctuation = STR_ ; if ( Util . get Variable Value As Boolean ( options . get ( STR_ ) ) ) { punctuation += STR_ ; } fallthrough Style Patterns . add ( Arrays . as List ( new Object [ ] { PR PUNCTUATION , Pattern . compile ( punctuation ) , null } ) ) ; return new Create Simple Lexer ( shortcut Style Patterns , fallthrough Style Patterns ) ; }
private Level select Finest Level ( Level a , Level b ) { if ( a == null ) return b ; else if ( b == null ) return a ; else if ( b . int Value ( ) < a . int Value ( ) ) return b ; else return a ; }
static public String to Hex ( byte b ) { char hex Digit [ ] = { STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ , STR_ } ; char [ ] array = { hex Digit [ ( b > > NUM_ ) & NUM_ ] , hex Digit [ b & NUM_ ] } ; return new String ( array ) ; }
private void check Failed ( ) throws Wrong Message Digest Exception { if ( failed != null ) { Wrong Message Digest Exception exception = new Wrong Message Digest Exception ( failed ) ; logger . log ( Levels . FAILED , STR_ , exception ) ; throw exception ; } }
@ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( ! ( o instanceof Long Bit Set ) ) { return false ; } Long Bit Set other = ( Long Bit Set ) o ; if ( num Bits != other . num Bits ) { return false ; } return Arrays . equals ( bits , other . bits ) ; }
public static boolean contains ( Data Flavor [ ] array , Data Flavor flavor ) { for ( int i = NUM_ ; i < array . length ; i ++ ) { if ( flavor . equals ( array [ i ] ) ) { return true ; } } return false ; }
public static boolean is Enemy In ( I Game game , Entity entity , Coords coords , boolean only Mechs , boolean ignore Infantry , int en Low El ) { int en High El = en Low El + entity . get Height ( ) ; for ( Entity in Hex : game . get Entities Vector ( coords ) ) { int in Hex En Low El = in Hex . get Elevation ( ) ; int in Hex En High El = in Hex En Low El + in Hex . get Height ( ) ; if ( ( ! only Mechs || ( in Hex instanceof Mech ) ) && ! ( ignore Infantry && ( in Hex instanceof Infantry ) ) && in Hex . is Enemy Of ( entity ) && ! in Hex . is Making Dfa ( ) && ( en Low El <= in Hex En High El ) && ( en High El >= in Hex En Low El ) ) { return true ; } } return false ; }
public static String short Name ( String long Name ) { final String temp = long Name . replace ( DOLLAR , DOT ) ; if ( temp . contains ( DOT ) ) { return temp . substring ( temp . last Index Of ( DOT ) + NUM_ ) ; } else { return temp ; } }
private int read WS ( ) throws IO Exception { int next Char ; while ( ( next Char = read Char ( ) ) != - NUM_ && Character . is Whitespace ( ( char ) next Char ) ) { read WS = true ; } return next Char ; }
public boolean is Fusion ( ) { if ( ( engine Type == COMBUSTION ENGINE ) || ( engine Type == FISSION ) || ( engine Type == FUEL CELL ) || ( engine Type == NONE ) || ( engine Type == BATTERY ) || ( engine Type == SOLAR ) || ( engine Type == STEAM ) || ( engine Type == MAGLEV ) ) { return false ; } return true ; }
public boolean is Set Average Load ( ) { return isset bit vector . get ( AVERAGELOAD ISSET ID ) ; }
public static Tolerated Update Error parse Metadata If Tolerated Update Error ( String metadata Key , String metadata Val ) { if ( ! metadata Key . starts With ( META PRE ) ) { return null ; } final int type End = metadata Key . index Of ( STR_ , META PRE LEN ) ; if ( type End < NUM_ ) { return null ; } return new Tolerated Update Error ( Cmd Type . value Of ( metadata Key . substring ( META PRE LEN , type End ) ) , metadata Key . substring ( type End + NUM_ ) , metadata Val ) ; }
public static < T > List < T > difference ( final Collection < T > c 1 , final Collection < T > c 2 ) { if ( c 1 == null || c 1 . size ( ) == NUM_ ) { return new Array List < > ( NUM_ ) ; } if ( c 2 == null || c 2 . size ( ) == NUM_ ) { return new Array List < > ( c 1 ) ; } final List < T > difference = new Array List < > ( ) ; for ( final T current : c 1 ) { if ( ! c 2 . contains ( current ) ) { difference . add ( current ) ; } } return difference ; }
public static String random Realistic Unicode String ( Random r , int min Length , int max Length ) { final int end = next Int ( r , min Length , max Length ) ; final int block = r . next Int ( block Starts . length ) ; String Builder sb = new String Builder ( ) ; for ( int i = NUM_ ; i < end ; i ++ ) sb . append Code Point ( next Int ( r , block Starts [ block ] , block Ends [ block ] ) ) ; return sb . to String ( ) ; }
public static double random ( ) { return random . next Double ( ) ; }
public < V extends Comparable < ? super V > > Optional Double min By ( Double Function < V > key Extractor ) { Obj Double Box < V > result = collect ( null , null , null ) ; return result . a == null ? Optional Double . empty ( ) : Optional Double . of ( result . b ) ; }
final public boolean starts With Ignore Case ( final Char Sequence prefix ) { final int l = prefix . length ( ) ; if ( l > length ( ) ) return false ; int i = l ; final char [ ] a = array ; char c , d ; while ( i -- != NUM_ ) { c = Character . to Lower Case ( Character . to Upper Case ( a [ i ] ) ) ; d = Character . to Lower Case ( Character . to Upper Case ( prefix . char At ( i ) ) ) ; if ( c != d ) return false ; } return true ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public static String strip Prefix ( String value , String prefix ) { if ( value != null && prefix != null && value . starts With ( prefix ) ) { return value . substring ( prefix . length ( ) ) ; } return value ; }
public static D 3 D Surface Data create Data ( W Component Peer peer ) { D 3 D Graphics Config gc = get GC ( peer ) ; if ( gc == null || ! peer . is Accel Capable ( ) ) { return null ; } return new D 3 D Window Surface Data ( peer , gc ) ; }
public String escape ( String string ) { int length = string . length ( ) ; for ( int index = NUM_ ; index < length ; index ++ ) { if ( escape ( string . char At ( index ) ) != null ) { return escape Slow ( string , index ) ; } } return string ; }
private static final int check Max Lg Arr Longs ( Memory dst Mem ) { int pre Bytes = CONST PREAMBLE LONGS << NUM_ ; long cap = dst Mem . get Capacity ( ) ; int max Lg Arr Longs = Integer . number Of Trailing Zeros ( floor Power Of 2 ( ( int ) ( cap - pre Bytes ) ) > > > NUM_ ) ; if ( max Lg Arr Longs < MIN LG ARR LONGS ) { throw new Sketches Argument Exception ( STR_ + cap ) ; } return max Lg Arr Longs ; }
public static Number mul ( Number a , Number b ) { if ( is Floating Point ( a ) || is Floating Point ( b ) ) { return a . double Value ( ) * b . double Value ( ) ; } else { return a . long Value ( ) * b . long Value ( ) ; } }
@ Suppress Warnings ( STR_ ) public static String url Encode ( String s ) { try { return URL Encoder . encode ( s , STR_ ) ; } catch ( Unsupported Encoding Exception e ) { return URL Encoder . encode ( s ) ; } }
public boolean extract Eigenvectors ( Vec 3 result 1 , Vec 3 result 2 , Vec 3 result 3 ) { if ( result 1 == null || result 2 == null || result 3 == null ) { throw new Illegal Argument Exception ( Logger . log Message ( Logger . ERROR , STR_ , STR_ , STR_ ) ) ; } if ( this . m [ NUM_ ] != this . m [ NUM_ ] || this . m [ NUM_ ] != this . m [ NUM_ ] || this . m [ NUM_ ] != this . m [ NUM_ ] ) { return false ; } final double EPSILON = NUM_ ; final int MAX SWEEPS = NUM_ ; double m 11 = this . m [ NUM_ ] ; double m 12 = this . m [ NUM_ ] ; double m 13 = this . m [ NUM_ ] ; double m 22 = this . m [ NUM_ ] ; double m 23 = this . m [ NUM_ ] ; double m 33 = this . m [ NUM_ ] ; double [ ] [ ] r = new double [ NUM_ ] [ NUM_ ] ; r [ NUM_ ] [ NUM_ ] = r [ NUM_ ] [ NUM_ ] = r [ NUM_ ] [ NUM_ ] = NUM_ ; for ( int a = NUM_ ; a < MAX SWEEPS ; a ++ ) { if ( Math . abs ( m 12 ) < EPSILON && Math . abs ( m 13 ) < EPSILON && Math . abs ( m 23 ) < EPSILON ) { break ; } if ( m 12 != NUM_ ) { double u = ( m 22 - m 11 ) * NUM_ / m 12 ; double u 2 = u * u ; double u 2 p 1 = u 2 + NUM_ ; double t = ( u 2 p 1 != u 2 ) ? ( ( u < NUM_ ) ? - NUM_ : NUM_ ) * ( Math . sqrt ( u 2 p 1 ) - Math . abs ( u ) ) : NUM_ / u ; double c = NUM_ / Math . sqrt ( t * t + NUM_ ) ; double s = c * t ; m 11 -= t * m 12 ; m 22 += t * m 12 ; m 12 = NUM_ ; double temp = c * m 13 - s * m 23 ; m 23 = s * m 13 + c * m 23 ; m 13 = temp ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { temp = c * r [ i ] [ NUM_ ] - s * r [ i ] [ NUM_ ] ; r [ i ] [ NUM_ ] = s * r [ i ] [ NUM_ ] + c * r [ i ] [ NUM_ ] ; r [ i ] [ NUM_ ] = temp ; } } if ( m 13 != NUM_ ) { double u = ( m 33 - m 11 ) * NUM_ / m 13 ; double u 2 = u * u ; double u 2 p 1 = u 2 + NUM_ ; double t = ( u 2 p 1 != u 2 ) ? ( ( u < NUM_ ) ? - NUM_ : NUM_ ) * ( Math . sqrt ( u 2 p 1 ) - Math . abs ( u ) ) : NUM_ / u ; double c = NUM_ / Math . sqrt ( t * t + NUM_ ) ; double s = c * t ; m 11 -= t * m 13 ; m 33 += t * m 13 ; m 13 = NUM_ ; double temp = c * m 12 - s * m 23 ; m 23 = s * m 12 + c * m 23 ; m 12 = temp ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { temp = c * r [ i ] [ NUM_ ] - s * r [ i ] [ NUM_ ] ; r [ i ] [ NUM_ ] = s * r [ i ] [ NUM_ ] + c * r [ i ] [ NUM_ ] ; r [ i ] [ NUM_ ] = temp ; } } if ( m 23 != NUM_ ) { double u = ( m 33 - m 22 ) * NUM_ / m 23 ; double u 2 = u * u ; double u 2 p 1 = u 2 + NUM_ ; double t = ( u 2 p 1 != u 2 ) ? ( ( u < NUM_ ) ? - NUM_ : NUM_ ) * ( Math . sqrt ( u 2 p 1 ) - Math . abs ( u ) ) : NUM_ / u ; double c = NUM_ / Math . sqrt ( t * t + NUM_ ) ; double s = c * t ; m 22 -= t * m 23 ; m 33 += t * m 23 ; m 23 = NUM_ ; double temp = c * m 12 - s * m 13 ; m 13 = s * m 12 + c * m 13 ; m 12 = temp ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { temp = c * r [ i ] [ NUM_ ] - s * r [ i ] [ NUM_ ] ; r [ i ] [ NUM_ ] = s * r [ i ] [ NUM_ ] + c * r [ i ] [ NUM_ ] ; r [ i ] [ NUM_ ] = temp ; } } } int i 1 = NUM_ ; int i 2 = NUM_ ; int i 3 = NUM_ ; int itemp ; double temp ; if ( m 11 < m 22 ) { temp = m 11 ; m 11 = m 22 ; m 22 = temp ; itemp = i 1 ; i 1 = i 2 ; i 2 = itemp ; } if ( m 22 < m 33 ) { temp = m 22 ; m 22 = m 33 ; m 33 = temp ; itemp = i 2 ; i 2 = i 3 ; i 3 = itemp ; } if ( m 11 < m 22 ) { temp = m 11 ; m 11 = m 22 ; m 22 = temp ; itemp = i 1 ; i 1 = i 2 ; i 2 = itemp ; } result 1 . set ( r [ NUM_ ] [ i 1 ] , r [ NUM_ ] [ i 1 ] , r [ NUM_ ] [ i 1 ] ) ; result 2 . set ( r [ NUM_ ] [ i 2 ] , r [ NUM_ ] [ i 2 ] , r [ NUM_ ] [ i 2 ] ) ; result 3 . set ( r [ NUM_ ] [ i 3 ] , r [ NUM_ ] [ i 3 ] , r [ NUM_ ] [ i 3 ] ) ; result 1 . normalize ( ) ; result 2 . normalize ( ) ; result 3 . normalize ( ) ; result 1 . multiply ( m 11 ) ; result 2 . multiply ( m 22 ) ; result 3 . multiply ( m 33 ) ; return true ; }
public boolean is Src Class ( String clz ) { if ( Config . v ( ) . apk != null ) { if ( is Lib Class ( clz ) ) return false ; } return src Classes . contains ( clz ) ; }
public long weighted Size ( ) { return Math . max ( NUM_ , weighted Size . get ( ) ) ; }
public static int length ( final String value ) { validate ( value , NULL STRING PREDICATE , NULL STRING MSG SUPPLIER ) ; return value . length ( ) ; }
public static String to Code String ( Object value ) { if ( value == null ) { return STR_ ; } Type value Type = Type . for Class ( value . get Class ( ) ) ; assert Typed Operation . is Nonreceiver Type ( value Type ) : STR_ + value Type ; if ( value Type . is String ( ) ) { String escaped = String Escape Utils . escape Java ( value . to String ( ) ) ; if ( escaped . length ( ) > Gen Inputs Abstract . string maxlen ) { throw new Error ( STR_ + escaped . length ( ) ) ; } return STR_ + escaped + STR_ ; } if ( value Type . get Runtime Class ( ) . equals ( Class . class ) ) { return ( ( Class < ? > ) value ) . get Name ( ) + STR_ ; } if ( value Type . is Boxed Primitive ( ) ) { value Type = ( ( Non Parameterized Type ) value Type ) . to Primitive ( ) ; } if ( value Type . equals ( Java Types . CHAR TYPE ) ) { if ( value . equals ( STR_ ) ) { return STR_ ; } return STR_ + String Escape Utils . escape Java Style String ( value . to String ( ) , true ) + STR_ ; } if ( value Type . equals ( Java Types . BOOLEAN TYPE ) ) { return value . to String ( ) ; } String rep ; if ( value Type . equals ( Java Types . DOUBLE TYPE ) ) { Double d = ( Double ) value ; if ( d . is Na N ( ) ) { return STR_ ; } else if ( d . equals ( Double . POSITIVE INFINITY ) ) { return STR_ ; } else if ( d . equals ( Double . NEGATIVE INFINITY ) ) { return STR_ ; } rep = d . to String ( ) ; assert rep != null ; rep = rep + STR_ ; } else if ( value Type . equals ( Java Types . FLOAT TYPE ) ) { Float f = ( Float ) value ; if ( f . is Na N ( ) ) { return STR_ ; } else if ( f . equals ( Float . POSITIVE INFINITY ) ) { return STR_ ; } else if ( f == Float . NEGATIVE INFINITY ) { return STR_ ; } rep = f . to String ( ) ; assert rep != null ; rep = rep + STR_ ; } else if ( value Type . equals ( Java Types . LONG TYPE ) ) { rep = value . to String ( ) + STR_ ; } else if ( value Type . equals ( Java Types . BYTE TYPE ) ) { rep = STR_ + value . to String ( ) ; } else if ( value Type . equals ( Java Types . SHORT TYPE ) ) { rep = STR_ + value . to String ( ) ; } else if ( value Type . equals ( Java Types . INT TYPE ) ) { rep = value . to String ( ) ; } else { throw new Bug In Randoop Exception ( STR_ + value Type ) ; } if ( rep . char At ( NUM_ ) == STR_ ) { rep = STR_ + rep + STR_ ; } return rep ; }
public static int direct Blow BA Damage ( double damage , int damage Type , Battle Armor target ) { switch ( damage Type ) { case Weapon Type . WEAPON BURST 1 D 6 : damage = Compute . d 6 ( ) ; break ; case Weapon Type . WEAPON BURST 3 D 6 : damage = Compute . d 6 ( NUM_ ) ; break ; case Weapon Type . WEAPON PLASMA : if ( ! target . is Fire Resistant ( ) ) { damage = NUM_ + Compute . d 6 ( NUM_ ) ; } break ; } damage = Math . ceil ( damage ) ; return ( int ) damage ; }
private Object supress Serialization ( Object obj ) { Serializable Proxy res = new Serializable Proxy ( UUID . random UUID ( ) ) ; serialized Obj . put ( res . uuid , obj ) ; return res ; }
static public Timestamp add Minutess ( Timestamp date Time , int offset ) { if ( date Time == null ) date Time = new Timestamp ( System . current Time Millis ( ) ) ; if ( offset == NUM_ ) return date Time ; Gregorian Calendar cal = new Gregorian Calendar ( ) ; cal . set Time ( date Time ) ; cal . add ( Calendar . MINUTE , offset ) ; return new Timestamp ( cal . get Time In Millis ( ) ) ; }
protected Object new Instance ( Class c ) throws SQL Exception { try { return c . new Instance ( ) ; } catch ( Instantiation Exception e ) { throw new SQL Exception ( STR_ + c . get Name ( ) + STR_ + e . get Message ( ) ) ; } catch ( Illegal Access Exception e ) { throw new SQL Exception ( STR_ + c . get Name ( ) + STR_ + e . get Message ( ) ) ; } }
public Object key ( ) { int dr = + NUM_ ; int dc = + NUM_ ; boolean r First = true ; int d = board [ NUM_ ] [ NUM_ ] ; if ( board [ NUM_ ] [ NUM_ ] < d ) { dr = + NUM_ ; dc = - NUM_ ; d = board [ NUM_ ] [ NUM_ ] ; r First = false ; } if ( board [ NUM_ ] [ NUM_ ] < d ) { dr = - NUM_ ; dc = - NUM_ ; d = board [ NUM_ ] [ NUM_ ] ; r First = true ; } if ( board [ NUM_ ] [ NUM_ ] < d ) { dr = - NUM_ ; dc = + NUM_ ; d = board [ NUM_ ] [ NUM_ ] ; r First = false ; } String Builder sb = new String Builder ( NUM_ ) ; if ( r First ) { for ( int r = - dr + NUM_ ; dr * r <= dr + NUM_ ; r += dr ) { for ( int c = - dc + NUM_ ; dc * c <= dc + NUM_ ; c += dc ) { sb . append ( board [ r ] [ c ] ) ; } } } else { for ( int c = - dc + NUM_ ; dc * c <= dc + NUM_ ; c += dc ) { for ( int r = - dr + NUM_ ; dr * r <= dr + NUM_ ; r += dr ) { sb . append ( board [ r ] [ c ] ) ; } } } return sb . to String ( ) ; }
public static List < Nameable Object > as List ( Collection < ? extends Nameable Object > collection ) { List < Nameable Object > list = new Array List < > ( ) ; list . add All ( collection ) ; return list ; }
@ Deprecated public static int offset ( Schema sch , String fld Name ) { int pos = NUM_ ; for ( String fldname : sch . fields ( ) ) { if ( fld Name . equals ( fldname ) ) break ; pos += Page . max Size ( sch . type ( fldname ) ) ; } return pos ; }
public boolean is Running ( ) { return started ; }
byte [ ] read From Secret Store ( String filename , String data Type , AM Password password ) throws Exception { byte [ ] crypto Data = null ; File file = new File ( filename ) ; File Input Stream fis = new File Input Stream ( file ) ; Key Store store = Key Store . get Instance ( STR_ ) ; store . load ( fis , password . get Chars ( ) ) ; fis . close ( ) ; Key Store . Protection Parameter params = new Key Store . Password Protection ( password . get Chars ( ) ) ; Key Store . Secret Key Entry keyentry = ( Key Store . Secret Key Entry ) store . get Entry ( data Type , params ) ; if ( keyentry != null ) { Secret Key sdata = keyentry . get Secret Key ( ) ; crypto Data = ( byte [ ] ) sdata . get Encoded ( ) ; } return crypto Data ; }
public Set < String > key Set ( ) { synchronized ( mutex ) { return Collections . unmodifiable Set ( estimated Data . key Set ( ) ) ; } }
protected static void fail ( int exit Code ) { System . exit ( exit Code ) ; }
public static List < String > match Description Classes ( String desc ) { String pattern = STR_ ; Pattern pat = Pattern . compile ( pattern ) ; Matcher m = pat . matcher ( desc ) ; List < String > matches = new Array List < String > ( ) ; while ( m . find ( ) ) { matches . add ( m . group ( ) ) ; } return matches ; }
public static boolean contains Type Parameter ( Type type ) { if ( type . is Type Parameter ( ) ) return true ; for ( Type pt : type . get Type Argument List ( ) ) { if ( contains Type Parameter ( pt ) ) { return true ; } } if ( type . is Intersection ( ) ) { List < Type > types = type . get Satisfied Types ( ) ; for ( int i = NUM_ , l = types . size ( ) ; i < l ; i ++ ) { if ( contains Type Parameter ( types . get ( i ) ) ) return true ; } return false ; } if ( type . is Union ( ) ) { List < Type > types = type . get Case Types ( ) ; for ( int i = NUM_ , l = types . size ( ) ; i < l ; i ++ ) { if ( contains Type Parameter ( types . get ( i ) ) ) return true ; } return false ; } return false ; }
protected int default Maximum Allowed Character ( ) { String encoding = format . get Encoding ( ) ; if ( encoding != null ) { if ( encoding . equals ( STR_ ) ) { return NUM_ ; } } return - NUM_ ; }
public static boolean is Chart By Distance ( Context context ) { return CHART X AXIS DEFAULT . equals ( get String ( context , R . string . chart x axis key , CHART X AXIS DEFAULT ) ) ; }
public static double calculate Row Total ( Values 2 D data , int row , int [ ] valid Cols ) { Param Checks . null Not Permitted ( data , STR_ ) ; double total = NUM_ ; int col Count = data . get Column Count ( ) ; for ( int v = NUM_ ; v < valid Cols . length ; v ++ ) { int col = valid Cols [ v ] ; if ( col < col Count ) { Number n = data . get Value ( row , col ) ; if ( n != null ) { total += n . double Value ( ) ; } } } return total ; }
public String product Name ( ) { return properties . get Property ( STR_ ) ; }
private boolean try To Ensure Number Of Bytes In Buffer ( int min Capacity ) throws IO Exception { while ( buffer . size ( ) <= min Capacity && ! eof ) { eof = in Channel . read ( read Buffer ) == - NUM_ ; read Buffer . flip ( ) ; buffer = buffer . concat ( Byte String . copy From ( read Buffer ) ) ; read Buffer . clear ( ) ; } return buffer . size ( ) >= min Capacity ; }
public Pla Direction add ( Pla Direction p other ) { long new x = dir x + p other . dir x ; long new y = dir y + p other . dir y ; return new Pla Direction ( Big Integer . value Of ( new x ) , Big Integer . value Of ( new y ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public final Char Sequence next Token ( Char Sequence csq , Char Set char Set ) { int n = csq . length ( ) ; for ( int i = index ; i < n ; i ++ ) { if ( ! char Set . contains ( csq . char At ( i ) ) ) { int j = i ; for ( ; ( ++ j < n ) && ! char Set . contains ( csq . char At ( j ) ) ; ) { } index = j ; return csq . sub Sequence ( i , j ) ; } } index = n ; return null ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return result . elements ( ) ; }
public int hash Code ( ) { if ( Thread . interrupted ( ) ) throw new Runtime Exception ( ) ; int acc = NUM_ ; int c = NUM_ ; c = op . ordinal ( ) ; acc = acc * NUM_ + c ; c = low ; acc = acc * NUM_ + c ; c = high ; acc = acc * NUM_ + c ; if ( lit == null ) { acc *= NUM_ ; } else { acc = acc * NUM_ + lit . hash Code ( ) ; } if ( unary Arg == null ) { acc *= NUM_ ; } else { acc = acc * NUM_ + unary Arg . hash Code ( ) ; } if ( cats == null ) { acc *= NUM_ ; } else { acc = acc * NUM_ + cats . hash Code ( ) ; } if ( alts == null ) { acc *= NUM_ ; } else { acc = acc * NUM_ + alts . hash Code ( ) ; } if ( str Op == null ) { acc *= NUM_ ; } else { acc = acc * NUM_ + str Op . hash Code ( ) ; } return acc ; }
private boolean is Accelerating ( Sensor Event event ) { float ax = event . values [ NUM_ ] ; float ay = event . values [ NUM_ ] ; float az = event . values [ NUM_ ] ; final double magnitude = Math . sqrt ( ax * ax + ay * ay + az * az ) ; return magnitude > ACCELERATION THRESHOLD ; }
public boolean finished ( ) { synchronized ( finished ) { return finished . cardinality ( ) == workers . length ; } }
public List < Edge > incoming Edges ( Method Or Method Context momc ) { List < Edge > edges = new Linked List < Edge > ( ) ; Iterator < Edge > it = call Graph . edges Into ( momc ) ; while ( it . has Next ( ) ) edges . add ( it . next ( ) ) ; return edges ; }
private int utf Length ( String s ) { int len = s . length ( ) ; int utf Len = NUM_ ; for ( int off = NUM_ ; off < len ; ) { int size = Math . min ( len - off , CHAR BUF SIZE ) ; s . get Chars ( off , off + size , cbuf , NUM_ ) ; for ( int pos = NUM_ ; pos < size ; pos ++ ) { char c = cbuf [ pos ] ; if ( c >= NUM_ && c <= NUM_ ) utf Len ++ ; else utf Len += c > NUM_ ? NUM_ : NUM_ ; } off += size ; } return utf Len ; }
public static List < Cookie > parse All ( Http Url url , Headers headers ) { List < String > cookie Strings = headers . values ( STR_ ) ; List < Cookie > cookies = null ; for ( int i = NUM_ , size = cookie Strings . size ( ) ; i < size ; i ++ ) { Cookie cookie = Cookie . parse ( url , cookie Strings . get ( i ) ) ; if ( cookie == null ) continue ; if ( cookies == null ) cookies = new Array List < > ( ) ; cookies . add ( cookie ) ; } return cookies != null ? Collections . unmodifiable List ( cookies ) : Collections . < Cookie > empty List ( ) ; }
public String preview Next Char ( ) { if ( position < text . length ( ) ) { return text . substring ( position , position + NUM_ ) ; } else if ( position == text . length ( ) ) { return text . substring ( NUM_ , NUM_ ) ; } return STR_ ; }
public Period multiplied By ( int scalar ) { if ( this == ZERO || scalar == NUM_ ) { return this ; } return create ( Math . multiply Exact ( years , scalar ) , Math . multiply Exact ( months , scalar ) , Math . multiply Exact ( days , scalar ) ) ; }
public boolean contains ( final Artist p ) { synchronized ( m Artists ) { return m Artists . contains ( p ) ; } }
public < V extends Comparable < ? super V > > Optional Int min By ( Int Function < V > key Extractor ) { Obj Int Box < V > result = collect ( null , null , null ) ; return result . a == null ? Optional Int . empty ( ) : Optional Int . of ( result . b ) ; }
public int capacity ( ) { return delegate . capacity ( ) ; }
public static boolean is Report Speed ( Context context ) { return STATS RATE DEFAULT . equals ( get String ( context , R . string . stats rate key , STATS RATE DEFAULT ) ) ; }
Visual Item adapt Aggregate ( Visual Item item ) { if ( item instanceof Aggregate Item ) { Visual Item [ ] proxy = { item } ; with Visual Item ( ( Aggregate Item ) item , null ) ; item = proxy [ NUM_ ] ; } return item ; }
public static String adjust Author Name ( final String author Name , String committer Name ) { if ( ! author Name . equals ( committer Name ) ) { committer Name = author Name + STR_ + committer Name ; } return committer Name ; }
boolean should EDT Sleep ( ) { Form current = impl . get Current Form ( ) ; return ( ( current == null || ( ! current . has Animations ( ) ) ) && ( animation Queue == null || animation Queue . size ( ) == NUM_ ) && input Event Stack Pointer == NUM_ && ( ! impl . has Pending Paints ( ) ) && has No Serial Calls Pending ( ) && ! key Repeat Charged && ! long Pointer Charged ) || ( is Minimized ( ) && has No Serial Calls Pending ( ) ) ; }
public I Block State with Rotation ( I Block State state , Rotation rot ) { return state . with Property ( FACING , rot . rotate ( ( Enum Facing ) state . get Value ( FACING ) ) ) ; }
static private String to 64 ( long v , int size ) { final String Buffer result = new String Buffer ( ) ; while ( -- size >= NUM_ ) { result . append ( itoa 64 . char At ( ( int ) ( v & NUM_ ) ) ) ; v >>>= NUM_ ; } return result . to String ( ) ; }
public Normalized Url normalize ( ) { return new Normalized Url ( url Marker ) ; }
public static < C > List < C > to List ( final B Op op , final Class < C > clas ) { final List < C > list = new Linked List < C > ( ) ; final Iterator < C > it = visit All ( op , clas ) ; while ( it . has Next ( ) ) { list . add ( it . next ( ) ) ; } return list ; }
default Collection < Class < ? extends Module > > overrides ( ) { return Collections . empty List ( ) ; }
public static String format ( double d , int decimals ) { double factor = Math . pow ( NUM_ , decimals ) ; double digits = Math . round ( factor * d ) ; return ( ( int ) Math . floor ( digits / factor ) ) + STR_ + ( ( int ) ( digits % factor ) ) ; }
public List < String > field Property Comment ( Field field ) { String comment Type = field Type Cardinality Comment ( field ) ; String field Name = property Name ( field ) ; return convert To Commented Block ( field Comment ( String . format ( STR_ , comment Type , field Name ) , null , field ) ) ; }
public int size ( ) { return vector List . size ( ) ; }
public Node find ( Coordinate coord ) { return ( Node ) node Map . get ( coord ) ; }
@ Not Null public static String generate Word Enumeration ( @ Not Null Collection < String > words ) { return Android Text Utils . generate Comma Separated List ( words , STR_ ) ; }
private String field Comment ( String name , String type , String param Comment ) { String comment = String . format ( STR_ , name , type ) ; if ( ! Strings . is Null Or Empty ( param Comment ) ) { if ( param Comment . char At ( param Comment . length ( ) - NUM_ ) == STR_ ) { param Comment = param Comment . substring ( NUM_ , param Comment . length ( ) - NUM_ ) ; } comment += STR_ + param Comment . replace All ( STR_ , STR_ ) ; } return comment + STR_ ; }
private boolean filter Date ( I Log Entry log Entry , Date start Date , Date end Date ) { Date date = log Entry . get Date ( ) ; if ( date == null ) { return true ; } if ( ( start Date != null ) && date . before ( start Date ) ) { return false ; } if ( ( end Date != null ) && date . after ( end Date ) ) { return false ; } return true ; }
public boolean check Big Decimal Value ( final Big Decimal obj 1 , final Big Decimal obj 2 ) { if ( obj 1 == null ) return true ; if ( obj 2 == null ) return true ; if ( obj 1 . compare To ( obj 2 ) == - NUM_ ) return false ; if ( obj 1 . compare To ( obj 2 ) == NUM_ ) return false ; return true ; }
protected boolean check Relations ( Cn A Tree Element tree Element ) { return true ; }
public static String normalize Request Uri ( Http Servlet Request http Request ) { String ret Val = http Request . get Request URI ( ) ; String context Path = http Request . get Context Path ( ) ; if ( ret Val . starts With ( context Path ) ) { ret Val = ret Val . substring ( context Path . length ( ) ) ; } String servlet Path = http Request . get Servlet Path ( ) ; if ( ret Val . starts With ( servlet Path ) ) { ret Val = ret Val . substring ( servlet Path . length ( ) ) ; } return ret Val ; }
public static String truncate ( final String string , final int max Len ) { return ( string . length ( ) <= max Len ) ? string : string . substring ( NUM_ , max Len ) ; }
public int count ( ) { return component list . size ( ) ; }
public static Accountable named Accountable ( String description , long bytes ) { return named Accountable ( description , Collections . < Accountable > empty List ( ) , bytes ) ; }
@ Override public Request Methods Request Condition combine ( Request Methods Request Condition other ) { Set < Request Method > set = new Linked Hash Set < > ( this . methods ) ; set . add All ( other . methods ) ; return new Request Methods Request Condition ( set ) ; }
public static Bytes Ref random Binary Term ( Random r ) { int length = r . next Int ( NUM_ ) ; Bytes Ref b = new Bytes Ref ( length ) ; r . next Bytes ( b . bytes ) ; b . length = length ; return b ; }
public boolean is Set ( ) { return m Parameter . size ( ) > NUM_ ; }
public boolean is Connected ( ) { return ( m Connection != null ) ; }
public static File [ ] files Over Mod Date ( File [ ] files , Interval retention ) { Array List < File > over Files = new Array List < File > ( ) ; long now = System . current Time Millis ( ) ; for ( File file : files ) { long mod Date = file . last Modified ( ) ; if ( mod Date > NUM_ && retention . over Interval ( mod Date , now ) ) over Files . add ( file ) ; } File [ ] file Array = new File [ over Files . size ( ) ] ; return over Files . to Array ( file Array ) ; }
private int next Int ( double the Mean ) { double xm = the Mean ; double g = this . cached g ; if ( xm == - NUM_ ) return NUM_ ; if ( xm < SWITCH MEAN ) { int poisson = - NUM_ ; double product = NUM_ ; do { poisson ++ ; product *= random Generator . raw ( ) ; } while ( product >= g ) ; return poisson ; } else if ( xm < MEAN MAX ) { double t ; double em ; double sq = this . cached sq ; double alxm = this . cached alxm ; Random Engine rand = this . random Generator ; do { double y ; do { y = Math . tan ( Math . PI * rand . raw ( ) ) ; em = sq * y + xm ; } while ( em < NUM_ ) ; em = ( double ) ( int ) ( em ) ; t = NUM_ * ( NUM_ + y * y ) * Math . exp ( em * alxm - log Gamma ( em + NUM_ ) - g ) ; } while ( rand . raw ( ) > t ) ; return ( int ) em ; } else { return ( int ) xm ; } }
public byte [ ] encode ( ) { char data Length = get Data Length ( ) ; char type = get Attribute Type ( ) ; byte binary [ ] = new byte [ HEADER LENGTH + data Length + ( padding ? ( ( NUM_ - data Length % NUM_ ) % NUM_ ) : NUM_ ) ] ; binary [ NUM_ ] = ( byte ) ( type > > NUM_ ) ; binary [ NUM_ ] = ( byte ) ( type & NUM_ ) ; binary [ NUM_ ] = ( byte ) ( data Length > > NUM_ ) ; binary [ NUM_ ] = ( byte ) ( data Length & NUM_ ) ; System . arraycopy ( data , NUM_ , binary , NUM_ , data Length ) ; return binary ; }
public static boolean is Negative ( Query q ) { if ( ! ( q instanceof Boolean Query ) ) return false ; Boolean Query bq = ( Boolean Query ) q ; Collection < Boolean Clause > clauses = bq . clauses ( ) ; if ( clauses . size ( ) == NUM_ ) return false ; for ( Boolean Clause clause : clauses ) { if ( ! clause . is Prohibited ( ) ) return false ; } return true ; }
public static String to Number ( double number ) { String str = ( is Float Precision ) ? Float . to String ( ( float ) number ) : Double . to String ( number ) ; if ( str . ends With ( STR_ ) ) { str = str . substring ( NUM_ , str . length ( ) - NUM_ ) ; } return str ; }
private String z Get Standard Text Field Time String ( Local Time time ) { String standard Time String = STR_ ; if ( time == null ) { return standard Time String ; } standard Time String = time . format ( settings . get Format For Display Time ( ) ) ; return standard Time String ; }
String encoded Username ( ) { if ( username . is Empty ( ) ) return STR_ ; int username Start = scheme . length ( ) + NUM_ ; int username End = delimiter Offset ( url , username Start , url . length ( ) , STR_ ) ; return url . substring ( username Start , username End ) ; }
public String clusterer Tip Text ( ) { return STR_ ; }
public boolean contains Explicit Char ( final @ Non Null Char Sequence input ) { if ( ! Text Utils . is Empty ( input ) ) { for ( int i = NUM_ ; i < input . length ( ) ; i ++ ) { char c = input . char At ( i ) ; if ( is Explicit Char ( c ) ) { return true ; } } } return false ; }
public Dimension minimum Layout Size ( Container parent ) { return new Dimension ( NUM_ , NUM_ ) ; }
public static Time Range unbounded ( ) { return UNBOUNDED ; }
public static List < String > command Lines ( List < Evaluation Statistics > stats , boolean sort ) { List < String > result ; result = new Array List < > ( ) ; for ( Evaluation Statistics stat : stats ) { if ( ! result . contains ( stat . get Command Line ( ) ) ) result . add ( stat . get Command Line ( ) ) ; } if ( sort ) Collections . sort ( result ) ; return result ; }
public Iterator < String > find Attributes ( ) { Set < String > attrs ; if ( attributes == null ) attrs = Collections . empty Set ( ) ; else attrs = attributes . key Set ( ) ; return attrs . iterator ( ) ; }
public String create Hash ( String password ) { return create Hash ( password . to Char Array ( ) ) ; }
public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
public mx Rectangle process Changes ( List < mx Undoable Change > changes , boolean invalidate , boolean ignore Dirty ) { return process Changes ( changes , invalidate , ignore Dirty , null ) ; }
public Collection engine Generate Certificates ( Input Stream in Stream ) throws Certificate Exception { java . security . cert . Certificate cert ; List certs = new Array List ( ) ; while ( ( cert = engine Generate Certificate ( in Stream ) ) != null ) { certs . add ( cert ) ; } return certs ; }
private boolean is Translateable ( String source Word ) { return Token Utils . is Numeric Or Punctuation Or Symbols ( source Word ) || Token Utils . is URL ( source Word ) ; }
protected boolean conversion Requires Narrowing ( Type Mirror var Type , Node node ) { Type Mirror unboxed Var Type = Types Utils . is Boxed Primitive ( var Type ) ? types . unboxed Type ( var Type ) : var Type ; Type Kind unboxed Var Kind = unboxed Var Type . get Kind ( ) ; boolean is Left Narrowable To = unboxed Var Kind == Type Kind . BYTE || unboxed Var Kind == Type Kind . SHORT || unboxed Var Kind == Type Kind . CHAR ; boolean is Right Constant = node instanceof Value Literal Node ; return is Left Narrowable To && is Right Constant ; }
protected Big Integer freq ( String [ ] a Words ) { Big Integer total = Big Integer . value Of ( NUM_ ) ; for ( N Gram Model gram : finder . find ( a Words ) ) { total = total . add ( Big Integer . value Of ( gram . get Freq ( ) ) ) ; } return total ; }
public Double Stream Ex remove ( Double Predicate predicate ) { return filter ( predicate . negate ( ) ) ; }
public E sample ( Random rand ) { double total = total Count ( ) ; if ( total <= NUM_ ) { throw new Runtime Exception ( String . format ( STR_ , total ) ) ; } double sum = NUM_ ; double r = rand . next Double ( ) ; for ( Map . Entry < E , Double > entry : entries . entry Set ( ) ) { double count = entry . get Value ( ) ; double frac = count / total ; sum += frac ; if ( r < sum ) { return entry . get Key ( ) ; } } throw new Illegal State Exception ( STR_ ) ; }
public String password ( ) { return cfg . get ( port Name ( ) + STR_ ) ; }
public double [ ] coefficients ( ) { double [ ] coefficients = new double [ m Selected Attributes . length + NUM_ ] ; int counter = NUM_ ; for ( int i = NUM_ ; i < m Selected Attributes . length ; i ++ ) { if ( ( m Selected Attributes [ i ] ) && ( ( i != m Class Index ) ) ) { coefficients [ i ] = m Coefficients [ counter ++ ] ; } } coefficients [ m Selected Attributes . length ] = m Coefficients [ counter ] ; return coefficients ; }
public static double next After ( final double start , final double direction ) { if ( Double . is Na N ( start ) || Double . is Na N ( direction ) ) { return Double . Na N ; } if ( start == direction ) { return direction ; } final double abs Start = Math . abs ( start ) ; final double abs Dir = Math . abs ( direction ) ; final boolean to Zero = ! is Same Sign ( start , direction ) || abs Dir < abs Start ; if ( to Zero ) { if ( abs Start == Double . MIN VALUE ) { return copy Sign ( NUM_ , start ) ; } if ( Double . is Infinite ( abs Start ) ) { return copy Sign ( Double . MAX VALUE , start ) ; } return copy Sign ( Double . long Bits To Double ( Double . double To Long Bits ( abs Start ) - NUM_ ) , start ) ; } else { if ( start == NUM_ ) { return copy Sign ( Double . MIN VALUE , direction ) ; } if ( abs Start == Double . MAX VALUE ) { return copy Sign ( Double . POSITIVE INFINITY , start ) ; } return copy Sign ( Double . long Bits To Double ( Double . double To Long Bits ( abs Start ) + NUM_ ) , start ) ; } }
public static Runtime Exception rewrap And Throw Unchecked Exception ( Throwable ex ) { throw rewrap And Throw Unchecked Exception ( ex . get Message ( ) , ex ) ; }
public cc Quad 3 original Tile ( cc Grid Size pos ) { int idx = ( grid Size . y * pos . x + pos . y ) * cc Quad 3 . size ; float [ ] vert Array = new float [ cc Quad 3 . size ] ; for ( int i = NUM_ ; i < cc Quad 3 . size ; i ++ ) { vert Array [ i ] = original Vertices . get ( idx + i ) ; } return new cc Quad 3 ( vert Array ) ; }
public void verify Nfs AC Ls ( Nfs ACL Update Params param ) { List < Nfs ACE > add List = param . get Aces To Add ( ) ; List < Nfs ACE > modify List = param . get Aces To Modify ( ) ; List < Nfs ACE > delete List = param . get Aces To Delete ( ) ; List < NFS Share ACL > db ACL List = query DBS File Nfs AC Ls ( false ) ; Set < String > user Set DB = new Hash Set < String > ( ) ; for ( NFS Share ACL db Acl : db ACL List ) { user Set DB . add ( db Acl . get User ( ) ) ; } if ( add List != null && ! add List . is Empty ( ) ) { verify Nfs AC Ls Add List ( add List , user Set DB ) ; } if ( modify List != null && ! modify List . is Empty ( ) ) { verify Nfs AC Ls Modify Or Delete List ( modify List , user Set DB ) ; } if ( delete List != null && ! delete List . is Empty ( ) ) { verify Nfs AC Ls Modify Or Delete List ( delete List , user Set DB ) ; } }
public List < Edge > outgoing Edges ( Method Or Method Context momc , Stmt stmt ) { List < Edge > edges = new Linked List < Edge > ( ) ; Iterator < Edge > it = call Graph . edges Out Of ( momc ) ; while ( it . has Next ( ) ) { Edge e = it . next ( ) ; if ( stmt . equals ( e . src Stmt ( ) ) ) edges . add ( e ) ; } return edges ; }
public boolean is Show Normal Functions ( ) { return m normal Function Checkbox . is Selected ( ) ; }
public boolean is Enabled ( ) { return log Status ; }
public int hash Code ( ) { int retval = NUM_ ; int len = available ( ) ; int p = pos ; for ( int i = NUM_ ; i < len ; i ++ ) retval += buf [ p + i ] * i ; return retval ; }
public static Number convert To Number ( String str ) { if ( str == null ) { return null ; } str = str . trim ( ) ; if ( str . length ( ) == NUM_ ) { return null ; } if ( str . index Of ( STR_ ) >= NUM_ || str . index Of ( STR_ ) >= NUM_ || str . index Of ( STR_ ) >= NUM_ ) { return Double . value Of ( str ) ; } try { long lval = Long . parse Long ( str ) ; if ( lval == ( int ) lval ) { return new Integer ( ( int ) lval ) ; } return new Long ( lval ) ; } catch ( Number Format Exception ee ) { return new java . math . Big Integer ( str , NUM_ ) ; } }
public static double max ( Array array ) throws Page Exception { if ( array . get Dimension ( ) > NUM_ ) throw new Expression Exception ( STR_ ) ; if ( array . size ( ) == NUM_ ) return NUM_ ; double rtn = to Double Value ( array , NUM_ ) ; int len = array . size ( ) ; try { for ( int i = NUM_ ; i <= len ; i ++ ) { double v = to Double Value ( array , i ) ; if ( rtn < v ) rtn = v ; } } catch ( Page Exception e ) { throw new Expression Exception ( STR_ + e . get Message ( ) ) ; } return rtn ; }
public Flux Merge < T > merge Additional Source ( Publisher < ? extends T > source , Int Function < Supplier < ? extends Queue < T > > > new Queue Supplier ) { int n = sources . length ; @ Suppress Warnings ( STR_ ) Publisher < ? extends T > [ ] new Array = new Publisher [ n + NUM_ ] ; System . arraycopy ( sources , NUM_ , new Array , NUM_ , n ) ; new Array [ n ] = source ; Supplier < ? extends Queue < T > > new Main Queue ; int mc = max Concurrency ; if ( mc != Integer . MAX VALUE ) { mc ++ ; new Main Queue = new Queue Supplier . apply ( mc ) ; } else { new Main Queue = main Queue Supplier ; } return new Flux Merge < > ( new Array , delay Error , mc , new Main Queue , prefetch , inner Queue Supplier ) ; }
static double distance ( I Point p 1 , I Point p 2 ) { return Math . sqrt ( ( p 1 . get X ( ) - p 2 . get X ( ) ) * ( p 1 . get X ( ) - p 2 . get X ( ) ) + ( p 1 . get Y ( ) - p 2 . get Y ( ) ) * ( p 1 . get Y ( ) - p 2 . get Y ( ) ) ) ; }
private Node < K , V > find Predecessor ( Object key , Comparator < ? super K > cmp ) { if ( key == null ) throw new Null Pointer Exception ( ) ; for ( ; ; ) { for ( Index < K , V > q = head , r = q . right , d ; ; ) { if ( r != null ) { Node < K , V > n = r . node ; K k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( cpr ( cmp , key , k ) > NUM_ ) { q = r ; r = r . right ; continue ; } } if ( ( d = q . down ) == null ) return q . node ; q = d ; r = d . right ; } } }
public int hash Code ( ) { return user . hash Code ( ) ; }
public int y ( double lat ) { return ( int ) Math . round ( dots Per Deg * ( origin Lat - lat ) ) ; }
private boolean wait Time Expired ( long start ) { return ( System . current Time Millis ( ) - start ) > conf . basic . max Wait Time ; }
public static boolean service Has Sub Schema ( SSO Token token , String service Name , Schema Type schema Type ) throws SMS Exception , SSO Exception { boolean schema Type Flg = false ; try { Service Schema Manager ssm = new Service Schema Manager ( service Name , token ) ; Set types = ssm . get Schema Types ( ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ + service Name + STR_ + types ) ; } schema Type Flg = types . contains ( schema Type ) ; } catch ( Service Not Found Exception ex ) { if ( debug . warning Enabled ( ) ) { debug . warning ( STR_ + STR_ + service Name ) ; } } return ( schema Type Flg ) ; }
@ Override public int hash Code ( ) { int hash = ( ( time . to Second Of Day ( ) + ( time End Of Day ? NUM_ : NUM_ ) ) << NUM_ ) + ( month . ordinal ( ) << NUM_ ) + ( ( dom + NUM_ ) << NUM_ ) + ( ( dow == null ? NUM_ : dow . ordinal ( ) ) << NUM_ ) + ( time Definition . ordinal ( ) ) ; return hash ^ standard Offset . hash Code ( ) ^ offset Before . hash Code ( ) ^ offset After . hash Code ( ) ; }
private boolean is Conflict ( String coordinate , String direct Version , String indirect Version ) { boolean is Conflict = LATEST VERSION COMPARATOR . compare ( direct Version , indirect Version ) < NUM_ ; if ( is Conflict ) { Set < String > ignored Versions = ignore Conflict Versions . get ( coordinate ) ; if ( null != ignored Versions && ignored Versions . contains ( indirect Version ) ) { is Conflict = false ; } } return is Conflict ; }
public static < S , K , M extends Map < K , S > > Collector < S , ? , M > to Dictionary ( Function < ? super S , ? extends K > key Mapper , Supplier < M > map Supplier ) { return Collectors . to Map ( key Mapper , Function . identity ( ) , Stream Utils . throwing Merger ( ) , map Supplier ) ; }
public final int last Index Of ( char c , int from Index ) { if ( ( offset + from Index ) >= ( offset + length ) ) throw new Index Out Of Bounds Exception ( String . format ( STR_ , from Index ) ) ; for ( int i = offset + from Index , end = offset ; i >= end ; i -- ) { if ( array [ i ] == c ) return i - offset ; } return - NUM_ ; }
@ Override public int locations ( ) { int ret Val = Math . round ( get Troopers ( ) ) ; if ( ret Val == NUM_ ) { if ( ! is Initialized ) { ret Val = NUM_ + NUM_ ; } else if ( is Clan ( ) ) { ret Val = NUM_ + NUM_ ; } else { ret Val = NUM_ + NUM_ ; } } else { ret Val ++ ; } return ret Val ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public Text Character without Modifier ( SGR modifier ) { if ( ! modifiers . contains ( modifier ) ) { return this ; } Enum Set < SGR > new Set = Enum Set . copy Of ( this . modifiers ) ; new Set . remove ( modifier ) ; return new Text Character ( character , foreground Color , background Color , new Set ) ; }
public Path Impl lookup ( String user Path , Map < String , Object > new Attributes ) { if ( new Attributes != null ) { return lookup Impl ( user Path , new Attributes , true ) ; } else if ( user Path == null ) { return this ; } Path Impl path = get Cache ( user Path ) ; if ( path != null ) { return path ; } path = lookup Impl ( user Path , null , true ) ; if ( start Time == NUM_ ) { start Time = System . current Time Millis ( ) ; put Cache ( user Path , path ) ; } return path ; }
public static long max Fill ( final long n , final float f ) { return Math . min ( ( long ) Math . ceil ( n * f ) , n - NUM_ ) ; }
public String build Jvm Version ( ) { return properties . get Property ( STR_ ) ; }
public String last String ( ) { return current ; }
public boolean is Show Bootpath ( ) { return true ; }
@ Override public Enumeration list Options ( ) { Vector new Vector = new Vector ( ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
private boolean next String ( int state , int position ) { int c = NUM_ ; if ( position < seek Bytes Ref . length ( ) ) { c = seek Bytes Ref . byte At ( position ) & NUM_ ; if ( c ++ == NUM_ ) return false ; } seek Bytes Ref . set Length ( position ) ; visited [ state ] = cur Gen ; final int num Transitions = automaton . get Num Transitions ( state ) ; automaton . init Transition ( state , transition ) ; for ( int i = NUM_ ; i < num Transitions ; i ++ ) { automaton . get Next Transition ( transition ) ; if ( transition . max >= c ) { int next Char = Math . max ( c , transition . min ) ; seek Bytes Ref . grow ( seek Bytes Ref . length ( ) + NUM_ ) ; seek Bytes Ref . append ( ( byte ) next Char ) ; state = transition . dest ; while ( visited [ state ] != cur Gen && ! run Automaton . is Accept ( state ) ) { visited [ state ] = cur Gen ; automaton . init Transition ( state , transition ) ; automaton . get Next Transition ( transition ) ; state = transition . dest ; seek Bytes Ref . grow ( seek Bytes Ref . length ( ) + NUM_ ) ; seek Bytes Ref . append ( ( byte ) transition . min ) ; if ( ! finite && ! linear && visited [ state ] == cur Gen ) { set Linear ( seek Bytes Ref . length ( ) - NUM_ ) ; } } return true ; } } return false ; }
boolean should Disk Name Be Visible ( String disk Name ) { return disk Name . starts With ( m File Prefix ) ; }
@ Override public Enumeration < String > enumerate Measures ( ) { Vector < String > new Vector = new Vector < String > ( NUM_ ) ; new Vector . add Element ( STR_ ) ; new Vector . add Element ( STR_ ) ; return new Vector . elements ( ) ; }
public static String hex Bytes To String ( String hex String ) { String Builder output = new String Builder ( ) ; for ( int i = NUM_ ; i < hex String . length ( ) ; i += NUM_ ) { String str = hex String . substring ( i , i + NUM_ ) ; output . append ( ( char ) Integer . parse Int ( str , NUM_ ) ) ; } return output . to String ( ) ; }
public boolean is Bordered ( ) { return modifiers . contains ( SGR . BORDERED ) ; }
public final int last common layer ( Brd Item p other ) { int max first layer = Math . max ( first layer ( ) , p other . first layer ( ) ) ; int min last layer = Math . min ( last layer ( ) , p other . last layer ( ) ) ; if ( max first layer > min last layer ) return - NUM_ ; return min last layer ; }
public int hash Code ( ) { int retval = alg . hash Code ( ) ; retval ^= max Key Size ; if ( exemption Mechanism != null ) { retval ^= exemption Mechanism . hash Code ( ) ; } if ( check Param ) retval ^= NUM_ ; if ( alg Param Spec != null ) { retval ^= alg Param Spec . hash Code ( ) ; } return retval ; }
public static byte [ ] random Salt ( ) { byte [ ] salt = new byte [ SALT LENGTH ] ; secure Random . next Bytes ( salt ) ; return salt ; }
public String to Clock ( ) { String Builder s = new String Builder ( ) ; s . append ( ( ( this . weeks * NUM_ + this . days ) * NUM_ + this . hours ) + STR_ ) ; if ( this . minutes < NUM_ ) { s . append ( STR_ ) ; } s . append ( this . minutes + STR_ ) ; if ( this . seconds < NUM_ ) { s . append ( STR_ ) ; } s . append ( this . seconds + STR_ ) ; if ( this . milliseconds < NUM_ ) { s . append ( STR_ ) ; } if ( this . milliseconds < NUM_ ) { s . append ( STR_ ) ; } s . append ( this . milliseconds ) ; return s . to String ( ) ; }
public static double pt Line Dist ( double x 1 , double y 1 , double x 2 , double y 2 , double px , double py ) { return Math . sqrt ( pt Line Dist Sq ( x 1 , y 1 , x 2 , y 2 , px , py ) ) ; }
private static Char Handler parse International Codes ( String [ ] code Strings ) { if ( code Strings . length != NUM_ ) { throw new Illegal State Exception ( STR_ + Arrays . as List ( code Strings ) ) ; } return new International Char Handler ( codes To Bytes ( code Strings [ NUM_ ] , true ) , codes To Bytes ( code Strings [ NUM_ ] , true ) ) ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; return new Vector . elements ( ) ; }
public String poll ( long timeout ) throws Interrupted Exception { last Time Millis = System . current Time Millis ( ) ; String result = STR_ ; synchronized ( this ) { if ( buffer . length ( ) == NUM_ ) { wait ( timeout ) ; } if ( buffer . length ( ) > NUM_ ) { result = STR_ + buffer . to String ( ) + STR_ ; buffer = new String Buffer ( ) ; } notify ( ) ; } return result ; }
public void enter Slave Mode ( ) { Core Cmd ccmd = get Queue . peek ( ) ; while ( ccmd != null ) { ccmd = get Queue . remove ( ) ; ccmd . update ( Command . STATUS SLAVE MODE , cmember . leader Id ) ; ccmd = get Queue . peek ( ) ; } }
public static synchronized Data Source Window Manager shared Instance ( ) { if ( shared Instance == null ) shared Instance = new Data Source Window Manager ( ) ; return shared Instance ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + JSON Loader . FILE EXTENSION COMPRESSED + STR_ + JSON Loader . FILE EXTENSION + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public boolean field Is Final ( ) { return Modifier . is Final ( field . get Modifiers ( ) ) ; }
protected static String branch String ( Dalv Insn insn ) { Target Insn ti = ( Target Insn ) insn ; int address = ti . get Target Address ( ) ; return ( address == ( char ) address ) ? Hex . u 2 ( address ) : Hex . u 4 ( address ) ; }
public long nanos Elapsed ( ) { return System . nano Time ( ) - start Time Nanos ; }
@ Override protected final double black Vol Impl ( final double maturity , final double strike ) { double non Zero Maturity ; final double m = maturity ; if ( m == NUM_ ) { non Zero Maturity = NUM_ ; } else { non Zero Maturity = m ; } final double var = black Variance Impl ( non Zero Maturity , strike ) ; return Math . sqrt ( var / non Zero Maturity ) ; }
default Field Declaration as Field ( ) { throw new Unsupported Operation Exception ( String . format ( STR_ , this ) ) ; }
public Charset charset ( ) { return Text Utils . is Empty ( charset ) ? null : Charset . for Name ( charset ) ; }
public String to Plain ( ) { String Buffer sb = new String Buffer ( ) ; int length = size ( ) ; for ( int i = NUM_ ; i <= length ; i ++ ) { sb . append ( i ) ; sb . append ( STR_ ) ; sb . append ( get ( i - NUM_ , null ) ) ; sb . append ( STR_ ) ; } return sb . to String ( ) ; }
public < X extends Throwable > int or Else Throw ( Supplier < X > exception Supplier ) throws X { if ( is Present ) { return value ; } else { throw exception Supplier . get ( ) ; } }
public static double float To Double Upper ( float f ) { if ( Float . is Na N ( f ) ) { return Double . Na N ; } if ( Float . is Infinite ( f ) ) { if ( f > NUM_ ) { return Double . POSITIVE INFINITY ; } else { return Double . long Bits To Double ( NUM_ ) ; } } long bits = Double . double To Raw Long Bits ( ( double ) f ) ; if ( ( bits & NUM_ ) == NUM_ ) { if ( bits == NUM_ ) { return Double . long Bits To Double ( NUM_ ) ; } if ( f == Float . MIN VALUE ) { return Double . long Bits To Double ( NUM_ ) ; } if ( Float . MIN NORMAL > f && f >= Double . MIN NORMAL ) { final long bits 2 = Double . double To Raw Long Bits ( ( double ) Math . next Up ( f ) ) ; bits = ( bits > > > NUM_ ) + ( bits 2 > > > NUM_ ) - NUM_ ; } else { bits += NUM_ ; } return Double . long Bits To Double ( bits ) ; } else { if ( bits == NUM_ ) { return - NUM_ ; } if ( f == - Float . MIN VALUE ) { return Double . long Bits To Double ( NUM_ ) ; } if ( - Float . MIN NORMAL < f && f <= - Double . MIN NORMAL ) { final long bits 2 = Double . double To Raw Long Bits ( ( double ) Math . next Up ( f ) ) ; bits = ( bits > > > NUM_ ) + ( bits 2 > > > NUM_ ) + NUM_ ; } else { bits -= NUM_ ; } return Double . long Bits To Double ( bits ) ; } }
public static Date date ( final String imm Code ) { return date ( imm Code , new Date ( ) ) ; }
public boolean has Genome ( String genome ) { return m Genomes . contains ( genome ) ; }
public static boolean is Variable ( String expression ) { return expression . starts With ( PREFIX ) ; }
public int hash Code ( ) { int result = NUM_ ; if ( is Destroyed ( ) ) { return result ; } result = NUM_ * result + Arrays . hash Code ( get Encoded ( ) ) ; result = NUM_ * result + get Key Type ( ) ; if ( principal != null ) { result = NUM_ * result + principal . hash Code ( ) ; } return result * NUM_ + version Num ; }
public String read Config Name ( Solr Zk Client zk Client , String collection ) throws Keeper Exception , Interrupted Exception { if ( collection == null ) { throw new Illegal Argument Exception ( STR_ ) ; } String config Name = null ; byte [ ] alias Data = zk Client . get Data ( Zk State Reader . ALIASES , null , null , true ) ; Aliases aliases = Cluster State . load ( alias Data ) ; String alias = aliases . get Collection Alias ( collection ) ; if ( alias != null ) { List < String > alias List = Str Utils . split Smart ( alias , STR_ , true ) ; if ( alias List . size ( ) > NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } collection = alias List . get ( NUM_ ) ; } String path = Zk State Reader . COLLECTIONS ZKNODE + STR_ + collection ; if ( LOG . is Info Enabled ( ) ) { LOG . info ( STR_ + path ) ; } byte [ ] data = zk Client . get Data ( path , null , null , true ) ; if ( data != null ) { Zk Node Props props = Zk Node Props . load ( data ) ; config Name = props . get Str ( Zk Controller . CONFIGNAME PROP ) ; } if ( config Name != null && ! zk Client . exists ( Zk Controller . CONFIGS ZKNODE + STR_ + config Name , true ) ) { LOG . error ( STR_ + config Name ) ; throw new Illegal Argument Exception ( STR_ + config Name ) ; } return config Name ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ + STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
protected Two Level Expandable Adapter ( List < T > data , List < Boolean > state ) { full Data = data ; data List = new Array List < > ( ) ; is Open = new Array List < > ( state ) ; for ( int i = NUM_ ; i < full Data . size ( ) ; i ++ ) { T header Group = full Data . get ( i ) ; data List . add ( new Data Holder ( header Group . get Data ( ) , Item Type . HEADER ) ) ; if ( is Open . get ( i ) ) { for ( Object item : header Group . get Children ( ) ) { data List . add ( new Data Holder ( item , Item Type . ITEM ) ) ; } } } }
public synchronized static boolean is Desktop Supported ( ) { if ( ! desktop Supported Initialized ) { desktop Supported = Desktop . is Desktop Supported ( ) ; desktop Supported Initialized = true ; } return desktop Supported ; }
public void wait For Response ( int timeout Sec ) throws Exception { if ( future Response == null ) { throw new Coded Exception ( X INTERNAL ERROR , STR_ ) ; } LOG . trace ( STR_ ) ; try { Http Response response = future Response . get ( timeout Sec , Time Unit . SECONDS ) ; handle Response ( response ) ; } catch ( Timeout Exception e ) { cancel Request ( ) ; throw new Coded Exception ( X NETWORK ERROR , STR_ ) ; } catch ( Exception e ) { handle Failure ( e ) ; } finally { future Response = null ; Performance Logger . log ( LOG , STR_ ) ; } }
public boolean has Scrolled ( ) { return this . scroll != NUM_ ; }
private static < E > Object [ ] remove Dupes ( Object [ ] array , Comparator < ? super E > comparator ) { int size = NUM_ ; for ( int i = NUM_ ; i < array . length ; i ++ ) { Object element = array [ i ] ; if ( unsafe Compare ( comparator , array [ size - NUM_ ] , element ) != NUM_ ) { array [ size ] = element ; size ++ ; } } if ( size == array . length ) { return array ; } else { Object [ ] copy = new Object [ size ] ; System . arraycopy ( array , NUM_ , copy , NUM_ , size ) ; return copy ; } }
private byte [ ] windows Absolute Path ( ) { Byte Array Output Stream bstream = new Byte Array Output Stream ( ) ; bstream . write ( WINDOWS ROOT PATH , NUM_ , WINDOWS ROOT PATH . length - NUM_ ) ; String Tokenizer tokenizer = new String Tokenizer ( absolute Path ( ) , STR_ ) ; while ( tokenizer . has More Tokens ( ) ) { bstream . write ( ( byte ) STR_ ) ; String next Name = tokenizer . next Token ( ) ; byte [ ] windows Next Name = to Windows Name ( next Name ) ; bstream . write ( windows Next Name , NUM_ , windows Next Name . length - NUM_ ) ; } bstream . write ( NUM_ ) ; return bstream . to Byte Array ( ) ; }
public Remote lookup ( String key ) throws Registry Exception { try { return registry . lookup ( key ) ; } catch ( Exception e ) { throw new Registry Exception ( STR_ + key + STR_ , e ) ; } }
public boolean accept ( File f ) { if ( f != null ) { if ( f . is Directory ( ) ) { return true ; } String extension = get Extension ( f ) ; if ( ( extension != null ) && ( filters . get ( get Extension ( f ) ) != null ) ) { return true ; } } return false ; }
public static boolean has Dead States To Accept ( Automaton a ) { Bit Set reachable From Initial = get Live States From Initial ( a ) ; Bit Set reachable From Accept = get Live States To Accept ( a ) ; reachable From Accept . and Not ( reachable From Initial ) ; return reachable From Accept . is Empty ( ) == false ; }
public static int [ ] int Array From String ( String string ) { List < Integer > result = new Array List < Integer > ( NUM_ ) ; if ( String Utils . is Not Blank ( string ) ) { Raptor String Tokenizer tok = new Raptor String Tokenizer ( string , STR_ , false ) ; while ( tok . has More Tokens ( ) ) { try { result . add ( Integer . parse Int ( tok . next Token ( ) ) ) ; } catch ( Number Format Exception nfe ) { throw new Illegal State Exception ( nfe ) ; } } } int [ ] array Result = new int [ result . size ( ) ] ; for ( int i = NUM_ ; i < result . size ( ) ; i ++ ) { array Result [ i ] = result . get ( i ) ; } return array Result ; }
public boolean is User Lockout ( String user DN , String org DN ) { populate Lockout Values ( org DN ) ; PW Reset Account Lockout pw Reset Lockout = new PW Reset Account Lockout ( this ) ; return pw Reset Lockout . is Lockout ( user DN ) ; }
@ Gwt Incompatible ( STR_ ) public static < T extends Object > T [ ] concat ( T [ ] first , T [ ] second , Class < T > type ) { T [ ] result = new Array ( type , first . length + second . length ) ; System . arraycopy ( first , NUM_ , result , NUM_ , first . length ) ; System . arraycopy ( second , NUM_ , result , first . length , second . length ) ; return result ; }
public static < T extends Data Object > List < T > iterator To List ( Iterator < T > itr ) { List < T > objs = new Array List < T > ( ) ; while ( itr . has Next ( ) ) { objs . add ( itr . next ( ) ) ; } return objs ; }
public static boolean is Unit Interval ( String value ) { if ( ! is Numeric ( value ) ) { return false ; } Double dbl = Double . parse Double ( value ) ; return dbl >= NUM_ && dbl <= NUM_ ; }
@ Override public boolean implies ( Permission p ) { return false ; }
public static Set < J Component > all Components ( J Component parent ) { Set < J Component > result = new Hash Set < > ( ) ; Deque < J Component > queue = new Linked List < > ( ) ; queue . add ( parent ) ; while ( ! queue . is Empty ( ) ) { J Component c = queue . remove First ( ) ; result . add ( c ) ; for ( Component c 0 : c . get Components ( ) ) { if ( c 0 instanceof J Component ) { queue . add ( ( J Component ) c 0 ) ; } } } result . remove ( parent ) ; return result ; }
public boolean in Tag ( ) { return ! stack . is Empty ( ) ; }
public boolean is Compression Enabled ( ) { return compression ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public static Range iterate To Find Range Bounds ( XY Dataset dataset , List visible Series Keys , Range x Range , boolean include Interval ) { Param Checks . null Not Permitted ( dataset , STR_ ) ; Param Checks . null Not Permitted ( visible Series Keys , STR_ ) ; Param Checks . null Not Permitted ( x Range , STR_ ) ; double minimum = Double . POSITIVE INFINITY ; double maximum = Double . NEGATIVE INFINITY ; if ( include Interval && dataset instanceof OHLC Dataset ) { OHLC Dataset ohlc = ( OHLC Dataset ) dataset ; Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM_ ; item < item Count ; item ++ ) { double x = ohlc . get X Value ( series , item ) ; if ( x Range . contains ( x ) ) { double lvalue = ohlc . get Low Value ( series , item ) ; double uvalue = ohlc . get High Value ( series , item ) ; if ( ! Double . is Na N ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . is Na N ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } } } } else if ( include Interval && dataset instanceof Box And Whisker XY Dataset ) { Box And Whisker XY Dataset bx = ( Box And Whisker XY Dataset ) dataset ; Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM_ ; item < item Count ; item ++ ) { double x = bx . get X Value ( series , item ) ; if ( x Range . contains ( x ) ) { Number lvalue = bx . get Min Regular Value ( series , item ) ; Number uvalue = bx . get Max Regular Value ( series , item ) ; if ( lvalue != null ) { minimum = Math . min ( minimum , lvalue . double Value ( ) ) ; } if ( uvalue != null ) { maximum = Math . max ( maximum , uvalue . double Value ( ) ) ; } } } } } else if ( include Interval && dataset instanceof Interval XY Dataset ) { Interval XY Dataset ixyd = ( Interval XY Dataset ) dataset ; Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM_ ; item < item Count ; item ++ ) { double x = ixyd . get X Value ( series , item ) ; if ( x Range . contains ( x ) ) { double yvalue = ixyd . get Y Value ( series , item ) ; double lvalue = ixyd . get Start Y Value ( series , item ) ; double uvalue = ixyd . get End Y Value ( series , item ) ; if ( ! Double . is Na N ( yvalue ) ) { minimum = Math . min ( minimum , yvalue ) ; maximum = Math . max ( maximum , yvalue ) ; } if ( ! Double . is Na N ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . is Na N ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } } } } else { Iterator iterator = visible Series Keys . iterator ( ) ; while ( iterator . has Next ( ) ) { Comparable series Key = ( Comparable ) iterator . next ( ) ; int series = dataset . index Of ( series Key ) ; int item Count = dataset . get Item Count ( series ) ; for ( int item = NUM_ ; item < item Count ; item ++ ) { double x = dataset . get X Value ( series , item ) ; double y = dataset . get Y Value ( series , item ) ; if ( x Range . contains ( x ) ) { if ( ! Double . is Na N ( y ) ) { minimum = Math . min ( minimum , y ) ; maximum = Math . max ( maximum , y ) ; } } } } } if ( minimum == Double . POSITIVE INFINITY ) { return null ; } else { return new Range ( minimum , maximum ) ; } }
public boolean location Is Torso ( int loc ) { return ( loc == LOC CT ) || ( loc == LOC RT ) || ( loc == LOC LT ) ; }
public static Prototype intern ( String descriptor ) { if ( descriptor == null ) { throw new Null Pointer Exception ( STR_ ) ; } Prototype result ; synchronized ( intern Table ) { result = intern Table . get ( descriptor ) ; } if ( result != null ) { return result ; } Type [ ] params = make Parameter Array ( descriptor ) ; int param Count = NUM_ ; int at = NUM_ ; for ( ; ; ) { int start At = at ; char c = descriptor . char At ( at ) ; if ( c == STR_ ) { at ++ ; break ; } while ( c == STR_ ) { at ++ ; c = descriptor . char At ( at ) ; } if ( c == STR_ ) { int end At = descriptor . index Of ( STR_ , at ) ; if ( end At == - NUM_ ) { throw new Illegal Argument Exception ( STR_ ) ; } at = end At + NUM_ ; } else { at ++ ; } params [ param Count ] = Type . intern ( descriptor . substring ( start At , at ) ) ; param Count ++ ; } Type return Type = Type . intern Return Type ( descriptor . substring ( at ) ) ; Std Type List parameter Types = new Std Type List ( param Count ) ; for ( int i = NUM_ ; i < param Count ; i ++ ) { parameter Types . set ( i , params [ i ] ) ; } result = new Prototype ( descriptor , return Type , parameter Types ) ; return put Intern ( result ) ; }
public static int hash ( float value ) { return Float . float To Int Bits ( value * NUM_ ) ; }
public static String optimize ( String ... args ) { return simple Tag ( STR_ , args ) ; }
public DST Zone build Tail Zone ( String id ) { if ( i Rules . size ( ) == NUM_ ) { Rule start Rule = i Rules . get ( NUM_ ) ; Rule end Rule = i Rules . get ( NUM_ ) ; if ( start Rule . get To Year ( ) == Integer . MAX VALUE && end Rule . get To Year ( ) == Integer . MAX VALUE ) { return new DST Zone ( id , i Standard Offset , start Rule . i Recurrence , end Rule . i Recurrence ) ; } } return null ; }
protected boolean can Paths Be Removed ( Tree Path [ ] paths ) { if ( row Mapper == null || selection == null || selection Mode == Tree Selection Model . DISCONTIGUOUS TREE SELECTION ) return true ; else { Bit Set bit Set = new Bit Set ( ) ; int counter ; int path Count = paths . length ; int an Index ; int min = - NUM_ ; int valid Count = NUM_ ; Tree Path [ ] temp Path = new Tree Path [ NUM_ ] ; int [ ] rows ; last Paths . clear ( ) ; for ( counter = NUM_ ; counter < path Count ; counter ++ ) { if ( paths [ counter ] != null ) { last Paths . put ( paths [ counter ] , Boolean . TRUE ) ; } } for ( counter = selection . length - NUM_ ; counter >= NUM_ ; counter -- ) { if ( last Paths . get ( selection [ counter ] ) == null ) { temp Path [ NUM_ ] = selection [ counter ] ; rows = row Mapper . get Rows For Paths ( temp Path ) ; if ( rows != null && rows [ NUM_ ] != - NUM_ && ! bit Set . get ( rows [ NUM_ ] ) ) { valid Count ++ ; if ( min == - NUM_ ) min = rows [ NUM_ ] ; else min = Math . min ( min , rows [ NUM_ ] ) ; bit Set . set ( rows [ NUM_ ] ) ; } } } last Paths . clear ( ) ; if ( valid Count > NUM_ ) { for ( counter = min + valid Count - NUM_ ; counter >= min ; counter -- ) if ( ! bit Set . get ( counter ) ) return false ; } } return true ; }
public boolean recognizes ( String txt ) { Directed DFS dfs = new Directed DFS ( graph , NUM_ ) ; Bag < Integer > pc = new Bag < Integer > ( ) ; for ( int v = NUM_ ; v < graph . V ( ) ; v ++ ) if ( dfs . marked ( v ) ) pc . add ( v ) ; for ( int i = NUM_ ; i < txt . length ( ) ; i ++ ) { if ( txt . char At ( i ) == STR_ || txt . char At ( i ) == STR_ || txt . char At ( i ) == STR_ || txt . char At ( i ) == STR_ ) throw new Illegal Argument Exception ( STR_ + txt . char At ( i ) + STR_ ) ; Bag < Integer > match = new Bag < Integer > ( ) ; for ( int v : pc ) { if ( v == m ) continue ; if ( ( regexp . char At ( v ) == txt . char At ( i ) ) || regexp . char At ( v ) == STR_ ) match . add ( v + NUM_ ) ; } dfs = new Directed DFS ( graph , match ) ; pc = new Bag < Integer > ( ) ; for ( int v = NUM_ ; v < graph . V ( ) ; v ++ ) if ( dfs . marked ( v ) ) pc . add ( v ) ; if ( pc . size ( ) == NUM_ ) return false ; } for ( int v : pc ) if ( v == m ) return true ; return false ; }
private static int find Closest Size ( List < Size > sorted Sizes , int target Pixel Count ) { int closest Match Index = NUM_ ; int closest Match Pixel Count Diff = Integer . MAX VALUE ; for ( int i = NUM_ ; i < sorted Sizes . size ( ) ; ++ i ) { Size size = sorted Sizes . get ( i ) ; int pixel Count Diff = Math . abs ( ( size . width ( ) * size . height ( ) ) - target Pixel Count ) ; if ( pixel Count Diff < closest Match Pixel Count Diff ) { closest Match Index = i ; closest Match Pixel Count Diff = pixel Count Diff ; } } return closest Match Index ; }
public static int uniform ( int N ) { return random . next Int ( N ) ; }
String transform Name ( String class Name ) { String new Name = m Rename Classes . get ( class Name ) ; if ( new Name != null ) { return new Name ; } int pos = class Name . index Of ( STR_ ) ; if ( pos > NUM_ ) { String base = class Name . substring ( NUM_ , pos ) ; new Name = m Rename Classes . get ( base ) ; if ( new Name != null ) { return new Name + class Name . substring ( pos ) ; } } return class Name ; }
public static float round To Decimal Places ( float num To Round , int dec Places ) { float p = ( float ) Math . pow ( NUM_ , dec Places ) ; num To Round = num To Round * p ; float tmp = Math . round ( num To Round ) ; return ( float ) tmp / p ; }
public final double root Mean Squared Error ( ) { return Math . sqrt ( m Sum Sqr Err / ( m With Class - m Unclassified ) ) ; }
private static int Windows Reg Set Value Ex 1 ( int h Key , byte [ ] value Name , byte [ ] value ) { int result = Windows Reg Set Value Ex ( h Key , value Name , value ) ; if ( result == ERROR SUCCESS ) { return result ; } else { long sleep Time = INIT SLEEP TIME ; for ( int i = NUM_ ; i < MAX ATTEMPTS ; i ++ ) { try { Thread . sleep ( sleep Time ) ; } catch ( Interrupted Exception e ) { return result ; } sleep Time *= NUM_ ; result = Windows Reg Set Value Ex ( h Key , value Name , value ) ; if ( result == ERROR SUCCESS ) { return result ; } } } return result ; }
static double compute Final Sum ( double [ ] summands ) { double tmp = summands [ NUM_ ] + summands [ NUM_ ] ; double simple Sum = summands [ summands . length - NUM_ ] ; if ( Double . is Na N ( tmp ) && Double . is Infinite ( simple Sum ) ) { return simple Sum ; } else { return tmp ; } }
public static String escape ( String str ) { Utils . check Not Null ( str , STR_ ) ; int slen = str . length ( ) ; for ( int index = NUM_ ; index < slen ; index ++ ) { char c = str . char At ( index ) ; if ( c >= SAFE OCTETS . length || ! SAFE OCTETS [ c ] ) { return escape Slow ( str , index ) ; } } return str ; }
@ Override public boolean equals ( Object obj ) { if ( ! ( obj instanceof Xml Namespace ) ) { return false ; } Xml Namespace other = ( Xml Namespace ) obj ; if ( alias == null ) { return ( other . alias == null ) && uri . equals ( other . uri ) ; } else { return alias . equals ( other . alias ) && uri . equals ( other . uri ) ; } }
public static Entry Reader new Entry Collection Reader ( final Collection < Entry > entries ) { return new Entry Iterator Reader ( entries . iterator ( ) ) ; }
public Feature List Table feature List ( ) { if ( feature List Table . get ( ) == null ) { feature List Table . compare And Set ( null , gsub . create Feature List ( ) ) ; } return feature List Table . get ( ) ; }
public static int aspect Ratio Denominator ( Size size ) { Big Integer width = Big Integer . value Of ( size . width ( ) ) ; Big Integer height = Big Integer . value Of ( size . height ( ) ) ; Big Integer gcd = width . gcd ( height ) ; int denominator = Math . min ( width . int Value ( ) , height . int Value ( ) ) / gcd . int Value ( ) ; return denominator ; }
public static Double Vector dchisq Log ( double x , Double Vector ncp ) { Double Vector d Log = new Double Vector ( ncp . size ( ) ) ; double xh = Math . sqrt ( x ) ; double mean ; for ( int i = NUM_ ; i < ncp . size ( ) ; i ++ ) { mean = Math . sqrt ( ncp . get ( i ) ) ; if ( ncp . get ( i ) == NUM_ ) d Log . set ( i , dchisq Log ( x ) ) ; else d Log . set ( i , Math . log ( dnorm ( xh - mean ) + dnorm ( - xh - mean ) ) - Math . log ( NUM_ * xh ) ) ; } return d Log ; }
public static boolean contains Ignore Case ( String string , String substring ) { return contains ( string . to Lower Case ( ) , substring . to Lower Case ( ) ) ; }
private static boolean is Supported Syntax ( Statement stat , String sql ) { try { stat . execute ( sql ) ; return true ; } catch ( SQL Exception ex ) { return false ; } }
private static String latitude Ref ( double latitude ) { return latitude < NUM_ ? STR_ : STR_ ; }
public static < K , V > Map < K , V > of ( K k 1 , V v 1 , K k 2 , V v 2 , K k 3 , V v 3 ) { Map map = of ( ) ; map . put ( k 1 , v 1 ) ; map . put ( k 2 , v 2 ) ; map . put ( k 3 , v 3 ) ; return map ; }
public static void throw Exception ( Throwable t ) { if ( UNSAFE != null ) { UNSAFE . throw Exception ( t ) ; } else { J Unsafe . < Runtime Exception > throw Exception 0 ( t ) ; } }
public Object clone ( ) throws Clone Not Supported Exception { Default Tree Selection Model clone = ( Default Tree Selection Model ) super . clone ( ) ; clone . change Support = null ; if ( selection != null ) { int sel Length = selection . length ; clone . selection = new Tree Path [ sel Length ] ; System . arraycopy ( selection , NUM_ , clone . selection , NUM_ , sel Length ) ; } clone . listener List = new Event Listener List ( ) ; clone . list Selection Model = ( Default List Selection Model ) list Selection Model . clone ( ) ; clone . unique Paths = new Hashtable < Tree Path , Boolean > ( ) ; clone . last Paths = new Hashtable < Tree Path , Boolean > ( ) ; clone . temp Paths = new Tree Path [ NUM_ ] ; return clone ; }
public static boolean is Smallmem ( ) { return is Smallmem ; }
public boolean is Empty ( ) { return options . is Empty ( ) ; }
void add Query Result ( long token , UI Search Result line , Search Result Mediator rp ) { if ( rp . is Stopped ( ) ) { return ; } if ( ! rp . matches ( token ) ) throw new Illegal Argument Exception ( STR_ ) ; rp . add ( line ) ; int result Panel Index ; result Panel Index = entries . index Of ( rp ) ; if ( result Panel Index == - NUM_ ) { return ; } tabbed Pane . set Title At ( result Panel Index , title Of ( rp ) ) ; }
public String build Id ( ) { return properties . get Property ( STR_ ) ; }
public static byte [ ] read Input Stream ( Input Stream in ) throws IO Exception { try { class Part { byte [ ] part Data ; int len ; } Linked List < Part > parts = new Linked List < > ( ) ; int len = NUM_ ; while ( len > NUM_ ) { byte [ ] data = new byte [ NUM_ ] ; len = in . read ( data ) ; if ( len > NUM_ ) { Part part = new Part ( ) ; part . part Data = data ; part . len = len ; parts . add ( part ) ; } } int length = NUM_ ; for ( Part part : parts ) { length += part . len ; } byte [ ] result = new byte [ length ] ; int pos = NUM_ ; for ( Part part : parts ) { System . arraycopy ( part . part Data , NUM_ , result , pos , part . len ) ; pos += part . len ; } return result ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IO Exception e ) { } } } }
boolean is User A Local Admin Or Not Closed ( Request And Response request And Response ) throws IO Exception { if ( is User A Local Admin ( request And Response ) ) { return true ; } if ( ! is User Signed In ( request And Response ) ) { request And Response . print ( servlet Text . error Requires Sign In ( false ) ) ; return false ; } else if ( is Users Account Closed ( request And Response ) ) { request And Response . print ( servlet Text . error Account Is Closed ( ) ) ; return false ; } return true ; }
public Iterator iterator ( ) { return list . iterator ( ) ; }
public static boolean is Trusted Source ( Inet Address source ) throws Session Exception { if ( trusted Sources == null ) { trusted Sources = get Trusted Source List ( ) ; } return trusted Sources . contains ( source ) ; }
public static Preferences system Root ( ) { Security Manager security = System . get Security Manager ( ) ; if ( security != null ) security . check Permission ( prefs Perm ) ; return factory . system Root ( ) ; }
public static boolean is Valid Email ( Object value ) { Internet Address addr = parse Email ( value ) ; if ( addr != null ) { String address = addr . get Address ( ) ; if ( address . contains ( STR_ ) ) return false ; int pos = address . index Of ( STR_ ) ; if ( pos < NUM_ || pos == address . length ( ) - NUM_ ) return false ; String local = address . substring ( NUM_ , pos ) ; String domain = address . substring ( pos + NUM_ ) ; if ( domain . char At ( NUM_ ) == STR_ || local . char At ( NUM_ ) == STR_ || local . char At ( local . length ( ) - NUM_ ) == STR_ ) return false ; pos = domain . last Index Of ( STR_ ) ; if ( pos > NUM_ && pos < domain . length ( ) - NUM_ ) { if ( String Util . is All Alpha ( domain . substring ( pos + NUM_ ) ) ) return true ; try { addr . validate ( ) ; return true ; } catch ( Address Exception e ) { } } } return false ; }
public static boolean is Numeric Type Specifier ( char c , boolean is Decimal ) { if ( is Decimal ) { switch ( c ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : return true ; } } else { switch ( c ) { case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : case STR_ : return true ; } } return false ; }
public List < C > instantiate Classes ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new Array List < > ( ) ; if ( get Value ( ) == null ) { config . report Error ( new Unused Parameter Exception ( STR_ + get Name ( ) + STR_ ) ) ; return instances ; } for ( Class < ? extends C > cls : get Value ( ) ) { try { C instance = Class Generics Util . try Instantiate ( restriction Class , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . report Error ( new Wrong Parameter Value Exception ( this , cls . get Name ( ) , e ) ) ; } } return instances ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > new Vector = new Vector < Option > ( NUM_ ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add Element ( new Option ( STR_ , STR_ , NUM_ , STR_ ) ) ; new Vector . add All ( Collections . list ( super . list Options ( ) ) ) ; return new Vector . elements ( ) ; }
@ Override public Inet Address address Remote ( ) { if ( s != null ) return s . get Inet Address ( ) ; else return null ; }
public Accessible Relation [ ] to Array ( ) { if ( relations == null ) { return new Accessible Relation [ NUM_ ] ; } else { Accessible Relation [ ] relation Array = new Accessible Relation [ relations . size ( ) ] ; for ( int i = NUM_ ; i < relation Array . length ; i ++ ) { relation Array [ i ] = ( Accessible Relation ) relations . element At ( i ) ; } return relation Array ; } }
@ Override public int hash Code ( ) { return variable . hash Code ( ) - value . hash Code ( ) ; }
public static int max Element ( int [ ] vals ) { if ( vals . length == NUM_ ) { throw new No Such Element Exception ( STR_ ) ; } return max Element ( vals , NUM_ , vals . length ) ; }
public int hash Code ( Object obj ) { return obj . hash Code ( ) ; }
public Element deep Copy ( ) { return deep Freeze Or Copy ( false ) ; }
public boolean is Authn Context Matching ( List requested AC Class Refs , String ac Class Ref , String comparison , String realm , String host Entity ID ) { Map auth Ref Map = get Auth Ref Map ( realm , host Entity ID ) ; return SAML 2 Utils . is Authn Context Matching ( requested AC Class Refs , ac Class Ref , comparison , auth Ref Map ) ; }
protected double dist of scale ( int s ) { return Math . pow ( m Base , s ) ; }
public long length ( ) throws IO Exception { LOG . trace ( STR_ ) ; if ( length Of Data ( ) < NUM_ ) { return - NUM_ ; } final Byte Array Output Stream overhead = new Byte Array Output Stream ( ) ; send Start ( overhead ) ; send Disposition Header ( overhead ) ; send Content Type Header ( overhead ) ; send Transfer Encoding Header ( overhead ) ; send End Of Header ( overhead ) ; send End ( overhead ) ; return overhead . size ( ) + length Of Data ( ) ; }
public static String replace ( String original , String old Substring , String new Substring , boolean all ) { String Buffer b = new String Buffer ( original ) ; replace ( b , old Substring , new Substring , all ) ; return b . to String ( ) ; }
protected List < ? extends Itemset > frequent Itemsets ( List < ? extends Itemset > candidates , Relation < Bit Vector > relation , int needed , DBI Ds ids , Array Modifiable DBI Ds survivors , int length ) { if ( candidates . is Empty ( ) ) { return Collections . empty List ( ) ; } Itemset first = candidates . get ( NUM_ ) ; if ( candidates . size ( ) > length * length * length * NUM_ && first instanceof Sparse Itemset ) { @ Suppress Warnings ( STR_ ) List < Sparse Itemset > sparsecand = ( List < Sparse Itemset > ) candidates ; return frequent Itemsets Sparse ( sparsecand , relation , needed , ids , survivors , length ) ; } for ( DBID Iter iditer = ids . iter ( ) ; iditer . valid ( ) ; iditer . advance ( ) ) { Bit Vector bv = relation . get ( iditer ) ; int lives = NUM_ ; for ( Itemset candidate : candidates ) { if ( candidate . contained In ( bv ) ) { candidate . increase Support ( ) ; ++ lives ; } } if ( lives > length ) { survivors . add ( iditer ) ; } } List < Itemset > frequent = new Array List < > ( candidates . size ( ) ) ; for ( Iterator < ? extends Itemset > iter = candidates . iterator ( ) ; iter . has Next ( ) ; ) { final Itemset candidate = iter . next ( ) ; if ( candidate . get Support ( ) >= needed ) { frequent . add ( candidate ) ; } } return frequent ; }
public static boolean is Mime Type Video ( String mime Type ) { if ( mime Type . equals ( Const . Content Types . VIDEO MP 4 ) ) { return true ; } return false ; }
@ Visible For Testing protected Http URL Connection create Connection ( ) throws Request Failure Exception { try { URL url = new URL ( m Generator . get Server Url ( ) ) ; Http URL Connection connection = ( Http URL Connection ) url . open Connection ( ) ; connection . set Connect Timeout ( MS CONNECTION TIMEOUT ) ; connection . set Read Timeout ( MS CONNECTION TIMEOUT ) ; return connection ; } catch ( Malformed URL Exception e ) { throw new Request Failure Exception ( STR_ , e ) ; } catch ( IO Exception e ) { throw new Request Failure Exception ( STR_ , e ) ; } }
public final boolean exit ( ) { if ( ! in Queue ) return false ; in Queue = false ; return cancel Scheduled Timeout ( this ) ; }
private void check Fenced ( ) throws Managed Ledger Exception { if ( state . get ( ) == State . Fenced ) { log . error ( STR_ , name ) ; throw new Managed Ledger Fenced Exception ( ) ; } }
protected final void read Properties ( final Element element , final Properties Provider provider ) { if ( provider == null ) { return ; } Element properties Element = Lw Xml Reader . get Child ( element , UI Form Xml Constants . ELEMENT PROPERTIES ) ; if ( properties Element == null ) { properties Element = new Element ( UI Form Xml Constants . ELEMENT PROPERTIES , element . get Namespace ( ) ) ; } final Hash Map name 2 property = provider . get Lw Properties ( get Component Class Name ( ) ) ; if ( name 2 property == null ) { my Error Component Properties = ( Element ) properties Element . clone ( ) ; return ; } final List property Elements = properties Element . get Children ( ) ; for ( int i = NUM_ ; i < property Elements . size ( ) ; i ++ ) { final Element t = ( Element ) property Elements . get ( i ) ; final String name = t . get Name ( ) ; final Lw Introspected Property property = ( Lw Introspected Property ) name 2 property . get ( name ) ; if ( property == null ) { continue ; } try { final Object value = property . read ( t ) ; set Property Value ( property , value ) ; } catch ( final Exception exc ) { } } read Client Properties ( element ) ; }
@ Override public boolean connection Allowed ( String event Name ) { if ( m first Input != null && m second Input != null ) { return false ; } if ( m first Input == null || m second Input == null ) { if ( m first Input != null ) { if ( m first Input Connection Type . equals ( STR_ ) && ! event Name . equals ( STR_ ) ) { return false ; } else if ( ! m first Input Connection Type . equals ( STR_ ) && event Name . equals ( STR_ ) ) { return false ; } return true ; } else if ( m second Input != null ) { if ( m second Input Connection Type . equals ( STR_ ) && ! event Name . equals ( STR_ ) ) { return false ; } else if ( ! m second Input Connection Type . equals ( STR_ ) && event Name . equals ( STR_ ) ) { return false ; } return true ; } return true ; } return false ; }
public static < K , V > Map < K , V > of ( K k 1 , V v 1 , K k 2 , V v 2 , K k 3 , V v 3 , K k 4 , V v 4 , K k 5 , V v 5 ) { Map map = of ( ) ; map . put ( k 1 , v 1 ) ; map . put ( k 2 , v 2 ) ; map . put ( k 3 , v 3 ) ; map . put ( k 4 , v 4 ) ; map . put ( k 5 , v 5 ) ; return map ; }
public Set < F > filter Set ( ) { return Collections . unmodifiable Set ( m Filters ) ; }
public static int num Of Parameters ( String desc ) { int n = NUM_ ; int i = NUM_ ; for ( ; ; ) { char c = desc . char At ( i ) ; if ( c == STR_ ) break ; while ( c == STR_ ) c = desc . char At ( ++ i ) ; if ( c == STR_ ) { i = desc . index Of ( STR_ , i ) + NUM_ ; if ( i <= NUM_ ) throw new Index Out Of Bounds Exception ( STR_ ) ; } else ++ i ; ++ n ; } return n ; }
@ Override public Enumeration < Option > list Options ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add Element ( new Option ( STR_ + STR_ , STR_ , NUM_ , STR_ ) ) ; result . add All ( Collections . list ( super . list Options ( ) ) ) ; return result . elements ( ) ; }
public boolean is Paused ( ) { return m Paused ; }
@ Nullable public static String extract Major Version From Semantic Version ( String semantic Version ) { Matcher matcher = SEMANTIC VERSION REGEX PATTERN . matcher ( semantic Version ) ; if ( matcher . find ( ) ) { return matcher . group ( NUM_ ) ; } else { return null ; } }
public static String simple Hostname ( String full Hostname ) { int offset = full Hostname . index Of ( STR_ ) ; if ( offset != - NUM_ ) { return full Hostname . substring ( NUM_ , offset ) ; } return full Hostname ; }
static boolean may Invoke Direct ( Group And Invoke Count my Group And Invoke Count , Asynchronous Channel Group Impl group ) { if ( ( my Group And Invoke Count != null ) && ( my Group And Invoke Count . group ( ) == group ) && ( my Group And Invoke Count . invoke Count ( ) < max Handler Invoke Count ) ) { return true ; } return false ; }
public String version ( ) { return System . get Property ( STR_ ) ; }
public Map < String , Object > flatten As Map ( ) { if ( flattened Map != null ) return flattened Map ; flattened Map = new Jsonify Linked Hash Map ( ) ; reduce ( source ) ; while ( ! element Iters . is Empty ( ) ) { Indexed Peek Iterator < ? > deepest Iter = element Iters . get Last ( ) ; if ( ! deepest Iter . has Next ( ) ) { element Iters . remove Last ( ) ; } else if ( deepest Iter . peek ( ) instanceof Member ) { Member mem = ( Member ) deepest Iter . next ( ) ; reduce ( mem . get Value ( ) ) ; } else { Json Value val = ( Json Value ) deepest Iter . next ( ) ; reduce ( val ) ; } } return flattened Map ; }
public static String file Builder Url ( String base Uri , String seed , byte [ ] signature Secret , long file Id , long file Access Hash ) { byte [ ] seed Bytes = decode Hex ( seed . to Char Array ( ) ) ; byte [ ] file Id Bytes = get Bytes ( file Id ) ; byte [ ] access Hash Bytes = get Bytes ( file Access Hash ) ; byte [ ] bytes To Sign = Array Utils . add All ( Array Utils . add All ( seed Bytes , file Id Bytes ) , access Hash Bytes ) ; String sign Part = Hmac Utils . hmac Sha 256 Hex ( signature Secret , bytes To Sign ) ; String signature = seed + STR_ + sign Part ; return base Uri + STR_ + file Id + STR_ + signature ; }
@ Override public Grammar load Grammar ( XML Input Source source ) throws IO Exception , XNI Exception { reset ( f Loader Config ) ; f Settings Changed = false ; XSD Description desc = new XSD Description ( ) ; desc . f Context Type = XSD Description . CONTEXT PREPARSE ; desc . set Base System Id ( source . get Base System Id ( ) ) ; desc . set Literal System Id ( source . get System Id ( ) ) ; Hashtable location Pairs = new Hashtable ( ) ; process External Hints ( f External Schemas , f External No NS Schema , location Pairs , f Error Reporter ) ; Schema Grammar grammar = load Schema ( desc , source , location Pairs ) ; if ( grammar != null && f Grammar Pool != null ) { f Grammar Pool . cache Grammars ( XML Grammar Description . XML SCHEMA , f Grammar Bucket . get Grammars ( ) ) ; if ( f Is Checked Fully && f JAXP Cache . get ( grammar ) != grammar ) { XS Constraints . full Schema Checking ( f Grammar Bucket , f Sub Group Handler , f CM Builder , f Error Reporter ) ; } } return grammar ; }
