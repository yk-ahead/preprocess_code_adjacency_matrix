@ Override protected void on Delete Complete ( int token , Object cookie , int result ) { if ( token == m Delete Token ) { synchronized ( s Deleting Threads Lock ) { s Deleting Threads = false ; if ( DELETEDEBUG ) { Log . v ( TAG , STR_ + s Deleting Threads ) ; } s Deleting Threads Lock . notify All ( ) ; } Unread Badge Service . update ( m Context ) ; Notification Manager . create ( m Context ) ; } }
public void add Translator ( Class Pool cp , Translator t ) throws Not Found Exception , Cannot Compile Exception { source = cp ; translator = t ; t . start ( cp ) ; }
@ Suppress Warnings ( STR_ ) @ Override protected Object read Post Process ( Object o ) throws Exception { Enumeration < Object > enm ; Vector < Vector < ? > > deserialized ; Object key ; deserialized = ( Vector < Vector < ? > > ) super . read Post Process ( o ) ; rebuild Bean Connections ( deserialized , REGULAR CONNECTION ) ; enm = m Bean Connection Relation . keys ( ) ; while ( enm . has More Elements ( ) ) { key = enm . next Element ( ) ; if ( ! ( key instanceof Meta Bean ) ) { continue ; } rebuild Bean Connections ( deserialized , key ) ; } if ( get Data Type ( ) == DATATYPE USERCOMPONENTS ) { remove User Tool Bar Beans ( deserialized ) ; } return deserialized ; }
public void process Connection ( Data Input Stream dis , Data Output Stream dos Param ) throws IO Exception , Exception { GZIP Output Stream gzip = new GZIP Output Stream ( new Buffered Output Stream ( dos Param ) ) ; Data Output Stream dos = new Data Output Stream ( gzip ) ; byte response Status = Response Status . STATUS ERROR ; try { Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; String name = dis . read UTF ( ) ; String pw = dis . read UTF ( ) ; String serializer = dis . read UTF ( ) ; @ Suppress Warnings ( STR_ ) String locale = dis . read UTF ( ) ; byte action = dis . read Byte ( ) ; Context . open Session ( ) ; try { Context . authenticate ( name , pw ) ; } catch ( Context Authentication Exception ex ) { response Status = Response Status . STATUS ACCESS DENIED ; } if ( response Status != Response Status . STATUS ACCESS DENIED ) { Data Output Stream dos Temp = new Data Output Stream ( baos ) ; if ( action == ACTION DOWNLOAD PATIENTS ) download Patients ( String . value Of ( dis . read Int ( ) ) , dos Temp , serializer , false ) ; else if ( action == ACTION DOWNLOAD SS PATIENTS ) download Patients ( String . value Of ( dis . read Int ( ) ) , dos Temp , serializer , true ) ; else if ( action == ACTION DOWNLOAD COHORTS ) Patient Download Manager . download Cohorts ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD SAVED SEARCHES ) Patient Download Manager . download Saves Searches ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD FORMS ) Xform Download Manager . download Xforms ( dos Temp , serializer ) ; else if ( action == ACTION UPLOAD FORMS ) submit Xforms ( dis , dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD USERS ) User Download Manager . download Users ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD USERS AND FORMS ) download Users And Forms ( dos Temp , serializer ) ; else if ( action == ACTION DOWNLOAD FILTERED PATIENTS ) download Patients ( dis . read UTF ( ) , dis . read UTF ( ) , dos Temp , serializer ) ; response Status = Response Status . STATUS SUCCESS ; } dos . write Byte ( response Status ) ; if ( response Status == Response Status . STATUS SUCCESS ) dos . write ( baos . to Byte Array ( ) ) ; dos . close ( ) ; gzip . finish ( ) ; } catch ( Exception ex ) { log . error ( ex . get Message ( ) , ex ) ; try { dos . write Byte ( response Status ) ; dos . flush ( ) ; gzip . finish ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } finally { Context . close Session ( ) ; } }
public static void begin ( Servlet Request request , Servlet Response response , String service Name , String object Id ) throws Servlet Exception { Service Context context = ( Service Context ) local Context . get ( ) ; if ( context == null ) { context = new Service Context ( ) ; local Context . set ( context ) ; } context . request = request ; context . response = response ; context . service Name = service Name ; context . object Id = object Id ; context . count ++ ; }
public void draw Figure ( Graphics 2 D g ) { Affine Transform saved Transform = null ; if ( get ( TRANSFORM ) != null ) { saved Transform = g . get Transform ( ) ; g . transform ( get ( TRANSFORM ) ) ; } Paint paint = SVG Attribute Keys . get Fill Paint ( this ) ; if ( paint != null ) { g . set Paint ( paint ) ; draw Fill ( g ) ; } paint = SVG Attribute Keys . get Stroke Paint ( this ) ; if ( paint != null && get ( STROKE WIDTH ) > NUM_ ) { g . set Paint ( paint ) ; g . set Stroke ( SVG Attribute Keys . get Stroke ( this ) ) ; draw Stroke ( g ) ; } if ( get ( TRANSFORM ) != null ) { g . set Transform ( saved Transform ) ; } }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { if ( m Orientation == Orientation . VERTICAL ) { final int scroll Y = get Scroll Y ( ) ; int padding Top = get Padding Top ( ) ; int padding Bottom = get Padding Bottom ( ) ; final int height = get Height ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int vgrav = lp . gravity & Gravity . VERTICAL GRAVITY MASK ; int child Top = NUM_ ; switch ( vgrav ) { default : child Top = padding Top ; break ; case Gravity . TOP : child Top = padding Top ; padding Top += child . get Height ( ) ; break ; case Gravity . CENTER VERTICAL : child Top = Math . max ( ( height - child . get Measured Height ( ) ) / NUM_ , padding Top ) ; break ; case Gravity . BOTTOM : child Top = height - padding Bottom - child . get Measured Height ( ) ; padding Bottom += child . get Measured Height ( ) ; break ; } child Top += scroll Y ; final int child Offset = child Top - child . get Top ( ) ; if ( child Offset != NUM_ ) { child . offset Top And Bottom ( child Offset ) ; } } } else { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final int scroll = ( m Orientation == Orientation . VERTICAL ) ? get Scroll Y ( ) : get Scroll X ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( ( ( m Orientation == Orientation . VERTICAL ) ? child . get Top ( ) : child . get Left ( ) ) - scroll ) / get Client Size ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = true ; }
private void check Class And Sync ( Class < ? extends I Packet > clazz ) { if ( ! registered Classes . contains ( clazz ) ) { throw new Runtime Exception ( STR_ + clazz + STR_ ) ; } while ( is Currently Sending Semaphor ) { Thread . yield ( ) ; } is Currently Sending Semaphor = true ; }
public byte [ ] to Byte Array ( ) { int total Len = past Len + curr Block Ptr ; if ( total Len == NUM_ ) { return NO BYTES ; } byte [ ] result = new byte [ total Len ] ; int offset = NUM_ ; for ( byte [ ] block : past Blocks ) { int len = block . length ; System . arraycopy ( block , NUM_ , result , offset , len ) ; offset += len ; } System . arraycopy ( curr Block , NUM_ , result , offset , curr Block Ptr ) ; offset += curr Block Ptr ; if ( offset != total Len ) { throw new Runtime Exception ( STR_ + total Len + STR_ + offset + STR_ ) ; } if ( ! past Blocks . is Empty ( ) ) { reset ( ) ; } return result ; }
void on Deferred End Drag ( Drag View drag View ) { drag View . remove ( ) ; if ( m Drag Object . defer Drag View Cleanup Post Animation ) { for ( Drag Listener listener : new Array List < > ( m Listeners ) ) { listener . on Drag End ( ) ; } } }
protected void find And Init ( Iterator it ) { while ( it . has Next ( ) ) { find And Init ( it . next ( ) ) ; } }
private void resize Name Column ( int diff , boolean resize Statistic Panels ) { if ( diff != NUM_ ) { if ( name Dim == null ) { name Dim = new Dimension ( DIMENSION HEADER ATTRIBUTE NAME . width + diff , DIMENSION HEADER ATTRIBUTE NAME . height ) ; } else { int new Width = name Dim . width + diff ; int min Width = RESIZE MARGIN SHRINK ; int max Width = column Header Panel . get Width ( ) - ( DIMENSION HEADER MISSINGS . width + DIMENSION HEADER TYPE . width + DIMENSION SEARCH FIELD . width + RESIZE MARGIN ENLARGE ) ; if ( new Width > max Width ) { new Width = max Width ; } if ( new Width < min Width ) { new Width = min Width ; } name Dim = new Dimension ( new Width , name Dim . height ) ; } sorting Label Att Name . set Minimum Size ( name Dim ) ; sorting Label Att Name . set Preferred Size ( name Dim ) ; column Header Panel . revalidate ( ) ; column Header Panel . repaint ( ) ; } if ( resize Statistic Panels ) { revalidate Attribute Panels ( ) ; } }
public static final void init ZK ( Zoo Keeper zkc , String self Broker Url ) { try { Local Zoo Keeper Connection Service . check And Create Persist Node ( zkc , OWNER INFO ROOT ) ; cleanup Namespace Nodes ( zkc , OWNER INFO ROOT , self Broker Url ) ; } catch ( Exception e ) { LOG . error ( e . get Message ( ) , e ) ; throw new Runtime Exception ( e ) ; } }
public void connected ( ) { final String method Name = STR_ ; log . fine ( CLASS NAME , method Name , STR_ ) ; this . connected = true ; ping Sender . start ( ) ; }
public boolean just Serialized ( ) { return serialized . get And Set ( false ) ; }
protected void do Write ( Http Servlet Request request , Http Servlet Response response , String tunnel UUID ) throws Guacamole Exception { Guacamole Tunnel tunnel = get Tunnel ( tunnel UUID ) ; response . set Content Type ( STR_ ) ; response . set Header ( STR_ , STR_ ) ; response . set Content Length ( NUM_ ) ; try { Guacamole Writer writer = tunnel . acquire Writer ( ) ; Reader input = new Input Stream Reader ( request . get Input Stream ( ) , STR_ ) ; try { int length ; char [ ] buffer = new char [ NUM_ ] ; while ( tunnel . is Open ( ) && ( length = input . read ( buffer , NUM_ , buffer . length ) ) != - NUM_ ) writer . write ( buffer , NUM_ , length ) ; } finally { input . close ( ) ; } } catch ( Guacamole Connection Closed Exception e ) { logger . debug ( STR_ , e ) ; } catch ( IO Exception e ) { deregister Tunnel ( tunnel ) ; tunnel . close ( ) ; throw new Guacamole Server Exception ( STR_ + e . get Message ( ) , e ) ; } finally { tunnel . release Writer ( ) ; } }
protected void close Dialog Ok ( ) { dispose ( ) ; }
private void on Location Changed Async ( Location location ) { try { if ( ! is Recording ( ) || is Paused ( ) ) { Log . w ( TAG , STR_ ) ; return ; } Track track = my Tracks Provider Utils . get Track ( recording Track Id ) ; if ( track == null ) { Log . w ( TAG , STR_ ) ; return ; } if ( ! Location Utils . is Valid Location ( location ) ) { Log . w ( TAG , STR_ ) ; return ; } if ( ! location . has Accuracy ( ) || location . get Accuracy ( ) >= recording Gps Accuracy ) { Log . d ( TAG , STR_ ) ; return ; } if ( location . get Time ( ) == NUM_ ) { location . set Time ( System . current Time Millis ( ) ) ; } Location last Valid Track Point = get Last Valid Track Point In Current Segment ( track . get Id ( ) ) ; long idle Time = NUM_ ; if ( last Valid Track Point != null && location . get Time ( ) > last Valid Track Point . get Time ( ) ) { idle Time = location . get Time ( ) - last Valid Track Point . get Time ( ) ; } location Listener Policy . update Idle Time ( idle Time ) ; if ( current Recording Interval != location Listener Policy . get Desired Polling Interval ( ) ) { register Location Listener ( ) ; } Sensor Data Set sensor Data Set = get Sensor Data Set ( ) ; if ( sensor Data Set != null ) { location = new My Tracks Location ( location , sensor Data Set ) ; } if ( ! current Segment Has Location ) { insert Location ( track , location , null ) ; current Segment Has Location = true ; last Location = location ; return ; } if ( ! Location Utils . is Valid Location ( last Valid Track Point ) ) { insert Location ( track , location , null ) ; last Location = location ; return ; } double distance To Last Track Location = location . distance To ( last Valid Track Point ) ; if ( distance To Last Track Location > max Recording Distance ) { insert Location ( track , last Location , last Valid Track Point ) ; Location pause = new Location ( Location Manager . GPS PROVIDER ) ; pause . set Longitude ( NUM_ ) ; pause . set Latitude ( PAUSE LATITUDE ) ; pause . set Time ( last Location . get Time ( ) ) ; insert Location ( track , pause , null ) ; insert Location ( track , location , null ) ; is Idle = false ; } else if ( sensor Data Set != null || distance To Last Track Location >= recording Distance Interval ) { insert Location ( track , last Location , last Valid Track Point ) ; insert Location ( track , location , null ) ; is Idle = false ; } else if ( ! is Idle && location . has Speed ( ) && location . get Speed ( ) < MAX NO MOVEMENT SPEED ) { insert Location ( track , last Location , last Valid Track Point ) ; insert Location ( track , location , null ) ; is Idle = true ; } else if ( is Idle && location . has Speed ( ) && location . get Speed ( ) >= MAX NO MOVEMENT SPEED ) { insert Location ( track , last Location , last Valid Track Point ) ; insert Location ( track , location , null ) ; is Idle = false ; } else { Log . d ( TAG , STR_ ) ; } last Location = location ; } catch ( Error e ) { Log . e ( TAG , STR_ , e ) ; throw e ; } catch ( Runtime Exception e ) { Log . e ( TAG , STR_ , e ) ; throw e ; } }
public void lock UI ( Process Info pi ) { m is Locked = true ; }
private void profiles CB ( ) { Profile profile ; String host ; profile = ( Profile ) profiles Combo Box . get Selected Item ( ) ; if ( profile != null ) { host = profile . get Host ( ) ; server Field . set Text ( host ) ; server Port Field . set Text ( String . value Of ( profile . get Port ( ) ) ) ; username Field . set Text ( profile . get User ( ) ) ; password Field . set Text ( profile . get Password ( ) ) ; } else { server Port Field . set Text ( String . value Of ( Profile . DEFAULT SERVER PORT ) ) ; username Field . set Text ( STR_ ) ; password Field . set Text ( STR_ ) ; } }
private void show About ( ) { if ( about == null ) { about = new Common About Dialog ( frame ) ; } about . set Visible ( true ) ; }
public void received ( Byte Buffer buffer ) { has Received Data = true ; last Receive Time = System . current Time Millis ( ) ; }
public void stop ( ) { is Alive = false ; stats Snap Shot . stop ( ) ; holding Buffer . clear ( ) ; IO Utils . close Quietly ( this ) ; }
protected void on Service Stopped ( ) { unregister Receiver ( m Bluetooth State Broadcast Receiver ) ; for ( final Ble Manager < Ble Manager Callbacks > manager : m Ble Managers . values ( ) ) { manager . close ( ) ; manager . log ( Log Contract . Log . Level . INFO , STR_ ) ; } m Ble Managers . clear ( ) ; m Managed Devices . clear ( ) ; m Ble Managers = null ; m Managed Devices = null ; }
public synchronized void register ( Entity Creation Listener listener ) { listeners . add ( listener ) ; }
public static boolean can Translate ( String unlocalized String ) { if ( I 18 n . has Key ( unlocalized String ) ) return true ; else { if ( UNLOCALIZED STRINGS . size ( ) < NUM_ && ! UNLOCALIZED STRINGS . contains ( unlocalized String ) ) UNLOCALIZED STRINGS . add ( unlocalized String ) ; return false ; } }
@ Override public double calculate Distance ( double [ ] x 1 , double [ ] x 2 ) { double prod = a * inner Product ( x 1 , x 2 ) + b ; double e 1 = Math . exp ( prod ) ; double e 2 = Math . exp ( - prod ) ; return ( ( e 1 - e 2 ) / ( e 1 + e 2 ) ) ; }
private void pre Buffer Access ( ) { most Recent Use = System . current Time Millis ( ) ; lock . lock ( ) ; try { while ( flush Pending ) { flush Complete . await ( ) ; } ensure Buffer Available ( this ) ; ensure Loaded ( ) ; buffer Use Count ++ ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; } finally { lock . unlock ( ) ; } }
private boolean finish Line ( boolean saw Newline ) throws IO Exception { handle Line ( line . to String ( ) , saw Return ? ( saw Newline ? STR_ : STR_ ) : ( saw Newline ? STR_ : STR_ ) ) ; line = new String Builder ( ) ; saw Return = false ; return saw Newline ; }
@ Deprecated protected void insert At Boundry ( J Editor Pane editor , HTML Document doc , int offset , Element insert Element , String html , HTML . Tag parent Tag , HTML . Tag add Tag ) { Element e ; Element common Parent ; boolean is First = ( offset == NUM_ ) ; if ( offset > NUM_ || insert Element == null ) { e = doc . get Default Root Element ( ) ; while ( e != null && e . get Start Offset ( ) != offset && ! e . is Leaf ( ) ) { e = e . get Element ( e . get Element Index ( offset ) ) ; } common Parent = ( e != null ) ? e . get Parent Element ( ) : null ; } else { common Parent = insert Element ; } if ( common Parent != null ) { int pops = NUM_ ; int pushes = NUM_ ; if ( is First && insert Element != null ) { e = common Parent ; while ( e != null && ! e . is Leaf ( ) ) { e = e . get Element ( e . get Element Index ( offset ) ) ; pops ++ ; } } else { e = common Parent ; offset -- ; while ( e != null && ! e . is Leaf ( ) ) { e = e . get Element ( e . get Element Index ( offset ) ) ; pops ++ ; } e = common Parent ; offset ++ ; while ( e != null && e != insert Element ) { e = e . get Element ( e . get Element Index ( offset ) ) ; pushes ++ ; } } pops = Math . max ( NUM_ , pops - NUM_ ) ; insert HTML ( editor , doc , offset , html , pops , pushes , add Tag ) ; } }
@ Override public void on Item Click ( Adapter View < ? > parent , View view , int position , long id ) { Check Box enable Component Checkbox = ( Check Box ) view . find View By Id ( R . id . enable component checkbox ) ; enable Component Checkbox . perform Click ( ) ; }
public static int object Equals ( Object obj 1 , Object obj 2 ) { return obj 1 . equals ( obj 2 ) ? TRUE : FALSE ; }
protected boolean is Always Non Null ( Value v ) { return false ; }
protected < T > void register Service ( Class < T > clazz , T instance ) { application Container . register Component Instance ( clazz . get Name ( ) , instance ) ; }
protected void on No Update ( ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , STR_ ) ; } ui Handler . hide Message ( ) ; updating = false ; fire Application Cache Event ( Cache Event . on Noupdate ) ; }
private void enlarge Capacity ( int key ) { int diff = off Count - offset ; int min Capacity = Math . max ( arr . length , key + offset + diff + NUM_ ) ; if ( min Capacity > arr . length ) { int old Capacity = arr . length ; int new Capacity = old Capacity + ( old Capacity > > NUM_ ) ; if ( new Capacity - min Capacity < NUM_ ) new Capacity = min Capacity ; if ( new Capacity - MAX ARRAY SIZE > NUM_ ) new Capacity = huge Capacity ( min Capacity ) ; arr = Arrays . copy Of ( arr , new Capacity ) ; } }
public void run ( ) { int rc = - NUM_ ; String ip Addr = ( String ) ip Address . get Selected Item ( ) ; String port Num = ( String ) port . get Selected Item ( ) ; String conn Str = STR_ ; try { if ( ip Addr . index Of ( STR_ ) < NUM_ ) { conn Str = STR_ + ip Addr + STR_ + port Num ; } else { conn Str = ip Addr ; } connect ( conn Str , options Comp . is Persistence Selected ( ) ) ; update Combo Box List ( ip Address , ip Addr ) ; update Combo Box List ( port , port Num ) ; connected = true ; led . set Green ( ) ; set Connected ( true ) ; } catch ( Number Format Exception nfe ) { J Option Pane . show Message Dialog ( frame , STR_ , STR_ , J Option Pane . ERROR MESSAGE ) ; } catch ( Mqtt Exception mqe ) { set Title Text ( STR_ ) ; Throwable e = mqe . get Cause ( ) ; String msg = STR_ ; if ( e == null ) { e = mqe ; } else if ( mqe . get Message ( ) != null ) { msg += mqe . get Message ( ) + STR_ ; } msg += e ; J Option Pane . show Message Dialog ( frame , msg , STR_ , J Option Pane . ERROR MESSAGE ) ; e . print Stack Trace ( ) ; } catch ( Exception ex ) { set Title Text ( STR_ ) ; J Option Pane . show Message Dialog ( frame , ex , STR_ , J Option Pane . ERROR MESSAGE ) ; ex . print Stack Trace ( ) ; } if ( ! connected ) { led . set Red ( ) ; set Connected ( false ) ; } synchronized ( this ) { if ( connected ) { write Logln ( STR_ + mqtt . get Server URI ( ) ) ; } else { write Logln ( STR_ + conn Str ) ; } } }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final int scroll X = get Scroll X ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Left ( ) - scroll X ) / get Client Width ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = true ; }
public Response on Command ( SMTP Session session , Request request ) { return NOT SUPPORTED ; }
public boolean before Writing ( ) { if ( file Lock Method != File Lock . LOCK SERIALIZED ) { return true ; } while ( checkpoint Running ) { try { Thread . sleep ( NUM_ + ( int ) ( Math . random ( ) * NUM_ ) ) ; } catch ( Exception e ) { } } synchronized ( reconnect Sync ) { if ( reconnect Modified ( true ) ) { checkpoint Allowed ++ ; if ( Sys Properties . CHECK && checkpoint Allowed > NUM_ ) { throw Db Exception . throw Internal Error ( ) ; } return true ; } } reconnect Check Next = System . current Time Millis ( ) - NUM_ ; reconnect Last Lock = null ; return false ; }
public static void signal Cache Close ( ) { is Cache Closing = true ; if ( proctor != null ) { proctor . interrupt ( ) ; } if ( watch Dog != null ) { watch Dog . interrupt ( ) ; } }
public boolean read From File ( ) { return read From File ( FILENAME ) ; }
public boolean compute Scroll Offset ( ) { if ( m Finished ) { return false ; } int time Passed = ( int ) ( Animation Utils . current Animation Time Millis ( ) - m Start Time ) ; if ( time Passed < m Duration ) { switch ( m Mode ) { case SCROLL MODE : float x = time Passed * m Duration Reciprocal ; if ( m Interpolator == null ) x = viscous Fluid ( x ) ; else x = m Interpolator . get Interpolation ( x ) ; m Curr X = m Start X + Math . round ( x * m Delta X ) ; m Curr Y = m Start Y + Math . round ( x * m Delta Y ) ; break ; case FLING MODE : final float t = ( float ) time Passed / m Duration ; final int index = ( int ) ( NB SAMPLES * t ) ; final float t inf = ( float ) index / NB SAMPLES ; final float t sup = ( float ) ( index + NUM_ ) / NB SAMPLES ; final float d inf = SPLINE [ index ] ; final float d sup = SPLINE [ index + NUM_ ] ; final float distance Coef = d inf + ( t - t inf ) / ( t sup - t inf ) * ( d sup - d inf ) ; m Curr X = m Start X + Math . round ( distance Coef * ( m Final X - m Start X ) ) ; m Curr X = Math . min ( m Curr X , m Max X ) ; m Curr X = Math . max ( m Curr X , m Min X ) ; m Curr Y = m Start Y + Math . round ( distance Coef * ( m Final Y - m Start Y ) ) ; m Curr Y = Math . min ( m Curr Y , m Max Y ) ; m Curr Y = Math . max ( m Curr Y , m Min Y ) ; if ( m Curr X == m Final X && m Curr Y == m Final Y ) { m Finished = true ; } break ; } } else { m Curr X = m Final X ; m Curr Y = m Final Y ; m Finished = true ; } return true ; }
public void on Activity Result ( int request Code , int result Code , Intent data ) { if ( m Initialization Complete ) { m Activity Delegate . on Activity Result With Native ( request Code , result Code , data ) ; } else { if ( m Pending Activity Results == null ) { m Pending Activity Results = new Array List < Activity Result > ( NUM_ ) ; } m Pending Activity Results . add ( new Activity Result ( request Code , result Code , data ) ) ; } }
@ Override protected void property Change ( Property Change Event evt ) { super . property Change ( evt ) ; String name = evt . get Property Name ( ) ; if ( name . equals ( STR_ ) ) { update Foreground ( ( Color ) evt . get New Value ( ) ) ; } else if ( name . equals ( STR_ ) ) { update Font ( ( Font ) evt . get New Value ( ) ) ; } else if ( name . equals ( STR_ ) ) { J Component comp = get Component ( ) ; update Foreground ( comp . get Foreground ( ) ) ; update Font ( comp . get Font ( ) ) ; } }
@ Override protected void on Activity Result ( int request Code , int result Code , Intent data ) { if ( request Code == GET CODE ) { Editable text = ( Editable ) m Results . get Text ( ) ; if ( result Code == RESULT CANCELED ) { text . append ( STR_ ) ; } else { text . append ( STR_ ) ; text . append ( Integer . to String ( result Code ) ) ; text . append ( STR_ ) ; if ( data != null ) { text . append ( data . get Action ( ) ) ; } } text . append ( STR_ ) ; } }
@ Visible For Testing protected boolean alert Column Number Change ( boolean source Is Mapped , int number , int original Number ) { if ( source Is Mapped ) { if ( Integer . compare ( original Number , number ) != NUM_ ) { add Action Warning ( get Text ( STR_ , new String [ ] { source . get Name ( ) , String . value Of ( original Number ) , String . value Of ( number ) } ) ) ; return true ; } } return false ; }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { final int scroll Y = get Scroll Y ( ) ; int padding Top = get Padding Top ( ) ; int padding Bottom = get Padding Bottom ( ) ; final int height = get Height ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int vgrav = lp . gravity & Gravity . VERTICAL GRAVITY MASK ; int child Top = NUM_ ; switch ( vgrav ) { default : child Top = padding Top ; break ; case Gravity . TOP : child Top = padding Top ; padding Top += child . get Height ( ) ; break ; case Gravity . CENTER VERTICAL : child Top = Math . max ( ( height - child . get Measured Height ( ) ) / NUM_ , padding Top ) ; break ; case Gravity . BOTTOM : child Top = height - padding Bottom - child . get Measured Height ( ) ; padding Bottom += child . get Measured Height ( ) ; break ; } child Top += scroll Y ; final int child Offset = child Top - child . get Top ( ) ; if ( child Offset != NUM_ ) { child . offset Top And Bottom ( child Offset ) ; } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final int scroll Y = get Scroll Y ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Top ( ) - scroll Y ) / get Client Height ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = true ; }
public void execute Action ( final String js Code ) { actions Executed = true ; if ( disable Javascript ) { return ; } js Parser . execute Functions ( js Code , null ) ; }
@ Override public void on Service Disconnected ( Component Name class Name ) { Log . d ( TAG , STR_ ) ; }
public static int collection Contains All ( Collection < ? > c , Collection < ? > c 2 ) { int mismatch = NUM_ ; for ( Object o : c 2 ) { if ( ! c . contains ( o ) ) mismatch ++ ; } return mismatch > NUM_ ? - mismatch : c 2 . size ( ) + NUM_ ; }
public < CT > CT call Batch Tasks ( Database Connection connection , boolean saved , Callable < CT > callable ) throws SQL Exception { if ( database Type . is Batch Use Transaction ( ) ) { return Transaction Manager . call In Transaction ( connection , saved , database Type , callable ) ; } boolean auto Commit At Start = false ; try { if ( connection . is Auto Commit Supported ( ) ) { auto Commit At Start = connection . is Auto Commit ( ) ; if ( auto Commit At Start ) { connection . set Auto Commit ( false ) ; logger . debug ( STR_ , table Info . get Table Name ( ) ) ; } } try { return callable . call ( ) ; } catch ( SQL Exception e ) { throw e ; } catch ( Exception e ) { throw Sql Exception Util . create ( STR_ , e ) ; } } finally { if ( auto Commit At Start ) { connection . set Auto Commit ( true ) ; logger . debug ( STR_ , table Info . get Table Name ( ) ) ; } } }
private void init Backup Components ( ) throws Space Components Initialize Exception { for ( Iterator < I Space Components Handler > iterator = components Handlers . iterator ( ) ; iterator . has Next ( ) ; ) { I Space Components Handler handler = iterator . next ( ) ; if ( ! handler . is Recovery Supported ( ) ) handler . init Components ( false ) ; } }
public void reload ( ) { if ( m Original Geometry != null ) { if ( ! m Original Geometry . is Valid ( ) ) { m Original Geometry . reload ( ) ; } copy From Geometry 3 D ( m Original Geometry ) ; } create Buffers ( ) ; }
@ Override public void layer Moved ( final Map Layer List Event event ) { redraw Base Image = true ; if ( ! is Disposed ( ) ) redraw ( ) ; }
public boolean tasks ( ) { log . info ( STR_ ) ; log . info ( STR_ + ( m Server Socket == null ) + STR_ + ( m Bluetooth Adapter != null ) + STR_ + ( m Bluetooth Adapter != null ) ) ; if ( m Server Socket == null && m Bluetooth Adapter != null && m Bluetooth Adapter . is Enabled ( ) && ( m Connection Accepting Thread == null || ! m Connection Accepting Thread . is Alive ( ) ) ) { try { log . info ( STR_ ) ; create Listening Socket ( ) ; spawn Connection Accepting Thread ( ) ; } catch ( IO Exception e ) { log . error ( STR_ , e ) ; log . error ( STR_ ) ; return false ; } } if ( m Bluetooth Adapter == null || ! m Bluetooth Adapter . is Enabled ( ) ) { log . info ( STR_ ) ; return false ; } log . info ( STR_ ) ; return true ; }
protected final String handle Unusual Field Name ( int i ) throws IO Exception , Json Parse Exception { if ( i == INT APOSTROPHE && is Enabled ( Feature . ALLOW SINGLE QUOTES ) ) { return parse Apostrophe Field Name ( ) ; } if ( ! is Enabled ( Feature . ALLOW UNQUOTED FIELD NAMES ) ) { report Unexpected Char ( i , STR_ ) ; } final int [ ] codes = Char Types . get Input Code Latin 1 Js Names ( ) ; final int max Code = codes . length ; boolean first Ok ; if ( i < max Code ) { first Ok = ( codes [ i ] == NUM_ ) && ( i < INT 0 || i > INT 9 ) ; } else { first Ok = Character . is Java Identifier Part ( ( char ) i ) ; } if ( ! first Ok ) { report Unexpected Char ( i , STR_ ) ; } int ptr = input Ptr ; int hash = NUM_ ; final int input Len = input End ; if ( ptr < input Len ) { do { int ch = input Buffer [ ptr ] ; if ( ch < max Code ) { if ( codes [ ch ] != NUM_ ) { int start = input Ptr - NUM_ ; input Ptr = ptr ; return symbols . find Symbol ( input Buffer , start , ptr - start , hash ) ; } } else if ( ! Character . is Java Identifier Part ( ( char ) ch ) ) { int start = input Ptr - NUM_ ; input Ptr = ptr ; return symbols . find Symbol ( input Buffer , start , ptr - start , hash ) ; } hash = ( hash * NUM_ ) + ch ; ++ ptr ; } while ( ptr < input Len ) ; } int start = input Ptr - NUM_ ; input Ptr = ptr ; return parse Unusual Field Name 2 ( start , hash , codes ) ; }
@ Override public final int size ( ) { return ( int ) Math . max ( ( tail . get ( ) - head . get ( ) ) , NUM_ ) ; }
@ Override public void execute ( Runnable task ) { tasks In Process . increment And Get ( ) ; try { super . execute ( task ) ; } catch ( Runtime Exception | Error e ) { tasks In Process . decrement And Get ( ) ; throw e ; } }
public void apply ( List items ) { int size = items . size ( ) ; if ( size > NUM_ ) { if ( comparator != null ) { Collections . sort ( items , comparator ) ; } for ( int i = - NUM_ ; i < size ; i ++ ) { Header Item header Item ; if ( i == - NUM_ ) { header Item = grouping Function . group ( null , ( Item ) items . get ( i + NUM_ ) , i ) ; } else if ( i == items . size ( ) - NUM_ ) { header Item = grouping Function . group ( ( Item ) items . get ( i ) , null , i ) ; } else { header Item = grouping Function . group ( ( Item ) items . get ( i ) , ( Item ) items . get ( i + NUM_ ) , i ) ; } if ( header Item != null ) { items . add ( i + NUM_ , header Item ) ; i = i + NUM_ ; } } } if ( item Adapter != null ) { item Adapter . set ( items ) ; } if ( generic Item Adapter != null ) { generic Item Adapter . set Model ( items ) ; } }
@ Override @ Debug Log public void on Stream Progress ( Torrent torrent , Stream Status status ) { if ( ! m Video Location . is Empty ( ) ) { start Player ( m Video Location ) ; } set State ( State . STREAMING , status ) ; }
public void focus Lost ( Focus Event e ) { combo Box . repaint ( ) ; }
public static void signal Cache Create ( ) { is Cache Closing = false ; }
public void on Sensor Changed ( long timestamp , float values [ ] ) { if ( Math . abs ( timestamp - m Last Timestamp ) > MAX PERMITTED TIME BETWEEN SAMPLES NANOS ) { clear Energy Samples List ( ) ; if ( DEBUG ) { Log . v ( STR_ , STR_ ) ; } if ( m Current State != Sensor Detector State . TOO NOISY ) { change To New Current State ( timestamp , Sensor Detector State . TOO NOISY ) ; } } m Last Timestamp = timestamp ; m Last Conditioned Magnitude Sq = NUM_ ; for ( int i = NUM_ ; i < NUMBER OF DIMENSIONS ; ++ i ) { m Last Filter Output [ i ] = m Detector Type . filter Num [ NUM_ ] * values [ i ] + m Detector Type . filter Num [ NUM_ ] * m Last Input [ i ] - m Detector Type . filter Den [ NUM_ ] * m Last Filter Output [ i ] ; m Last Input [ i ] = values [ i ] ; m Last Conditioned Magnitude Sq += m Last Filter Output [ i ] * m Last Filter Output [ i ] ; } m Conditioned Signal Energy += m Last Conditioned Magnitude Sq ; m Energy Samples List . add Last ( new Energy Sample Pair ( timestamp , m Last Conditioned Magnitude Sq ) ) ; while ( m Energy Samples List . get First ( ) . m Time <= timestamp - ENERGY HISTORY LENGTH NANOS ) { m Conditioned Signal Energy -= m Energy Samples List . get First ( ) . m Value ; m Energy Samples List . remove First ( ) ; } if ( DEBUG ) { Log . v ( STR_ , String . format ( STR_ , m Current State . name ( ) , m Conditioned Signal Energy , m Energy Samples List . size ( ) , m Energy Samples List . size ( ) * m Detector Type . energy Per Sample Noise Limit , m Last Conditioned Magnitude Sq ) ) ; } switch ( m Current State ) { case NO TAP : state Machine No Tap ( timestamp ) ; break ; case PROCESSING CANDIDATE DEFINITE TAP : state Machine Processing Definite Tap ( timestamp ) ; break ; case PROCESSING CANDIDATE POSSIBLE TAP : state Machine Processing Possible Tap ( timestamp ) ; break ; case TOO NOISY : state Machine Too Noisy ( timestamp ) ; break ; case DEFINITE TAP : case POSSIBLE TAP : change To New Current State ( timestamp , Sensor Detector State . TOO NOISY ) ; break ; default : } }
public void on Event ( No Subscriber Event event ) { if ( event . original Event instanceof Model Modified Message ) { on Event ( new Sticky Updated Message ( ) ) ; } }
protected void connection Established ( Channel connected Channel ) { LOG . info ( STR_ , connected Channel ) ; channel = connected Channel ; connected . set ( true ) ; }
public static void premain ( String agent Args , Instrumentation inst ) { instrumentation = inst ; }
public void reply ( Z 21 Reply msg ) { if ( msg . is X Press Net Tunnel Message ( ) ) { X Net Reply reply = msg . get X Net Reply ( ) ; log . debug ( STR_ , msg , reply ) ; for ( int i = NUM_ ; i < reply . get Num Data Elements ( ) ; i ++ ) { try { outpipe . write Byte ( reply . get Element ( i ) ) ; } catch ( java . io . IO Exception ioe ) { log . error ( STR_ ) ; } } } }
private void on Subtitle Download Failed ( ) { subtitle Language = Subs Provider . SUBTITLE LANGUAGE NONE ; if ( listener Reference . get ( ) == null ) return ; I Subtitle Downloader Listener listener = listener Reference . get ( ) ; listener . on Subtitle Download Completed ( false , null ) ; }
public static Object [ ] dynamic ( Object [ ] args ) { String Builder buff = new String Builder ( ) ; for ( Object a : args ) { buff . append ( a ) ; } return new Object [ ] { buff . to String ( ) } ; }
public void start Phase ( int phase , String source ) { if ( Trace . phase ) { String name = ( compiler Name == null ) ? STR_ : compiler Name ; boolean isabc = name . equals ( STR_ ) ; if ( isabc == false || Trace . phaseabc ) { Trace . trace ( STR_ + name + STR_ + get Phase Name ( phase ) + STR_ + source ) ; } } start Time = System . current Time Millis ( ) ; }
private static synchronized void cleanup ( Connection C ) { logger . trace ( STR_ ) ; if ( C != null ) { logger . trace ( STR_ ) ; try { C . close ( ) ; } catch ( Throwable t ) { surface Throwable ( STR_ , t ) ; } } logger . trace ( STR_ ) ; }
protected WS Display create Display ( Frame owner ) { WS Display wsd ; if ( persistent Display Type == null && Environment . get Boolean ( Environment . Use Internal Frames ) ) { wsd = new Intrnl Frm ( title ) ; } else { Class w Type Class = persistent Display Type == null ? get Default Window Support Display Type ( ) : persistent Display Type ; if ( w Type Class == Dlg . class ) { wsd = new Dlg ( owner , title ) ; } else if ( w Type Class == Intrnl Frm . class ) { wsd = new Intrnl Frm ( title ) ; } else { wsd = new Frm ( title ) ; } } set Fav Icon ( wsd ) ; set Display ( wsd ) ; return wsd ; }
public void sync ( ) { try { barrier . await ( ) ; } catch ( Interrupted Exception | Broken Barrier Exception e ) { Log Helper . fatal ( e . get Localized Message ( ) ) ; } }
public static void paint 3 Deffect ( Graphics 2 D g 2 D , J Component c , boolean round , boolean out ) { Gradient Paint top Paint = null ; if ( out ) top Paint = new Gradient Paint ( NUM_ , NUM_ , COL 1 TOP , NUM_ , c . get Height ( ) / NUM_ , COL 1 END ) ; else top Paint = new Gradient Paint ( NUM_ , NUM_ , COL 2 END , NUM_ , c . get Height ( ) / NUM_ , COL 2 TOP ) ; g 2 D . set Paint ( top Paint ) ; Rectangular Shape top Rec = null ; if ( round ) top Rec = new Round Rectangle 2 D . Float ( NUM_ , NUM_ , c . get Width ( ) , c . get Height ( ) / NUM_ , NUM_ , NUM_ ) ; else top Rec = new Rectangle ( NUM_ , NUM_ , c . get Width ( ) , c . get Height ( ) / NUM_ ) ; g 2 D . fill ( top Rec ) ; Gradient Paint end Paint = null ; if ( out ) end Paint = new Gradient Paint ( NUM_ , c . get Height ( ) / NUM_ , COL 2 TOP , NUM_ , c . get Height ( ) , COL 2 END ) ; else end Paint = new Gradient Paint ( NUM_ , c . get Height ( ) / NUM_ , COL 1 END , NUM_ , c . get Height ( ) , COL 1 TOP ) ; g 2 D . set Paint ( end Paint ) ; Rectangular Shape end Rec = null ; if ( round ) end Rec = new Round Rectangle 2 D . Float ( NUM_ , c . get Height ( ) / NUM_ , c . get Width ( ) , c . get Height ( ) / NUM_ , NUM_ , NUM_ ) ; else end Rec = new Rectangle ( NUM_ , c . get Height ( ) / NUM_ , c . get Width ( ) , c . get Height ( ) / NUM_ ) ; g 2 D . fill ( end Rec ) ; }
@ Override public double total Estimated Quantity ( final Long wo Activity Id , Long mb Header Id , final Long activity Id , final Work Order work Order ) { Date current Timestamp = null ; MB Header mb Header = null ; if ( mb Header Id == null ) { mb Header Id = - NUM_ ; current Timestamp = new Date ( ) ; } else { mb Header = persistence Service . find ( STR_ , mb Header Id ) ; current Timestamp = mb Header . get Created Date ( ) ; } Object [ ] params = null ; Double est Quantity = null ; params = new Object [ ] { work Order , wo Activity Id , activity Id } ; est Quantity = ( Double ) generic Service . find By Named Query ( STR_ , params ) ; Double est Quantity RE = null ; if ( work Order . get Parent ( ) != null ) params = new Object [ ] { current Timestamp , work Order . get Parent ( ) , work Order . get Parent ( ) , activity Id } ; else params = new Object [ ] { current Timestamp , work Order , work Order , activity Id } ; est Quantity RE = ( Double ) generic Service . find By Named Query ( STR_ , params ) ; if ( est Quantity != null && est Quantity RE != null ) est Quantity = est Quantity + est Quantity RE ; if ( est Quantity == null && est Quantity RE != null ) est Quantity = est Quantity RE ; if ( est Quantity == null ) return NUM_ ; else return est Quantity . double Value ( ) ; }
public void commit Binding ( ) { if ( defered Values != null && defered Values . size ( ) > NUM_ ) { Enumeration en = defered Values . keys ( ) ; while ( en . has More Elements ( ) ) { Object k = en . next Element ( ) ; values . put ( k , defered Values . get ( k ) ) ; } defered Values = null ; } }
public Object flip Edge ( Object edge ) { if ( edge != null && alternate Edge Style != null ) { model . begin Update ( ) ; try { String style = model . get Style ( edge ) ; if ( style == null || style . length ( ) == NUM_ ) { model . set Style ( edge , alternate Edge Style ) ; } else { model . set Style ( edge , null ) ; } reset Edge ( edge ) ; fire Event ( new mx Event Object ( mx Event . FLIP EDGE , STR_ , edge ) ) ; } finally { model . end Update ( ) ; } } return edge ; }
public final Parallel Flux < T > do On Request ( Long Consumer on Request ) { Objects . require Non Null ( on Request , STR_ ) ; return do On Signal ( this , null , null , null , null , null , null , on Request , null ) ; }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { if ( is Orientation Horizontal ( ) ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } else { final int scroll Y = get Scroll Y ( ) ; int padding Top = get Padding Top ( ) ; int padding Bottom = get Padding Bottom ( ) ; final int height = get Height ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int vgrav = lp . gravity & Gravity . VERTICAL GRAVITY MASK ; int child Top = NUM_ ; switch ( vgrav ) { default : child Top = padding Top ; break ; case Gravity . TOP : child Top = padding Top ; padding Top += child . get Height ( ) ; break ; case Gravity . CENTER VERTICAL : child Top = Math . max ( ( height - child . get Measured Height ( ) ) / NUM_ , padding Top ) ; break ; case Gravity . BOTTOM : child Top = height - padding Bottom - child . get Measured Height ( ) ; padding Bottom += child . get Measured Height ( ) ; break ; } child Top += scroll Y ; final int child Offset = child Top - child . get Top ( ) ; if ( child Offset != NUM_ ) { child . offset Top And Bottom ( child Offset ) ; } } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final boolean horizontal = is Orientation Horizontal ( ) ; final int scroll = horizontal ? get Scroll X ( ) : get Scroll Y ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; float transform Pos ; if ( horizontal ) { transform Pos = ( float ) ( child . get Left ( ) - scroll ) / get Client Width ( ) ; } else { transform Pos = ( float ) ( child . get Top ( ) - scroll ) / get Client Height ( ) ; } m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = true ; }
private synchronized void initialise Base Layer ( Point max Tile Dimensions ) { scale = Math . min ( NUM_ , Math . min ( get Width ( ) / ( float ) s Width ( ) , get Height ( ) / ( float ) s Height ( ) ) ) ; default Scale = scale ; fit To Bounds ( true ) ; full Image Sample Size = calculate In Sample Size ( ) ; if ( full Image Sample Size > NUM_ ) { full Image Sample Size /= NUM_ ; } initialise Tile Map ( max Tile Dimensions ) ; List < Tile > base Grid = tile Map . get ( full Image Sample Size ) ; for ( Tile base Tile : base Grid ) { Bitmap Tile Task task = new Bitmap Tile Task ( this , decoder , decoder Lock , base Tile , this . fail Listener ) ; task . execute ( ) ; } }
@ Override public void on Place Selected ( Place place ) { Log . i ( TAG , STR_ + place . get Name ( ) ) ; m Place Details Text . set Text ( format Place Details ( get Resources ( ) , place . get Name ( ) , place . get Id ( ) , place . get Address ( ) , place . get Phone Number ( ) , place . get Website Uri ( ) ) ) ; Char Sequence attributions = place . get Attributions ( ) ; if ( ! Text Utils . is Empty ( attributions ) ) { m Place Attribution . set Text ( Html . from Html ( attributions . to String ( ) ) ) ; } else { m Place Attribution . set Text ( STR_ ) ; } }
public IO Utils ( ) { super ( ) ; }
public void add Node ( final I Navi View Node node ) { Preconditions . check Not Null ( node , STR_ ) ; Preconditions . check Argument ( ! m node Cache . contains ( node ) , STR_ ) ; m node Cache . add ( node ) ; final int index = m node Cache . index Of ( node ) ; fire Table Rows Inserted ( index , index ) ; }
protected boolean before Delete ( ) { log . save Error ( STR_ , Msg . get Msg ( get Ctx ( ) , STR_ ) ) ; return false ; }
void start Element ( String uri , String local Name , String q Name , long attribute Pointer , int attribute Count ) throws SAX Exception { Content Handler content Handler = xml Reader . content Handler ; if ( content Handler == null ) { return ; } try { in Start Element = true ; this . attribute Pointer = attribute Pointer ; this . attribute Count = attribute Count ; content Handler . start Element ( uri , local Name , q Name , this . attributes ) ; } finally { in Start Element = false ; this . attribute Count = - NUM_ ; this . attribute Pointer = NUM_ ; } }
public Connection Config ( jmri . jmrix . Network Port Adapter p ) { super ( p ) ; String h = adapter . get Host Name ( ) ; if ( h != null && ! h . equals ( Jmrix Config Pane . NONE ) ) { host Name Field = new J Text Field ( h ) ; } String t = STR_ + adapter . get Port ( ) ; if ( ! t . equals ( STR_ ) ) { port Field = new J Text Field ( t ) ; } }
public void processed Accountt Lockout ( Long event Time , String user DN ) throws AM Auth Call Back Exception { Map event Params = new Hash Map ( ) ; event Params . put ( AM Auth Call Back . TIME KEY , event Time ) ; event Params . put ( AM Auth Call Back . REALM KEY , the Realm ) ; event Params . put ( AM Auth Call Back . USER KEY , user DN ) ; processed Event ( AM Auth Call Back . ACCOUNT LOCKOUT , event Params ) ; }
private void expand ( int min New Segment Size ) { if ( segments == null ) { segments = new Array List < char [ ] > ( ) ; } char [ ] curr = current Segment ; has Segments = true ; segments . add ( curr ) ; segment Size += curr . length ; int old Len = curr . length ; int size Addition = old Len > > NUM_ ; if ( size Addition < min New Segment Size ) { size Addition = min New Segment Size ; } curr = char Array ( Math . min ( MAX SEGMENT LEN , old Len + size Addition ) ) ; current Size = NUM_ ; current Segment = curr ; }
public void on Child Account Signin Complete ( ) { native Set Is Child Account ( true ) ; }
@ Override public void on Visibility Changed ( boolean visible ) { super . on Visibility Changed ( visible ) ; if ( visible ) { register Receiver ( ) ; calendar . set Time Zone ( Time Zone . get Default ( ) ) ; } else { unregister Receiver ( ) ; } update Timer ( ) ; }
public boolean compute Scroll Offset ( ) { if ( m Finished ) { return false ; } final long time Passed = Animation Utils . current Animation Time Millis ( ) - m Start Time ; float time Passed Percent = time Passed * NUM_ / m Duration ; if ( time Passed >= m Duration ) { m Finished = true ; time Passed Percent = NUM_ ; } m Curr Value = Math . round ( m Value Factor * m Path Points Holder . get Y ( time Passed Percent ) ) ; return true ; }
public void write Raw ( final long offset , final Byte Buffer transfer ) throws IO Exception { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + offset ) ; final Lock lock = m extension Lock . read Lock ( ) ; lock . lock ( ) ; try { File Channel Utility . write All ( m reopener , transfer , offset ) ; } finally { lock . unlock ( ) ; } }
public static Buffered Input Stream blob 2 stream ( Blob value ) throws SQL Exception { if ( value == null ) { return null ; } Buffered Input Stream buffered In Stream = new Buffered Input Stream ( value . get Binary Stream ( ) ) ; return buffered In Stream ; }
@ Override public void action Performed ( Action Event e ) { Object o ; o = e . get Source ( ) ; if ( o == menu Item Mean ) { calc Mean ( ) ; } else if ( o == menu Item Set All Values ) { set Values ( menu Item Set All Values ) ; } else if ( o == menu Item Set Missing Values ) { set Values ( menu Item Set Missing Values ) ; } else if ( o == menu Item Replace Values ) { set Values ( menu Item Replace Values ) ; } else if ( o == menu Item Rename Attribute ) { rename Attribute ( ) ; } else if ( o == menu Item Attribute As Class ) { attribute As Class ( ) ; } else if ( o == menu Item Delete Attribute ) { delete Attribute ( ) ; } else if ( o == menu Item Delete Attributes ) { delete Attributes ( ) ; } else if ( o == menu Item Delete Selected Instance ) { delete Instance ( ) ; } else if ( o == menu Item Delete All Selected Instances ) { delete Instances ( ) ; } else if ( o == menu Item Sort Instances ) { sort Instances ( ) ; } else if ( o == menu Item Search ) { search ( ) ; } else if ( o == menu Item Clear Search ) { clear Search ( ) ; } else if ( o == menu Item Undo ) { undo ( ) ; } else if ( o == menu Item Copy ) { copy Content ( ) ; } else if ( o == menu Item Optimal Col Width ) { set Optimal Col Width ( ) ; } else if ( o == menu Item Optimal Col Widths ) { set Optimal Col Widths ( ) ; } }
public void add Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { m Listeners = new Array List < Swipe Listener > ( ) ; } m Listeners . add ( listener ) ; }
public static void relax Host Checking ( Http URL Connection conn ) throws Key Management Exception , No Such Algorithm Exception , Key Store Exception { if ( conn instanceof Https URL Connection ) { Https URL Connection https Connection = ( Https URL Connection ) conn ; SSL Socket Factory factory = prep Factory ( https Connection ) ; https Connection . set SSL Socket Factory ( factory ) ; https Connection . set Hostname Verifier ( TRUSTING HOSTNAME VERIFIER ) ; } }
@ Override public void before File Movement ( @ Not Null Virtual File Move Event event ) { Mason Settings mason Settings = Mason Settings . get Instance ( get Project ( ) ) ; List < Virtual File > components Roots = mason Settings . get Components Roots Virtual Files ( ) ; if ( components Roots . is Empty ( ) ) { return ; } Virtual File moved File = event . get File ( ) ; Set < Virtual File > roots Set = new T Hash Set < Virtual File > ( components Roots ) ; if ( moved File . is Directory ( ) ) { if ( Vfs Util . is Under ( moved File , roots Set ) || contains At Least One File ( moved File , components Roots ) ) { moved File . put User Data ( FORCE REINDEX , true ) ; } } else if ( moved File . get File Type ( ) instanceof Mason File Type ) { if ( Vfs Util . is Under ( moved File , roots Set ) ) { moved File . put User Data ( FORCE REINDEX , true ) ; } } }
public void removed ( java . awt . Container cont ) { if ( kill Cache ) { rpf Logger . fine ( STR_ ) ; clear Cache ( ) ; } set Projection ( ( Projection ) null ) ; }
private void run Impl ( long tid ) { alive = true ; native Thread Id = tid ; Long nid = new Long ( native Thread Id ) ; active Threads ++ ; try { target . run ( ) ; } catch ( Throwable t ) { t . print Stack Trace ( ) ; } active Threads -- ; alive = false ; }
protected void on Error ( ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , messages . application Cache Error ( ) ) ; } ui Handler . hide Message ( ) ; updating = false ; fire Application Cache Event ( Cache Event . on Error ) ; }
public void append Except First ( String s ) { if ( index ++ > NUM_ ) { builder . append ( s ) ; } }
public Response on Command ( POP 3 Session session , Request request ) { String parameters = request . get Argument ( ) ; if ( session . get Handler State ( ) == POP 3 Session . AUTHENTICATION USERSET && parameters != null ) { return do Auth ( session , session . get User ( ) , parameters ) ; } else { session . set Handler State ( POP 3 Session . AUTHENTICATION READY ) ; return AUTH FAILED ; } }
public void after Moving To Backup ( ) { switch ( space Mode ) { case NONE : start Components ( false ) ; break ; case PRIMARY : try { space . stop Internal ( ) ; space . start Internal ( ) ; } catch ( Remote Exception e ) { if ( logger . is Loggable ( Level . WARNING ) ) { logger . log ( Level . WARNING , STR_ , e ) ; } } break ; } }
public void on Download Completed ( Download Info download Info , String notify URI ) { long download Id = download Info . get Download Id ( ) ; OMA Info oma Info = m Pending OMA Downloads . get ( download Id ) ; if ( oma Info == null ) { oma Info = new OMA Info ( ) ; oma Info . add Attribute Value ( OMA INSTALL NOTIFY URI , notify URI ) ; } send Install Notification And Next Step ( oma Info , download Info , DOWNLOAD STATUS SUCCESS ) ; m Pending OMA Downloads . remove ( download Id ) ; }
@ Override protected void execution Finished ( Throwable t ) { m Button Start . set Enabled ( has Data ( ) ) ; m Button Stop . set Enabled ( false ) ; if ( t != null ) { handle Exception ( STR_ , t ) ; J Option Pane . show Message Dialog ( this , STR_ + t , STR_ , J Option Pane . ERROR MESSAGE ) ; } }
public static Morph Transition create ( int duration ) { Morph Transition mt = new Morph Transition ( ) ; mt . duration = duration ; return mt ; }
public boolean refresh Object State ( boolean keep Old State ) { boolean change Detected = false ; Object [ ] args = null ; if ( keep Old State ) { old Object State . put All ( object State ) ; } for ( Map . Entry < String , Method > gettor Method Entry : getter Method Map . entry Set ( ) ) { String property = gettor Method Entry . get Key ( ) ; Object property Value = null ; try { Method m = gettor Method Entry . get Value ( ) ; property Value = m . invoke ( mbean Object , args ) ; Open Method op = method Handler Map . get ( m ) ; property Value = op . to Open Return Value ( property Value ) ; } catch ( Exception e ) { property Value = null ; if ( logger . is Trace Enabled ( ) ) { logger . trace ( e . get Message ( ) ) ; } } Object old Value = object State . put ( property , property Value ) ; if ( ! change Detected ) { if ( property Value != null ) { if ( ! property Value . equals ( old Value ) ) { change Detected = true ; } } else { if ( old Value != null ) { change Detected = true ; } } } } boolean ret Val = prev Refresh Change Detected || change Detected ; prev Refresh Change Detected = change Detected ; return ret Val ; }
private void run Init Function If Required ( String url , Connection connection ) throws SQL Exception { Matcher matcher = INITFUNCTION MATCHING PATTERN . matcher ( url ) ; if ( matcher . matches ( ) ) { String class Name = matcher . group ( NUM_ ) ; String method Name = matcher . group ( NUM_ ) ; try { Class < ? > init Function Clazz = Class . for Name ( class Name ) ; Method method = init Function Clazz . get Method ( method Name , Connection . class ) ; method . invoke ( null , connection ) ; } catch ( Class Not Found Exception | No Such Method Exception | Illegal Access Exception | Invocation Target Exception e ) { LOGGER . error ( STR_ , class Name , method Name , e ) ; throw new SQL Exception ( STR_ + class Name + STR_ + method Name , e ) ; } } }
public void action Performed ( Action Event e ) { J Text Pane pane ; Document Printing doc ; pane = new Code Pane ( ) ; pane . set Text ( m Text Code . get Text ( ) ) ; doc = new Document Printing ( ) ; doc . print ( pane ) ; }
@ Override public void on Draw ( Canvas canvas , Rect bounds ) { int width = bounds . width ( ) ; int height = bounds . height ( ) ; calendar . set Time In Millis ( System . current Time Millis ( ) ) ; wf Bitmap = Bitmap . create Scaled Bitmap ( wf Bitmap , width , height , true ) ; wf Ambient Bitmap = Bitmap . create Scaled Bitmap ( wf Ambient Bitmap , width , height , true ) ; if ( height < ORIGINAL SIZE ) { k = ( float ) height / ORIGINAL SIZE ; sec Scaled Bitmap = scale Bitmap ( sec Bitmap ) ; min Scaled Bitmap = scale Bitmap ( min Bitmap ) ; hr Scaled Bitmap = scale Bitmap ( hr Bitmap ) ; hr Ambient Scaled Bitmap = scale Bitmap ( hr Ambient Bitmap ) ; min Ambient Scaled Bitmap = scale Bitmap ( min Ambient Bitmap ) ; } else { sec Scaled Bitmap = sec Bitmap ; min Scaled Bitmap = min Bitmap ; hr Scaled Bitmap = hr Bitmap ; hr Ambient Scaled Bitmap = hr Ambient Bitmap ; min Ambient Scaled Bitmap = min Ambient Bitmap ; } center X = width / NUM_ ; center Y = height / NUM_ ; float seconds = calendar . get ( Calendar . SECOND ) + calendar . get ( Calendar . MILLISECOND ) / NUM_ ; float minutes = calendar . get ( Calendar . MINUTE ) + seconds / NUM_ ; float hours = calendar . get ( Calendar . HOUR ) + minutes / NUM_ ; float minutes Rotation = minutes * MINUTES TO DEGREES + NUM_ ; float hours Rotation = hours * HOURS TO DEGREES + NUM_ ; boolean is Interactive = ! is In Ambient Mode ( ) ; Paint m Filter Paint = new Paint ( ) ; m Filter Paint . set Filter Bitmap ( true ) ; if ( is Interactive ) { canvas . draw Color ( Color . BLACK ) ; canvas . draw Bitmap ( wf Bitmap , NUM_ , NUM_ , m Filter Paint ) ; draw Base Ticks ( canvas , minutes Rotation , hours Rotation , seconds ) ; } else { canvas . draw Bitmap ( wf Ambient Bitmap , NUM_ , NUM_ , m Filter Paint ) ; draw Ambient Ticks ( canvas , minutes Rotation , hours Rotation ) ; } }
protected void merge Scanned Results ( List < Result > scanned Result List ) { long start = System . current Time Millis ( ) ; LOGGER . debug ( STR_ ) ; for ( int i = NUM_ ; i < scanned Result List . size ( ) ; i ++ ) { merged Scanned Result . merge ( scanned Result List . get ( i ) ) ; } LOGGER . debug ( STR_ + ( System . current Time Millis ( ) - start ) ) ; }
static public void pre Init ( String application Name ) { Log 4 J Util . init Logging ( ) ; try { Application . set Application Name ( application Name ) ; } catch ( Illegal Access Exception | Illegal Argument Exception ex ) { log . error ( STR_ ) ; } log . info ( Log 4 J Util . startup Info ( application Name ) ) ; pre Init = true ; }
public void leave Source ( Node Handler handler , Context context ) { if ( TRACE ) { indent = indent . substring ( NUM_ , indent . length ( ) - NUM_ ) ; trace ( indent + STR_ + Navigator . get Path ( context . get Context Node Info ( ) ) + STR_ ) ; } my Debugger . pop Source ( ) ; }
public void result Changed ( Result Changed Event evt ) { m URL = evt . get URL ( ) ; m User = evt . get User ( ) ; m Password = evt . get Password ( ) ; m Query = evt . get Query ( ) ; m Label Query . set Text ( STR_ + m Query ) ; }
public static Argument Exception missing Mandatory Non Interactive Argument ( Argument arg ) { Localizable Message msg = ERR DSCFG ERROR MISSING NON INTERACTIVE ARG . get ( arg . get Long Identifier ( ) ) ; return new Argument Exception ( msg ) ; }
protected void reset Common ( ) throws XNI Exception { int count = f Common Components . size ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { XML Component c = ( XML Component ) f Common Components . get ( i ) ; c . reset ( this ) ; } }
@ Override public void member Online ( Internal Distributed Member member , Persistent Member ID persistent ID ) { this . membership Changed = true ; }
public void add Swipe Listener ( On Swipe Listener listener ) { if ( m Listeners == null ) { m Listeners = new Array List < > ( ) ; } m Listeners . add ( listener ) ; }
public static void register Reportable Object ( Reportable obj ) { report Objects . add ( obj ) ; }
public String full Location ( String location ) { String Builder buf = new String Builder ( ) ; if ( ! env Name . is Empty ( ) ) { String prop Value = System . get Property ( env Name ) ; if ( prop Value == null ) { String err Msg = STR_ + env Name + STR_ ; Debug . log Error ( err Msg , module ) ; throw new Illegal Argument Exception ( err Msg ) ; } buf . append ( prop Value ) ; } buf . append ( prefix ) ; buf . append ( location ) ; return buf . to String ( ) ; }
@ Override public void history Changed ( History Changed Event evt ) { load History ( false ) ; m History . set Property ( evt . get History Name ( ) , model To String ( evt . get History ( ) ) ) ; save History ( ) ; }
@ Override public void on Location Changed ( Location location ) { if ( GPS . equals ( location . get Provider ( ) ) ) { m Gps Location = location ; update Fused Location ( ) ; } else if ( NETWORK . equals ( location . get Provider ( ) ) ) { m Network Location = location ; update Fused Location ( ) ; } }
protected void st Exit ( ) { is Dead = true ; set Runnable ( false ) ; }
@ On Close public void on Close ( final Session session , final Close Reason close Reason ) { remove Session ( session ) ; }
public void teardown ( ) { holding Buffer . clear ( ) ; }
private void z Internal Set Time Text Field ( String text ) { skip Text Field Changed Function While True = true ; if ( settings . use Lowercase For Display Time ) { text = text . to Lower Case ( settings . get Locale ( ) ) ; } time Text Field . set Text ( text ) ; skip Text Field Changed Function While True = false ; z Event Text Field Changed ( ) ; }
private void drawables Selected ( List < File > files ) { Array < File Handle > file Handles = new Array < > ( ) ; for ( File file : files ) { file Handles . add ( new File Handle ( file ) ) ; } drawables Selected ( file Handles ) ; }
protected void guard ( final Guard r ) throws Interrupted Exception { thread Guard . guard ( r ) ; }
public synchronized void send Command ( AR Drone drone , Controller Button button ) throws IO Exception { List < Assignable Control > commands = map . get ( button ) ; if ( commands == null ) { return ; } for ( Iterator < Assignable Control > it = commands . iterator ( ) ; it . has Next ( ) ; ) { final Assignable Control assignable Command = it . next ( ) ; if ( assignable Command . get Delay ( ) > NUM_ ) { delay Command ( assignable Command , drone ) ; } else { assignable Command . send To Drone ( drone ) ; } } }
public File System Utils ( ) { super ( ) ; }
public void property Change ( Property Change Event e ) { String property Name = e . get Property Name ( ) ; if ( property Name == STR_ || property Name == STR_ ) { if ( e . get New Value ( ) instanceof J Scroll Bar ) { set Scroll Bar Relations ( ( J Scroll Bar ) e . get New Value ( ) ) ; } } }
public void do Send Email ( Email Params email Params ) throws IO Exception { List < String > filter Domains = new Array List < > ( ) ; filter Domains . add ( STR_ ) ; filter Domains . add ( STR_ ) ; filter Domains . add ( STR_ ) ; filter Domains . add ( STR_ ) ; filter Domains . add ( STR_ ) ; send Via Sendcloud Api ( email Params ) ; }
public void on Progress ( int bytes Written , int total Size ) { if ( total Size >= NUM_ ) { Log . d ( LOG TAG , String . format ( STR_ , bytes Written , total Size , bytes Written / ( total Size / NUM_ ) ) ) ; } }
private void on Skill Button Clicked ( ) { if ( skill Tree == null ) { Intent i = new Intent ( get Context ( ) , Skill Tree List Activity . class ) ; i . put Extra ( ASB Activity . EXTRA FROM TALISMAN EDITOR , true ) ; i . put Extra ( ASB Activity . EXTRA TALISMAN SKILL INDEX , skill Index - NUM_ ) ; parent . start Activity For Result ( i , ASB Activity . REQUEST CODE CREATE TALISMAN ) ; } else { set Skill Tree ( null ) ; } }
protected static Header Card save New Header Card ( String key , String comment , boolean is String ) { try { return new Header Card ( key , null , comment , false , is String ) ; } catch ( Header Card Exception e ) { LOG . log ( Level . SEVERE , STR_ + key , e ) ; throw new Illegal State Exception ( e ) ; } }
public void invoke Hook Bolt Ack ( Tuple tuple , long process Latency Ns ) { if ( task Hooks . size ( ) != NUM_ ) { Bolt Ack Info ack Info = new Bolt Ack Info ( tuple , get This Task Id ( ) , process Latency Ns / Constants . MILLISECONDS TO NANOSECONDS ) ; for ( I Task Hook task Hook : task Hooks ) { task Hook . bolt Ack ( ack Info ) ; } } }
public void pre Serialize ( ) { delegate . add All ( observable Delegate ) ; }
public void on Drawer Closed ( View view ) { super . on Drawer Closed ( view ) ; if ( m Deferred On Drawer Closed Runnable != null ) { m Deferred On Drawer Closed Runnable . run ( ) ; m Deferred On Drawer Closed Runnable = null ; } on Nav Drawer State Changed ( false , false ) ; }
void make Stale ( Long overlapped ) { synchronized ( stale Io Set ) { stale Io Set . add ( overlapped ) ; } }
@ Override public void on Reset ( ) { close Dialog ( ) ; }
private boolean page Scrolled ( int x Pos ) { if ( items . size ( ) == NUM_ ) { return false ; } final int delta Scroll = x Pos - last Scroll ; virtual Pos = reverse Pos ? virtual Pos + delta Scroll : virtual Pos - delta Scroll ; last Scroll = x Pos ; final int width = get Client Width ( ) ; final float page Offset = virtual Pos / width ; if ( on Card Change Listener != null ) { on Card Change Listener . on Card Scrolled ( current Item , page Offset , ( int ) virtual Pos ) ; } on Page Scrolled ( ) ; return true ; }
@ Override public synchronized void start Manager ( ) { try { if ( logger . is Debug Enabled ( ) ) { logger . debug ( STR_ ) ; } Runtime rt = Runtime . get Runtime ( ) ; this . pooled Membership Executor = Executors . new Fixed Thread Pool ( rt . available Processors ( ) ) ; running = true ; start Managing Activity ( ) ; messenger . broadcast Manager Info ( ) ; } catch ( Interrupted Exception e ) { running = false ; throw new Management Exception ( e ) ; } catch ( Exception e ) { running = false ; throw new Management Exception ( e ) ; } }
private void handle End Of Stream ( State state , Inner State inner State ) throws Stop Request { m Info . m Current Bytes = inner State . m Bytes So Far ; m DB . update Download ( m Info ) ; boolean length Mismatched = ( inner State . m Header Content Length != null ) && ( inner State . m Bytes So Far != Integer . parse Int ( inner State . m Header Content Length ) ) ; if ( length Mismatched ) { if ( cannot Resume ( inner State ) ) { throw new Stop Request ( Downloader Service . STATUS CANNOT RESUME , STR_ ) ; } else { throw new Stop Request ( get Final Status For Http Error ( state ) , STR_ ) ; } } }
public void on Stop ( Grunt Process grunt Process , Grunt Runner Configuration grunt Runner Configuration ) { if ( grunt Runner Configuration != null ) { port Service . release ( grunt Runner Configuration . get Http Port ( ) ) ; port Service . release ( grunt Runner Configuration . get Live Reload Port ( ) ) ; Run Request run Request = grunt Runner Configuration . get Request ( ) ; String project Name = run Request . get Project ( ) ; String workspace = run Request . get Workspace ( ) ; project Event Service . remove Listener ( workspace , project Name , grunt Process ) ; } }
protected Set Val ( Value ... values ) { this ( Arrays . as List ( values ) ) ; }
void on Continue Permission Request ( ) { rationale Accepted . set ( true ) ; request Permissions To System ( pending Permissions ) ; }
public void on Blocked ( ) { resolution = Resolution . BLOCKED ; combat Icon Time = System . current Time Millis ( ) ; play Sound From Category ( Sound Layer . FIGHTING NOISE . group Name , STR_ ) ; }
void update Visual Position ( ) { Vertical Info old Info = my Caret Info ; Logical Position vis Unaware Pos = new Logical Position ( my Logical Caret . line , my Logical Caret . column ) ; set Current Logical Caret ( vis Unaware Pos ) ; my Visible Caret = my Editor . logical To Visual Position ( my Logical Caret ) ; update Visual Line Info ( ) ; my Editor . update Caret Cursor ( ) ; request Repaint ( old Info ) ; }
@ Override public Array List < Array List < Region > > define Regions ( Array List < Chart Set > data ) { Array List < Array List < Region > > result = new Array List < Array List < Region > > ( ) ; Array List < Region > region Set ; float x ; float y ; for ( Chart Set set : data ) { region Set = new Array List < Region > ( set . size ( ) ) ; for ( Chart Entry e : set . get Entries ( ) ) { x = e . get X ( ) ; y = e . get Y ( ) ; region Set . add ( new Region ( ( int ) ( x - s Region Radius ) , ( int ) ( y - s Region Radius ) , ( int ) ( x + s Region Radius ) , ( int ) ( y + s Region Radius ) ) ) ; } result . add ( region Set ) ; } return result ; }
private void finished Dispatching ( boolean dispatched ) { this . dispatched = dispatched ; if ( notifier != null ) { synchronized ( notifier ) { notifier . notify All ( ) ; } } if ( listener != null ) { listener . run ( ) ; } }
public void done ( ) { Count Down Latch latch = this . latch ; latch . count Down ( ) ; }
void update Waiting Commands ( ) { int index = commit Index ; if ( is Leader ( ) ) { Core Cmd ccmd = wait Queue . peek ( ) ; while ( ccmd != null && ccmd . index <= index ) { latency . tail ( ccmd . index ) ; ccmd . update ( Command . STATUS OK , leader Id ) ; wait Queue . poll ( ) ; ccmd = wait Queue . peek ( ) ; } } save Queue . get Latest ( saved Rid ) ; index = Math . min ( commit Index , saved Rid . index ) ; commit Queue . update Commit Index ( index ) ; }
private int read Input Data ( byte [ ] buf , int off , int len ) throws IO Exception { cb Lock . lock ( ) ; try { return iis . read ( buf , off , len ) ; } finally { cb Lock . unlock ( ) ; } }
void locked Query ( Object lower Bound Key , int lower Bound Operator , Object upper Bound Key , int upper Bound Operator , Collection results , Set keys To Remove , Execution Context context ) throws Type Mismatch Exception , Function Domain Exception , Name Resolution Exception , Query Invocation Target Exception { throw new Unsupported Operation Exception ( STR_ ) ; }
private String multiple Selector String ( int current Number , int individual Total , int total Number ) { Number Sequencer tmp Sequencer = new Number Sequencer ( total Number ) ; tmp Sequencer . set Current Number ( current Number ) ; String Builder selector String = new String Builder ( ) ; for ( int i = NUM_ ; i < individual Total ; i ++ ) { selector String . append ( single Selector String ( tmp Sequencer . next Number ( ) ) ) ; if ( i > NUM_ ) { selector String . append ( STR_ ) ; } } return selector String . to String ( ) ; }
public void invoke Hook Spout Fail ( Object message Id , long fail Latency Ns ) { if ( task Hooks . size ( ) != NUM_ ) { Spout Fail Info fail Info = new Spout Fail Info ( message Id , get This Task Id ( ) , fail Latency Ns / Constants . MILLISECONDS TO NANOSECONDS ) ; for ( I Task Hook task Hook : task Hooks ) { task Hook . spout Fail ( fail Info ) ; } } }
public void end Element ( String q Name ) throws SAX Exception { if ( ! namespaces ) { if ( content Handler != null ) { content Handler . end Element ( STR_ , STR_ , q Name . intern ( ) ) ; } return ; } String names [ ] = process Name ( q Name , false , false ) ; if ( content Handler != null ) { content Handler . end Element ( names [ NUM_ ] , names [ NUM_ ] , names [ NUM_ ] ) ; Enumeration prefixes = ns Support . get Declared Prefixes ( ) ; while ( prefixes . has More Elements ( ) ) { String prefix = ( String ) prefixes . next Element ( ) ; content Handler . end Prefix Mapping ( prefix ) ; } } ns Support . pop Context ( ) ; }
public void replace With ( Scope new Scope ) { if ( child Scopes != null ) { for ( Scope kid : child Scopes ) { new Scope . add Child Scope ( kid ) ; } child Scopes . clear ( ) ; child Scopes = null ; } if ( symbol Table != null && ! symbol Table . is Empty ( ) ) { join Scopes ( this , new Scope ) ; } }
protected void default Sort ( Comparator < ? super T > comparator ) { Collections . sort ( this , comparator ) ; }
public OM Graphic List init ( ) { OM Graphic List om List = new OM Graphic List ( ) ; OM Line line = new OM Line ( NUM_ , - NUM_ , NUM_ , - NUM_ , OM Graphic . LINETYPE GREATCIRCLE ) ; line . set Stroke ( new Basic Stroke ( NUM_ ) ) ; line . put Attribute ( OM Graphic Constants . LABEL , new OM Text Labeler ( STR_ ) ) ; line . set Line Paint ( Color . red ) ; line . set Select Paint ( Color . blue ) ; line . put Attribute ( OM Graphic Constants . TOOLTIP , STR_ ) ; om List . add ( line ) ; OM Graphic List point List = new OM Graphic List ( ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { OM Point point = new OM Point ( ( float ) ( Math . random ( ) * NUM_ ) , ( float ) ( Math . random ( ) * - NUM_ ) , NUM_ ) ; point . put Attribute ( OM Graphic Constants . TOOLTIP , STR_ + i ) ; point . set Line Paint ( Color . green ) ; point . set Select Paint ( Color . yellow ) ; point List . add ( point ) ; } om List . add ( point List ) ; return om List ; }
private void read Object ( Object Input Stream in ) throws Class Not Found Exception , IO Exception { in . default Read Object ( ) ; set Before Caret Text ( this . before Caret ) ; set After Caret Text ( this . after Caret ) ; }
public Cache Object load ( Object key , int x , int y , int zoom Level , Projection proj ) { if ( key instanceof String ) { String image Path = ( String ) key ; if ( verbose ) { logger . fine ( STR_ + image Path ) ; } try { URL image URL = Prop Utils . get Resource Or File Or URL ( image Path ) ; if ( image URL != null ) { Buffered Image bi = Buffered Image Helper . get Buffered Image ( image URL ) ; OM Graphic raster = create OM Graphic From Buffered Image ( bi , x , y , zoom Level , proj ) ; if ( raster != null ) { return new Cache Object ( image Path , raster ) ; } } else { logger . fine ( STR_ + image Path ) ; } } catch ( Malformed URL Exception e ) { logger . fine ( STR_ + image Path ) ; } catch ( Interrupted Exception e ) { logger . fine ( STR_ + image Path ) ; } catch ( Exception fnfe ) { logger . fine ( STR_ + image Path ) ; } } return null ; }
public Trigger Option with Late Firings At Every ( Duration duration ) { Time Trigger trigger = new Time Trigger ( Type . LATE , duration ) ; trigger List . add ( trigger ) ; return this ; }
public void put Response Get Resource ( String resource Id , Byte Buffer object ) { Resource Id rid = gson . from Json ( resource Id , Resource Id . class ) ; logger . debug ( STR_ , rid . get Name ( ) ) ; Object o = null ; try { o = Resource . deserialize Object ( object ) ; } catch ( IO Exception e ) { logger . error ( e . get Message ( ) , e ) ; } catch ( Class Not Found Exception e ) { logger . error ( e . get Message ( ) , e ) ; } synchronized ( get Resource Response ) { get Resource Response . put ( rid , o ) ; get Resource Response . notify All ( ) ; } }
@ After public void tear Down ( Test Context context ) { vertx . close ( context . async Assert Success ( ) ) ; }
public void on Accuracy Changed ( Sensor sensor , int accuracy ) { if ( sensor . get Type ( ) != Sensor . TYPE ACCELEROMETER ) { return ; } if ( this . status == Accel Listener . STOPPED ) { return ; } this . accuracy = accuracy ; }
@ Suppress Warnings ( STR_ ) protected int call Speak ( String text , float volume , int utterance Id ) { Hash Map < String , String > params = new Hash Map < String , String > ( ) ; if ( volume != NUM_ ) { params . put ( Text To Speech . Engine . KEY PARAM VOLUME , Double . to String ( volume ) ) ; } params . put ( Text To Speech . Engine . KEY PARAM UTTERANCE ID , Integer . to String ( utterance Id ) ) ; return m Text To Speech . speak ( text , Text To Speech . QUEUE FLUSH , params ) ; }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } dispatch On Page Scrolled ( position , offset , offset Pixels ) ; if ( m Page Transformer != null ) { final int scroll X = get Scroll X ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Left ( ) - scroll X ) / get Client Width ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = true ; }
public void close ( ) { named Param Sql Cache . clear ( ) ; named Param Index Prop Cache . clear ( ) ; clear Statement Cache ( ) ; if ( use Connection != null ) { try { use Connection . close ( ) ; } catch ( SQL Exception e ) { LOG . finest ( STR_ + e . get Message ( ) ) ; } } }
private Response do RSET ( SMTP Session session , String argument ) { if ( ( argument == null ) || ( argument . length ( ) == NUM_ ) ) { session . reset State ( ) ; return OK ; } else { return SYNTAX ERROR ; } }
public boolean is Turnout Connectivity Complete ( ) { return turnout Connectivity ; }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof Information Delegator ) { Debug . message ( STR_ , STR_ ) ; set Info Delegator ( ( Information Delegator ) some Obj ) ; } if ( some Obj instanceof Coord Info Formatter Handler ) { set Coord Formatter Handler ( ( Coord Info Formatter Handler ) some Obj ) ; } }
@ Override @ Nullable public Object find Template Source ( @ Not Null String name ) throws IO Exception { File file = resolve Name ( name ) ; Template Source template Source = Template Source . open ( file ) ; push Template Folder ( file . get Parent File ( ) ) ; return template Source ; }
@ Override public void after Properties Set ( ) throws Exception { registered Class . add ( this ) ; init ( ) ; }
public void reset ( ) { data . clear ( ) ; m Regions . clear ( ) ; m To Update Values . clear ( ) ; ver Controller . min Label Value = NUM_ ; ver Controller . max Label Value = NUM_ ; if ( hor Controller . mandatory Border Spacing != NUM_ ) hor Controller . mandatory Border Spacing = NUM_ ; style . threshold Paint = null ; style . grid Paint = null ; style . has Horizontal Grid = false ; style . has Vertical Grid = false ; }
void did Succeed ( final Callable task ) { nended . increment And Get ( ) ; try { final boolean waiting = false ; release Locks ( waiting ) ; } catch ( Throwable t ) { log . warn ( STR_ + t , t ) ; } if ( INFO ) log . info ( STR_ + nended ) ; }
public boolean compute Scroll Offset ( ) { if ( m Finished ) { return false ; } int time Passed = ( int ) ( Animation Utils . current Animation Time Millis ( ) - m Start Time ) ; if ( time Passed < m Duration ) { switch ( m Mode ) { case SCROLL MODE : float x = time Passed * m Duration Reciprocal ; if ( m Interpolator == null ) x = viscous Fluid ( x ) ; else x = m Interpolator . get Interpolation ( x ) ; m Curr X = m Start X + Math . round ( x * m Delta X ) ; m Curr Y = m Start Y + Math . round ( x * m Delta Y ) ; break ; case FLING MODE : final float t = ( float ) time Passed / m Duration ; final int index = ( int ) ( NB SAMPLES * t ) ; float distance Coef = NUM_ ; float velocity Coef = NUM_ ; if ( index < NB SAMPLES ) { final float t inf = ( float ) index / NB SAMPLES ; final float t sup = ( float ) ( index + NUM_ ) / NB SAMPLES ; final float d inf = SPLINE POSITION [ index ] ; final float d sup = SPLINE POSITION [ index + NUM_ ] ; velocity Coef = ( d sup - d inf ) / ( t sup - t inf ) ; distance Coef = d inf + ( t - t inf ) * velocity Coef ; } m Curr Velocity = velocity Coef * m Distance / m Duration * NUM_ ; m Curr X = m Start X + Math . round ( distance Coef * ( m Final X - m Start X ) ) ; m Curr X = Math . min ( m Curr X , m Max X ) ; m Curr X = Math . max ( m Curr X , m Min X ) ; m Curr Y = m Start Y + Math . round ( distance Coef * ( m Final Y - m Start Y ) ) ; m Curr Y = Math . min ( m Curr Y , m Max Y ) ; m Curr Y = Math . max ( m Curr Y , m Min Y ) ; if ( m Curr X == m Final X && m Curr Y == m Final Y ) { m Finished = true ; } break ; } } else { m Curr X = m Final X ; m Curr Y = m Final Y ; m Finished = true ; } return true ; }
public static void stop Run Timer ( ) { exec End Time = System . nano Time ( ) ; }
private void delete Progress Item ( ) { int progress Position = get Global Position Of ( m Progress Item ) ; if ( progress Position >= NUM_ ) { m Items . remove ( m Progress Item ) ; notify Item Removed ( progress Position ) ; } }
public void disconnected ( Mqtt Exception reason ) { final String method Name = STR_ ; log . fine ( CLASS NAME , method Name , STR_ , new Object [ ] { reason } ) ; this . connected = false ; try { if ( clean Session ) { clear State ( ) ; } pending Messages . clear ( ) ; pending Flows . clear ( ) ; synchronized ( ping Outstanding Lock ) { ping Outstanding = NUM_ ; } } catch ( Mqtt Exception e ) { } }
protected void fire Projection Changed ( ) { Projection proj = get Rotated Projection ( ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + proj ) ; } try { fire Property Change ( Projection Property , null , proj ) ; } catch ( Projection Change Veto Exception pcve ) { fire Property Change ( Projection Vetoed Property , proj , pcve ) ; pcve . update With Parameters ( this ) ; return ; } for ( Component c : get Components ( ) ) { Layer l = ( Layer ) c ; if ( l != null ) { l . set Ready To Paint ( false ) ; } } projection Support . fire Projection Changed ( proj ) ; purge And Notify Removed Layers ( ) ; }
@ Override protected void key Typed ( char par 1 , int par 2 ) { name Box . textbox Key Typed ( par 1 , par 2 ) ; if ( par 2 == NUM_ || par 2 == NUM_ ) action Performed ( ( Gui Button ) button List . get ( NUM_ ) ) ; }
public static Ads Service create Ads Service ( ) { try { Ads Service ads Service = ( Ads Service ) service . new Instance ( ) ; return ads Service ; } catch ( Instantiation Exception ex ) { ex . print Stack Trace ( ) ; } catch ( Illegal Access Exception ex ) { ex . print Stack Trace ( ) ; } return null ; }
private void priority Layout 2 ( int level [ ] , int priorities [ ] , int b Centers [ ] , int hor Positions [ ] ) { int desc Order [ ] = new int [ priorities . length ] ; desc Order [ NUM_ ] = NUM_ ; for ( int i = NUM_ ; i < priorities . length - NUM_ ; i ++ ) { int j = i ; int temp = i + NUM_ ; while ( j > - NUM_ && priorities [ desc Order [ j ] ] < priorities [ temp ] ) { desc Order [ j + NUM_ ] = desc Order [ j ] ; j -- ; } j ++ ; desc Order [ j ] = temp ; } for ( int k = NUM_ ; k < desc Order . length ; k ++ ) { for ( int i = NUM_ ; i < desc Order . length ; i ++ ) { int left Count = NUM_ , right Count = NUM_ , left Nodes [ ] , right Nodes [ ] ; for ( int j = NUM_ ; j < priorities . length ; j ++ ) { if ( hor Positions [ level [ desc Order [ i ] ] ] > hor Positions [ level [ j ] ] ) { left Count ++ ; } else if ( hor Positions [ level [ desc Order [ i ] ] ] < hor Positions [ level [ j ] ] ) { right Count ++ ; } } left Nodes = new int [ left Count ] ; right Nodes = new int [ right Count ] ; for ( int j = NUM_ , l = NUM_ , r = NUM_ ; j < priorities . length ; j ++ ) { if ( hor Positions [ level [ desc Order [ i ] ] ] > hor Positions [ level [ j ] ] ) { left Nodes [ l ++ ] = j ; } else if ( hor Positions [ level [ desc Order [ i ] ] ] < hor Positions [ level [ j ] ] ) { right Nodes [ r ++ ] = j ; } } while ( Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] - NUM_ - b Centers [ desc Order [ i ] ] ) < Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] - b Centers [ desc Order [ i ] ] ) ) { int temp = hor Positions [ level [ desc Order [ i ] ] ] ; boolean cant Move = false ; for ( int j = left Nodes . length - NUM_ ; j >= NUM_ ; j -- ) { if ( temp - hor Positions [ level [ left Nodes [ j ] ] ] > NUM_ ) { break ; } else if ( priorities [ desc Order [ i ] ] <= priorities [ left Nodes [ j ] ] ) { cant Move = true ; break ; } else { temp = hor Positions [ level [ left Nodes [ j ] ] ] ; } } if ( cant Move ) { break ; } temp = hor Positions [ level [ desc Order [ i ] ] ] - NUM_ ; for ( int j = left Nodes . length - NUM_ ; j >= NUM_ ; j -- ) { if ( temp == hor Positions [ level [ left Nodes [ j ] ] ] ) { hor Positions [ level [ left Nodes [ j ] ] ] = temp = hor Positions [ level [ left Nodes [ j ] ] ] - NUM_ ; } } hor Positions [ level [ desc Order [ i ] ] ] = hor Positions [ level [ desc Order [ i ] ] ] - NUM_ ; } while ( Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] + NUM_ - b Centers [ desc Order [ i ] ] ) < Math . abs ( hor Positions [ level [ desc Order [ i ] ] ] - b Centers [ desc Order [ i ] ] ) ) { int temp = hor Positions [ level [ desc Order [ i ] ] ] ; boolean cant Move = false ; for ( int right Node : right Nodes ) { if ( hor Positions [ level [ right Node ] ] - temp > NUM_ ) { break ; } else if ( priorities [ desc Order [ i ] ] <= priorities [ right Node ] ) { cant Move = true ; break ; } else { temp = hor Positions [ level [ right Node ] ] ; } } if ( cant Move ) { break ; } temp = hor Positions [ level [ desc Order [ i ] ] ] + NUM_ ; for ( int j = NUM_ ; j < right Nodes . length ; j ++ ) { if ( temp == hor Positions [ level [ right Nodes [ j ] ] ] ) { hor Positions [ level [ right Nodes [ j ] ] ] = temp = hor Positions [ level [ right Nodes [ j ] ] ] + NUM_ ; } } hor Positions [ level [ desc Order [ i ] ] ] = hor Positions [ level [ desc Order [ i ] ] ] + NUM_ ; } } } }
public void process Starts ( ) throws Operator Exception { apply Count . set ( NUM_ ) ; apply Count At Last Execution = NUM_ ; }
public synchronized void release ( Object obj ) { if ( obj == null ) { throw new Null Pointer Exception ( STR_ + STR_ ) ; } if ( alloced . remove ( obj ) == false ) { throw new Illegal Argument Exception ( STR_ + obj ) ; } free Resource ( obj ) ; notify All ( ) ; }
public void login Start ( final String username ) { if ( inactive ) return ; logs . add ( save Login Start ( username ) ) ; active Log Timer ( ) ; }
public synchronized void cancel If Killed ( Future < ? > f ) { clean Futures To Kill ( ) ; if ( is Killed ( ) ) { f . cancel ( true ) ; } future To Cancel . add ( new Weak Reference < > ( f ) ) ; }
public void deinstall ( J Editor Pane c ) { c . remove Caret Listener ( input Attribute Updater ) ; c . remove Property Change Listener ( input Attribute Updater ) ; current Run = null ; current Paragraph = null ; }
protected void end Page ( Page Format format , Printable painter , int index ) throws Printer Exception { m PS Stream . println ( PAGE RESTORE ) ; m PS Stream . println ( SHOWPAGE ) ; }
public void will Be Displayed ( ) { if ( fragment Container != null ) { Animation fade In = Animation Utils . load Animation ( get Activity ( ) , R . anim . fade in ) ; fragment Container . start Animation ( fade In ) ; } }
public void build ( ) throws SQL Exception { build Templates ( ) ; }
public void start ( ) { if ( cameras != null ) { Camera Descriptor camera = cameras . get ( current Camera ) ; Camera View cv = get Preview ( camera ) ; if ( cv . is Available ( ) ) { open ( ) ; } } }
@ Override public void mouse Exited ( final Mouse Event e ) { if ( units Changed ( null ) ) { final Mouse Details md = convert ( e ) ; current Units = null ; notify Mouse Enter Unit ( Collections . empty List ( ) , get Territory ( e . get X ( ) , e . get Y ( ) ) , md ) ; } }
public void init ( Servlet Config config ) throws Servlet Exception { super . init ( config ) ; Servlet Context context = config . get Servlet Context ( ) ; String descriptions = context . get Init Parameter ( TILE SET DESCRIPTION ATTRIBUTE ) ; Logger logger = get Logger ( ) ; logger . info ( STR_ + descriptions ) ; if ( descriptions != null ) { try { URL description Folder = Prop Utils . get Resource Or File Or URL ( descriptions ) ; Properties Wanderer wanderer = new Properties Wanderer ( new File ( description Folder . get File ( ) ) ) ; } catch ( Malformed URL Exception e ) { logger . warning ( STR_ + descriptions ) ; } catch ( Null Pointer Exception npe ) { logger . warning ( STR_ + descriptions ) ; } } }
@ Call Super protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } dispatch On Page Scrolled ( position , offset , offset Pixels ) ; if ( m Page Transformer != null ) { final int scroll X = get Scroll X ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Left ( ) - scroll X ) / get Client Width ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = true ; }
public void do Search ( ) { do Refresh ( ) ; }
private boolean handle Before Slide Changed ( ) { Fragment current Fragment = m Pager Adapter . get Item ( pager . get Current Item ( ) ) ; Log Helper . d ( TAG , String . format ( STR_ , current Fragment ) ) ; if ( current Fragment instanceof I Slide Policy ) { I Slide Policy slide = ( I Slide Policy ) current Fragment ; Log Helper . d ( TAG , STR_ ) ; if ( ! slide . is Policy Respected ( ) ) { Log Helper . d ( TAG , STR_ ) ; return false ; } } Log Helper . d ( TAG , STR_ ) ; return true ; }
public void on Retry ( int retry No ) { Log . d ( LOG TAG , String . format ( STR_ , retry No ) ) ; }
protected Algo Pull Tight ( Routing Board p board , Net Nos List p only net no arr , Thread Stoppable p stoppable thread , Brd Keep Point p keep point , int p min move dist ) { r board = p board ; only net no arr = p only net no arr ; stoppable = p stoppable thread ; keep point = p keep point ; min move dist = Math . max ( p min move dist , NUM_ ) ; }
public void form List Downloading Complete ( Hash Map < String , Form Details > result ) { dismiss Dialog ( PROGRESS DIALOG ) ; m Download Form List Task . set Downloader Listener ( null ) ; m Download Form List Task = null ; if ( result == null ) { Log . e ( t , STR_ ) ; create Alert Dialog ( get String ( R . string . load remote form error ) , get String ( R . string . error occured ) , EXIT ) ; return ; } if ( result . contains Key ( Download Form List Task . DL AUTH REQUIRED ) ) { show Dialog ( AUTH DIALOG ) ; } else if ( result . contains Key ( Download Form List Task . DL ERROR MSG ) ) { String dialog Message = get String ( R . string . list failed with error , result . get ( Download Form List Task . DL ERROR MSG ) . error Str ) ; String dialog Title = get String ( R . string . load remote form error ) ; create Alert Dialog ( dialog Title , dialog Message , DO NOT EXIT ) ; } else { m Form Names And UR Ls = result ; m Form List . clear ( ) ; Array List < String > ids = new Array List < String > ( m Form Names And UR Ls . key Set ( ) ) ; for ( int i = NUM_ ; i < result . size ( ) ; i ++ ) { String form Details Key = ids . get ( i ) ; Form Details details = m Form Names And UR Ls . get ( form Details Key ) ; Hash Map < String , String > item = new Hash Map < String , String > ( ) ; item . put ( FORMNAME , details . form Name ) ; item . put ( FORMID DISPLAY , ( ( details . form Version == null ) ? STR_ : ( get String ( R . string . version ) + STR_ + details . form Version + STR_ ) ) + STR_ + details . form ID ) ; item . put ( FORMDETAIL KEY , form Details Key ) ; if ( m Form List . size ( ) == NUM_ ) { m Form List . add ( item ) ; } else { int j ; for ( j = NUM_ ; j < m Form List . size ( ) ; j ++ ) { Hash Map < String , String > compare Me = m Form List . get ( j ) ; String name = compare Me . get ( FORMNAME ) ; if ( name . compare To ( m Form Names And UR Ls . get ( ids . get ( i ) ) . form Name ) > NUM_ ) { break ; } } m Form List . add ( j , item ) ; } } m Form List Adapter . notify Data Set Changed ( ) ; } }
public void on Button No Clicked ( View view ) { start Activity ( new Intent ( get Application Context ( ) , Main Activity . class ) ) ; set Result ( RESULT CANCELED ) ; finish ( ) ; }
public void handle Document Event ( Document Event e ) { if ( running && parsers . size ( ) > NUM_ ) { timer . restart ( ) ; } }
public void find And Init ( Iterator it ) { while ( it . has Next ( ) ) { find And Init ( it . next ( ) ) ; } }
@ Subscribe Event public void on Render ( Render Tick Event event ) { if ( event . phase == Phase . START ) { resize If Needed ( ) ; } }
public boolean on Intercept Touch Event ( Motion Event ev ) { @ Suppress Warnings ( STR_ ) final boolean debug = false ; if ( debug ) { Log . d ( Launcher . TAG , STR_ + ev + STR_ + m Dragging ) ; } if ( m Is Accessible Drag ) { return false ; } acquire Velocity Tracker And Add Movement ( ev ) ; final int action = ev . get Action ( ) ; final int [ ] drag Layer Pos = get Clamped Drag Layer Pos ( ev . get X ( ) , ev . get Y ( ) ) ; final int drag Layer X = drag Layer Pos [ NUM_ ] ; final int drag Layer Y = drag Layer Pos [ NUM_ ] ; switch ( action ) { case Motion Event . ACTION MOVE : break ; case Motion Event . ACTION DOWN : m Motion Down X = drag Layer X ; m Motion Down Y = drag Layer Y ; m Last Drop Target = null ; break ; case Motion Event . ACTION UP : m Last Touch Up Time = System . current Time Millis ( ) ; if ( m Dragging ) { Point F vec = is Flinging To Delete ( m Drag Object . drag Source ) ; if ( ! Delete Drop Target . supports Drop ( m Drag Object . drag Info ) ) { vec = null ; } if ( vec != null ) { drop On Fling To Delete Target ( drag Layer X , drag Layer Y , vec ) ; } else { drop ( drag Layer X , drag Layer Y ) ; } } end Drag ( ) ; break ; case Motion Event . ACTION CANCEL : cancel Drag ( ) ; break ; } return m Dragging ; }
@ Override protected void on Detached From Window ( ) { super . on Detached From Window ( ) ; if ( m Deco Event Manager != null ) { m Deco Event Manager . reset Events ( ) ; } }
void close ( String name ) { if ( jmx ) { try { Utils . call Static Method ( STR_ , name ) ; } catch ( Exception e ) { throw Db Exception . get ( Error Code . FEATURE NOT SUPPORTED 1 , e , STR_ ) ; } } DATABASES . remove ( name ) ; }
public void comment ( String data ) throws org . xml . sax . SAX Exception { final int length = data . length ( ) ; if ( length > m chars Buff . length ) { m chars Buff = new char [ length * NUM_ + NUM_ ] ; } data . get Chars ( NUM_ , length , m chars Buff , NUM_ ) ; comment ( m chars Buff , NUM_ , length ) ; }
public Data File create Data File ( ) { Data File data File = new Data File ( ) ; data File List . add ( data File ) ; return data File ; }
public void popup Menu Canceled ( Popup Menu Event e ) { if ( should Act Like Button ( ) || pressed When Popup Visible ) { combo Box . repaint ( ) ; } }
public static int overload 1 or 2 With Conn ( int one , int two ) { return one + two ; }
private Boot Util ( ) { throw new Assertion Error ( STR_ ) ; }
public void action Performed ( Action Event e ) { File next Page = ( File ) J Option Pane . show Input Dialog ( eeze Frame , STR_ , STR_ , J Option Pane . PLAIN MESSAGE , null , test Files . to Array ( ) , current Displayed ) ; try { switch Page ( next Page , false ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } }
void enable GUI ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ ) ; } if ( ! init ) { log . error ( STR_ ) ; } load Button . set Enabled ( true ) ; load Button . set Tool Tip Text ( res . get String ( STR_ ) ) ; status . set Text ( res . get String ( STR_ ) ) ; }
public void on Absorb ( int velocity ) { m State = STATE ABSORB ; velocity = Math . max ( MIN VELOCITY , Math . abs ( velocity ) ) ; m Start Time = Animation Utils . current Animation Time Millis ( ) ; m Duration = NUM_ + ( velocity * NUM_ ) ; m Edge Alpha Start = NUM_ ; m Edge Scale Y = m Edge Scale Y Start = NUM_ ; m Glow Alpha Start = NUM_ ; m Glow Scale Y Start = NUM_ ; m Edge Alpha Finish = Math . max ( NUM_ , Math . min ( velocity * VELOCITY EDGE FACTOR , NUM_ ) ) ; m Edge Scale Y Finish = Math . max ( HELD EDGE SCALE Y , Math . min ( velocity * VELOCITY EDGE FACTOR , NUM_ ) ) ; m Glow Scale Y Finish = Math . min ( NUM_ + ( velocity * ( velocity / NUM_ ) * NUM_ ) , NUM_ ) ; m Glow Alpha Finish = Math . max ( m Glow Alpha Start , Math . min ( velocity * VELOCITY GLOW FACTOR * NUM_ , MAX ALPHA ) ) ; }
protected void close Dialog Ok ( ) { wta . set K ( Integer . parse Int ( k Value . get Text ( ) ) ) ; super . close Dialog Ok ( ) ; }
public void state Changed ( Change Event e ) { if ( e == null ) { throw new Null Pointer Exception ( ) ; } fire Property Change ( ACCESSIBLE VISIBLE DATA PROPERTY , Boolean . value Of ( false ) , Boolean . value Of ( true ) ) ; }
public void reset ( ) { for ( Async Task task : m Tasks ) { task . cancel ( true ) ; } m Tasks . clear ( ) ; }
public static UUID xor UUID ( UUID a , UUID b ) { return new UUID ( a . get Most Significant Bits ( ) ^ b . get Most Significant Bits ( ) , a . get Least Significant Bits ( ) ^ b . get Least Significant Bits ( ) ) ; }
protected Completion Stage < Result > on Dev Server Error ( Http . Request Header request , Useful Exception exception ) { Object Node json Error = Json . new Object ( ) ; final Throwable cause = exception . cause ; final String description = exception . description ; final String id = exception . id ; final String title = exception . title ; json Error . put ( STR_ , description ) ; json Error . put ( STR_ , title ) ; json Error . put ( STR_ , id ) ; json Error . put ( STR_ , exception . get Message ( ) ) ; json Error . set ( STR_ , causes To Json ( cause ) ) ; return Completable Future . completed Future ( Results . internal Server Error ( json Error ) ) ; }
public void on New Intent ( Intent intent ) { if ( m Initialization Complete ) { m Activity Delegate . on New Intent With Native ( intent ) ; } else { if ( m Pending New Intents == null ) m Pending New Intents = new Array List < Intent > ( NUM_ ) ; m Pending New Intents . add ( intent ) ; } }
private void build Rev Call Graph ( ) { rev call graph = new Hash Map < Integer , Linked List < Cg Edge > > ( ) ; for ( int i = NUM_ ; i < n func ; ++ i ) { Cg Edge p = call graph [ i ] ; while ( p != null ) { Linked List < Cg Edge > list = rev call graph . get ( p . t ) ; if ( list == null ) { list = new Linked List < Cg Edge > ( ) ; rev call graph . put ( p . t , list ) ; } list . add ( p ) ; p = p . next ; } } }
@ Override public void on Create ( Bundle saved Instance State ) { super . on Create ( saved Instance State ) ; m Handler = new Handler ( ) ; set Content View ( R . layout . voice recognition ) ; Button speak Button = ( Button ) find View By Id ( R . id . btn speak ) ; m List = ( List View ) find View By Id ( R . id . list ) ; m Supported Language View = ( Spinner ) find View By Id ( R . id . supported languages ) ; Package Manager pm = get Package Manager ( ) ; List < Resolve Info > activities = pm . query Intent Activities ( new Intent ( Recognizer Intent . ACTION RECOGNIZE SPEECH ) , NUM_ ) ; if ( activities . size ( ) != NUM_ ) { speak Button . set On Click Listener ( this ) ; } else { speak Button . set Enabled ( false ) ; speak Button . set Text ( STR_ ) ; } refresh Voice Settings ( ) ; }
@ Override public void on Draw ( ) { if ( m Is Controller Attached ) { return ; } if ( ! m Trimmed ) { F Log . wtf ( Drawee Event Tracker . class , STR_ , System . identity Hash Code ( this ) , System . identity Hash Code ( m Controller ) , to String ( ) ) ; } m Trimmed = false ; m Is Holder Attached = true ; m Is Visible = true ; attach Or Detach Controller ( ) ; }
public void commit Random ( final Randomizer rand ) { rand . set Pdf ( pdf ) ; if ( pdf == Prob Distribution . NULL ) { return ; } double param 1 = Utils . double Parsable ( tf Param 1 ) ; if ( tf Param 1 . is Enabled ( ) && ! Double . is Na N ( param 1 ) ) { rand . set Param 1 Consistent ( pdf . get Param 1 Name ( ) , param 1 ) ; } double param 2 = Utils . double Parsable ( tf Param 2 ) ; if ( tf Param 2 . is Enabled ( ) && ! Double . is Na N ( param 2 ) ) { rand . set Param 2 Consistent ( pdf . get Param 2 Name ( ) , param 2 ) ; } if ( ! ts Clipping . is Null ( ) ) { rand . set Clipping ( ts Clipping . is Selected ( ) ) ; if ( ts Clipping . is Selected ( ) ) { double upper Bound = Utils . double Parsable ( tf Up Bound ) ; if ( ! Double . is Na N ( upper Bound ) ) { rand . set Upper Bound ( upper Bound ) ; } double lower Bound = Utils . double Parsable ( tf Low Bound ) ; if ( ! Double . is Na N ( lower Bound ) ) { rand . set Lower Bound ( lower Bound ) ; } } } }
private void unshare ( int need Extra ) { int shared Len = input Len ; input Len = NUM_ ; char [ ] input Buf = input Buffer ; input Buffer = null ; int start = input Start ; input Start = - NUM_ ; int needed = shared Len + need Extra ; if ( current Segment == null || needed > current Segment . length ) { current Segment = find Buffer ( needed ) ; } if ( shared Len > NUM_ ) { System . arraycopy ( input Buf , start , current Segment , NUM_ , shared Len ) ; } segment Size = NUM_ ; current Size = shared Len ; }
private void compute Crc For Writing ( ) { crcengine = new CRC 32 ( ) ; crcengine . update ( idbytes , NUM_ , NUM_ ) ; if ( len > NUM_ ) crcengine . update ( data , NUM_ , len ) ; Png Helper Internal . write Int 4 tobytes ( ( int ) crcengine . get Value ( ) , crcval , NUM_ ) ; }
public Encrypted Editor put Float ( String key , float value ) { put Value ( key , String . value Of ( value ) ) ; return this ; }
public void on Record Complete ( Record Complete Listener listener ) { on Record Complete ( listener , Fork Join Pool . common Pool ( ) ) ; }
public static void start Run Timer ( ) { exec Start Time = System . nano Time ( ) ; }
public static void instrument ( Instrumentation inst ) throws Class Not Found Exception , Unmodifiable Class Exception , IO Exception { inst . redefine Classes ( new Class Definition [ ] { get Redefined Class ( Object . class ) } ) ; }
public void action Performed ( Action Event e ) { boolean ok ; int ret Val ; if ( ! check Modified ( ) ) return ; ret Val = m File Chooser . show Open Dialog ( File Scripting Panel . this ) ; if ( ret Val != J File Chooser . APPROVE OPTION ) return ; ok = m Script . open ( m File Chooser . get Selected File ( ) ) ; m Text Code . set Caret Position ( NUM_ ) ; if ( ! ok ) J Option Pane . show Message Dialog ( File Scripting Panel . this , STR_ + m File Chooser . get Selected File ( ) + STR_ ) ; notify Title Updated Listeners ( new Title Updated Event ( File Scripting Panel . this ) ) ; }
private synchronized Content Model Validator create Child Model ( int content Spec Index ) { XML Content Spec content Spec = new XML Content Spec ( ) ; get Content Spec ( content Spec Index , content Spec ) ; if ( ( content Spec . type & NUM_ ) == XML Content Spec . CONTENTSPECNODE ANY || ( content Spec . type & NUM_ ) == XML Content Spec . CONTENTSPECNODE ANY OTHER || ( content Spec . type & NUM_ ) == XML Content Spec . CONTENTSPECNODE ANY LOCAL ) { } else if ( content Spec . type == XML Content Spec . CONTENTSPECNODE LEAF ) { if ( content Spec . value == null && content Spec . other Value == null ) throw new Runtime Exception ( STR_ ) ; f Q Name . set Values ( null , ( String ) content Spec . value , ( String ) content Spec . value , ( String ) content Spec . other Value ) ; return new Simple Content Model ( content Spec . type , f Q Name , null ) ; } else if ( ( content Spec . type == XML Content Spec . CONTENTSPECNODE CHOICE ) || ( content Spec . type == XML Content Spec . CONTENTSPECNODE SEQ ) ) { XML Content Spec content Spec Left = new XML Content Spec ( ) ; XML Content Spec content Spec Right = new XML Content Spec ( ) ; get Content Spec ( ( ( int [ ] ) content Spec . value ) [ NUM_ ] , content Spec Left ) ; get Content Spec ( ( ( int [ ] ) content Spec . other Value ) [ NUM_ ] , content Spec Right ) ; if ( ( content Spec Left . type == XML Content Spec . CONTENTSPECNODE LEAF ) && ( content Spec Right . type == XML Content Spec . CONTENTSPECNODE LEAF ) ) { f Q Name . set Values ( null , ( String ) content Spec Left . value , ( String ) content Spec Left . value , ( String ) content Spec Left . other Value ) ; f Q Name 2 . set Values ( null , ( String ) content Spec Right . value , ( String ) content Spec Right . value , ( String ) content Spec Right . other Value ) ; return new Simple Content Model ( content Spec . type , f Q Name , f Q Name 2 ) ; } } else if ( ( content Spec . type == XML Content Spec . CONTENTSPECNODE ZERO OR ONE ) || ( content Spec . type == XML Content Spec . CONTENTSPECNODE ZERO OR MORE ) || ( content Spec . type == XML Content Spec . CONTENTSPECNODE ONE OR MORE ) ) { XML Content Spec content Spec Left = new XML Content Spec ( ) ; get Content Spec ( ( ( int [ ] ) content Spec . value ) [ NUM_ ] , content Spec Left ) ; if ( content Spec Left . type == XML Content Spec . CONTENTSPECNODE LEAF ) { f Q Name . set Values ( null , ( String ) content Spec Left . value , ( String ) content Spec Left . value , ( String ) content Spec Left . other Value ) ; return new Simple Content Model ( content Spec . type , f Q Name , null ) ; } } else { throw new Runtime Exception ( STR_ ) ; } f Leaf Count = NUM_ ; f Leaf Count = NUM_ ; CM Node cmn = build Syntax Tree ( content Spec Index , content Spec ) ; return new DFA Content Model ( cmn , f Leaf Count , false ) ; }
private void init Connection ( ) throws Core Token Exception { if ( connection == null || ! factory . is Valid ( connection ) ) { try { connection = factory . create ( ) ; query . set Connection ( connection ) ; } catch ( Data Layer Exception e ) { throw new Core Token Exception ( STR_ , e ) ; } } }
@ Override public void on Finish Input ( ) { super . on Finish Input ( ) ; m Composing . set Length ( NUM_ ) ; update Candidates ( ) ; set Candidates View Shown ( false ) ; m Cur Keyboard = m Qwerty Keyboard ; if ( m Input View != null ) { m Input View . closing ( ) ; } }
private final Object slot Exchange ( Object item , boolean timed , long ns ) { Node p = participant . get ( ) ; Thread t = Thread . current Thread ( ) ; if ( t . is Interrupted ( ) ) return null ; for ( Node q ; ; ) { if ( ( q = slot ) != null ) { if ( U . compare And Swap Object ( this , SLOT , q , null ) ) { Object v = q . item ; q . match = item ; Thread w = q . parked ; if ( w != null ) U . unpark ( w ) ; return v ; } if ( NCPU > NUM_ && bound == NUM_ && U . compare And Swap Int ( this , BOUND , NUM_ , SEQ ) ) arena = new Node [ ( FULL + NUM_ ) << ASHIFT ] ; } else if ( arena != null ) return null ; else { p . item = item ; if ( U . compare And Swap Object ( this , SLOT , null , p ) ) break ; p . item = null ; } } int h = p . hash ; long end = timed ? System . nano Time ( ) + ns : NUM_ ; int spins = ( NCPU > NUM_ ) ? SPINS : NUM_ ; Object v ; while ( ( v = p . match ) == null ) { if ( spins > NUM_ ) { h ^= h << NUM_ ; h ^= h > > > NUM_ ; h ^= h << NUM_ ; if ( h == NUM_ ) h = SPINS | ( int ) t . get Id ( ) ; else if ( h < NUM_ && ( -- spins & ( ( SPINS > > > NUM_ ) - NUM_ ) ) == NUM_ ) Thread . yield ( ) ; } else if ( slot != p ) spins = SPINS ; else if ( ! t . is Interrupted ( ) && arena == null && ( ! timed || ( ns = end - System . nano Time ( ) ) > NUM_ ) ) { U . put Object ( t , BLOCKER , this ) ; p . parked = t ; if ( slot == p ) U . park ( false , ns ) ; p . parked = null ; U . put Object ( t , BLOCKER , null ) ; } else if ( U . compare And Swap Object ( this , SLOT , p , null ) ) { v = timed && ns <= NUM_ && ! t . is Interrupted ( ) ? TIMED OUT : null ; break ; } } U . put Ordered Object ( p , MATCH , null ) ; p . item = null ; p . hash = h ; return v ; }
public void callback ( final long status id , final String twitlonger message id ) throws Exception { final Array List < Name Value Pair > args = new Array List < > ( NUM_ ) ; args . add ( new Basic Name Value Pair ( STR_ , app name ) ) ; args . add ( new Basic Name Value Pair ( STR_ , api key ) ) ; args . add ( new Basic Name Value Pair ( STR_ , twitlonger message id ) ) ; args . add ( new Basic Name Value Pair ( STR_ , Long . to String ( status id ) ) ) ; try { final Http Client httpclient = new Default Http Client ( ) ; final Http Post httppost = new Http Post ( TWITLONGER API CALLBACK ) ; httppost . set Entity ( new Url Encoded Form Entity ( args , STR_ ) ) ; final Http Response response = httpclient . execute ( httppost ) ; final String response Str = Entity Utils . to String ( response . get Entity ( ) , STR_ ) ; final Xml Pull Parser Factory factory = Xml Pull Parser Factory . new Instance ( ) ; factory . set Namespace Aware ( true ) ; final Xml Pull Parser parser = factory . new Pull Parser ( ) ; parser . set Input ( new String Reader ( response Str ) ) ; int event Type = parser . get Event Type ( ) ; String tag Name ; boolean looking For End Of Unknown Tag = false ; String unknown Tag Name = null ; do { if ( event Type == Xml Pull Parser . START TAG ) { tag Name = parser . get Name ( ) ; if ( TAG TWITLONGER . equals ( tag Name ) ) { event Type = parser . next ( ) ; break ; } throw new Runtime Exception ( STR_ + TAG TWITLONGER + STR_ + tag Name ) ; } event Type = parser . next ( ) ; } while ( event Type != Xml Pull Parser . END DOCUMENT ) ; boolean end Of Document = false ; while ( ! end Of Document ) { switch ( event Type ) { case Xml Pull Parser . START TAG : { if ( looking For End Of Unknown Tag ) { break ; } tag Name = parser . get Name ( ) ; if ( TAG POST . equals Ignore Case ( tag Name ) ) { } else if ( TAG ERROR . equals Ignore Case ( tag Name ) ) throw new Twit Longer Exception ( STR_ + parser . next Text ( ) ) ; else { looking For End Of Unknown Tag = true ; unknown Tag Name = tag Name ; } break ; } case Xml Pull Parser . END TAG : { tag Name = parser . get Name ( ) ; if ( looking For End Of Unknown Tag && tag Name . equals ( unknown Tag Name ) ) { looking For End Of Unknown Tag = false ; unknown Tag Name = null ; } break ; } case Xml Pull Parser . END DOCUMENT : { end Of Document = true ; } } event Type = parser . next ( ) ; } } catch ( final IO Exception e ) { throw new Twit Longer Exception ( e ) ; } catch ( final Xml Pull Parser Exception e ) { throw new Twit Longer Exception ( e ) ; } }
public void paint ( Graphics g , Component c ) { int x = c . get X ( ) ; int y = c . get Y ( ) ; int width = c . get Width ( ) ; int height = c . get Height ( ) ; if ( outer Border != null ) { if ( paint Outer Border First ) { outer Border . paint ( g , x , y , width , height , c ) ; paint ( g , x + thickness , y + thickness , width - thickness * NUM_ , height - thickness * NUM_ , c ) ; } else { paint ( g , x + thickness , y + thickness , width - thickness * NUM_ , height - thickness * NUM_ , c ) ; outer Border . paint ( g , x , y , width , height , c ) ; } } else { paint ( g , x , y , width , height , c ) ; } }
public void mouse Pressed ( Mouse Event e ) { if ( Swing Utilities 2 . should Ignore ( e , tree ) ) { return ; } if ( is Editing ( tree ) && tree . get Invokes Stop Cell Editing ( ) && ! stop Editing ( tree ) ) { return ; } complete Editing ( ) ; pressed Path = get Closest Path For Location ( tree , e . get X ( ) , e . get Y ( ) ) ; if ( tree . get Drag Enabled ( ) ) { mouse Pressed DND ( e ) ; } else { Swing Utilities 2 . adjust Focus ( tree ) ; handle Selection ( e ) ; } }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } transform Pages ( ) ; m Called Super = true ; }
public Trigger Option with Early Firings At Every ( long count ) { Count Trigger trigger = new Count Trigger ( Type . EARLY , count ) ; trigger List . add ( trigger ) ; return this ; }
@ Override public void on Destroy ( ) { LOG . d ( TAG , STR_ ) ; super . on Destroy ( ) ; if ( this . app View != null ) { app View . handle Destroy ( ) ; } else { this . activity State = ACTIVITY EXITING ; } }
public void processed Password Change ( Long event Time , String user DN ) throws AM Auth Call Back Exception { Map event Params = new Hash Map ( ) ; event Params . put ( AM Auth Call Back . TIME KEY , event Time ) ; event Params . put ( AM Auth Call Back . REALM KEY , the Realm ) ; event Params . put ( AM Auth Call Back . USER KEY , user DN ) ; processed Event ( AM Auth Call Back . PASSWORD CHANGE , event Params ) ; }
protected void sleep ( final int wait Time ) throws Interrupted Exception { Thread . sleep ( wait Time ) ; }
private void put Namespaces ( XML Stream Reader reader ) { for ( int i = NUM_ ; i < reader . get Namespace Count ( ) ; i ++ ) { final String prefix = reader . get Namespace Prefix ( i ) ; if ( prefix != null ) { put Namespace ( prefix , reader . get Namespace URI ( i ) ) ; } } }
protected void wait For Shutdown Signal ( ) throws Interrupted Exception { if ( mutex Waiting == null ) { mutex Waiting = new Object ( ) ; } try { synchronized ( mutex Waiting ) { mutex Waiting . wait ( ) ; } } catch ( Interrupted Exception e ) { if ( ! shutdown ) { throw e ; } } }
protected Prepared Script ( Program prog , String [ ] inputs , String [ ] outputs ) { prog = prog ; vars = new Local Variable Map ( ) ; in Varnames = new Hash Set < String > ( ) ; Collections . add All ( in Varnames , inputs ) ; out Varnames = new Hash Set < String > ( ) ; Collections . add All ( out Varnames , outputs ) ; in Var Reuse = new Hash Map < String , Data > ( ) ; }
@ Override public void end ( ) { super . end ( ) ; m moves To Undo . clear ( ) ; }
public void add Swipe Listener ( Swipe Listener listener ) { if ( m Listeners == null ) { m Listeners = new Array List < > ( ) ; } m Listeners . add ( listener ) ; }
protected static String canonicalize Prefix ( String prefix ) { prefix = prefix . replace ( STR_ , STR_ ) ; if ( prefix . length ( ) > NUM_ && ! prefix . ends With ( STR_ ) ) { prefix += STR_ ; } return prefix ; }
protected void reset ( ) throws XNI Exception { if ( f Validation Manager != null ) f Validation Manager . reset ( ) ; int count = f Components . size ( ) ; for ( int i = NUM_ ; i < count ; i ++ ) { XML Component c = ( XML Component ) f Components . get ( i ) ; c . reset ( this ) ; } }
protected void on Exception ( final Wro Runtime Exception e ) { throw e ; }
public void fling ( long time , float x , float y , float velocity X , float velocity Y ) { if ( m Drag Lock != Drag Lock . SCROLL && m Discarding Tab != null ) { float velocity = m Current Mode == Orientation . PORTRAIT ? velocity X : velocity Y ; float max Delta = get Discard Range ( ) * DISCARD FLING MAX CONTRIBUTION ; float delta Amount = Math Utils . clamp ( velocity * DISCARD FLING DT , - max Delta , max Delta ) ; m Discarding Tab . add To Discard Amount ( delta Amount ) ; } else if ( m Overview Animation Type == Overview Animation Type . NONE && m Scroller . is Finished ( ) && m Over Scroll Offset == NUM_ && get Tab Index At Positon ( x , y ) >= NUM_ ) { float velocity = m Current Mode == Orientation . PORTRAIT ? velocity Y : ( Localization Utils . is Layout Rtl ( ) ? - velocity X : velocity X ) ; m Scroller . fling ( NUM_ , ( int ) m Scroll Target , NUM_ , ( int ) velocity , NUM_ , NUM_ , ( int ) get Min Scroll ( false ) , ( int ) get Max Scroll ( false ) , NUM_ , ( int ) ( ( velocity > NUM_ ? m Max Over Scroll : m Max Under Scroll ) * MAX OVER FLING SCALE ) , time ) ; set Scroll Target ( m Scroller . get Final Y ( ) , false ) ; } }
@ Override protected void before Show ( ) { super . before Show ( ) ; m Current = m Editor . get Value ( ) ; if ( m Editor . get Custom Editor ( ) instanceof GOE Panel ) m Result = CANCEL OPTION ; else m Result = APPROVE OPTION ; }
public void run Once ( Runnable task ) { temporary Tasks . add ( task ) ; }
@ Override public final int size ( ) { return ( int ) Math . max ( tail . get ( ) - head . get ( ) , NUM_ ) ; }
protected void mouse Clicked ( int mouse X , int mouse Y , int mouse Button ) throws IO Exception { super . mouse Clicked ( mouse X , mouse Y , mouse Button ) ; for ( Gui Text Field gtf : this . fields ) gtf . mouse Clicked ( mouse X , mouse Y , mouse Button ) ; }
private void handle Mouse Move ( final Event e ) { final int x = e . x , y = e . y ; final Image img = orientation == SWT . HORIZONTAL ? slider : v Slider ; upper Hover = x >= coord Upper . x && x <= coord Upper . x + img . get Bounds ( ) . width && y >= coord Upper . y && y <= coord Upper . y + img . get Bounds ( ) . height ; lower Hover = x >= coord Lower . x && x <= coord Lower . x + img . get Bounds ( ) . width && y >= coord Lower . y && y <= coord Lower . y + img . get Bounds ( ) . height ; if ( drag In Progress ) { if ( orientation == SWT . HORIZONTAL ) { final int mouse Value = ( int ) ( ( x - NUM_ ) / compute Pixel Size For Horizonal Slider ( ) ) + minimum ; if ( last Selected == SELECTED KNOB . UPPER ) { upper Value = ( int ) ( Math . ceil ( mouse Value / increment ) * increment ) - increment ; check Upper Value ( ) ; } else { lower Value = ( int ) ( Math . ceil ( mouse Value / increment ) * increment ) - increment ; check Lower Value ( ) ; } } else { final int mouse Value = ( int ) ( ( y - NUM_ ) / compute Pixel Size For Vertical Slider ( ) ) + minimum ; if ( last Selected == SELECTED KNOB . UPPER ) { upper Value = ( int ) ( Math . ceil ( mouse Value / increment ) * increment ) - increment ; check Upper Value ( ) ; } else { lower Value = ( int ) ( Math . ceil ( mouse Value / increment ) * increment ) - increment ; check Lower Value ( ) ; } } } redraw ( ) ; }
@ Override public void on Extracted Text Clicked ( ) { if ( m Re Correction Enabled && is Prediction On ( ) ) return ; super . on Extracted Text Clicked ( ) ; }
public Volatile Image create Back Buffer ( W Component Peer peer ) { Component target = ( Component ) peer . get Target ( ) ; return new Sun Volatile Image ( target , target . get Width ( ) , target . get Height ( ) , Boolean . TRUE ) ; }
public String add Manager ( ) throws Exception { if ( resource == null ) { return NOT FOUND ; } User u = user Manager . get ( id ) ; if ( u != null && ! potential Managers . contains ( u ) ) { add Action Error ( get Text ( STR_ , new String [ ] { id } ) ) ; } else if ( u != null ) { resource . add Manager ( u ) ; add Action Message ( get Text ( STR_ , new String [ ] { u . get Name ( ) } ) ) ; save Resource ( ) ; potential Managers . remove ( u ) ; } return execute ( ) ; }
@ Override public void run ( ) { try { while ( running ) { step ( ) ; try { Thread . sleep ( step Pause ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } } } catch ( Null Pointer Exception e ) { robot Gui . notify Initialize ( ) ; } catch ( Robot Exception e ) { } try { running Lock . acquire ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } running = false ; gui . enable Buttons ( gui . button State Normal ) ; button . set Text ( gui . auto Locate Title ) ; running Lock . release ( ) ; }
public boolean evaluate ( Feature Class Info fci , List < Object > row ) { boolean ret = true ; String Buffer reasoning = null ; if ( logger . is Loggable ( Level . FINE ) ) { reasoning = new String Buffer ( ) ; logger . fine ( to String ( ) ) ; } if ( exp != null ) { ret = exp . evaluate ( fci , row , reasoning ) ; } if ( reasoning != null ) { reasoning . append ( STR_ ) ; logger . fine ( reasoning . to String ( ) ) ; } return ret ; }
protected Resources fetch Resource File ( ) { try { if ( resource File != null ) { return resource File ; } String p = get Resource File Path ( ) ; if ( p . index Of ( STR_ ) > - NUM_ ) { return Resources . open ( p ) ; } Resources res = Resources . open Layered ( p ) ; if ( is Keep Resources In Ram ( ) ) { resource File = res ; } return res ; } catch ( IO Exception ex ) { ex . print Stack Trace ( ) ; return null ; } }
@ Override public void reload ACK ( final Page Position position ) { if ( recovered ACK == null ) { recovered ACK = new Linked List < > ( ) ; } recovered ACK . add ( position ) ; }
@ Override public void finish ( ) throws Cleartk Processing Exception { all False Writer . close ( ) ; all False File . delete ( ) ; for ( Print Writer pw : training Data Writers . values ( ) ) { pw . flush ( ) ; pw . close ( ) ; } super . finish ( ) ; }
void clean Up ( ) { Map tmp Cq = this . cqs ; if ( tmp Cq . size ( ) > NUM_ ) { for ( Object server Cq Name : tmp Cq . key Set ( ) ) { process Close Cq ( ( String ) server Cq Name ) ; } } }
@ Override public void on WZ Audio Sample Listener Release ( ) { m Update Thread . shutdown ( ) ; m Update Thread = null ; }
public void on Higher Level ( View view ) { Indoor Building building = m Map . get Focused Building ( ) ; if ( building != null ) { List < Indoor Level > levels = building . get Levels ( ) ; if ( ! levels . is Empty ( ) ) { int current Level = building . get Active Level Index ( ) ; int new Level = current Level - NUM_ ; if ( new Level == - NUM_ ) { new Level = levels . size ( ) - NUM_ ; } Indoor Level level = levels . get ( new Level ) ; set Text ( STR_ + level . get Name ( ) ) ; level . activate ( ) ; } else { set Text ( STR_ ) ; } } else { set Text ( STR_ ) ; } }
private void invoke And Wait ( Runnable run ) { if ( ! Swing Utilities . is Event Dispatch Thread ( ) ) { try { Swing Utilities . invoke And Wait ( run ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } else { run . run ( ) ; } }
void updated Text Field ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ ) ; } Cv Value cv = cv Map . get ( get Cv Num ( ) ) ; int old Cv = cv . get Value ( ) ; int new Val ; try { new Val = text To Value ( value . get Text ( ) ) ; } catch ( java . lang . Number Format Exception ex ) { new Val = NUM_ ; } int new Cv = new Value ( old Cv , new Val , get Mask ( ) ) ; if ( old Cv != new Cv ) { cv . set Value ( new Cv ) ; } }
@ Override protected void key Typed ( char par 1 , int par 2 ) { ip Box . textbox Key Typed ( par 1 , par 2 ) ; max Threads Box . textbox Key Typed ( par 1 , par 2 ) ; if ( par 2 == NUM_ || par 2 == NUM_ ) action Performed ( ( Gui Button ) button List . get ( NUM_ ) ) ; }
protected Packet ( short packettype ) { sig = new byte [ ] { STR_ , STR_ , STR_ , STR_ } ; minver = NUM_ ; majver = NUM_ ; this . packettype = packettype ; }
public void focus Gained ( Focus Event e ) { if ( focus Log . is Loggable ( Platform Logger . Level . FINE ) ) { focus Log . fine ( STR_ , e ) ; } b Has Focus = true ; }
protected String post Process Raml ( String pre Raml ) { Matcher fix Includes = INCLUDE FIXER PATTERN . matcher ( pre Raml ) ; while ( fix Includes . find ( ) ) { try { pre Raml = pre Raml . replace ( fix Includes . group ( NUM_ ) , fix Includes . group ( NUM_ ) ) ; logger . info ( STR_ + fix Includes . group ( NUM_ ) + STR_ + fix Includes . group ( NUM_ ) + STR_ ) ; } catch ( Exception ex ) { logger . error ( STR_ + ex . get Message ( ) ) ; } } return pre Raml ; }
public void handle Value ( String value ) { if ( property Name != null && value != null && value . length ( ) > NUM_ ) { CSS . Attribute css Key = CSS . get Attribute ( property Name ) ; if ( css Key != null ) { if ( css Key == CSS . Attribute . LIST STYLE IMAGE ) { if ( value != null && ! value . equals ( STR_ ) ) { URL url = CSS . get URL ( base , value ) ; if ( url != null ) { value = url . to String ( ) ; } } } add CSS Attribute ( declaration , css Key , value ) ; } property Name = null ; } }
public void find And Init ( Iterator < Object > it ) { while ( it . has Next ( ) ) { find And Init ( it . next ( ) ) ; } }
public void decorate At Time Of Capture Request Available ( Capture Result Proxy capture Result ) { Face [ ] faces Captured = capture Result . get ( Capture Result . STATISTICS FACES ) ; if ( faces Captured == null ) { m Face Proxies = null ; } else { m Face Proxies = new Array List < > ( faces Captured . length ) ; for ( Face face : faces Captured ) { m Face Proxies . add ( Camera 2 Face Proxy . from ( face ) ) ; } } m Lens Focus Distance = capture Result . get ( Capture Result . LENS FOCUS DISTANCE ) ; }
public void free SL Holder ( I Stored List Iterator < T > slh ) { if ( slh != null ) { Segmented List Iterator < T > si = ( Segmented List Iterator < T > ) slh ; slh . release ( ) ; } }
public void fire Offer Issued ( Offer offer ) { offers . add ( offer ) ; synchronized ( listeners ) { for ( Game Service Listener listener : listeners ) { listener . offer Issued ( offer ) ; } } }
private void post Buffer Access ( ) { lock . lock ( ) ; try { if ( -- buffer Use Count == NUM_ ) { flush Ready . signal All ( ) ; } } finally { lock . unlock ( ) ; } }
public static void unregister Field Prefix ( final String prefix ) { field Prefixes . remove ( prefix ) ; }
@ Override public void on Draw ( ) { if ( m Is Controller Attached ) { return ; } F Log . wtf ( Drawee Event Tracker . class , STR_ , System . identity Hash Code ( this ) , System . identity Hash Code ( m Controller ) , to String ( ) ) ; m Is Holder Attached = true ; m Is Visible = true ; m Is Activity Started = true ; attach Or Detach Controller ( ) ; }
@ Override public State Connection service ( ) { try { State Connection next State = state . service ( this ) ; return next State ; } catch ( Throwable e ) { log . warning ( e . to String ( ) ) ; log . log ( Level . FINER , e . to String ( ) , e ) ; to Close ( ) ; return State Connection . CLOSE READ A ; } }
@ Not Null public List < Pair < C , Collection < Virtual File > > > create Configurations ( @ Not Null Collection < Virtual File > files , @ Not Null Collection < C > existent Facet Configurations ) { final C configuration = create Configuration ( files ) ; if ( configuration != null ) { return Collections . singleton List ( Pair . create ( configuration , files ) ) ; } return Collections . empty List ( ) ; }
private void result Set Next ( ) { try { has Next = result Set . next ( ) ; } catch ( final SQL Exception e ) { has Next = false ; logger . error ( e , e ) ; } if ( ! has Next ) { close ( ) ; } }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } for ( On Page Change Listener each Listener : m On Page Change Listeners ) { if ( each Listener != null ) { each Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final int scroll X = get Scroll X ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Left ( ) - scroll X ) / get Client Width ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = true ; }
public Element store ( Object o ) { return null ; }
public void component Hidden ( final Component Event e ) { final Object source = e . get Source ( ) ; if ( ! ( source instanceof J Menu Item ) ) return ; set Child Visible ( ( J Menu Item ) source , false ) ; }
public void handle Periodic Maintenance ( Operation post ) { post . complete ( ) ; }
void prepare For Close ( Local Region region , Disk Region dr ) { if ( dr . is Backup ( ) ) { force Flush ( ) ; } }
public void processed Event ( int event Type , Map event Params ) throws AM Auth Call Back Exception { if ( plugin Set != Collections . EMPTY SET ) { Iterator itr = plugin Set . iterator ( ) ; while ( itr . has Next ( ) ) { AM Auth Call Back plugin Class = instantiate Class ( ( String ) itr . next ( ) ) ; if ( plugin Class != null ) plugin Class . auth Event Callback ( event Type , event Params ) ; } } if ( plugin Set . is Empty ( ) && debug . message Enabled ( ) ) { debug . message ( STR_ + STR_ ) ; } }
protected void inc Local Sibling Count ( ) { synchronized ( fsm ) { local Sibling Count ++ ; } }
public static void register Error Listener ( Error Listener l ) { error Listeners . add ( l ) ; }
public void subscription ( String topic , int qos , boolean sub ) { set Title Text ( STR_ ) ; if ( connected ) { try { String [ ] these Topics = new String [ NUM_ ] ; int [ ] these Qo S = new int [ NUM_ ] ; these Topics [ NUM_ ] = topic ; these Qo S [ NUM_ ] = qos ; synchronized ( this ) { if ( sub ) { write Logln ( STR_ + topic + STR_ + qos ) ; } else { write Logln ( STR_ + topic ) ; } } if ( sub ) { mqtt . subscribe ( these Topics , these Qo S ) ; } else { mqtt . unsubscribe ( these Topics ) ; } } catch ( Exception ex ) { set Title Text ( STR_ ) ; J Option Pane . show Message Dialog ( frame , ex . get Message ( ) , STR_ , J Option Pane . ERROR MESSAGE ) ; } } else { set Title Text ( STR_ ) ; } }
private void on Finished Movement ( ) { check Selection Changed ( ) ; invalidate ( ) ; }
private void about Upload ( List < Image Model > image Array List , final int index ) { for ( int i = NUM_ ; i < image Array List . size ( ) ; i ++ ) { m Adapter . set Progress ( index , false ) ; } }
public S 2 Polygon assemble Polygon ( ) { S 2 Polygon polygon = new S 2 Polygon ( ) ; List < S 2 Edge > unused Edges = Lists . new Array List ( ) ; assemble Polygon ( polygon , unused Edges ) ; return polygon ; }
@ Override protected void on Started ( final Player player ) { player . send Private Text ( STR_ ) ; add Event ( new Sound Event ( start Sound , SOUND RADIUS , NUM_ , Sound Layer . AMBIENT SOUND ) ) ; notify World About Changes ( ) ; }
private void z Internal Set Date Text Field ( String text ) { skip Text Field Changed Function While True = true ; date Text Field . set Text ( text ) ; skip Text Field Changed Function While True = false ; z Event Text Field Changed ( ) ; }
private void co entry pause ( ) throws SAX Exception { if ( f Coroutine Manager == null ) { init ( null , - NUM_ , - NUM_ ) ; } try { Object arg = f Coroutine Manager . co entry pause ( f Source Coroutine ID ) ; if ( arg == Boolean . FALSE ) co yield ( false ) ; } catch ( No Such Method Exception e ) { if ( DEBUG ) e . print Stack Trace ( ) ; throw new SAX Exception ( e ) ; } }
private void write Object ( Object Output Stream out ) throws IO Exception { maybe Parse ( ) ; out . default Write Object ( ) ; }
public void column Added ( Table Column Model Event e ) { Lime Table Column added Column = get To Column ( e ) ; Lime Table Column ltc = added Column ; set Visibility ( ltc , true ) ; Table Column Model tcm = table . get Column Model ( ) ; int order = get Order ( ltc ) ; int current = tcm . get Column Index ( ltc . get Id ( ) ) ; int max = tcm . get Column Count ( ) ; if ( order != current ) { stop Listening ( ) ; order = Math . min ( order , max - NUM_ ) ; tcm . move Column ( current , order ) ; for ( current = order + NUM_ ; current < max ; current ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( current ) ; set Order ( ltc , current ) ; } for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current + NUM_ ) ; } start Listening ( ) ; } if ( listener != null ) listener . column Added ( added Column , table ) ; save ( ) ; }
public Workflow . Method zone Export Masks Delete Method ( List < Network Zoning Param > zoning Params , Collection < URI > volume UR Is ) { return new Workflow . Method ( STR_ , zoning Params , volume UR Is ) ; }
protected Solr Input Document process ( Solr Input Document doc ) { String doc Lang = null ; Hash Set < String > doc Langs = new Hash Set < > ( ) ; String fallback Lang = get Fallback Lang ( doc , fallback Fields , fallback Value ) ; if ( lang Field == null || ! doc . contains Key ( lang Field ) || ( doc . contains Key ( lang Field ) && overwrite ) ) { List < Detected Language > languagelist = detect Language ( doc ) ; doc Lang = resolve Language ( languagelist , fallback Lang ) ; doc Langs . add ( doc Lang ) ; log . debug ( STR_ + Arrays . to String ( input Fields ) + STR_ + doc Lang ) ; if ( doc . contains Key ( lang Field ) && overwrite ) { log . debug ( STR_ + doc . get Field Value ( lang Field ) ) ; } if ( lang Field != null && lang Field . length ( ) != NUM_ ) { doc . set Field ( lang Field , doc Lang ) ; } } else { doc Lang = resolve Language ( ( String ) doc . get Field Value ( lang Field ) , fallback Lang ) ; doc Langs . add ( doc Lang ) ; log . debug ( STR_ + lang Field + STR_ + doc Lang + STR_ ) ; } if ( enable Mapping ) { for ( String field Name : all Map Fields Set ) { if ( doc . contains Key ( field Name ) ) { String field Lang ; if ( map Individual && map Individual Fields Set . contains ( field Name ) ) { List < Detected Language > languagelist = detect Language ( doc ) ; field Lang = resolve Language ( languagelist , doc Lang ) ; doc Langs . add ( field Lang ) ; log . debug ( STR_ + field Name + STR_ + field Lang ) ; } else { field Lang = doc Lang ; log . debug ( STR_ + field Name + STR_ + field Lang ) ; } String mapped Output Field = get Mapped Field ( field Name , field Lang ) ; if ( mapped Output Field != null ) { log . debug ( STR_ , doc . get Field Value ( doc Id Field ) , field Lang ) ; Solr Input Field in Field = doc . get Field ( field Name ) ; doc . set Field ( mapped Output Field , in Field . get Value ( ) , in Field . get Boost ( ) ) ; if ( ! map Keep Orig ) { log . debug ( STR_ , field Name ) ; doc . remove Field ( field Name ) ; } } else { throw new Solr Exception ( Solr Exception . Error Code . BAD REQUEST , STR_ + field Name + STR_ + field Lang ) ; } } } } if ( langs Field != null && langs Field . length ( ) != NUM_ ) { doc . set Field ( langs Field , doc Langs . to Array ( ) ) ; } return doc ; }
static public void done With Arguments ( Context ctx , Local Member res [ ] ) { for ( int i = NUM_ ; i < res . length ; i ++ ) { if ( res [ i ] . original Of Copy . access Peer == res [ i ] ) { res [ i ] . original Of Copy . access Peer = null ; } } }
private static void clean Model ( Model pom ) { Properties properties = new Sorted Properties ( ) ; properties . put All ( pom . get Properties ( ) ) ; pom . set Properties ( properties ) ; }
public static void open Browser ( String url ) { last Url = url ; }
public void on Show ( Form f ) { if ( on Current Form Change != null ) { on Current Form Change . run ( ) ; } }
private void signal Control Op End ( ) { control Operation Executing . set ( false ) ; Lock Support . unpark ( control Waiters . peek ( ) ) ; if ( control Waiters . size ( ) == NUM_ ) { Thread t = eval Waiters . poll ( ) ; while ( t != null ) { Lock Support . unpark ( t ) ; t = eval Waiters . poll ( ) ; } } }
public void select ( OM Graphic List list ) { if ( list != null && ! list . is Empty ( ) ) { OM Graphic omg = list . get OM Graphic At ( NUM_ ) ; Drawing Tool dt = get Drawing Tool ( ) ; if ( dt != null && dt . can Edit ( omg . get Class ( ) ) ) { dt . set Behavior Mask ( OM Drawing Tool . QUICK CHANGE BEHAVIOR MASK ) ; if ( dt . edit ( omg , this ) == null ) { fire Request Info Line ( STR_ ) ; } } } }
public void clear Clusters ( ) { clusters . clear ( ) ; }
@ Override public double total Estimated Quantity For RE ( final Long wo Activity Id , Long estimate Id , final Long activity Id , final Work Order work Order ) { if ( estimate Id == null ) estimate Id = - NUM_ ; Object [ ] params = null ; Double est Quantity = null ; params = new Object [ ] { estimate Id , work Order , work Order , wo Activity Id , activity Id } ; est Quantity = ( Double ) generic Service . find By Named Query ( STR_ , params ) ; Double est Quantity RE = null ; if ( work Order . get Parent ( ) != null ) params = new Object [ ] { estimate Id , work Order . get Parent ( ) , work Order . get Parent ( ) , activity Id } ; else params = new Object [ ] { estimate Id , work Order , work Order , activity Id } ; est Quantity RE = ( Double ) generic Service . find By Named Query ( STR_ , params ) ; if ( est Quantity != null && est Quantity RE != null ) est Quantity = est Quantity + est Quantity RE ; if ( est Quantity == null && est Quantity RE != null ) est Quantity = est Quantity RE ; if ( est Quantity == null ) return NUM_ ; else return est Quantity . double Value ( ) ; }
@ Override public void action Perform ( Component component ) { if ( before Refresh Handler != null ) { before Refresh Handler . run ( ) ; } Collection Datasource datasource = owner . get Datasource ( ) ; Map < String , Object > params = get Refresh Params ( ) ; if ( params != null ) { datasource . refresh ( params ) ; } else { datasource . refresh ( ) ; } if ( after Refresh Handler != null ) { after Refresh Handler . run ( ) ; } }
public boolean mouse Pressed ( Mouse Event e ) { if ( show plot && graph != null ) { int x = e . get X ( ) ; int y = e . get Y ( ) ; if ( ( x >= plot X ) && ( x <= plot X + plot Width ) && ( y >= plot Y ) && ( y <= plot Y + plot Width ) ) { grabbed plot graphics = true ; prev X = x ; prev Y = y ; } } return false ; }
public void initialize ( ) { Thread athread = new Thread ( new Initialize Thread ( ) ) ; athread . set Name ( classname + STR_ ) ; athread . set Priority ( Thread . MIN PRIORITY ) ; athread . start ( ) ; }
public void over ( boolean value ) { m Over = value ; if ( m Over ) { m Show Actions = true ; } m Hide Actions . restart ( ) ; }
public void paint Layered Highlights ( Graphics g , int p 0 , int p 1 , Shape view Bounds , J Text Component editor , View view ) { paint List Layered ( g , p 0 , p 1 , view Bounds , editor , view , marked Occurrences ) ; super . paint Layered Highlights ( g , p 0 , p 1 , view Bounds , editor , view ) ; paint List Layered ( g , p 0 , p 1 , view Bounds , editor , view , parser Highlights ) ; }
private void tick ( ) { if ( started Index Time Stamp == NUM_ ) { started Index Time Stamp = System . current Time Millis ( ) ; } long time Elapsed Since Index Start Milliseconds = System . current Time Millis ( ) - started Index Time Stamp ; int maximum Index = divisor List . length - NUM_ ; int current Divisor = divisor List [ current Index ] ; if ( ticks Since Index Change % current Divisor == NUM_ ) { time Picker . z Internal Try Change Time By Increment ( change Amount Minutes ) ; if ( ( current Index < maximum Index ) && ( time Elapsed Since Index Start Milliseconds > millis For Divisor List [ current Index ] ) ) { ticks Since Index Change = NUM_ ; ++ current Index ; started Index Time Stamp = System . current Time Millis ( ) ; } } ++ ticks Since Index Change ; }
public void remove Events ( ) { scene . set On Key Pressed ( null ) ; scene . set On Key Released ( null ) ; up = down = left = right = sprint = jump = shoot Fireball = false ; }
@ Override public void close ( ) { action Delegates . clear ( ) ; }
public @ Non Null Charge Request . Builder auto Return ( long timeout , Time Unit unit ) { long auto Return Millis ; if ( timeout != Register Api . AUTO RETURN NO TIMEOUT ) { auto Return Millis = unit . to Millis ( timeout ) ; non Null ( unit , STR_ ) ; if ( auto Return Millis < Register Api . AUTO RETURN TIMEOUT MIN MILLIS ) { throw new Illegal Argument Exception ( STR_ + Register Api . AUTO RETURN TIMEOUT MIN MILLIS ) ; } if ( auto Return Millis > Register Api . AUTO RETURN TIMEOUT MAX MILLIS ) { throw new Illegal Argument Exception ( STR_ + Register Api . AUTO RETURN TIMEOUT MAX MILLIS ) ; } } else { auto Return Millis = Register Api . AUTO RETURN NO TIMEOUT ; } this . auto Return Millis = auto Return Millis ; return this ; }
public Optional < T > execute If Absent ( Runnable action ) { if ( value == null ) action . run ( ) ; return this ; }
public void writing Request Headers ( ) { if ( sent Request Millis != - NUM_ ) { throw new Illegal State Exception ( ) ; } sent Request Millis = System . current Time Millis ( ) ; }
@ Override public void on Resume ( boolean multitasking ) { this . plugin Destroyed = false ; }
protected synchronized void bcs Pre Deserialization Hook ( Object Input Stream ois ) throws IO Exception , Class Not Found Exception { serializable = ois . read Int ( ) ; int count = serializable ; while ( count > NUM_ ) { services . put ( ois . read Object ( ) , ois . read Object ( ) ) ; count -- ; } }
public void action Performed ( Action Event e ) { String ret Val ; ret Val = J Option Pane . show Input Dialog ( File Scripting Panel . this , STR_ , Utils . join Options ( m Args ) ) ; if ( ret Val == null ) return ; try { m Args = Utils . split Options ( ret Val ) ; } catch ( Exception ex ) { m Args = new String [ NUM_ ] ; ex . print Stack Trace ( ) ; J Option Pane . show Message Dialog ( File Scripting Panel . this , STR_ + ex , STR_ , J Option Pane . ERROR MESSAGE ) ; } }
protected void monitor ( long millis Time Stamp , List < Resource Instance > resource Instances ) { monitor Statistic Ids ( millis Time Stamp , resource Instances ) ; }
static Jpa Target update Target Info ( @ Not Null final Jpa Target target , @ Not Null final Target Update Status status , final boolean set Installed Date , final Target Info Repository target Info Repository , final Entity Manager entity Manager ) { final Jpa Target Info ts = ( Jpa Target Info ) target . get Target Info ( ) ; ts . set Update Status ( status ) ; if ( set Installed Date ) { ts . set Installation Date ( System . current Time Millis ( ) ) ; } target Info Repository . save ( ts ) ; return entity Manager . merge ( target ) ; }
protected void on Obsolete ( ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , messages . application Cache Obsolete ( ) ) ; } this . obsolete = true ; updating = false ; ui Handler . show Message ( messages . application Cache Obsolete ( ) ) ; fire Application Cache Event ( Cache Event . on Obsolete ) ; }
@ Override public void on Finished ( Build Status build Status ) { if ( build Status == Build Status . SUCCESSFUL ) { project Explorer . reload Children ( ) ; names By Types . clear ( ) ; widget By Types . clear ( ) ; view . clear ( ) ; update Generate Button ( ) ; } }
@ Override public void on Tab Unselected ( Action Bar . Tab tab , Fragment Transaction ft ) { Bundle tab Holder = ( Bundle ) tab . get Tag ( ) ; String fragment Tag = tab Holder . get String ( KEY FRAGMENT TAG , STR_ ) ; Log . d ( LOG TAG , STR_ + fragment Tag ) ; save Ui Tab Context ( tab ) ; if ( fragment Tag . equals ( TAG FRAGMENT PEOPLE ROOM DETAILS ) ) { if ( null != m Room Details Members Fragment ) { ft . detach ( m Room Details Members Fragment ) ; } } else if ( fragment Tag . equals ( TAG FRAGMENT SETTINGS ROOM DETAIL ) ) { on Tab Unselected Settings Fragment ( ) ; } else if ( fragment Tag . equals ( TAG FRAGMENT FILES DETAILS ) ) { if ( null != m Search Files Fragment ) { m Search Files Fragment . cancel Catching Requests ( ) ; ft . detach ( m Search Files Fragment ) ; } } else { Log . w ( LOG TAG , STR_ ) ; } }
public void init ( ) { n var = int 2 var . size ( ) ; for ( int i = NUM_ ; i < n var ; ++ i ) { var Graph . set ( i , null ) ; int 2 var . get ( i ) . will Update = false ; } }
protected void connection Established ( Channel connected Channel ) { channel = connected Channel ; connected . set ( true ) ; connect Latch . count Down ( ) ; }
public Class < ? > load Class ( String class Name ) throws Class Not Found Exception { return load Class ( class Name , false ) ; }
protected void init ( ) throws Exception { Jetstream Application Information ai = get Application Information ( ) ; ai . self Locate ( ) ; m work Queue = new Linked Blocking Queue < Runnable > ( ai . get Work Qeue Sz ( ) ) ; m worker = new Thread Pool Executor ( ai . get Worker Threads ( ) , NUM_ , NUM_ , Time Unit . SECONDS , m work Queue , new Thread Pool Executor . Caller Runs Policy ( ) ) ; m worker . prestart Core Thread ( ) ; Management . add Bean ( ai . get Application Name ( ) , this ) ; log Info ( STR_ + ai ) ; String [ ] configs = ai . get Config Roots ( ) ; Root Configuration rc = configs == null ? new Root Configuration ( ai ) : new Root Configuration ( ai , configs ) ; rc . start ( ) ; String [ ] sa = ai . get Beans ( ) ; if ( sa != null ) for ( String bean : sa ) rc . get Bean ( bean ) ; }
public boolean mouse Pressed ( Mouse Event e ) { if ( wants Events ( ) ) { if ( omdtmm != null ) { omdtmm . mouse Pressed ( e ) ; } return consume Events ; } else { return super . mouse Pressed ( e ) ; } }
@ Override public Promise < Void , Authentication Exception > clean Subject ( Message Info Context message Info , Subject client Subject ) { return auth Module . clean Subject ( message Info , client Subject ) ; }
public static void optimize ( P Opt Mode type , Par For Statement Block sb , Par For Program Block pb , Execution Context ec , boolean monitor ) throws DML Runtime Exception { Timing time = new Timing ( true ) ; LOG . debug ( STR_ + pb . get ID ( ) + STR_ ) ; int ck = Util Functions . to Int ( Math . max ( Infrastructure Analyzer . get Ck Max CP ( ) , Infrastructure Analyzer . get Ck Max MR ( ) ) * PAR FACTOR INFRASTRUCTURE ) ; double cm = Infrastructure Analyzer . get Cm Max ( ) * Optimizer Utils . MEM UTIL FACTOR ; optimize ( type , ck , cm , sb , pb , ec , monitor ) ; double time Val = time . stop ( ) ; LOG . debug ( STR_ + pb . get ID ( ) + STR_ + time Val + STR_ ) ; if ( monitor ) Statistic Monitor . put PF Stat ( pb . get ID ( ) , Stat . OPT T , time Val ) ; }
public static void update Actor Position ( final Actor actor , final Vector 2 new Screen Size In Stage Coords ) { if ( actor != null ) { update Actor Position ( actor , actor . get Stage ( ) , new Screen Size In Stage Coords ) ; } }
private void call On Load ( ) { if ( ! jni On Load . is Zero ( ) ) { int version = run JNI On Load ( jni On Load ) ; check JNI Version ( version ) ; } }
public void add ( final Runnable task ) { synchronized ( cleanup ) { if ( ran ) { throw new Illegal State Exception ( STR_ ) ; } cleanup . add ( task ) ; } }
private synchronized void switch Removed From Store ( Datapath Id dpid ) { if ( floodlight Provider . get Role ( ) != HA Role . STANDBY ) { return ; } IOF Switch old Sw = synced Switches . remove ( dpid ) ; if ( old Sw != null ) { add Update To Queue ( new Switch Update ( dpid , Switch Update Type . REMOVED ) ) ; } else { } }
protected void property Change ( Property Change Event evt ) { if ( Sea Glass Look And Feel . should Update Style ( evt ) ) { update Style ( ( J Text Component ) evt . get Source ( ) ) ; } super . property Change ( evt ) ; }
public void start ( String message Header ) throws IO Exception { dos . write ( message Header . get Bytes ( ) ) ; }
public void node Changed ( Tree Node node ) { if ( listener List != null && node != null ) { Tree Node parent = node . get Parent ( ) ; if ( parent != null ) { int an Index = parent . get Index ( node ) ; if ( an Index != - NUM_ ) { int [ ] c Indexs = new int [ NUM_ ] ; c Indexs [ NUM_ ] = an Index ; nodes Changed ( parent , c Indexs ) ; } } else if ( node == get Root ( ) ) { nodes Changed ( node , null ) ; } } }
private Object internal Get ( final String path ) throws Illegal Argument Exception { List v = internal Get As Array ( path ) ; if ( v == null || v . size ( ) == NUM_ ) { return null ; } return v . get ( NUM_ ) ; }
public Remote Interpreter Event poll Event ( ) { synchronized ( event Queue ) { if ( event Queue . is Empty ( ) ) { try { event Queue . wait ( NUM_ ) ; } catch ( Interrupted Exception e ) { } } if ( event Queue . is Empty ( ) ) { return new Remote Interpreter Event ( Remote Interpreter Event Type . NO OP , STR_ ) ; } else { Remote Interpreter Event event = event Queue . remove ( NUM_ ) ; logger . debug ( STR_ , event . get Type ( ) ) ; return event ; } } }
@ Override public boolean on Preference Tree Click ( Preference Screen preference Screen , Preference preference ) { log ( STR_ + preference ) ; if ( preference == m Airplane Mode Preference && Boolean . parse Boolean ( System Properties . get ( Telephony Properties . PROPERTY INECM MODE ) ) ) { start Activity For Result ( new Intent ( Telephony Intents . ACTION SHOW NOTICE ECM BLOCK OTHERS , null ) , REQUEST CODE EXIT ECM ) ; return true ; } else if ( preference == find Preference ( KEY MANAGE MOBILE PLAN ) ) { on Manage Mobile Plan Click ( ) ; } return super . on Preference Tree Click ( preference Screen , preference ) ; }
@ Override public String to Property String ( ) { return String . value Of ( file Modification Stamp ) ; }
protected boolean traverse Out ( boolean direction ) { return false ; }
public Filename Utils ( ) { super ( ) ; }
@ Validation Error Page ( value = STR_ ) @ Action ( value = STR_ ) public String save Orupdate ( ) { try { errors . clear ( ) ; if ( receipt Header . get Receipt Header ( ) != null ) collection Common . cancel Challan Receipt On Creation ( receipt Header ) ; boolean set Instrument = true ; List < Instrument Header > receipt Instr List = new Array List < Instrument Header > ( ) ; receipt Header . set Is Reconciled ( Boolean . FALSE ) ; receipt Header . set Is Modifiable ( Boolean . TRUE ) ; receipt Header . set Collectiontype ( Collection Constants . COLLECTION TYPE COUNTER ) ; receipt Header . set Location ( collections Util . get Location Of User ( get Session ( ) ) ) ; receipt Header . set Status ( collections Util . get Status For Module And Code ( Collection Constants . MODULE NAME RECEIPTHEADER , Collection Constants . RECEIPT STATUS CODE TO BE SUBMITTED ) ) ; receipt Header . set Created By ( collections Util . get Logged In User ( ) ) ; receipt Header . set Created Date ( new Date ( ) ) ; if ( set Instrument ) { receipt Instr List = populate Instrument Details ( ) ; set Instrument = false ; } receipt Header . set Receipt Instrument ( new Hash Set ( receipt Instr List ) ) ; Big Decimal debit Amount = Big Decimal . ZERO ; for ( final Receipt Detail receipt Detail : receipt Header . get Receipt Details ( ) ) debit Amount = debit Amount . add ( receipt Detail . get Cramount ( ) ) ; receipt Header . add Receipt Detail ( collection Common . add Debit Account Head Details ( debit Amount , receipt Header , cheque Instrumenttotal , cash Or Card Instrumenttotal , instrument Type Cash Or Card ) ) ; if ( cheque Instrumenttotal != null && cheque Instrumenttotal . compare To ( Big Decimal . ZERO ) != NUM_ ) receipt Header . set Total Amount ( cheque Instrumenttotal ) ; if ( cash Or Card Instrumenttotal != null && cash Or Card Instrumenttotal . compare To ( Big Decimal . ZERO ) != NUM_ ) receipt Header . set Total Amount ( cash Or Card Instrumenttotal ) ; receipt Header Service . set Receipt Number ( receipt Header ) ; receipt Header Service . populate And Persist Receipts ( receipt Header , receipt Instr List ) ; final Receipt Header [ ] receipts = new Receipt Header [ NUM_ ] ; receipts [ NUM_ ] = receipt Header ; try { report Id = collection Common . generate Report ( receipts , true ) ; } catch ( final Exception e ) { LOGGER . error ( Collection Constants . REPORT GENERATION ERROR , e ) ; throw new Application Runtime Exception ( Collection Constants . REPORT GENERATION ERROR , e ) ; } return Collection Constants . REPORT ; } catch ( final Stale Object State Exception exp ) { errors . add ( new Validation Error ( get Text ( STR_ ) , STR_ ) ) ; throw new Validation Exception ( errors ) ; } catch ( final Exception exp ) { errors . add ( new Validation Error ( get Text ( STR_ ) , STR_ ) ) ; throw new Validation Exception ( errors ) ; } }
@ Override public void node Changed ( Tree Node node ) { if ( listener List != null && node != null ) { Tree Node parent = node . get Parent ( ) ; if ( parent == null && node != root ) { parent = root ; } if ( parent != null ) { int an Index = get Index Of Child ( parent , node ) ; if ( an Index != - NUM_ ) { int [ ] c Indexs = new int [ NUM_ ] ; c Indexs [ NUM_ ] = an Index ; nodes Changed ( parent , c Indexs ) ; } } } }
void update Blocks ( int start Line , int end Line , int new Line Count ) { if ( m Block End Lines == null ) { create Blocks ( ) ; return ; } int first Block = - NUM_ ; int last Block = - NUM_ ; for ( int i = NUM_ ; i < m Number Of Blocks ; i ++ ) { if ( m Block End Lines [ i ] >= start Line ) { first Block = i ; break ; } } for ( int i = first Block ; i < m Number Of Blocks ; i ++ ) { if ( m Block End Lines [ i ] >= end Line ) { last Block = i ; break ; } } final int last Block End Line = m Block End Lines [ last Block ] ; boolean create Block Before = start Line > ( first Block == NUM_ ? NUM_ : m Block End Lines [ first Block - NUM_ ] + NUM_ ) ; boolean create Block = new Line Count > NUM_ ; boolean create Block After = end Line < m Block End Lines [ last Block ] ; int num Added Blocks = NUM_ ; if ( create Block Before ) num Added Blocks ++ ; if ( create Block ) num Added Blocks ++ ; if ( create Block After ) num Added Blocks ++ ; final int num Removed Blocks = last Block - first Block + NUM_ ; final int new Number Of Blocks = m Number Of Blocks + num Added Blocks - num Removed Blocks ; if ( new Number Of Blocks == NUM_ ) { m Block End Lines [ NUM_ ] = NUM_ ; m Block Indices [ NUM_ ] = INVALID BLOCK INDEX ; m Number Of Blocks = NUM_ ; return ; } if ( new Number Of Blocks > m Block End Lines . length ) { int [ ] block End Lines = Array Utils . new Unpadded Int Array ( Math . max ( m Block End Lines . length * NUM_ , new Number Of Blocks ) ) ; int [ ] block Indices = new int [ block End Lines . length ] ; System . arraycopy ( m Block End Lines , NUM_ , block End Lines , NUM_ , first Block ) ; System . arraycopy ( m Block Indices , NUM_ , block Indices , NUM_ , first Block ) ; System . arraycopy ( m Block End Lines , last Block + NUM_ , block End Lines , first Block + num Added Blocks , m Number Of Blocks - last Block - NUM_ ) ; System . arraycopy ( m Block Indices , last Block + NUM_ , block Indices , first Block + num Added Blocks , m Number Of Blocks - last Block - NUM_ ) ; m Block End Lines = block End Lines ; m Block Indices = block Indices ; } else { System . arraycopy ( m Block End Lines , last Block + NUM_ , m Block End Lines , first Block + num Added Blocks , m Number Of Blocks - last Block - NUM_ ) ; System . arraycopy ( m Block Indices , last Block + NUM_ , m Block Indices , first Block + num Added Blocks , m Number Of Blocks - last Block - NUM_ ) ; } m Number Of Blocks = new Number Of Blocks ; int new First Changed Block ; final int delta Lines = new Line Count - ( end Line - start Line + NUM_ ) ; if ( delta Lines != NUM_ ) { new First Changed Block = first Block + num Added Blocks ; for ( int i = new First Changed Block ; i < m Number Of Blocks ; i ++ ) { m Block End Lines [ i ] += delta Lines ; } } else { new First Changed Block = m Number Of Blocks ; } m Index First Changed Block = Math . min ( m Index First Changed Block , new First Changed Block ) ; int block Index = first Block ; if ( create Block Before ) { m Block End Lines [ block Index ] = start Line - NUM_ ; m Block Indices [ block Index ] = INVALID BLOCK INDEX ; block Index ++ ; } if ( create Block ) { m Block End Lines [ block Index ] = start Line + new Line Count - NUM_ ; m Block Indices [ block Index ] = INVALID BLOCK INDEX ; block Index ++ ; } if ( create Block After ) { m Block End Lines [ block Index ] = last Block End Line + delta Lines ; m Block Indices [ block Index ] = INVALID BLOCK INDEX ; } }
@ Override protected void key Typed ( char par 1 , int par 2 ) { if ( par 2 == NUM_ || par 2 == NUM_ ) action Performed ( ( Gui Button ) button List . get ( NUM_ ) ) ; }
public void init Impl ( ) throws Config Exception { if ( handler != null ) { } else if ( path Handler != null ) { } else { set Path ( Paths . get ( STR_ ) ) ; } if ( formatter != null ) { } else if ( handler != null && handler . get Formatter ( ) != null ) { } else { formatter = new Pattern Formatter ( Pattern Formatter . DEFAULT PATTERN ) ; } if ( path Handler != null ) { path Handler . init ( ) ; handler = path Handler ; } if ( handler == null ) { throw new Config Exception ( L . l ( STR_ ) ) ; } if ( level != null ) { handler . set Level ( level ) ; } if ( formatter != null ) { handler . set Formatter ( formatter ) ; } if ( filter != null ) { handler . set Filter ( filter ) ; } if ( names . size ( ) == NUM_ ) { names . add ( STR_ ) ; } for ( String name : names ) { Logger logger = Logger . get Logger ( name ) ; if ( ! ( logger instanceof Environment Logger ) ) { if ( handler instanceof Auto Closeable ) { Env Loader . add Close Listener ( ( Auto Closeable ) handler ) ; } } logger . add Handler ( handler ) ; } }
public Encrypted Editor put Int ( String key , int value ) { put Value ( key , String . value Of ( value ) ) ; return this ; }
public void finish ( ) { if ( ready To Use == false ) { ready To Use = true ; out List . clear ( ) ; if ( table View . size ( ) == NUM_ ) return ; for ( Map . Entry < Node , List < Var Type > > entry : table View . entry Set ( ) ) { List < Var Type > res List = entry . get Value ( ) ; out List . add All ( res List ) ; } } }
public I Project [ ] add To Workspace ( String [ ] reference Strings , Project Set Serialization Context context , I Progress Monitor monitor ) throws Team Exception { monitor = Policy . monitor For ( monitor ) ; Policy . check Canceled ( monitor ) ; Map < I Project , Load Info > info Map = new Hash Map < I Project , SVN Project Set Capability . Load Info > ( reference Strings . length ) ; I Project [ ] projects = as Projects ( context , reference Strings , info Map ) ; projects = confirm Overwrite ( context , projects ) ; if ( projects == null ) { return new I Project [ NUM_ ] ; } try { return checkout ( projects , info Map , monitor ) ; } catch ( Malformed URL Exception e ) { throw SVN Exception . wrap Exception ( e ) ; } }
public boolean on Owner Changed ( Grid Cache Entry Ex entry , Grid Cache Mvcc Candidate owner ) { if ( owner != null ) { Ignite Tx Adapter tx = tx ( owner . version ( ) ) ; if ( tx == null ) tx = near Tx ( owner . version ( ) ) ; if ( tx != null ) { if ( ! tx . local ( ) ) { if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + owner + STR_ + entry + STR_ + tx + STR_ ) ; tx . on Owner Changed ( entry , owner ) ; return true ; } else if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + tx ) ; } else if ( log . is Debug Enabled ( ) ) log . debug ( STR_ + owner + STR_ + entry + STR_ ) ; } return false ; }
protected void on Exception ( final Exception e ) { LOG . info ( STR_ , e . get Message ( ) ) ; LOG . debug ( STR_ , e ) ; }
@ Override void paint Peer ( final Graphics g ) { if ( ! disposed ) { Dimension size = get Peer Size ( ) ; g . set Color ( get Peer Background ( ) ) ; g . fill Rect ( NUM_ , NUM_ , size . width , size . height ) ; paint Border ( g , border Insets . left , border Insets . top , size . width - ( border Insets . left + border Insets . right ) , size . height - ( border Insets . top + border Insets . bottom ) ) ; Font Metrics fm = g . get Font Metrics ( ) ; Rectangle text Rect , icon Rect , view Rect ; text Rect = new Rectangle ( ) ; view Rect = new Rectangle ( ) ; icon Rect = new Rectangle ( ) ; view Rect . width = size . width - ( content Area Insets . left + content Area Insets . right ) ; view Rect . height = size . height - ( content Area Insets . top + content Area Insets . bottom ) ; view Rect . x = content Area Insets . left ; view Rect . y = content Area Insets . top ; String llabel = ( label != null ) ? label : STR_ ; String text = Swing Utilities . layout Compound Label ( fm , llabel , null , Swing Constants . CENTER , Swing Constants . CENTER , Swing Constants . CENTER , Swing Constants . CENTER , view Rect , icon Rect , text Rect , NUM_ ) ; Font f = get Peer Font ( ) ; g . set Font ( f ) ; if ( pressed && armed ) { paint Button Pressed ( g , target ) ; } paint Text ( g , target , text Rect , text ) ; if ( has Focus ( ) ) { paint Focus ( g , focus Insets . left , focus Insets . top , size . width - ( focus Insets . left + focus Insets . right ) - NUM_ , size . height - ( focus Insets . top + focus Insets . bottom ) - NUM_ ) ; } } flush ( ) ; }
public void insert Update ( Document Event e ) { if ( ! dirty ) { set Dirty ( true ) ; } }
public void fire Setup Game Became Examined ( String game Id ) { Game game = get Game ( game Id ) ; if ( game != null ) { synchronized ( listeners ) { for ( Game Service Listener listener : listeners ) { listener . setup Game Became Examined ( game ) ; } } } }
public void focus Lost ( Focus Event e ) { if ( focus Log . is Loggable ( Platform Logger . Level . FINE ) ) { focus Log . fine ( STR_ , e ) ; } b Has Focus = false ; }
void end ( ) { long time = System . current Time Millis ( ) - start Time ; log ( current Action , STR_ , ( int ) time ) ; if ( test . is Collect ( ) ) { total Time += time ; } }
private void read Object ( Object Input Stream ois ) throws IO Exception , Class Not Found Exception { try { ois . default Read Object ( ) ; init Plot ( ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } }
public static int visit ( int x ) { last Visited = x ; return x ; }
public void on Complete ( final Consumer < On Complete > fn ) { this . for X Of = fn ; if ( done ) { fn . accept ( build On Complete ( ) ) ; } }
public void discharge Item ( Item Stack a Stack ) { increase Stored Energy Units ( GT Mod Handler . discharge Electric Item ( a Stack , ( int ) Math . min ( Integer . MAX VALUE , get EU Capacity ( ) - get Stored EU ( ) ) , ( int ) Math . min ( Integer . MAX VALUE , m Meta Tile Entity . get Input Tier ( ) ) , false , false , false ) , true ) ; }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof Mouse Delegator ) { Debug . message ( STR_ , STR_ ) ; set Mouse Delegator ( ( Mouse Delegator ) some Obj ) ; } }
protected void on Message ( final String message ) { if ( message != null && message . length ( ) > NUM_ ) { post Message Event ( message ) ; } }
void parse ( ) { Byte Buffer bb = byte Buffer ; bb . clear ( ) ; size = bb . get Short ( ) ; if ( size > buffer . length ) { throw new Illegal State Exception ( STR_ + size + STR_ + buffer . length ) ; } bb . limit ( size ) ; type = bb . get ( ) ; from Member Id = bb . get Short ( ) ; term = bb . get Int ( ) ; command Size = NUM_ ; num Commands = NUM_ ; timestamp = NUM_ ; switch ( type ) { case TYPE APPEND ENTRY REQ : prev Rid . set ( bb . get Int ( ) , bb . get Int ( ) ) ; commit Index = bb . get Int ( ) ; entry Term = bb . get Int ( ) ; is Heartbeat = entry Term == NUM_ ; command Size = bb . get Short ( ) ; buffer Offset = bb . position ( ) ; if ( message Tracing ) { if ( is Heartbeat ) { if ( heartbeat Tracing ) { tracing Info = String . format ( STR_ , term , prev Rid . term , prev Rid . index , commit Index ) ; } } else { tracing Info = String . format ( STR_ , term , prev Rid . term , entry Term , prev Rid . index + NUM_ , commit Index , size - overhead [ TYPE APPEND ENTRY REQ ] ) ; } } num Commands = NUM_ ; int s = overhead [ TYPE APPEND ENTRY REQ ] + command Size ; int bo = buffer Offset ; int cs = command Size ; while ( s < size ) { num Commands ++ ; bo += cs ; cs = ( NUM_ & buffer [ bo ] ) << NUM_ | ( NUM_ & buffer [ bo + NUM_ ] ) ; bo += NUM_ ; s += cs + NUM_ ; } break ; case TYPE APPEND ENTRY REP : mn Index = bb . get Int ( ) ; success = bb . get ( ) == NUM_ ; is Heartbeat = bb . get ( ) == NUM_ ; if ( message Tracing && ( heartbeat Tracing || ! is Heartbeat ) ) { tracing Info = String . format ( STR_ , is Heartbeat ? STR_ : STR_ , term , success ? STR_ : STR_ , mn Index , success ? STR_ : STR_ ) ; } break ; case TYPE REQUEST VOTE REQ : is Prevote = bb . get ( ) == NUM_ ; prev Rid . set ( bb . get Int ( ) , bb . get Int ( ) ) ; if ( message Tracing ) { tracing Info = String . format ( STR_ , term , prev Rid . term , prev Rid . index , is Prevote ? STR_ : STR_ ) ; } break ; case TYPE REQUEST VOTE REP : is Prevote = bb . get ( ) == NUM_ ; vote Granted = bb . get ( ) == NUM_ ; if ( message Tracing ) { tracing Info = String . format ( STR_ , term , vote Granted ? STR_ : STR_ , is Prevote ? STR_ : STR_ ) ; } break ; default : throw new Illegal State Exception ( STR_ + type ) ; } }
public void add Bug ( Bug Instance bug ) { Source Line Annotation source = bug . get Primary Source Line Annotation ( ) ; Package Stats stat = get Package Stats ( source . get Package Name ( ) ) ; stat . add Error ( bug ) ; ++ total Errors [ NUM_ ] ; int priority = bug . get Priority ( ) ; if ( priority >= NUM_ ) { ++ total Errors [ Math . min ( priority , total Errors . length - NUM_ ) ] ; } }
private void disable Stage ( J Check Box check , J Label label , J Label time ) { check . set Enabled ( false ) ; label . set Enabled ( false ) ; time . set Enabled ( false ) ; }
public void remove From Upload ( Osm Element element ) { api Storage . remove Element ( element ) ; element . set State ( Osm Element . STATE UNCHANGED ) ; }
public void make Secure ( SSL Server Socket Factory ssl Server Socket Factory ) { this . ssl Server Socket Factory = ssl Server Socket Factory ; }
public Optional Int execute If Absent ( Runnable action ) { if ( ! is Present ( ) ) action . run ( ) ; return this ; }
public void mouse Pressed ( Mouse Event e ) { events . clear ( ) ; if ( map Drag Operation From Modifiers ( e ) != Dn D Constants . ACTION NONE ) { try { motion Threshold = Drag Source . get Drag Threshold ( ) ; } catch ( Exception exc ) { motion Threshold = NUM_ ; } append Event ( e ) ; } }
@ Override public void state Changed ( Change Event e ) { if ( e . get Source ( ) == m Spinner Max Size . get Model ( ) ) { trim ( ) ; validate ( ) ; caret Update ( null ) ; } }
public boolean compute Angle Offset ( ) { if ( m Finished ) { return false ; } long system Clock = Animation Utils . current Animation Time Millis ( ) ; long time Passed = system Clock - m Start Time ; if ( time Passed < m Duration ) { switch ( m Mode ) { case SCROLL MODE : float sc = ( float ) time Passed / m Duration ; m Curr Angle = m Start Angle + Math . round ( m Delta Angle * sc ) ; break ; case FLING MODE : float time Passed Seconds = time Passed / NUM_ ; float distance ; if ( m Velocity < NUM_ ) { distance = m Coeff Velocity * m Velocity * time Passed Seconds - ( m Deceleration * time Passed Seconds * time Passed Seconds / NUM_ ) ; } else { distance = - m Coeff Velocity * m Velocity * time Passed Seconds - ( m Deceleration * time Passed Seconds * time Passed Seconds / NUM_ ) ; } m Curr Angle = m Start Angle - Math . signum ( m Velocity ) * Math . round ( distance ) ; break ; } return true ; } else { m Finished = true ; return false ; } }
public void invalidate Visual State ( ) { arguments . for Each ( null ) ; result . invalidate Visual State ( ) ; }
public void reload ( ) { this . kek = null ; this . mwk = null ; this . mwk Index = null ; }
protected void handle Reorder Change ( Property Change Event evt ) { refresh Children ( ) ; refresh Visuals ( ) ; }
public void add Details Loaded Listener ( @ Not Null Runnable runnable ) { my Loading Finished Listeners . add ( runnable ) ; }
public boolean compute Scroll Offset ( ) { if ( m Finished ) { return false ; } int time Passed = ( int ) ( Animation Utils . current Animation Time Millis ( ) - m Start Time ) ; if ( time Passed < m Duration ) { switch ( m Mode ) { case SCROLL MODE : final float x = m Interpolator . get Interpolation ( time Passed * m Duration Reciprocal ) ; m Curr X = m Start X + Math . round ( x * m Delta X ) ; m Curr Y = m Start Y + Math . round ( x * m Delta Y ) ; break ; case FLING MODE : final float t = ( float ) time Passed / m Duration ; final int index = ( int ) ( NB SAMPLES * t ) ; float distance Coef = NUM_ ; float velocity Coef = NUM_ ; if ( index < NB SAMPLES ) { final float t inf = ( float ) index / NB SAMPLES ; final float t sup = ( float ) ( index + NUM_ ) / NB SAMPLES ; final float d inf = SPLINE POSITION [ index ] ; final float d sup = SPLINE POSITION [ index + NUM_ ] ; velocity Coef = ( d sup - d inf ) / ( t sup - t inf ) ; distance Coef = d inf + ( t - t inf ) * velocity Coef ; } m Curr Velocity = velocity Coef * m Distance / m Duration * NUM_ ; m Curr X = m Start X + Math . round ( distance Coef * ( m Final X - m Start X ) ) ; m Curr X = Math . min ( m Curr X , m Max X ) ; m Curr X = Math . max ( m Curr X , m Min X ) ; m Curr Y = m Start Y + Math . round ( distance Coef * ( m Final Y - m Start Y ) ) ; m Curr Y = Math . min ( m Curr Y , m Max Y ) ; m Curr Y = Math . max ( m Curr Y , m Min Y ) ; if ( m Curr X == m Final X && m Curr Y == m Final Y ) { m Finished = true ; } break ; } } else { m Curr X = m Final X ; m Curr Y = m Final Y ; m Finished = true ; } return true ; }
public void fire Offer Received ( Offer offer ) { offers . add ( offer ) ; synchronized ( listeners ) { for ( Game Service Listener listener : listeners ) { listener . offer Received ( offer ) ; } } }
@ Override @ Ui Thread public void on Detached From Recycler View ( @ Non Null Recycler View recycler View ) { super . on Detached From Recycler View ( recycler View ) ; m Attached Recycler View Pool . remove ( recycler View ) ; }
void on Item Moved ( ) { if ( m Swapped Item != null && m Stop Drag Pos != INVALID DRAG POS ) { if ( m Data Change Listener != null ) { m Data Change Listener . on Item Reorder ( m Swapped Item , m Start Drag Pos , m Stop Drag Pos ) ; } final Adapter Transaction revert Reorder Transaction = new Revert Reorder Transaction < > ( this , m Start Drag Pos , m Stop Drag Pos ) ; m Transactions . offer ( revert Reorder Transaction ) ; m Swapped Item = null ; m Stop Drag Pos = INVALID DRAG POS ; } }
@ Override public void mouse Clicked ( Mouse Event e ) { int col ; boolean popup ; col = m Table Arff . column At Point ( e . get Point ( ) ) ; popup = ( ( e . get Button ( ) == Mouse Event . BUTTON 3 ) && ( e . get Click Count ( ) == NUM_ ) ) || ( ( e . get Button ( ) == Mouse Event . BUTTON 1 ) && ( e . get Click Count ( ) == NUM_ ) && e . is Alt Down ( ) && ! e . is Control Down ( ) && ! e . is Shift Down ( ) ) ; popup = popup && ( get Instances ( ) != null ) ; if ( e . get Source ( ) == m Table Arff . get Table Header ( ) ) { m Current Col = col ; if ( popup ) { e . consume ( ) ; set Menu ( ) ; init Popup Menus ( ) ; m Popup Header . show ( e . get Component ( ) , e . get X ( ) , e . get Y ( ) ) ; } } else if ( e . get Source ( ) == m Table Arff ) { if ( popup ) { e . consume ( ) ; set Menu ( ) ; init Popup Menus ( ) ; m Popup Rows . show ( e . get Component ( ) , e . get X ( ) , e . get Y ( ) ) ; } } if ( ( e . get Button ( ) == Mouse Event . BUTTON 1 ) && ( e . get Click Count ( ) == NUM_ ) && ( ! e . is Alt Down ( ) ) && ( col > - NUM_ ) ) { m Table Arff . set Selected Column ( col ) ; } }
private final void maybe Show Popup ( final Mouse Event e ) { if ( e . is Popup Trigger ( ) ) { show Popup ( e ) ; } }
protected boolean can Handle ( String class Name , String message , @ Nullable Throwable throwable ) { return true ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { init Factory ( ) ; in . default Read Object ( ) ; }
public static void register Baggage Handler ( Baggage Handler handler ) { handlers . add ( handler ) ; }
@ Override public void stop ( Bundle Context context ) throws Exception { if ( null != cmr Repository Manager ) { cmr Repository Manager . cancel All Update Repositories Jobs ( ) ; } Platform . remove Log Listener ( log Listener ) ; log Listener = null ; super . stop ( context ) ; plugin = null ; }
private String replace Inlist ( String str ) { try { Pattern pt = Pattern . compile ( STR_ ) ; Matcher m = pt . matcher ( str ) ; if ( m . find ( ) ) { int start = m . start ( ) ; int idx = str . index Of ( STR_ , start ) ; if ( idx < NUM_ || idx == str . length ( ) - NUM_ ) return str . substring ( NUM_ , start ) + STR_ ; else return str . substring ( NUM_ , start ) + STR_ + str . substring ( idx + NUM_ ) ; } } catch ( Exception ex ) { } return str ; }
final Goro delegate ( ) { return delegate ; }
public Set < Adapter > required Type Adapters ( ) { return Collections . empty Set ( ) ; }
protected void request Update ( boolean force ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , STR_ ) ; } if ( force ) { Screen . reload ( ) ; } else { ui Handler . confirm Reload Page ( ) ; } }
void dispose ( ) { reverse . dispose ( ) ; if ( DO CLEAN DIRTY ) { Arrays . fill ( offset 0 , NUM_ ) ; Arrays . fill ( offset 1 , NUM_ ) ; Arrays . fill ( offset 2 , NUM_ ) ; Arrays . fill ( miter , NUM_ ) ; Arrays . fill ( middle , NUM_ ) ; Arrays . fill ( lp , NUM_ ) ; Arrays . fill ( rp , NUM_ ) ; Arrays . fill ( subdiv Ts , NUM_ ) ; } }
@ Override public void on Message Received ( String from , Bundle data ) { String message = data . get String ( STR_ ) ; Log . d ( TAG , STR_ + from ) ; Log . d ( TAG , STR_ + message ) ; if ( from . starts With ( STR_ ) ) { } else { } send Notification ( message ) ; }
public static Result Set simple Function Table ( Connection conn ) { Simple Result Set result = new Simple Result Set ( ) ; result . add Column ( STR_ , Types . INTEGER , NUM_ , NUM_ ) ; result . add Column ( STR_ , Types . CHAR , NUM_ , NUM_ ) ; result . add Row ( NUM_ , STR_ ) ; return result ; }
public Class plain Class For Name ( String name ) throws Class Not Found Exception { Class c = null ; try { if ( external Class Loader != null ) c = external Class Loader . load Class ( name ) ; else c = Class . for Name ( name ) ; cache Class Info ( name , c ) ; } catch ( No Class Def Found Error e ) { throw no Class Def Found ( name , e ) ; } return c ; }
public void member Joined ( Client Membership Event event ) { Notification notification = new Notification ( JMX Notification Type . CLIENT JOINED , server Source , Sequence Number . next ( ) , System . current Time Millis ( ) , Management Constants . CLIENT JOINED PREFIX + event . get Member Id ( ) ) ; server Level Notif Emitter . send Notification ( notification ) ; member Level Notif Emitter . send Notification ( notification ) ; }
private void write Output Data ( byte [ ] data , int offset , int len ) throws IO Exception { cb Lock . lock ( ) ; try { ios . write ( data , offset , len ) ; } finally { cb Lock . unlock ( ) ; } }
@ Override public List < byte [ ] > read ( long start Offset ) throws IO Exception { List < Carbon Dictionary Column Meta Chunk > carbon Dictionary Column Meta Chunks = read Dictionary Metadata File ( ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = carbon Dictionary Column Meta Chunks . get ( carbon Dictionary Column Meta Chunks . size ( ) - NUM_ ) ; long end Offset = carbon Dictionary Column Meta Chunk . get End offset ( ) ; return read ( carbon Dictionary Column Meta Chunks , start Offset , end Offset ) ; }
protected void on Checking ( ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , messages . checking Resources ( ) ) ; } fire Application Cache Event ( Cache Event . on Checking ) ; }
@ Override public void command ( ) { try { create Schema Watcher ( ) ; update Schema ( null , - NUM_ ) ; } catch ( Exception exc ) { log . error ( STR_ + exc , exc ) ; } }
private void init Select Position ( int position ) { if ( m Select Mode == I Selectable . SELECT MODE SINGLE ) { if ( m Selected Position == I Selectable . INVALID POSITION ) { m Selected Position = position ; } } else if ( m Select Mode == I Selectable . SELECT MODE MULTI ) { if ( ! m Selected Positions . contains ( position ) ) m Selected Positions . add ( position ) ; } else { throw new Runtime Exception ( ) ; } }
public void reset Timer ( int interval ) { timer Delay = interval ; stop Timer ( ) ; timer = new Timer ( ) ; timer . schedule At Fixed Rate ( new Manage Graphics Task ( Simple Animation Layer . this ) , NUM_ , timer Delay ) ; if ( timer Button != null ) { timer Button . set Selected ( true ) ; } }
public synchronized boolean read From File ( Context context ) { try { reading Lock . lock ( ) ; Task Storage new Storage = saving Helper . load ( context , FILENAME , true ) ; if ( new Storage != null ) { Log . d ( DEBUG TAG , STR_ ) ; tasks = new Storage . tasks ; boxes = new Storage . boxes ; dirty = false ; return true ; } else { Log . d ( DEBUG TAG , STR_ ) ; return false ; } } finally { reading Lock . unlock ( ) ; } }
public void done ( ) { for ( Report r : this . reports ) { r . done ( ) ; } }
@ Override protected void execution Started ( ) { m Button Start . set Enabled ( false ) ; m Button Stop . set Enabled ( true ) ; }
public void close ( ) { synchronized ( async Close Executors ) { if ( ! this . closed ) { this . closed = true ; for ( Thread Pool Executor pool : async Close Executors . values ( ) ) { pool . shutdown ( ) ; } async Close Executors . clear ( ) ; } } }
public void on Pull ( float delta Distance ) { final long now = Animation Utils . current Animation Time Millis ( ) ; if ( m State == STATE PULL DECAY && now - m Start Time < m Duration ) { return ; } if ( m State != STATE PULL ) { m Glow Scale Y = PULL GLOW BEGIN ; } m State = STATE PULL ; m Start Time = now ; m Duration = PULL TIME ; m Pull Distance += delta Distance ; float distance = Math . abs ( m Pull Distance ) ; m Edge Alpha = m Edge Alpha Start = Math . max ( PULL EDGE BEGIN , Math . min ( distance , MAX ALPHA ) ) ; m Edge Scale Y = m Edge Scale Y Start = Math . max ( HELD EDGE SCALE Y , Math . min ( distance * PULL DISTANCE EDGE FACTOR , NUM_ ) ) ; m Glow Alpha = m Glow Alpha Start = Math . min ( MAX ALPHA , m Glow Alpha + ( Math . abs ( delta Distance ) * PULL DISTANCE ALPHA GLOW FACTOR ) ) ; float glow Change = Math . abs ( delta Distance ) ; if ( delta Distance > NUM_ && m Pull Distance < NUM_ ) { glow Change = - glow Change ; } if ( m Pull Distance == NUM_ ) { m Glow Scale Y = NUM_ ; } m Glow Scale Y = m Glow Scale Y Start = Math . min ( MAX GLOW HEIGHT , Math . max ( NUM_ , glow Change * PULL DISTANCE GLOW FACTOR ) ) ; m Edge Alpha Finish = m Edge Alpha ; m Edge Scale Y Finish = m Edge Scale Y ; m Glow Alpha Finish = m Glow Alpha ; m Glow Scale Y Finish = m Glow Scale Y ; }
public void mouse Clicked ( Mouse Event ev ) { if ( ! try Popup ( ev ) && Swing Utilities . is Left Mouse Button ( ev ) ) { if ( ! is Resizing ) hmo . handle Header Column Left Click ( ev . get Point ( ) ) ; else is Resizing = false ; } }
public void hide Player Info ( ) { if ( player Card Tooltip == null ) { return ; } player Card Tooltip . hide ( ) ; player Card Tooltip = null ; }
public static boolean check Image Index ( ) { if ( index Changed ) { int result = J Option Pane . show Confirm Dialog ( null , Bundle . get Message ( STR_ ) , Bundle . get Message ( STR_ ) , J Option Pane . YES NO CANCEL OPTION , J Option Pane . QUESTION MESSAGE ) ; if ( result == J Option Pane . YES OPTION ) { store Image Index ( ) ; return true ; } else if ( result == J Option Pane . NO OPTION ) { index Changed ( false ) ; } } return false ; }
public void client Left Game ( ) { if ( ! Swing Utilities . is Event Dispatch Thread ( ) ) { Swing Action . invoke And Wait ( null ) ; return ; } Thread Util . sleep ( NUM_ ) ; m game Selector Model . load Default Game ( this ) ; m setup Panel Model . show Select Type ( ) ; set Visible ( true ) ; }
private void apply To ( Class Visitor v , Enum < ? > e ) { if ( Log . is Logging On ( ) ) { Log . log Line ( String . format ( STR_ , e ) ) ; } v . visit ( e ) ; }
private void rehash ( ) { int size = symbols . length ; int new Size = size + size ; if ( new Size > MAX TABLE SIZE ) { size = NUM_ ; Arrays . fill ( symbols , null ) ; Arrays . fill ( buckets , null ) ; dirty = true ; return ; } String [ ] old Syms = symbols ; Bucket [ ] old Buckets = buckets ; symbols = new String [ new Size ] ; buckets = new Bucket [ new Size > > NUM_ ] ; index Mask = new Size - NUM_ ; size Threshold += size Threshold ; int count = NUM_ ; for ( int i = NUM_ ; i < size ; ++ i ) { String symbol = old Syms [ i ] ; if ( symbol != null ) { ++ count ; int index = calc Hash ( symbol ) & index Mask ; if ( symbols [ index ] == null ) { symbols [ index ] = symbol ; } else { int bix = index > > NUM_ ; buckets [ bix ] = new Bucket ( symbol , buckets [ bix ] ) ; } } } size >>= NUM_ ; for ( int i = NUM_ ; i < size ; ++ i ) { Bucket b = old Buckets [ i ] ; while ( b != null ) { ++ count ; String symbol = b . get Symbol ( ) ; int index = calc Hash ( symbol ) & index Mask ; if ( symbols [ index ] == null ) { symbols [ index ] = symbol ; } else { int bix = index > > NUM_ ; buckets [ bix ] = new Bucket ( symbol , buckets [ bix ] ) ; } b = b . get Next ( ) ; } } if ( count != size ) { throw new Error ( STR_ + size + STR_ + count + STR_ ) ; } }
private void append Type Parameters ( final List < String > types ) { boolean first = true ; for ( final String type Value : types ) { if ( V Card Config . is Version 30 ( m V Card Type ) || V Card Config . is Version 40 ( m V Card Type ) ) { final String encoded = ( V Card Config . is Version 40 ( m V Card Type ) ? V Card Utils . to String As V 40 Param Value ( type Value ) : V Card Utils . to String As V 30 Param Value ( type Value ) ) ; if ( Text Utils . is Empty ( encoded ) ) { continue ; } if ( first ) { first = false ; } else { m Builder . append ( VCARD PARAM SEPARATOR ) ; } append Type Parameter ( encoded ) ; } else { if ( ! V Card Utils . is V 21 Word ( type Value ) ) { continue ; } if ( first ) { first = false ; } else { m Builder . append ( VCARD PARAM SEPARATOR ) ; } append Type Parameter ( type Value ) ; } } }
private final void write String Segments ( String text ) throws IO Exception , Json Generation Exception { int left = text . length ( ) ; int offset = NUM_ ; final char [ ] cbuf = char Buffer ; while ( left > NUM_ ) { int len = Math . min ( output Max Contiguous , left ) ; text . get Chars ( offset , offset + len , cbuf , NUM_ ) ; if ( ( output Tail + len ) > output End ) { flush Buffer ( ) ; } write String Segment ( cbuf , NUM_ , len ) ; offset += len ; left -= len ; } }
Parse Result ( Throwable throwable ) { this ( Optional . empty ( ) , singleton List ( new Problem ( throwable . get Message ( ) , Optional . empty ( ) , Optional . of ( throwable ) ) ) , Optional . empty ( ) , Optional . empty ( ) ) ; }
public void process Config Messages ( ) { List < String > keys To Process = new Linked List < > ( ) ; keys To Process . add ( YARN CONTAINER COUNT OPT ) ; keys To Process . add ( SERVER URL OPT ) ; process Config Messages ( keys To Process ) ; }
void free Ref Count Info ( Long address ) { if ( ! track Reference Counts ( ) ) return ; List < Ref Count Change Info > freed Info = stacktraces . remove ( address ) ; if ( freed Info == LOCKED ) { Memory Allocator Impl . debug Log ( STR_ + Long . to Hex String ( address ) , true ) ; } else if ( track Freed Reference Counts ( ) ) { if ( freed Info != null ) { freed Stacktraces . put ( address , freed Info ) ; } else { freed Stacktraces . remove ( address ) ; } } }
public void on Progress ( int bytes Written , int total Size ) { Log . v ( LOG TAG , String . format ( STR_ , bytes Written , total Size , ( total Size > NUM_ ) ? ( bytes Written * NUM_ / total Size ) * NUM_ : - NUM_ ) ) ; }
@ Override public void on Failure ( Throwable cause ) { LOG . error ( STR_ , new Object [ ] { current Log Segment Seq No , current Entry Id , cause } ) ; errors Found . set ( true ) ; sync Latch . count Down ( ) ; }
private void on Cache Data Changed ( ) { if ( m Cache Data List . size ( ) >= NUM_ ) { m Icon Status = ICON SHOW DROP DOWN ; } else { m Icon Status = ICON ABSENT ; } }
protected boolean should Be Closed When No Experiments ( ) { return true ; }
public void member Crashed ( Client Membership Event event ) { Notification notification = new Notification ( JMX Notification Type . CLIENT CRASHED , server Source , Sequence Number . next ( ) , System . current Time Millis ( ) , Management Constants . CLIENT CRASHED PREFIX + event . get Member Id ( ) ) ; server Level Notif Emitter . send Notification ( notification ) ; member Level Notif Emitter . send Notification ( notification ) ; }
protected void on Activities Destroyed ( ) { Application Status . unregister Application State Listener ( m Application State Listener ) ; disconnect ( false ) ; }
public void caret Update ( Caret Event e ) { timer . restart ( ) ; }
public void on Success ( ) { if ( first Success Time <= NUM_ ) { first Success Time = Current Time . current Time ( ) ; } dynamic Recover Timeout . set ( NUM_ ) ; first Fail Time = NUM_ ; }
@ edu . umd . cs . findbugs . annotations . Suppress FB Warnings ( value = STR_ , justification = STR_ ) @ Override public void recover ( ) { if ( ! allow Connection Recovery ) { return ; } opened = false ; try { socket Conn . close ( ) ; } catch ( IO Exception e ) { } reconnect ( ) ; }
public void on Navigate Up ( ) { File parent Dir = null ; if ( m Directory != null ) { parent Dir = m Directory . get Parent File ( ) ; } list Directory ( parent Dir ) ; restore Index And Top Position ( ) ; }
protected void add Supported Service ( UUID a Supported Service ) { m Supported Services . add ( a Supported Service ) ; }
void dispose ( ) { if ( DO CLEAN DIRTY ) { Arrays . fill ( cur Curvepts , NUM_ ) ; Arrays . fill ( first Segments Buffer , NUM_ ) ; } if ( recycle Dashes && dash != dashes initial ) { rdr Ctx . put Dirty Float Array ( dash ) ; dash = null ; } if ( first Segments Buffer != first Segments Buffer initial ) { rdr Ctx . put Dirty Float Array ( first Segments Buffer ) ; first Segments Buffer = first Segments Buffer initial ; } }
protected static void override Template Parameters ( Template template , Maven Project project , Logger log ) { List < io . fabric 8 . openshift . api . model . Parameter > parameters = template . get Parameters ( ) ; if ( parameters != null && project != null ) { Properties properties = get Project And Fabric 8 Properties ( project ) ; boolean missing Property = false ; for ( io . fabric 8 . openshift . api . model . Parameter parameter : parameters ) { String parameter Name = parameter . get Name ( ) ; String name = STR_ + parameter Name ; String property Value = properties . get Property ( name ) ; if ( property Value != null ) { log . info ( STR_ + name + STR_ + property Value ) ; parameter . set Value ( property Value ) ; } else { missing Property = true ; log . info ( STR_ + name ) ; } } if ( missing Property ) { log . debug ( STR_ + new Tree Set < > ( properties . key Set ( ) ) ) ; } } }
protected double apply Operator ( double first , double second ) { switch ( m operator ) { case STR_ : return ( first + second ) ; case STR_ : return ( first - second ) ; case STR_ : return ( first * second ) ; case STR_ : return ( first / second ) ; case STR_ : return Math . pow ( first , second ) ; } return Double . Na N ; }
void post Init ( X Create Window Params params ) { if ( log . is Loggable ( Platform Logger . Level . FINE ) ) { log . fine ( STR_ + get WM Name ( ) ) ; } update WM Name ( ) ; init Client Leader ( ) ; }
public void component Shown ( final Component Event e ) { final Object source = e . get Source ( ) ; if ( ! ( source instanceof J Menu Item ) ) return ; set Child Visible ( ( J Menu Item ) source , true ) ; }
@ Override public void after Properties Set ( ) throws Exception { registered Process . add ( this ) ; }
public void property Change ( Property Change Event e ) { if ( e . get Source ( ) == note Label && e . get Property Name ( ) == STR_ ) { fire Property Change ( ACCESSIBLE TEXT PROPERTY , null , NUM_ ) ; } }
@ Before Class public static void load Properties ( ) throws Exception { URL url = Class Loader . get System Resource ( PROP FILE NAME ) ; s logsvc Props . load ( url . open Stream ( ) ) ; }
public void drop Action Changed ( Drop Target Drag Event dtde ) { Debug . message ( STR_ , STR_ ) ; int action = dtde . get Drop Action ( ) ; Debug . message ( STR_ , STR_ + action ) ; dtde . accept Drag ( action ) ; }
private static final void cleanup Single Namespace Node ( Zoo Keeper zkc , String path , String self Broker Url ) throws Exception { String broker Url = null ; try { byte [ ] data = zkc . get Data ( path , false , null ) ; if ( data . length == NUM_ ) { return ; } Namespace Ephemeral Data zdata = json Mapper . read Value ( data , Namespace Ephemeral Data . class ) ; broker Url = zdata . get Native Url ( ) ; if ( self Broker Url . equals ( broker Url ) ) { zkc . delete ( path , - NUM_ ) ; } } catch ( No Node Exception nne ) { } }
private void on Show Pop Up ( View anchor , I Directory selection ) { Popup Menu popup = new Popup Menu ( get Activity ( ) , anchor ) ; popup . set On Menu Item Click Listener ( pop Up Listener ) ; Menu Inflater inflater = popup . get Menu Inflater ( ) ; inflater . inflate ( this . m Context Menue , popup . get Menu ( ) ) ; m Pop Up Selection = selection ; popup . show ( ) ; }
public Held Locks Token refresh ( long expiration Date Ms ) { return new Held Locks Token ( token Id , client , creation Date Ms , expiration Date Ms , lock Map , lock Timeout , version Id ) ; }
protected void layout Panel ( Map Bean map ) { Dimension minimum Size = new Dimension ( Map Bean . DEFAULT WIDTH , Map Bean . DEFAULT HEIGHT ) ; J Panel hack Panel = new J Panel ( ) ; hack Panel . set Layout ( new Border Layout ( ) ) ; hack Panel . set Opaque ( false ) ; hack Panel . add ( map , Border Layout . CENTER ) ; center Container = new J Panel ( ) ; center Container . set Layout ( new Overlay Layout ( center Container ) ) ; Drawing Attributes active Widget Colors = get Active Widget Colors ( ) ; Drawing Attributes inactive Widget Colors = get Inactive Widget Colors ( ) ; int widget Button Size = get Widget Button Size ( ) ; Embedded Nav Panel nav Panel = new Embedded Nav Panel ( active Widget Colors , inactive Widget Colors , widget Button Size ) ; nav Panel . set Bounds ( NUM_ , NUM_ , nav Panel . get Minimum Size ( ) . width , nav Panel . get Minimum Size ( ) . height ) ; add Map Component ( nav Panel ) ; add Map Component ( new Projection Stack ( ) ) ; Embedded Scale Display Panel scale Display = new Embedded Scale Display Panel ( ) ; add Map Component ( scale Display ) ; widgets = new J Panel ( ) ; widgets . set Layout ( new Border Layout ( ) ) ; widgets . set Background ( OM Graphic Constants . clear ) ; widgets . set Opaque ( false ) ; widgets . set Bounds ( NUM_ , NUM_ , map . get Width ( ) , map . get Height ( ) ) ; widgets . set Minimum Size ( minimum Size ) ; widgets . add ( nav Panel , Border Layout . WEST ) ; widgets . add ( scale Display , Border Layout . EAST ) ; set Borders ( map , widgets ) ; center Container . add ( widgets ) ; center Container . add ( hack Panel ) ; add ( center Container , Border Layout . CENTER ) ; }
protected void fire Structure Changed ( ) { fire Tree Structure Changed ( new Tree Path ( get Root ( ) ) ) ; }
public void invoke Hook Prepare ( ) { for ( I Task Hook task Hook : task Hooks ) { task Hook . prepare ( get Topology Config ( ) , this ) ; } }
public void action Performed ( Action Event e ) { File next Page = null ; for ( Iterator iter = test Files . iterator ( ) ; iter . has Next ( ) ; ) { File f = ( File ) iter . next ( ) ; if ( f . equals ( current Displayed ) ) { if ( iter . has Next ( ) ) { next Page = ( File ) iter . next ( ) ; break ; } } } if ( next Page == null ) { Iterator iter = test Files . iterator ( ) ; next Page = ( File ) iter . next ( ) ; } try { switch Page ( next Page , false ) ; } catch ( Exception ex ) { ex . print Stack Trace ( ) ; } }
public final Dava Flow Set process Single Sub Body Node ( AST Node node , Dava Flow Set input ) { List < Object > sub Bodies = node . get Sub Bodies ( ) ; if ( sub Bodies . size ( ) != NUM_ ) { throw new Runtime Exception ( STR_ ) ; } List sub Body = ( List ) sub Bodies . get ( NUM_ ) ; return process ( sub Body , input ) ; }
public int print ( Graphics g , Page Format page Format , int page Index ) { return R Print Utilities . print Document Word Wrap ( g , this , get Font ( ) , page Index , page Format , get Tab Size ( ) ) ; }
@ Override protected void on Completed ( Async Event Args e ) { super . on Completed ( e ) ; if ( e . get Bytes Transferred ( ) > NUM_ ) { if ( e . get Bytes Transferred ( ) < e . get Count ( ) ) send Async ( e . get Offset ( ) + e . get Bytes Transferred ( ) , e . get Count ( ) - e . get Bytes Transferred ( ) ) ; else if ( m Cursor != m Total ) send Entity ( ) ; else send Next ( ) ; } else { dispose ( ) ; } }
public void verify Counts And Clear ( int expected Registrations , int expected Unregistrations ) { assert Equals ( expected Registrations , registration Count ) ; assert Equals ( expected Unregistrations , unregistration Count ) ; registration Count = NUM_ ; unregistration Count = NUM_ ; }
private Single Byte Charset Converter ( String encoding Name ) throws Unsupported Encoding Exception { String all Bytes String = new String ( all Bytes , NUM_ , BYTE RANGE , encoding Name ) ; int all Bytes Len = all Bytes String . length ( ) ; System . arraycopy ( unknown Chars Map , NUM_ , this . char To Byte Map , NUM_ , this . char To Byte Map . length ) ; for ( int i = NUM_ ; i < BYTE RANGE && i < all Bytes Len ; i ++ ) { char c = all Bytes String . char At ( i ) ; this . byte To Chars [ i ] = c ; this . char To Byte Map [ c ] = all Bytes [ i ] ; } }
protected void configure Reader ( XML Reader reader , Default Handler handler ) throws Document Exception { SAX Helper . set Parser Property ( reader , SAX LEXICALHANDLER , handler ) ; SAX Helper . set Parser Property ( reader , SAX LEXICAL HANDLER , handler ) ; if ( include Internal DTD Declarations || include External DTD Declarations ) { SAX Helper . set Parser Property ( reader , SAX DECL HANDLER , handler ) ; } SAX Helper . set Parser Feature ( reader , SAX NAMESPACES , true ) ; SAX Helper . set Parser Feature ( reader , SAX NAMESPACE PREFIXES , false ) ; SAX Helper . set Parser Feature ( reader , SAX STRING INTERNING , is String Intern Enabled ( ) ) ; SAX Helper . set Parser Feature ( reader , STR_ , true ) ; try { reader . set Feature ( STR_ , is Validating ( ) ) ; if ( error Handler != null ) { reader . set Error Handler ( error Handler ) ; } else { reader . set Error Handler ( handler ) ; } } catch ( Exception e ) { if ( is Validating ( ) ) { throw new Document Exception ( STR_ + STR_ + reader , e ) ; } } }
protected Document read Pre Process ( Document document ) throws Exception { return document ; }
public void remove Notify ( ) { super . remove Notify ( ) ; if ( text Area != null ) { l . uninstall ( text Area ) ; } }
public final void on Dead ( final Killer killer ) { on Dead ( killer , true ) ; }
private void done ( Submit Info info ) { info . done ( ) ; if ( io Space != null ) { io Space . release ( ) ; } }
public Per Directory Suite ( Class < ? > klass ) throws Throwable { super ( klass , Collections . < Runner > empty List ( ) ) ; final Test Class test Class = get Test Class ( ) ; final Class < ? > java Test Class = test Class . get Java Class ( ) ; final List < List < File > > parameters List = get Parameters List ( test Class ) ; for ( List < File > parameters : parameters List ) { runners . add ( new Per Parameter Set Test Runner ( java Test Class , parameters ) ) ; } }
private synchronized void delete Comment Internal ( final Commenting Strategy strategy , final I Comment comment ) { Preconditions . check Not Null ( comment , STR_ ) ; final List < I Comment > current Comments = strategy . get Comments ( ) ; if ( ! current Comments . remove ( comment ) ) { return ; } strategy . save Comments ( current Comments ) ; comment Id To Comment . remove ( comment . get Id ( ) ) ; for ( final Comment Listener listener : listeners ) { try { strategy . send Deleted Comment Notification ( listener , comment ) ; } catch ( final Exception exception ) { C Utility Functions . log Exception ( exception ) ; } } }
void on Start Tracking Touch ( ) { m Is Dragging = true ; }
public void on Show Notification ( Notification View view , View content View , Notification Entry entry , int layout Id ) { if ( DBG ) Log . v ( TAG , STR_ + entry . ID ) ; final Drawable icon = entry . icon Drawable ; final Char Sequence title = entry . title ; final Char Sequence text = entry . text ; final Char Sequence when = entry . show When ? entry . when Formatted : null ; Child View Manager mgr = view . get Child View Manager ( ) ; if ( layout Id == R . layout . notification simple || layout Id == R . layout . notification large icon || layout Id == R . layout . notification full ) { boolean title Changed = true ; boolean content Changed = view . is Content Layout Changed ( ) ; Notification Entry last Entry = view . get Last Notification ( ) ; if ( ! content Changed && title != null && last Entry != null && title . equals ( last Entry . title ) ) { title Changed = false ; } mgr . set Image Drawable ( ICON , icon , title Changed ) ; mgr . set Text ( TITLE , title , title Changed ) ; mgr . set Text ( TEXT , text ) ; mgr . set Text ( WHEN , when ) ; } else if ( layout Id == R . layout . notification simple 2 ) { mgr . set Image Drawable ( ICON , icon ) ; mgr . set Text ( TITLE , title ) ; mgr . set Text ( TEXT , text ) ; mgr . set Text ( WHEN , when ) ; } }
private void update Slider State ( int touch X , int touch Y ) { int distance X = touch X - m Circle Center X ; int distance Y = m Circle Center Y - touch Y ; double c = Math . sqrt ( Math . pow ( distance X , NUM_ ) + Math . pow ( distance Y , NUM_ ) ) ; m Angle = Math . acos ( distance X / c ) ; if ( distance Y < NUM_ ) { m Angle = - m Angle ; } if ( m Listener != null ) { m Listener . on Slider Moved ( ( m Angle - m Start Angle ) / ( NUM_ * Math . PI ) ) ; } }
@ Override public void deliver Result ( List < Application Item > data ) { if ( is Reset ( ) ) { if ( data != null ) { on Release Resources ( data ) ; } } List < Application Item > olddata = m Data ; m Data = data ; if ( is Started ( ) ) { super . deliver Result ( data ) ; } if ( olddata != null ) { on Release Resources ( olddata ) ; } }
public Plugin Printer ( Component applet , Print Stream stream , int x , int y , int w , int h ) { this . applet = applet ; this . eps Title = STR_ ; this . stream = stream ; bx = x ; by = y ; bw = w ; bh = h ; width = applet . size ( ) . width ; height = applet . size ( ) . height ; eps Printer = new EPS Printer ( this , eps Title , stream , NUM_ , NUM_ , width , height ) ; }
@ Override public int hash Code ( ) { return ( summary Label . hash Code ( ) + units . hash Code ( ) ) ; }
@ Override public void on Detach ( ) { synchronized ( m Thread ) { m Progress Bar = null ; m Ready = false ; m Thread . notify ( ) ; } super . on Detach ( ) ; }
public static List < Select Arg > make Select Args From List ( Collection < ? extends Object > items ) { List < Select Arg > args = new Array List < Select Arg > ( items . size ( ) ) ; for ( Object item : items ) { args . add ( new Select Arg ( item ) ) ; } return args ; }
public void mouse Wheel Moved ( Mouse Wheel Event e ) { int rot = e . get Wheel Rotation ( ) ; timeline Layer . adjust Zoom From Mouse Wheel ( rot ) ; }
@ Override public void tree Selection ( Tree Selection Event e ) { if ( ! tree . is Dragging ( ) ) { if ( parent Obj != null ) { parent Obj . pre Load ( ) ; } List < SLD Data Interface > sld Data List = new Array List < SLD Data Interface > ( ) ; List < Node Interface > node List = new Array List < Node Interface > ( ) ; boolean is Data Source = false ; boolean is Folder = false ; Tree Path [ ] selected Paths = tree . get Selection Paths ( ) ; if ( selected Paths != null ) { for ( Tree Path selected Path : selected Paths ) { Object o = selected Path . get Last Path Component ( ) ; if ( o instanceof Node Interface ) { Node Interface handler = ( Node Interface ) o ; File System Interface input = handler . get Handler ( ) ; Selected Files selected Files = input . get SLD Contents ( handler ) ; if ( selected Files != null ) { is Data Source = selected Files . is Data Source ( ) ; is Folder |= selected Files . is Folder ( ) ; List < SLD Data Interface > handler Data List = selected Files . get Sld Data ( ) ; if ( handler Data List != null ) { sld Data List . add All ( handler Data List ) ; } } node List . add ( handler ) ; } } tool Mgr . set Selected Items ( node List , sld Data List ) ; if ( ! parent Obj . load SLD String ( is Folder , is Data Source , sld Data List ) ) { tree . revert Selection ( e . get Old Lead Selection Path ( ) ) ; } } else { tool Mgr . set Selected Items ( node List , sld Data List ) ; } } }
@ On Web Socket Connect public void on Connect ( Session session ) { this . websocket Session = session ; send Update ( this . websocket Session , this . o Auth Token , this . stream Type , this . stream Query , this . stream Version , this . schema Version ) ; }
public synchronized void on Space Connect ( Space Connection Event event ) { try { active Spaces . add ( event . get Id ( ) ) ; if ( current Space State == Startup State . WAITING ) { notify ( ) ; } else { change State ( Startup State . NOT LAST ) ; } } catch ( Exception e ) { if ( logger . is Loggable ( Level . WARNING ) ) { logger . log ( Level . WARNING , STR_ + space Name + STR_ , e ) ; } } }
public static void take Snapshot ( ) { m Snapshot Surface . set Z Order On Top ( true ) ; m Snapshot Layout . add View ( m Snapshot Surface ) ; }
protected void draw Image ( Graphics g , Object native Graphics , int x , int y ) { g . draw Image ( image , x , y , transform ) ; }
public void add Card To Table ( My Card c ) { Game Table Views . add Card ( c . id , c ) ; if ( c . pile == My Card . MONEYPILE ) money Pile . add Card ( c ) ; else if ( c . pile == My Card . VPPILE ) vp Pile . add Card ( c ) ; else if ( c . pile == My Card . SUPPLYPILE ) supply Pile . add Card ( c ) ; else if ( c . pile == My Card . PRIZEPILE ) prize Pile . add Card ( c ) ; else if ( c . pile == My Card . NON SUPPLY PILE ) non Supply Pile . add Card ( c ) ; }
public void pop ( ) { state = ( Graphics State ) stack . pop ( ) ; set Transform ( state . xform ) ; set Clip ( state . cliprgn ) ; }
public void namespace After Start Element ( String prefix , String uri ) throws SAX Exception { if ( m first Tag Not Emitted && m first Element URI == null && m first Element Name != null ) { String prefix 1 = get Prefix Part ( m first Element Name ) ; if ( prefix 1 == null && EMPTYSTRING . equals ( prefix ) ) { m first Element URI = uri ; } } start Prefix Mapping ( prefix , uri , false ) ; }
@ Override public void z Event Custom Popup Was Closed ( Custom Popup popup ) { popup = null ; if ( time Menu Panel != null ) { time Menu Panel . clear Parent ( ) ; } time Menu Panel = null ; last Popup Close Time = Instant . now ( ) ; }
public void stop Timer ( ) { if ( timer != null ) { timer . cancel ( ) ; timer . purge ( ) ; timer = null ; } if ( timer Button != null ) { timer Button . set Selected ( false ) ; } }
@ Advice . On Method Enter public static long enter ( ) { final long start Time = System . current Time Millis ( ) ; return start Time ; }
static public String [ ] get Att Names ( ) { return dc Valid Attribute Names ; }
public boolean is Enabled For Context ( int context Id ) { return true ; }
synchronized void changed ( ) { change Count . increment And Get ( ) ; segment Infos . changed ( ) ; }
public void destroy ( ) { global On Error Callbacks . clear ( ) ; }
public void action Performed ( Action Event e ) { boolean ok ; int ret Val ; if ( m Show Dialog || ( m Script . get Filename ( ) == null ) ) { ret Val = m File Chooser . show Save Dialog ( File Scripting Panel . this ) ; if ( ret Val != J File Chooser . APPROVE OPTION ) return ; ok = m Script . save As ( m File Chooser . get Selected File ( ) ) ; } else { ok = m Script . save ( ) ; } if ( ! ok ) { if ( m Script . get Filename ( ) != null ) J Option Pane . show Message Dialog ( File Scripting Panel . this , STR_ + m File Chooser . get Selected File ( ) + STR_ ) ; else J Option Pane . show Message Dialog ( File Scripting Panel . this , STR_ ) ; } else { m Save Action . set Enabled ( false ) ; } notify Title Updated Listeners ( new Title Updated Event ( File Scripting Panel . this ) ) ; }
protected void on File Processed ( File file ) { if ( importer Config . is Rename Files After Processing ( ) ) { current File . rename To ( new File ( current File . get Absolute File ( ) + STR_ ) ) ; } }
public void run ( ) { Buffered Reader tdin = null ; Print Writer tdout = null ; if ( view Name == null ) { Debug . error ( STR_ ) ; return ; } while ( ! this . shutdown ) { if ( DEBUG ) Debug . output ( STR_ ) ; try { tdin = new Buffered Reader ( new Input Stream Reader ( s . get Input Stream ( ) ) ) ; tdout = new Print Writer ( s . get Output Stream ( ) , true ) ; if ( DEBUG ) Debug . output ( STR_ + view Name ) ; tdout . println ( STR_ + view Name + STR_ ) ; s . set So Timeout ( NUM_ ) ; } catch ( Interrupted IO Exception e Connect Interrupted ) { continue ; } catch ( IO Exception e Connect ) { Debug . error ( STR_ + e Connect . get Message ( ) + STR_ ) ; try { Thread . sleep ( NUM_ ) ; } catch ( Exception e Sleep ) { } continue ; } if ( netmap Conn == null ) { continue ; } netmap Conn . connection Up ( ) ; while ( ! this . shutdown ) { try { String line = null ; if ( ( line = tdin . read Line ( ) ) == null ) break ; if ( DEBUG VERBOSE ) Debug . output ( STR_ + line ) ; Properties event Props = procline ( line ) ; if ( DEBUG VERBOSE ) Debug . output ( STR_ ) ; if ( ! event Props . is Empty ( ) ) { netmap Conn . distribute Event ( event Props ) ; if ( DEBUG VERBOSE ) Debug . output ( STR_ ) ; } else { if ( DEBUG VERBOSE ) Debug . output ( STR_ ) ; } } catch ( Interrupted IO Exception e Read Interrupted ) { continue ; } catch ( Exception e ) { Debug . error ( STR_ + e . get Message ( ) + STR_ ) ; continue ; } } try { s . close ( ) ; netmap Conn . connection Down ( ) ; } catch ( Exception e Shutdown ) { } } }
public int reduce Mp ( int value ) { mp Lock . lock ( ) ; try { int new Mp = this . current Mp - value ; if ( new Mp < NUM_ ) { new Mp = NUM_ ; } this . current Mp = new Mp ; } finally { mp Lock . unlock ( ) ; } if ( value != NUM_ ) { on Reduce Mp ( ) ; } return current Mp ; }
public static void before Call ( URL url , Request request ) { String uri = url . get Uri ( ) ; on Before Call ( get Service Stat ( uri ) ) ; on Before Call ( get Method Stat ( uri , request . get Method Name ( ) , request . get Paramters Desc ( ) ) ) ; }
public void on Cache Start ( Grid Cache Context ctx ) throws Ignite Checked Exception { for ( Map . Entry < UUID , Remote Routine Info > entry : rmt Infos . entry Set ( ) ) { UUID routine Id = entry . get Key ( ) ; Remote Routine Info rmt Info = entry . get Value ( ) ; Grid Continuous Handler hnd = rmt Info . hnd ; if ( hnd . is Query ( ) && F . eq ( ctx . name ( ) , hnd . cache Name ( ) ) && rmt Info . clear Delayed Register ( ) ) { Grid Continuous Handler . Register Status status = hnd . register ( rmt Info . node Id , routine Id , this . ctx ) ; assert status != Grid Continuous Handler . Register Status . DELAYED ; } } }
public void return Tag ( byte [ ] data ) { if ( tag Pool != null && tag Pool . size ( ) < max Pool Size ) { tag Pool . add ( data ) ; } }
private void register Projects ( ) throws Exit Code Exception , N 4 JS Compile Exception { if ( project Locations == null ) { throw new Exit Code Exception ( EXITCODE WRONG CMDLINE OPTIONS , STR_ ) ; } else { Headless Helper . register Projects ( convert To Files Add Target Platform And Check Writable Dir ( project Locations ) , fb Workspace ) ; } }
public void nodes Were Inserted ( Tree Node node , int [ ] child Indices ) { if ( listener List != null && node != null && child Indices != null && child Indices . length > NUM_ ) { int c Count = child Indices . length ; Object [ ] new Children = new Object [ c Count ] ; for ( int counter = NUM_ ; counter < c Count ; counter ++ ) new Children [ counter ] = node . get Child At ( child Indices [ counter ] ) ; fire Tree Nodes Inserted ( this , get Path To Root ( node ) , child Indices , new Children ) ; } }
public void key Pressed ( Key Event e ) { if ( is Navigation Key ( e ) ) { prefix = STR_ ; typed String = STR_ ; last Time = NUM_ ; } }
public void init ( ) { Named Icon icon = ( Named Icon ) get Icon ( ) ; String name = icon . get URL ( ) ; if ( name . ends With ( STR_ ) ) { loco Color = Color . WHITE ; } else if ( name . ends With ( STR_ ) ) { loco Color = Color . GREEN ; } else if ( name . ends With ( STR_ ) ) { loco Color = Color . GRAY ; } else if ( name . ends With ( STR_ ) ) { loco Color = Color . RED ; } else if ( name . ends With ( STR_ ) ) { loco Color = COLOR BLUE ; } else if ( name . ends With ( STR_ ) ) { loco Color = Color . YELLOW ; } }
@ Override protected void execution Started ( ) { m Button Apply Filter . set Enabled ( false ) ; m Button Remove Attributes . set Enabled ( false ) ; m Panel Data Summary . set Enabled ( false ) ; m Panel Attributes . set Enabled ( false ) ; }
public void add Job ( Runnable job ) { m Jobs . add ( job ) ; }
private final void write String ( char [ ] text , int offset , int len ) throws IO Exception , Json Generation Exception { if ( character Escapes != null ) { write String Custom ( text , offset , len ) ; return ; } if ( maximum Non Escaped Char != NUM_ ) { write String ASCII ( text , offset , len , maximum Non Escaped Char ) ; return ; } len += offset ; final int [ ] esc Codes = output Escapes ; final int esc Len = esc Codes . length ; while ( offset < len ) { int start = offset ; while ( true ) { char c = text [ offset ] ; if ( c < esc Len && esc Codes [ c ] != NUM_ ) { break ; } if ( ++ offset >= len ) { break ; } } int new Amount = offset - start ; if ( new Amount < SHORT WRITE ) { if ( ( output Tail + new Amount ) > output End ) { flush Buffer ( ) ; } if ( new Amount > NUM_ ) { System . arraycopy ( text , start , output Buffer , output Tail , new Amount ) ; output Tail += new Amount ; } } else { flush Buffer ( ) ; writer . write ( text , start , new Amount ) ; } if ( offset >= len ) { break ; } char c = text [ offset ++ ] ; append Character Escape ( c , esc Codes [ c ] ) ; } }
@ Override protected void on Activity Result ( int request Code , int result Code , Intent data ) { super . on Activity Result ( request Code , result Code , data ) ; if ( request Code == REQUEST CODE AUTOCOMPLETE ) { if ( result Code == RESULT OK ) { Place place = Place Autocomplete . get Place ( this , data ) ; Log . i ( TAG , STR_ + place . get Name ( ) ) ; m Place Details Text . set Text ( format Place Details ( get Resources ( ) , place . get Name ( ) , place . get Id ( ) , place . get Address ( ) , place . get Phone Number ( ) , place . get Website Uri ( ) ) ) ; Char Sequence attributions = place . get Attributions ( ) ; if ( ! Text Utils . is Empty ( attributions ) ) { m Place Attribution . set Text ( Html . from Html ( attributions . to String ( ) ) ) ; } else { m Place Attribution . set Text ( STR_ ) ; } } else if ( result Code == Place Autocomplete . RESULT ERROR ) { Status status = Place Autocomplete . get Status ( this , data ) ; Log . e ( TAG , STR_ + status . to String ( ) ) ; } else if ( result Code == RESULT CANCELED ) { } } }
@ Override public void state Changed ( Change Event e ) { update Frame Title ( ) ; update Menu ( ) ; if ( e . get Source ( ) instanceof J Component ) { set Tab Title ( ( J Component ) e . get Source ( ) ) ; } }
public void log Error ( final Level level , final String message , final Error e ) { try { Logger errors = Logging Factory . get Logger ( Logging Factory . NAME ERROR LOGGER ) ; errors . log Throwable ( level , message , e ) ; } catch ( Logging Exception ex ) { ex . print Stack Trace ( ) ; } if ( log Level . int Value ( ) > level . int Value ( ) ) { return ; } log Throwable ( level , message , e ) ; }
@ Override public void on Thread End ( ) { thread Count . get And Decrement ( ) ; wake ( ) ; }
private boolean is Paragraph Change ( String w Spaces ) { int len = w Spaces . length ( ) ; for ( int i = NUM_ ; i < len ; i ++ ) { char c = w Spaces . char At ( i ) ; if ( ( STR_ == c ) || ( STR_ == c ) ) { for ( int j = i + NUM_ ; j < len ; j ++ ) { if ( c == w Spaces . char At ( j ) ) { return true ; } } } } return false ; }
public void mouse Released ( Mouse Event ev ) { if ( ! try Popup ( ev ) && Swing Utilities . is Left Mouse Button ( ev ) ) { hmo . handle Header Column Released ( ev . get Point ( ) ) ; } }
public static synchronized void cleanup ( Result Set R ) { Statement S = null ; if ( R != null ) { try { S = R . get Statement ( ) ; } catch ( Throwable t ) { surface Throwable ( STR_ , t ) ; } cleanup ( S , R ) ; } }
protected void fire Path Changed ( Tree Path path ) { Object node = path . get Last Path Component ( ) ; Tree Path parent Path = path . get Parent Path ( ) ; if ( parent Path == null ) { fire Children Changed ( path , null , null ) ; } else { Object parent = parent Path . get Last Path Component ( ) ; fire Child Changed ( parent Path , get Index Of Child ( parent , node ) , node ) ; } }
@ Override public void end ( ) { super . end ( ) ; final Game Data data = get Data ( ) ; if ( Game Step Properties Helper . is Remove Air That Can Not Land ( data ) ) { remove Air That Cant Land ( ) ; } if ( Game Step Properties Helper . is Fire Rockets ( data ) ) { if ( m need To Do Rockets && Tech Tracker . has Rocket ( m bridge . get Player ID ( ) ) ) { final Rockets Fire Helper helper = new Rockets Fire Helper ( ) ; helper . fire Rockets ( m bridge , m bridge . get Player ID ( ) ) ; m need To Do Rockets = false ; } } if ( Game Step Properties Helper . is Reset Unit State At End ( data ) ) { reset Unit State And Delegate State ( ) ; } m need To Initialize = true ; m need To Do Rockets = true ; }
private void on Stop Attacked ( final I Entity attacker ) { attackers . remove ( attacker ) ; }
synchronized void close ( ) { expire ( System . current Time Millis ( ) ) ; closed = true ; }
@ Override protected void property Change ( Property Change Event evt ) { if ( Synth Look And Feel . should Update Style ( evt ) ) { update Style ( ( J Text Component ) evt . get Source ( ) ) ; } super . property Change ( evt ) ; }
long purge ( final int sample Size ) { final int limit = Math . min ( sample Size , get Num Active ( ) ) ; int num Samples = NUM_ ; int i = NUM_ ; final long [ ] samples = new long [ limit ] ; while ( num Samples < limit ) { if ( is Active ( i ) ) { samples [ num Samples ] = values [ i ] ; num Samples ++ ; } i ++ ; } final long val = Quick Select . select ( samples , NUM_ , num Samples - NUM_ , limit / NUM_ ) ; adjust All Values By ( - NUM_ * val ) ; keep Only Positive Counts ( ) ; return val ; }
@ Override public void done ( ) { if ( done ) return ; if ( ! deflater . finished ( ) ) { deflater . finish ( ) ; while ( ! deflater . finished ( ) ) deflate ( ) ; } done = true ; if ( idat Chunk Writer != null ) idat Chunk Writer . close ( ) ; }
public void on Child Thread Launch End ( ) { try { if ( thread Max <= thread Count . get And Decrement ( ) ) { wake ( ) ; } wake If Low Idle ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } }
public static void update Actor Position ( final Actor actor , final Stage stage , final Vector 2 new Screen Size In Stage Coords ) { if ( actor != null && stage != null ) { actor . set Position ( ( int ) ( ( actor . get X ( ) + actor . get Width ( ) / NUM_ ) / stage . get Width ( ) * new Screen Size In Stage Coords . x - actor . get Width ( ) / NUM_ ) , ( int ) ( ( actor . get Y ( ) + actor . get Height ( ) / NUM_ ) / stage . get Height ( ) * new Screen Size In Stage Coords . y - actor . get Height ( ) / NUM_ ) ) ; } }
void set Text ( byte [ ] text ) { this . text = text ; this . props = null ; }
@ Override public void completed ( int bytes Transferred , boolean can Invoke Direct ) { update Position ( bytes Transferred ) ; release Buffer If Substituted ( ) ; result . set Result ( bytes Transferred ) ; if ( can Invoke Direct ) { Invoker . invoke Unchecked ( result ) ; } else { Invoker . invoke ( result ) ; } }
@ Override protected void on Completed ( Io Event Args e ) { int transferred = e . get Bytes Transferred ( ) ; if ( transferred > NUM_ ) { if ( transferred < e . get Count ( ) ) { e . set Buffer ( e . get Offset ( ) + transferred , e . get Count ( ) - transferred ) ; send Async ( ) ; } else { send Packet ( ) ; } } else { dispose ( ) ; } }
private void apply To ( Class Visitor v , Method m ) { if ( Log . is Logging On ( ) ) { Log . log Line ( String . format ( STR_ , m . to Generic String ( ) ) ) ; } v . visit ( m ) ; }
public static void main ( String [ ] args ) { System . set Property ( STR_ , STR_ ) ; J Frame frame = new J Frame ( ) ; frame . set Content Pane ( new Bowler Studio 3 d Engine ( ) ) ; frame . set Size ( NUM_ , NUM_ ) ; frame . set Visible ( true ) ; frame . set Default Close Operation ( J Frame . EXIT ON CLOSE ) ; }
void renew Transaction ( ) throws Transaction Create Exception { if ( m conn == null || m closing ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ ) ; } tx = null ; return ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ ) ; } try { tx = m conn . get Transaction ( use Local Transactions , GS Session Impl . tx Lease Time ) ; } catch ( Transaction Create Exception re ) { if ( logger . is Loggable ( Level . SEVERE ) ) { logger . log ( Level . SEVERE , STR_ , re . orig ) ; } tx = null ; throw re ; } if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + tx ) ; } }
public void call Serially ( Runnable r ) { if ( codename One Running ) { synchronized ( lock ) { pending Serial Calls . add ( r ) ; lock . notify All ( ) ; } } else { r . run ( ) ; } }
protected void match Token ( Json Token token ) throws IO Exception , Json Parse Exception { String match Str = token . as String ( ) ; int i = NUM_ ; for ( int len = match Str . length ( ) ; i < len ; ++ i ) { if ( input Ptr >= input End ) { if ( ! load More ( ) ) { report Invalid EOF ( STR_ ) ; } } char c = input Buffer [ input Ptr ] ; if ( c != match Str . char At ( i ) ) { report Invalid Token ( match Str . substring ( NUM_ , i ) ) ; } ++ input Ptr ; } return ; }
public void dispose ( ) { if ( ffmpeg != null ) { try { ffmpeg . flush ( ) ; ffmpeg . close ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } if ( process != null ) { try { Thread . sleep ( NUM_ ) ; process . destroy ( ) ; process . wait For ( ) ; } catch ( Interrupted Exception e ) { P Applet . println ( STR_ ) ; e . print Stack Trace ( ) ; } } process Builder = null ; process = null ; img = null ; parent = null ; ffmpeg = null ; ffmpeg Output Msg = null ; settings = null ; P Applet . println ( output File Path , STR_ ) ; }
void abort ( ) { aborted = true ; try { if ( info Stream . is Enabled ( STR_ ) ) { info Stream . message ( STR_ , STR_ ) ; } try { consumer . abort ( ) ; } catch ( Throwable t ) { } pending Updates . clear ( ) ; } finally { if ( info Stream . is Enabled ( STR_ ) ) { info Stream . message ( STR_ , STR_ ) ; } } }
private Marker Util ( ) { super ( ) ; }
public static void paint 3 Deffect ( Graphics 2 D g 2 D , Rectangle r , boolean round , boolean out ) { Gradient Paint top Paint = null ; if ( out ) top Paint = new Gradient Paint ( r . x , r . y , COL 1 TOP , r . x , r . y + r . height / NUM_ , COL 1 END ) ; else top Paint = new Gradient Paint ( r . x , r . y , COL 2 END , r . x , r . y + r . height / NUM_ , COL 2 TOP ) ; g 2 D . set Paint ( top Paint ) ; Rectangular Shape top Rec = null ; if ( round ) top Rec = new Round Rectangle 2 D . Float ( r . x , r . y , r . width , r . height / NUM_ , NUM_ , NUM_ ) ; else top Rec = new Rectangle ( r . x , r . y , r . width , r . height / NUM_ ) ; g 2 D . fill ( top Rec ) ; Gradient Paint end Paint = null ; if ( out ) end Paint = new Gradient Paint ( r . x , r . y + r . height / NUM_ , COL 2 TOP , r . x , r . y + r . height , COL 2 END ) ; else end Paint = new Gradient Paint ( r . x , r . y + r . height / NUM_ , COL 1 END , r . x , r . y + r . height , COL 1 TOP ) ; g 2 D . set Paint ( end Paint ) ; Rectangular Shape end Rec = null ; if ( round ) end Rec = new Round Rectangle 2 D . Float ( r . x , r . y + r . height / NUM_ , r . width , r . height / NUM_ , NUM_ , NUM_ ) ; else end Rec = new Rectangle ( r . x , r . y + r . height / NUM_ , r . width , r . height / NUM_ ) ; g 2 D . fill ( end Rec ) ; }
public static < REACTOR extends React Builder > React Pool < REACTOR > unbounded Pool ( final Collection < REACTOR > reactors ) { final React Pool < REACTOR > r = new React Pool < > ( ) ; reactors . for Each ( null ) ; return r ; }
private void scroll ( float x , float y , float amount X , float amount Y , boolean is Tilt ) { if ( ( ! m Scroller . is Finished ( ) && is Tilt ) || m Stack Tabs == null || ( m Overview Animation Type != Overview Animation Type . NONE && m Overview Animation Type != Overview Animation Type . DISCARD && m Overview Animation Type != Overview Animation Type . UNDISCARD && m Overview Animation Type != Overview Animation Type . DISCARD ALL && m Overview Animation Type != Overview Animation Type . ENTER STACK ) ) { return ; } float amount Screen = m Current Mode == Orientation . PORTRAIT ? amount Y : amount X ; float amount Scroll = amount Screen ; float amount Even Out = amount Screen ; float tab Scroll Space Final = NUM_ ; if ( m Scrolling Tab == null || is Tilt ) { m Scrolling Tab = get Tab At Positon ( x , y ) ; } if ( m Scrolling Tab == null && m In Swipe && m Stack Tabs != null ) { int index = m Tab Model . index ( ) ; if ( index >= NUM_ && index <= m Stack Tabs . length ) m Scrolling Tab = m Stack Tabs [ index ] ; } if ( m Scrolling Tab == null ) { if ( ! is Tilt ) { amount Scroll = NUM_ ; amount Even Out = NUM_ ; } } else if ( m Scrolling Tab . get Index ( ) == NUM_ ) { amount Even Out = NUM_ ; } else { float tab Scroll Space = m Scrolling Tab . get Scroll Offset ( ) + m Scroll Offset ; float tab Screen = scroll To Screen ( tab Scroll Space ) ; tab Scroll Space Final = screen To Scroll ( tab Screen + amount Screen ) ; amount Scroll = tab Scroll Space Final - tab Scroll Space ; amount Scroll = Math . signum ( amount Screen ) * Math Utils . clamp ( Math . abs ( amount Scroll ) , Math . abs ( amount Screen ) * NUM_ , Math . abs ( amount Screen ) * NUM_ ) ; } if ( even Out Tabs ( amount Even Out , false ) && m Scrolling Tab . get Index ( ) > NUM_ ) { float tab Scroll Space = m Scrolling Tab . get Scroll Offset ( ) + m Scroll Offset ; amount Scroll = tab Scroll Space Final - tab Scroll Space ; } set Scroll Target ( m Scroll Target + amount Scroll , false ) ; }
@ Override protected void key Typed ( char par 1 , int par 2 ) { proxy Box . textbox Key Typed ( par 1 , par 2 ) ; if ( par 2 == NUM_ || par 2 == NUM_ ) action Performed ( ( Gui Button ) button List . get ( NUM_ ) ) ; }
private void handle Status ( Status status ) { Log . d ( TAG , STR_ + status ) ; Bean State bean State = status . bean State ( ) ; if ( bean State == Bean State . READY ) { reset Sketch State Timeout ( ) ; if ( sketch Upload State == Sketch Upload State . SENDING START COMMAND ) { sketch Upload State = Sketch Upload State . SENDING BLOCKS ; stop Sketch State Timeout ( ) ; send Next Sketch Block ( ) ; } } else if ( bean State == Bean State . PROGRAMMING ) { reset Sketch State Timeout ( ) ; } else if ( bean State == Bean State . COMPLETE ) { if ( on Sketch Upload Complete != null ) on Sketch Upload Complete . run ( ) ; reset Sketch Upload State ( ) ; } else if ( bean State == Bean State . ERROR ) { return Upload Error ( Bean Error . UNKNOWN ) ; reset Sketch Upload State ( ) ; } }
public void pre Single Sign On Request ( String hosted Entity ID , String idp Entity ID , String realm , Http Servlet Request request , Http Servlet Response response , Authn Request authn Request ) throws SAML 2 Exception { return ; }
public void action Performed ( Action Event e ) { Default Mutable Tree Node last Item = get Selected Node ( ) ; Default Mutable Tree Node parent ; if ( last Item != null ) { parent = ( Default Mutable Tree Node ) last Item . get Parent ( ) ; if ( parent == null ) { parent = ( Default Mutable Tree Node ) tree Model . get Root ( ) ; last Item = null ; } } else { parent = ( Default Mutable Tree Node ) tree Model . get Root ( ) ; } if ( parent == null ) { tree Model . set Root ( create New Node ( STR_ + Integer . to String ( add Count ++ ) ) ) ; } else { int new Index ; if ( last Item == null ) { new Index = tree Model . get Child Count ( parent ) ; } else { new Index = parent . get Index ( last Item ) + NUM_ ; } tree Model . insert Node Into ( create New Node ( STR_ + Integer . to String ( add Count ++ ) ) , parent , new Index ) ; } }
@ Suppress Warnings ( STR_ ) protected void initialize ( ) throws Illegal Argument Exception { if ( pattern . char At ( NUM_ ) != PATTERN CHAR ) { throw new Illegal Argument Exception ( ) ; } final String Builder pattern Builder = new String Builder ( pattern ) ; pattern Builder . delete ( NUM_ , NUM_ ) ; final char type = pattern Builder . char At ( NUM_ ) ; final String format = init Parameter ( pattern Builder , FORMAT CHARS ) ; set Inputs ( new Input [ ] { value Input Factory . create Input ( type , format , null ) } ) ; }
public void on Fedlet SLO Success ( Http Servlet Request request , Http Servlet Response response , Logout Request logout Req , Logout Response logout Res , String hosted Entity ID , String idp Entity ID , String binding ) throws SAML 2 Exception { on Fedlet SLO Success Or Failure ( request , response , logout Req , logout Res , hosted Entity ID , idp Entity ID , binding , true ) ; return ; }
public void schema Changed ( String service Name , String version ) { if ( debug . message Enabled ( ) ) { debug . message ( STR_ + service Name ) ; } try { Auth D authd = Auth D . get Auth ( ) ; if ( service Name . equals ( IS Auth Constants . AUTH SERVICE NAME ) ) { authd . update Auth Service Globals ( schema Manager ) ; } else if ( service Name . equals ( IS Auth Constants . AUTHCONFIG SERVICE NAME ) ) { authd . update Auth Config Globals ( schema Manager ) ; } else if ( service Name . equals ( IS Auth Constants . PLATFORM SERVICE NAME ) ) { authd . update Platform Service Globals ( schema Manager ) ; } else if ( service Name . equals ( IS Auth Constants . SESSION SERVICE NAME ) ) { authd . update Session Service Dynamics ( schema Manager ) ; } } catch ( Exception e ) { debug . error ( STR_ + e . get Message ( ) ) ; if ( debug . message Enabled ( ) ) { debug . message ( STR_ , e ) ; } } }
@ Override public void on Create ( Bundle saved Instance State ) { super . on Create ( saved Instance State ) ; set Content View ( R . layout . recents ) ; m Recents View = ( Overview ) find View By Id ( R . id . recents view ) ; m Recents View . set Callbacks ( this ) ; m Recents View . set System Ui Visibility ( View . SYSTEM UI FLAG LAYOUT STABLE | View . SYSTEM UI FLAG LAYOUT FULLSCREEN | View . SYSTEM UI FLAG LAYOUT HIDE NAVIGATION ) ; Intent Filter filter = new Intent Filter ( ) ; filter . add Action ( Intent . ACTION SCREEN OFF ) ; filter . add Action ( Search Manager . INTENT GLOBAL SEARCH ACTIVITY CHANGED ) ; try { Utilities . set Shadow Property ( STR_ , String . value Of ( NUM_ ) ) ; } catch ( Illegal Access Exception e ) { e . print Stack Trace ( ) ; } catch ( Invocation Target Exception e ) { e . print Stack Trace ( ) ; } }
public void hookup Stats ( Statistics Factory f , String name ) { if ( this . stats == null ) { this . stats = f . create Atomic Statistics ( type , name ) ; set Locator Count ( known locators . get ( ) ) ; set Server Count ( endpoints known . get ( ) ) ; set Locator Requests ( requests to locator . get ( ) ) ; set Locator Responses ( responses from locator . get ( ) ) ; set Server Load Updates ( server Load Updates . get ( ) ) ; } }
public static String translate To Local ( String unlocalized String , Object ... params ) { if ( I 18 n . has Key ( unlocalized String ) ) return I 18 n . format ( unlocalized String , params ) ; else { if ( UNLOCALIZED STRINGS . size ( ) < NUM_ && ! UNLOCALIZED STRINGS . contains ( unlocalized String ) ) UNLOCALIZED STRINGS . add ( unlocalized String ) ; return unlocalized String ; } }
void record Access ( Hash Entry < K , V > header , Eviction Policy eviction Policy ) { wait For Modify Permition ( header ) ; remove ( ) ; add Before ( ( Hash Entry < K , V > ) eviction Policy . record Access ( header , this ) ) ; access Count ++ ; last Accessed Time = System . current Time Millis ( ) ; grand Modify And Clone All Permition ( header ) ; }
public void logic ( final int current Turn ) { this . current Turn = current Turn ; Set < Turn Listener > set = null ; synchronized ( sync ) { set = register . remove ( Integer . value Of ( current Turn ) ) ; } if ( logger . is Debug Enabled ( ) ) { final String Builder os = new String Builder ( ) ; os . append ( STR_ + register . size ( ) + STR_ ) ; int set Size ; if ( set != null ) { set Size = set . size ( ) ; } else { set Size = NUM_ ; } os . append ( STR_ + set Size + STR_ ) ; logger . info ( os ) ; } if ( set != null ) { for ( final Turn Listener turn Listener : set ) { try { turn Listener . on Turn Reached ( current Turn ) ; } catch ( final Runtime Exception e ) { logger . error ( STR_ + turn Listener , e ) ; } } } }
public synchronized void add Property Change Listener ( Property Change Listener l ) { pcs . add Property Change Listener ( l ) ; }
@ Override public int put ( long key ) { Array Based Long To Internal Int Fixed Length Bi Map map ; int bucket ; for ( int i = NUM_ ; i < reader Accessible Info . maps . length - NUM_ ; i ++ ) { map = reader Accessible Info . maps [ i ] ; bucket = map . get ( key ) ; if ( bucket != default Get Return Value ) { return bucket + reader Accessible Info . map Index Offsets [ i ] ; } } int num Stored Keys Before = current Active Map . get Num Stored Keys ( ) ; map = current Active Map ; bucket = map . put ( key ) + current Active Map Index Offset ; num Stored Keys Counter . incr ( current Active Map . get Num Stored Keys ( ) - num Stored Keys Before ) ; if ( map . is At Capacity ( ) ) { add New Map ( ) ; } return bucket ; }
public Trigger Option with Early Firings At Every ( Duration duration ) { Time Trigger trigger = new Time Trigger ( Type . EARLY , duration ) ; trigger List . add ( trigger ) ; return this ; }
@ Suppress Warnings ( { STR_ , STR_ } ) private static Object to Set ( Object value , Class < ? > parameter Type ) throws Gf Json Exception { try { JSON Array array = ( JSON Array ) value ; Set set = new Hash Set ( ) ; for ( int i = NUM_ ; i < array . length ( ) ; i ++ ) { Object element = array . get ( i ) ; if ( is Primitive Or Wrapper ( element . get Class ( ) ) ) { set . add ( element ) ; } else throw new Gf Json Exception ( STR_ ) ; } return set ; } catch ( JSON Exception e ) { throw new Gf Json Exception ( e ) ; } }
public boolean post Single Sign On Failure ( String hosted Entity ID , String realm , Http Servlet Request request , Http Servlet Response response , Authn Request authn Request , Response sso Response , String profile , int failure Code ) { return false ; }
public void statistics Available ( Statistics Notification Event e ) { m Statistics . add All ( e . get Statistics ( ) ) ; update View ( ) ; }
protected View on Content View Created ( View content View ) { return content View ; }
private void undo ( ) { last Was Undo = true ; if ( pending Removal Header != null ) { list . add ( pending Removal Position - NUM_ , pending Removal Header ) ; list . add ( pending Removal Position , pending Removal Item ) ; notify Item Range Inserted ( pending Removal Position - NUM_ , NUM_ ) ; } else { list . add ( pending Removal Position , pending Removal Item ) ; notify Item Inserted ( pending Removal Position ) ; } if ( pending Removal Swipe Dir == Item Touch Helper . LEFT ) { undo Left ( pending Removal Item . object ) ; } else if ( pending Removal Swipe Dir == Item Touch Helper . RIGHT ) { undo Right ( pending Removal Item . object ) ; } }
private void start File Based Merge ( ) throws Carbon Sort Key And Group By Exception { try { data Sorter And Writer Executor Service . shutdown ( ) ; data Sorter And Writer Executor Service . await Termination ( NUM_ , Time Unit . DAYS ) ; } catch ( Interrupted Exception e ) { throw new Carbon Sort Key And Group By Exception ( STR_ , e ) ; } }
public void log Exception ( final Level level , final String message , final Exception e ) { try { Logger errors = Logging Factory . get Logger ( Logging Factory . NAME ERROR LOGGER ) ; errors . log Throwable ( level , message , e ) ; } catch ( Logging Exception ex ) { ex . print Stack Trace ( ) ; } if ( log Level . int Value ( ) > level . int Value ( ) ) { return ; } log Throwable ( level , message , e ) ; }
public void on Click ( View v ) { if ( v == m Popup View ) { switch Views ( true ) ; } }
public void reconect On Failure ( final boolean reconnect On Failure ) { this . reconnect On Failure = reconnect On Failure ; }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof Layer Handler ) { logger . fine ( STR_ ) ; set Layer Handler ( ( Layer Handler ) some Obj ) ; } if ( some Obj instanceof Buffered Layer Map Bean ) { logger . fine ( STR_ ) ; background Layer Separator = Layer Pane . get Background Layer Separator ( STR_ ) ; } if ( controls != null && some Obj != this ) { controls . find And Init ( some Obj ) ; } }
public void form List Downloading Complete ( Hash Map < String , Form Details > result ) { dismiss Dialog ( PROGRESS DIALOG ) ; m Download Form List Task . set Downloader Listener ( null ) ; m Download Form List Task = null ; if ( result == null ) { Log . e ( t , STR_ ) ; create Alert Dialog ( get String ( R . string . load remote form error ) , get String ( R . string . error occured ) , EXIT ) ; return ; } if ( result . contains Key ( Download Form List Task . DL AUTH REQUIRED ) ) { show Dialog ( AUTH DIALOG ) ; } else if ( result . contains Key ( Download Form List Task . DL ERROR MSG ) ) { String dialog Message = get String ( R . string . list failed with error , result . get ( Download Form List Task . DL ERROR MSG ) . error Str ) ; String dialog Title = get String ( R . string . load remote form error ) ; create Alert Dialog ( dialog Title , dialog Message , DO NOT EXIT ) ; } else { m Form Names And UR Ls = result ; m Form List . clear ( ) ; Array List < String > ids = new Array List < String > ( m Form Names And UR Ls . key Set ( ) ) ; for ( int i = NUM_ ; i < result . size ( ) ; i ++ ) { String form Details Key = ids . get ( i ) ; Form Details details = m Form Names And UR Ls . get ( form Details Key ) ; Hash Map < String , String > item = new Hash Map < String , String > ( ) ; item . put ( FORMNAME , details . form Name ) ; item . put ( FORMID DISPLAY , ( ( details . form Version == null ) ? STR_ : ( get String ( R . string . version ) + STR_ + details . form Version + STR_ ) ) + STR_ + details . form ID ) ; item . put ( FORMDETAIL KEY , form Details Key ) ; item . put ( FORM ID KEY , details . form ID ) ; item . put ( FORM VERSION KEY , details . form Version ) ; if ( m Form List . size ( ) == NUM_ ) { m Form List . add ( item ) ; } else { int j ; for ( j = NUM_ ; j < m Form List . size ( ) ; j ++ ) { Hash Map < String , String > compare Me = m Form List . get ( j ) ; String name = compare Me . get ( FORMNAME ) ; if ( name . compare To ( m Form Names And UR Ls . get ( ids . get ( i ) ) . form Name ) > NUM_ ) { break ; } } m Form List . add ( j , item ) ; } } select Superseded Forms ( ) ; m Form List Adapter . notify Data Set Changed ( ) ; m Download Button . set Enabled ( ! ( selected Item Count ( ) == NUM_ ) ) ; } }
public static void notify ( Object lock ) { synchronized ( lock ) { lock . notify ( ) ; } }
public void on First Run ( Configuration From Context configuration , Configuration Context context , Runnable start Runnable ) { start Runnable . run ( ) ; }
private void update For New Position ( ) { if ( ! current Position . equals ( STR_ ) ) { String [ ] splitty = current Position . split ( STR_ ) ; set Player List ( splitty [ NUM_ ] ) ; set Player Info Map ( splitty [ NUM_ ] ) ; exp List Adapter . notify Data Set Changed ( ) ; } else { players = avail All ; players Info = new Linked Hash Map < String , List < String > > ( ) ; for ( String p : players ) { Array List < String > p Info List = new Array List < String > ( ) ; p Info List . add ( get Player Details ( p , p . split ( STR_ ) [ NUM_ ] ) ) ; players Info . put ( p . substring ( NUM_ , p . length ( ) - NUM_ ) , p Info List ) ; } exp List Adapter . notify Data Set Changed ( ) ; } }
public boolean frame ( ) { frame Count ++ ; long time = System . current Time Millis ( ) ; if ( period Start <= NUM_ ) period Start = time ; long elapsed = time - period Start ; if ( elapsed >= NUM_ ) { current FPS = ( NUM_ * frame Count ) / ( float ) elapsed ; frame Count = NUM_ ; period Start = time ; return true ; } return false ; }
private void read Object ( Object Input Stream in ) throws IO Exception , Class Not Found Exception { in . default Read Object ( ) ; compute Parameters ( ) ; proj ID = null ; }
public void mouse Clicked ( Mouse Event event ) { if ( try Popup ( event ) ) return ; if ( Swing Utilities . is Right Mouse Button ( event ) ) { cm . handle Right Mouse Click ( event ) ; } else if ( event . get Click Count ( ) >= NUM_ ) { cm . handle Mouse Double Click ( event ) ; } else { cm . handle Mouse Click ( event ) ; } }
private void on Submit Query ( ) { Char Sequence query = m Search Edit Text . get Text ( ) ; if ( query != null && Text Utils . get Trimmed Length ( query ) > NUM_ ) { if ( m On Query Text Listener == null || ! m On Query Text Listener . on Query Text Submit ( query . to String ( ) ) ) { if ( m Should Keep History ) { save Query To Db ( query . to String ( ) , System . current Time Millis ( ) ) ; } refresh Adapter Cursor ( ) ; close Search ( ) ; m Search Edit Text . set Text ( STR_ ) ; } } }
private void check Target Is Not Writable ( File target , Throwable exception ) throws Core Exception { if ( ! target . can Write ( ) ) { String message = NLS . bind ( Messages . could Not Write , target . get Absolute Path ( ) ) ; Policy . error ( EFS . ERROR WRITE , message ) ; } }
public Response on Command ( SMTP Session session , Request request ) { return NOOP ; }
private void on Subtitle Download Success ( ) { if ( context Reference . get ( ) == null ) return ; if ( listener Reference . get ( ) == null ) return ; Context context = context Reference . get ( ) ; I Subtitle Downloader Listener listener = listener Reference . get ( ) ; try { File subtitle File = get Downloaded Subtitle File ( context , media , subtitle Language ) ; Subtitle Parse Task task = new Subtitle Parse Task ( subtitle Language , listener ) ; task . execute ( subtitle File ) ; } catch ( File Not Found Exception e ) { e . print Stack Trace ( ) ; listener . on Subtitle Download Completed ( false , null ) ; } }
@ Override public void close ( ) { try { out . close ( ) ; } catch ( final XML Stream Exception e ) { throw new Stream Exception ( e ) ; } }
public void append Only First ( String s ) { if ( index == NUM_ ) { builder . append ( s ) ; } }
@ Override public void mouse Dragged ( Mouse Event e ) { int x = e . get X ( ) ; int y = e . get Y ( ) ; if ( selecting area ) { if ( shaping selection ) { int dx = ( x - origin x ) / NUM_ ; int dy = ( y - origin y ) / NUM_ ; if ( shaping action == Cursor Selection Position . INSIDE || shaping action == Cursor Selection Position . W SIDE || shaping action == Cursor Selection Position . NW CORNER || shaping action == Cursor Selection Position . SW CORNER ) selection start x = ( int ) ( ssx + dx / zoom level ) ; if ( shaping action == Cursor Selection Position . INSIDE || shaping action == Cursor Selection Position . N SIDE || shaping action == Cursor Selection Position . NW CORNER || shaping action == Cursor Selection Position . NE CORNER ) selection start z = ( int ) ( ssz + dy / zoom level ) ; if ( shaping action == Cursor Selection Position . INSIDE || shaping action == Cursor Selection Position . E SIDE || shaping action == Cursor Selection Position . NE CORNER || shaping action == Cursor Selection Position . SE CORNER ) selection end x = ( int ) ( sex + dx / zoom level ) ; if ( shaping action == Cursor Selection Position . INSIDE || shaping action == Cursor Selection Position . S SIDE || shaping action == Cursor Selection Position . SW CORNER || shaping action == Cursor Selection Position . SE CORNER ) selection end z = ( int ) ( sez + dy / zoom level ) ; repaint ( ) ; return ; } selection end x = ( int ) Math . floor ( ( e . get X ( ) / zoom level - shift x ) / NUM_ ) ; selection end z = ( int ) Math . floor ( ( e . get Y ( ) / zoom level - shift y ) / NUM_ ) ; if ( selectchunks ) { if ( selection start x % NUM_ != NUM_ ) { selection start x = Math . round ( selection start x / NUM_ ) * NUM_ ; } if ( selection start z % NUM_ != NUM_ ) { selection start z = Math . round ( selection start z / NUM_ ) * NUM_ ; } if ( selection end x % NUM_ != NUM_ ) { selection end x = Math . round ( selection end x / NUM_ ) * NUM_ ; } if ( selection end z % NUM_ != NUM_ ) { selection end z = Math . round ( selection end z / NUM_ ) * NUM_ ; } } repaint ( ) ; return ; } if ( moving map ) { shift x += ( x - last x ) / zoom level ; shift y += ( y - last y ) / zoom level ; last x = x ; last y = y ; redraw ( true ) ; repaint ( ) ; } }
@ Call Super protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( is Horizontal ( ) ) { if ( m Decor Child Count > NUM_ ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } dispatch On Page Scrolled ( position , offset , offset Pixels ) ; if ( m Page Transformer != null ) { final int scroll X = get Scroll X ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Left ( ) - scroll X ) / get Client Width ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } } else { if ( m Decor Child Count > NUM_ ) { final int scroll Y = get Scroll Y ( ) ; int padding Top = get Padding Top ( ) ; int padding Bottom = get Padding Bottom ( ) ; final int height = get Height ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int vgrav = lp . gravity & Gravity . VERTICAL GRAVITY MASK ; int child Top = NUM_ ; switch ( vgrav ) { default : child Top = padding Top ; break ; case Gravity . TOP : child Top = padding Top ; padding Top += child . get Height ( ) ; break ; case Gravity . CENTER VERTICAL : child Top = Math . max ( ( height - child . get Measured Height ( ) ) / NUM_ , padding Top ) ; break ; case Gravity . BOTTOM : child Top = height - padding Bottom - child . get Measured Height ( ) ; padding Bottom += child . get Measured Height ( ) ; break ; } child Top += scroll Y ; final int child Offset = child Top - child . get Top ( ) ; if ( child Offset != NUM_ ) { child . offset Top And Bottom ( child Offset ) ; } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final int scroll Y = get Scroll Y ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Top ( ) - scroll Y ) / get Client Height ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } } m Called Super = true ; }
@ Call Super public void on View Model Created ( ) { m Ui Thread = Thread . current Thread ( ) ; }
protected void on Exception ( final Throwable e , Object ... context ) { if ( e != null ) { e . print Stack Trace ( ) ; } }
public void removed ( Container cont ) { Map Tile Factory tile Factory = get Tile Factory ( ) ; if ( tile Factory != null ) { tile Factory . reset ( ) ; } }
@ Override public int hash Code ( ) { return id . hash Code ( ) ; }
private Fixed Allocator establish Free Fixed Allocator ( final int block ) { final Array List < Fixed Allocator > list = m free Fixed [ block ] ; for ( int i = NUM_ ; i < list . size ( ) ; i ++ ) { Fixed Allocator f = list . get ( i ) ; if ( ! is On Commit List ( f ) ) { list . remove ( i ) ; return f ; } } final int alloc Size = NUM_ * m alloc Sizes [ block ] ; final Fixed Allocator allocator = new Fixed Allocator ( this , alloc Size ) ; allocator . set Index ( m allocs . size ( ) ) ; m allocs . add ( allocator ) ; if ( m storage Stats != null ) { m storage Stats . register ( allocator , true ) ; } return allocator ; }
public synchronized boolean on Delta Received ( UUID node Id , long time Delta ) { Delta Average avg = pending Deltas . get ( node Id ) ; if ( avg != null ) { avg . on Value ( time Delta ) ; if ( avg . ready ( ) ) { pending Deltas . remove ( node Id ) ; deltas . put ( node Id , avg . average ( ) ) ; if ( ready ( ) ) notify All ( ) ; return false ; } return true ; } return false ; }
@ Override public void on Scale End ( Scale Gesture Detector detector ) { float scale = cell Size / initial Cell Size ; double f = Math . pow ( ZOOM STEP , Math . round ( Math . log ( scale ) / Math . log ( ZOOM STEP ) ) ) ; scale = ( float ) ( initial Cell Size * f ) / cell Size ; cell Size *= scale ; origin X += last Focus X * scale - last Focus X ; origin Y += last Focus Y * scale - last Focus Y ; origin X = Math . round ( origin X / cell Size ) * cell Size ; origin Y = Math . round ( origin Y / cell Size ) * cell Size ; selection . set Visibility ( INVISIBLE ) ; sge . set State ( origin X , origin Y , cell Size ) ; invalidate ( ) ; }
protected J Component create Content ( ) { J Label lb = new J Label ( STR_ ) ; lb . set Foreground ( new Color ( NUM_ , NUM_ , NUM_ ) ) ; return lb ; }
public void rollback Nothing Method ( String step Id ) { Workflow Step Completer . step Succeded ( step Id ) ; }
@ Override public void insert String ( int offset , String str , Attribute Set a ) throws Bad Location Exception { if ( m Add Matching End Blocks && ( m Block Start . length ( ) > NUM_ ) && str . equals ( m Block Start ) ) { str = add Matching Block End ( offset ) ; } else if ( m Use Blanks && str . equals ( STR_ ) ) { str = m Indentation ; } super . insert String ( offset , str , a ) ; process Changed Lines ( offset , str . length ( ) ) ; }
public void find And Init ( Iterator < ? > it ) { while ( it . has Next ( ) ) { find And Init ( it . next ( ) ) ; } }
public static String decode Dummy Marker From Property Info ( String possible Dummy Marker ) { if ( possible Dummy Marker != null && possible Dummy Marker . starts With ( DUMMY MARKER NAME ) ) { int last Dot = possible Dummy Marker . last Index Of ( STR_ ) ; if ( last Dot != - NUM_ ) { possible Dummy Marker = possible Dummy Marker . substring ( last Dot + NUM_ ) ; } } return possible Dummy Marker ; }
private void init Vocoder ( int mcep order , int mcep vsize , HMM Data hts Data ) { stage = hts Data . get Stage ( ) ; gamma = hts Data . get Gamma ( ) ; use log gain = hts Data . get Use Log Gain ( ) ; fprd = hts Data . get Fperiod ( ) ; rate = hts Data . get Rate ( ) ; rand = new Random ( SEED ) ; C = new double [ mcep order ] ; CC = new double [ mcep order ] ; CINC = new double [ mcep order ] ; if ( stage == NUM_ ) { int vector size = ( mcep vsize * ( NUM_ + PADEORDER ) + NUM_ * PADEORDER + NUM_ ) - ( NUM_ * ( mcep order ) ) ; D 1 = new double [ vector size ] ; pt 2 = ( NUM_ * ( PADEORDER + NUM_ ) ) + ( PADEORDER * ( mcep order + NUM_ ) ) ; for ( int i = PADEORDER ; i >= NUM_ ; i -- ) pt 3 [ i ] = ( NUM_ * ( PADEORDER + NUM_ ) ) + ( ( i - NUM_ ) * ( mcep order + NUM_ ) ) ; } else { int vector size = ( ( mcep vsize + NUM_ ) * ( stage + NUM_ ) ) - ( NUM_ * ( mcep order ) ) ; D 1 = new double [ vector size ] ; } p 1 = - NUM_ ; pc = NUM_ ; }
@ Override public Path Impl lookup Impl ( String user Path , Map < String , Object > new Attributes , boolean is Allow Root ) { String new Path ; if ( user Path == null ) return root . fs Walk ( get Path ( ) , new Attributes , STR_ ) ; int length = user Path . length ( ) ; int colon = user Path . index Of ( STR_ ) ; int slash = user Path . index Of ( STR_ ) ; int query = user Path . index Of ( STR_ ) ; if ( colon != - NUM_ && ( colon < slash || slash == - NUM_ ) ) return super . lookup Impl ( user Path , new Attributes , is Allow Root ) ; if ( slash == NUM_ && length > NUM_ && user Path . char At ( NUM_ ) == STR_ ) return scheme Walk ( user Path , new Attributes , user Path , NUM_ ) ; else if ( slash == NUM_ ) { String query String = STR_ ; if ( query >= NUM_ ) { query String = user Path . substring ( query ) ; user Path = user Path . substring ( NUM_ , query ) ; } new Path = normalize Path ( STR_ , user Path , NUM_ , STR_ ) ; if ( query >= NUM_ ) new Path += query String ; } else { String query String = STR_ ; if ( query >= NUM_ ) { query String = user Path . substring ( query ) ; user Path = user Path . substring ( NUM_ , query ) ; } new Path = normalize Path ( pathname , user Path , NUM_ , STR_ ) ; if ( query >= NUM_ ) new Path += query String ; } return root . fs Walk ( user Path , new Attributes , new Path ) ; }
public static < REACTOR extends React Builder > React Pool < REACTOR > bounded Pool ( final Collection < REACTOR > reactors ) { final React Pool < REACTOR > r = new React Pool < > ( reactors . size ( ) ) ; reactors . for Each ( null ) ; return r ; }
@ Override public SOAP Handler on Start Child ( String namespace , String local Name , String prefix , Attributes attributes , Deserialization Context context ) throws SAX Exception { handle Mixed Content ( ) ; Bean Property Descriptor prop Desc = null ; Field Desc field Desc = null ; SOAP Constants soap Constants = context . get SOAP Constants ( ) ; String encoding Style = context . get Encoding Style ( ) ; boolean is Encoded = Constants . is SOAP ENC ( encoding Style ) ; Q Name elem Q Name = new Q Name ( namespace , local Name ) ; if ( ( prev Q Name == null ) || ( ! prev Q Name . equals ( elem Q Name ) ) ) { collection Index = - NUM_ ; } boolean is Array = false ; Q Name item Q Name = null ; if ( type Desc != null ) { String field Name = type Desc . get Field Name For Element ( elem Q Name , is Encoded ) ; prop Desc = ( Bean Property Descriptor ) property Map . get ( field Name ) ; field Desc = type Desc . get Field By Name ( field Name ) ; if ( field Desc != null ) { Element Desc element = ( Element Desc ) field Desc ; is Array = element . is Max Occurs Unbounded ( ) ; item Q Name = element . get Item Q Name ( ) ; } } if ( prop Desc == null ) { prop Desc = ( Bean Property Descriptor ) property Map . get ( local Name ) ; } if ( prop Desc == null ) { String Builder sb = new String Builder ( ) ; sb . append ( Character . to Lower Case ( local Name . char At ( NUM_ ) ) ) ; if ( local Name . length ( ) > NUM_ ) sb . append ( local Name . substring ( NUM_ ) ) ; prop Desc = ( Bean Property Descriptor ) property Map . get ( sb . to String ( ) ) ; } if ( prop Desc == null || ( ( ( prev Q Name != null ) && prev Q Name . equals ( elem Q Name ) && ! ( prop Desc . is Indexed ( ) || is Array ) && get Any Property Desc ( ) != null ) ) ) { prev Q Name = elem Q Name ; prop Desc = get Any Property Desc ( ) ; if ( prop Desc != null ) { try { Message Element [ ] cur Elements = ( Message Element [ ] ) prop Desc . get ( value ) ; int length = NUM_ ; if ( cur Elements != null ) { length = cur Elements . length ; } Message Element [ ] new Elements = new Message Element [ length + NUM_ ] ; if ( cur Elements != null ) { System . arraycopy ( cur Elements , NUM_ , new Elements , NUM_ , length ) ; } Message Element this El = context . get Cur Element ( ) ; new Elements [ length ] = this El ; prop Desc . set ( value , new Elements ) ; if ( ! local Name . equals ( this El . get Name ( ) ) ) { return new SOAP Handler ( new Elements , length ) ; } return new SOAP Handler ( ) ; } catch ( Exception e ) { throw new SAX Exception ( e ) ; } } } if ( prop Desc == null ) { throw new SAX Exception ( Messages . get Message ( STR_ , java Type . get Name ( ) , local Name ) ) ; } prev Q Name = elem Q Name ; Q Name child XML Type = context . get Type From Attributes ( namespace , local Name , attributes ) ; String href = attributes . get Value ( soap Constants . get Attr Href ( ) ) ; Class field Type = prop Desc . get Type ( ) ; if ( child XML Type == null && field Desc != null && href == null ) { child XML Type = field Desc . get Xml Type ( ) ; if ( item Q Name != null ) { child XML Type = Constants . SOAP ARRAY ; field Type = prop Desc . get Actual Type ( ) ; } else { child XML Type = field Desc . get Xml Type ( ) ; } } Deserializer d Ser = get Deserializer ( child XML Type , field Type , href , context ) ; if ( d Ser == null ) { d Ser = context . get Deserializer For Class ( prop Desc . get Type ( ) ) ; } if ( context . is Nil ( attributes ) ) { if ( ( prop Desc . is Indexed ( ) || is Array ) ) { if ( ! ( ( d Ser != null ) && ( d Ser instanceof Array Deserializer ) ) ) { collection Index ++ ; d Ser . register Value Target ( new Bean Property Target ( value , prop Desc , collection Index ) ) ; add Child Deserializer ( d Ser ) ; return ( SOAP Handler ) d Ser ; } } return null ; } if ( d Ser == null ) { throw new SAX Exception ( Messages . get Message ( STR_ , child XML Type . to String ( ) ) ) ; } if ( constructor To Use != null ) { if ( constructor Target == null ) { constructor Target = new Constructor Target ( constructor To Use , this ) ; } d Ser . register Value Target ( constructor Target ) ; } else if ( prop Desc . is Writeable ( ) ) { if ( ( item Q Name != null || prop Desc . is Indexed ( ) || is Array ) && ! ( d Ser instanceof Array Deserializer ) ) { collection Index ++ ; d Ser . register Value Target ( new Bean Property Target ( value , prop Desc , collection Index ) ) ; } else { collection Index = - NUM_ ; d Ser . register Value Target ( new Bean Property Target ( value , prop Desc ) ) ; } } add Child Deserializer ( d Ser ) ; return ( SOAP Handler ) d Ser ; }
protected boolean check Portal Icon For Update ( Portal Icon icon , boolean moved ) { Portal portal = icon . get Portal ( ) ; if ( portal == null ) { icon . remove ( ) ; log . error ( STR_ ) ; return false ; } String name = portal . get Display Name ( ) ; String msg = null ; O Block from Block = portal . get From Block ( ) ; O Block to Block = portal . get To Block ( ) ; if ( ! home Block . equals ( from Block ) && ! home Block . equals ( to Block ) ) { msg = Bundle . get Message ( STR_ , home Block . get Display Name ( ) , portal . get Description ( ) ) ; adjacent Block = null ; } if ( msg == null ) { msg = icon Intersects Block ( icon , home Block ) ; } if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + home Block . get Display Name ( ) + STR_ + ( msg == null ) + STR_ + msg ) ; } if ( msg == null ) { if ( home Block . equals ( from Block ) ) { adjacent Block = to Block ; } else { adjacent Block = from Block ; } if ( adjacent Block == null ) { adjacent Block = find Adjacent Block ( icon ) ; if ( home Block . equals ( from Block ) ) { portal . set To Block ( adjacent Block , false ) ; } else { portal . set From Block ( adjacent Block , false ) ; } portal List . data Change ( ) ; } if ( moved ) { O Block block = find Adjacent Block ( icon ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + ( block != null ? block . get Display Name ( ) : STR_ ) + STR_ + ( adjacent Block != null ? adjacent Block . get Display Name ( ) : STR_ ) ) ; } if ( block != null && block . equals ( adjacent Block ) ) { portal List . set Selected Value ( portal , true ) ; return true ; } } if ( adjacent Block != null ) { msg = icon Intersects Block ( icon , adjacent Block ) ; if ( msg == null ) { portal List . set Selected Value ( portal , true ) ; return true ; } } if ( adjacent Block == null ) { adjacent Block = find Adjacent Block ( icon ) ; if ( adjacent Block != null ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + home Block . get Display Name ( ) + STR_ + adjacent Block . get Display Name ( ) ) ; } int result = J Option Pane . show Confirm Dialog ( this , Bundle . get Message ( STR_ , name , home Block . get Display Name ( ) , adjacent Block . get Display Name ( ) ) , Bundle . get Message ( STR_ ) , J Option Pane . YES NO OPTION , J Option Pane . QUESTION MESSAGE ) ; if ( result == J Option Pane . YES OPTION ) { if ( home Block . equals ( from Block ) ) { portal . set To Block ( adjacent Block , true ) ; } else { portal . set From Block ( adjacent Block , true ) ; } } msg = null ; } else { msg = Bundle . get Message ( STR_ , icon . get Name String ( ) , home Block . get Display Name ( ) ) ; } } } if ( msg != null ) { J Option Pane . show Message Dialog ( this , msg , Bundle . get Message ( STR_ ) , J Option Pane . INFORMATION MESSAGE ) ; clear List Selection ( ) ; return false ; } portal List . set Selected Value ( portal , true ) ; portal List . data Change ( ) ; return true ; }
protected void update Size ( ) { reset Mapping ( ) ; if ( frame Peer != null ) { frame Peer . reshape Menubar Peer ( ) ; } }
public void pending Removal ( int position , int swipe Dir ) { last Was Undo = false ; pending Removal Item = list . get ( position ) ; pending Removal Position = position ; pending Removal Swipe Dir = swipe Dir ; if ( position != NUM_ && get Item View Type ( position - NUM_ ) == TYPE HEADER && ( position == list . size ( ) - NUM_ || get Item View Type ( position + NUM_ ) == TYPE HEADER ) ) { pending Removal Header = list . get ( position - NUM_ ) ; list . remove ( position ) ; list . remove ( position - NUM_ ) ; notify Item Range Removed ( position - NUM_ , NUM_ ) ; } else { pending Removal Header = null ; list . remove ( position ) ; notify Item Removed ( position ) ; } if ( swipe Dir == Item Touch Helper . LEFT ) { show Snackbar ( swiped Left ( pending Removal Item . object ) ) ; } else if ( swipe Dir == Item Touch Helper . RIGHT ) { show Snackbar ( swiped Right ( pending Removal Item . object ) ) ; } }
public void register Data Set Observer ( Data Set Observer observer ) { list Adapter Observable . register Observer ( observer ) ; }
public void do Print Setup ( ) { do Print ( ) ; }
protected void rejected ( final RP Entity user ) { if ( rejected Message != null ) { send Message ( user , rejected Message ) ; if ( get Resistance ( ) != NUM_ ) { user . stop ( ) ; user . clear Path ( ) ; } } }
void on Cancel Permission Request ( ) { rationale Accepted . set ( false ) ; update Permissions As Denied ( pending Permissions ) ; }
public static void main ( String [ ] args ) { Print Stream ps = null ; try { ps = new Print Stream ( System . out , true , STR_ ) ; ps . println ( transform ( args ) ) ; } catch ( Throwable t ) { t . print Stack Trace ( ) ; if ( ps != null ) ps . println ( TRANSFORMATION FAILED FLAG ) ; if ( t instanceof Error ) throw ( Error ) t ; } }
public boolean handle Long Click ( View v , float x , float y ) { synchronized ( action Mode Callback Lock ) { if ( ( current Action Mode Callback instanceof Path Creation Action Mode Callback ) ) { Log . d ( STR_ , STR_ ) ; return false ; } } v . perform Haptic Feedback ( Haptic Feedback Constants . LONG PRESS ) ; if ( main . start Support Action Mode ( new Long Click Action Mode Callback ( x , y ) ) == null ) { main . start Support Action Mode ( new Path Creation Action Mode Callback ( x , y ) ) ; } return true ; }
public static long optimize ( Input Stream in , Output Stream out , Configuration configuration ) throws IO Exception { Movie movie = new Movie ( ) ; Tag Decoder tag Decoder = new Tag Decoder ( in ) ; Movie Decoder movie Decoder = new Movie Decoder ( movie ) ; tag Decoder . parse ( movie Decoder ) ; optimize ( movie , configuration ) ; Tag Encoder handler = new Tag Encoder ( ) ; Movie Encoder encoder = new Movie Encoder ( handler ) ; encoder . export ( movie ) ; Byte Array Output Stream baos = new Byte Array Output Stream ( ) ; handler . write To ( baos ) ; out . write ( baos . to Byte Array ( ) ) ; return baos . size ( ) ; }
private void on Tts Ready ( ) { Locale locale = Locale . get Default ( ) ; int language Availability = tts . is Language Available ( locale ) ; if ( language Availability == Text To Speech . LANG MISSING DATA || language Availability == Text To Speech . LANG NOT SUPPORTED ) { Log . w ( TAG , STR_ ) ; locale = Locale . ENGLISH ; } tts . set Language ( locale ) ; tts . set Speech Rate ( TTS SPEECH RATE ) ; tts . set On Utterance Completed Listener ( utterance Listener ) ; }
public static void on Event ( int event Type ) { if ( s Instance == null ) { s Instance = new Camera Performance Tracker ( ) ; } long current Time = System . current Time Millis ( ) ; switch ( event Type ) { case ACTIVITY START : s Instance . m App Start Time = current Time ; break ; case ACTIVITY PAUSE : s Instance . m First Preview Frame Latency Warm Start = UNSET ; break ; case ACTIVITY RESUME : s Instance . m App Resume Time = current Time ; break ; case FIRST PREVIEW FRAME : Log . d ( TAG , STR_ ) ; if ( s Instance . m First Preview Frame Latency Cold Start == UNSET ) { s Instance . m First Preview Frame Latency Cold Start = current Time - s Instance . m App Start Time ; } else { s Instance . m First Preview Frame Latency Warm Start = current Time - s Instance . m App Resume Time ; } if ( s Instance . m Mode Switch Start Time != UNSET ) { s Instance . m Mode Switch Duration = current Time - s Instance . m Mode Switch Start Time ; s Instance . m Mode Switch Start Time = UNSET ; } break ; case MODE SWITCH START : s Instance . m Mode Switch Start Time = current Time ; break ; default : break ; } if ( DEBUG && event Type == FIRST PREVIEW FRAME ) { Log . d ( TAG , STR_ + ( s Instance . m Mode Switch Duration == UNSET ? STR_ : s Instance . m Mode Switch Duration ) ) ; Log . d ( TAG , STR_ + ( s Instance . m First Preview Frame Latency Cold Start == UNSET ? STR_ : s Instance . m First Preview Frame Latency Cold Start ) ) ; Log . d ( TAG , STR_ + ( s Instance . m First Preview Frame Latency Warm Start == UNSET ? STR_ : s Instance . m First Preview Frame Latency Warm Start ) ) ; } }
public Fast Adapter < Item > with Saved Instance State ( Bundle saved Instance State , String prefix ) { if ( saved Instance State != null ) { deselect ( ) ; if ( m Position Based State Management ) { int [ ] expanded Items = saved Instance State . get Int Array ( BUNDLE EXPANDED + prefix ) ; if ( expanded Items != null ) { for ( Integer expanded Item : expanded Items ) { expand ( expanded Item ) ; } } int [ ] selections = saved Instance State . get Int Array ( BUNDLE SELECTIONS + prefix ) ; if ( selections != null ) { for ( Integer selection : selections ) { select ( selection ) ; } } } else { Array List < String > expanded Items = saved Instance State . get String Array List ( BUNDLE EXPANDED + prefix ) ; Array List < String > selected Items = saved Instance State . get String Array List ( BUNDLE SELECTIONS + prefix ) ; Item item ; String id ; for ( int i = NUM_ , size = get Item Count ( ) ; i < size ; i ++ ) { item = get Item ( i ) ; id = String . value Of ( item . get Identifier ( ) ) ; if ( expanded Items != null && expanded Items . contains ( id ) ) { expand ( i ) ; } if ( selected Items != null && selected Items . contains ( id ) ) { select ( i ) ; } Adapter Util . restore Sub Item Selection States For Alternative State Management ( item , selected Items ) ; } } } return this ; }
@ Override public void shutdown ( Shutdown Mode Amp mode ) { for ( int i = service Close List . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Service Ref Amp service = service Close List . get ( i ) ; service . shutdown ( mode ) ; } for ( Gateway Result Stream result : gateway Result Map . values ( ) ) { result . cancel ( ) ; } service Ref Out . close ( Result . ignore ( ) ) ; }
public void writing Request Headers ( ) { if ( sent Request Millis != - NUM_ ) throw new Illegal State Exception ( ) ; sent Request Millis = System . current Time Millis ( ) ; }
private void on Resume ( ) { m Subscription = m Subscription . is Unsubscribed ( ) ? new Composite Subscription ( ) : m Subscription ; Map < Integer , Observable > observables = m Cache . get Observables ( m UUID ) ; for ( Map . Entry < Integer , Observable > entry : observables . entry Set ( ) ) { if ( ! m Dispatched Observables History . contains ( entry . get Key ( ) ) ) { dispatch Observable To Host ( entry . get Key ( ) , entry . get Value ( ) ) ; } } }
public void draw Figure ( Graphics 2 D g ) { Affine Transform saved Transform = null ; if ( get ( TRANSFORM ) != null ) { saved Transform = g . get Transform ( ) ; g . transform ( get ( TRANSFORM ) ) ; } if ( get ( FILL STYLE ) != ODG Constants . Fill Style . NONE ) { Paint paint = ODG Attribute Keys . get Fill Paint ( this ) ; if ( paint != null ) { g . set Paint ( paint ) ; draw Fill ( g ) ; } } if ( get ( STROKE STYLE ) != ODG Constants . Stroke Style . NONE ) { Paint paint = ODG Attribute Keys . get Stroke Paint ( this ) ; if ( paint != null ) { g . set Paint ( paint ) ; g . set Stroke ( ODG Attribute Keys . get Stroke ( this ) ) ; draw Stroke ( g ) ; } } if ( get ( TRANSFORM ) != null ) { g . set Transform ( saved Transform ) ; } }
public void state Changed ( Change Event e ) { if ( e == null ) { return ; } if ( my Bar != null ) { Object new Model Value = my Bar . get Value ( ) ; fire Property Change ( ACCESSIBLE VALUE PROPERTY , old Model Value , new Model Value ) ; old Model Value = new Model Value ; } }
protected void copy Selected Bean ( ) { if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ ) ; if ( selected Bean == null || selected Bean Location == null ) { clear Selection ( ) ; if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ + selected Bean ) ; if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ + selected Bean Location ) ; return ; } try { ser Bean = new Byte Array Output Stream ( ) ; Object Output Stream oos = new Object Output Stream ( ser Bean ) ; oos . write Object ( selected Bean ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; clear Selection ( ) ; if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ ) ; return ; } cut Bean = null ; if ( Debug . debugging ( STR_ ) ) Debug . output ( STR_ ) ; }
public void animate Expand ( int duration , long pop Time ) { long time Difference = System . current Time Millis ( ) - pop Time ; Object Animator animator Expand Y = Object Animator . of Float ( peek View , STR_ , NUM_ ) ; Object Animator animator Expand X = Object Animator . of Float ( peek View , STR_ , NUM_ ) ; animator Expand X . set Interpolator ( new Decelerate Interpolator ( ) ) ; animator Expand Y . set Interpolator ( new Decelerate Interpolator ( ) ) ; animator Expand X . set Duration ( Math . max ( NUM_ , duration - time Difference ) ) ; animator Expand Y . set Duration ( Math . max ( NUM_ , duration - time Difference ) ) ; animator Expand X . start ( ) ; animator Expand Y . start ( ) ; }
public static void alert ( final GTG Event event , final boolean is On , final Object obj ) { int i ; synchronized ( event Listeners ) { if ( event . is On == is On && obj == null ) return ; event . is On = is On ; event . obj = obj ; local Event Listeners . clear ( ) ; local Event Listeners . add All ( event Listeners . key Set ( ) ) ; i = local Event Listeners . size ( ) - NUM_ ; } for ( ; i >= NUM_ ; i -- ) { GTG Event Listener el ; el = local Event Listeners . get ( i ) ; if ( event . is On ) { if ( el . on GTG Event ( event ) ) { alert ( event , false ) ; break ; } } else el . off GTG Event ( event ) ; } local Event Listeners . clear ( ) ; }
private Configuration Provider ( ) { throw new Assertion Error ( ) ; }
@ Override public final void on Heatmap Failed ( ) { m Update Pending = false ; }
public boolean zone Export Add Volumes ( URI export Group URI , List < URI > export Mask UR Is , Collection < URI > volume UR Is , String token ) { Export Group export Group = db Client . query Object ( Export Group . class , export Group URI ) ; log . info ( String . format ( STR_ , export Group . get Label ( ) , export Group . get Id ( ) , volume UR Is . to String ( ) ) ) ; String add Zone While Adding Volume = custom Config Handler . get Computed Custom Config Value ( Custom Config Constants . ZONE ADD VOLUME , Custom Config Constants . GLOBAL KEY , null ) ; Boolean add Zone On Device Operation = true ; log . info ( STR_ , add Zone While Adding Volume , add Zone On Device Operation ) ; if ( add Zone While Adding Volume != null ) { add Zone On Device Operation = Boolean . value Of ( add Zone While Adding Volume ) ; log . info ( STR_ , add Zone While Adding Volume , add Zone On Device Operation ) ; } else { log . info ( STR_ , add Zone On Device Operation ) ; } log . info ( STR_ , add Zone While Adding Volume , add Zone On Device Operation ) ; return do Zone Export Masks Create ( export Group , export Mask UR Is , volume UR Is , token , add Zone On Device Operation ) ; }
public void on Query Filter Change ( final String current Text , final boolean valid , final String validation Message ) { if ( valid ) { show Validation Succes Icon ( current Text ) ; } else { show Validation Failure Icon ( validation Message ) ; } listeners . for Each ( null ) ; }
public void done With Executing Unsafe Code On Same Thread ( ) throws Security Exception , Illegal State Exception { if ( ! privileged Threads . contains ( Thread . current Thread ( ) ) ) { throw new Security Exception ( STR_ ) ; } if ( privileged Thread To Ignore == null ) { throw new Illegal State Exception ( STR_ ) ; } privileged Thread To Ignore = null ; }
protected void style Changed ( Style style ) { if ( get Length ( ) != NUM_ ) { if ( update Runnable == null ) { update Runnable = new Change Update Runnable ( ) ; } synchronized ( update Runnable ) { if ( ! update Runnable . is Pending ) { Swing Utilities . invoke Later ( update Runnable ) ; update Runnable . is Pending = true ; } } } }
protected void on Progress ( Progress Event event ) { if ( Log Configuration . logging Is Enabled ( ) ) { logger . log ( Level . INFO , messages . progress Status ( event . get Loaded ( ) , event . get Total ( ) ) ) ; } ui Handler . show Message ( messages . progress Status ( event . get Loaded ( ) , event . get Total ( ) ) ) ; fire Application Cache Event ( Cache Event . on Progress ) ; }
public boolean is Update Completed ( ) { return update Completed . get ( ) ; }
@ Override public void file Moved ( @ Not Null Virtual File Move Event event ) { process File Change ( event . get File ( ) ) ; }
public void reload ( final String svc Name ) throws Local Repository Exception { final String prefix = String . format ( STR_ , svc Name ) ; log . debug ( prefix ) ; final String [ ] cmd = { SYSTOOL CMD , SYSTOOL RELOAD , svc Name } ; final Exec . Result result = Exec . sudo ( SYSTOOL TIMEOUT , cmd ) ; check Failure ( result , prefix ) ; }
protected void install Keyboard Actions ( mx Graph Component graph Component ) { Input Map input Map = get Input Map ( J Component . WHEN ANCESTOR OF FOCUSED COMPONENT ) ; Swing Utilities . replace UI Input Map ( graph Component , J Component . WHEN ANCESTOR OF FOCUSED COMPONENT , input Map ) ; input Map = get Input Map ( J Component . WHEN FOCUSED ) ; Swing Utilities . replace UI Input Map ( graph Component , J Component . WHEN FOCUSED , input Map ) ; Swing Utilities . replace UI Action Map ( graph Component , create Action Map ( ) ) ; }
public void notify Change ( ) { execute Event ( ) ; }
public void drag ( long time , float x , float y , float delta X , float delta Y , float total X , float total Y ) { reset Resize Timeout ( false ) ; delta X = Math Utils . flip Sign If ( delta X , Localization Utils . is Layout Rtl ( ) ) ; m New Tab Button . drag ( x , y ) ; if ( m Last Pressed Close Button != null ) { if ( ! m Last Pressed Close Button . drag ( x , y ) ) m Last Pressed Close Button = null ; } if ( m In Reorder Mode ) { float accumulated Delta X = x - m Last Reorder X ; if ( Math . abs ( accumulated Delta X ) >= NUM_ ) { if ( ! Localization Utils . is Layout Rtl ( ) ) { if ( delta X >= NUM_ ) { m Reorder State |= REORDER SCROLL RIGHT ; } else if ( delta X <= - NUM_ ) { m Reorder State |= REORDER SCROLL LEFT ; } } else { if ( delta X >= NUM_ ) { m Reorder State |= REORDER SCROLL LEFT ; } else if ( delta X <= - NUM_ ) { m Reorder State |= REORDER SCROLL RIGHT ; } } m Last Reorder X = x ; update Reorder Position ( accumulated Delta X ) ; } } else if ( ! m Scroller . is Finished ( ) ) { m Scroller . set Final X ( ( int ) ( m Scroller . get Final X ( ) + delta X ) ) ; } else { float fast Expand Delta = calculate Offset To Make Tab Visible ( m Interacting Tab , true , true , true ) ; if ( m Interacting Tab != null && fast Expand Delta != NUM_ ) { if ( ( fast Expand Delta > NUM_ && delta X > NUM_ ) || ( fast Expand Delta < NUM_ && delta X < NUM_ ) ) { m Scroller . start Scroll ( m Scroll Offset , NUM_ , ( int ) fast Expand Delta , NUM_ , time , EXPAND DURATION MS ) ; } } else { update Scroll Offset Position ( ( int ) ( m Scroll Offset + delta X ) ) ; } } if ( ! m In Reorder Mode ) { final float abs Total X = Math . abs ( total X ) ; final float abs Total Y = Math . abs ( total Y ) ; if ( total Y > m Reorder Move Start Threshold && abs Total X < m Reorder Move Start Threshold * NUM_ && ( abs Total X > EPSILON && ( abs Total Y / abs Total X ) > TAN OF REORDER ANGLE START THRESHOLD ) ) { start Reorder Mode ( time , x , x - total X ) ; } } if ( ! m In Reorder Mode ) m Interacting Tab = null ; m Update Host . request Update ( ) ; }
public void enter Source ( Node Handler handler , Context context ) { Node Info curr = context . get Context Node Info ( ) ; final String path = Navigator . get Path ( curr ) ; if ( TRACE ) { trace ( indent + STR_ + path + STR_ + curr . get Line Number ( ) + STR_ + get Mode Name ( context ) + STR_ ) ; indent += STR_ ; } my Debugger . push Source ( new Saxon Source Frame ( my Debugger . get Source Frame ( ) , curr ) ) ; }
void done ( ) { elapsed Nanos . set ( System . nano Time ( ) - begin Nanos ) ; }
@ Override public int on Start Command ( Intent intent , int flags , int startid ) { log . info ( STR_ ) ; return START STICKY ; }
@ Override public Change update Config ( Equipment equipment , Properties properties ) throws Illegal Access Exception { if ( ( properties . get Property ( STR_ ) ) != null ) { throw new Configuration Exception ( Configuration Exception . INVALID PARAMETER VALUE , STR_ + STR_ ) ; } return super . update Config ( equipment , properties ) ; }
protected void cell Added ( Object cell ) { if ( cell instanceof mx I Cell ) { mx I Cell mxc = ( mx I Cell ) cell ; if ( mxc . get Id ( ) == null && is Create Ids ( ) ) { mxc . set Id ( create Id ( cell ) ) ; } if ( mxc . get Id ( ) != null ) { Object collision = get Cell ( mxc . get Id ( ) ) ; if ( collision != cell ) { while ( collision != null ) { mxc . set Id ( create Id ( cell ) ) ; collision = get Cell ( mxc . get Id ( ) ) ; } if ( cells == null ) { cells = new Hashtable < String , Object > ( ) ; } cells . put ( mxc . get Id ( ) , cell ) ; } } try { int id = Integer . parse Int ( mxc . get Id ( ) ) ; next Id = Math . max ( next Id , id + NUM_ ) ; } catch ( Number Format Exception e ) { } int child Count = mxc . get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { cell Added ( mxc . get Child At ( i ) ) ; } } }
@ Override public void on Pause ( ) { if ( Camera != null ) Camera . shutdown ( ) ; Camera = null ; if ( Snap Handler != null ) Snap Handler . shutdown ( ) ; Snap Handler = null ; super . on Pause ( ) ; }
protected void on Exception ( final Exception e ) { throw Wro Runtime Exception . wrap ( e ) ; }
public static int root ( int value ) { if ( value < NUM_ ) { Test Base . log Error ( STR_ , null ) ; } return ( int ) Math . sqrt ( value ) ; }
public void on Dependency Changed ( Preference dependency , boolean disable Dependent ) { if ( m Dependency Met == disable Dependent ) { m Dependency Met = ! disable Dependent ; notify Dependency Change ( should Disable Dependents ( ) ) ; notify Changed ( ) ; } }
protected void do Read ( Http Servlet Request request , Http Servlet Response response , String tunnel UUID ) throws Guacamole Exception { Guacamole Tunnel tunnel = get Tunnel ( tunnel UUID ) ; if ( ! tunnel . is Open ( ) ) throw new Guacamole Resource Not Found Exception ( STR_ ) ; Guacamole Reader reader = tunnel . acquire Reader ( ) ; try { response . set Content Type ( STR_ ) ; response . set Header ( STR_ , STR_ ) ; Writer out = new Buffered Writer ( new Output Stream Writer ( response . get Output Stream ( ) , STR_ ) ) ; try { char [ ] message = reader . read ( ) ; if ( message == null ) throw new Guacamole Connection Closed Exception ( STR_ ) ; do { out . write ( message , NUM_ , message . length ) ; if ( ! reader . available ( ) ) { out . flush ( ) ; response . flush Buffer ( ) ; } if ( tunnel . has Queued Reader Threads ( ) ) break ; } while ( tunnel . is Open ( ) && ( message = reader . read ( ) ) != null ) ; if ( message == null ) { deregister Tunnel ( tunnel ) ; tunnel . close ( ) ; } out . write ( STR_ ) ; out . flush ( ) ; response . flush Buffer ( ) ; } catch ( Guacamole Connection Closed Exception e ) { deregister Tunnel ( tunnel ) ; tunnel . close ( ) ; out . write ( STR_ ) ; out . flush ( ) ; response . flush Buffer ( ) ; } catch ( Guacamole Exception e ) { deregister Tunnel ( tunnel ) ; tunnel . close ( ) ; throw e ; } finally { out . close ( ) ; } } catch ( IO Exception e ) { logger . debug ( STR_ , e ) ; deregister Tunnel ( tunnel ) ; tunnel . close ( ) ; } finally { tunnel . release Reader ( ) ; } }
public boolean on Scroll Changed ( int scroll Y ) { boolean is Pulling Down Now = scroll Y < last Scroll Y ; latest Pulling Down . offer ( is Pulling Down Now ) ; if ( latest Pulling Down . size ( ) > PULLING DOWN TIME MAX ) { latest Pulling Down . poll ( ) ; } last Scroll Y = scroll Y ; return get Pulling Down Time ( ) >= PULLING DOWN TIME THRESHOLD ; }
public boolean contains ( @ Non Null T item ) { return item != null && m Items != null && m Items . contains ( item ) ; }
private void slider Direction State Changed ( ) { direction = direction Slider . get Value ( ) ; outfit Label . changed ( ) ; hair Label . changed ( ) ; if ( Testing . OUTFITS ) { eyes Label . changed ( ) ; } head Label . changed ( ) ; body Label . changed ( ) ; dress Label . changed ( ) ; }
@ Provides @ Singleton @ Inject public Configuration provide Freemarker ( Data Dir datadir ) { Configuration fm = new Configuration ( ) ; List < Template Loader > t Loader = new Array List < Template Loader > ( ) ; t Loader . add ( new Class Template Loader ( App Config . class , STR_ ) ) ; try { Template Loader tl Data Dir = new Data Dir Template Loader ( datadir . data File ( STR_ ) ) ; t Loader . add ( tl Data Dir ) ; } catch ( IO Exception e ) { LOG . warn ( STR_ + e . get Message ( ) , e ) ; } Template Loader tl = new Multi Template Loader ( t Loader . to Array ( new Template Loader [ t Loader . size ( ) ] ) ) ; fm . set Default Encoding ( STR_ ) ; fm . set Template Loader ( tl ) ; return fm ; }
protected void check Invalid Options Infer Signatures ( ) { if ( checker . use Unchecked Code Default ( STR_ ) || checker . use Unchecked Code Default ( STR_ ) ) { Error Reporter . error Abort ( STR_ + STR_ ) ; } }
public Navigator on Settled ( On Settled on Settled ) { this . on Settled = on Settled ; return this ; }
private Class ( RVM Type type ) { this . type = type ; }
public static void wait ( Object lock ) { try { synchronized ( lock ) { lock . wait ( ) ; } } catch ( Interrupted Exception e ) { } }
private Finished ( byte [ ] verify Data , Inet Socket Address peer Address ) { super ( peer Address ) ; this . verify Data = Arrays . copy Of ( verify Data , verify Data . length ) ; }
public void on Drawer Closed ( View view ) { super . on Drawer Closed ( view ) ; update Action Bar Title And Home Button ( null ) ; invalidate Options Menu ( ) ; }
private void fill After ( final Canvas canvas ) { if ( svg Resource Id != NUM_ && fill After && Math . abs ( progress - NUM_ ) < NUM_ ) { svg Utils . draw Svg After ( canvas , width , height ) ; } }
void update GUI ( ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + msg Count + STR_ + ( pdi File . length ( ) / msg Size ) ) ; } if ( ! init ) { return ; } status . set Text ( res . get String ( STR_ ) ) ; msg Count ++ ; bar . set Value ( NUM_ * msg Count * msg Size / pdi File . length ( ) ) ; }
public void send Request ( @ Method Def int method , String url Pattern , List < Pairs . Pair > pairs , Api Params body Params , Volley Util . Http Callback callback ) { Volley Util . send Request ( method - NUM_ , Restful Helper . build Restful Url ( url Pattern , pairs ) , body Params , this , callback ) ; }
private boolean on Tap ( float raw X , float raw Y ) { Barcode barcode = null ; if ( m Mode == MV Barcode Scanner . Scanning Mode . SINGLE AUTO ) { Barcode Graphic graphic = m Graphic Overlay . get First Graphic ( ) ; if ( graphic != null ) { barcode = graphic . get Barcode ( ) ; if ( barcode != null && m Listener != null ) { m Listener . on Barcode Scanned ( barcode ) ; } } } else if ( m Mode == MV Barcode Scanner . Scanning Mode . SINGLE MANUAL ) { Set < Barcode Graphic > graphic Set = m Graphic Overlay . get All Graphics ( ) ; if ( graphic Set != null && ! graphic Set . is Empty ( ) ) { for ( Barcode Graphic graphic : graphic Set ) { if ( graphic != null && graphic . is Point Inside Barcode ( raw X , raw Y ) ) { barcode = graphic . get Barcode ( ) ; break ; } } if ( m Listener != null ) { m Listener . on Barcode Scanned ( barcode ) ; } } } else { Set < Barcode Graphic > graphic Set = m Graphic Overlay . get All Graphics ( ) ; if ( graphic Set != null && ! graphic Set . is Empty ( ) ) { List < Barcode > barcodes = new Array List < > ( ) ; for ( Barcode Graphic graphic : graphic Set ) { if ( graphic != null ) { barcode = graphic . get Barcode ( ) ; if ( barcode != null ) barcodes . add ( barcode ) ; } } if ( m Listener != null ) { m Listener . on Barcodes Scanned ( barcodes ) ; } } } return barcode != null ; }
public void update ( ) { matrix . remove All ( ) ; List < System Connection Memo > conn List = Instance Manager . get List ( System Connection Memo . class ) ; if ( ! conn List . is Empty ( ) ) { log . debug ( STR_ , conn List . size ( ) ) ; reload Connections ( conn List ) ; } else { log . debug ( STR_ ) ; matrix . add ( new J Label ( STR_ ) ) ; } }
@ Override public void on Request Error ( int code , String message ) { if ( code == Connect API . LOGIN CODE ) { email Layout . set Error ( STR_ ) ; request Focus ( email ) ; password Layout . set Error ( STR_ ) ; request Focus ( password ) ; signin . set Text ( STR_ ) ; signin . set Clickable ( true ) ; } }
private void user Selected A Date ( Local Date selected Date ) { if ( settings == null ) { return ; } if ( selected Date != null ) { Date Veto Policy veto Policy = settings . get Veto Policy ( ) ; if ( Internal Utilities . is Date Vetoed ( veto Policy , selected Date ) ) { return ; } } if ( selected Date != null ) { Year Month selected Date Year Month = Year Month . from ( selected Date ) ; displayed Year Month = selected Date Year Month ; } else { displayed Year Month = Year Month . now ( ) ; } z Internal Change Selected Date Procedure ( selected Date ) ; if ( settings . get Parent Date Picker ( ) != null ) { Date Picker parent = settings . get Parent Date Picker ( ) ; parent . set Date ( selected Date ) ; parent . close Popup ( ) ; } }
public static final void stop Stale Reference Cleaner ( ) { cleaner Service . shutdown Now ( ) ; }
public void dispose ( ) { set Layer Removal Delayed ( false ) ; if ( projection Support != null ) { projection Support . dispose ( ) ; projection Support = null ; } if ( painters != null ) { painters . clear ( ) ; painters = null ; } if ( added Layers != null ) { added Layers . remove All Elements ( ) ; added Layers = null ; } current Layers = null ; projection Factory = null ; remove Component Listener ( this ) ; remove Container Listener ( this ) ; remove All ( ) ; purge And Notify Removed Layers ( ) ; }
public static Text Node value Of ( String v ) { if ( v == null ) { return null ; } if ( v . length ( ) == NUM_ ) { return EMPTY STRING NODE ; } return new Text Node ( v ) ; }
boolean compute Angle Offset ( ) { if ( m Finished ) { return false ; } long system Clock = Animation Utils . current Animation Time Millis ( ) ; long time Passed = system Clock - m Start Millis ; if ( time Passed < m Duration Millis ) { switch ( m Mode ) { case SCROLL MODE : float sc = ( float ) time Passed / m Duration Millis ; m Curr Angle Deg = m Start Angle Deg + Math . round ( m Delta Angle Deg * sc ) ; break ; case FLING MODE : float time Passed Seconds = time Passed / NUM_ ; float distance = m Coeff Velocity * m Velocity * time Passed Seconds - ( DECELERATION * time Passed Seconds * time Passed Seconds / NUM_ ) ; m Curr Angle Deg = m Start Angle Deg + Math . round ( distance ) ; break ; } return true ; } else { m Finished = true ; return false ; } }
protected void progress ( double pct , int blocks So Far , Date date ) { log . info ( String . format ( Locale . US , STR_ , ( int ) pct , blocks So Far , Utils . date Time Format ( date ) ) ) ; }
public boolean mouse Clicked ( Mouse Event e ) { if ( selected Graphic != null && ! show plot ) { switch ( e . get Click Count ( ) ) { case NUM_ : add Selection To Plot List ( ) ; generate Plot ( ) ; repaint ( ) ; break ; case NUM_ : repaint ( ) ; break ; default : break ; } return true ; } else { return false ; } }
public void begin Display ( Display Event event ) throws Model Control Exception { if ( ad != null ) { try { String cookie Domain = null ; Set < String > cookie Domain Set = Auth Client Utils . get Cookie Domains For Request ( request ) ; Cookie cookie ; set Page Encoding ( request , response ) ; if ( cookie Domain Set . is Empty ( ) ) { cookie = Auth Utils . get Logout Cookie ( ac , null ) ; response . add Cookie ( cookie ) ; } else { Iterator iter = cookie Domain Set . iterator ( ) ; while ( iter . has Next ( ) ) { cookie Domain = ( String ) iter . next ( ) ; cookie = Auth Utils . get Logout Cookie ( ac , cookie Domain ) ; response . add Cookie ( cookie ) ; } } Auth Utils . clearlb Cookie ( request , response ) ; Result Val = rb . get String ( STR_ ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; if ( ex Debug . message Enabled ( ) ) { ex Debug . message ( STR_ + e . get Message ( ) ) ; } Result Val = rb . get String ( STR_ ) + STR_ + e . get Message ( ) ; } } }
@ Override public void fire ( Connection conn , Object [ ] old Row , Object [ ] new Row ) throws SQL Exception { Big Decimal diff = null ; if ( new Row != null ) { diff = ( Big Decimal ) new Row [ NUM_ ] ; } if ( old Row != null ) { Big Decimal m = ( Big Decimal ) old Row [ NUM_ ] ; diff = diff == null ? m . negate ( ) : diff . subtract ( m ) ; } Prepared Statement prep = conn . prepare Statement ( STR_ ) ; prep . set Big Decimal ( NUM_ , diff ) ; prep . execute ( ) ; }
protected void reset Palette ( ) { java . awt . Container pal = get Palette ( ) ; boolean put Up = false ; if ( pal != null && pal . is Visible ( ) ) { put Up = true ; set Palette Visible ( false ) ; } if ( put Up ) { set Palette Visible ( true ) ; } }
@ Override public boolean on Preference Start Fragment ( Preference Fragment caller , Preference pref ) { show Timezone Picker ( R . id . timezone dropdown anchor ) ; return true ; }
void did Start ( final Callable task ) { nstarted . increment And Get ( ) ; if ( INFO ) log . info ( STR_ + nstarted ) ; }
public final synchronized boolean close When Possible ( ) throws IO Exception { do Close . set ( true ) ; if ( reading Count . get ( ) == NUM_ ) { close ( ) ; } return closed . get ( ) ; }
public Encrypted Editor put Long ( String key , long value ) { put Value ( key , String . value Of ( value ) ) ; return this ; }
@ Called By Native public void sync State Changed ( ) { if ( ! m Listeners . is Empty ( ) ) { for ( Sync State Changed Listener listener : m Listeners ) { listener . sync State Changed ( ) ; } } }
@ Override public void property Change ( Property Change Event evt ) { update Text ( ) ; }
@ Override public void connection Change ( Connection Event evt ) { m Connected = evt . is Connected ( ) ; m Db Utils = evt . get Db Utils ( ) ; set Buttons ( ) ; }
public void on Failure ( int status Code , Header [ ] headers , byte [ ] response Body , Throwable error ) { try { String response = response Body == null ? null : new String ( response Body , get Charset ( ) ) ; on Failure ( status Code , headers , error , response ) ; } catch ( Unsupported Encoding Exception e ) { Log . e ( LOG TAG , e . to String ( ) ) ; on Failure ( status Code , headers , e , null ) ; } }
public static void wait ( Object lock , long timeout ) { try { synchronized ( lock ) { lock . wait ( timeout ) ; } } catch ( Interrupted Exception e ) { } }
@ Button ( list = STR_ , key = STR_ , order = NUM_ , type = Button . TYPE PRIMARY ) @ Requires Permissions ( permissions = PERMISSION EDIT ) public Resolution bulk Update ( ) { int updated = NUM_ ; setup Form ( Mode . BULK EDIT ) ; disable Blob Fields ( ) ; form . read From Request ( context . get Request ( ) ) ; if ( form . validate ( ) ) { for ( String current : selection ) { load Object ( current . split ( STR_ ) ) ; edit Setup ( object ) ; write Form To Object ( ) ; if ( edit Validate ( object ) ) { do Update ( object ) ; edit Post Process ( object ) ; updated ++ ; } } try { commit Transaction ( ) ; } catch ( Throwable e ) { String root Cause Message = Exception Utils . get Root Cause Message ( e ) ; logger . warn ( root Cause Message , e ) ; Session Messages . add Error Message ( root Cause Message ) ; return get Bulk Edit View ( ) ; } Session Messages . add Info Message ( Elements Thread Locals . get Text ( STR_ , updated ) ) ; return get Successful Update View ( ) ; } else { return get Bulk Edit View ( ) ; } }
private byte post Decryption ( Cipher State state , Byte Buffer in Byte Buffer , long position , byte [ ] iv ) throws IO Exception { byte padding = NUM_ ; if ( state . is Reset ( ) ) { reset Cipher ( state , position , iv ) ; padding = get Padding ( position ) ; in Byte Buffer . position ( padding ) ; } return padding ; }
public void display Changed ( ) { if ( ! is Acceleration Enabled ( ) ) { return ; } lost Surface = true ; if ( sd Accel != null ) { sd Backup = null ; Surface Data old Data = sd Accel ; sd Accel = null ; old Data . invalidate ( ) ; sd Current = get Backup Surface ( ) ; } v Img . update Graphics Config ( ) ; }
public void write Job Data File ( String version ) throws Exception { Object obj = get Target Object ( ) ; File Output Stream fos = new File Output Stream ( get Serialized File Name ( version , obj . get Class ( ) ) ) ; Object Output Stream oos = new Object Output Stream ( fos ) ; oos . write Object ( obj ) ; oos . flush ( ) ; fos . close ( ) ; oos . close ( ) ; }
public void save New Post ( Post post ) { post Repository . save ( post ) ; Post Search Service . index ( post ) ; if ( post . get Status ( ) == Post Status . PUBLIC ) { hot Post Service . add Hot Post ( post ) ; hot Post Service . add Tagged Post ( post , post . get Tags ( ) ) ; new Posts Service . add ( post ) ; new Posts Service . add Tagged Post ( post , post . get Tags ( ) ) ; counting Service . inc Public Posts Count ( ) ; } counting Service . inc Posts Count ( ) ; }
public void add Translator ( Class Pool cp , Translator t ) throws Not Found Exception , Cannot Compile Exception { class Pool = cp ; translator = t ; t . start ( class Pool ) ; }
public void push ( Bitmap bitmap ) throws Interrupted Exception { check Not Main Thread ( ) ; pending . put ( bitmap ) ; ensure Scheduled ( ) ; }
public Xing Api add Auth Error Callback ( Auth Error Callback error Callback ) { auth Error Callbacks . add ( error Callback ) ; return this ; }
@ Override public void mouse Clicked ( Mouse Event e ) { int col ; boolean popup ; col = m Table Data . column At Point ( e . get Point ( ) ) ; popup = ( ( e . get Button ( ) == Mouse Event . BUTTON 3 ) && ( e . get Click Count ( ) == NUM_ ) ) || ( ( e . get Button ( ) == Mouse Event . BUTTON 1 ) && ( e . get Click Count ( ) == NUM_ ) && e . is Alt Down ( ) && ! e . is Control Down ( ) && ! e . is Shift Down ( ) ) ; popup = popup && ( get Instances ( ) != null ) ; if ( e . get Source ( ) == m Table Data . get Table Header ( ) ) { m Current Col = col ; if ( popup ) { e . consume ( ) ; set Menu ( ) ; init Popup Menus ( ) ; m Popup Header . show ( e . get Component ( ) , e . get X ( ) , e . get Y ( ) ) ; } } else if ( e . get Source ( ) == m Table Data ) { if ( popup ) { e . consume ( ) ; set Menu ( ) ; init Popup Menus ( ) ; m Popup Rows . show ( e . get Component ( ) , e . get X ( ) , e . get Y ( ) ) ; } } if ( ( e . get Button ( ) == Mouse Event . BUTTON 1 ) && ( e . get Click Count ( ) == NUM_ ) && ( ! e . is Alt Down ( ) ) && ( col > - NUM_ ) ) { m Table Data . set Selected Column ( col ) ; } }
public void add To Cleanup ( Runnable task ) { cleanup . add ( task ) ; }
public void on Fail ( ) { last Fail Time = Current Time . current Time ( ) ; if ( first Fail Time == NUM_ ) { first Fail Time = last Fail Time ; } first Success Time = NUM_ ; to State ( State . FAIL ) ; long recover Timeout = dynamic Recover Timeout . get ( ) ; long next Recover Timeout = Math . min ( recover Timeout + NUM_ , recover Timeout ) ; dynamic Recover Timeout . compare And Set ( recover Timeout , next Recover Timeout ) ; }
public void handle Window Focus Event ( boolean parent Window Active ) { this . parent Window Active = parent Window Active ; synchronized ( class Lock ) { if ( ! parent Window Active ) { this . browser Window Focused Applet = global Focused Window ; } if ( parent Window Active && global Focused Window != this && is Parent Window Changed ( ) ) { global Focused Window = ( this . browser Window Focused Applet != null ) ? this . browser Window Focused Applet : this ; } } if ( global Focused Window == this && parent Window Active ) { responder . handle Window Focus Event ( parent Window Active , null ) ; } }
public void lock UI ( Process Info pi ) { if ( m is Lock ) return ; m is Lock = true ; Clients . show Busy ( null , true ) ; }
public void leave ( Node Info element , Context context ) { if ( element . get Node Type ( ) == Node Info . ELEMENT ) { my Debugger . leave ( ) ; if ( TRACE ) { indent = indent . substring ( NUM_ , indent . length ( ) - NUM_ ) ; trace ( indent + STR_ + element . get Display Name ( ) + STR_ ) ; } } }
@ Override public void on Destroy ( ) { synchronized ( m Thread ) { m Ready = false ; m Quiting = true ; m Thread . notify ( ) ; } super . on Destroy ( ) ; }
public Encrypted Editor put Boolean ( String key , boolean value ) { put Value ( key , String . value Of ( value ) ) ; return this ; }
private void on Pause ( ) { m Subscription . unsubscribe ( ) ; m Dispatched Observables History . clear ( ) ; }
public synchronized void remove Action Listener ( Action Listener listener ) { action Listeners . remove Element ( listener ) ; }
private URL Util ( ) { super ( ) ; }
protected void cancel ( ) { clear Images ( ) ; if ( callbacks != null ) { for ( Guided Tour Life Cycle guided Tour Life Cycle : callbacks ) { guided Tour Life Cycle . end ( ) ; } } }
public void end ( String namespace , String name ) { UI Component uic = ( UI Component ) digester . peek ( ) ; if ( uic instanceof UI Form ) { root = ( UI Component ) digester . peek ( digester . get Count ( ) - NUM_ ) ; } }
@ After public final void verify Mocks ( ) { if ( ! mocks . is Empty ( ) || ! mock Controls . is Empty ( ) ) { assert True ( STR_ + STR_ , mocks Replayed ) ; if ( use Power Mock ) { Power Mock . verify All ( ) ; } else { Easy Mock . verify ( mocks . to Array ( ) ) ; } for ( I Mocks Control mock Control : mock Controls ) { mock Control . verify ( ) ; } } }
public boolean on Long Click ( int position ) { if ( m Mode == MODE SINGLE SELECT ) { m Selected Items . add ( position ) ; notify Selection Changed ( position ) ; set Mode ( MODE MULTIPLE SELECT ) ; return true ; } return false ; }
void on Access Points Updated ( Preference Screen preference Screen , Collection < Access Point > access Points ) { if ( m Progress Bar . is Indeterminate ( ) && access Points . size ( ) > NUM_ ) { show Disconnected Progress Bar ( ) ; if ( m Screen State == SCREEN STATE DISCONNECTED ) { m Wifi Settings Fragment Layout . set Visibility ( View . VISIBLE ) ; m Bottom Padding . set Visibility ( View . GONE ) ; } m Add Network Button . set Enabled ( true ) ; m Refresh Button . set Enabled ( true ) ; } for ( Access Point access Point : access Points ) { access Point . set Layout Resource ( R . layout . custom preference ) ; preference Screen . add Preference ( access Point ) ; } }
@ Override public void on Message ( Context context , Intent intent ) { String id = intent . get String Extra ( STR_ ) ; String operation = intent . get String Extra ( STR_ ) ; String email Address = intent . get String Extra ( STR_ ) ; Log . i ( Cloud Notes Activity . TAG , STR_ + id + STR_ + operation + STR_ + email Address ) ; Note Application app = ( Note Application ) get Application ( ) ; if ( email Address . equals ( app . get Email Address ( ) ) ) { app . notify Listener ( id , operation ) ; } }
public void begin ( Attributes attributes ) throws Exception { UI Component uic = ( UI Component ) digester . peek ( ) ; Attributes Impl attrs = new Attributes Impl ( attributes ) ; for ( int i = NUM_ ; i < attrs . get Length ( ) ; i ++ ) { String q Name = attributes . get Q Name ( i ) ; attrs . set Local Name ( i , q Name ) ; attrs . set Value ( i , attributes . get Value ( q Name ) ) ; } bc . handle Nested Component Tag ( uic , STR_ , attrs ) ; }
@ Override public boolean perform Finish ( ) { Driver Descriptor driver = get Selected Driver ( ) ; Connection Page Settings page Settings = get Page Settings ( ) ; Data Source Descriptor data Source Tpl = page Settings == null ? get Active Data Source ( ) : page Settings . get Active Data Source ( ) ; DBP Data Source Registry data Source Registry = get Data Source Registry ( ) ; Data Source Descriptor data Source New = new Data Source Descriptor ( data Source Registry , data Source Tpl . get Id ( ) , driver , data Source Tpl . get Connection Configuration ( ) ) ; data Source New . copy From ( data Source Tpl ) ; save Settings ( data Source New ) ; data Source Registry . add Data Source ( data Source New ) ; return true ; }
public void update Screen ( ) { super . update Screen ( ) ; ++ this . field 146444 f ; }
@ Override public void delete ( ) { if ( ! deleted ) { deleted = true ; commits To Delete . add ( this ) ; } }
public void register Fm Radio Listener ( Fm Radio Listener callback ) { synchronized ( m Records ) { Record record = null ; int hash Code = callback . hash Code ( ) ; final int n = m Records . size ( ) ; for ( int i = NUM_ ; i < n ; i ++ ) { record = m Records . get ( i ) ; if ( hash Code == record . m Hash Code ) { return ; } } record = new Record ( ) ; record . m Hash Code = hash Code ; record . m Callback = callback ; m Records . add ( record ) ; } }
public void begin Display ( Display Event event ) throws Model Control Exception { set Page Encoding ( request , response ) ; Call Back Tiled View t View = ( Call Back Tiled View ) get Child ( TILED CALLBACKS ) ; t View . set Call Back Array ( callbacks , required List , info Text ) ; if ( rb != null ) { if ( new Org ) { button Options = new String [ NUM_ ] ; button Options [ NUM_ ] = rb . get String ( STR_ ) ; button Options [ NUM_ ] = rb . get String ( STR_ ) ; } set Display Field Value ( TXT GOTO LOGIN AFTER FAIL , rb . get String ( STR_ ) ) ; set Display Field Value ( CMD SUBMIT , STR_ ) ; if ( ( req Data Hash . get ( STR_ ) != null ) || ( req Data Hash . get ( Constants . COMPOSITE ADVICE ) != null ) ) { set Display Field Value ( LBL SUBMIT , rb . get String ( STR_ ) ) ; } else { set Display Field Value ( LBL SUBMIT , rb . get String ( STR_ ) ) ; } set Display Field Value ( CMD CONTINUE , STR_ ) ; set Display Field Value ( LBL CONTINUE , rb . get String ( STR_ ) ) ; set Display Field Value ( CMD AGREE , STR_ ) ; set Display Field Value ( LBL AGREE , rb . get String ( STR_ ) ) ; set Display Field Value ( CMD DISAGREE , STR_ ) ; set Display Field Value ( LBL DISAGREE , rb . get String ( STR_ ) ) ; set Display Field Value ( CMD YES , STR_ ) ; set Display Field Value ( LBL YES , rb . get String ( STR_ ) ) ; set Display Field Value ( CMD NO , STR_ ) ; set Display Field Value ( LBL NO , rb . get String ( STR_ ) ) ; set Display Field Value ( CMD NEW USER , STR_ ) ; set Display Field Value ( LBL NEW USER , rb . get String ( STR_ ) ) ; set Display Field Value ( LBL RESET , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE LOGIN , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE MESSAGE , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE REDIRECT , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE ACCOUNTEXPIRED , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE AUTHERROR , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE SELFREGERROR , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE DISCLAIMER , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE INVALIDPASSWORD , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE INVALIDDOMAIN , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE USERPROFILENOTFOUND , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE AUTHFAILED , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE MEMBERSHIP , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE AUTHMODULEDENIED , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE NOCONFIGERROR , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE ORGINACTIVE , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE SELFREGMODULE , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE SESSIONTIMEOUT , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE USERNOTFOUND , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE USERINACTIVE , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE NEWORG , rb . get String ( STR_ ) ) ; set Display Field Value ( HTML TITLE MAXSESSIONS , rb . get String ( STR_ ) ) ; } else { login Debug . message ( STR_ ) ; } Button Tiled View t Btn View = ( Button Tiled View ) get Child ( TILED BUTTONS ) ; t Btn View . set Button Array ( button Options ) ; if ( ( button Options != null ) && ( button Options . length > NUM_ ) ) { set Display Field Value ( DEFAULT BTN , button Options [ NUM_ ] ) ; } set Display Field Value ( REDIRECT URL , redirect url ) ; }
public String apply ( Instance inst ) { for ( int i = NUM_ ; i < m selected Atts . length ; i ++ ) { if ( ! inst . is Missing ( m selected Atts [ i ] ) ) { String value = inst . string Value ( m selected Atts [ i ] ) ; String result = apply ( value ) ; if ( result != null ) { return result ; } } } return null ; }
public boolean on Back Pressed ( ) { if ( does Drawer Exist ( ) ) { if ( m Drawer . is Drawer Visible ( Gravity . START ) ) { m Drawer . close Drawer ( Gravity . START ) ; return true ; } } if ( m Content View . on Back Pressed ( ) ) return true ; if ( ! m State Stack . empty ( ) ) { m State Stack . pop ( ) ; if ( ! m State Stack . empty ( ) ) { set State ( m State Stack . pop ( ) ) ; return true ; } } return false ; }
public void after Connection Established ( Web Socket Session session ) { logger . debug ( STR_ , session ) ; }
private void build Contact Data ( ) { Context context = get Application Context ( ) ; App Contact Service app Contact Service = new App Contact Service ( context ) ; if ( ! app Contact Service . is Contact Exists ( STR_ ) ) { List < Contact > contact List = new Array List < Contact > ( ) ; Contact contact = new Contact ( ) ; contact . set User Id ( STR_ ) ; contact . set Full Name ( STR_ ) ; contact . set Image URL ( STR_ ) ; contact List . add ( contact ) ; Contact contact Raj = new Contact ( ) ; contact Raj . set User Id ( STR_ ) ; contact Raj . set Full Name ( STR_ ) ; contact Raj . set Image URL ( STR_ ) ; contact List . add ( contact Raj ) ; Contact contact 2 = new Contact ( ) ; contact 2 . set User Id ( STR_ ) ; contact 2 . set Full Name ( STR_ ) ; contact 2 . set Image URL ( STR_ ) ; contact List . add ( contact 2 ) ; Contact contact 3 = new Contact ( ) ; contact 3 . set User Id ( STR_ ) ; contact 3 . set Full Name ( STR_ ) ; contact 3 . set Image URL ( STR_ ) ; contact List . add ( contact 3 ) ; Contact contact 4 = new Contact ( ) ; contact 4 . set User Id ( STR_ ) ; contact 4 . set Full Name ( STR_ ) ; contact 4 . set Image URL ( STR_ ) ; contact List . add ( contact 4 ) ; Contact contact 6 = new Contact ( ) ; contact 6 . set User Id ( STR_ ) ; contact 6 . set Full Name ( STR_ ) ; contact 6 . set Image URL ( STR_ ) ; contact List . add ( contact 6 ) ; Contact contact 7 = new Contact ( ) ; contact 7 . set User Id ( STR_ ) ; contact 7 . set Full Name ( STR_ ) ; contact 7 . set Image URL ( STR_ ) ; contact List . add ( contact 7 ) ; app Contact Service . add All ( contact List ) ; } }
@ Subscribe public synchronized void on Socket Preview Changed ( Socket Preview Changed Event event ) { final Output Socket < ? > socket = event . get Socket ( ) ; Platform Impl . run And Wait ( null ) ; }
public static Result Set result Set With Null ( Connection conn ) throws SQL Exception { Prepared Statement statement = conn . prepare Statement ( STR_ ) ; return statement . execute Query ( ) ; }
public static void main ( String ... args ) throws Exception { Class . for Name ( STR_ ) ; Delete Db Files . execute ( STR_ , STR_ , true ) ; String url = STR_ ; initial Insert ( url , NUM_ ) ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { create As Select ( url , true ) ; create As Select ( url , false ) ; } }
@ Override public int put ( long key ) { long primary Hash Value = primary Hash Function ( key ) ; int bucket = ( int ) ( primary Hash Value & bit Mask ) ; long current Key = array . get ( bucket ) ; if ( current Key == default Get Return Value ) { if ( is At Capacity ( ) ) { throw new Runtime Exception ( STR_ ) ; } array . set ( bucket , key ) ; size . get And Increment ( ) ; num Stored Keys Counter . incr ( ) ; return bucket ; } else if ( current Key == key ) { return bucket ; } int secondary Hash Key = secondary Hash Function ( key , bit Mask ) ; do { bucket = ( int ) ( ( ( long ) bucket + secondary Hash Key ) & bit Mask ) ; current Key = array . get ( bucket ) ; } while ( ( current Key != default Get Return Value ) && ( current Key != key ) ) ; if ( current Key == default Get Return Value ) { if ( is At Capacity ( ) ) { throw new Runtime Exception ( STR_ ) ; } array . set ( bucket , key ) ; size . get And Increment ( ) ; num Stored Keys Counter . incr ( ) ; return bucket ; } else { return bucket ; } }
@ Override public List < byte [ ] > read ( long start Offset ) throws IO Exception { List < Carbon Dictionary Column Meta Chunk > carbon Dictionary Column Meta Chunks = read Dictionary Metadata File ( ) ; Carbon Dictionary Column Meta Chunk carbon Dictionary Column Meta Chunk = carbon Dictionary Column Meta Chunks . get ( carbon Dictionary Column Meta Chunks . size ( ) - NUM_ ) ; long end Offset = carbon Dictionary Column Meta Chunk . get End offset ( ) ; List < Column Dictionary Chunk > column Dictionary Chunks = read ( carbon Dictionary Column Meta Chunks , start Offset , end Offset ) ; return get Dictionary List ( column Dictionary Chunks ) ; }
private synchronized void handle Watchdog ( ) { final int exit Code ; if ( watchdog == null ) return ; if ( watchdog Timeout == NUM_ ) return ; if ( ! is Running ( ) ) { exit Code = On Command Result Listener . SHELL DIED ; Debug . log ( String . format ( STR_ , shell . to Upper Case ( Locale . ENGLISH ) ) ) ; } else if ( watchdog Count ++ < watchdog Timeout ) { return ; } else { exit Code = On Command Result Listener . WATCHDOG EXIT ; Debug . log ( String . format ( STR_ , shell . to Upper Case ( Locale . ENGLISH ) ) ) ; } if ( handler != null ) { post Callback ( command , exit Code , buffer ) ; } command = null ; buffer = null ; idle = true ; watchdog . shutdown ( ) ; watchdog = null ; kill ( ) ; }
private void process Tracker State Change ( Tracker tracker , O Block block , int state ) { List < O Block > old Range = tracker . get Range ( ) ; switch ( tracker . move ( block , state ) ) { case Tracker . NO BLOCK : adjust Block Listeners ( old Range , tracker . get Range ( ) , tracker ) ; String msg = Bundle . get Message ( STR_ , tracker . get Train Name ( ) , block . get Display Name ( ) ) + STR_ + Bundle . get Message ( STR_ ) ; J Option Pane . show Message Dialog ( this , msg , Bundle . get Message ( STR_ ) , J Option Pane . WARNING MESSAGE ) ; stop Train ( tracker ) ; set Status ( msg ) ; break ; case Tracker . ENTER BLOCK : block . entry Time = System . current Time Millis ( ) ; adjust Block Listeners ( old Range , tracker . get Range ( ) , tracker ) ; set Status ( Bundle . get Message ( STR_ , tracker . get Train Name ( ) , block . get Display Name ( ) ) ) ; break ; case Tracker . LEAVE BLOCK : adjust Block Listeners ( old Range , tracker . get Range ( ) , tracker ) ; long et = ( System . current Time Millis ( ) - block . entry Time ) / NUM_ ; set Status ( Bundle . get Message ( STR_ , tracker . get Train Name ( ) , block . get Display Name ( ) , et / NUM_ , et % NUM_ ) ) ; break ; case Tracker . ERROR BLOCK : break ; } }
public void load Icon Callback ( byte [ ] data , int width , int height , int row Stride , int bps , int channels , boolean alpha ) { tmp Image = null ; Data Buffer data Buf = new Data Buffer Byte ( data , ( row Stride * height ) ) ; Writable Raster raster = Raster . create Interleaved Raster ( data Buf , width , height , row Stride , channels , ( alpha ? BAND OFFSETS ALPHA : BAND OFFSETS ) , null ) ; Color Model color Model = new Component Color Model ( Color Space . get Instance ( Color Space . CS s RGB ) , alpha , false , Color Model . TRANSLUCENT , Data Buffer . TYPE BYTE ) ; tmp Image = new Buffered Image ( color Model , raster , false , null ) ; }
public Api Response handle Api View ( String name , JSON Object params ) throws Api Exception { throw new Api Exception ( Api Exception . Type . BAD VIEW , name ) ; }
@ Override public boolean equals ( Object compare Key ) { return ( compare Key instanceof Mon Key Imp && summary Label . equals ( ( ( Mon Key Imp ) compare Key ) . summary Label ) && units . equals ( ( ( Mon Key Imp ) compare Key ) . units ) ) ; }
private void write String ( char [ ] text , int offset , int len ) throws IO Exception , Json Generation Exception { len += offset ; final int [ ] esc Codes = Char Types . get Output Escapes ( ) ; final int esc Len = esc Codes . length ; while ( offset < len ) { int start = offset ; while ( true ) { char c = text [ offset ] ; if ( c < esc Len && esc Codes [ c ] != NUM_ ) { break ; } if ( ++ offset >= len ) { break ; } } int new Amount = offset - start ; if ( new Amount < SHORT WRITE ) { if ( ( output Tail + new Amount ) > output End ) { flush Buffer ( ) ; } if ( new Amount > NUM_ ) { System . arraycopy ( text , start , output Buffer , output Tail , new Amount ) ; output Tail += new Amount ; } } else { flush Buffer ( ) ; writer . write ( text , start , new Amount ) ; } if ( offset >= len ) { break ; } int esc Code = esc Codes [ text [ offset ] ] ; ++ offset ; int need Len = ( esc Code < NUM_ ) ? NUM_ : NUM_ ; if ( ( output Tail + need Len ) > output End ) { flush Buffer ( ) ; } append Single Escape ( esc Code , output Buffer , output Tail ) ; output Tail += need Len ; } }
public void done ( ) { if ( result Number == ( end + NUM_ ) ) { get Previous And Next Links For Pagination ( start != NUM_ , true , request And Response , result ) ; } else if ( start == NUM_ && ! any Matches ) { result . append ( no Matches Text ) ; } else if ( start != NUM_ && ! any Matches ) { result . append ( servlet Text . sentence No More Results ( ) ) ; } else if ( start != NUM_ ) { get Previous And Next Links For Pagination ( true , false , request And Response , result ) ; } }
@ Suppress Warnings ( STR_ ) private void rebalance Load Across EC With Affinity ( List < Jetstream Topic > topics , Long affinity Key ) { Iterator < Jetstream Topic > itr = topics . iterator ( ) ; while ( itr . has Next ( ) ) { Jetstream Topic topic = itr . next ( ) ; if ( m event Topic Registry . contains Key ( topic ) ) { Array List < Linked List < Selection > > weightedeclist = m event Topic Registry . get ( topic ) ; Iterator < Linked List < Selection > > weightedeclistitr = weightedeclist . iterator ( ) ; while ( weightedeclistitr . has Next ( ) ) { Linked List < Selection > eclist = weightedeclistitr . next ( ) ; Iterator < Selection > eclistitr = eclist . iterator ( ) ; while ( eclistitr . has Next ( ) ) { Event Consumer Info info = ( Event Consumer Info ) eclistitr . next ( ) ; if ( info == null ) continue ; if ( info . contains Multiple Affinity Key Bindings ( ) ) { if ( ! info . is Affinity Key Bound ( affinity Key ) ) continue ; info . unbind Affinity Key ( affinity Key ) ; Map < Channel , Consumer Channel Context > context Map = info . get Consumer Channel Contexts ( ) ; Collection < Consumer Channel Context > consumer Contexts = context Map . values ( ) ; for ( Consumer Channel Context channel Context : consumer Contexts ) { List < Long > affinity Key List = ( List < Long > ) channel Context . get Attribute ( STR_ ) ; print Info ( STR_ + affinity Key . long Value ( ) ) ; affinity Key List . remove ( affinity Key ) ; } } } } } } }
public void find And Undo ( Object some Obj ) { super . find And Undo ( some Obj ) ; if ( some Obj instanceof Time Bounds Provider ) { remove Time Bounds Provider ( ( Time Bounds Provider ) some Obj ) ; } }
public static void safe Invoke Later ( Runnable runnable ) { if ( Event Queue . is Dispatch Thread ( ) ) runnable . run ( ) ; else Swing Utilities . invoke Later ( runnable ) ; }
@ Override public void cleanup ( ) { page = null ; state = null ; stack = null ; global Dirty Region = null ; last Shape = null ; }
@ Override public void key Pressed ( Key Event e ) { if ( enable Arrow Keys && e . is Action Key ( ) && e . get Key Code ( ) == Key Event . VK RIGHT ) { e . consume ( ) ; open Popup ( ) ; if ( popup != null ) { time Menu Panel . select First Entry ( ) ; } } if ( enable Arrow Keys && e . is Action Key ( ) && e . get Key Code ( ) == Key Event . VK UP ) { e . consume ( ) ; if ( up Pressed || ! is Enabled ( ) ) { return ; } up Pressed = true ; if ( get Time ( ) == null ) { set Time ( Local Time . NOON ) ; } z Internal Try Change Time By Increment ( NUM_ ) ; increase Timer . start ( ) ; } if ( enable Arrow Keys && e . is Action Key ( ) && e . get Key Code ( ) == Key Event . VK DOWN ) { e . consume ( ) ; if ( down Pressed || ! is Enabled ( ) ) { return ; } down Pressed = true ; if ( get Time ( ) == null ) { set Time ( Local Time . NOON ) ; } z Internal Try Change Time By Increment ( - NUM_ ) ; decrease Timer . start ( ) ; } }
public Meth Executor Result execute Method On Class ( String class Name , String method Name ) { String name = class Name + STR_ + method Name ; long start = start ( name ) ; Meth Executor Result result = Meth Executor . execute ( class Name , method Name ) ; log Delta ( name , start , result ) ; return result ; }
protected void on Layout ( Watch Shape shape , Rect screen Bounds , Window Insets screen Insets ) { Logr . v ( String . format ( STR_ , shape . name ( ) , screen Bounds , screen Insets ) ) ; }
public void action Performed ( Action Event ae ) { long current Time = System . nano Time ( ) / NUM_ ; long total Time = current Time - anim Start Time ; if ( total Time > animation Duration ) { anim Start Time = current Time ; } float fraction = ( float ) total Time / animation Duration ; fraction = Math . min ( NUM_ , fraction ) ; int red = ( int ) ( fraction * end Color . get Red ( ) + ( NUM_ - fraction ) * start Color . get Red ( ) ) ; int green = ( int ) ( fraction * end Color . get Green ( ) + ( NUM_ - fraction ) * start Color . get Green ( ) ) ; int blue = ( int ) ( fraction * end Color . get Blue ( ) + ( NUM_ - fraction ) * start Color . get Blue ( ) ) ; current Color = new Color ( red , green , blue ) ; repaint ( ) ; }
public void install ( J Text Component c ) { component = c ; Document doc = c . get Document ( ) ; dot = mark = NUM_ ; dot LTR = mark LTR = true ; dot Bias = mark Bias = Position . Bias . Forward ; if ( doc != null ) { doc . add Document Listener ( handler ) ; } c . add Property Change Listener ( handler ) ; c . add Focus Listener ( this ) ; c . add Mouse Listener ( this ) ; c . add Mouse Motion Listener ( this ) ; if ( component . has Focus ( ) ) { focus Gained ( null ) ; } Number ratio = ( Number ) c . get Client Property ( STR_ ) ; if ( ratio != null ) { aspect Ratio = ratio . float Value ( ) ; } else { aspect Ratio = - NUM_ ; } Integer width = ( Integer ) c . get Client Property ( STR_ ) ; if ( width != null ) { caret Width = width . int Value ( ) ; } else { caret Width = - NUM_ ; } }
public static void put ( JA Mon Listener jamon Listener ) { map . put ( jamon Listener . get Name ( ) , jamon Listener ) ; }
public static float [ ] [ ] to Matrix ( Affine Transform xform ) { return new float [ ] [ ] { { ( float ) xform . get Scale X ( ) , ( float ) xform . get Shear X ( ) , NUM_ } , { ( float ) xform . get Shear Y ( ) , ( float ) xform . get Scale Y ( ) , NUM_ } , { ( float ) xform . get Translate X ( ) , ( float ) xform . get Translate Y ( ) , NUM_ } } ; }
public static void main ( String ... args ) throws SQL Exception { Self Destructor . start Countdown ( NUM_ ) ; if ( args . length == NUM_ ) { System . exit ( NUM_ ) ; } String url = args [ NUM_ ] ; Test Exit . execute ( url ) ; }
protected boolean update Image For Projection ( Projection proj ) { position ( proj ) ; if ( image Decoder != null ) { if ( ! is On Map ( proj ) ) { set Need To Regenerate ( true ) ; return false ; } if ( should Fetch For Projection ( proj ) ) { if ( real Selection == null ) { if ( get Fill Paint ( ) == com . bbn . openmap . om Graphics . OM Color . clear ) { set Fill Paint ( DEFAULT NON CLEAR FILL PAINT ) ; } real Selection = Boolean . value Of ( selected ) ; } selected = true ; set Shape ( ) ; set Need To Regenerate ( false ) ; return false ; } else if ( real Selection != null ) { if ( get Fill Paint ( ) == DEFAULT NON CLEAR FILL PAINT ) { set Fill Paint ( com . bbn . openmap . om Graphics . OM Color . clear ) ; } set Fill Paint ( com . bbn . openmap . om Graphics . OM Color . clear ) ; selected = real Selection . boolean Value ( ) ; real Selection = null ; } if ( bitmap == null ) { if ( cache != null ) { set Image ( ( Image ) cache . get ( image Decoder ) ) ; } else { set Image ( image Decoder . get Buffered Image ( ) ) ; } } } return true ; }
public synchronized void update Path ( Property Change Listener listener , Object new Object , Set update Set ) { if ( current Object != new Object ) { remove Listeners ( ) ; } if ( ( children != null ) && ( children . length > NUM_ ) ) { try { Object new Value = null ; if ( new Object != null ) { update Set . add ( new Object ) ; new Value = extract New Value ( new Object ) ; } for ( Bind Path child : children ) { child . update Path ( listener , new Value , update Set ) ; } } catch ( Exception e ) { } } if ( current Object != new Object ) { add Listeners ( listener , new Object , update Set ) ; } }
public void undoable Edit Happened ( Undoable Edit Event e ) { m Undo . add Edit ( e . get Edit ( ) ) ; m Undo Action . update Undo State ( ) ; m Redo Action . update Redo State ( ) ; }
protected void fire Item Changed ( ) { if ( ! is Disposed ) { for ( Item Changed Listener listener : item Changed Listeners ) { listener . item State Changed ( ) ; } } }
public boolean copy Image ( Image img , int dx , int dy , int sx , int sy , int width , int height , Color bgcolor , Image Observer observer ) { try { return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e ) { try { revalidate All ( ) ; return imagepipe . copy Image ( this , img , dx , dy , sx , sy , width , height , bgcolor , observer ) ; } catch ( Invalid Pipe Exception e 2 ) { return false ; } } finally { surface Data . mark Dirty ( ) ; } }
@ Call Super protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } dispatch On Page Scrolled ( position , offset , offset Pixels ) ; if ( m Page Transformer != null ) { final int scroll X = get Scroll X ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Left ( ) - scroll X ) / get Padded Width ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = true ; }
public S 2 Polygon ( ) { this . loops = Lists . new Array List ( ) ; this . bound = S 2 Lat Lng Rect . empty ( ) ; this . has Holes = false ; this . num Vertices = NUM_ ; }
public Response on Command ( SMTP Session session , Request request ) { if ( session . is Start TLS Supported ( ) ) { if ( session . is TLS Started ( ) ) { return TLS ALREADY ACTIVE ; } else { String parameters = request . get Argument ( ) ; if ( ( parameters == null ) || ( parameters . length ( ) == NUM_ ) ) { return READY FOR STARTTLS ; } else { return SYNTAX ERROR ; } } } else { return NOT SUPPORTED ; } }
private static int global Error Handler ( long display , long event ptr ) { if ( noisy Awt Handler ) { Xlib Wrapper . Print X Error Event ( display , event ptr ) ; } X Error Event event = new X Error Event ( event ptr ) ; saved error = event ; try { if ( current error handler != null ) { return current error handler . handle Error ( display , event ) ; } else { return SAVED XERROR HANDLER ( display , event ) ; } } catch ( Throwable z ) { log . fine ( STR_ , z ) ; } return NUM_ ; }
public void calc Auto Scale ( ) { double max No Of Major Ticks = NUM_ ; double max No Of Minor Ticks = NUM_ ; double nice Range = ( Helper . calc Nice Number ( get Range ( ) , false ) ) ; set Major Tick Space ( Helper . calc Nice Number ( nice Range / ( max No Of Major Ticks - NUM_ ) , true ) ) ; double nice Min Value = ( Math . floor ( get Min Value ( ) / get Major Tick Space ( ) ) * get Major Tick Space ( ) ) ; double nice Max Value = ( Math . ceil ( get Max Value ( ) / get Major Tick Space ( ) ) * get Major Tick Space ( ) ) ; set Minor Tick Space ( Helper . calc Nice Number ( get Major Tick Space ( ) / ( max No Of Minor Ticks - NUM_ ) , true ) ) ; set Min Value ( nice Min Value ) ; set Max Value ( nice Max Value ) ; }
private void check Read Only Parent ( File target , Throwable exception ) throws Core Exception { File parent = target . get Parent File ( ) ; if ( parent != null && ( attributes ( parent ) & EFS . ATTRIBUTE READ ONLY ) != NUM_ ) { String message = NLS . bind ( Messages . read Only Parent , target . get Absolute Path ( ) ) ; Policy . error ( EFS . ERROR PARENT READ ONLY , message , exception ) ; } }
public void focus Gained ( Focus Event e ) { combo Box . repaint ( ) ; }
public void invoke Hook Bolt Fail ( Tuple tuple , long fail Latency Ns ) { if ( task Hooks . size ( ) != NUM_ ) { Bolt Fail Info fail Info = new Bolt Fail Info ( tuple , get This Task Id ( ) , fail Latency Ns / Constants . MILLISECONDS TO NANOSECONDS ) ; for ( I Task Hook task Hook : task Hooks ) { task Hook . bolt Fail ( fail Info ) ; } } }
@ Override public void on Image Results ( List < Face > faces , Frame image , float time Stamp ) { most Recent Frame = image ; if ( faces == null ) { return ; } perform FPS Calculations ( ) ; if ( faces . size ( ) <= NUM_ ) { drawing View . invalidate Points ( ) ; } else if ( faces . size ( ) == NUM_ ) { metric View Layout . set Visibility ( View . VISIBLE ) ; for ( Metric Display metric Display : metric Displays ) { update Metric Score ( metric Display , faces . get ( NUM_ ) ) ; } if ( drawing View . get Draw Points Enabled ( ) || drawing View . get Draw Appearance Markers Enabled ( ) || drawing View . get Draw Emoji Markers Enabled ( ) ) { drawing View . update Points ( faces , mirror Points ) ; } } else { metric View Layout . set Visibility ( View . GONE ) ; drawing View . update Points ( faces , mirror Points ) ; } }
public void component Shown ( Component Event e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + layer . get Name ( ) + STR_ ) ; } Component comp = e . get Component ( ) ; if ( comp == null ) { } else if ( comp == layer ) { if ( is Layer On ( ) != true ) { set Layer On ( true ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + layer . get Name ( ) + STR_ ) ; } } } else if ( comp == layer . get Palette ( ) ) { set Palette On ( true ) ; } }
public void initialize ( Input Split split , Image Transform image Transform ) throws IO Exception { this . image Loader = null ; this . image Transform = image Transform ; initialize ( split ) ; }
@ Override protected void update ( ) { m Button Start . set Enabled ( has Data ( ) ) ; m Button Stop . set Enabled ( is Running ( ) ) ; }
public void init ( ) { try { synchronized ( lock . validated ( ) ) { remote . init ( ) ; } } catch ( Throwable t ) { Util . handle Exception ( t ) ; } }
void did Abort ( final Callable task , final Throwable t , final boolean waiting ) { if ( INFO ) log . info ( STR_ + nended ) ; nerror . increment And Get ( ) ; try { release Locks ( waiting ) ; } catch ( Throwable t 2 ) { log . warn ( STR_ + t 2 , t 2 ) ; } if ( INFO ) log . info ( STR_ + nended ) ; }
@ On Open public void on Connect ( final Session session ) { SESSIONS . add ( session ) ; }
private void source Iterator Exhaushted ( ) { if ( logger . is Loggable ( Level . FINEST ) ) logger . finest ( STR_ + identifier + STR_ ) ; source Iterator Exhausted = true ; }
public static void notify All ( Object lock ) { synchronized ( lock ) { lock . notify All ( ) ; } }
@ Override public void do Layout ( ) { super . do Layout ( ) ; Dimension size = get Size ( ) ; coordinate System = new Coordinate System ( NUM_ , size . get Width ( ) , NUM_ , size . get Height ( ) ) ; should Draw = true ; recalculate Display List ( ) ; }
public static Connection ensure Table Exists ( final Table table ) throws SQL Exception { establish Connection ( ) ; try ( final Statement stmt = connection . create Statement ( ) ) { stmt . execute ( table . get Creation Statement ( ) ) ; return connection ; } }
public void find And Undo ( Object some Obj ) { if ( some Obj instanceof Layer Listener ) { logger . fine ( STR_ ) ; remove Layer Listener ( ( Layer Listener ) some Obj ) ; } if ( some Obj instanceof Layer Configuration Listener ) { logger . fine ( STR_ ) ; remove Layer Configuration Listener ( ( Layer Configuration Listener ) some Obj ) ; } if ( some Obj instanceof Layer ) { remove Layer ( ( Layer ) some Obj ) ; } if ( some Obj instanceof Plug In ) { Plug In pi = ( Plug In ) some Obj ; Component comp = pi . get Component ( ) ; if ( comp instanceof Layer && has Layer ( ( Layer ) comp ) ) { remove Layer ( ( Layer ) comp ) ; } } if ( some Obj instanceof Property Handler && some Obj == get Property Handler ( ) ) { set Property Handler ( null ) ; } }
public void on Surface Changed ( GL 10 gl Unused , int width , int height ) { Log . d ( TAG , STR_ + width + STR_ + height ) ; int video width = m Media Player . get Video Width ( ) ; int video height = m Media Player . get Video Height ( ) ; Log . d ( TAG , STR_ + video width + STR_ + video height ) ; GLES 20 . gl Viewport ( NUM_ , NUM_ , video width , video height ) ; m Width = Math . min ( Video Dump Config . MAX DUMP WIDTH , video width ) ; m Height = Math . min ( Video Dump Config . MAX DUMP HEIGHT , video height ) ; m Start X = video width / m Width / NUM_ * m Width ; m Start Y = video height / m Height / NUM_ * m Height ; Log . d ( TAG , STR_ + m Start X + STR_ + m Start Y + STR_ + STR_ + m Width + STR_ + m Height ) ; int image size = m Width * m Height * Video Dump Config . BYTES PER PIXEL ; m Buffer = Byte Buffer . allocate ( image size ) ; int bpp [ ] = new int [ NUM_ ] ; GLES 20 . gl Get Integerv ( GLES 20 . GL RED BITS , bpp , NUM_ ) ; GLES 20 . gl Get Integerv ( GLES 20 . GL GREEN BITS , bpp , NUM_ ) ; GLES 20 . gl Get Integerv ( GLES 20 . GL BLUE BITS , bpp , NUM_ ) ; Log . d ( TAG , STR_ + bpp [ NUM_ ] + STR_ + bpp [ NUM_ ] + STR_ + bpp [ NUM_ ] ) ; Properties prop = new Properties ( ) ; prop . set Property ( STR_ , Integer . to String ( m Width ) ) ; prop . set Property ( STR_ , Integer . to String ( m Height ) ) ; prop . set Property ( STR_ , Integer . to String ( m Start X ) ) ; prop . set Property ( STR_ , Integer . to String ( m Start Y ) ) ; prop . set Property ( STR_ , Integer . to String ( Video Dump Config . BYTES PER PIXEL ) ) ; prop . set Property ( STR_ , Integer . to String ( Video Dump Config . FRAME RATE ) ) ; try { prop . store To XML ( new File Output Stream ( Video Dump Config . ROOT DIR + Video Dump Config . PROPERTY FILE ) , STR_ ) ; } catch ( java . io . IO Exception e ) { Log . e ( TAG , e . get Message ( ) , e ) ; } }
@ Override protected void key Typed ( char par 1 , int par 2 ) { token Box . textbox Key Typed ( par 1 , par 2 ) ; if ( par 2 == NUM_ || par 2 == NUM_ ) action Performed ( ( Gui Button ) button List . get ( NUM_ ) ) ; }
private void call On Active ( Runnable r ) { synchronized ( on Active Listeners ) { if ( is Active ) { r . run ( ) ; } else { on Active Listeners . add ( r ) ; } } }
public void invoke Main ( String s Class , String [ ] args ) throws Throwable { Class < ? > clazz = load Class ( s Class ) ; log Info ( Log Area . CONFIG , STR_ , s Class , clazz . get Class Loader ( ) ) ; Method method = clazz . get Method ( STR_ , new Class < ? > [ ] { String [ ] . class } ) ; boolean b Valid Modifiers = false ; boolean b Valid Void = false ; if ( method != null ) { method . set Accessible ( true ) ; int n Modifiers = method . get Modifiers ( ) ; b Valid Modifiers = Modifier . is Public ( n Modifiers ) && Modifier . is Static ( n Modifiers ) ; Class < ? > clazz Ret = method . get Return Type ( ) ; b Valid Void = ( clazz Ret == void . class ) ; } if ( method == null || ! b Valid Modifiers || ! b Valid Void ) { throw new No Such Method Exception ( STR_ + s Class + STR_ ) ; } try { method . invoke ( null , ( Object ) args ) ; } catch ( Invocation Target Exception e ) { throw e . get Target Exception ( ) ; } }
public static void do Move ( Project project , @ Not Null Psi Element [ ] elements , Psi Element target Container , Data Context data Context , Move Callback callback ) { if ( elements . length == NUM_ ) return ; for ( Move Handler Delegate delegate : Extensions . get Extensions ( Move Handler Delegate . EP NAME ) ) { if ( delegate . can Move ( elements , target Container ) ) { delegate . do Move ( project , elements , delegate . adjust Target For Move ( data Context , target Container ) , callback ) ; break ; } } }
private void fire Process View Changed ( ) { for ( Extended Process Editor editor : process Editors . get Listeners ( Extended Process Editor . class ) ) { editor . process View Changed ( process ) ; } }
@ Override protected void failed ( Throwable e , Description description ) { this . tr State . is Success = false ; this . tr State . failure Reason = Utils . to String ( e ) ; }
synchronized protected void send Message ( Abstract MR Message m , Abstract MR Listener reply ) { msg Queue . add Last ( m ) ; listener Queue . add Last ( reply ) ; synchronized ( xmt Runnable ) { if ( m Current State == IDLESTATE ) { m Current State = NOTIFIEDSTATE ; xmt Runnable . notify ( ) ; } } if ( m != null ) { if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ , m . to String ( ) ) ; } } }
@ Override protected void after ( ) throws Exception { Codec . set Default ( saved Codec ) ; Info Stream . set Default ( saved Info Stream ) ; if ( saved Locale != null ) Locale . set Default ( saved Locale ) ; if ( saved Time Zone != null ) Time Zone . set Default ( saved Time Zone ) ; }
public void changed Update ( Document Event e ) { something Changed ( ) ; }
public void init HMM Data ( String voice Name , String marybase , String config File ) throws Exception { Properties props = new Properties ( ) ; File Input Stream fis = new File Input Stream ( marybase + config File ) ; props . load ( fis ) ; fis . close ( ) ; Map < String , String > mary Base Replacer = new Hash Map < String , String > ( ) ; mary Base Replacer . put ( STR_ , marybase ) ; init HMM Data ( new Properties Accessor ( props , false , mary Base Replacer ) , voice Name ) ; }
@ Override public void series Changed ( Series Change Event event ) { refresh Keys ( ) ; fire Dataset Changed ( ) ; }
@ Override public boolean on Options Item Selected ( Menu Item item ) { switch ( item . get Item Id ( ) ) { case MENU SETTINGS ID : start Activity ( new Intent ( this , Activity Settings . class ) ) ; return true ; case MENU ABOUT ID : show About ( ) ; return true ; } return super . on Options Item Selected ( item ) ; }
@ Override public void on Message Received ( String from , Bundle data ) { JSON Object json Object = new JSON Object ( ) ; final Set < String > keys = data . key Set ( ) ; for ( String key : keys ) { try { json Object . put ( key , data . get String ( key ) ) ; } catch ( JSON Exception e ) { e . print Stack Trace ( ) ; } } Log . d ( TAG , STR_ + json Object . to String ( ) ) ; send Notification ( json Object ) ; }
@ Override public void wait For GC ( ) { boolean all Waiting ; synchronized ( count ) { mutators Blocked ++ ; all Waiting = all Waiting For GC ( ) ; } wait For GC ( all Waiting , true ) ; synchronized ( count ) { mutators Blocked -- ; } }
public int reduce Fp ( int value ) { fp Lock . lock ( ) ; try { int new Fp = this . current Fp - value ; if ( new Fp < NUM_ ) { new Fp = NUM_ ; } this . current Fp = new Fp ; } finally { fp Lock . unlock ( ) ; } on Reduce Fp ( ) ; return current Fp ; }
public void action Performed ( Action Event ae ) { if ( ae . get Source ( ) == get Timer ( ) ) { change Time By ( time Increment * clock Direction , time Wrap , clock Direction < NUM_ ? Timer Status . UPDATE : Timer Status . FORWARD ) ; } }
@ Override public String save ( ) { log . info ( STR_ ) ; boolean base Url Changed = false ; if ( ! string Equals ( base Url , cfg . get Base Url ( ) ) ) { log . info ( STR_ + cfg . get Base Url ( ) + STR_ + base Url + STR_ ) ; try { URL burl = new URL ( base Url ) ; config Manager . set Base Url ( burl ) ; update All Alternate Identifiers For IPTURL To Resource ( ) ; log . info ( STR_ + base Url + STR_ ) ; add Action Message ( get Text ( STR_ ) ) ; add Action Message ( get Text ( STR_ ) ) ; add Action Message ( get Text ( STR_ ) ) ; session . remove ( Constants . SESSION USER ) ; if ( URL Utils . is Localhost ( burl ) ) { add Action Warning ( get Text ( STR_ ) ) ; } else if ( URL Utils . is Host Name ( burl ) ) { log . info ( STR_ ) ; add Action Warning ( get Text ( STR_ ) ) ; } base Url Changed = true ; } catch ( Malformed URL Exception e ) { add Action Error ( get Text ( STR_ ) ) ; return INPUT ; } catch ( Invalid Config Exception e ) { if ( e . get Type ( ) == Invalid Config Exception . TYPE . INVALID BASE URL ) { add Action Error ( get Text ( STR_ ) + STR_ + base Url ) ; } else if ( e . get Type ( ) == Invalid Config Exception . TYPE . INACCESSIBLE BASE URL ) { add Action Error ( get Text ( STR_ ) + STR_ + base Url ) ; } else { add Action Error ( get Text ( STR_ , new String [ ] { e . get Message ( ) } ) ) ; } return INPUT ; } } try { config Manager . set Proxy ( proxy ) ; } catch ( Invalid Config Exception e ) { add Action Error ( get Text ( e . get Message ( ) ) + STR_ + proxy ) ; return INPUT ; } if ( debug != null ) { try { config Manager . set Debug Mode ( debug ) ; } catch ( Invalid Config Exception e ) { add Action Error ( get Text ( STR_ ) ) ; return INPUT ; } } if ( archival Mode != null ) { try { config Manager . set Archival Mode ( archival Mode ) ; } catch ( Invalid Config Exception e ) { if ( e . get Type ( ) == Invalid Config Exception . TYPE . DOI REGISTRATION ALREADY ACTIVATED ) { add Action Error ( get Text ( STR_ ) ) ; } else { add Action Error ( get Text ( STR_ ) ) ; } return INPUT ; } } if ( analytics Gbif != null ) { try { config Manager . set Gbif Analytics ( analytics Gbif ) ; } catch ( Invalid Config Exception e ) { add Action Error ( get Text ( STR_ ) ) ; return INPUT ; } } if ( analytics Key != null ) { try { config Manager . set Analytics Key ( analytics Key ) ; } catch ( Invalid Config Exception e ) { add Action Error ( get Text ( STR_ ) ) ; return INPUT ; } } try { config Manager . set Ipt Location ( latitude , longitude ) ; } catch ( Invalid Config Exception e ) { add Action Error ( get Text ( STR_ ) ) ; return INPUT ; } try { config Manager . save Config ( ) ; } catch ( Invalid Config Exception e ) { log . error ( STR_ , e ) ; add Action Error ( get Text ( STR_ ) ) ; return INPUT ; } if ( base Url Changed ) { return HOME ; } return SUCCESS ; }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } m Called Super = true ; }
@ Override public void on Draw Frame ( final GL 10 unused ) { GLES 20 . gl Clear ( GLES 20 . GL COLOR BUFFER BIT ) ; if ( requesr Update Tex ) { requesr Update Tex = false ; m S Texture . update Tex Image ( ) ; m S Texture . get Transform Matrix ( m St Matrix ) ; update ( h Tex , m St Matrix ) ; } GLES 20 . gl Bind Framebuffer ( GLES 20 . GL FRAMEBUFFER , NUM_ ) ; GLES 20 . gl Clear ( GLES 20 . GL COLOR BUFFER BIT ) ; GLES 20 . gl Enable ( GLES 20 . GL BLEND ) ; final Camera GL View parent = m Weak Parent . get ( ) ; render ( parent . m Render Viewport . x , parent . m Render Viewport . y , parent . m Render Viewport . width , parent . m Render Viewport . height ) ; GLES 20 . gl Disable ( GLES 20 . GL BLEND ) ; flip = ! flip ; if ( flip ) { synchronized ( this ) { if ( m Video Encoder != null ) { m Video Encoder . frame Available Soon ( m St Matrix , m Mvp Matrix ) ; } } } }
protected void check Response ( ) throws IO Exception , Service Exception { if ( is O Auth Proxy Error Response ( ) ) { handle O Auth Proxy Error Response ( ) ; } else if ( http Conn . get Response Code ( ) >= NUM_ ) { handle Error Response ( ) ; } }
public void charge Item ( Item Stack a Stack ) { decrease Stored EU ( GT Mod Handler . charge Electric Item ( a Stack , ( int ) Math . min ( Integer . MAX VALUE , get Stored EU ( ) ) , ( int ) Math . min ( Integer . MAX VALUE , m Meta Tile Entity . get Output Tier ( ) ) , false , false ) , true ) ; }
protected Server Socket create Server Socket ( ) throws IO Exception { Inet Socket Address isa ; if ( this . bind Address == null ) { isa = new Inet Socket Address ( this . port ) ; } else { isa = new Inet Socket Address ( this . bind Address , this . port ) ; } Server Socket server Socket = new Server Socket ( ) ; server Socket . bind ( isa , this . backlog ) ; if ( this . port == NUM_ ) { this . port = server Socket . get Local Port ( ) ; } return server Socket ; }
@ Called By Native public static Bitmap generate Home Screen Icon ( Context context , String url , int red , int green , int blue ) { Activity Manager am = ( Activity Manager ) context . get System Service ( Context . ACTIVITY SERVICE ) ; final int outer Size = am . get Launcher Large Icon Size ( ) ; final int icon Density = am . get Launcher Large Icon Density ( ) ; Bitmap bitmap = null ; try { bitmap = Bitmap . create Bitmap ( outer Size , outer Size , Bitmap . Config . ARGB 8888 ) ; } catch ( Out Of Memory Error e ) { Log . w ( TAG , STR_ ) ; return null ; } Canvas canvas = new Canvas ( bitmap ) ; int padding = ( int ) ( GENERATED ICON PADDING RATIO * outer Size ) ; Rect outer Bounds = new Rect ( NUM_ , NUM_ , outer Size , outer Size ) ; Bitmap bookmark Widget Bg = get Bitmap From Resource Id ( context , R . mipmap . bookmark widget bg , icon Density ) ; Paint paint = new Paint ( Paint . FILTER BITMAP FLAG ) ; canvas . draw Bitmap ( bookmark Widget Bg , null , outer Bounds , paint ) ; int inner Size = outer Size - NUM_ * padding ; int corner Radius = Math . round ( ICON CORNER RADIUS RATIO * outer Size ) ; int font Size = Math . round ( GENERATED ICON FONT SIZE RATIO * outer Size ) ; int color = Color . rgb ( red , green , blue ) ; Rounded Icon Generator generator = new Rounded Icon Generator ( inner Size , inner Size , corner Radius , color , font Size ) ; Bitmap icon = generator . generate Icon For Url ( url ) ; if ( icon == null ) return null ; canvas . draw Bitmap ( icon , padding , padding , null ) ; return bitmap ; }
private void save Profile State CB ( ) { save Password Box . set Enabled ( save Login Box . is Selected ( ) ) ; }
void on Deferred End Drag ( Drag View drag View ) { drag View . remove ( ) ; if ( m Drag Object . defer Drag View Cleanup Post Animation ) { for ( Drag Listener listener : m Listeners ) { listener . on Drag End ( ) ; } } }
public void find And Init ( Object some Obj ) { if ( some Obj instanceof Map Bean ) { set Map ( ( Map Bean ) some Obj ) ; } }
public void on Ready ( Runnable runnable ) { runnable . run ( ) ; }
public boolean is Standard Module ( String module Name ) { return false ; }
public Trigger Option with Late Firings At Every ( long count ) { Count Trigger trigger = new Count Trigger ( Type . LATE , count ) ; trigger List . add ( trigger ) ; return this ; }
@ Override public void notify Node Down ( final long event Time , final String node ID ) { if ( ! ha ) { return ; } if ( logger . is Trace Enabled ( ) ) { logger . trace ( STR_ + this + STR_ + node ID + STR_ , new Exception ( STR_ ) ) ; } topology . remove Member ( event Time , node ID ) ; if ( cluster Connection ) { update Arrays And Pairs ( ) ; } else { if ( topology . is Empty ( ) ) { received Topology = false ; topology Array = null ; } else { update Arrays And Pairs ( ) ; if ( topology . nodes ( ) == NUM_ && topology . get Member ( this . node ID ) != null ) { received Topology = false ; } } } }
private void copy Arrays ( ) { String [ ] old Syms = symbols ; int size = old Syms . length ; symbols = new String [ size ] ; System . arraycopy ( old Syms , NUM_ , symbols , NUM_ , size ) ; Bucket [ ] old Buckets = buckets ; size = old Buckets . length ; buckets = new Bucket [ size ] ; System . arraycopy ( old Buckets , NUM_ , buckets , NUM_ , size ) ; }
protected Page Channel ( boolean testing ) { if ( ! testing ) { throw new Illegal Argument Exception ( ) ; } channel = null ; close Channel = false ; format = Jet Format . VERSION 4 ; auto Sync = false ; }
public void sent Data ( ) { has Sent Data = true ; last Send Time = System . current Time Millis ( ) ; }
private boolean recovery ( O Block block ) { if ( occupies . size ( ) == NUM_ ) { Iterator < O Block > it = head Range . iterator ( ) ; while ( it . has Next ( ) ) { O Block b = it . next ( ) ; if ( ( b . get State ( ) & ( O Block . DARK | O Block . OCCUPIED ) ) != NUM_ ) { lost Range . add ( b ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + b . get Display Name ( ) + STR_ + b . get Value ( ) ) ; } } } it = tail Range . iterator ( ) ; while ( it . has Next ( ) ) { O Block b = it . next ( ) ; if ( ( b . get State ( ) & ( O Block . DARK | O Block . OCCUPIED ) ) != NUM_ ) { lost Range . add ( b ) ; if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + b . get Display Name ( ) + STR_ + b . get Value ( ) ) ; } } } } if ( log . is Debug Enabled ( ) ) { log . debug ( STR_ + block . get Display Name ( ) + STR_ + lost Range . size ( ) ) ; } if ( lost Range == null || lost Range . size ( ) == NUM_ ) { return false ; } O Block blk = ( O Block ) J Option Pane . show Input Dialog ( null , Bundle . get Message ( STR_ , train Name , block . get Display Name ( ) ) + STR_ + Bundle . get Message ( STR_ ) , Bundle . get Message ( STR_ ) , J Option Pane . INFORMATION MESSAGE , null , lost Range . to Array ( ) , null ) ; if ( blk != null ) { occupies . add First ( blk ) ; show Block Value ( blk ) ; } else { return false ; } setup Check ( ) ; return true ; }
public boolean supports Session Variables ( ) { return false ; }
synchronized void start Running Images ( ) { queue . remove All Elements ( ) ; Vector urls = new Vector ( ) ; for ( Enumeration e = images . keys ( ) ; e . has More Elements ( ) ; ) { Component img Comp = ( Component ) e . next Element ( ) ; String image Url = ( String ) images . get ( img Comp ) ; int url Index = urls . index Of ( image Url ) ; if ( url Index != - NUM_ ) { Resource Thread t = ( Resource Thread ) queue . element At ( url Index ) ; t . add Label ( img Comp ) ; } else { Resource Thread t = new Resource Thread ( image Url , img Comp , html C , this ) ; queue . add Element ( t ) ; urls . add Element ( image Url ) ; } } urls = null ; images = new Hashtable ( ) ; if ( ! start Dequeue ( ) ) { html C . set Page Status ( HTML Callback . STATUS COMPLETED ) ; } }
public void done ( ) { if ( out != null ) { out . close ( ) ; } }
public void component Hidden ( Component Event e ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + layer . get Name ( ) + STR_ ) ; } Component comp = e . get Component ( ) ; if ( comp == layer ) { if ( is Layer On ( ) != false ) { set Layer On ( false ) ; if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + layer . get Name ( ) + STR_ ) ; } } } else if ( comp == layer . get Palette ( ) ) { set Palette On ( false ) ; } else if ( comp == null ) { if ( logger . is Loggable ( Level . FINE ) ) { logger . fine ( STR_ + layer . get Name ( ) + STR_ ) ; } } }
public static void assume Networking ( ) { try { Enumeration < Network Interface > ifaces = Network Interface . get Network Interfaces ( ) ; assume That ( ifaces , is ( not Null Value ( ) ) ) ; assume True ( ifaces . has More Elements ( ) ) ; } catch ( Socket Exception ex ) { assume No Exception ( ex ) ; } }
public final Parallel Flux < T > do On Subscribe ( Consumer < ? super Subscription > on Subscribe ) { Objects . require Non Null ( on Subscribe , STR_ ) ; return do On Signal ( this , null , null , null , null , null , on Subscribe , null , null ) ; }
private void on Users Synced ( Set < Json User > synced Users ) throws User Sync Exception { if ( synced Users == null || synced Users . is Empty ( ) ) { throw new User Sync Exception ( STR_ ) ; } synchronized ( m Lock ) { Immutable Set < Json User > added Users = Immutable Set . copy Of ( Sets . difference ( synced Users , m Known Users ) ) ; Immutable Set < Json User > deleted Users = Immutable Set . copy Of ( Sets . difference ( m Known Users , synced Users ) ) ; m Known Users . clear ( ) ; m Known Users . add All ( synced Users ) ; m Event Bus . post ( new Known Users Synced Event ( added Users , deleted Users ) ) ; if ( m Active User != null && deleted Users . contains ( m Active User ) ) { m Event Bus . post ( new Active User Unset Event ( m Active User , Active User Unset Event . REASON USER DELETED ) ) ; } } }
@ Override @ Suppress Warnings ( STR_ ) public void completed ( int bytes Transferred , boolean can Invoke Direct ) { update Buffers ( bytes Transferred ) ; release Buffers ( ) ; synchronized ( result ) { if ( result . is Done ( ) ) return ; enable Writing ( ) ; if ( gathering Write ) { result . set Result ( ( V ) Long . value Of ( bytes Transferred ) ) ; } else { result . set Result ( ( V ) Integer . value Of ( bytes Transferred ) ) ; } } if ( can Invoke Direct ) { Invoker . invoke Unchecked ( result ) ; } else { Invoker . invoke ( result ) ; } }
protected void enqueue ( Method Call < ? > method Call ) { if ( ! running . get ( ) ) { throw new Illegal State Exception ( STR_ ) ; } if ( ! pending Calls . offer ( method Call ) ) { throw new Illegal State Exception ( STR_ ) ; } }
private void prepare Data ( ) { final I Searcher searcher = ( I Searcher ) m type Box . get Selected Item ( ) ; if ( searcher != null ) { m search Data = searcher . get Search Data ( m input Field . get Text ( ) ) ; } }
void show About ( ) { if ( about == null ) { about = new Common About Dialog ( frame ) ; } about . set Visible ( true ) ; }
protected void finish Adding ( ) { no More Adding = true ; work Space = null ; storage Space = null ; word Counts = null ; final int [ ] frqs = new int [ dimension Size ] ; for ( int i = NUM_ ; i < term Document Frequencys . length ( ) ; i ++ ) frqs [ i ] = term Document Frequencys . get ( i ) ; weighting . set Weight ( vectors , Int List . unmodifiable View ( frqs , dimension Size ) ) ; for ( Sparse Vector vec : vectors ) weighting . apply To ( vec ) ; term Document Frequencys = null ; }
protected final void read Response ( Input Stream input ) throws IO Exception { if ( is Gzipped ) { read Unziped Response ( new GZIP Input Stream ( input ) ) ; } else { read Unziped Response ( input ) ; } }
public void handle Notification ( Notification notification , Object handback ) { String notify Type = notification . get Type ( ) ; if ( notify Type . equals ( Garbage Collection Notification Info . GARBAGE COLLECTION NOTIFICATION ) ) { Composite Data cd = ( Composite Data ) notification . get User Data ( ) ; Garbage Collection Notification Info gc Notify Info = Garbage Collection Notification Info . from ( cd ) ; monitor ( gc Notify Info ) ; if ( ! gc Names . contains ( gc Notify Info . get Gc Name ( ) ) ) { register Dependent Gc Mbeans ( gc Notify Info . get Gc Name ( ) ) ; } } }
private void process Axis Fault ( Axis Fault fault ) { Element runtime Exception = fault . lookup Fault Detail ( Constants . QNAME FAULTDETAIL RUNTIMEEXCEPTION ) ; if ( runtime Exception != null ) { exception Log . info ( Messages . get Message ( STR_ ) , fault ) ; fault . remove Fault Detail ( Constants . QNAME FAULTDETAIL RUNTIMEEXCEPTION ) ; } else if ( exception Log . is Debug Enabled ( ) ) { exception Log . debug ( Messages . get Message ( STR_ ) , fault ) ; } fault . remove Fault Detail ( Constants . QNAME FAULTDETAIL STACKTRACE ) ; }
void do Once ( ) { switch ( mode . get Selected Index ( ) ) { default : log . error ( STR_ + mode . get Selected Index ( ) ) ; return ; case NUM_ : do Reading From Time Fields ( ) ; return ; case NUM_ : do Measurement From Position Fields ( ) ; return ; case NUM_ : try { do Load Reading From File ( ) ; do Reading From Time Fields ( ) ; } catch ( java . io . IO Exception e ) { log . error ( STR_ + e ) ; } return ; case NUM_ : try { do Load Measurement From File ( ) ; } catch ( java . io . IO Exception e ) { log . error ( STR_ + e ) ; } return ; } }
@ Override protected void key Typed ( char par 1 , int par 2 ) { command Box . textbox Key Typed ( par 1 , par 2 ) ; }
@ On Open public void on Connect ( final Session session ) { final String article Ids = ( String ) Channels . get Http Parameter ( session , Article . ARTICLE T IDS ) ; if ( String Utils . is Blank ( article Ids ) ) { return ; } SESSIONS . put ( session , article Ids ) ; }
public Repository Changed update Existing Repository ( String repo Name , String repo Remote Location , String repo User Name , String repo Password , String repo Locations , String repo Branch , boolean use Credentials ) { return null ; }
public void post Deserialize ( ) throws Malformed Json Exception { observable Delegate = FX Collections . observable Array List ( delegate ) ; delegate . clear ( ) ; try { create Underlying ( ) ; } catch ( Null Pointer Exception npe ) { throw new Malformed Json Exception ( npe . get Message ( ) ) ; } }
@ Synchronized ( STR_ ) @ Suppress Warnings ( STR_ ) public C create Channel ( @ Non Null String name ) { C chan = ( C ) bot Factory . create Channel ( bot , name ) ; channel Name Map . put ( name . to Lower Case ( locale ) , chan ) ; return chan ; }
private void wait For All ( Count Down Latch latch ) { try { latch . await ( ) ; } catch ( Interrupted Exception e ) { e . print Stack Trace ( ) ; } }
public static void main ( String ... args ) throws Exception { Self Destructor . start Countdown ( NUM_ ) ; Test Halt App app = new Test Halt App ( ) ; if ( args . length == NUM_ ) { app . controller Test ( ) ; } else { app . operations = Integer . parse Int ( args [ NUM_ ] ) ; app . flags = Integer . parse Int ( args [ NUM_ ] ) ; app . value = Integer . parse Int ( args [ NUM_ ] ) ; app . process Run Random ( ) ; } }
public void on Success ( int status Code , Header [ ] headers , byte [ ] response Body ) { try { String response = response Body == null ? null : new String ( response Body , get Charset ( ) ) ; on Success ( status Code , headers , response ) ; } catch ( Unsupported Encoding Exception e ) { Log . e ( LOG TAG , e . to String ( ) ) ; on Failure ( status Code , headers , e , null ) ; } }
@ Override protected Void do In Background ( Void ... voids ) { Https URL Connection con = null ; Input Stream input Stream = null ; File Output Stream output Stream = null ; try { con = Net Cipher . get Https URL Connection ( file URL ) ; int response Code = con . get Response Code ( ) ; if ( response Code == Http URL Connection . HTTP OK ) { file Size = con . get Content Length ( ) ; input Stream = new Buffered Input Stream ( con . get Input Stream ( ) ) ; output Stream = new File Output Stream ( save File Path ) ; int buffer Size = NUM_ ; int downloaded = NUM_ ; int bytes Read = - NUM_ ; byte [ ] buffer = new byte [ buffer Size ] ; while ( ( bytes Read = input Stream . read ( buffer ) ) != - NUM_ ) { output Stream . write ( buffer , NUM_ , bytes Read ) ; downloaded += bytes Read ; if ( downloaded % NUM_ < buffer Size ) { publish Progress ( downloaded ) ; } } publish Progress ( buffer Size ) ; } else { Log . i ( TAG , STR_ + response Code ) ; } } catch ( IO Exception e ) { Log . e ( TAG , STR_ , e ) ; e . print Stack Trace ( ) ; } finally { try { if ( output Stream != null ) { output Stream . close ( ) ; } if ( input Stream != null ) { input Stream . close ( ) ; } } catch ( IO Exception e ) { e . print Stack Trace ( ) ; } if ( con != null ) { con . disconnect ( ) ; } } return null ; }
protected Runnable create Tile Runner ( Tile tile ) { return new Tile Runner ( ) ; }
public void invoke Hook Emit ( List < Object > values , String stream , Collection < Integer > out Tasks ) { if ( task Hooks . size ( ) != NUM_ ) { Emit Info emit Info = new Emit Info ( values , stream , get This Task Id ( ) , out Tasks ) ; for ( I Task Hook task Hook : task Hooks ) { task Hook . emit ( emit Info ) ; } } }
public static void load Data Object Configuration ( List < Data Object Field Configuration > configuration ) { for ( Data Object Field Configuration field Config : configuration ) { Data Object Type do Type = get Do Type ( field Config . get Do Class ( ) ) ; Column Field field = do Type . get Column Field ( field Config . get Field Name ( ) ) ; if ( field == null ) { throw new Illegal Argument Exception ( String . format ( STR_ , field Config . get Field Name ( ) ) ) ; } field . set Ttl ( field Config . get Ttl ( ) ) ; } }
public void focus Gained ( Focus Event e ) { Component c = e . get Component ( ) ; if ( c instanceof J Formatted Text Field ) { select It Later ( c ) ; } }
public void adjustment Value Changed ( Adjustment Event e ) { Adjustable adj = e . get Adjustable ( ) ; int value = e . get Value ( ) ; Scroll Pane Peer peer = ( Scroll Pane Peer ) scroller . peer ; if ( peer != null ) { peer . set Value ( adj , value ) ; } Component c = scroller . get Component ( NUM_ ) ; switch ( adj . get Orientation ( ) ) { case Adjustable . VERTICAL : c . move ( c . get Location ( ) . x , - ( value ) ) ; break ; case Adjustable . HORIZONTAL : c . move ( - ( value ) , c . get Location ( ) . y ) ; break ; default : throw new Illegal Argument Exception ( STR_ ) ; } }
private void prepare Interval Propagations ( ) { if ( prop initialized ) return ; top rank = new int [ n func ] ; Arrays . fill ( top rank , NUM_ ) ; top Q = new Linked List < Integer > ( ) ; top Q . add ( Constants . SUPER MAIN ) ; while ( ! top Q . is Empty ( ) ) { int s = top Q . poll ( ) ; Cg Edge p = call graph [ s ] ; while ( p != null ) { int t = p . t ; int rep t = rep cg [ t ] ; int w = top rank [ s ] + NUM_ ; if ( top rank [ rep t ] < w ) top rank [ rep t ] = w ; if ( -- in degree [ rep t ] == NUM_ ) top Q . add ( rep t ) ; p = p . next ; } } contexts For Methods = new Contexts Collector [ n func ] ; for ( int i = NUM_ ; i < n func ; ++ i ) { Contexts Collector cc = new Contexts Collector ( ) ; cc . set Budget ( Parameters . qry Budget Size ) ; contexts For Methods [ i ] = cc ; } prop initialized = true ; }
public void fire Synapses Updated ( ) { for ( Network Listener listener : network Listeners ) { listener . update Synapses ( ) ; } }
public final void update Animation State ( ) { update State ( ) ; if ( ! is In Progress ( ) ) { if ( notify Lock != null ) { synchronized ( notify Lock ) { notify Lock . notify ( ) ; } } if ( on Completion != null ) { on Completion . run ( ) ; } if ( post != null ) { for ( Runnable p : post ) { p . run ( ) ; } } } }
public void push Draw List Head ( Psp Ge List list ) { synchronized ( draw List Queue ) { int array Size = draw List Queue . size ( ) ; if ( array Size > NUM_ ) { Psp Ge List [ ] array = draw List Queue . to Array ( new Psp Ge List [ array Size ] ) ; Concurrent Linked Queue < Psp Ge List > new Queue = new Concurrent Linked Queue < Psp Ge List > ( ) ; Psp Ge List [ ] new Array = new Psp Ge List [ array Size + NUM_ ] ; new Array [ NUM_ ] = list ; for ( int i = NUM_ ; i < array Size ; i ++ ) { new Array [ i + NUM_ ] = array [ i ] ; new Queue . add ( new Array [ i ] ) ; } draw List Queue = new Queue ; } else { draw List Queue . add ( list ) ; } } }
private void on Death ( ) { play Sound From Category ( Sound Layer . FIGHTING NOISE . group Name , STR_ ) ; }
@ Override @ In Service ( Page Service Sync . class ) public void after Data Flush ( Page Service Impl table Service , int sequence Flush ) { super . after Data Flush ( table Service , sequence Flush ) ; sweep Stub ( table Service ) ; }
public void sync All Asynchronously ( ) { if ( ! is Syncing . compare And Set ( false , true ) ) { throw new Sync Exception ( STR_ ) ; } scheduler . execute ( null ) ; }
void update Buffers ( int bytes Written ) { for ( int i = NUM_ ; i < num Bufs ; i ++ ) { Byte Buffer next Buffer = bufs [ i ] ; int pos = next Buffer . position ( ) ; int lim = next Buffer . limit ( ) ; int len = ( pos <= lim ? lim - pos : lim ) ; if ( bytes Written >= len ) { bytes Written -= len ; int new Position = pos + len ; try { next Buffer . position ( new Position ) ; } catch ( Illegal Argument Exception x ) { } } else { if ( bytes Written > NUM_ ) { assert ( pos + bytes Written < ( long ) Integer . MAX VALUE ) ; int new Position = pos + bytes Written ; try { next Buffer . position ( new Position ) ; } catch ( Illegal Argument Exception x ) { } } break ; } } }
public void on Missed ( ) { resolution = Resolution . MISSED ; combat Icon Time = System . current Time Millis ( ) ; }
public void on Navigate Up ( ) { File parent Dir = null ; if ( m Directory != null ) { parent Dir = m Directory . get Parent File ( ) ; } list Directory ( parent Dir ) ; }
protected void connected ( String ip , int port ) { this . connected Ip = ip ; this . connected Port = port ; this . connected Since = System . current Time Millis ( ) ; set State ( Irc . STATE CONNECTED ) ; on Connect ( ) ; if ( pass != null ) { send ( STR_ + pass ) ; } send ( STR_ + nick ) ; send ( String . format ( STR_ , nick ) ) ; }
public void stop ( ) { if ( null != periodic Tick Task ) { stop Task ( periodic Tick Task ) ; } if ( null != periodic Tick Executor Service ) { periodic Tick Executor Service . shutdown Now ( ) ; } }
protected void compute Doubles For All Zoom Levels ( ) { int num Frames = m Sound File . get Num Frames ( ) ; float max Gain = NUM_ ; for ( int i = NUM_ ; i < num Frames ; i ++ ) { float gain = get Gain ( i , num Frames , m Sound File . get Frame Gains ( ) ) ; if ( gain > max Gain ) { max Gain = gain ; } } scale Factor = NUM_ ; if ( max Gain > NUM_ ) { scale Factor = NUM_ / max Gain ; } max Gain = NUM_ ; int gain Hist [ ] = new int [ NUM_ ] ; for ( int i = NUM_ ; i < num Frames ; i ++ ) { int smoothed Gain = ( int ) ( get Gain ( i , num Frames , m Sound File . get Frame Gains ( ) ) * scale Factor ) ; if ( smoothed Gain < NUM_ ) smoothed Gain = NUM_ ; if ( smoothed Gain > NUM_ ) smoothed Gain = NUM_ ; if ( smoothed Gain > max Gain ) max Gain = smoothed Gain ; gain Hist [ smoothed Gain ] ++ ; } min Gain = NUM_ ; int sum = NUM_ ; while ( min Gain < NUM_ && sum < num Frames / NUM_ ) { sum += gain Hist [ ( int ) min Gain ] ; min Gain ++ ; } sum = NUM_ ; while ( max Gain > NUM_ && sum < num Frames / NUM_ ) { sum += gain Hist [ ( int ) max Gain ] ; max Gain -- ; } range = max Gain - min Gain ; m Num Zoom Levels = NUM_ ; m Len By Zoom Level = new int [ NUM_ ] ; m Zoom Factor By Zoom Level = new float [ NUM_ ] ; float ratio = get Measured Width ( ) / ( float ) num Frames ; if ( ratio < NUM_ ) { m Len By Zoom Level [ NUM_ ] = Math . round ( num Frames * ratio ) ; m Zoom Factor By Zoom Level [ NUM_ ] = ratio ; m Len By Zoom Level [ NUM_ ] = num Frames ; m Zoom Factor By Zoom Level [ NUM_ ] = NUM_ ; m Len By Zoom Level [ NUM_ ] = num Frames * NUM_ ; m Zoom Factor By Zoom Level [ NUM_ ] = NUM_ ; m Len By Zoom Level [ NUM_ ] = num Frames * NUM_ ; m Zoom Factor By Zoom Level [ NUM_ ] = NUM_ ; m Zoom Level = NUM_ ; } else { m Len By Zoom Level [ NUM_ ] = num Frames ; m Zoom Factor By Zoom Level [ NUM_ ] = NUM_ ; m Len By Zoom Level [ NUM_ ] = num Frames * NUM_ ; m Zoom Factor By Zoom Level [ NUM_ ] = NUM_ ; m Len By Zoom Level [ NUM_ ] = num Frames * NUM_ ; m Zoom Factor By Zoom Level [ NUM_ ] = NUM_ ; m Len By Zoom Level [ NUM_ ] = num Frames * NUM_ ; m Zoom Factor By Zoom Level [ NUM_ ] = NUM_ ; m Zoom Level = NUM_ ; for ( int i = NUM_ ; i < NUM_ ; i ++ ) { if ( m Len By Zoom Level [ m Zoom Level ] - get Measured Width ( ) > NUM_ ) { break ; } else { m Zoom Level = i ; } } } m Initialized = true ; }
public static String fake Signature ( String qualified Name ) { String cname = qualified Name . substring ( NUM_ , qualified Name . last Index Of ( STR_ ) ) ; String mname = qualified Name . substring ( qualified Name . last Index Of ( STR_ ) + NUM_ , qualified Name . length ( ) ) ; return STR_ + cname + STR_ + mname + STR_ ; }
void replace ( Document Filter . Filter Bypass fb , int offset , int length , String string , Attribute Set attr ) throws Bad Location Exception { if ( ! get Allows Invalid ( ) && length == NUM_ && string != null && string . length ( ) == NUM_ && toggle Sign If Necessary ( fb , offset , string . char At ( NUM_ ) ) ) { return ; } super . replace ( fb , offset , length , string , attr ) ; }
public Process Drawer ( final Process Renderer Model model , final boolean draw Highlight ) { if ( model == null ) { throw new Illegal Argument Exception ( STR_ ) ; } this . model = model ; this . draw Highlight = draw Highlight ; decorators = new Hash Map < > ( ) ; for ( Render Phase phase : Render Phase . draw Order ( ) ) { decorators . put ( phase , new Copy On Write Array List < Process Draw Decorator > ( ) ) ; } operator Decorators = new Copy On Write Array List < Operator Draw Decorator > ( ) ; }
public void require Loaded ( ) { if ( loaded ) return ; if ( loading thread == null ) throw new Illegal State Exception ( STR_ ) ; try { loading thread . join ( ) ; loaded = true ; } catch ( Interrupted Exception e ) { } }
public void on First Run ( Configuration Context context , Runnable start Runnable ) { start Runnable . run ( ) ; }
public void fatal Error ( Exception e ) { scanner Status = fr . gael . dhus . database . object . File Scanner . STATUS ERROR ; processings Done ( e . get Message ( ) ) ; }
public void register On Shared Preference Change Listener ( On Shared Preference Change Listener listener ) { if ( listener != null ) { register Listener ( listener ) ; } }
@ Override public void on Create ( Bundle icicle ) { super . on Create ( icicle ) ; set Content View ( R . layout . main ) ; File path = Environment . get Data Directory ( ) ; Stat Fs stat = new Stat Fs ( path . get Path ( ) ) ; int total Blocks = stat . get Block Count ( ) ; m Block Size = ( int ) ( stat . get Block Size ( ) ) ; Text View start Size Text View = ( Text View ) find View By Id ( R . id . totalsize ) ; start Size Text View . set Text ( Long . to String ( ( total Blocks * m Block Size ) / BYTE SIZE ) ) ; Button button = ( Button ) find View By Id ( R . id . button run ) ; button . set On Click Listener ( m Start Listener ) ; }
public void query ( boolean only Current Rows , int only Current Days , int max Rows ) { m m Tab . query ( only Current Rows , only Current Days , max Rows ) ; if ( ! is Single Row ( ) ) v Table . auto Size ( true ) ; activate Childs ( ) ; }
public boolean fire Row ( Session session , Row old Row , Row new Row , boolean before Action , boolean rollback ) { if ( ! row Based || before != before Action ) { return false ; } if ( rollback && ! on Rollback ) { return false ; } load ( ) ; Object [ ] old List ; Object [ ] new List ; boolean fire = false ; if ( ( type Mask & Trigger . INSERT ) != NUM_ ) { if ( old Row == null && new Row != null ) { fire = true ; } } if ( ( type Mask & Trigger . UPDATE ) != NUM_ ) { if ( old Row != null && new Row != null ) { fire = true ; } } if ( ( type Mask & Trigger . DELETE ) != NUM_ ) { if ( old Row != null && new Row == null ) { fire = true ; } } if ( ! fire ) { return false ; } old List = convert To Object List ( old Row ) ; new List = convert To Object List ( new Row ) ; Object [ ] new List Backup ; if ( before && new List != null ) { new List Backup = new Object [ new List . length ] ; System . arraycopy ( new List , NUM_ , new List Backup , NUM_ , new List . length ) ; } else { new List Backup = null ; } Connection c 2 = session . create Connection ( false ) ; boolean old = session . get Auto Commit ( ) ; boolean old Disabled = session . set Commit Or Rollback Disabled ( true ) ; Value identity = session . get Last Scope Identity ( ) ; try { session . set Auto Commit ( false ) ; trigger Callback . fire ( c 2 , old List , new List ) ; if ( new List Backup != null ) { for ( int i = NUM_ ; i < new List . length ; i ++ ) { Object o = new List [ i ] ; if ( o != new List Backup [ i ] ) { Value v = Data Type . convert To Value ( session , o , Value . UNKNOWN ) ; new Row . set Value ( i , v ) ; } } } } catch ( Exception e ) { if ( on Rollback ) { } else { throw Db Exception . convert ( e ) ; } } finally { if ( session . get Last Trigger Identity ( ) != null ) { session . set Last Scope Identity ( session . get Last Trigger Identity ( ) ) ; session . set Last Trigger Identity ( null ) ; } else { session . set Last Scope Identity ( identity ) ; } session . set Commit Or Rollback Disabled ( old Disabled ) ; session . set Auto Commit ( old ) ; } return instead Of ; }
public void add Filter Code ( String name , String code ) { this . filter Code = new Source Code ( name , code ) ; new Source Code ( name , code ) ; }
@ Override protected void update ( ) { super . update ( ) ; m Statistics = new Array List < > ( ) ; if ( m Experiment != null ) m Statistics . add All ( m Experiment . get Statistics ( ) ) ; update View ( ) ; }
@ Override public void query Executed ( Query Execute Event evt ) { Result Set Helper helper ; if ( evt . failed ( ) ) { m Info Panel . append ( STR_ + evt . get Query ( ) , STR_ ) ; m Info Panel . append ( STR_ + evt . get Exception ( ) , STR_ ) ; } else { m Info Panel . append ( STR_ + evt . get Query ( ) , STR_ ) ; try { if ( evt . has Result ( ) ) { helper = new Result Set Helper ( evt . get Result Set ( ) ) ; if ( ( evt . get Max Rows ( ) > NUM_ ) && ( helper . get Row Count ( ) >= evt . get Max Rows ( ) ) ) { m Info Panel . append ( helper . get Row Count ( ) + STR_ + evt . get Max Rows ( ) + STR_ , STR_ ) ; } else if ( helper . get Row Count ( ) == - NUM_ ) { m Info Panel . append ( STR_ , STR_ ) ; } else { m Info Panel . append ( helper . get Row Count ( ) + STR_ , STR_ ) ; } } load History ( false ) ; m History . set Property ( Query Panel . MAX ROWS , Integer . to String ( evt . get Max Rows ( ) ) ) ; save History ( ) ; } catch ( Exception e ) { e . print Stack Trace ( ) ; } } }
public boolean mouse Pressed ( Mouse Event e ) { if ( DEBUG ) { Debug . output ( STR_ ) ; } return set Click Interest From Mouse Event ( e ) ; }
public void on Size Changed ( int width , int height ) { m Width = width ; m Height = height ; m View Radius = ( float ) Math . sqrt ( m Width * m Width / NUM_ + m Height * m Height / NUM_ ) ; }
public void error ( Element e , String msg ) { messager . print Message ( Diagnostic . Kind . ERROR , msg , e ) ; }
private void start Block ( int start Token ) { if ( stack Count == unit Stack . length ) { int [ ] new US = new int [ stack Count * NUM_ ] ; System . arraycopy ( unit Stack , NUM_ , new US , NUM_ , stack Count ) ; unit Stack = new US ; } unit Stack [ stack Count ++ ] = start Token ; }
protected Unknown Type . Error Reporter make Model Error Reporter ( String message ) { return new Log Error Runnable ( this , message ) ; }
@ Override public void shutdown ( Shutdown Mode Amp mode ) { for ( int i = service Close List . size ( ) - NUM_ ; i >= NUM_ ; i -- ) { Service Ref Amp service = service Close List . get ( i ) ; service . shutdown ( mode ) ; } }
public void update Progress ( ) { support Invalidate Options Menu ( ) ; }
@ Override public void on Success ( DLSN value ) { if ( value . get Log Segment Sequence No ( ) != current Log Segment Seq No ) { LOG . error ( STR_ , value . get Log Segment Sequence No ( ) , current Log Segment Seq No ) ; errors Found . set ( true ) ; } if ( verify Entry Id && value . get Entry Id ( ) != current Entry Id ) { LOG . error ( STR_ , value . get Entry Id ( ) , current Entry Id ) ; errors Found . set ( true ) ; } sync Latch . count Down ( ) ; }
public void column Removed ( Table Column Model Event e ) { Lime Table Column ltc ; Table Column Model tcm = table . get Column Model ( ) ; for ( int i = NUM_ ; i < tcm . get Column Count ( ) ; i ++ ) { ltc = ( Lime Table Column ) tcm . get Column ( i ) ; set Order ( ltc , i ) ; } Lime Table Column removed Column = table . get Last Removed Column ( ) ; ltc = removed Column ; set Visibility ( ltc , false ) ; int order = get Order ( ltc ) ; for ( Iterator < Lime Table Column > i = table . get Hidden Columns ( ) ; i . has Next ( ) ; ) { ltc = i . next ( ) ; int current = get Order ( ltc ) ; if ( current > order ) set Order ( ltc , current - NUM_ ) ; } if ( listener != null ) listener . column Removed ( removed Column , table ) ; save ( ) ; }
public void unregister Source ( Progress Source pi ) { synchronized ( progress Source List ) { if ( progress Source List . contains ( pi ) == false ) return ; pi . close ( ) ; progress Source List . remove ( pi ) ; } if ( progress Listener List . size ( ) > NUM_ ) { Array List < Progress Listener > listeners = new Array List < Progress Listener > ( ) ; synchronized ( progress Listener List ) { for ( Iterator < Progress Listener > iter = progress Listener List . iterator ( ) ; iter . has Next ( ) ; ) { listeners . add ( iter . next ( ) ) ; } } for ( Iterator < Progress Listener > iter = listeners . iterator ( ) ; iter . has Next ( ) ; ) { Progress Listener pl = iter . next ( ) ; Progress Event pe = new Progress Event ( pi , pi . get URL ( ) , pi . get Method ( ) , pi . get Content Type ( ) , pi . get State ( ) , pi . get Progress ( ) , pi . get Expected ( ) ) ; pl . progress Finish ( pe ) ; } } }
@ Override public void action Performed ( Action Event e ) { Object o ; o = e . get Source ( ) ; if ( o == menu Item Mean ) { calc Mean ( ) ; } else if ( o == menu Item Set All Values ) { set Values ( menu Item Set All Values ) ; } else if ( o == menu Item Set Missing Values ) { set Values ( menu Item Set Missing Values ) ; } else if ( o == menu Item Replace Values ) { set Values ( menu Item Replace Values ) ; } else if ( o == menu Item Rename Attribute ) { rename Attribute ( ) ; } else if ( o == menu Item Attribute As Class ) { attribute As Class ( ) ; } else if ( o == menu Item Delete Attribute ) { delete Attribute ( ) ; } else if ( o == menu Item Delete Attributes ) { delete Attributes ( ) ; } else if ( o == menu Item Delete Selected Instance ) { delete Instance ( ) ; } else if ( o == menu Item Delete All Selected Instances ) { delete Instances ( ) ; } else if ( o == menu Item Insert Instance ) { add Instance ( ) ; } else if ( o == menu Item Sort Instances ) { sort Instances ( ) ; } else if ( o == menu Item Search ) { search ( ) ; } else if ( o == menu Item Clear Search ) { clear Search ( ) ; } else if ( o == menu Item Undo ) { undo ( ) ; } else if ( o == menu Item Copy ) { copy Content ( ) ; } else if ( o == menu Item Optimal Col Width ) { set Optimal Col Width ( ) ; } else if ( o == menu Item Optimal Col Widths ) { set Optimal Col Widths ( ) ; } }
private void on Breakpoints Changed ( ) { final List < Breakpoint > breakpoint List = process . get Current Breakpoint List ( ) ; Swing Utilities . invoke Later ( new Model Setter ( breakpoint List , get Selection ( ) ) ) ; }
public Per File Suite ( Class < ? > klass ) throws Throwable { super ( klass , Collections . < Runner > empty List ( ) ) ; final Test Class test Class = get Test Class ( ) ; final Class < ? > java Test Class = test Class . get Java Class ( ) ; final List < Object [ ] > parameters List = get Parameters List ( test Class ) ; for ( Object [ ] parameters : parameters List ) { runners . add ( new Per Parameter Set Test Runner ( java Test Class , parameters ) ) ; } }
private void write Index File ( ) throws IO Exception , Carbon Data Writer Exception { Index Header index Header = Carbon Metadata Util . get Index Header ( local Cardinality , thrift Column Schema List ) ; List < Block Index > block Index Thrift = Carbon Metadata Util . get Block Index Info ( block Index Info List ) ; String file Name = store Location + File . separator + carbon Table Path . get Carbon Index File Name ( carbon Data File Attributes . get Task Id ( ) , carbon Data File Attributes . get Fact Time Stamp ( ) ) ; Carbon Index File Writer writer = new Carbon Index File Writer ( ) ; writer . open Thrift Writer ( file Name ) ; writer . write Thrift ( index Header ) ; for ( Block Index block Index : block Index Thrift ) { writer . write Thrift ( block Index ) ; } writer . close ( ) ; copy Carbon Data File To Carbon Store Path ( file Name ) ; }
public void on Draw Scroll Bar ( Canvas canvas , int range , int offset , int extent , int alpha ) { float stroke Radius = m Paint . get Stroke Width ( ) / NUM_ ; float extra Angle = NUM_ ; float offset Y = m Offset . y ; if ( offset Y > NUM_ ) { float target Height = m Screen Radius - offset Y - stroke Radius ; double target Radians = - Math . asin ( target Height / m Screen Radius ) ; float target Angle = ( float ) ( NUM_ * target Radians / Math . PI / NUM_ ) ; extra Angle = Math Utils . constrain ( target Angle - START ANGLE , NUM_ , - START ANGLE ) ; } else if ( offset Y < NUM_ ) { float target Height = m Screen Radius + offset Y - stroke Radius ; double target Radians = Math . asin ( target Height / m Screen Radius ) ; float target Angle = ( float ) ( NUM_ * target Radians / Math . PI / NUM_ ) ; extra Angle = Math Utils . constrain ( START ANGLE + SWEEP ANGLE - target Angle , NUM_ , START ANGLE + SWEEP ANGLE ) ; } float start Angle = Math Utils . constrain ( START ANGLE + extra Angle , START ANGLE , NUM_ ) ; float sweep Angle = Math Utils . constrain ( SWEEP ANGLE - NUM_ * extra Angle , NUM_ , SWEEP ANGLE ) ; float min Sweep = MIN SWEEP * sweep Angle / SWEEP ANGLE ; float thumb Sweep = ( extent * sweep Angle ) / range ; thumb Sweep = Math Utils . constrain ( thumb Sweep , min Sweep , sweep Angle ) ; float thumb Rotation = ( sweep Angle - thumb Sweep ) * ( offset ) / ( range - extent ) ; float opacity = alpha / NUM_ ; if ( Design Config . DEBUG SCROLLBAR && offset Y != NUM_ ) { Log . v ( TAG , STR_ + offset Y + STR_ + extra Angle + STR_ + start Angle + STR_ + sweep Angle + STR_ + opacity ) ; } canvas . save ( ) ; canvas . translate ( - m Offset . x , - m Offset . y ) ; if ( m Is Round ) { set Color With Opacity ( m Paint , m Bg Color , opacity ) ; canvas . draw Arc ( m Oval , start Angle , sweep Angle , false , m Paint ) ; set Color With Opacity ( m Paint , m Sweep Color , opacity ) ; canvas . rotate ( thumb Rotation , m Oval . center X ( ) , m Oval . center Y ( ) ) ; canvas . draw Arc ( m Oval , start Angle , thumb Sweep , false , m Paint ) ; } else { float x = m Oval . right ; set Color With Opacity ( m Paint , m Bg Color , opacity ) ; float start Y = get Y ( start Angle , x ) ; float length = get Y ( start Angle + sweep Angle , x ) - start Y ; canvas . draw Line ( x , start Y , x , start Y + length , m Paint ) ; set Color With Opacity ( m Paint , m Sweep Color , opacity ) ; float start = start Y + ( thumb Rotation / sweep Angle ) * length ; float end = start Y + ( ( thumb Rotation + thumb Sweep ) / sweep Angle ) * length ; canvas . draw Line ( x , start , x , end , m Paint ) ; } canvas . restore ( ) ; }
D create Delegate ( ) { return null ; }
protected void on Page Scrolled ( int position , float offset , int offset Pixels ) { if ( m Decor Child Count > NUM_ ) { final int scroll X = get Scroll X ( ) ; int padding Left = get Padding Left ( ) ; int padding Right = get Padding Right ( ) ; final int width = get Width ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( ! lp . is Decor ) continue ; final int hgrav = lp . gravity & Gravity . HORIZONTAL GRAVITY MASK ; int child Left = NUM_ ; switch ( hgrav ) { default : child Left = padding Left ; break ; case Gravity . LEFT : child Left = padding Left ; padding Left += child . get Width ( ) ; break ; case Gravity . CENTER HORIZONTAL : child Left = Math . max ( ( width - child . get Measured Width ( ) ) / NUM_ , padding Left ) ; break ; case Gravity . RIGHT : child Left = width - padding Right - child . get Measured Width ( ) ; padding Right += child . get Measured Width ( ) ; break ; } child Left += scroll X ; final int child Offset = child Left - child . get Left ( ) ; if ( child Offset != NUM_ ) { child . offset Left And Right ( child Offset ) ; } } } for ( On Page Change Listener each Listener : m On Page Change Listeners ) { if ( each Listener != null ) { each Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } } if ( m On Page Change Listener != null ) { m On Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Internal Page Change Listener != null ) { m Internal Page Change Listener . on Page Scrolled ( position , offset , offset Pixels ) ; } if ( m Page Transformer != null ) { final int scroll X = get Scroll X ( ) ; final int child Count = get Child Count ( ) ; for ( int i = NUM_ ; i < child Count ; i ++ ) { final View child = get Child At ( i ) ; final Layout Params lp = ( Layout Params ) child . get Layout Params ( ) ; if ( lp . is Decor ) continue ; final float transform Pos = ( float ) ( child . get Left ( ) - scroll X ) / get Client Width ( ) ; m Page Transformer . transform Page ( child , transform Pos ) ; } } m Called Super = true ; }
public boolean on Running Tick ( Item Stack a Stack ) { if ( m E Ut > NUM_ ) { add Energy Output ( ( ( long ) m E Ut * m Efficiency ) / NUM_ ) ; return true ; } if ( m E Ut < NUM_ ) { if ( ! drain Energy Input ( ( ( long ) - m E Ut * NUM_ ) / Math . max ( NUM_ , m Efficiency ) ) ) { stop Machine ( ) ; return false ; } } return true ; }
private static synchronized void start Event Dispatch Thread If Necessary ( ) { if ( event Dispatch Thread == null ) { event Dispatch Thread = new Event Dispatch Thread ( ) ; event Dispatch Thread . set Daemon ( true ) ; event Dispatch Thread . start ( ) ; } }
@ Override public void control Event ( int event ) { if ( ( event == Wrapper Manager . WRAPPER CTRL LOGOFF EVENT ) && Wrapper Manager . is Launched As Service ( ) ) { if ( logger . is Info Enabled ( ) ) { logger . info ( STR_ + event + STR_ ) ; } } else { if ( logger . is Info Enabled ( ) ) { logger . info ( STR_ + event + STR_ ) ; } Wrapper Manager . stop ( NUM_ ) ; } }
public int increment Reference Count ( ) { return m reference Count . increment And Get ( ) ; }
public boolean on Machine Activated ( World world , int x , int y , int z , Entity Player entity Player , int side , float hit X , float hit Y , float hit Z ) { return false ; }
private void update Home Task List Adapter ( ) { m Home Task List Adapter . notify Data Set Changed ( ) ; m Home Task Count Text View . set Text ( String . value Of ( m Home Task List Adapter . get Item Count ( ) ) ) ; }
public void after Data Flush ( Page Service Impl table Service , int sequence Flush ) { write Sequence Flushed = Math . max ( write Sequence Flushed , sequence Flush ) ; }
private final void write String Segments ( char [ ] cbuf , int offset , int total Len ) throws IO Exception , Json Generation Exception { do { int len = Math . min ( output Max Contiguous , total Len ) ; if ( ( output Tail + len ) > output End ) { flush Buffer ( ) ; } write String Segment ( cbuf , offset , len ) ; offset += len ; total Len -= len ; } while ( total Len > NUM_ ) ; }
public boolean is Out Dated ( ) { return is Out Dated ( true ) ; }
static void force Invalidate Event ( Entry Event Impl event , Local Region owner ) { if ( FORCE INVALIDATE EVENT ) { event . invoke Callbacks ( owner , false , false ) ; } }
@ Call Super public void on View Model Destroyed ( ) { m View = null ; m Ui Thread Task Queue . clear ( ) ; }
public void item State Changed ( Item Event e ) { String p Name = ( String ) e . get Item ( ) ; if ( e . get State Change ( ) == Item Event . SELECTED ) { this . printer Name = p Name ; } }
protected Solr Input Document process ( Solr Input Document doc ) { String doc Lang = null ; Hash Set < String > doc Langs = new Hash Set < > ( ) ; String fallback Lang = get Fallback Lang ( doc , fallback Fields , fallback Value ) ; if ( lang Field == null || ! doc . contains Key ( lang Field ) || ( doc . contains Key ( lang Field ) && overwrite ) ) { String all Text = concat Fields ( doc , input Fields ) ; List < Detected Language > languagelist = detect Language ( all Text ) ; doc Lang = resolve Language ( languagelist , fallback Lang ) ; doc Langs . add ( doc Lang ) ; log . debug ( STR_ + input Fields + STR_ + doc Lang ) ; if ( doc . contains Key ( lang Field ) && overwrite ) { log . debug ( STR_ + doc . get Field Value ( lang Field ) ) ; } if ( lang Field != null && lang Field . length ( ) != NUM_ ) { doc . set Field ( lang Field , doc Lang ) ; } } else { doc Lang = resolve Language ( ( String ) doc . get Field Value ( lang Field ) , fallback Lang ) ; doc Langs . add ( doc Lang ) ; log . debug ( STR_ + lang Field + STR_ + doc Lang + STR_ ) ; } if ( enable Mapping ) { for ( String field Name : all Map Fields Set ) { if ( doc . contains Key ( field Name ) ) { String field Lang ; if ( map Individual && map Individual Fields Set . contains ( field Name ) ) { String text = ( String ) doc . get Field Value ( field Name ) ; List < Detected Language > languagelist = detect Language ( text ) ; field Lang = resolve Language ( languagelist , doc Lang ) ; doc Langs . add ( field Lang ) ; log . debug ( STR_ + field Name + STR_ + field Lang ) ; } else { field Lang = doc Lang ; log . debug ( STR_ + field Name + STR_ + field Lang ) ; } String mapped Output Field = get Mapped Field ( field Name , field Lang ) ; if ( mapped Output Field != null ) { log . debug ( STR_ , doc . get Field Value ( doc Id Field ) , field Lang ) ; Solr Input Field in Field = doc . get Field ( field Name ) ; doc . set Field ( mapped Output Field , in Field . get Value ( ) , in Field . get Boost ( ) ) ; if ( ! map Keep Orig ) { log . debug ( STR_ , field Name ) ; doc . remove Field ( field Name ) ; } } else { throw new Solr Exception ( Solr Exception . Error Code . BAD REQUEST , STR_ + field Name + STR_ + field Lang ) ; } } } } if ( langs Field != null && langs Field . length ( ) != NUM_ ) { doc . set Field ( langs Field , doc Langs . to Array ( ) ) ; } return doc ; }
public void member Left ( Client Membership Event event ) { Notification notification = new Notification ( JMX Notification Type . CLIENT LEFT , server Source , Sequence Number . next ( ) , System . current Time Millis ( ) , Management Constants . CLIENT LEFT PREFIX + event . get Member Id ( ) ) ; server Level Notif Emitter . send Notification ( notification ) ; member Level Notif Emitter . send Notification ( notification ) ; }
public void on Item Changed ( int item Id ) { if ( m Block Updates || m Presenter == null ) return ; int old Pos = get Adapter Pos For Id ( item Id ) ; prepare Menu Items ( ) ; int new Pos = get Adapter Pos For Id ( item Id ) ; if ( old Pos == - NUM_ && new Pos == - NUM_ ) { return ; } if ( old Pos == - NUM_ ) { m Presenter . report Change ( new Change ( Change . Change Type . ITEM INSERTED , new Pos , - NUM_ , - NUM_ , - NUM_ ) , m Adapter Data ) ; } else if ( new Pos == - NUM_ ) { m Presenter . report Change ( new Change ( Change . Change Type . ITEM REMOVED , old Pos , - NUM_ , - NUM_ , - NUM_ ) , m Adapter Data ) ; } else if ( old Pos == new Pos ) { m Presenter . report Change ( new Change ( Change . Change Type . ITEM CHANGED , new Pos , - NUM_ , - NUM_ , - NUM_ ) , m Adapter Data ) ; } else { m Presenter . report Change ( new Change ( Change . Change Type . ITEM MOVED , - NUM_ , old Pos , new Pos , - NUM_ ) , m Adapter Data ) ; } }
protected void run TLC Pre Loop ( ) { this . done = false ; }
@ Override protected void after Execute ( Runnable r , Throwable t ) { super . after Execute ( r , t ) ; synchronized ( this ) { tasks In Process . decrement And Get ( ) ; if ( tasks In Process . int Value ( ) == NUM_ ) { synchronizer . signal All ( ) ; } } }
private void assign Node Tags ( final Map < I Node , Tag > chatters ) { for ( final I Node node : chatters . key Set ( ) ) { final Tag tag = chatters . get ( node ) ; add To Notes Map ( node , tag ) ; } }
private void update ( ) { data Control . set First Row ( NUM_ ) ; data Control . set Last Row ( Math . min ( data Control . get Max Rows ( ) , get Default Maximum Number ( STR_ , data Control . get Max Rows ( ) ) ) ) ; data Control . set First Column ( NUM_ ) ; data Control . set Last Column ( Math . min ( data Control . get Max Columns ( ) , get Default Maximum Number ( STR_ , data Control . get Max Columns ( ) ) ) ) ; data Control . update ( ) ; }
public void going To Execute Unsafe Code On Same Thread ( ) throws Security Exception , Illegal State Exception { if ( ! privileged Threads . contains ( Thread . current Thread ( ) ) ) { throw new Security Exception ( STR_ ) ; } if ( privileged Thread To Ignore != null ) { throw new Illegal State Exception ( STR_ ) ; } privileged Thread To Ignore = Thread . current Thread ( ) ; }
public Overloaded Checksum ( Krb 5 Context context , Checksum checksum , Encryption Key key , Encryption Key sub Key ) throws GSS Exception , Krb Exception , IO Exception { int pos = NUM_ ; if ( checksum == null ) { GSS Exception ge = new GSS Exception ( GSS Exception . FAILURE , - NUM_ , STR_ ) ; ge . init Cause ( new Krb Exception ( Krb 5 . KRB AP ERR INAPP CKSUM ) ) ; throw ge ; } checksum Bytes = checksum . get Bytes ( ) ; if ( ( checksum Bytes [ NUM_ ] != CHECKSUM FIRST BYTES [ NUM_ ] ) || ( checksum Bytes [ NUM_ ] != CHECKSUM FIRST BYTES [ NUM_ ] ) || ( checksum Bytes [ NUM_ ] != CHECKSUM FIRST BYTES [ NUM_ ] ) || ( checksum Bytes [ NUM_ ] != CHECKSUM FIRST BYTES [ NUM_ ] ) ) { throw new GSS Exception ( GSS Exception . FAILURE , - NUM_ , STR_ ) ; } Channel Binding local Bindings = context . get Channel Binding ( ) ; if ( local Bindings != null ) { byte [ ] remote Binding Bytes = new byte [ CHECKSUM BINDINGS SIZE ] ; System . arraycopy ( checksum Bytes , NUM_ , remote Binding Bytes , NUM_ , CHECKSUM BINDINGS SIZE ) ; byte [ ] no Bindings = new byte [ CHECKSUM BINDINGS SIZE ] ; if ( ! Arrays . equals ( no Bindings , remote Binding Bytes ) ) { byte [ ] local Bindings Bytes = compute Channel Binding ( local Bindings ) ; if ( ! Arrays . equals ( local Bindings Bytes , remote Binding Bytes ) ) { throw new GSS Exception ( GSS Exception . BAD BINDINGS , - NUM_ , STR_ ) ; } } else { throw new GSS Exception ( GSS Exception . BAD BINDINGS , - NUM_ , STR_ ) ; } } flags = read Little Endian ( checksum Bytes , NUM_ , NUM_ ) ; if ( ( flags & CHECKSUM DELEG FLAG ) > NUM_ ) { int cred Len = read Little Endian ( checksum Bytes , NUM_ , NUM_ ) ; byte [ ] cred Bytes = new byte [ cred Len ] ; System . arraycopy ( checksum Bytes , NUM_ , cred Bytes , NUM_ , cred Len ) ; Krb Cred cred ; try { cred = new Krb Cred ( cred Bytes , key ) ; } catch ( Krb Exception ke ) { if ( sub Key != null ) { cred = new Krb Cred ( cred Bytes , sub Key ) ; } else { throw ke ; } } deleg Creds = cred . get Delegated Creds ( ) [ NUM_ ] ; } }
public void changed Cell ( DF Lattice Cell cell ) { Iterator < DF Equation > e = cell . get Uses ( ) ; while ( e . has Next ( ) ) { new Equations . add ( e . next ( ) ) ; } }
public void removed ( java . awt . Container cont ) { if ( auto Timer ) { timer . stop ( ) ; update Timer Button ( ) ; } }
